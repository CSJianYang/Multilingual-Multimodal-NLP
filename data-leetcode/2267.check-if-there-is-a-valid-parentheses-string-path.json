[
    {
        "title": "Encrypt and Decrypt Strings",
        "question_content": "You are given a character array keys containing unique characters and a string array values containing strings of length 2. You are also given another string array dictionary that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a 0-indexed string.\nA string is encrypted with the following process:\n\n\tFor each character c in the string, we find the index i satisfying keys[i] == c in keys.\n\tReplace c with values[i] in the string.\n\nNote that in case a character of the string is not present in keys, the encryption process cannot be carried out, and an empty string \"\" is returned.\nA string is decrypted with the following process:\n\n\tFor each substring s of length 2 occurring at an even index in the string, we find an i such that values[i] == s. If there are multiple valid i, we choose any one of them. This means a string could have multiple possible strings it can decrypt to.\n\tReplace s with keys[i] in the string.\n\nImplement the Encrypter class:\n\n\tEncrypter(char[] keys, String[] values, String[] dictionary) Initializes the Encrypter class with keys, values, and dictionary.\n\tString encrypt(String word1) Encrypts word1 with the encryption process described above and returns the encrypted string.\n\tint decrypt(String word2) Returns the number of possible strings word2 could decrypt to that also appear in dictionary.\n\n&nbsp;\nExample 1:\n\nInput\n[\"Encrypter\", \"encrypt\", \"decrypt\"]\n[[['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]], [\"abcd\"], [\"eizfeiam\"]]\nOutput\n[null, \"eizfeiam\", 2]\nExplanation\nEncrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]);\nencrypter.encrypt(\"abcd\"); // return \"eizfeiam\". \n&nbsp;                          // 'a' maps to \"ei\", 'b' maps to \"zf\", 'c' maps to \"ei\", and 'd' maps to \"am\".\nencrypter.decrypt(\"eizfeiam\"); // return 2. \n                              // \"ei\" can map to 'a' or 'c', \"zf\" maps to 'b', and \"am\" maps to 'd'. \n                              // Thus, the possible strings after decryption are \"abad\", \"cbad\", \"abcd\", and \"cbcd\". \n                              // 2 of those strings, \"abad\" and \"abcd\", appear in dictionary, so the answer is 2.\n\n&nbsp;\nConstraints:\n\n\t1 <= keys.length == values.length <= 26\n\tvalues[i].length == 2\n\t1 <= dictionary.length <= 100\n\t1 <= dictionary[i].length <= 100\n\tAll keys[i] and dictionary[i] are unique.\n\t1 <= word1.length <= 2000\n\t1 <= word2.length <= 200\n\tAll word1[i] appear in keys.\n\tword2.length is even.\n\tkeys, values[i], dictionary[i], word1, and word2 only contain lowercase English letters.\n\tAt most 200 calls will be made to encrypt and decrypt in total.",
        "solutions": [
            {
                "id": 1909025,
                "title": "java-c-python-two-hashmaps-with-explanation",
                "content": "# **Explanation**\\nThe hashmap `enc` help binding each paire of `keys[i]` and `values[i]`,\\nso that we can encrypt a char to the string in `O(1)`\\n\\n`count` counts the frequency of words in `dictionary` after `encrypt`,\\nthen we can used in `decrypt` in `O(1)`.\\n<br>\\n\\n# **Complexity**\\n`Encrypter`  Time `O(n)`      Space `O(n)`\\n`encrypt`    Time `O(word1)`  Space `O(word1)`\\n`decrypt`    Time `O(1)`      Space `O(1)`\\n<br>\\n\\n# **Note**\\nNot all word can be \"encrypt\", \\nFor character `c`, if we can\\'t find the index `i` satisfying `keys[i] == c` in keys.\\nThe behavior are **NOT** clearly defined.\\n\\nIn my opinion we should do nothing but keep the original character, \\n(the standard solution of OJ doesn\\'t work as I suggest)\\n\\nThese kind of test cases are not present in the original test cases set,\\nbut recedntly blindly added to the test cases.\\n\\nThe descrption of probelm should be fixed, not blindly add an appropriat test cases.\\n\\nIt\\'s like, a bug is reported and not guarded by tests, \\nthen LC adds a test but not fix anything at all.\\n\\n\\n**Java**\\n```java\\n    Map<Character, String> enc;\\n    Map<String, Integer> count;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        enc = new HashMap<>();\\n        for (int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        count = new HashMap<>();\\n        for (String w : dictionary) {\\n            String e = encrypt(w);\\n            count.put(e, count.getOrDefault(e, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < word1.length(); ++i)\\n            res.append(enc.getOrDefault(word1.charAt(i), \"#\"));\\n        return res.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return count.getOrDefault(word2, 0);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n```\\n\\n**Python**\\n3-lines Python.\\n`decrypt` method is not missing, `defined` in `init`\\nI remoded unnecessay code from default template.\\n```py\\nclass Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n        self.enc = {k: v for k,v in zip(keys, values)}\\n        self.decrypt = collections.Counter(self.encrypt(w) for w in dictionary).__getitem__\\n\\n    def encrypt(self, word1):\\n        return \\'\\'.join(self.enc.get(c, \\'#\\') for c in word1)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    Map<Character, String> enc;\\n    Map<String, Integer> count;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        enc = new HashMap<>();\\n        for (int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        count = new HashMap<>();\\n        for (String w : dictionary) {\\n            String e = encrypt(w);\\n            count.put(e, count.getOrDefault(e, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < word1.length(); ++i)\\n            res.append(enc.getOrDefault(word1.charAt(i), \"#\"));\\n        return res.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return count.getOrDefault(word2, 0);\\n    }\\n```\n```cpp\\n    unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n```\n```py\\nclass Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n        self.enc = {k: v for k,v in zip(keys, values)}\\n        self.decrypt = collections.Counter(self.encrypt(w) for w in dictionary).__getitem__\\n\\n    def encrypt(self, word1):\\n        return \\'\\'.join(self.enc.get(c, \\'#\\') for c in word1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908722,
                "title": "easy-understanding-c-code-with-comments-without-tries",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            dict[encrypt(d[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string ans = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()) return \"\";\\n            ans += m[s[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```\\n**Upvote if it helps!\\uD83D\\uDE4C**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            dict[encrypt(d[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string ans = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()) return \"\";\\n            ans += m[s[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908714,
                "title": "c-simple-solution-w-explanation-hashmap-trie-dfs-hashmap-preprocess",
                "content": "\\n\\u2714\\uFE0F ***Solution - I  (Hashmap + Trie)***\\n\\nWe are given an array of characters `K`, an array of strings `V` and another array of strings `D`.\\nA string `W` is encrypted by replacing each character `c`, found at `K[i]` with `V[i]` (only single possible index `i`).\\nA string `W` is decrypted by replacing every 2-character substring `s`, found at `V[i]` with `K[i]` for all possible `i`. This decrypted value must be present in `D`.\\n\\n**Encryption:**\\n* The encryption process is straight-forward wherein for every character `c` in given word `W`, we need to find  `c`\\'s index `i` in `K` & replace it with corresponding string in `V`, i.e `V[i]`. \\n* For this, we can use a hashmap `K_V` to keep mapping between each key and value.\\n\\n**Decryption:**\\n* For decryption, there can be multiple choices for replacement of a substring of length 2 and we need to consider each of them to find count of possible decryptions. \\n* But for efficient decryption process, we need to eliminate a choice as soon as we know that it wont be found in `D`. \\n* For this, we can maintain Trie consisting of all strings from `D` & we stop further exploration as soon as we find that current choice wont lead to a string present in the trie.\\n* We also keep a hashmap `V_Ks` to map a value in `V` to all possible keys in `K`.\\n\\n**C++**\\n```cpp\\nclass Trie {\\npublic:    \\n    Trie* chars[26]{};\\n    bool endsHere = false;\\n    void insert(string& s) {\\n        auto cur = this;\\n        for(auto c : s) \\n            cur = cur -> chars[c-\\'a\\'] ? cur -> chars[c-\\'a\\'] : cur -> chars[c-\\'a\\'] = new Trie();\\n        cur -> endsHere = true;\\n    }\\n};\\n\\nclass Encrypter {\\n    Trie* t = new Trie();                      // Trie of dictionary strings\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, vector<char>> V_Ks;  // value : [key]\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) \\n            K_V[K[i]] = V[i], \\n            V_Ks[V[i]].push_back(K[i]);\\n        for(auto& d : D) t -> insert(d);\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return dfs(W, t);\\n    }\\n    int dfs(string& W, Trie* T, int i = 0) {\\n        if(i == size(W)) return T -> endsHere;\\n        int ans = 0;\\n        for(string s = W.substr(i, 2); auto c : V_Ks[s]) \\n            if(T -> chars[c-\\'a\\']) \\n                ans += dfs(W, T -> chars[c-\\'a\\'], i+2);\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II  (Hashmap + Pre-process)***\\n\\nWe can also preprocess and keep all possible encrypted strings that can be obtained by encrypting strings in `D`. Then we can directly return the count of strings which could lead to a given encrypted string `W`.\\n\\n**C++**\\n```cpp\\nclass Encrypter {\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, int> mp;             // encrypted string : count\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) K_V[K[i]] = V[i];\\n        for(auto& d : D) mp[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return mp[W];\\n    }\\n};\\n```\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Trie {\\npublic:    \\n    Trie* chars[26]{};\\n    bool endsHere = false;\\n    void insert(string& s) {\\n        auto cur = this;\\n        for(auto c : s) \\n            cur = cur -> chars[c-\\'a\\'] ? cur -> chars[c-\\'a\\'] : cur -> chars[c-\\'a\\'] = new Trie();\\n        cur -> endsHere = true;\\n    }\\n};\\n\\nclass Encrypter {\\n    Trie* t = new Trie();                      // Trie of dictionary strings\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, vector<char>> V_Ks;  // value : [key]\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) \\n            K_V[K[i]] = V[i], \\n            V_Ks[V[i]].push_back(K[i]);\\n        for(auto& d : D) t -> insert(d);\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return dfs(W, t);\\n    }\\n    int dfs(string& W, Trie* T, int i = 0) {\\n        if(i == size(W)) return T -> endsHere;\\n        int ans = 0;\\n        for(string s = W.substr(i, 2); auto c : V_Ks[s]) \\n            if(T -> chars[c-\\'a\\']) \\n                ans += dfs(W, T -> chars[c-\\'a\\'], i+2);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Encrypter {\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, int> mp;             // encrypted string : count\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) K_V[K[i]] = V[i];\\n        for(auto& d : D) mp[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return mp[W];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908702,
                "title": "encrypted-dictionary-vs-trie",
                "content": "#### Approach 1: Encrypted Dictionary\\nI did not see this, but it makes sense. If we encrypt all words in the dictionary, some of those words may have the same encrypted representation.\\n\\nWe could store the number of dictionary words for each encrypted representation in hash map `m`, and return this count in the `decrypt` function.\\n\\n**C++**\\n```cpp\\nclass Encrypter {\\n    unordered_map<char, string> ch2s;    \\n    unordered_map<string, int> m;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            ch2s[keys[i]] = values[i];\\n        for (auto &s : dictionary)\\n            ++m[encrypt(s)];\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return m[word2]; }\\n};\\n```\\n\\n#### Approach 2: Trie\\nWe need to pay attention to the `decrypt` function. If we check for a valid word in the end, we will get TLE.\\n    \\nTherefore, we need to use Trie so we can prune invalid words as we go.\\n    \\n**C++**\\n```cpp\\nint val2int(char a, char b) { return (a - \\'a\\') * 26 + b - \\'a\\'; }\\nstruct trie {\\n    trie* ch[26] = {};\\n    bool end = false;\\n    void insert(string &w, int i = 0) {\\n        if (i == w.size())\\n            end = true;\\n        else {\\n            auto *p = ch[w[i] - \\'a\\'];\\n            if (p == nullptr)\\n                p = ch[w[i] - \\'a\\'] = new trie();\\n            p->insert(w, i + 1);\\n        }\\n    }\\n    int count(string &w, unordered_map<int, vector<char>> &s2ch, int i = 0) {\\n        if (i == w.size())\\n            return end;\\n        int res = 0, v = val2int(w[i], w[i + 1]);\\n        for (auto k : s2ch[v])\\n            if (ch[k - \\'a\\'] != nullptr)\\n                res += ch[k - \\'a\\']->count(w, s2ch, i + 2);\\n        return res;\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<int, vector<char>> s2ch;\\n    unordered_map<char, string> ch2s;    \\n    trie root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            s2ch[val2int(values[i][0], values[i][1])].push_back(keys[i]);\\n            ch2s[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary)\\n            root.insert(s);\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return root.count(word2, s2ch); }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Encrypter {\\n    unordered_map<char, string> ch2s;    \\n    unordered_map<string, int> m;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            ch2s[keys[i]] = values[i];\\n        for (auto &s : dictionary)\\n            ++m[encrypt(s)];\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return m[word2]; }\\n};\\n```\n```cpp\\nint val2int(char a, char b) { return (a - \\'a\\') * 26 + b - \\'a\\'; }\\nstruct trie {\\n    trie* ch[26] = {};\\n    bool end = false;\\n    void insert(string &w, int i = 0) {\\n        if (i == w.size())\\n            end = true;\\n        else {\\n            auto *p = ch[w[i] - \\'a\\'];\\n            if (p == nullptr)\\n                p = ch[w[i] - \\'a\\'] = new trie();\\n            p->insert(w, i + 1);\\n        }\\n    }\\n    int count(string &w, unordered_map<int, vector<char>> &s2ch, int i = 0) {\\n        if (i == w.size())\\n            return end;\\n        int res = 0, v = val2int(w[i], w[i + 1]);\\n        for (auto k : s2ch[v])\\n            if (ch[k - \\'a\\'] != nullptr)\\n                res += ch[k - \\'a\\']->count(w, s2ch, i + 2);\\n        return res;\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<int, vector<char>> s2ch;\\n    unordered_map<char, string> ch2s;    \\n    trie root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            s2ch[val2int(values[i][0], values[i][1])].push_back(keys[i]);\\n            ch2s[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary)\\n            root.insert(s);\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return root.count(word2, s2ch); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908833,
                "title": "python-hashmap-counter-solution-with-detailed-explanations-very-clean-concise",
                "content": "This is the first time I get AK over the past few months. I would like to share my solution with the LC community.\\n\\n**Intuition**\\nThe given constraints are not large, we can pre-compute all necessary quantities only once.\\n\\n\\n**Explanation**\\nWe can pre-compute two hashmaps as follows:\\n\\n(1) The first hashmap `self.hashmap` is a encryption map - we map each key with their encrypted values, which is straightforward.\\n(2) The second hashmap `self.dictmap` is a `Counter` - we encrypt each word in the given `dictionary` and use the encrypted string as the key and increase the counter by 1. As such, we have solved the duplication problem of the `decrypt()` method.\\n\\n**Complexity**\\nTime in `__init__()`: `O(sum(dictionary[i].length))`, which gets amortized over later function calls\\nSpace in `__init__()`: `O(dictionary.length)`\\nTime in `encrypt()`: `O(word1.length)`\\nSpace in `encrypt()`: `O(1)` (if not counting the `output` string)\\nTime in `decrypt()`: `O(1)`\\nSpace in `decrypt()`: `O(1)`\\n\\n\\nBelow is my in-contest solution. Please upvote if you find this solution helpful. Thanks!\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```\\n\\n**Follow up** (for self-learning purpose): The `encrypt()` method can be written as follows to handle more general test cases (given in the Comments section).\\n```\\ndef encrypt(self, word1: str) -> str:\\n    output = \\'\\'\\n    for char in word1:\\n        if char in self.hashmap:\\n            output += self.hashmap[char]\\n        else:\\n            return \\'\\'\\n    return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```\n```\\ndef encrypt(self, word1: str) -> str:\\n    output = \\'\\'\\n    for char in word1:\\n        if char in self.hashmap:\\n            output += self.hashmap[char]\\n        else:\\n            return \\'\\'\\n    return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908706,
                "title": "c-maps-fastest",
                "content": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908902,
                "title": "python-very-simple-code",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.enc = dict()\\n        self.n = len(keys)        \\n        \\n        for i in range(self.n):\\n            self.enc[keys[i]] = values[i]\\n        \\n        self.dict = dictionary\\n            \\n    def encrypt(self, word1: str) -> str:\\n        es = \\'\\'\\n        for w in word1:\\n            es += self.enc[w]\\n        return es\\n\\n    def decrypt(self, word2: str) -> int:\\n        ans = 0 \\n        for w in self.dict:\\n            if self.encrypt(w) == word2:\\n                ans += 1\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.enc = dict()\\n        self.n = len(keys)        \\n        \\n        for i in range(self.n):\\n            self.enc[keys[i]] = values[i]\\n        \\n        self.dict = dictionary\\n            \\n    def encrypt(self, word1: str) -> str:\\n        es = \\'\\'\\n        for w in word1:\\n            es += self.enc[w]\\n        return es\\n\\n    def decrypt(self, word2: str) -> int:\\n        ans = 0 \\n        for w in self.dict:\\n            if self.encrypt(w) == word2:\\n                ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908891,
                "title": "java-solution-with-description-pre-process-dictionary-o-1-decrypt",
                "content": "**Approach**: \\nWhenever decrypt(word) is called decrypt the word. However `values` contains duplicates and it will match to different keys and our descrypt can have many answers. \\nSo, total number of combinations you can achieve is really high and checking every value to dictionary is not a feasible solution.\\n\\nTo overcome that instead of processing word in decrypt(word), pre-process all values in dictionary before. As given there are at most 100 words in dictionary so, encrypt that. As any encryption can lead to same string, store the count of each encryption. This way whenever decrypt is called, just seach that string in our Map and return the count.\\n\\n**Time complexity**:\\n\\nEncrypt: O(n), n: length of word\\nDecrypt: O(1)\\nClass define Encrypter : O(n*m), where n: length of longest word in dictionary, m = dictionary.length\\n\\n**Upvote if it helps. Thanks :)**\\n\\n```\\nclass Encrypter {\\n    \\n    Map<String, Integer> encryptedDictCount;\\n    int[] keys;\\n    Set<String> dictionary;\\n    String[] val;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = new int[26];\\n        encryptedDictCount = new HashMap<>();\\n        this.val = values.clone();\\n        this.dictionary = new HashSet<>(Arrays.asList(dictionary));\\n        \\n        for(int i=0; i<keys.length; i++) {\\n            this.keys[keys[i] - \\'a\\'] = i;\\n        }\\n        \\n        for(String dict : dictionary) {\\n            String encrpted = encrypt(dict);\\n            encryptedDictCount.put(encrpted, encryptedDictCount.getOrDefault(encrpted, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i < word1.length(); i++) {\\n            int c = word1.charAt(i) - \\'a\\';\\n            sb.append(val[keys[c]]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encryptedDictCount.getOrDefault(word2, 0);\\n    }\\n}\\n\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    \\n    Map<String, Integer> encryptedDictCount;\\n    int[] keys;\\n    Set<String> dictionary;\\n    String[] val;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = new int[26];\\n        encryptedDictCount = new HashMap<>();\\n        this.val = values.clone();\\n        this.dictionary = new HashSet<>(Arrays.asList(dictionary));\\n        \\n        for(int i=0; i<keys.length; i++) {\\n            this.keys[keys[i] - \\'a\\'] = i;\\n        }\\n        \\n        for(String dict : dictionary) {\\n            String encrpted = encrypt(dict);\\n            encryptedDictCount.put(encrpted, encryptedDictCount.getOrDefault(encrpted, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i < word1.length(); i++) {\\n            int c = word1.charAt(i) - \\'a\\';\\n            sb.append(val[keys[c]]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encryptedDictCount.getOrDefault(word2, 0);\\n    }\\n}\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2778107,
                "title": "java-solutions",
                "content": "```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908980,
                "title": "java-trie-map-with-trie-node-class-implementation",
                "content": "The approach is to first encrypt the words of the dictionary and store them in a trie with a count of each words.\\nNext, what\\'s left is just traversing over the trie with decrypted word to get the count.\\n**Please upvote if you got the solution.**\\n```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```\\nQueries and discussions regarding the implementation are most welcome.",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908851,
                "title": "c-short-hash-map",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n## Solution 1. Hash Map\\n\\n`encrypt` is straightforward. For `decrypt`, we can precompute ans store the frequencies of encrypted permitted value strings in a map `freq`, and return `freq[word]` in `decrypt`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/encrypt-and-decrypt-strings/\\n// Author: github.com/lzl124631x\\n// Time:\\n//      Encrypter: O(K + V + D) where `K` is the length of `keys`, `V` and `D` are the sizes of all the contents in `values` and `dict`, respectively.\\n//      encrypt: O(W) where `W` is the length of the input word\\n//      decrypt: O(W)\\n// Space: O(K + V + D)\\nclass Encrypter {\\n    unordered_map<char, string> m; // mapping from character keys to corresponding value strings\\n    unordered_map<string, int> freq; // frequency map of encrypted permitted original strings\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            m[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary) {\\n            auto e = encrypt(s);\\n            if (e.size()) freq[e]++;\\n        }\\n    }\\n    string encrypt(string s) {\\n        string ans;\\n        for (char c : s) {\\n            if (m.count(c) == 0) return \"\"; // invalid key character met, return empty string.\\n            ans += m[c];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string s) {\\n        return freq.count(s) ? freq[s] : 0;\\n    }\\n};\\n```\\n\\nThe problem didn\\'t say clearly whether a permitted original string might include unsupported keys. If it might include, then we need to consider the following testcase:\\n\\n```\\n[\"Encrypter\",\"decrypt\"]\\n[[[\"a\"],[\"pq\"],[\"a\",\"ax\"]],[\"pq\"]]\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/encrypt-and-decrypt-strings/\\n// Author: github.com/lzl124631x\\n// Time:\\n//      Encrypter: O(K + V + D) where `K` is the length of `keys`, `V` and `D` are the sizes of all the contents in `values` and `dict`, respectively.\\n//      encrypt: O(W) where `W` is the length of the input word\\n//      decrypt: O(W)\\n// Space: O(K + V + D)\\nclass Encrypter {\\n    unordered_map<char, string> m; // mapping from character keys to corresponding value strings\\n    unordered_map<string, int> freq; // frequency map of encrypted permitted original strings\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            m[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary) {\\n            auto e = encrypt(s);\\n            if (e.size()) freq[e]++;\\n        }\\n    }\\n    string encrypt(string s) {\\n        string ans;\\n        for (char c : s) {\\n            if (m.count(c) == 0) return \"\"; // invalid key character met, return empty string.\\n            ans += m[c];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string s) {\\n        return freq.count(s) ? freq[s] : 0;\\n    }\\n};\\n```\n```\\n[\"Encrypter\",\"decrypt\"]\\n[[[\"a\"],[\"pq\"],[\"a\",\"ax\"]],[\"pq\"]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979556,
                "title": "java-c-python-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***C++***\\n```class Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            string p = encrypt(d[i]);\\n            dict[p]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string p = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()){\\n                return \"\";\\n            }\\n            p += m[s[i]];\\n        }\\n        return p;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```\\n\\n***Java***\\n```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```\\n\\n***Python***\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```class Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            string p = encrypt(d[i]);\\n            dict[p]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string p = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()){\\n                return \"\";\\n            }\\n            p += m[s[i]];\\n        }\\n        return p;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```\n```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961804,
                "title": "python3-hash-table-freq-table",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/f2b4a5c0268eb27201b136764bb0b6ad3880c6f6) for solutions of weekly 287.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mp = dict(zip(keys, values))\\n        self.freq = Counter(map(self.encrypt, dictionary))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.mp.get(ch, \"##\") for ch in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.freq[word2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mp = dict(zip(keys, values))\\n        self.freq = Counter(map(self.encrypt, dictionary))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.mp.get(ch, \"##\") for ch in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.freq[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909284,
                "title": "c-hashmap-based-solution-why-is-this-problem-marked-as-hard",
                "content": "```\\nclass Encrypter {\\npublic:\\n    map<string, int> cnt;\\n    map<char, string> kv;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        \\n        for(int i=0; i<keys.size(); i++)\\n            kv[keys[i]]=values[i];\\n        \\n        for(auto d : dict)\\n            cnt[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encp;\\n        for(auto c : word1)\\n            encp+=kv[c];\\n        return encp;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt[word2];\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<string, int> cnt;\\n    map<char, string> kv;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        \\n        for(int i=0; i<keys.size(); i++)\\n            kv[keys[i]]=values[i];\\n        \\n        for(auto d : dict)\\n            cnt[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encp;\\n        for(auto c : word1)\\n            encp+=kv[c];\\n        return encp;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt[word2];\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1909054,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_set<string> dict;\\n    unordered_map<char,string> en;\\n    unordered_map<string,vector<char>> dy;\\n   \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& t:dictionary)\\n         {   dict.insert(t);}\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            char c=keys[i];\\n            string s=values[i];\\n            en[c]=s;\\n            dy[s].push_back(c);\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(char c:word1)\\n        {\\n            ans+=en[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int cnt=0;\\n        for(auto t:dict)\\n        {\\n            string ans=\"\";\\n            for(int i=0;i<t.size();i++)\\n            {\\n                ans+=en[t[i]];\\n            }\\n            if(ans==word2)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_set<string> dict;\\n    unordered_map<char,string> en;\\n    unordered_map<string,vector<char>> dy;\\n   \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& t:dictionary)\\n         {   dict.insert(t);}\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            char c=keys[i];\\n            string s=values[i];\\n            en[c]=s;\\n            dy[s].push_back(c);\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(char c:word1)\\n        {\\n            ans+=en[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int cnt=0;\\n        for(auto t:dict)\\n        {\\n            string ans=\"\";\\n            for(int i=0;i<t.size();i++)\\n            {\\n                ans+=en[t[i]];\\n            }\\n            if(ans==word2)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908746,
                "title": "java-solution-using-hashmaps",
                "content": "```\\nclass Encrypter {\\n    Map<Character, String> map;\\n    Map<String, Integer> counts;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        map = new HashMap<>();\\n        counts = new HashMap<>();\\n        \\n        for (int i = 0; i < keys.length; i++) {\\n            map.put(keys[i], values[i]);\\n        }\\n        \\n        for (int i = 0; i < dictionary.length; i++) {\\n            String dictionaryResult = encrypt(dictionary[i]);\\n            counts.put(dictionaryResult, counts.getOrDefault(dictionaryResult, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String result = \"\";\\n        \\n        for (int i = 0; i < word1.length(); i++) {\\n            char c = word1.charAt(i);\\n            result = result + map.get(c);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return counts.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character, String> map;\\n    Map<String, Integer> counts;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        map = new HashMap<>();\\n        counts = new HashMap<>();\\n        \\n        for (int i = 0; i < keys.length; i++) {\\n            map.put(keys[i], values[i]);\\n        }\\n        \\n        for (int i = 0; i < dictionary.length; i++) {\\n            String dictionaryResult = encrypt(dictionary[i]);\\n            counts.put(dictionaryResult, counts.getOrDefault(dictionaryResult, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String result = \"\";\\n        \\n        for (int i = 0; i < word1.length(); i++) {\\n            char c = word1.charAt(i);\\n            result = result + map.get(c);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return counts.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908740,
                "title": "python-trie-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python] \\uD83C\\uDF1F Trie Solution and Explanation \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Main Idea:\\n* key2Value:  It is a **one to one map** from key to value, so we could just creat a key2Value hashMap easily\\n* value2Key: It is a **one to many map** from value back to keys, so we use defaultdict(list) to store all keys\\n* trieDict: We build our dictionary in a trie, beacuse when we decrypt from value2Key. There are too many possible that could generate Memory Limit Exceed\\n\\tSo we could use a trie, once we found currChar is not in our currNode. We don\\'t have to traverse all remaining possible.\\n\\t\\n* **func buildTrie** : Init a trie = {}, iterate through all words in dictionary. And iterate through char in word to build a trie\\n* **encrypt**: Iterate through word1 to map all char to its value. And append it in res. Finnally stringfy res and return.\\n* **decrypt** : This is the hard part in this question\\n1. Find all posiible from value2Key: For example ```\"ei\" can map to \\'a\\' or \\'c\\', \"zf\" maps to \\'b\\', and \"am\" maps to \\'d\\'.``` ```So possible = [[a,c] , [b], [a,c], [d]]```\\n2. findInTrie: Given possibles, DFS search from possible in our self.trieDict. If current word is valid res += 1.\\n\\n## Code\\n\\n**Python**\\n```python\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.key2Value = {}\\n        for key, value in zip(keys, values):\\n            self.key2Value[key] = value\\n            \\n        self.value2Key = defaultdict(list)\\n        for key, value in zip(keys, values):\\n            self.value2Key[value].append(key)\\n            \\n        self.trieDict = self.buildTrie(dictionary)\\n        \\n    def buildTrie(self, dictionary):\\n        trie = {}\\n        for word in dictionary:\\n            currNode = trie\\n            for s in word:\\n                if s not in currNode:\\n                    currNode[s] = {}\\n                currNode = currNode[s]\\n            currNode[\"*\"] = word\\n        return trie\\n    \\n    def encrypt(self, word1: str) -> str:\\n        res = []\\n        for char in word1:\\n            res.append(self.key2Value[char])\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        # 1. Find all posiible from value2Key \\n        idx = 0\\n        possible = []\\n        while idx < len(word2):\\n            value = word2[idx:idx+2]\\n            possible.append(self.value2Key[value])\\n            idx += 2\\n        # 2. Given possible, see if a possilbe is valid in trie\\n        return self.findInTrie(possible, 0, self.trieDict)\\n        \\n        \\n    def findInTrie(self, possible, idx, currNode):\\n        res = 0\\n        if idx == len(possible):\\n            if \"*\" in currNode:\\n                return 1\\n            return 0\\n        for char in possible[idx]:\\n            if char in currNode:\\n                res += self.findInTrie(possible, idx + 1, currNode[char])\\n        return res\\n```\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```\"ei\" can map to \\'a\\' or \\'c\\', \"zf\" maps to \\'b\\', and \"am\" maps to \\'d\\'.```\n```So possible = [[a,c] , [b], [a,c], [d]]```\n```python\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.key2Value = {}\\n        for key, value in zip(keys, values):\\n            self.key2Value[key] = value\\n            \\n        self.value2Key = defaultdict(list)\\n        for key, value in zip(keys, values):\\n            self.value2Key[value].append(key)\\n            \\n        self.trieDict = self.buildTrie(dictionary)\\n        \\n    def buildTrie(self, dictionary):\\n        trie = {}\\n        for word in dictionary:\\n            currNode = trie\\n            for s in word:\\n                if s not in currNode:\\n                    currNode[s] = {}\\n                currNode = currNode[s]\\n            currNode[\"*\"] = word\\n        return trie\\n    \\n    def encrypt(self, word1: str) -> str:\\n        res = []\\n        for char in word1:\\n            res.append(self.key2Value[char])\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        # 1. Find all posiible from value2Key \\n        idx = 0\\n        possible = []\\n        while idx < len(word2):\\n            value = word2[idx:idx+2]\\n            possible.append(self.value2Key[value])\\n            idx += 2\\n        # 2. Given possible, see if a possilbe is valid in trie\\n        return self.findInTrie(possible, 0, self.trieDict)\\n        \\n        \\n    def findInTrie(self, possible, idx, currNode):\\n        res = 0\\n        if idx == len(possible):\\n            if \"*\" in currNode:\\n                return 1\\n            return 0\\n        for char in possible[idx]:\\n            if char in currNode:\\n                res += self.findInTrie(possible, idx + 1, currNode[char])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775969,
                "title": "c-easy-faster",
                "content": "\\n\\n# Code\\n```\\nclass Encrypter {\\npublic:\\n   unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n   unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909590,
                "title": "easiest-hard-probelm-logic-complexity-analysis-c",
                "content": "## **Solution**\\n\\n\\n#### **LOGIC**\\n* Map vector ```keys``` to ```values``` so that we do not need to loop through ```keys``` to find correct value.\\n* ```dictionary``` is having all decrypted string, so we will encrypt them and see if the result match to the ```word2``` if so, then increase ```sol``` by 1.\\n* If you crete all decrypted string from ```word2``` and then try to look ```dictionary``` for that valuse. then it will make it very complex in term of code and time.\\n\\n\\n#### **Code**  \\n```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> mp1;\\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->dictionary = dictionary;\\n        for (int i = 0; i < keys.size(); i++) {\\n            mp1[keys[i]] =  values[i];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string sol = \"\";\\n        for (auto x : word1) {\\n            sol += mp1[x];\\n        }\\n        return sol;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sol = 0;\\n        \\n        for (auto x : this->dictionary) {\\n            if (encrypt(x) == word2) {\\n                sol++;\\n            }\\n        }\\n        \\n        return sol;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```\\n\\n## **Complexity**\\n\\n##### __Apporach : 1__  \\n##### Time Complexity:  \\n* __Encrypter__:  __O(size_of_keys)__\\n* __encrypt__:  __O(size_of_word1)__\\n* __decrypt__:  __O(size_of_dictionary)__\\n\\n##### Space Complexity:\\n* __O(size_of_dictionary)__\\n\\n\\n<br>\\n\\n __Check out all [my](https://leetcode.com/siddp6/) recent solutions [here](https://github.com/sidd6p/LeetCode)__\\n\\n \\n __Feel Free to Ask Doubts\\nAnd Please Share Some Suggestions\\nHAPPY CODING :)__\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```keys```\n```values```\n```keys```\n```dictionary```\n```word2```\n```sol```\n```word2```\n```dictionary```\n```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> mp1;\\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->dictionary = dictionary;\\n        for (int i = 0; i < keys.size(); i++) {\\n            mp1[keys[i]] =  values[i];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string sol = \"\";\\n        for (auto x : word1) {\\n            sol += mp1[x];\\n        }\\n        return sol;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sol = 0;\\n        \\n        for (auto x : this->dictionary) {\\n            if (encrypt(x) == word2) {\\n                sol++;\\n            }\\n        }\\n        \\n        return sol;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909251,
                "title": "elegant-pythonic-solution",
                "content": "The `encrypt` is the easiest part of the problem. Create a mapping and you are done.  The `decrypt` and `dictionary` values is a little tricky to figure out and we have basically have to create an inverse frequency map for this.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.encrypt_map = {k: v for k, v in zip(keys, values)}\\n        self.decrypt_map = Counter()\\n        \\n        for word in dictionary:\\n            res = self.encrypt(word)\\n            self.decrypt_map[res] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.encrypt_map[letter] for letter in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decrypt_map[word2]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.encrypt_map = {k: v for k, v in zip(keys, values)}\\n        self.decrypt_map = Counter()\\n        \\n        for word in dictionary:\\n            res = self.encrypt(word)\\n            self.decrypt_map[res] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.encrypt_map[letter] for letter in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decrypt_map[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909075,
                "title": "python-easy-understanding-python-solution",
                "content": "After 1 hour struggled with dp and trie. The question tend to be solved as simple as this \\nLOL\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = set(dictionary)\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        res = 0\\n        \\n        for item in self.dictionary:\\n            if self.encrypt(item) == word2:\\n                res += 1\\n        return res\\n```\\n\\nHere I also  post my Trie + Dp solution, but it is exceed the time limit. I would appricate if anyone could helpe me optimize the solution.\\n\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.child = {}\\n    \\n    def add(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.child:\\n                cur.child[c] = Trie()\\n            cur = cur.child[c]\\n        \\n        if \\'#\\' not in cur.child:\\n            cur.child[\\'#\\'] = \\'#\\'\\n    \\n    def find(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        \\n        return True \\n    \\n    def findExact(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        return \\'#\\' in cur.child \\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.trie = Trie()\\n        \\n        for word in dictionary:\\n            self.trie.add(word)\\n            \\n        self.map = defaultdict(list)\\n        \\n        for key, enco in zip(keys, values): # build the map from the eco to the initial word\\n            self.map[enco].append(key)\\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        chunks, chunk_size = len(word2), 2\\n        word = [ word2[i:i+chunk_size] for i in range(0, chunks, chunk_size)]\\n        size = len(word)\\n        dp = [[] for _ in range(size)]\\n        \\n        res  = 0\\n        for i in range(size):\\n            enco = word[i]\\n            if i == 0:\\n                for item in self.map[enco]:\\n                    if self.trie.find(item):\\n                        if i == size -1:\\n                            if \\'#\\' in self.trie.child[item].child:\\n                                res += 1\\n                        else:       \\n                            dp[i].append((item,self.trie.child[item]))\\n            else :\\n                for prev,pointer in dp[i-1]:\\n                    for curc in self.map[enco]:\\n                        if pointer.find(curc):\\n                            if i == size -1:\\n                                if \\'#\\' in pointer.child[curc].child:\\n                                    res += 1\\n                            else:\\n                                dp[i].append((prev + curc,pointer.child[curc]))\\n        return res     \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = set(dictionary)\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        res = 0\\n        \\n        for item in self.dictionary:\\n            if self.encrypt(item) == word2:\\n                res += 1\\n        return res\\n```\n```\\nclass Trie:\\n    def __init__(self):\\n        self.child = {}\\n    \\n    def add(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.child:\\n                cur.child[c] = Trie()\\n            cur = cur.child[c]\\n        \\n        if \\'#\\' not in cur.child:\\n            cur.child[\\'#\\'] = \\'#\\'\\n    \\n    def find(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        \\n        return True \\n    \\n    def findExact(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        return \\'#\\' in cur.child \\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.trie = Trie()\\n        \\n        for word in dictionary:\\n            self.trie.add(word)\\n            \\n        self.map = defaultdict(list)\\n        \\n        for key, enco in zip(keys, values): # build the map from the eco to the initial word\\n            self.map[enco].append(key)\\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        chunks, chunk_size = len(word2), 2\\n        word = [ word2[i:i+chunk_size] for i in range(0, chunks, chunk_size)]\\n        size = len(word)\\n        dp = [[] for _ in range(size)]\\n        \\n        res  = 0\\n        for i in range(size):\\n            enco = word[i]\\n            if i == 0:\\n                for item in self.map[enco]:\\n                    if self.trie.find(item):\\n                        if i == size -1:\\n                            if \\'#\\' in self.trie.child[item].child:\\n                                res += 1\\n                        else:       \\n                            dp[i].append((item,self.trie.child[item]))\\n            else :\\n                for prev,pointer in dp[i-1]:\\n                    for curc in self.map[enco]:\\n                        if pointer.find(curc):\\n                            if i == size -1:\\n                                if \\'#\\' in pointer.child[curc].child:\\n                                    res += 1\\n                            else:\\n                                dp[i].append((prev + curc,pointer.child[curc]))\\n        return res     \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908808,
                "title": "c-hashmap-trie-dp-dfs",
                "content": "```C++\\nstruct Trie {\\n    Trie* next[26];\\n    bool eof = false;\\n    Trie() {memset(next,0,sizeof(next));}\\n    void insert(string& s, int p) {\\n        if(p == s.length()) eof = true;\\n        else {\\n            if(!next[s[p]-\\'a\\']) next[s[p]-\\'a\\'] = new Trie();\\n            next[s[p]-\\'a\\']->insert(s, p + 1);\\n        }\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<char, int> k;\\n    vector<string> v;\\n    unordered_map<string, unordered_set<char>> mpv;\\n    Trie* t, *rt;\\n\\n    vector<pair<bool, vector<Trie*>>> DP;\\n    vector<bool> vis;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        t = new Trie();\\n        rt = new Trie();\\n        v = values;\\n\\n        for(int i = 0; i < keys.size(); i++)\\n            k[keys[i]] = i;\\n        for(int i = 0; i < values.size(); i++)\\n            mpv[values[i]].insert(keys[i]);\\n        for(auto& v : values)\\n            t->insert(v, 0);\\n        for(auto& d : dictionary) {\\n            auto rd = d;\\n            reverse(rd.begin(), rd.end());\\n            rt->insert(rd, 0);\\n        }\\n    }\\n\\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for(auto& w : word1) {\\n            ss<<v[k[w]];\\n        }\\n        return ss.str();\\n    }\\n\\n    int decrypt(string word2) {\\n        int n = word2.length();\\n        DP = vector<pair<bool, vector<Trie*>>>(n + 1, {false, {}});\\n        DP.back() = {true, {rt}};\\n\\n        vis = vector<bool>(n + 1, false);\\n        vis.back() = true;\\n\\n        auto [_, s] = helper(word2, 0);\\n        int res = 0;\\n        for(auto& rtrie : s) {\\n            res += rtrie->eof;\\n        }\\n\\n        return res;\\n    }\\n\\n    pair<bool,vector<Trie*>> helper(string& w, int p) {\\n        if(vis[p]) return DP[p];\\n        vis[p] = true;\\n        string ss;\\n        vector<Trie*> res;\\n        Trie* trie = t;\\n        bool PO = false;\\n        for(int i = p; i < w.length(); i++) {\\n            if(!trie->next[w[i]-\\'a\\']) break;\\n\\n            trie = trie->next[w[i]-\\'a\\'];\\n            ss += w[i];\\n            if(!trie->eof) continue;\\n            auto [po, comb] = helper(w, i + 1);\\n            if(!po) continue;\\n\\n            for(auto& rtrie : comb) {\\n                for(auto ch : mpv[ss]) {\\n                    if(!rtrie->next[ch-\\'a\\']) continue;\\n                    PO = true;\\n                    Trie* nrt = rtrie->next[ch-\\'a\\'];\\n                    res.push_back(nrt);\\n                }\\n            }\\n        }\\n        return DP[p] = {PO, res};\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```C++\\nstruct Trie {\\n    Trie* next[26];\\n    bool eof = false;\\n    Trie() {memset(next,0,sizeof(next));}\\n    void insert(string& s, int p) {\\n        if(p == s.length()) eof = true;\\n        else {\\n            if(!next[s[p]-\\'a\\']) next[s[p]-\\'a\\'] = new Trie();\\n            next[s[p]-\\'a\\']->insert(s, p + 1);\\n        }\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<char, int> k;\\n    vector<string> v;\\n    unordered_map<string, unordered_set<char>> mpv;\\n    Trie* t, *rt;\\n\\n    vector<pair<bool, vector<Trie*>>> DP;\\n    vector<bool> vis;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        t = new Trie();\\n        rt = new Trie();\\n        v = values;\\n\\n        for(int i = 0; i < keys.size(); i++)\\n            k[keys[i]] = i;\\n        for(int i = 0; i < values.size(); i++)\\n            mpv[values[i]].insert(keys[i]);\\n        for(auto& v : values)\\n            t->insert(v, 0);\\n        for(auto& d : dictionary) {\\n            auto rd = d;\\n            reverse(rd.begin(), rd.end());\\n            rt->insert(rd, 0);\\n        }\\n    }\\n\\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for(auto& w : word1) {\\n            ss<<v[k[w]];\\n        }\\n        return ss.str();\\n    }\\n\\n    int decrypt(string word2) {\\n        int n = word2.length();\\n        DP = vector<pair<bool, vector<Trie*>>>(n + 1, {false, {}});\\n        DP.back() = {true, {rt}};\\n\\n        vis = vector<bool>(n + 1, false);\\n        vis.back() = true;\\n\\n        auto [_, s] = helper(word2, 0);\\n        int res = 0;\\n        for(auto& rtrie : s) {\\n            res += rtrie->eof;\\n        }\\n\\n        return res;\\n    }\\n\\n    pair<bool,vector<Trie*>> helper(string& w, int p) {\\n        if(vis[p]) return DP[p];\\n        vis[p] = true;\\n        string ss;\\n        vector<Trie*> res;\\n        Trie* trie = t;\\n        bool PO = false;\\n        for(int i = p; i < w.length(); i++) {\\n            if(!trie->next[w[i]-\\'a\\']) break;\\n\\n            trie = trie->next[w[i]-\\'a\\'];\\n            ss += w[i];\\n            if(!trie->eof) continue;\\n            auto [po, comb] = helper(w, i + 1);\\n            if(!po) continue;\\n\\n            for(auto& rtrie : comb) {\\n                for(auto ch : mpv[ss]) {\\n                    if(!rtrie->next[ch-\\'a\\']) continue;\\n                    PO = true;\\n                    Trie* nrt = rtrie->next[ch-\\'a\\'];\\n                    res.push_back(nrt);\\n                }\\n            }\\n        }\\n        return DP[p] = {PO, res};\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908758,
                "title": "c-hashmap-set",
                "content": "Decryption: The dictionary of strings size is atmax 100. it\\'s better to encrypt each string in the dictionary and check whether it matches with the given string.\\n```\\nclass Encrypter {\\npublic:\\n    set<string> isInDictionary;\\n    vector<string> value;\\n    vector<int> keyIndex;\\n    unordered_map<char,string> keyToValueMap;\\n    \\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        //allocate space to store indices of each character in keys.\\n        keyIndex.resize(26,INT_MAX);\\n        \\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n            keyIndex[keys[i]-\\'a\\']=i;\\n        \\n        //assign value to values vector.\\n        value=values;\\n        \\n        \\n        // store the corresponding value string of each character in keys.\\n        for(int i=0;i<n;i++)\\n            keyToValueMap[keys[i]]=values[i];\\n        \\n        //save the strings in dictionary in a map.\\n        for(auto str:dictionary)\\n            isInDictionary.insert(str);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encryptedStr;\\n        // retrieve each charater value string using the keyIndex of that character.\\n        for(auto ch:word1)\\n            encryptedStr+=value[keyIndex[ch-\\'a\\']];\\n        return encryptedStr;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sz=word2.length();\\n        int count=0;\\n        // dictionary contains the decrypted strings since the dictionary size is 100.\\n        // traverse the dictionary and construct the corresponding encrypted string.\\n        for(string dictStr:isInDictionary){\\n            string enctryptedStr;\\n            //construct the encrypted string.\\n            for(auto ch:dictStr){\\n                //if there is no mapping for the character\\n                if(keyToValueMap.find(ch)==keyToValueMap.end())\\n                    return 0;\\n                enctryptedStr+=keyToValueMap[ch];\\n            }\\n\\t\\t\\t//increase the count if the encrypted string matches with word2.\\n            if(enctryptedStr==word2)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "Decryption: The dictionary of strings size is atmax 100. it\\'s better to encrypt each string in the dictionary and check whether it matches with the given string.\\n```\\nclass Encrypter {\\npublic:\\n    set<string> isInDictionary;\\n    vector<string> value;\\n    vector<int> keyIndex;\\n    unordered_map<char,string> keyToValueMap;\\n    \\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        //allocate space to store indices of each character in keys.\\n        keyIndex.resize(26,INT_MAX);\\n        \\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n            keyIndex[keys[i]-\\'a\\']=i;\\n        \\n        //assign value to values vector.\\n        value=values;\\n        \\n        \\n        // store the corresponding value string of each character in keys.\\n        for(int i=0;i<n;i++)\\n            keyToValueMap[keys[i]]=values[i];\\n        \\n        //save the strings in dictionary in a map.\\n        for(auto str:dictionary)\\n            isInDictionary.insert(str);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encryptedStr;\\n        // retrieve each charater value string using the keyIndex of that character.\\n        for(auto ch:word1)\\n            encryptedStr+=value[keyIndex[ch-\\'a\\']];\\n        return encryptedStr;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sz=word2.length();\\n        int count=0;\\n        // dictionary contains the decrypted strings since the dictionary size is 100.\\n        // traverse the dictionary and construct the corresponding encrypted string.\\n        for(string dictStr:isInDictionary){\\n            string enctryptedStr;\\n            //construct the encrypted string.\\n            for(auto ch:dictStr){\\n                //if there is no mapping for the character\\n                if(keyToValueMap.find(ch)==keyToValueMap.end())\\n                    return 0;\\n                enctryptedStr+=keyToValueMap[ch];\\n            }\\n\\t\\t\\t//increase the count if the encrypted string matches with word2.\\n            if(enctryptedStr==word2)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 4080996,
                "title": "very-simple-solution-try-catch-without-trie",
                "content": "# Code\\n```\\nclass Encrypter {\\n    String key_value[]=new String[26];\\n    HashMap<String, Integer> encrypted_dictionary=new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i=0;\\n        for(char key: keys) key_value[key-\\'a\\']=values[i++];\\n        \\n        for(String word: dictionary) {\\n            String encr=encrypt(word);\\n            if(encr==null) continue;\\n            encrypted_dictionary.put(encr, encrypted_dictionary.getOrDefault(encr, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] res=new char[word1.length()*2];\\n        for(int i=0;i<word1.length();i++) {\\n            try{\\n                res[i*2]=key_value[word1.charAt(i)-\\'a\\'].charAt(0);\\n                res[i*2+1]=key_value[word1.charAt(i)-\\'a\\'].charAt(1);\\n            }catch(Exception e){\\n                return null;\\n            }\\n        }\\n        return new String(res);\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encrypted_dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```\\n\\nThe Try catch block... its because I didnt want to mannually check for the error. Anyways, if a word causes problem, it wont be there in encrypted dictionary anyways... \\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Encrypter {\\n    String key_value[]=new String[26];\\n    HashMap<String, Integer> encrypted_dictionary=new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i=0;\\n        for(char key: keys) key_value[key-\\'a\\']=values[i++];\\n        \\n        for(String word: dictionary) {\\n            String encr=encrypt(word);\\n            if(encr==null) continue;\\n            encrypted_dictionary.put(encr, encrypted_dictionary.getOrDefault(encr, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] res=new char[word1.length()*2];\\n        for(int i=0;i<word1.length();i++) {\\n            try{\\n                res[i*2]=key_value[word1.charAt(i)-\\'a\\'].charAt(0);\\n                res[i*2+1]=key_value[word1.charAt(i)-\\'a\\'].charAt(1);\\n            }catch(Exception e){\\n                return null;\\n            }\\n        }\\n        return new String(res);\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encrypted_dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544782,
                "title": "two-maps-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\npublic:\\n    map<char,string> mp;\\n    map<string,int> decrypted;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++){\\n            mp[keys[i]] = values[i];\\n        }\\n        for(int i = 0; i < dictionary.size(); i++){\\n            decrypted[encrypt(dictionary[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            if(mp.find(word1[i]) == mp.end()){\\n                return \"\";\\n            }\\n            ans += mp[word1[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       if(decrypted.find(word2) == decrypted.end()){\\n           return 0;\\n       }\\n       return decrypted[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> mp;\\n    map<string,int> decrypted;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++){\\n            mp[keys[i]] = values[i];\\n        }\\n        for(int i = 0; i < dictionary.size(); i++){\\n            decrypted[encrypt(dictionary[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            if(mp.find(word1[i]) == mp.end()){\\n                return \"\";\\n            }\\n            ans += mp[word1[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       if(decrypted.find(word2) == decrypted.end()){\\n           return 0;\\n       }\\n       return decrypted[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475098,
                "title": "java-trie-hashmap",
                "content": "```\\nclass Encrypter {\\n    class Node {\\n        Node[] child = new Node[26];\\n        boolean isEnd = false;\\n        String word;\\n        Node () {\\n            //  Default\\n        }\\n    }\\n    //  this map is requied for encrypting the string\\n    HashMap<Integer, List<String>> charMap = new HashMap<>();\\n    //  this map is required for decrypting the string (to get the next valid or possible \\n    //  characters of a string in dictionary)\\n    HashMap<String, List<Integer>> revMap = new HashMap<>();\\n    //  stores all string in dictionary\\n    HashSet<String> dict = new HashSet<>();\\n    //  root of the Trie\\n    Node root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (String s : dictionary) {\\n            dict.add(s);\\n        }\\n        constructTrie(dictionary);\\n        for (int i = 0; i < keys.length; i++) {\\n            //  charMap\\n            if (!charMap.containsKey(keys[i] - \\'a\\')) {\\n                charMap.put(keys[i] - \\'a\\', new ArrayList<>());\\n            }\\n            charMap.get(keys[i] - \\'a\\').add(values[i]);\\n            //  revMap\\n            if (!revMap.containsKey(values[i])) {\\n                revMap.put(values[i], new ArrayList<>());\\n            }\\n            revMap.get(values[i]).add(keys[i] - \\'a\\');\\n        }\\n    }\\n    \\n    //  Trie for pruning (adding words on trie)\\n    private void constructTrie(String[] words) {\\n        root = new Node();\\n        for (String w : words) {\\n            Node curr = root;\\n            for (char c : w.toCharArray()) {\\n                if (curr.child[c - \\'a\\'] == null) {\\n                    curr.child[c - \\'a\\'] = new Node();\\n                }\\n                curr = curr.child[c - \\'a\\'];\\n            }\\n            curr.isEnd = true;\\n            curr.word = w;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder answer = new StringBuilder(\"\");\\n        for (char c : word1.toCharArray()) {\\n            if (!charMap.containsKey(c - \\'a\\')) return \"\";\\n            answer.append(charMap.get(c - \\'a\\').get(0));\\n        }\\n        return answer.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        Node curr = root;\\n        return helper(word2, curr, 0);\\n    }\\n    \\n    private int helper(String s, Node curr, int currIdx) {\\n        if (currIdx == s.length()) {\\n            //  at the end of the string and checking if this is present in the dict\\n            return dict.contains(curr.word) ? 1 : 0;\\n        }\\n        String key = s.substring(currIdx, currIdx + 2);\\n        List<Integer> next = revMap.getOrDefault(key, new ArrayList<>());\\n        int count = 0;\\n        for (int c : next) {\\n            if (curr.child[c] != null) {\\n                count += helper(s, curr.child[c], currIdx + 2);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    class Node {\\n        Node[] child = new Node[26];\\n        boolean isEnd = false;\\n        String word;\\n        Node () {\\n            //  Default\\n        }\\n    }\\n    //  this map is requied for encrypting the string\\n    HashMap<Integer, List<String>> charMap = new HashMap<>();\\n    //  this map is required for decrypting the string (to get the next valid or possible \\n    //  characters of a string in dictionary)\\n    HashMap<String, List<Integer>> revMap = new HashMap<>();\\n    //  stores all string in dictionary\\n    HashSet<String> dict = new HashSet<>();\\n    //  root of the Trie\\n    Node root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (String s : dictionary) {\\n            dict.add(s);\\n        }\\n        constructTrie(dictionary);\\n        for (int i = 0; i < keys.length; i++) {\\n            //  charMap\\n            if (!charMap.containsKey(keys[i] - \\'a\\')) {\\n                charMap.put(keys[i] - \\'a\\', new ArrayList<>());\\n            }\\n            charMap.get(keys[i] - \\'a\\').add(values[i]);\\n            //  revMap\\n            if (!revMap.containsKey(values[i])) {\\n                revMap.put(values[i], new ArrayList<>());\\n            }\\n            revMap.get(values[i]).add(keys[i] - \\'a\\');\\n        }\\n    }\\n    \\n    //  Trie for pruning (adding words on trie)\\n    private void constructTrie(String[] words) {\\n        root = new Node();\\n        for (String w : words) {\\n            Node curr = root;\\n            for (char c : w.toCharArray()) {\\n                if (curr.child[c - \\'a\\'] == null) {\\n                    curr.child[c - \\'a\\'] = new Node();\\n                }\\n                curr = curr.child[c - \\'a\\'];\\n            }\\n            curr.isEnd = true;\\n            curr.word = w;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder answer = new StringBuilder(\"\");\\n        for (char c : word1.toCharArray()) {\\n            if (!charMap.containsKey(c - \\'a\\')) return \"\";\\n            answer.append(charMap.get(c - \\'a\\').get(0));\\n        }\\n        return answer.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        Node curr = root;\\n        return helper(word2, curr, 0);\\n    }\\n    \\n    private int helper(String s, Node curr, int currIdx) {\\n        if (currIdx == s.length()) {\\n            //  at the end of the string and checking if this is present in the dict\\n            return dict.contains(curr.word) ? 1 : 0;\\n        }\\n        String key = s.substring(currIdx, currIdx + 2);\\n        List<Integer> next = revMap.getOrDefault(key, new ArrayList<>());\\n        int count = 0;\\n        for (int c : next) {\\n            if (curr.child[c] != null) {\\n                count += helper(s, curr.child[c], currIdx + 2);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1956564,
                "title": "python-trie-and-hashmap",
                "content": "`@cache` helps a lot with same queries in test cases.\\n\\n# Trie\\n```python\\nclass TrieNode:\\n    def __init__(self, words: List[str] = None):\\n        self.children = {}\\n        self.a_word = False\\n        if words:\\n            for word in words:\\n                self.add(word)\\n\\n    def add(self, word: str):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.a_word = True\\n\\n\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keylookup = {key: val for key, val in zip(keys, values)}\\n        self.vallookup = defaultdict(list)\\n        for i, val in enumerate(values):\\n            self.vallookup[val].append(keys[i])\\n        self.trie = TrieNode(dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.keylookup:\\n                return \"\"\\n            ret.append(self.keylookup[c])\\n        return \"\".join(ret)\\n\\n    @cache\\n    def decrypt(self, word2: str) -> int:\\n        chunks = (word2[i : i + 2] for i in range(0, len(word2), 2))\\n        candidates = list(self.vallookup[s] for s in chunks)\\n        N = len(candidates)\\n\\n        def dfs(root: TrieNode, i):\\n            if i == N:\\n                return int(root.a_word)\\n\\n            count = 0\\n            for key in candidates[i]:\\n                if key in root.children:\\n                    count += dfs(root.children[key], i + 1)\\n\\n            return count\\n\\n        return dfs(self.trie, 0)\\n```\\n\\n# hashmap\\n```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.klookup = {key: val for key, val in zip(keys, values)}\\n        self.dlookup = Counter(self.encrypt(w) for w in dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.klookup:\\n                return \"\"\\n            ret.append(self.klookup[c])\\n        return \"\".join(ret)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dlookup[word2]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass TrieNode:\\n    def __init__(self, words: List[str] = None):\\n        self.children = {}\\n        self.a_word = False\\n        if words:\\n            for word in words:\\n                self.add(word)\\n\\n    def add(self, word: str):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.a_word = True\\n\\n\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keylookup = {key: val for key, val in zip(keys, values)}\\n        self.vallookup = defaultdict(list)\\n        for i, val in enumerate(values):\\n            self.vallookup[val].append(keys[i])\\n        self.trie = TrieNode(dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.keylookup:\\n                return \"\"\\n            ret.append(self.keylookup[c])\\n        return \"\".join(ret)\\n\\n    @cache\\n    def decrypt(self, word2: str) -> int:\\n        chunks = (word2[i : i + 2] for i in range(0, len(word2), 2))\\n        candidates = list(self.vallookup[s] for s in chunks)\\n        N = len(candidates)\\n\\n        def dfs(root: TrieNode, i):\\n            if i == N:\\n                return int(root.a_word)\\n\\n            count = 0\\n            for key in candidates[i]:\\n                if key in root.children:\\n                    count += dfs(root.children[key], i + 1)\\n\\n            return count\\n\\n        return dfs(self.trie, 0)\\n```\n```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.klookup = {key: val for key, val in zip(keys, values)}\\n        self.dlookup = Counter(self.encrypt(w) for w in dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.klookup:\\n                return \"\"\\n            ret.append(self.klookup[c])\\n        return \"\".join(ret)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dlookup[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942851,
                "title": "java-solution-faster-than-25-81-less-than-81-35",
                "content": "```\\n\\tMap<Character, String> kvMap = new HashMap<>();\\n    Map<String, List<Character>> vkMap = new HashMap<>();\\n    TrieNode root = new TrieNode();\\n    Map<String, Integer> cache = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0, len = keys.length; i < len; ++i) {\\n            char key = keys[i];\\n            String value = values[i];\\n            kvMap.put(key, value);\\n            List<Character> characters = vkMap.getOrDefault(value, new ArrayList<>());\\n            characters.add(key);\\n            vkMap.put(value, characters);\\n        }\\n        for (String dic : dictionary) {\\n            build(root, dic);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            String s = kvMap.get(c);\\n            if (s == null) {\\n                return \"\";\\n            }\\n            sb.append(s);\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        Integer integer = cache.get(word2);\\n        if (integer == null) {\\n            int dfs = dfs(word2, 0, new StringBuilder());\\n            cache.put(word2, dfs);\\n            return dfs;\\n        }\\n        return integer;\\n    }\\n\\n        private int dfs(String word2, int index, StringBuilder sb) {\\n        if (index == word2.length()) {\\n            return search(root, sb.toString(), 0) ? 1 : 0;\\n        }\\n        if (index > 0 && !searchPrefix(root, sb.toString(), 0)) {\\n             return 0;\\n        }\\n        int count = 0;\\n        String substr = word2.substring(index, index + 2);\\n        List<Character> characters = vkMap.get(substr);\\n        if (characters == null) {\\n            return 0;\\n        }\\n        for (Character c : characters) {\\n            sb.append(c);\\n            count += dfs(word2, index + 2, sb);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        return count;\\n    }\\n\\n    private void build(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        for (char c : word.toCharArray()) {\\n            Map<Character, TrieNode> children = curr.getChildren();\\n            TrieNode node = children.get(c);\\n            if (node == null) {\\n                node = new TrieNode();\\n                children.put(c, node);\\n            }\\n            curr = node;\\n        }\\n        curr.setWord(true);\\n    }\\n\\n    private boolean search(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return false;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        if (index == word.length() - 1 && node.isWord) {\\n            return true;\\n        }\\n        return search(node, word, index + 1);\\n    }\\n\\n    private boolean searchPrefix(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return true;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        return searchPrefix(node, word, index + 1);\\n    }\\n\\n    private static class TrieNode {\\n\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean isWord;\\n\\n        public Map<Character, TrieNode> getChildren() {\\n            return children;\\n        }\\n\\n        public void setChildren(Map<Character, TrieNode> children) {\\n            this.children = children;\\n        }\\n\\n        public boolean isWord() {\\n            return isWord;\\n        }\\n\\n        public void setWord(boolean word) {\\n            isWord = word;\\n        }\\n\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n\\tMap<Character, String> kvMap = new HashMap<>();\\n    Map<String, List<Character>> vkMap = new HashMap<>();\\n    TrieNode root = new TrieNode();\\n    Map<String, Integer> cache = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0, len = keys.length; i < len; ++i) {\\n            char key = keys[i];\\n            String value = values[i];\\n            kvMap.put(key, value);\\n            List<Character> characters = vkMap.getOrDefault(value, new ArrayList<>());\\n            characters.add(key);\\n            vkMap.put(value, characters);\\n        }\\n        for (String dic : dictionary) {\\n            build(root, dic);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            String s = kvMap.get(c);\\n            if (s == null) {\\n                return \"\";\\n            }\\n            sb.append(s);\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        Integer integer = cache.get(word2);\\n        if (integer == null) {\\n            int dfs = dfs(word2, 0, new StringBuilder());\\n            cache.put(word2, dfs);\\n            return dfs;\\n        }\\n        return integer;\\n    }\\n\\n        private int dfs(String word2, int index, StringBuilder sb) {\\n        if (index == word2.length()) {\\n            return search(root, sb.toString(), 0) ? 1 : 0;\\n        }\\n        if (index > 0 && !searchPrefix(root, sb.toString(), 0)) {\\n             return 0;\\n        }\\n        int count = 0;\\n        String substr = word2.substring(index, index + 2);\\n        List<Character> characters = vkMap.get(substr);\\n        if (characters == null) {\\n            return 0;\\n        }\\n        for (Character c : characters) {\\n            sb.append(c);\\n            count += dfs(word2, index + 2, sb);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        return count;\\n    }\\n\\n    private void build(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        for (char c : word.toCharArray()) {\\n            Map<Character, TrieNode> children = curr.getChildren();\\n            TrieNode node = children.get(c);\\n            if (node == null) {\\n                node = new TrieNode();\\n                children.put(c, node);\\n            }\\n            curr = node;\\n        }\\n        curr.setWord(true);\\n    }\\n\\n    private boolean search(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return false;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        if (index == word.length() - 1 && node.isWord) {\\n            return true;\\n        }\\n        return search(node, word, index + 1);\\n    }\\n\\n    private boolean searchPrefix(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return true;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        return searchPrefix(node, word, index + 1);\\n    }\\n\\n    private static class TrieNode {\\n\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean isWord;\\n\\n        public Map<Character, TrieNode> getChildren() {\\n            return children;\\n        }\\n\\n        public void setChildren(Map<Character, TrieNode> children) {\\n            this.children = children;\\n        }\\n\\n        public boolean isWord() {\\n            return isWord;\\n        }\\n\\n        public void setWord(boolean word) {\\n            isWord = word;\\n        }\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930455,
                "title": "this-very-simple-solution-beats-80-while-trie-gets-tle",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {k:v for k,v in zip(keys, values)}\\n        self.d = collections.Counter([self.encrypt(d) for d in dictionary])\\n        \\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            if c not in self.kv: return \\'\\'\\n            res += self.kv[c]\\n        return res\\n\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n            \\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {k:v for k,v in zip(keys, values)}\\n        self.d = collections.Counter([self.encrypt(d) for d in dictionary])\\n        \\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            if c not in self.kv: return \\'\\'\\n            res += self.kv[c]\\n        return res\\n\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n            \\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926788,
                "title": "simple-java-solution-with-2-maps",
                "content": "```\\nclass Encrypter {\\n    private Map<Character, String> enc = new HashMap<>();\\n    private Map<String, Integer> countMap = new HashMap<>();\\n    private static final String DEFAULT_ENCODE_STRING = \"#\";\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int idx = 0; idx < keys.length; idx++) {\\n            enc.put(keys[idx], values[idx]);\\n        }\\n        for (String word : dictionary) {\\n            String encryptString = encrypt(word);\\n            countMap.put(encryptString, countMap.getOrDefault(encryptString, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder result = new StringBuilder();\\n        for (int idx = 0; idx < word1.length(); idx++) {\\n            result.append(enc.getOrDefault(word1.charAt(idx), DEFAULT_ENCODE_STRING));\\n        }\\n        return result.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return countMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    private Map<Character, String> enc = new HashMap<>();\\n    private Map<String, Integer> countMap = new HashMap<>();\\n    private static final String DEFAULT_ENCODE_STRING = \"#\";\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int idx = 0; idx < keys.length; idx++) {\\n            enc.put(keys[idx], values[idx]);\\n        }\\n        for (String word : dictionary) {\\n            String encryptString = encrypt(word);\\n            countMap.put(encryptString, countMap.getOrDefault(encryptString, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder result = new StringBuilder();\\n        for (int idx = 0; idx < word1.length(); idx++) {\\n            result.append(enc.getOrDefault(word1.charAt(idx), DEFAULT_ENCODE_STRING));\\n        }\\n        return result.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return countMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920897,
                "title": "c-easy-to-understand-simple-solution-using-hashmap",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> mp1;\\n    vector<string> dic;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[keys[i]]=values[i];\\n        }\\n        dic=dictionary;\\n    }\\n    string encrypt(string word1) {\\n     string ans=\"\";\\n        for(char ch:word1)\\n        {\\n            if(mp1.find(ch)==mp1.end())\\n            return \"\";\\n            ans+=mp1[ch];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        int ans=0;\\n        for(auto str:dic)\\n        {\\n          if(encrypt(str)==word2)\\n          ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> mp1;\\n    vector<string> dic;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[keys[i]]=values[i];\\n        }\\n        dic=dictionary;\\n    }\\n    string encrypt(string word1) {\\n     string ans=\"\";\\n        for(char ch:word1)\\n        {\\n            if(mp1.find(ch)==mp1.end())\\n            return \"\";\\n            ans+=mp1[ch];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        int ans=0;\\n        for(auto str:dic)\\n        {\\n          if(encrypt(str)==word2)\\n          ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920780,
                "title": "a-few-solutions",
                "content": "Encrypt each string `s` of the input array `A` as `t` and track the count `cnt` of each successfully encrypted `t`.  We use a map `m` to associate each `i`<sup>th</sup> input character of `C` with the corresponding `i`<sup>th</sup> input string of `S` for encryption.\\n\\nNote: we know the encryption successfully transforms input string `s` into output string `t` when the cardinality of `s` is equal to the cardinality of `t` divided evenly by `2` since each single character is encoded as two characters.\\n* `2 * |s| == |t|`\\n\\n---\\n\\n*Kotlin*\\n```\\ntypealias CA = CharArray\\ntypealias AS = Array<String>\\nclass Encrypter(C: CA, S: AS, A: AS) {\\n    private var m = mutableMapOf<Char, String>()\\n    private var cnt = mutableMapOf<String, Int>()\\n    var encrypt = { s: String -> s.toCharArray().map{ m[it] ?: \"\" }.joinToString(\"\") }\\n    var decrypt = { s: String -> cnt[s] ?: 0 }\\n    init {\\n        m = (C zip S).toMap().toMutableMap()\\n        for (s in A) {\\n            var t = encrypt(s)\\n            if (2 * s.length == t.length)\\n                cnt[t] = 1 + (cnt[t] ?: 0)\\n        }\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass Encrypter {\\n    constructor(C, S, A) {\\n        this.m = new Map(_.zip(C, S));\\n        this.cnt = new Map();\\n        for (let s of A) {\\n            let t = this.encrypt(s);\\n            if (2 * s.length == t.length)\\n                this.cnt.set(t, 1 + (this.cnt.get(t) || 0));\\n        }\\n    }\\n    encrypt = s => s.split(\\'\\').map(c => this.m.get(c) || \\'\\').join(\\'\\');\\n    decrypt = s => this.cnt.get(s) || 0;\\n}\\n```\\n\\n*Python3*\\n```\\nclass Encrypter:\\n    def __init__(self, C, S, A):\\n        self.m = { c: s for c, s in zip(C, S) }\\n        self.cnt = defaultdict(int)\\n        for s in A:\\n            t = self.encrypt(s)\\n            if 2 * len(s) == len(t):\\n                self.cnt[t] += 1\\n    encrypt = lambda self, s: \\'\\'.join(self.m[c] for c in list(s) if c in self.m)\\n    decrypt = lambda self, s: self.cnt[s]\\n```\\n\\n*Rust*\\n```\\nuse std::collections::HashMap;\\nstruct Encrypter {\\n    m: HashMap<char, String>,\\n    cnt: HashMap<String, i32>\\n}\\ntype VC = Vec<char>;\\ntype VS = Vec<String>;\\nimpl Encrypter {\\n    fn new(C: VC, S: VS, A: VS) -> Self {\\n        let mut m = HashMap::new();\\n        let mut cnt = HashMap::new();\\n        for (c, s) in C.iter().zip(S.iter()) {\\n            m.insert(*c, s.clone());\\n        }\\n        let mut me = Encrypter{ m, cnt };\\n        for s in A {\\n            let t = Self::encrypt(&mut me, s.clone());\\n            if 2 * s.len() == t.len() {\\n                *me.cnt.entry(t).or_insert(0) += 1;\\n            }\\n        }\\n        me\\n    }\\n    fn encrypt(&mut self, s: String) -> String {\\n        let mut t = String::new();\\n        for c in s.chars() {\\n            if let Some(x) = self.m.get(&c) {\\n                t.push_str(x.as_str());\\n            }\\n        }\\n        t\\n    }\\n    fn decrypt(&mut self, s: String) -> i32 {\\n        *self.cnt.entry(s).or_insert(0)\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Encrypter {\\npublic:\\n    using VC = vector<char>;\\n    using VS = vector<string>;\\n    using Map = unordered_map<char, string>;\\n    using Counter = unordered_map<string, int>;\\n    Map m;\\n    Counter cnt;\\n    Encrypter(VC& C, VS& S, VS& A) {\\n        for (auto i{ 0 }; i < C.size(); ++i)\\n            m[C[i]] = S[i];\\n        for (auto& s: A) {\\n            auto t = encrypt(s);\\n            if (2 * s.size() == t.size())\\n                ++cnt[t];\\n        }\\n    }\\n    string encrypt(string s) {\\n        ostringstream os;\\n        transform(s.begin(), s.end(), ostream_iterator<string>(os, \"\"), [&](auto c) { return m[c]; });\\n        return os.str();\\n    }\\n    int decrypt(string s) {\\n        return cnt[s];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypealias CA = CharArray\\ntypealias AS = Array<String>\\nclass Encrypter(C: CA, S: AS, A: AS) {\\n    private var m = mutableMapOf<Char, String>()\\n    private var cnt = mutableMapOf<String, Int>()\\n    var encrypt = { s: String -> s.toCharArray().map{ m[it] ?: \"\" }.joinToString(\"\") }\\n    var decrypt = { s: String -> cnt[s] ?: 0 }\\n    init {\\n        m = (C zip S).toMap().toMutableMap()\\n        for (s in A) {\\n            var t = encrypt(s)\\n            if (2 * s.length == t.length)\\n                cnt[t] = 1 + (cnt[t] ?: 0)\\n        }\\n    }\\n}\\n```\n```\\nclass Encrypter {\\n    constructor(C, S, A) {\\n        this.m = new Map(_.zip(C, S));\\n        this.cnt = new Map();\\n        for (let s of A) {\\n            let t = this.encrypt(s);\\n            if (2 * s.length == t.length)\\n                this.cnt.set(t, 1 + (this.cnt.get(t) || 0));\\n        }\\n    }\\n    encrypt = s => s.split(\\'\\').map(c => this.m.get(c) || \\'\\').join(\\'\\');\\n    decrypt = s => this.cnt.get(s) || 0;\\n}\\n```\n```\\nclass Encrypter:\\n    def __init__(self, C, S, A):\\n        self.m = { c: s for c, s in zip(C, S) }\\n        self.cnt = defaultdict(int)\\n        for s in A:\\n            t = self.encrypt(s)\\n            if 2 * len(s) == len(t):\\n                self.cnt[t] += 1\\n    encrypt = lambda self, s: \\'\\'.join(self.m[c] for c in list(s) if c in self.m)\\n    decrypt = lambda self, s: self.cnt[s]\\n```\n```\\nuse std::collections::HashMap;\\nstruct Encrypter {\\n    m: HashMap<char, String>,\\n    cnt: HashMap<String, i32>\\n}\\ntype VC = Vec<char>;\\ntype VS = Vec<String>;\\nimpl Encrypter {\\n    fn new(C: VC, S: VS, A: VS) -> Self {\\n        let mut m = HashMap::new();\\n        let mut cnt = HashMap::new();\\n        for (c, s) in C.iter().zip(S.iter()) {\\n            m.insert(*c, s.clone());\\n        }\\n        let mut me = Encrypter{ m, cnt };\\n        for s in A {\\n            let t = Self::encrypt(&mut me, s.clone());\\n            if 2 * s.len() == t.len() {\\n                *me.cnt.entry(t).or_insert(0) += 1;\\n            }\\n        }\\n        me\\n    }\\n    fn encrypt(&mut self, s: String) -> String {\\n        let mut t = String::new();\\n        for c in s.chars() {\\n            if let Some(x) = self.m.get(&c) {\\n                t.push_str(x.as_str());\\n            }\\n        }\\n        t\\n    }\\n    fn decrypt(&mut self, s: String) -> i32 {\\n        *self.cnt.entry(s).or_insert(0)\\n    }\\n}\\n```\n```\\nclass Encrypter {\\npublic:\\n    using VC = vector<char>;\\n    using VS = vector<string>;\\n    using Map = unordered_map<char, string>;\\n    using Counter = unordered_map<string, int>;\\n    Map m;\\n    Counter cnt;\\n    Encrypter(VC& C, VS& S, VS& A) {\\n        for (auto i{ 0 }; i < C.size(); ++i)\\n            m[C[i]] = S[i];\\n        for (auto& s: A) {\\n            auto t = encrypt(s);\\n            if (2 * s.size() == t.size())\\n                ++cnt[t];\\n        }\\n    }\\n    string encrypt(string s) {\\n        ostringstream os;\\n        transform(s.begin(), s.end(), ostream_iterator<string>(os, \"\"), [&](auto c) { return m[c]; });\\n        return os.str();\\n    }\\n    int decrypt(string s) {\\n        return cnt[s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915722,
                "title": "c-using-two-hashmaps-easy-understanding-fastest",
                "content": "Here\\'s the trick:\\nDo not generate all the possible strings after decryption and then count the occurrences in dictionary, TAKE THE REVERSE WAY, encrypt the dictionary and store it in a map, now just return the number of occurrences in that map of the desired string to be decrypted.\\n\\nWe can create 2 hashmaps, \\n- one to map the keys to value, so that we can instantly get the corresponding encryption of a character in O(1) for the encryption method.\\n- other for decryption method, to encrypt all the strings in the dictionary and count the occurences. Now whenever we get a call to decrypt a string, we can direct look it up in the hashmap, and return the count instead of actually decrypting it and checking if it exists in the dictionary.\\n\\nThe Code below would make it much clearer. \\n\\n```\\nclass Encrypter {\\npublic:\\n  unordered_map<char, string> encDict;\\n  unordered_map<string, int> decDict;\\n  \\n  Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n    for(int i=0; i<keys.size(); i++) {\\n      encDict[keys[i]] = values[i];\\n    }\\n    for(auto i:dictionary) {\\n      string tmp = encrypt(i);\\n      if(tmp.size())\\n        decDict[tmp]++;\\n    }\\n  }\\n\\n  string encrypt(string word1) {\\n    string encrypted = \"\";\\n    for(auto i:word1) {\\n      if(encDict[i]==\"\") return \"\";\\n      encrypted += encDict[i];\\n    }\\n    return encrypted;\\n  }\\n\\n  int decrypt(string word2) {    \\n    return decDict[word2];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n  unordered_map<char, string> encDict;\\n  unordered_map<string, int> decDict;\\n  \\n  Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n    for(int i=0; i<keys.size(); i++) {\\n      encDict[keys[i]] = values[i];\\n    }\\n    for(auto i:dictionary) {\\n      string tmp = encrypt(i);\\n      if(tmp.size())\\n        decDict[tmp]++;\\n    }\\n  }\\n\\n  string encrypt(string word1) {\\n    string encrypted = \"\";\\n    for(auto i:word1) {\\n      if(encDict[i]==\"\") return \"\";\\n      encrypted += encDict[i];\\n    }\\n    return encrypted;\\n  }\\n\\n  int decrypt(string word2) {    \\n    return decDict[word2];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915491,
                "title": "test-cases-can-be-passed-using-a-simple-cache",
                "content": "The Time Limit Exceeded  cases (e.g case 201) rely on sending the same input over and over. If one adds a simple cache those cases get passed and the solution gets Accepted, despite it not being the intention.\\n\\nThere needs to be cases that lead to TLE using different inputs for each one to avoid this issue.",
                "solutionTags": [],
                "code": "The Time Limit Exceeded  cases (e.g case 201) rely on sending the same input over and over. If one adds a simple cache those cases get passed and the solution gets Accepted, despite it not being the intention.\\n\\nThere needs to be cases that lead to TLE using different inputs for each one to avoid this issue.",
                "codeTag": "Unknown"
            },
            {
                "id": 1915086,
                "title": "javascript-two-hashmaps",
                "content": "```\\nclass Encrypter {\\n  constructor(keys, values, dictionary) {\\n    this.mapKeyToValue = {};\\n    this.mapCount = {};\\n    const n = keys.length;\\n\\n    for (let i = 0; i < n; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.mapKeyToValue[key] = value;\\n    }\\n\\n    for (const dict of dictionary) {\\n      const encrypted = this.encrypt(dict);\\n      this.mapCount[encrypted] = (this.mapCount[encrypted] || 0) + 1;\\n    }\\n  }\\n\\n  encrypt(word1) {\\n    let res = \\'\\';\\n    for (const char of word1) {\\n      res += this.mapKeyToValue[char];\\n    }\\n    return res;\\n  }\\n\\n  decrypt(word2) {\\n    return this.mapCount[word2] || 0;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n  constructor(keys, values, dictionary) {\\n    this.mapKeyToValue = {};\\n    this.mapCount = {};\\n    const n = keys.length;\\n\\n    for (let i = 0; i < n; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.mapKeyToValue[key] = value;\\n    }\\n\\n    for (const dict of dictionary) {\\n      const encrypted = this.encrypt(dict);\\n      this.mapCount[encrypted] = (this.mapCount[encrypted] || 0) + 1;\\n    }\\n  }\\n\\n  encrypt(word1) {\\n    let res = \\'\\';\\n    for (const char of word1) {\\n      res += this.mapKeyToValue[char];\\n    }\\n    return res;\\n  }\\n\\n  decrypt(word2) {\\n    return this.mapCount[word2] || 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911392,
                "title": "easy-to-understand-cpp",
                "content": "```\\nclass Encrypter {\\n    map<char,int> k;\\n    map<int,string> v;\\n    map<string,int> cnt;\\n    set<string> dic;\\n    map<string,int> freq;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)k[keys[i]]=i;\\n        for(int i=0;i<values.size();i++)v[i]=values[i];\\n        \\n        for(auto &x:values)cnt[x]++;\\n        \\n        for(auto &x:dictionary){\\n            string enc=encrypt(x);\\n            freq[enc]++;\\n        }\\n        // dic.insert(x);        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(auto &x:word1){\\n            int tem=k[x];\\n            string s=v[tem];\\n            ans+=s;\\n        }\\n        return ans;        \\n    }\\n    \\n    int decrypt(string word2) {\\n        // if(dic.find(word2)==dic.end())return 0;\\n        int ans=1;\\n        \\n        \\n        return freq[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\n    map<char,int> k;\\n    map<int,string> v;\\n    map<string,int> cnt;\\n    set<string> dic;\\n    map<string,int> freq;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)k[keys[i]]=i;\\n        for(int i=0;i<values.size();i++)v[i]=values[i];\\n        \\n        for(auto &x:values)cnt[x]++;\\n        \\n        for(auto &x:dictionary){\\n            string enc=encrypt(x);\\n            freq[enc]++;\\n        }\\n        // dic.insert(x);        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(auto &x:word1){\\n            int tem=k[x];\\n            string s=v[tem];\\n            ans+=s;\\n        }\\n        return ans;        \\n    }\\n    \\n    int decrypt(string word2) {\\n        // if(dic.find(word2)==dic.end())return 0;\\n        int ans=1;\\n        \\n        \\n        return freq[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1911274,
                "title": "python-trie",
                "content": "Build the trie with encrypted strings in the dictionary. Use c[\\'#\\'] to store the number of occurence. \\n\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.trie = {}\\n    \\n    def add(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                cur[c]={}\\n            cur = cur[c]\\n        if \\'#\\' not in cur:\\n            cur[\\'#\\'] = 1\\n        else:\\n            cur[\\'#\\'] += 1\\n    \\n    def get(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                return 0\\n            cur = cur[c]\\n        if \\'#\\' in cur:\\n            return cur[\\'#\\']\\n        else:\\n            return 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        n = len(keys)\\n        self.dic = defaultdict(str)\\n        for i in range(n):\\n            self.dic[keys[i]] = values[i]\\n        \\n        self.T = Trie()\\n        for di in dictionary:\\n            ndi = [self.dic[c] for c in di]\\n            self.T.add(\\'\\'.join(ndi))\\n\\n    def encrypt(self, word1: str) -> str:\\n        ns = [self.dic[c] for c in word1]\\n        return \\'\\'.join(ns)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.T.get(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.trie = {}\\n    \\n    def add(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                cur[c]={}\\n            cur = cur[c]\\n        if \\'#\\' not in cur:\\n            cur[\\'#\\'] = 1\\n        else:\\n            cur[\\'#\\'] += 1\\n    \\n    def get(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                return 0\\n            cur = cur[c]\\n        if \\'#\\' in cur:\\n            return cur[\\'#\\']\\n        else:\\n            return 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        n = len(keys)\\n        self.dic = defaultdict(str)\\n        for i in range(n):\\n            self.dic[keys[i]] = values[i]\\n        \\n        self.T = Trie()\\n        for di in dictionary:\\n            ndi = [self.dic[c] for c in di]\\n            self.T.add(\\'\\'.join(ndi))\\n\\n    def encrypt(self, word1: str) -> str:\\n        ns = [self.dic[c] for c in word1]\\n        return \\'\\'.join(ns)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.T.get(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909405,
                "title": "javascript-brain-teaser-390ms",
                "content": "for decrypt() first thinking is do backtracking, and check if match to any of them in dictionary, this way I tried get TLE with 201/203 passed (don\\'t know how to improve)\\n\\nThen I figure out what we need to do is just encrypt each string in dictionary, and see if it match to decrypt (^_^)\\n```\\n// template: {value: array indices increasing order}\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v), memo = new Map();\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) { // reverse thinking\\n        if (memo.has(s)) return memo.get(s);\\n        let res = 0;\\n        for (const dic of dict) {\\n            if (encrypt(dic) == s) res++;\\n        }\\n        memo.set(s, res);\\n        return res;\\n    }\\n}\\n```\\nbacktracking tried version, not working TLE 201/203 passed\\n```\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v);\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) {\\n        let n = s.length, res = 0;\\n        function dfs(pos, cur) {\\n            if (pos == n) {\\n                let t = cur.join(\"\");\\n                if (dict.has(t)) res++;\\n                return;\\n            }\\n            for (let i = pos; i < n; i++) {\\n                let next = s.slice(pos, i + 1); // find next substring/array\\n                if (!mv.has(next)) continue;\\n                let ia = mv.get(next) || [];\\n                for (const idx of ia) {\\n                    cur.push(k[idx]);\\n                    dfs(i + 1, cur);\\n                    cur.pop();\\n                }\\n            }\\n        }\\n        dfs(0, []);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n// template: {value: array indices increasing order}\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v), memo = new Map();\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) { // reverse thinking\\n        if (memo.has(s)) return memo.get(s);\\n        let res = 0;\\n        for (const dic of dict) {\\n            if (encrypt(dic) == s) res++;\\n        }\\n        memo.set(s, res);\\n        return res;\\n    }\\n}\\n```\n```\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v);\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) {\\n        let n = s.length, res = 0;\\n        function dfs(pos, cur) {\\n            if (pos == n) {\\n                let t = cur.join(\"\");\\n                if (dict.has(t)) res++;\\n                return;\\n            }\\n            for (let i = pos; i < n; i++) {\\n                let next = s.slice(pos, i + 1); // find next substring/array\\n                if (!mv.has(next)) continue;\\n                let ia = mv.get(next) || [];\\n                for (const idx of ia) {\\n                    cur.push(k[idx]);\\n                    dfs(i + 1, cur);\\n                    cur.pop();\\n                }\\n            }\\n        }\\n        dfs(0, []);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909305,
                "title": "python-simple-short-and-easy-to-understand",
                "content": "```\\nfrom collections import defaultdict\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = { key:val for key, val in zip(keys, values)}\\n        self.decryptCount = defaultdict(lambda:0)\\n        \\n        for word in dictionary:\\n            self.decryptCount[\"\".join([self.keys[ch] for ch in word])]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join([self.keys[ch] for ch in word1])\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decryptCount[word2]\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = { key:val for key, val in zip(keys, values)}\\n        self.decryptCount = defaultdict(lambda:0)\\n        \\n        for word in dictionary:\\n            self.decryptCount[\"\".join([self.keys[ch] for ch in word])]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join([self.keys[ch] for ch in word1])\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decryptCount[word2]\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909172,
                "title": "c-using-hashmap-preprocessing",
                "content": "Simply, encrypt all the strings of *dictionary* in the constructor only and then store the frequency of the encoded string in the *dict* map. Then, return the frequency of the encoded string from the *dict* map int the **decrpyt** method.\\n\\n```\\nclass Encrypter\\n{\\npublic:\\n    unordered_map<char, string> kv;\\n    unordered_map<string,int> dict;\\n    Encrypter(vector<char> &keys, vector<string> &values, vector<string> &dictionary) {\\n        for (int i = 0; i < size(keys); i++)\\n            kv[keys[i]] = values[i];\\n        for(auto str: dictionary)\\n            dict[encrypt(str)]++;\\n    }\\n    \\n    string encrypt(string w) {\\n        string s = \"\";\\n        for (int i = 0; i < size(w); i++)\\n            s += kv[w[i]];\\n        return s;\\n    }\\n    \\n    int decrypt(string w) {\\n        return dict[w];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter\\n{\\npublic:\\n    unordered_map<char, string> kv;\\n    unordered_map<string,int> dict;\\n    Encrypter(vector<char> &keys, vector<string> &values, vector<string> &dictionary) {\\n        for (int i = 0; i < size(keys); i++)\\n            kv[keys[i]] = values[i];\\n        for(auto str: dictionary)\\n            dict[encrypt(str)]++;\\n    }\\n    \\n    string encrypt(string w) {\\n        string s = \"\";\\n        for (int i = 0; i < size(w); i++)\\n            s += kv[w[i]];\\n        return s;\\n    }\\n    \\n    int decrypt(string w) {\\n        return dict[w];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909139,
                "title": "easy-map-solution-in-c-with-comments-without-trie",
                "content": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> m1;\\n    map<string,vector<char>> m2;\\n    map<string,int> m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];  //store value of key\\n            m2[values[i]].push_back(keys[i]); //store key of value\\n        }\\n        for(int i=0;i<dic.size();i++)\\n        {\\n\\t\\t\\t//count the frequency of given text in encrypted form\\n            string sa=encrypt(dic[i]); \\n            m3[sa]++;\\n        }\\n    }\\n    string encrypt(string word1) {\\n        string s1;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            s1+=m1[word1[i]];\\n        }\\n        return s1;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> m1;\\n    map<string,vector<char>> m2;\\n    map<string,int> m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];  //store value of key\\n            m2[values[i]].push_back(keys[i]); //store key of value\\n        }\\n        for(int i=0;i<dic.size();i++)\\n        {\\n\\t\\t\\t//count the frequency of given text in encrypted form\\n            string sa=encrypt(dic[i]); \\n            m3[sa]++;\\n        }\\n    }\\n    string encrypt(string word1) {\\n        string s1;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            s1+=m1[word1[i]];\\n        }\\n        return s1;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1909130,
                "title": "by-using-three-maps",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string>m1;\\n    unordered_map<string,vector<char>>m2;\\n    unordered_map<string,int>m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]]=values[i];\\n            m2[values[i]].push_back(keys[i]);\\n        }\\n        for(int i=0;i<dictionary.size();i++) {\\n            string ss=encrypt(dictionary[i]);\\n            m3[ss]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ss;\\n        for(int i=0;i<word1.size();i++){\\n            ss+=m1[word1[i]];\\n        }\\n        return ss;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string>m1;\\n    unordered_map<string,vector<char>>m2;\\n    unordered_map<string,int>m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]]=values[i];\\n            m2[values[i]].push_back(keys[i]);\\n        }\\n        for(int i=0;i<dictionary.size();i++) {\\n            string ss=encrypt(dictionary[i]);\\n            m3[ss]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ss;\\n        for(int i=0;i<word1.size();i++){\\n            ss+=m1[word1[i]];\\n        }\\n        return ss;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909101,
                "title": "java-trie",
                "content": "\\tclass TrieNode{\\n        TrieNode[] children;\\n        boolean isWord;\\n        \\n        public TrieNode(){\\n            children = new TrieNode[26];\\n            isWord = false;\\n        }\\n    }\\n    \\n    Map<Character, String> key2value;\\n    Map<String, Set<Character>> value2key;\\n    TrieNode root;\\n    \\n    private void insert(String word, TrieNode root){\\n        TrieNode cur = root;\\n        for(int i = 0; i < word.length(); i++){\\n            char c = word.charAt(i);\\n            if(cur.children[c - \\'a\\'] == null)\\n                cur.children[c - \\'a\\'] = new TrieNode();\\n            cur = cur.children[c - \\'a\\'];\\n            if(i == word.length() - 1){\\n                cur.isWord = true;\\n            }\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        key2value = new HashMap<>();\\n        value2key = new HashMap<>();\\n        root = new TrieNode();\\n        for(int i = 0; i < keys.length; i++){\\n            char key = keys[i];\\n            String value = values[i];\\n            key2value.put(key, value);\\n            value2key.putIfAbsent(value, new HashSet<Character>());\\n            value2key.get(value).add(key);\\n        }\\n        for(String s: dictionary){\\n            insert(s, root);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < word1.length(); i++){\\n            sb.append(key2value.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int[] res = new int[1];\\n        dfs(word2, 0, res, this.root);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String s, int idx, int[] res, TrieNode root){\\n        if(idx == s.length() && root.isWord){\\n            res[0]++;\\n            return;\\n        }\\n        if(idx >= s.length()){\\n            return;\\n        }\\n        String str = s.substring(idx, idx + 2);\\n        if(!value2key.containsKey(str)){\\n            return;\\n        }\\n        for(char cha: value2key.get(str)){\\n            if(root.children[cha - \\'a\\'] != null){\\n                dfs(s, idx + 2, res, root.children[cha - \\'a\\']);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "\\tclass TrieNode{\\n        TrieNode[] children;\\n        boolean isWord;\\n        \\n        public TrieNode(){\\n            children = new TrieNode[26];\\n            isWord = false;\\n        }\\n    }\\n    \\n    Map<Character, String> key2value;\\n    Map<String, Set<Character>> value2key;\\n    TrieNode root;\\n    \\n    private void insert(String word, TrieNode root){\\n        TrieNode cur = root;\\n        for(int i = 0; i < word.length(); i++){\\n            char c = word.charAt(i);\\n            if(cur.children[c - \\'a\\'] == null)\\n                cur.children[c - \\'a\\'] = new TrieNode();\\n            cur = cur.children[c - \\'a\\'];\\n            if(i == word.length() - 1){\\n                cur.isWord = true;\\n            }\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        key2value = new HashMap<>();\\n        value2key = new HashMap<>();\\n        root = new TrieNode();\\n        for(int i = 0; i < keys.length; i++){\\n            char key = keys[i];\\n            String value = values[i];\\n            key2value.put(key, value);\\n            value2key.putIfAbsent(value, new HashSet<Character>());\\n            value2key.get(value).add(key);\\n        }\\n        for(String s: dictionary){\\n            insert(s, root);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < word1.length(); i++){\\n            sb.append(key2value.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int[] res = new int[1];\\n        dfs(word2, 0, res, this.root);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String s, int idx, int[] res, TrieNode root){\\n        if(idx == s.length() && root.isWord){\\n            res[0]++;\\n            return;\\n        }\\n        if(idx >= s.length()){\\n            return;\\n        }\\n        String str = s.substring(idx, idx + 2);\\n        if(!value2key.containsKey(str)){\\n            return;\\n        }\\n        for(char cha: value2key.get(str)){\\n            if(root.children[cha - \\'a\\'] != null){\\n                dfs(s, idx + 2, res, root.children[cha - \\'a\\']);\\n            }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1909063,
                "title": "cheated-solution-make-this-a-easy-problem",
                "content": "Instead of really solving this problem, as the dictionary is super short, we can just do a encryption of all of them when initialize, and store the encrpted->count map.\\n\\n\\n```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> m;\\n    unordered_map<string, int> count;\\n    \\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for (int i = 0; i < K.size(); ++i) \\n            m[K[i]] = V[i];\\n        \\n        for (string& s : D) {\\n            string en_s = encrypt(s);\\n            count[en_s]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret = \"\";\\n        for (char& c : word1) ret += m[c];\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> m;\\n    unordered_map<string, int> count;\\n    \\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for (int i = 0; i < K.size(); ++i) \\n            m[K[i]] = V[i];\\n        \\n        for (string& s : D) {\\n            string en_s = encrypt(s);\\n            count[en_s]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret = \"\";\\n        for (char& c : word1) ret += m[c];\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909016,
                "title": "hash-map-bruteforce",
                "content": "\\n```\\nclass Encrypter {\\npublic:\\n    map<char,string> m;\\n    map<string,int> com;\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        for(int i=0; i<k.size(); ++i)\\n        {\\n            m[k[i]] = v[i];\\n            // mm[v[i]].push_back(k[i]);\\n        }\\n        \\n        for(int i=0; i<d.size(); ++i)\\n        {\\n            string ans = \"\";\\n            for(int j=0; j<d[i].size(); ++j)\\n            {\\n                ans+=m[d[i][j]];\\n            }\\n            com[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        \\n        string ans = \"\";\\n        \\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            ans+=m[s[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string s) {\\n        \\n        if(com.count(s))\\n            return com[s];\\n        \\n        return 0;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> m;\\n    map<string,int> com;\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        for(int i=0; i<k.size(); ++i)\\n        {\\n            m[k[i]] = v[i];\\n            // mm[v[i]].push_back(k[i]);\\n        }\\n        \\n        for(int i=0; i<d.size(); ++i)\\n        {\\n            string ans = \"\";\\n            for(int j=0; j<d[i].size(); ++j)\\n            {\\n                ans+=m[d[i][j]];\\n            }\\n            com[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        \\n        string ans = \"\";\\n        \\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            ans+=m[s[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string s) {\\n        \\n        if(com.count(s))\\n            return com[s];\\n        \\n        return 0;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908959,
                "title": "easy-trie-bfs-python-optimized-code",
                "content": "**Solution 1: Trie**\\n\\n1. Use a trie to store the target words of dict\\n2. Find all combinations using a lookup dict.\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.child = defaultdict()\\n        self.present = False\\n        \\nclass Encrypter:\\n\\n    def insert(self,s):\\n        p = self.t\\n        for ch in s:\\n            if ch not in p.child:\\n                p.child[ch] = Trie()\\n            p = p.child[ch]\\n        p.present = True\\n    \\n    def __init__(self, k: List[str], v: List[str], target_dict: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.t = Trie()\\n        self.max_d_word_len = 0\\n        for s in target_dict:\\n            flag = True\\n            for ch in s:\\n                if ch not in self.d:\\n                    flag = False\\n                    break\\n            if flag:\\n                self.max_d_word_len = max(self.max_d_word_len, len(s))\\n                self.insert(s)\\n        \\n        self.rev = defaultdict(list)\\n        for i in range(len(k)):\\n            self.rev[v[i]].append(k[i])\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n      \\n        if len(s)//2 > self.max_d_word_len:\\n            return 0\\n        \\n        p = self.t        \\n        q = deque()\\n        q.append([0,p]) # index in s, ptr to trie\\n        cnt = 0\\n\\n        while q:\\n            i, p = q.popleft()\\n            \\n            if i == len(s):\\n                if p.present:\\n                    cnt += 1\\n                continue\\n            \\n            for k in self.rev[s[i:i+2]]:\\n                if k not in p.child:\\n                    continue\\n                t = p.child[k]\\n                q.append([i+2,t])\\n            \\n        return cnt\\n```\\n\\n**Solution 2:**\\n\\nInstead of decrypting result for each decrypt() call and then matching it with target list.\\nEncrypt the words in target list and count them. \\nSo each decrypt call can look it up in dict.\\n```\\nclass Encrypter:\\n    \\n    def __init__(self, k: List[str], v: List[str], target: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.encrypt_target = defaultdict(int)\\n        for val in target:\\n            self.encrypt_target[self.encrypt(val)] += 1\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n        return self.encrypt_target[s]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.child = defaultdict()\\n        self.present = False\\n        \\nclass Encrypter:\\n\\n    def insert(self,s):\\n        p = self.t\\n        for ch in s:\\n            if ch not in p.child:\\n                p.child[ch] = Trie()\\n            p = p.child[ch]\\n        p.present = True\\n    \\n    def __init__(self, k: List[str], v: List[str], target_dict: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.t = Trie()\\n        self.max_d_word_len = 0\\n        for s in target_dict:\\n            flag = True\\n            for ch in s:\\n                if ch not in self.d:\\n                    flag = False\\n                    break\\n            if flag:\\n                self.max_d_word_len = max(self.max_d_word_len, len(s))\\n                self.insert(s)\\n        \\n        self.rev = defaultdict(list)\\n        for i in range(len(k)):\\n            self.rev[v[i]].append(k[i])\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n      \\n        if len(s)//2 > self.max_d_word_len:\\n            return 0\\n        \\n        p = self.t        \\n        q = deque()\\n        q.append([0,p]) # index in s, ptr to trie\\n        cnt = 0\\n\\n        while q:\\n            i, p = q.popleft()\\n            \\n            if i == len(s):\\n                if p.present:\\n                    cnt += 1\\n                continue\\n            \\n            for k in self.rev[s[i:i+2]]:\\n                if k not in p.child:\\n                    continue\\n                t = p.child[k]\\n                q.append([i+2,t])\\n            \\n        return cnt\\n```\n```\\nclass Encrypter:\\n    \\n    def __init__(self, k: List[str], v: List[str], target: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.encrypt_target = defaultdict(int)\\n        for val in target:\\n            self.encrypt_target[self.encrypt(val)] += 1\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n        return self.encrypt_target[s]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908949,
                "title": "python-10-liner-o-1-for-decrypt",
                "content": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_to_value = {k: v for k, v in zip(keys, values)}\\n        self.counter = Counter([self.encrypt(word) for word in dictionary])\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.key_to_value[char] for char in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.counter[word2]\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_to_value = {k: v for k, v in zip(keys, values)}\\n        self.counter = Counter([self.encrypt(word) for word in dictionary])\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.key_to_value[char] for char in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.counter[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908938,
                "title": "simple-java-solution-precompute-o-1-decrypt",
                "content": "Idea is pre-encryting the word in dictionary and store the count in a map. When doing decryption, simply check the map and return the count.\\n```\\nclass Encrypter {\\n    Map<Character, Integer> keyIndexMap = new HashMap<>();\\n    Map<String, Integer> dictCountMap = new HashMap<>();\\n    String[] values;\\n    String[] dictionary;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0; i < keys.length; i++) {\\n            this.keyIndexMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n\\t\\t// precompute the encrypted value of all words in dict\\n        for(int i = 0; i < dictionary.length; i++) {\\n            dictionary[i] = encrypt(dictionary[i]);\\n            dictCountMap.put(dictionary[i], dictCountMap.getOrDefault(dictionary[i], 0) + 1);\\n        }\\n        this.dictionary = dictionary;\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] charArray = word1.toCharArray();\\n        StringBuilder builder = new StringBuilder();\\n        for(char c: charArray) {\\n            int index = keyIndexMap.get(c);\\n            builder.append(values[index]);\\n        }\\n        return builder.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictCountMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    Map<Character, Integer> keyIndexMap = new HashMap<>();\\n    Map<String, Integer> dictCountMap = new HashMap<>();\\n    String[] values;\\n    String[] dictionary;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0; i < keys.length; i++) {\\n            this.keyIndexMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n\\t\\t// precompute the encrypted value of all words in dict\\n        for(int i = 0; i < dictionary.length; i++) {\\n            dictionary[i] = encrypt(dictionary[i]);\\n            dictCountMap.put(dictionary[i], dictCountMap.getOrDefault(dictionary[i], 0) + 1);\\n        }\\n        this.dictionary = dictionary;\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] charArray = word1.toCharArray();\\n        StringBuilder builder = new StringBuilder();\\n        for(char c: charArray) {\\n            int index = keyIndexMap.get(c);\\n            builder.append(values[index]);\\n        }\\n        return builder.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictCountMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908927,
                "title": "python-not-trie-just-search-on-the-dictionary",
                "content": "Instead of trie, try to search for each word in the dictionary (because the dictionary size is only 100 and each word in the dictionary is also 100):\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {}\\n        self.vk = {}\\n        for i in range(len(keys)):\\n            k, v = keys[i], values[i]\\n            self.kv[k] = values[i]\\n            \\n            if v not in self.vk:\\n                self.vk[v] = set()\\n                \\n            self.vk[v].add(k)\\n            \\n        self.dick = dictionary\\n\\n        \\n    def encrypt(self, w: str) -> str:\\n        res = \"\"\\n        for c in w:\\n            res += self.kv[c]\\n        return res\\n    \\n\\n    def decrypt(self, w: str) -> int:\\n        adj = []\\n        for i in range(2, len(w)+1, 2):\\n            cur = w[i-2:i]\\n            if cur not in self.vk:\\n                return 0\\n            adj.append(self.vk[cur])\\n                \\n        res = 0\\n        for d in self.dick:\\n            if len(d) != len(adj):\\n                continue\\n                \\n            ok = True\\n            for i in range(len(d)):\\n                if d[i] not in adj[i]:\\n                    ok = False\\n                    break\\n            if ok:\\n                res += 1\\n        \\n        return res\\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {}\\n        self.vk = {}\\n        for i in range(len(keys)):\\n            k, v = keys[i], values[i]\\n            self.kv[k] = values[i]\\n            \\n            if v not in self.vk:\\n                self.vk[v] = set()\\n                \\n            self.vk[v].add(k)\\n            \\n        self.dick = dictionary\\n\\n        \\n    def encrypt(self, w: str) -> str:\\n        res = \"\"\\n        for c in w:\\n            res += self.kv[c]\\n        return res\\n    \\n\\n    def decrypt(self, w: str) -> int:\\n        adj = []\\n        for i in range(2, len(w)+1, 2):\\n            cur = w[i-2:i]\\n            if cur not in self.vk:\\n                return 0\\n            adj.append(self.vk[cur])\\n                \\n        res = 0\\n        for d in self.dick:\\n            if len(d) != len(adj):\\n                continue\\n                \\n            ok = True\\n            for i in range(len(d)):\\n                if d[i] not in adj[i]:\\n                    ok = False\\n                    break\\n            if ok:\\n                res += 1\\n        \\n        return res\\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908901,
                "title": "java-dfs-trie",
                "content": "This is the first time I completed all four problems~~~!!!\\n```\\nclass Encrypter {\\n    Map<Character,String> enMap;\\n    Map<String, List<Character>> deMap;\\n    Set<String> dict;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enMap = new HashMap<>();\\n        this.deMap = new HashMap<>();\\n        this.dict = new HashSet<>();\\n        \\n        for(int i = 0; i < keys.length; i++) {\\n            enMap.put(keys[i], values[i]);\\n            if(!deMap.containsKey(values[i])) {\\n                deMap.put(values[i], new ArrayList<>());\\n            }\\n            deMap.get(values[i]).add(keys[i]);\\n        }   \\n        \\n        for(String str : dictionary) {\\n            dict.add(str);\\n        }  \\n        \\n        this.root = new TrieNode();\\n        for(String str : dictionary){\\n            root.insert(root, str);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sol = new StringBuilder();\\n        for(char ch : word1.toCharArray()) {\\n            sol.append(enMap.get(ch));\\n        }\\n        return sol.toString();\\n    } \\n    \\n    public int decrypt(String word2) {\\n        int[] res = {0};\\n        StringBuilder sol = new StringBuilder();\\n        TrieNode curRoot = root;\\n        \\n        dfs(word2, curRoot, 0, sol, deMap, dict, res);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String word, TrieNode curRoot, int index, StringBuilder sol, Map<String, List<Character>> deMap, Set<String> dict, int[] res) {\\n        \\n        if(index >= word.length() - 1) {\\n            String temp = sol.toString();\\n            if(dict.contains(temp)) {\\n                res[0]++;\\n            }\\n            return;\\n        }\\n        \\n        String cur = word.substring(index, index + 2);\\n        \\n        List<Character> list = deMap.get(cur);\\n        int len = sol.length();\\n        if(list == null) {\\n            sol.append(cur);\\n            dfs(word, curRoot, index + 2, sol, deMap, dict, res);\\n            sol.setLength(len);\\n        } else {\\n            for(char c : list) {\\n                if(curRoot.children[c - \\'a\\'] == null) {\\n                    continue;\\n                }\\n                sol.append(c);\\n                dfs(word, curRoot.children[c -\\'a\\'], index + 2, sol, deMap, dict, res);\\n                sol.setLength(len);\\n            }\\n        }    \\n    }\\n    \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] children;\\n        public TrieNode() {\\n            this.isWord = false;\\n            this.children = new TrieNode[26];\\n        }\\n        \\n        public TrieNode insert(TrieNode root, String word) {\\n            TrieNode cur = root;\\n            \\n            for(int i = 0; i < word.length(); i++) {\\n                if(cur.children[word.charAt(i) - \\'a\\'] == null) {\\n                    cur.children[word.charAt(i) - \\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.children[word.charAt(i) - \\'a\\'];\\n            }\\n            cur.isWord = true;\\n            return root;\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> enMap;\\n    Map<String, List<Character>> deMap;\\n    Set<String> dict;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enMap = new HashMap<>();\\n        this.deMap = new HashMap<>();\\n        this.dict = new HashSet<>();\\n        \\n        for(int i = 0; i < keys.length; i++) {\\n            enMap.put(keys[i], values[i]);\\n            if(!deMap.containsKey(values[i])) {\\n                deMap.put(values[i], new ArrayList<>());\\n            }\\n            deMap.get(values[i]).add(keys[i]);\\n        }   \\n        \\n        for(String str : dictionary) {\\n            dict.add(str);\\n        }  \\n        \\n        this.root = new TrieNode();\\n        for(String str : dictionary){\\n            root.insert(root, str);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sol = new StringBuilder();\\n        for(char ch : word1.toCharArray()) {\\n            sol.append(enMap.get(ch));\\n        }\\n        return sol.toString();\\n    } \\n    \\n    public int decrypt(String word2) {\\n        int[] res = {0};\\n        StringBuilder sol = new StringBuilder();\\n        TrieNode curRoot = root;\\n        \\n        dfs(word2, curRoot, 0, sol, deMap, dict, res);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String word, TrieNode curRoot, int index, StringBuilder sol, Map<String, List<Character>> deMap, Set<String> dict, int[] res) {\\n        \\n        if(index >= word.length() - 1) {\\n            String temp = sol.toString();\\n            if(dict.contains(temp)) {\\n                res[0]++;\\n            }\\n            return;\\n        }\\n        \\n        String cur = word.substring(index, index + 2);\\n        \\n        List<Character> list = deMap.get(cur);\\n        int len = sol.length();\\n        if(list == null) {\\n            sol.append(cur);\\n            dfs(word, curRoot, index + 2, sol, deMap, dict, res);\\n            sol.setLength(len);\\n        } else {\\n            for(char c : list) {\\n                if(curRoot.children[c - \\'a\\'] == null) {\\n                    continue;\\n                }\\n                sol.append(c);\\n                dfs(word, curRoot.children[c -\\'a\\'], index + 2, sol, deMap, dict, res);\\n                sol.setLength(len);\\n            }\\n        }    \\n    }\\n    \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] children;\\n        public TrieNode() {\\n            this.isWord = false;\\n            this.children = new TrieNode[26];\\n        }\\n        \\n        public TrieNode insert(TrieNode root, String word) {\\n            TrieNode cur = root;\\n            \\n            for(int i = 0; i < word.length(); i++) {\\n                if(cur.children[word.charAt(i) - \\'a\\'] == null) {\\n                    cur.children[word.charAt(i) - \\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.children[word.charAt(i) - \\'a\\'];\\n            }\\n            cur.isWord = true;\\n            return root;\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908887,
                "title": "c-rainbow-table-solution-and-trie-solution",
                "content": "#### rainbow table \\nA [rainbow table](https://en.wikipedia.org/wiki/Rainbow_table) is a precomputed table for caching the output of cryptographic hash functions, usually for cracking password hashes. \\n```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    unordered_map<string,int> m; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& s : dictionary) {\\n            m[encrypt(s)]++; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return m[word2];\\n    }\\n};\\n\\n```\\n#### Trie solution \\n```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    class Node {\\n    public:\\n        bool leaf = false; \\n        vector<Node*> children;\\n        Node() : leaf{false}, children(26,nullptr) {}\\n    };\\n    class Trie {\\n    public:\\n        Node* root = new Node(); \\n        void insert(const string& str) {\\n            auto t = root; \\n            for(char ch : str) {\\n                if(t->children[ch - \\'a\\'] == nullptr) {\\n                    t->children[ch-\\'a\\'] = new Node(); \\n                }\\n                t = t->children[ch-\\'a\\'];\\n            }\\n            t->leaf = true; \\n        }\\n    };\\n    Trie trie; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& str : dictionary) {\\n            trie.insert(str);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    int f(Node* node, const string& word2, int i) {\\n        if(node == nullptr) {\\n            return 0; \\n        }\\n        if(i == word2.size()) {\\n            if(node->leaf) {\\n                return 1;\\n            }\\n            return 0; \\n        }\\n        auto v = word2.substr(i,2);\\n        int ret = 0; \\n        for(int k : v2k[v]) {\\n            ret += f(node->children[k],word2,i+2);\\n        }\\n        return ret; \\n    }\\n    int decrypt(string word2) {\\n        return f(trie.root,word2,0); \\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    unordered_map<string,int> m; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& s : dictionary) {\\n            m[encrypt(s)]++; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return m[word2];\\n    }\\n};\\n\\n```\n```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    class Node {\\n    public:\\n        bool leaf = false; \\n        vector<Node*> children;\\n        Node() : leaf{false}, children(26,nullptr) {}\\n    };\\n    class Trie {\\n    public:\\n        Node* root = new Node(); \\n        void insert(const string& str) {\\n            auto t = root; \\n            for(char ch : str) {\\n                if(t->children[ch - \\'a\\'] == nullptr) {\\n                    t->children[ch-\\'a\\'] = new Node(); \\n                }\\n                t = t->children[ch-\\'a\\'];\\n            }\\n            t->leaf = true; \\n        }\\n    };\\n    Trie trie; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& str : dictionary) {\\n            trie.insert(str);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    int f(Node* node, const string& word2, int i) {\\n        if(node == nullptr) {\\n            return 0; \\n        }\\n        if(i == word2.size()) {\\n            if(node->leaf) {\\n                return 1;\\n            }\\n            return 0; \\n        }\\n        auto v = word2.substr(i,2);\\n        int ret = 0; \\n        for(int k : v2k[v]) {\\n            ret += f(node->children[k],word2,i+2);\\n        }\\n        return ret; \\n    }\\n    int decrypt(string word2) {\\n        return f(trie.root,word2,0); \\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1908884,
                "title": "c-trie",
                "content": "```\\nclass TrieNode {\\npublic: \\n    TrieNode* next[26];\\n    bool is_word;\\n    TrieNode() {memset(next, 0, sizeof(next)); is_word = false;}\\n};\\n\\nclass Trie {\\npublic: \\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    TrieNode* getRoot()\\n    {\\n        return root;\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode* cur = root;\\n        for (auto c : word)\\n        {\\n            if (!cur->next[c - \\'a\\'])\\n                cur->next[c - \\'a\\'] = new TrieNode();\\n            cur = cur->next[c - \\'a\\'];\\n        }\\n        cur->is_word = true;\\n    }\\n    \\n    TrieNode* find(char c, TrieNode* node)\\n    {\\n        if (node->next[c - \\'a\\'])\\n            return node->next[c - \\'a\\'];\\n        else \\n            return nullptr;\\n    }\\n    \\nprivate: \\n    TrieNode* root;\\n};\\n\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n = keys.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            k2v[keys[i]] = values[i];\\n            v2k[values[i]].push_back(keys[i]);\\n        }\\n        trie = new Trie();\\n        for (auto& s : dictionary)\\n            trie->insert(s);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for (auto& c : word1)\\n            ans += k2v[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int n = word2.length(), m = n / 2;\\n        vector<vector<char>> k(m);\\n        for (int i = 0, j = 0; i < n; i += 2, j++)\\n        {\\n            k[j] = v2k[word2.substr(i, 2)];\\n            if (k[j].size() == 0)\\n                return 0;\\n        }\\n        int ans = 0;\\n        dfs(k, 0, m, trie->getRoot(), ans);\\n        return ans;\\n    }\\n    \\nprivate: \\n    unordered_map<char, string> k2v;\\n    unordered_map<string, vector<char>> v2k;\\n    Trie* trie;\\n    \\n    void dfs(vector<vector<char>>& k, int r, int& m, TrieNode* cur, int& ans)\\n    {\\n        if (r == m)\\n        {\\n            if (cur->is_word)\\n                ans++;\\n            return;\\n        }\\n        for (auto& c : k[r])\\n        {\\n            TrieNode* nxt = trie->find(c, cur);\\n            if (nxt)\\n                dfs(k, r + 1, m, nxt, ans);\\n        }\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\npublic: \\n    TrieNode* next[26];\\n    bool is_word;\\n    TrieNode() {memset(next, 0, sizeof(next)); is_word = false;}\\n};\\n\\nclass Trie {\\npublic: \\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    TrieNode* getRoot()\\n    {\\n        return root;\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode* cur = root;\\n        for (auto c : word)\\n        {\\n            if (!cur->next[c - \\'a\\'])\\n                cur->next[c - \\'a\\'] = new TrieNode();\\n            cur = cur->next[c - \\'a\\'];\\n        }\\n        cur->is_word = true;\\n    }\\n    \\n    TrieNode* find(char c, TrieNode* node)\\n    {\\n        if (node->next[c - \\'a\\'])\\n            return node->next[c - \\'a\\'];\\n        else \\n            return nullptr;\\n    }\\n    \\nprivate: \\n    TrieNode* root;\\n};\\n\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n = keys.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            k2v[keys[i]] = values[i];\\n            v2k[values[i]].push_back(keys[i]);\\n        }\\n        trie = new Trie();\\n        for (auto& s : dictionary)\\n            trie->insert(s);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for (auto& c : word1)\\n            ans += k2v[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int n = word2.length(), m = n / 2;\\n        vector<vector<char>> k(m);\\n        for (int i = 0, j = 0; i < n; i += 2, j++)\\n        {\\n            k[j] = v2k[word2.substr(i, 2)];\\n            if (k[j].size() == 0)\\n                return 0;\\n        }\\n        int ans = 0;\\n        dfs(k, 0, m, trie->getRoot(), ans);\\n        return ans;\\n    }\\n    \\nprivate: \\n    unordered_map<char, string> k2v;\\n    unordered_map<string, vector<char>> v2k;\\n    Trie* trie;\\n    \\n    void dfs(vector<vector<char>>& k, int r, int& m, TrieNode* cur, int& ans)\\n    {\\n        if (r == m)\\n        {\\n            if (cur->is_word)\\n                ans++;\\n            return;\\n        }\\n        for (auto& c : k[r])\\n        {\\n            TrieNode* nxt = trie->find(c, cur);\\n            if (nxt)\\n                dfs(k, r + 1, m, nxt, ans);\\n        }\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908873,
                "title": "c-clean-commented-code",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map <char, string> mp; // Will be used while encrypting. \\n    unordered_map <string, unordered_set<char>> allTwotoOne; // stores for each string of len 2, possible characteres it can map to\\n    unordered_set <string> dict; // our dictionary which includes valid words after decrypting.\\n\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            mp[keys[i]] = values[i]; // will be used in encryption.\\n        }\\n        for (int i = 0; i < values.size(); ++i) {\\n            allTwotoOne[values[i]].insert(keys[i]); // all possible chars which this encrypted 2 len string can decrpt to.\\n        }\\n        for (auto x : dictionary) {\\n            dict.insert(x);   // just making it global.\\n        }\\n    }   \\n    \\n    /*\\n        We can use mp to just replace each character with susbtrs of len 2.\\n    */\\n\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (auto x : word1) {\\n            res += mp[x];\\n        }\\n        return res;\\n    }\\n    /*\\n        Returns the number of possible strings word2 could decrypt to that also appear in dictionary.\\n    */\\n    int decrypt(string word2) {\\n        int ways = 0;\\n        int enc_len = word2.size() / 2;\\n        // check for each word in dictionary, can it be formed while decyrpting string in given manner.\\n        for (auto x : dict) { \\n            if (x.size() != enc_len) continue; // prune as fast as possible.\\n            int i = 0;\\n            int can = 1;\\n            for (auto ch : x) {\\n                if (!allTwotoOne[word2.substr(i, 2)].count(ch)) { // if this 2 len substr cant decrypt to the current char of current string in dict, then break(prune)\\n                    can = 0;\\n                    break;\\n                } else { // go to next 2 len substr.\\n                    i += 2;\\n                }\\n            }\\n            ways += can;\\n        }\\n        return ways;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```\\n\\nUPvote if you liked my solution.\\nThanks.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map <char, string> mp; // Will be used while encrypting. \\n    unordered_map <string, unordered_set<char>> allTwotoOne; // stores for each string of len 2, possible characteres it can map to\\n    unordered_set <string> dict; // our dictionary which includes valid words after decrypting.\\n\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            mp[keys[i]] = values[i]; // will be used in encryption.\\n        }\\n        for (int i = 0; i < values.size(); ++i) {\\n            allTwotoOne[values[i]].insert(keys[i]); // all possible chars which this encrypted 2 len string can decrpt to.\\n        }\\n        for (auto x : dictionary) {\\n            dict.insert(x);   // just making it global.\\n        }\\n    }   \\n    \\n    /*\\n        We can use mp to just replace each character with susbtrs of len 2.\\n    */\\n\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (auto x : word1) {\\n            res += mp[x];\\n        }\\n        return res;\\n    }\\n    /*\\n        Returns the number of possible strings word2 could decrypt to that also appear in dictionary.\\n    */\\n    int decrypt(string word2) {\\n        int ways = 0;\\n        int enc_len = word2.size() / 2;\\n        // check for each word in dictionary, can it be formed while decyrpting string in given manner.\\n        for (auto x : dict) { \\n            if (x.size() != enc_len) continue; // prune as fast as possible.\\n            int i = 0;\\n            int can = 1;\\n            for (auto ch : x) {\\n                if (!allTwotoOne[word2.substr(i, 2)].count(ch)) { // if this 2 len substr cant decrypt to the current char of current string in dict, then break(prune)\\n                    can = 0;\\n                    break;\\n                } else { // go to next 2 len substr.\\n                    i += 2;\\n                }\\n            }\\n            ways += can;\\n        }\\n        return ways;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908865,
                "title": "java-hashing-easy-to-understand-smart-approach",
                "content": "**Here I am discussing my approach to this problem**\\n**Approach:**\\n1. Create an `enc` map which **stores the key value pair** of what each character will **encrypt** to.\\n2. Create a `dictionary` map which will **store the count of each encrypted word** from the `dictionary` string.\\n3. In `encrypt` function, we just take each character from `word1`, and use `enc` map to **encrypt** it.\\n4. In `decrypt` function, we just return the **count of each** `word2` from `dictionary` map.\\n\\n**Source Code:**\\n```\\nclass Encrypter {\\n    Map<Character, String> enc;\\n    Map<String, Integer> dictionary;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enc = new HashMap<>();\\n        this.dictionary = new HashMap<>();\\n        \\n        for(int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        for(String v : dictionary) {\\n            StringBuilder sb = new StringBuilder();\\n            \\n            for(char ch : v.toCharArray())\\n                sb.append(enc.get(ch));\\n            \\n            this.dictionary.put(sb.toString(), this.dictionary.getOrDefault(sb.toString(), 0) + 1);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char ch : word1.toCharArray())\\n            sb.append(enc.get(ch));\\n        \\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```\\n\\n**Complexity Analysis:**\\n```\\nTime Complexity: O(c * n) // c = number of calls, n = word.length\\nSpace Complexity : O(m) // m = number of dictionary words\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character, String> enc;\\n    Map<String, Integer> dictionary;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enc = new HashMap<>();\\n        this.dictionary = new HashMap<>();\\n        \\n        for(int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        for(String v : dictionary) {\\n            StringBuilder sb = new StringBuilder();\\n            \\n            for(char ch : v.toCharArray())\\n                sb.append(enc.get(ch));\\n            \\n            this.dictionary.put(sb.toString(), this.dictionary.getOrDefault(sb.toString(), 0) + 1);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char ch : word1.toCharArray())\\n            sb.append(enc.get(ch));\\n        \\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```\n```\\nTime Complexity: O(c * n) // c = number of calls, n = word.length\\nSpace Complexity : O(m) // m = number of dictionary words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908853,
                "title": "hashmap-solution-o-n-encrypt-o-1-decrypt",
                "content": "pre-built dictionary to encrypt string\\n\\n```\\nclass Encrypter {\\n\\n    Map<Character, String> keyValueMap = new HashMap<>();\\n    Map<String, Integer> encryptCntMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0; i < keys.length; i++) {\\n            keyValueMap.put(keys[i], values[i]);\\n        }\\n\\n        for (String s : dictionary) {\\n            String enc = this.encrypt(s);\\n            encryptCntMap.put(enc, encryptCntMap.getOrDefault(enc, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < word1.length(); i++) {\\n            sb.append(keyValueMap.get(word1.charAt(i)));\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return encryptCntMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n\\n    Map<Character, String> keyValueMap = new HashMap<>();\\n    Map<String, Integer> encryptCntMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0; i < keys.length; i++) {\\n            keyValueMap.put(keys[i], values[i]);\\n        }\\n\\n        for (String s : dictionary) {\\n            String enc = this.encrypt(s);\\n            encryptCntMap.put(enc, encryptCntMap.getOrDefault(enc, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < word1.length(); i++) {\\n            sb.append(keyValueMap.get(word1.charAt(i)));\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return encryptCntMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908836,
                "title": "easy-understand-code-no-dfs-no-trie-simple-logic",
                "content": "public class Encrypter {\\n\\n    HashSet<string> pString;\\n    // dictionary used for encryption\\n    Dictionary<string, HashSet<char>> rDict = new Dictionary<string, HashSet<char>>();\\n    // dictionary used for decryption\\n    Dictionary<char, string> fDict = new Dictionary<char, string>();\\n        \\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        pString = new HashSet<string>(dictionary);\\n        for (int i = 0; i < keys.Length; i++){\\n            fDict.Add(keys[i], values[i]);\\n            if (!rDict.ContainsKey(values[i]))\\n                rDict.Add(values[i], new HashSet<char>());\\n            rDict[values[i]].Add(keys[i]);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string output = \"\";\\n        foreach (char c in word1){\\n            output += fDict[c];\\n        }\\n        return output;\\n    }\\n    \\n    // Because the dictionary is smaller than 100, we basically just loop the dictionary for each number, worst time is just 100 * 100\\n    public int Decrypt(string word2) {\\n        List<string> hs = new List<string>(pString);\\n        int len = word2.Length / 2;\\n        for (int i = 0; i < len; i++){\\n            string str = word2.Substring(i*2, 2);\\n            if (!rDict.ContainsKey(str))\\n                return 0;\\n            HashSet<char> ch = rDict[str];\\n            List<string> temp = new List<string>();\\n            foreach (string h in hs){\\n                if (h.Length > i && ch.Contains(h[i]))\\n                    temp.Add(h);\\n            }\\n            if (temp.Count == 0)\\n                return 0;\\n            hs = temp;\\n        }\\n        List<string> output = new List<string>();\\n        foreach (string k in hs){\\n            if (k.Length == len)\\n                output.Add(k);\\n        }\\n\\n        return output.Count;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */",
                "solutionTags": [],
                "code": "public class Encrypter {\\n\\n    HashSet<string> pString;\\n    // dictionary used for encryption\\n    Dictionary<string, HashSet<char>> rDict = new Dictionary<string, HashSet<char>>();\\n    // dictionary used for decryption\\n    Dictionary<char, string> fDict = new Dictionary<char, string>();\\n        \\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        pString = new HashSet<string>(dictionary);\\n        for (int i = 0; i < keys.Length; i++){\\n            fDict.Add(keys[i], values[i]);\\n            if (!rDict.ContainsKey(values[i]))\\n                rDict.Add(values[i], new HashSet<char>());\\n            rDict[values[i]].Add(keys[i]);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string output = \"\";\\n        foreach (char c in word1){\\n            output += fDict[c];\\n        }\\n        return output;\\n    }\\n    \\n    // Because the dictionary is smaller than 100, we basically just loop the dictionary for each number, worst time is just 100 * 100\\n    public int Decrypt(string word2) {\\n        List<string> hs = new List<string>(pString);\\n        int len = word2.Length / 2;\\n        for (int i = 0; i < len; i++){\\n            string str = word2.Substring(i*2, 2);\\n            if (!rDict.ContainsKey(str))\\n                return 0;\\n            HashSet<char> ch = rDict[str];\\n            List<string> temp = new List<string>();\\n            foreach (string h in hs){\\n                if (h.Length > i && ch.Contains(h[i]))\\n                    temp.Add(h);\\n            }\\n            if (temp.Count == 0)\\n                return 0;\\n            hs = temp;\\n        }\\n        List<string> output = new List<string>();\\n        foreach (string k in hs){\\n            if (k.Length == len)\\n                output.Add(k);\\n        }\\n\\n        return output.Count;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1908770,
                "title": "python-not-hard-but-confusing",
                "content": "That is, the way this question is worded. We are supposed to use the encryption function we have written to descript efficiently. That\\'s sort of the hint (otherwise it\\'s trivial to code the encryption).\\n\\n```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h = collections.defaultdict(str)\\n        for k, v in zip(keys, values):\\n            self.h[k] = v\\n        self.dictionary = set(dictionary)\\n        \\n\\n    def encrypt(self, word1):\\n        ans = \\'\\'\\n        for x in word1:\\n            if not self.h[x]:\\n                ans += x\\n            else:\\n                ans += self.h[x]\\n        return ans\\n\\n    \\n    def decrypt(self, word2):\\n        ans = 0\\n        for word in self.dictionary:\\n            if self.encrypt(word) == word2:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h = collections.defaultdict(str)\\n        for k, v in zip(keys, values):\\n            self.h[k] = v\\n        self.dictionary = set(dictionary)\\n        \\n\\n    def encrypt(self, word1):\\n        ans = \\'\\'\\n        for x in word1:\\n            if not self.h[x]:\\n                ans += x\\n            else:\\n                ans += self.h[x]\\n        return ans\\n\\n    \\n    def decrypt(self, word2):\\n        ans = 0\\n        for word in self.dictionary:\\n            if self.encrypt(word) == word2:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908735,
                "title": "easy-to-understand-solution-c-unordered-maps",
                "content": "Firstly, we will store all the information present with us in a hashmap so that we can retrieve them faster. The two arrays Keys[] and Values[] can be stored in a single hashmap\\n\\nThe encrypt function is easy to implement. Just traverse through the string \\u2018word1\\u2019 and replace each character with its corresponding value string.\\n\\nThe decrypt function needs only one trick to implement. One may think we can recursively form all the possible strings by taking characters in pairs and encrypt these pairs but this will have a polynomial time complexity since a given pair may have one or more encryption characters.\\n\\n**But we can be a little smart in doing this. Instead of finding all the decryption strings of the given string and check how many of those are present in the dictionary array, we can encrypt all the strings present in the dictionary array, maintain their count using a frequency hashmap and finally check how any time the string \\u2018word2\\u2019 exist in this frequency map. **\\n\\n\\n```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        // storing all the characters along with their encryption keys\\n\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];\\n        }\\n        \\n        // iterating through the string in the dictionary, encrypting them and maintaining a frequency hashmap m2\\n        \\n        for(auto i:dictionary)\\n        {\\n            string ans=\"\";\\n            \\n            string word1=i;\\n        \\n            for(int i=0;i<word1.size();i++)\\n            {\\n                ans+=m1[word1[i]];\\n            }\\n\\n            if(m2.find(ans)==m2.end())\\n            {\\n                m2[ans]=1;\\n            }\\n            else{\\n                m2[ans]++;\\n            }\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        // simple encryption\\n        \\n        string ans=\"\";\\n        \\n        for(int i=0;i<word1.size();i++)\\n        {\\n            ans+=m1[word1[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        // return the frequency of the word2 in the hashmap m2\\n        \\n        if(m2.find(word2)==m2.end())\\n        {\\n            return 0;\\n        }\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        // storing all the characters along with their encryption keys\\n\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];\\n        }\\n        \\n        // iterating through the string in the dictionary, encrypting them and maintaining a frequency hashmap m2\\n        \\n        for(auto i:dictionary)\\n        {\\n            string ans=\"\";\\n            \\n            string word1=i;\\n        \\n            for(int i=0;i<word1.size();i++)\\n            {\\n                ans+=m1[word1[i]];\\n            }\\n\\n            if(m2.find(ans)==m2.end())\\n            {\\n                m2[ans]=1;\\n            }\\n            else{\\n                m2[ans]++;\\n            }\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        // simple encryption\\n        \\n        string ans=\"\";\\n        \\n        for(int i=0;i<word1.size();i++)\\n        {\\n            ans+=m1[word1[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        // return the frequency of the word2 in the hashmap m2\\n        \\n        if(m2.find(word2)==m2.end())\\n        {\\n            return 0;\\n        }\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908733,
                "title": "cpp-straight-forward-solution",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> lookup;\\n    vector<string> dict;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict = dictionary;\\n        for(int i = 0; i < keys.size(); i++) {\\n            lookup[keys[i]] = values[i];\\n        }\\n        \\n    }\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for(auto key : word1) res += lookup[key];\\n        return res;\\n    }\\n    \\n    //generate all decrypted words from words in dictonary\\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        for(auto word : dict) {\\n            string s = \"\";\\n            for(auto key : word) {\\n                s += lookup[key];\\n            }\\n            \\n            if(s == word2) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> lookup;\\n    vector<string> dict;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict = dictionary;\\n        for(int i = 0; i < keys.size(); i++) {\\n            lookup[keys[i]] = values[i];\\n        }\\n        \\n    }\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for(auto key : word1) res += lookup[key];\\n        return res;\\n    }\\n    \\n    //generate all decrypted words from words in dictonary\\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        for(auto word : dict) {\\n            string s = \"\";\\n            for(auto key : word) {\\n                s += lookup[key];\\n            }\\n            \\n            if(s == word2) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018573,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    map: HashMap<char, String>,\\n    dictionary: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let map: HashMap<char, String> = keys.into_iter().zip(values.into_iter()).collect();\\n        let mut ret = Self { map, dictionary: HashMap::new() };\\n\\n        ret.dictionary = dictionary.into_iter().fold(HashMap::new(), |mut dict, word| {\\n            let word = ret.encrypt(word);\\n            if !word.is_empty() {\\n                dict.entry(word).and_modify(|e| *e += 1).or_insert(1);\\n            }\\n            dict\\n        });\\n        ret\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ret = String::new();\\n        for c in word1.chars() {\\n            if let Some(s) = self.map.get(&c) {\\n                ret.push_str(s.as_str());\\n            } else {\\n                return String::new();\\n            }\\n        }\\n        ret\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 { self.dictionary.get(&word2).cloned().unwrap_or(0) }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    map: HashMap<char, String>,\\n    dictionary: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let map: HashMap<char, String> = keys.into_iter().zip(values.into_iter()).collect();\\n        let mut ret = Self { map, dictionary: HashMap::new() };\\n\\n        ret.dictionary = dictionary.into_iter().fold(HashMap::new(), |mut dict, word| {\\n            let word = ret.encrypt(word);\\n            if !word.is_empty() {\\n                dict.entry(word).and_modify(|e| *e += 1).or_insert(1);\\n            }\\n            dict\\n        });\\n        ret\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ret = String::new();\\n        for c in word1.chars() {\\n            if let Some(s) = self.map.get(&c) {\\n                ret.push_str(s.as_str());\\n            } else {\\n                return String::new();\\n            }\\n        }\\n        ret\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 { self.dictionary.get(&word2).cloned().unwrap_or(0) }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996812,
                "title": "2-typescript-javascript-solutions-reverse-lookup-and-trie",
                "content": "# Code\\n\\n## Using Reverse Lookup (~200ms)\\n(Encrypt all dictionary words and lookup count during decryption.)\\n```\\nclass Encrypter {\\n  private keysToValues: { [key: string]: string } = {};\\n  private encryptionCount: { [word: string]: number } = {};\\n  \\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    for (let i = 0; i < keys.length; i++) {\\n      this.keysToValues[keys[i]] = values[i];\\n    }\\n    for (const word of dictionary) {\\n      const encrypted = this.encrypt(word);\\n      this.encryptionCount[encrypted] ??= 0;\\n      this.encryptionCount[encrypted]++;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    return this.encryptionCount[word2] ?? 0;\\n  }\\n}\\n```\\n\\n## Using Trie (~1500ms)\\n(Probably the intended solution.)\\n```\\nclass Encrypter {\\n  private trie: TrieNode;\\n  private keysToValues: { [key: string]: string } = {};\\n  private valuesToKeys: { [value: string]: string[] } = {};\\n\\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    this.trie = buildTrie(dictionary);\\n    for (let i = 0; i < keys.length; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.keysToValues[key] = value;\\n      const arr = this.valuesToKeys[value] ?? [];\\n      arr.push(key);\\n      this.valuesToKeys[value] = arr;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    const possible = [this.trie];\\n    for (let i = 0; i <= word2.length - 2; i += 2) {\\n      for (const trieNode of possible.splice(0, possible.length)) {\\n        for (const key of this.valuesToKeys[word2.slice(i, i + 2)] ?? []) {\\n          const nextNode = trieNode.children[key];\\n          if (nextNode) possible.push(nextNode);\\n        }\\n      }\\n      if (possible.length === 0) break;\\n    }\\n    return possible.filter(({ leaf }) => leaf).length;\\n  }\\n}\\n\\ninterface TrieNode {\\n  char: string;\\n  leaf: boolean;\\n  children: { [char: string]: TrieNode };\\n}\\n\\nconst buildTrie = (\\n  words: string[],\\n  parent: TrieNode = { char: \"\", leaf: false, children: {} }\\n) => {\\n  const wordMap: { [char: string]: string[] } = {};\\n  for (const word of words) {\\n    if (word === \"\") {\\n      parent.leaf = true;\\n      continue;\\n    }\\n    const char = word[0];\\n    const arr = wordMap[char] ?? [];\\n    arr.push(word.slice(1));\\n    wordMap[char] = arr;\\n  }\\n  for (const [char, words] of Object.entries(wordMap)) {\\n    const trieNode = {\\n      char,\\n      leaf: false,\\n      children: {},\\n    };\\n    buildTrie(words, trieNode);\\n    parent.children[char] = trieNode;\\n  }\\n  return parent;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n  private keysToValues: { [key: string]: string } = {};\\n  private encryptionCount: { [word: string]: number } = {};\\n  \\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    for (let i = 0; i < keys.length; i++) {\\n      this.keysToValues[keys[i]] = values[i];\\n    }\\n    for (const word of dictionary) {\\n      const encrypted = this.encrypt(word);\\n      this.encryptionCount[encrypted] ??= 0;\\n      this.encryptionCount[encrypted]++;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    return this.encryptionCount[word2] ?? 0;\\n  }\\n}\\n```\n```\\nclass Encrypter {\\n  private trie: TrieNode;\\n  private keysToValues: { [key: string]: string } = {};\\n  private valuesToKeys: { [value: string]: string[] } = {};\\n\\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    this.trie = buildTrie(dictionary);\\n    for (let i = 0; i < keys.length; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.keysToValues[key] = value;\\n      const arr = this.valuesToKeys[value] ?? [];\\n      arr.push(key);\\n      this.valuesToKeys[value] = arr;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    const possible = [this.trie];\\n    for (let i = 0; i <= word2.length - 2; i += 2) {\\n      for (const trieNode of possible.splice(0, possible.length)) {\\n        for (const key of this.valuesToKeys[word2.slice(i, i + 2)] ?? []) {\\n          const nextNode = trieNode.children[key];\\n          if (nextNode) possible.push(nextNode);\\n        }\\n      }\\n      if (possible.length === 0) break;\\n    }\\n    return possible.filter(({ leaf }) => leaf).length;\\n  }\\n}\\n\\ninterface TrieNode {\\n  char: string;\\n  leaf: boolean;\\n  children: { [char: string]: TrieNode };\\n}\\n\\nconst buildTrie = (\\n  words: string[],\\n  parent: TrieNode = { char: \"\", leaf: false, children: {} }\\n) => {\\n  const wordMap: { [char: string]: string[] } = {};\\n  for (const word of words) {\\n    if (word === \"\") {\\n      parent.leaf = true;\\n      continue;\\n    }\\n    const char = word[0];\\n    const arr = wordMap[char] ?? [];\\n    arr.push(word.slice(1));\\n    wordMap[char] = arr;\\n  }\\n  for (const [char, words] of Object.entries(wordMap)) {\\n    const trieNode = {\\n      char,\\n      leaf: false,\\n      children: {},\\n    };\\n    buildTrie(words, trieNode);\\n    parent.children[char] = trieNode;\\n  }\\n  return parent;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958315,
                "title": "encrypt-decrypt-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Time:  ctor:    O(m + d), m is len(keys), d is sum(len(x) for x in dictionary)\\n//        encrypt: O(n)\\n//        decrypt: O(n)\\n// Space: O(m + d)\\n\\n// freq table\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < size(keys); ++i) {\\n            lookup_[keys[i]] = values[i];\\n        }\\n        for (const auto& x : dictionary) {\\n            ++cnt_[encrypt(x)];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (const auto& c : word1) {\\n            if (!lookup_.count(c)) {\\n                return \"\";\\n            }\\n            result += lookup_[c];\\n        }\\n        return result;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt_[word2];\\n    }\\n\\nprivate:\\n    unordered_map<char, string> lookup_;\\n    unordered_map<string, int> cnt_;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Design",
                    "Trie"
                ],
                "code": "```\\n// Time:  ctor:    O(m + d), m is len(keys), d is sum(len(x) for x in dictionary)\\n//        encrypt: O(n)\\n//        decrypt: O(n)\\n// Space: O(m + d)\\n\\n// freq table\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < size(keys); ++i) {\\n            lookup_[keys[i]] = values[i];\\n        }\\n        for (const auto& x : dictionary) {\\n            ++cnt_[encrypt(x)];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (const auto& c : word1) {\\n            if (!lookup_.count(c)) {\\n                return \"\";\\n            }\\n            result += lookup_[c];\\n        }\\n        return result;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt_[word2];\\n    }\\n\\nprivate:\\n    unordered_map<char, string> lookup_;\\n    unordered_map<string, int> cnt_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899951,
                "title": "typescript-hash-table-time-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\n    private _keyMap: Map<string, string>;\\n    private _decryptedWordMap: Map<string, number>;\\n\\n    constructor(keys: string[], values: string[], dictionary: string[]) {\\n        this._keyMap = new Map();\\n        this._decryptedWordMap = new Map();\\n\\n        keys.forEach((key, i) => {\\n            this._keyMap.set(key, values[i]);\\n        });\\n\\n        dictionary.forEach((word) => {\\n            const decryptedWord = this.encrypt(word);\\n            const decryptedWordNum = this._decryptedWordMap.get(decryptedWord);\\n\\n            if (decryptedWordNum !== undefined)\\n                this._decryptedWordMap.set(decryptedWord, decryptedWordNum + 1);\\n            else\\n                this._decryptedWordMap.set(decryptedWord, 1);\\n        });\\n    }\\n\\n    encrypt(word1: string): string {\\n        let decryptedWord1 = \"\";\\n\\n        word1.split(\"\").forEach((char) => {\\n            decryptedWord1 += this._keyMap.get(char);\\n        });\\n\\n        return decryptedWord1;\\n    }\\n\\n    decrypt(word2: string): number {\\n        const decryptedWordNum = this._decryptedWordMap.get(word2);\\n\\n        if (decryptedWordNum)\\n            return decryptedWordNum\\n        else\\n            return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter {\\n    private _keyMap: Map<string, string>;\\n    private _decryptedWordMap: Map<string, number>;\\n\\n    constructor(keys: string[], values: string[], dictionary: string[]) {\\n        this._keyMap = new Map();\\n        this._decryptedWordMap = new Map();\\n\\n        keys.forEach((key, i) => {\\n            this._keyMap.set(key, values[i]);\\n        });\\n\\n        dictionary.forEach((word) => {\\n            const decryptedWord = this.encrypt(word);\\n            const decryptedWordNum = this._decryptedWordMap.get(decryptedWord);\\n\\n            if (decryptedWordNum !== undefined)\\n                this._decryptedWordMap.set(decryptedWord, decryptedWordNum + 1);\\n            else\\n                this._decryptedWordMap.set(decryptedWord, 1);\\n        });\\n    }\\n\\n    encrypt(word1: string): string {\\n        let decryptedWord1 = \"\";\\n\\n        word1.split(\"\").forEach((char) => {\\n            decryptedWord1 += this._keyMap.get(char);\\n        });\\n\\n        return decryptedWord1;\\n    }\\n\\n    decrypt(word2: string): number {\\n        const decryptedWordNum = this._decryptedWordMap.get(word2);\\n\\n        if (decryptedWordNum)\\n            return decryptedWordNum\\n        else\\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874459,
                "title": "python-simple-solution-beats-96-92",
                "content": "# Code\\n```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key2value={}\\n        for k,v in zip(keys,values):\\n            self.key2value[k]=v\\n        self.dictionary=Counter()\\n        for d in dictionary:\\n            self.dictionary[self.encrypt(d)]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        res=[]\\n        for c in word1:\\n            if c in self.key2value:\\n                res.append(self.key2value[c])\\n            else:\\n                return \"\"\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return  self.dictionary[word2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key2value={}\\n        for k,v in zip(keys,values):\\n            self.key2value[k]=v\\n        self.dictionary=Counter()\\n        for d in dictionary:\\n            self.dictionary[self.encrypt(d)]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        res=[]\\n        for c in word1:\\n            if c in self.key2value:\\n                res.append(self.key2value[c])\\n            else:\\n                return \"\"\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return  self.dictionary[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750883,
                "title": "c-solution-without-trie-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\n    public:\\n    unordered_map<char,string>mp;\\n    unordered_map<string,unordered_map<char,int>>revMp;\\n    unordered_map<int,vector<string>>dict;\\n\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            mp[keys[i]] = values[i];\\n            revMp[values[i]][keys[i]]++;\\n        }\\n        for(auto &i:dictionary)\\n        {\\n            dict[i.length()].push_back(i);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& i:word1)\\n        {\\n            if(mp.find(i) == mp.end())\\n            return \"\";\\n            ans+=mp[i];\\n        }\\n    return ans;\\n    }\\n    \\n    int decrypt(string word2){\\n        if(word2.length() % 2 )\\n        return 0;\\n        vector<string>&v = dict[word2.length()/2];\\n        int res=0;\\n        for(auto &i : v)\\n        {\\n            bool ok = true;\\n            int x = 0;\\n            for(int j=0;j<i.length();j++)\\n            {\\n                if(revMp[word2.substr(x,2)][i[j]] == 0)\\n                {\\n                    ok=false;\\n                    break;\\n                }\\n                x+=2;\\n            }\\n\\n            if(ok)\\n            res++;\\n        }\\n    return res;\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Encrypter {\\n    public:\\n    unordered_map<char,string>mp;\\n    unordered_map<string,unordered_map<char,int>>revMp;\\n    unordered_map<int,vector<string>>dict;\\n\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            mp[keys[i]] = values[i];\\n            revMp[values[i]][keys[i]]++;\\n        }\\n        for(auto &i:dictionary)\\n        {\\n            dict[i.length()].push_back(i);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& i:word1)\\n        {\\n            if(mp.find(i) == mp.end())\\n            return \"\";\\n            ans+=mp[i];\\n        }\\n    return ans;\\n    }\\n    \\n    int decrypt(string word2){\\n        if(word2.length() % 2 )\\n        return 0;\\n        vector<string>&v = dict[word2.length()/2];\\n        int res=0;\\n        for(auto &i : v)\\n        {\\n            bool ok = true;\\n            int x = 0;\\n            for(int j=0;j<i.length();j++)\\n            {\\n                if(revMp[word2.substr(x,2)][i[j]] == 0)\\n                {\\n                    ok=false;\\n                    break;\\n                }\\n                x+=2;\\n            }\\n\\n            if(ok)\\n            res++;\\n        }\\n    return res;\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676976,
                "title": "python3-hashmap-solution",
                "content": "\\n# Code\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mapping = {}\\n        self.countDict = defaultdict(int)\\n        for i in range(len(keys)):\\n            self.mapping[keys[i]]=values[i]\\n        for key in dictionary:\\n            self.countDict[self.encrypt(key,0)] += 1\\n    def encrypt(self, word1: str,init = 1) -> str:\\n        ans = \"\"\\n        for ch in word1:\\n            if ch in self.mapping:\\n                ans+=self.mapping[ch]\\n            else:\\n                if init==0: return \"\"\\n                ans+=ch\\n        return ans\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.countDict[word2]\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mapping = {}\\n        self.countDict = defaultdict(int)\\n        for i in range(len(keys)):\\n            self.mapping[keys[i]]=values[i]\\n        for key in dictionary:\\n            self.countDict[self.encrypt(key,0)] += 1\\n    def encrypt(self, word1: str,init = 1) -> str:\\n        ans = \"\"\\n        for ch in word1:\\n            if ch in self.mapping:\\n                ans+=self.mapping[ch]\\n            else:\\n                if init==0: return \"\"\\n                ans+=ch\\n        return ans\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.countDict[word2]\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661824,
                "title": "c-python-trie-hash-map-solution-with-explanation",
                "content": "use a hash map to record mapping of letter to values.\\nuse Trie to store word of dictionary after encrypting, if the word  after encrypting is empty string, pass it.\\n\\ntc: \\n__init__ O(len(keys) + O(len(dictionary)))\\nencrypt O(n)\\ndecrypt O(n)\\n\\nsc is O(len(dictionary) * 100)\\n\\n### c++\\n```cpp\\nclass Trie {\\npublic:\\n    int cnt;\\n    Trie* child[26];\\n    Trie(): cnt(0), child{} {};\\n};\\n\\nclass Encrypter {\\npublic:\\n    string* map[26];\\n    Trie* root;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary): map{nullptr}, root{nullptr} {\\n        for (int i = 0, size = keys.size(); i < size; i+=1) map[keys[i]-\\'a\\'] = &values[i];\\n        this -> root = new Trie();\\n        auto insert = [&] (const string& word) -> void {\\n            if (word.empty()) return;\\n            Trie* cur = this -> root;\\n            for (auto& ch: word) {\\n                if (cur -> child[ch-\\'a\\'] == nullptr) cur -> child[ch-\\'a\\'] = new Trie();\\n                cur = cur -> child[ch-\\'a\\'];\\n            }\\n            cur -> cnt += 1;\\n        };\\n        for (auto& word: dictionary) insert(this -> encrypt(word));\\n    }\\n    \\n    string encrypt(string word1) {\\n        string s;\\n        for (auto& ch: word1) {\\n            if (!this -> map[ch - \\'a\\']) return \"\";\\n            s += *(this -> map[ch - \\'a\\']);\\n        }\\n        return s;\\n    }\\n    \\n    int decrypt(string word2) {\\n        Trie* cur = this -> root;\\n        for (auto& ch: word2) {\\n            if (! cur -> child[ch -\\'a\\']) return 0;\\n            cur = cur -> child[ch -\\'a\\'];\\n        }\\n        return cur -> cnt;\\n    }\\n};\\n```\\n### python\\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.childs = {}\\n        self.cnt = 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.map = {k:v for k, v in zip(keys, values)}\\n        self.root = Trie()\\n        def insert(word):\\n            if not word: return\\n            cur = self.root\\n            for ch in word:\\n                if ch not in cur.childs: cur.childs[ch] = Trie()\\n                cur = cur.childs[ch]\\n            cur.cnt += 1\\n\\n        for word in dictionary:\\n            insert(self.encrypt(word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        string = []\\n        for ch in word1:\\n            if ch not in self.map: return \\'\\'\\n            string.append(self.map[ch])\\n        return \\'\\'.join(string)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        cur = self.root\\n        for idx, ch in enumerate(word2):\\n            if ch not in cur.childs: return 0\\n            cur = cur.childs[ch]\\n        return cur.cnt\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```cpp\\nclass Trie {\\npublic:\\n    int cnt;\\n    Trie* child[26];\\n    Trie(): cnt(0), child{} {};\\n};\\n\\nclass Encrypter {\\npublic:\\n    string* map[26];\\n    Trie* root;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary): map{nullptr}, root{nullptr} {\\n        for (int i = 0, size = keys.size(); i < size; i+=1) map[keys[i]-\\'a\\'] = &values[i];\\n        this -> root = new Trie();\\n        auto insert = [&] (const string& word) -> void {\\n            if (word.empty()) return;\\n            Trie* cur = this -> root;\\n            for (auto& ch: word) {\\n                if (cur -> child[ch-\\'a\\'] == nullptr) cur -> child[ch-\\'a\\'] = new Trie();\\n                cur = cur -> child[ch-\\'a\\'];\\n            }\\n            cur -> cnt += 1;\\n        };\\n        for (auto& word: dictionary) insert(this -> encrypt(word));\\n    }\\n    \\n    string encrypt(string word1) {\\n        string s;\\n        for (auto& ch: word1) {\\n            if (!this -> map[ch - \\'a\\']) return \"\";\\n            s += *(this -> map[ch - \\'a\\']);\\n        }\\n        return s;\\n    }\\n    \\n    int decrypt(string word2) {\\n        Trie* cur = this -> root;\\n        for (auto& ch: word2) {\\n            if (! cur -> child[ch -\\'a\\']) return 0;\\n            cur = cur -> child[ch -\\'a\\'];\\n        }\\n        return cur -> cnt;\\n    }\\n};\\n```\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.childs = {}\\n        self.cnt = 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.map = {k:v for k, v in zip(keys, values)}\\n        self.root = Trie()\\n        def insert(word):\\n            if not word: return\\n            cur = self.root\\n            for ch in word:\\n                if ch not in cur.childs: cur.childs[ch] = Trie()\\n                cur = cur.childs[ch]\\n            cur.cnt += 1\\n\\n        for word in dictionary:\\n            insert(self.encrypt(word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        string = []\\n        for ch in word1:\\n            if ch not in self.map: return \\'\\'\\n            string.append(self.map[ch])\\n        return \\'\\'.join(string)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        cur = self.root\\n        for idx, ch in enumerate(word2):\\n            if ch not in cur.childs: return 0\\n            cur = cur.childs[ch]\\n        return cur.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613010,
                "title": "straight-forward-solution-187ms-runtime-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor encryption - since for every character in string \\'c\\' present in key[i] we need to fetch values[i], we\\'ll build a dictionary mapping each key[i] to valeus[i] so we can get value associated with each key-character in O(1).\\n\\nFor decryption - since we need to find possible strings in valid \\'dictionary\\' array that we can encrypt to get this string that we are currently trying to decrypt, we can simply encrypt all the possible/valid string provided already in \\'dictionary\\' array, and see how many of those strings can map to same encrypted result (that we are currently tryint to decrypt)\\n\\nFor both of these steps since we need to build dictionaries, we perform the pre-computation steps needed in constructor.\\n\\n![Screenshot 2023-06-08 145030.png](https://assets.leetcode.com/users/images/b0531d62-cd4f-4283-8292-6e2d8fc57fd4_1686216056.4274116.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**Constructor / Pre-processing** - O(D*N) -> D is number of words in dictionary and N is the max number of characters in a word (as we are calling Encrypt for each word)\\n**Encrypt** - O(N) -> N is the number of characters in the word to encrypt\\n**Decrypt** - O(1)\\n\\nOverall - O(D*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**Constructor / Pre-processing** - O(D) -> D is number of words in dictionary that we are storing in Dictionary\\n**Encrypt** - O(N) -> as we are using a StringBuilder\\n**Decrypt** - O(1)\\n\\nOverall - O(D)\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\npublic class Encrypter {\\n    char[] keys;\\n    string[] values;\\n    string[] dictionary;\\n\\n    //for encrypt\\n    Dictionary<char, string> keyMap;\\n\\n    //for decrypt\\n    Dictionary<string, int> valueMap;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.dictionary = dictionary;\\n\\n        keyMap = new Dictionary<char, string>();\\n        for (int i = 0; i < keys.Length; i++)\\n            keyMap[keys[i]] = values[i];\\n\\n        valueMap = new Dictionary<string, int>();\\n        for (int i = 0; i < dictionary.Length; i++)\\n        {\\n            string str = Encrypt(dictionary[i]);\\n            if (!valueMap.ContainsKey(str))\\n            {\\n                valueMap.Add(str, 1);\\n            }\\n            else\\n            {\\n                valueMap[str]++;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < word1.Length; i++)\\n        {\\n            if (keyMap.TryGetValue(word1[i], out string str))\\n            {\\n                sb.Append(str);\\n            }\\n            else\\n            {\\n                return \"\";\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        if(valueMap.TryGetValue(word2, out int result))\\n            return result;\\n        else\\n            return 0;\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\npublic class Encrypter {\\n    char[] keys;\\n    string[] values;\\n    string[] dictionary;\\n\\n    //for encrypt\\n    Dictionary<char, string> keyMap;\\n\\n    //for decrypt\\n    Dictionary<string, int> valueMap;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.dictionary = dictionary;\\n\\n        keyMap = new Dictionary<char, string>();\\n        for (int i = 0; i < keys.Length; i++)\\n            keyMap[keys[i]] = values[i];\\n\\n        valueMap = new Dictionary<string, int>();\\n        for (int i = 0; i < dictionary.Length; i++)\\n        {\\n            string str = Encrypt(dictionary[i]);\\n            if (!valueMap.ContainsKey(str))\\n            {\\n                valueMap.Add(str, 1);\\n            }\\n            else\\n            {\\n                valueMap[str]++;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < word1.Length; i++)\\n        {\\n            if (keyMap.TryGetValue(word1[i], out string str))\\n            {\\n                sb.Append(str);\\n            }\\n            else\\n            {\\n                return \"\";\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        if(valueMap.TryGetValue(word2, out int result))\\n            return result;\\n        else\\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594273,
                "title": "python-simple-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter:\\n    def __init__(self, keys, values, dictionary):\\n        self.dict1 = {i:j for i,j in zip(keys,values)}\\n        self.dict2 = defaultdict(list)\\n        self.dictionary = dictionary\\n\\n        for i,j in zip(values,keys):\\n            self.dict2[i].append(j)\\n\\n    def encrypt(self, word1):\\n        str1 = \"\"\\n\\n        for i in word1:\\n            if i not in self.dict1:\\n                return \"\"\\n            else:\\n                str1 += self.dict1[i]\\n\\n        return str1\\n\\n    def decrypt(self, word2):\\n        total = 0\\n\\n        for i in self.dictionary:\\n            if self.encrypt(i) == word2:\\n                total += 1\\n\\n        return total\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys, values, dictionary):\\n        self.dict1 = {i:j for i,j in zip(keys,values)}\\n        self.dict2 = defaultdict(list)\\n        self.dictionary = dictionary\\n\\n        for i,j in zip(values,keys):\\n            self.dict2[i].append(j)\\n\\n    def encrypt(self, word1):\\n        str1 = \"\"\\n\\n        for i in word1:\\n            if i not in self.dict1:\\n                return \"\"\\n            else:\\n                str1 += self.dict1[i]\\n\\n        return str1\\n\\n    def decrypt(self, word2):\\n        total = 0\\n\\n        for i in self.dictionary:\\n            if self.encrypt(i) == word2:\\n                total += 1\\n\\n        return total\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590876,
                "title": "c-simple-solution-using-two-dictionaries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want a keys[i] -> values[i] dictionary to easily encrypt a character in O(1) and a word in O(n) where n is the length of the word.\\n\\nSimilarly, for an O(1) decryption we want to pre-process all of the strings in the given dictionary upon Encrypter construction.\\n\\nThe Encrytper would run in O(n) where n is the number of strings in the dictionary. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a dicitonary mapping chars to strings (keys to values).\\nUse a dicitonary mapping words to count the number of possible strings word2 could decrypt to that also appear in dictionary.\\nProcess the above in Encrypter.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nEncrypter O(n)\\nEncrypt O(n)\\nDecrypt O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nEncrypter O(n)\\nEncrypt O(1)\\nDecrypt O(1)\\n\\n# Code\\n```\\npublic class Encrypter {\\n\\n    Dictionary<char, string> keyToValue = new Dictionary<char,string>();\\n    Dictionary<string,int> fullDict = new Dictionary<string,int>();\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        for(int i = 0; i < keys.Length; i++) {\\n            keyToValue[keys[i]] = values[i];\\n        }\\n        \\n        for (int j = 0; j < dictionary.Length; j++) {\\n            var word = dictionary[j];\\n            var encrypted = Encrypt(word);\\n            var present = fullDict.TryGetValue(encrypted, out var val);\\n            if (!present) {\\n                fullDict.Add(encrypted, 1);\\n            }\\n            else {\\n                val++;\\n                fullDict[encrypted] = val;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        var encStr = string.Empty;\\n        for (int i = 0; i < word1.Length; i++) {\\n            var present = keyToValue.TryGetValue(word1[i] , out var val);\\n            if(!present) {\\n                encStr += \"#\";\\n                // gotta add a random value so that strings with no mapping don\\'t increase count in fullDict by mistake\\n                // testcase for this is \\n                //[[[\"b\"],[\"ca\"],[\"aaa\",\"cacbc\",\"bbaba\",\"bb\"]],[\"bbb\"],[\"cacaca\"]]\\n            }\\n            else{\\n                encStr += val; \\n            }          \\n        }\\n        return encStr;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        var present = fullDict.TryGetValue(word2, out var count);\\n        return present ? count : 0;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Encrypter {\\n\\n    Dictionary<char, string> keyToValue = new Dictionary<char,string>();\\n    Dictionary<string,int> fullDict = new Dictionary<string,int>();\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        for(int i = 0; i < keys.Length; i++) {\\n            keyToValue[keys[i]] = values[i];\\n        }\\n        \\n        for (int j = 0; j < dictionary.Length; j++) {\\n            var word = dictionary[j];\\n            var encrypted = Encrypt(word);\\n            var present = fullDict.TryGetValue(encrypted, out var val);\\n            if (!present) {\\n                fullDict.Add(encrypted, 1);\\n            }\\n            else {\\n                val++;\\n                fullDict[encrypted] = val;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        var encStr = string.Empty;\\n        for (int i = 0; i < word1.Length; i++) {\\n            var present = keyToValue.TryGetValue(word1[i] , out var val);\\n            if(!present) {\\n                encStr += \"#\";\\n                // gotta add a random value so that strings with no mapping don\\'t increase count in fullDict by mistake\\n                // testcase for this is \\n                //[[[\"b\"],[\"ca\"],[\"aaa\",\"cacbc\",\"bbaba\",\"bb\"]],[\"bbb\"],[\"cacaca\"]]\\n            }\\n            else{\\n                encStr += val; \\n            }          \\n        }\\n        return encStr;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        var present = fullDict.TryGetValue(word2, out var count);\\n        return present ? count : 0;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405875,
                "title": "simple-java-solution",
                "content": "```\\nclass Encrypter {\\n    HashMap<Character,String> h=new HashMap<Character,String>();\\n    HashMap<String,Integer> map=new HashMap<String,Integer>();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++)\\n        {\\n            h.put(keys[i],values[i]);\\n        }\\n        for(int i=0;i<dictionary.length;i++)\\n        {\\n            String str=\"\";\\n            int flag=0;\\n            for(int j=0;j<dictionary[i].length();j++)\\n            {\\n                if(!h.containsKey(dictionary[i].charAt(j)))\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n               str+=h.get(dictionary[i].charAt(j));\\n            }\\n            if(flag==0)\\n            {\\n                if(!map.containsKey(str))\\n                {\\n                    map.put(str,1);\\n                }\\n                else\\n                {\\n                    map.put(str,map.get(str)+1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String str=\"\";\\n        for(int i=0;i<word1.length();i++)\\n        {\\n            str+=h.get(word1.charAt(i));\\n        }\\n\\n        return str;\\n        \\n    }\\n    \\n    public int decrypt(String word2) {\\n        if(map.containsKey(word2))\\n        {\\n            return map.get(word2);\\n        }\\n\\n        return 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    HashMap<Character,String> h=new HashMap<Character,String>();\\n    HashMap<String,Integer> map=new HashMap<String,Integer>();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++)\\n        {\\n            h.put(keys[i],values[i]);\\n        }\\n        for(int i=0;i<dictionary.length;i++)\\n        {\\n            String str=\"\";\\n            int flag=0;\\n            for(int j=0;j<dictionary[i].length();j++)\\n            {\\n                if(!h.containsKey(dictionary[i].charAt(j)))\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n               str+=h.get(dictionary[i].charAt(j));\\n            }\\n            if(flag==0)\\n            {\\n                if(!map.containsKey(str))\\n                {\\n                    map.put(str,1);\\n                }\\n                else\\n                {\\n                    map.put(str,map.get(str)+1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String str=\"\";\\n        for(int i=0;i<word1.length();i++)\\n        {\\n            str+=h.get(word1.charAt(i));\\n        }\\n\\n        return str;\\n        \\n    }\\n    \\n    public int decrypt(String word2) {\\n        if(map.containsKey(word2))\\n        {\\n            return map.get(word2);\\n        }\\n\\n        return 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352515,
                "title": "c-golang-2-maps",
                "content": "# Code\\n```\\n//--------------------------------------\\n// C++\\n//--------------------------------------\\nclass Encrypter {\\n    unordered_map<char, string> EMap;\\n    unordered_map<string, int> DMap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++) {\\n            EMap[keys[i]] = values[i];\\n        }\\n        for(string word: dictionary) {\\n            string val = \"\";\\n            bool flag = true;\\n            for(char ch: word) {\\n                if(EMap.find(ch) != EMap.end())\\n                    val += EMap[ch];\\n                else {\\n                    flag = false;\\n                    break;\\n                }\\n            } \\n            if(flag)\\n            DMap[val]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1) {\\n            ans += EMap[ch];\\n        } \\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return DMap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n\\n//--------------------------------------\\n// Golang\\n//--------------------------------------\\ntype Encrypter struct {\\n    EMap map[byte]string\\n    DMap map[string]int\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    EMap := make(map[byte]string)\\n    DMap := make(map[string]int)\\n    for i := 0; i < len(keys); i++ {\\n        EMap[keys[i]] = values[i]\\n    }\\n    for _, word := range dictionary {\\n        val := \"\"\\n        flag := true\\n        for _, ch := range word {\\n            if _, ok := EMap[byte(ch)]; ok {\\n                val += EMap[byte(ch)]\\n            } else {\\n                flag = false\\n                break\\n            }\\n        } \\n        if flag {DMap[val]++} \\n    }\\n    return Encrypter {\\n        EMap: EMap,\\n        DMap: DMap,\\n    }\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    ans := \"\"\\n    for _, ch := range word1 {\\n        ans += this.EMap[byte(ch)]\\n    } \\n    return ans\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.DMap[word2]\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\n//--------------------------------------\\n// C++\\n//--------------------------------------\\nclass Encrypter {\\n    unordered_map<char, string> EMap;\\n    unordered_map<string, int> DMap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++) {\\n            EMap[keys[i]] = values[i];\\n        }\\n        for(string word: dictionary) {\\n            string val = \"\";\\n            bool flag = true;\\n            for(char ch: word) {\\n                if(EMap.find(ch) != EMap.end())\\n                    val += EMap[ch];\\n                else {\\n                    flag = false;\\n                    break;\\n                }\\n            } \\n            if(flag)\\n            DMap[val]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1) {\\n            ans += EMap[ch];\\n        } \\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return DMap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n\\n//--------------------------------------\\n// Golang\\n//--------------------------------------\\ntype Encrypter struct {\\n    EMap map[byte]string\\n    DMap map[string]int\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    EMap := make(map[byte]string)\\n    DMap := make(map[string]int)\\n    for i := 0; i < len(keys); i++ {\\n        EMap[keys[i]] = values[i]\\n    }\\n    for _, word := range dictionary {\\n        val := \"\"\\n        flag := true\\n        for _, ch := range word {\\n            if _, ok := EMap[byte(ch)]; ok {\\n                val += EMap[byte(ch)]\\n            } else {\\n                flag = false\\n                break\\n            }\\n        } \\n        if flag {DMap[val]++} \\n    }\\n    return Encrypter {\\n        EMap: EMap,\\n        DMap: DMap,\\n    }\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    ans := \"\"\\n    for _, ch := range word1 {\\n        ans += this.EMap[byte(ch)]\\n    } \\n    return ans\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.DMap[word2]\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284893,
                "title": "c-trie-dfs",
                "content": "```\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& s:dictionary) add(s);\\n        vals.resize(128);\\n        for(int i=0;i<keys.size();i++){\\n            vals[keys[i]] = values[i];\\n            decodeMap[values[i]].push_back(keys[i]-\\'a\\');\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res;\\n        for(auto c:word1){\\n            if(vals[c].empty()) return {};\\n            res += vals[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int res = 0;\\n        decrypt(word2, 0, root, res);\\n        return res;\\n    }\\n\\nprivate:\\n    struct Node{\\n        bool isWord = false;\\n        Node* child[26] = {nullptr};\\n    };\\n\\n    void add(const string& s){\\n        auto p = root;\\n        for(auto c:s){\\n            if(!p->child[c-\\'a\\']) p->child[c-\\'a\\'] = new Node();\\n            p = p->child[c-\\'a\\'];\\n        }\\n        p->isWord = true;\\n    }\\n\\n    void decrypt(const string& s, int i, Node* p, int& res){\\n        if(!p) return;\\n        if(i == s.size()){\\n            if(p->isWord) res++;\\n            return;\\n        }\\n        auto& v = decodeMap[s.substr(i, 2)];\\n        for(auto c:v){\\n            decrypt(s, i+2, p->child[c], res);\\n        }\\n    }\\n    \\n    Node* root = new Node();\\n    vector<string> vals;\\n    unordered_map<string, vector<int>> decodeMap;\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& s:dictionary) add(s);\\n        vals.resize(128);\\n        for(int i=0;i<keys.size();i++){\\n            vals[keys[i]] = values[i];\\n            decodeMap[values[i]].push_back(keys[i]-\\'a\\');\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res;\\n        for(auto c:word1){\\n            if(vals[c].empty()) return {};\\n            res += vals[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int res = 0;\\n        decrypt(word2, 0, root, res);\\n        return res;\\n    }\\n\\nprivate:\\n    struct Node{\\n        bool isWord = false;\\n        Node* child[26] = {nullptr};\\n    };\\n\\n    void add(const string& s){\\n        auto p = root;\\n        for(auto c:s){\\n            if(!p->child[c-\\'a\\']) p->child[c-\\'a\\'] = new Node();\\n            p = p->child[c-\\'a\\'];\\n        }\\n        p->isWord = true;\\n    }\\n\\n    void decrypt(const string& s, int i, Node* p, int& res){\\n        if(!p) return;\\n        if(i == s.size()){\\n            if(p->isWord) res++;\\n            return;\\n        }\\n        auto& v = decodeMap[s.substr(i, 2)];\\n        for(auto c:v){\\n            decrypt(s, i+2, p->child[c], res);\\n        }\\n    }\\n    \\n    Node* root = new Node();\\n    vector<string> vals;\\n    unordered_map<string, vector<int>> decodeMap;\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283180,
                "title": "c-solution-with-comments",
                "content": "unordered_map<char, string>m;\\n    unordered_map<string, int>dict;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n   //key--->value ki mapping kro\\n     int n = keys.size();   \\n     for(int i=0; i<n; i++){\\n         m[keys[i]] = values[i];\\n     }   \\n     //dictionary ke words  ko encrypt krkr unn encrypted words ki frequency store kro..   \\n     n = dictionary.size();  \\n     for(int i=0; i<n; i++){\\n        dict[encrypt(dictionary[i])]++; \\n     }   \\n    }\\n    \\n    string encrypt(string word1) {\\n    //map ki help de word1 ko encrypt kro\\n    int n = word1.size();  \\n      string ans = \"\";  \\n        for(int i=0; i<n; i++){\\n            if(m.find(word1[i]) == m.end())return \"\";\\n            else{\\n                ans += m[word1[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n   //map ke through word ko decrypt kro\\n        if(dict.find(word2) == dict.end())return 0;``\\n        return dict[word2];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "unordered_map<char, string>m;\\n    unordered_map<string, int>dict;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n   //key--->value ki mapping kro\\n     int n = keys.size();   \\n     for(int i=0; i<n; i++){\\n         m[keys[i]] = values[i];\\n     }   \\n     //dictionary ke words  ko encrypt krkr unn encrypted words ki frequency store kro..   \\n     n = dictionary.size();  \\n     for(int i=0; i<n; i++){\\n        dict[encrypt(dictionary[i])]++; \\n     }   \\n    }\\n    \\n    string encrypt(string word1) {\\n    //map ki help de word1 ko encrypt kro\\n    int n = word1.size();  \\n      string ans = \"\";  \\n        for(int i=0; i<n; i++){\\n            if(m.find(word1[i]) == m.end())return \"\";\\n            else{\\n                ans += m[word1[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n   //map ke through word ko decrypt kro\\n        if(dict.find(word2) == dict.end())return 0;``\\n        return dict[word2];\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3254331,
                "title": "using-hashmap",
                "content": "\\n# Code\\n```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243268,
                "title": "java-simple-solution-using-hashmap-and-its-methods",
                "content": "\\n\\n# Code\\n```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105951,
                "title": "simple-solution-100-faster-using-hashtable-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we will save values for encryption and as we have to decrypt word2 and see how many words can be made that lie in dict , so we will make encryption for words in dict and count in how many ways that encryption can be decrypted , so we can simply return in decrypt call .\\n![image.png](https://assets.leetcode.com/users/images/b48e583f-c741-4e4f-b8d9-9b7d0c74e89e_1674834382.4091935.png)\\n\\n# Complexity\\n- Time complexity: O(dict[i]*dict.length + word1.length**calls to encrypt)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\npublic:\\n    vector<string> val;\\n    unordered_map<string,int> m;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        val.resize(26,\"\");\\n        for(int i=0;i<keys.size();i++){\\n            val[keys[i]-\\'a\\'] = values[i];\\n        }\\n        // we will simply store encrypt string\\n        for(auto s: dict){\\n            string tem = \"\";\\n            for(auto c: s){\\n                if(val[c-\\'a\\'] == \"\"){ tem =\"\"; break;}\\n                tem += val[c-\\'a\\'];\\n            }\\n            m[tem]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c: word1){\\n            if(val[c-\\'a\\'] == \"\") return \"\";\\n            ans += val[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(m.find(word2) != m.end()) return m[word2];\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    vector<string> val;\\n    unordered_map<string,int> m;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        val.resize(26,\"\");\\n        for(int i=0;i<keys.size();i++){\\n            val[keys[i]-\\'a\\'] = values[i];\\n        }\\n        // we will simply store encrypt string\\n        for(auto s: dict){\\n            string tem = \"\";\\n            for(auto c: s){\\n                if(val[c-\\'a\\'] == \"\"){ tem =\"\"; break;}\\n                tem += val[c-\\'a\\'];\\n            }\\n            m[tem]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c: word1){\\n            if(val[c-\\'a\\'] == \"\") return \"\";\\n            ans += val[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(m.find(word2) != m.end()) return m[word2];\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899070,
                "title": "golang-hash-map-and-trie",
                "content": "```go\\ntype TrieNode struct {\\n  Children [26]*TrieNode\\n  Word bool\\n}\\n\\ntype Encrypter struct {\\n  encryptsTo map[byte]string\\n  decryptsTo map[string][]byte\\n  dict *TrieNode\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n  encryptsTo := make(map[byte]string)\\n  decryptsTo := make(map[string][]byte)\\n  for i := 0; i < len(keys); i++ {\\n    encryptsTo[keys[i]] = values[i]\\n    decryptsTo[values[i]] = append(decryptsTo[values[i]], keys[i])\\n  }\\n  root := &TrieNode{}\\n  for _, word := range dictionary {\\n    insert(root, word)\\n  }\\n  return Encrypter{encryptsTo, decryptsTo, root}\\n}\\n\\nfunc insert(root *TrieNode, word string) {\\n  curr := root\\n  for i := 0; i < len(word); i++ {\\n    child := curr.Children[word[i]-\\'a\\']\\n    if child == nil {\\n      child = &TrieNode{}\\n      curr.Children[word[i]-\\'a\\'] = child\\n    }\\n    curr = child\\n  }\\n  curr.Word = true\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n  var res strings.Builder\\n  for i := 0; i < len(word1); i++ {\\n    if ct, ok := this.encryptsTo[word1[i]]; ok {\\n      res.WriteString(ct)\\n    } else {\\n      return \"\"\\n    }\\n  }\\n  return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n  return this.countDecryptions(this.dict, word2, 0)  \\n}\\n\\nfunc (this *Encrypter) countDecryptions(node *TrieNode, word string, pos int) int {\\n  if pos == len(word) {\\n    if node.Word {\\n      return 1\\n    }\\n    return 0\\n  }\\n  var res int\\n  ct := word[pos:pos+2]\\n  for _, key := range this.decryptsTo[ct] {\\n    child := node.Children[key-\\'a\\']\\n    if child != nil {\\n      res += this.countDecryptions(child, word, pos+2)\\n    }\\n  }\\n  return res\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n ```",
                "solutionTags": [
                    "Go",
                    "Trie"
                ],
                "code": "```go\\ntype TrieNode struct {\\n  Children [26]*TrieNode\\n  Word bool\\n}\\n\\ntype Encrypter struct {\\n  encryptsTo map[byte]string\\n  decryptsTo map[string][]byte\\n  dict *TrieNode\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n  encryptsTo := make(map[byte]string)\\n  decryptsTo := make(map[string][]byte)\\n  for i := 0; i < len(keys); i++ {\\n    encryptsTo[keys[i]] = values[i]\\n    decryptsTo[values[i]] = append(decryptsTo[values[i]], keys[i])\\n  }\\n  root := &TrieNode{}\\n  for _, word := range dictionary {\\n    insert(root, word)\\n  }\\n  return Encrypter{encryptsTo, decryptsTo, root}\\n}\\n\\nfunc insert(root *TrieNode, word string) {\\n  curr := root\\n  for i := 0; i < len(word); i++ {\\n    child := curr.Children[word[i]-\\'a\\']\\n    if child == nil {\\n      child = &TrieNode{}\\n      curr.Children[word[i]-\\'a\\'] = child\\n    }\\n    curr = child\\n  }\\n  curr.Word = true\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n  var res strings.Builder\\n  for i := 0; i < len(word1); i++ {\\n    if ct, ok := this.encryptsTo[word1[i]]; ok {\\n      res.WriteString(ct)\\n    } else {\\n      return \"\"\\n    }\\n  }\\n  return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n  return this.countDecryptions(this.dict, word2, 0)  \\n}\\n\\nfunc (this *Encrypter) countDecryptions(node *TrieNode, word string, pos int) int {\\n  if pos == len(word) {\\n    if node.Word {\\n      return 1\\n    }\\n    return 0\\n  }\\n  var res int\\n  ct := word[pos:pos+2]\\n  for _, key := range this.decryptsTo[ct] {\\n    child := node.Children[key-\\'a\\']\\n    if child != nil {\\n      res += this.countDecryptions(child, word, pos+2)\\n    }\\n  }\\n  return res\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2826497,
                "title": "c-solution-using-little-string-trick",
                "content": "Well, unexpected problem : having problems in adding strings together (-_-) during encryption = time limit exceeded.\\n\\nSolution : Well, just realized that one can just set the resultant string into final size and assign characters to it = what do you know, 100 times faster than adding substrings (which will extend the string but I\\'ve never expected to have such a difference in runtime (-_-)) \\n\\nHa ha (-_-)\\n\\n```cpp\\nstruct n {\\n    char flag;\\n    n* chi[26];\\n    n() {\\n        for (int i = 0; i < 26; i++) {\\n            chi[i] = nullptr;\\n        }\\n    }\\n};\\nclass Encrypter {\\npublic:\\n    n* D;\\n    std::map<string, vector<char>> V;\\n    string M[26];\\n    int cnt, w2len;\\n    \\n    void insertT(n* T, string& str, char f) {\\n        for (char c : str) {\\n            if (T->chi[(c - \\'a\\')] == nullptr) {\\n                T->chi[(c - \\'a\\')] = new n();\\n            }\\n            T = T->chi[(c - \\'a\\')];\\n        }\\n        T->flag = f;\\n    }\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        D = new n();\\n        V = {};\\n        for (int i = 0; i < 26; i++) {\\n            M[i] = \"\";\\n        }\\n        for (int i = 0; i < values.size(); i++) {\\n            if (V.find(values[i]) == V.end()) {\\n                V[values[i]] = { keys[i] };\\n            }\\n            else {\\n                V[values[i]].push_back(keys[i]);\\n            }\\n            M[(keys[i] - \\'a\\')] = values[i];\\n        }    \\n        for (int i = 0; i < dictionary.size(); i++) {\\n            insertT(D, dictionary[i], \\'$\\');\\n        }\\n    }\\n    \\n    void opt(string& w2, int idx, n* cd) {\\n        string k = w2.substr(idx, 2);\\n        if (V.find(k) == V.end())\\n            return;\\n        else {\\n            for (char des : V[k]) {\\n                if (cd->chi[(des - \\'a\\')] != nullptr) {\\n                    if (idx + 2 == w2len && cd->chi[(des - \\'a\\')]->flag == \\'$\\') {\\n                        cnt++;\\n                    }\\n                    else {\\n                        opt(w2, idx + 2, cd->chi[(des - \\'a\\')]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = word1;\\n        res = res + word1;\\n        for (int i = 0; i < word1.length(); i++) {\\n            if (M[(word1[i] - \\'a\\')].length() == 0) {\\n                return \"\";\\n            }\\n            res[i * 2] = M[(word1[i] - \\'a\\')][0];\\n            res[i * 2 + 1] = M[(word1[i] - \\'a\\')][1];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        cnt = 0;\\n        w2len = word2.length();\\n        opt(word2, 0, D);\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstruct n {\\n    char flag;\\n    n* chi[26];\\n    n() {\\n        for (int i = 0; i < 26; i++) {\\n            chi[i] = nullptr;\\n        }\\n    }\\n};\\nclass Encrypter {\\npublic:\\n    n* D;\\n    std::map<string, vector<char>> V;\\n    string M[26];\\n    int cnt, w2len;\\n    \\n    void insertT(n* T, string& str, char f) {\\n        for (char c : str) {\\n            if (T->chi[(c - \\'a\\')] == nullptr) {\\n                T->chi[(c - \\'a\\')] = new n();\\n            }\\n            T = T->chi[(c - \\'a\\')];\\n        }\\n        T->flag = f;\\n    }\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        D = new n();\\n        V = {};\\n        for (int i = 0; i < 26; i++) {\\n            M[i] = \"\";\\n        }\\n        for (int i = 0; i < values.size(); i++) {\\n            if (V.find(values[i]) == V.end()) {\\n                V[values[i]] = { keys[i] };\\n            }\\n            else {\\n                V[values[i]].push_back(keys[i]);\\n            }\\n            M[(keys[i] - \\'a\\')] = values[i];\\n        }    \\n        for (int i = 0; i < dictionary.size(); i++) {\\n            insertT(D, dictionary[i], \\'$\\');\\n        }\\n    }\\n    \\n    void opt(string& w2, int idx, n* cd) {\\n        string k = w2.substr(idx, 2);\\n        if (V.find(k) == V.end())\\n            return;\\n        else {\\n            for (char des : V[k]) {\\n                if (cd->chi[(des - \\'a\\')] != nullptr) {\\n                    if (idx + 2 == w2len && cd->chi[(des - \\'a\\')]->flag == \\'$\\') {\\n                        cnt++;\\n                    }\\n                    else {\\n                        opt(w2, idx + 2, cd->chi[(des - \\'a\\')]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = word1;\\n        res = res + word1;\\n        for (int i = 0; i < word1.length(); i++) {\\n            if (M[(word1[i] - \\'a\\')].length() == 0) {\\n                return \"\";\\n            }\\n            res[i * 2] = M[(word1[i] - \\'a\\')][0];\\n            res[i * 2 + 1] = M[(word1[i] - \\'a\\')][1];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        cnt = 0;\\n        w2len = word2.length();\\n        opt(word2, 0, D);\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813645,
                "title": "go-solution-with-trie",
                "content": "```\\n// 2227. Encrypt and Decrypt Strings\\n// 2227. \\u52A0\\u5BC6\\u89E3\\u5BC6\\u5B57\\u7B26\\u4E32\\n// \\u601D\\u8DEF\\uFF1A\\u9006\\u5411\\u601D\\u7EF4\\ntype Encrypter struct {\\n\\tchildren [26]*Encrypter\\n\\tisEnd    bool\\n\\tcount    int             // counting the number of dictionary\\'s word same encrypt code\\n\\tm        map[byte]string // keys[i]:values[i]\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\te := Encrypter{}\\n\\t// keys[i]:values[i]\\n\\te.m = make(map[byte]string, len(keys))\\n\\tfor i := 0; i < len(keys); i++ {\\n\\t\\te.m[keys[i]] = values[i]\\n\\t}\\n\\t// encrypt the words of the dictionary\\n\\t// and store them in a trie\\n\\t// with a count of each words.\\n\\tfor _, word := range dictionary {\\n\\t\\tw := e.Encrypt(word)\\n\\t\\tif len(w) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\te.insert(w)\\n\\t}\\n\\treturn e\\n}\\n\\nfunc (e *Encrypter) insert(w string) {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\tcur.children[ch-\\'a\\'] = &Encrypter{}\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\tcur.isEnd = true\\n\\tcur.count++\\n}\\n\\nfunc (e *Encrypter) search(w string) bool {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.isEnd\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Encrypt(w string) string {\\n\\tans := strings.Builder{}\\n\\tfor _, ch := range w {\\n\\t\\tval, ok := e.m[byte(ch)]\\n\\t\\tif !ok {\\n\\t\\t\\t// in case a character of the string is not present in keys,\\n\\t\\t\\t// the encryption process cannot be carried out,\\n\\t\\t\\t// and an empty string \"\" is returned.\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tans.WriteString(val)\\n\\t}\\n\\treturn ans.String()\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Decrypt(w string) int {\\n\\t// traversing over the trie\\n\\t// with decrypted word to get the count.\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.count\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Trie"
                ],
                "code": "```\\n// 2227. Encrypt and Decrypt Strings\\n// 2227. \\u52A0\\u5BC6\\u89E3\\u5BC6\\u5B57\\u7B26\\u4E32\\n// \\u601D\\u8DEF\\uFF1A\\u9006\\u5411\\u601D\\u7EF4\\ntype Encrypter struct {\\n\\tchildren [26]*Encrypter\\n\\tisEnd    bool\\n\\tcount    int             // counting the number of dictionary\\'s word same encrypt code\\n\\tm        map[byte]string // keys[i]:values[i]\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\te := Encrypter{}\\n\\t// keys[i]:values[i]\\n\\te.m = make(map[byte]string, len(keys))\\n\\tfor i := 0; i < len(keys); i++ {\\n\\t\\te.m[keys[i]] = values[i]\\n\\t}\\n\\t// encrypt the words of the dictionary\\n\\t// and store them in a trie\\n\\t// with a count of each words.\\n\\tfor _, word := range dictionary {\\n\\t\\tw := e.Encrypt(word)\\n\\t\\tif len(w) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\te.insert(w)\\n\\t}\\n\\treturn e\\n}\\n\\nfunc (e *Encrypter) insert(w string) {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\tcur.children[ch-\\'a\\'] = &Encrypter{}\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\tcur.isEnd = true\\n\\tcur.count++\\n}\\n\\nfunc (e *Encrypter) search(w string) bool {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.isEnd\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Encrypt(w string) string {\\n\\tans := strings.Builder{}\\n\\tfor _, ch := range w {\\n\\t\\tval, ok := e.m[byte(ch)]\\n\\t\\tif !ok {\\n\\t\\t\\t// in case a character of the string is not present in keys,\\n\\t\\t\\t// the encryption process cannot be carried out,\\n\\t\\t\\t// and an empty string \"\" is returned.\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tans.WriteString(val)\\n\\t}\\n\\treturn ans.String()\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Decrypt(w string) int {\\n\\t// traversing over the trie\\n\\t// with decrypted word to get the count.\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.count\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2806049,
                "title": "2-solutions-using-trie-and-2-maps-easy-to-understand-c",
                "content": "```\\n\\nvector<int> keyMap;\\n    unordered_map<string,int> decryptMap;\\n    vector<string> valueArr;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        valueArr = values;\\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            decryptMap[encrypt(w)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        int len = word1.length();\\n        string result(2*len,\\'a\\');\\n        for (int i = 0; i < len; i++) {\\n            int idx = keyMap[word1[i]-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result[2*i]   = valueArr[idx][0];\\n            result[2*i+1] = valueArr[idx][1];\\n        }\\n        return result;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n       auto it = decryptMap.find(word2);\\n       if (it == decryptMap.end())\\n           return 0;\\n       return it->second;\\n    }\\n\\t\\nclass Encrypter {\\npublic:\\n    \\n    // Construct the trie of the given word\\n    struct TrieNode {\\n        bool isLeaf;\\n       TrieNode* child[26];\\n    };\\n    \\n    TrieNode* root = NULL;\\n    TrieNode* makeTrieNode() {\\n        TrieNode* node = new TrieNode();\\n        node->isLeaf = false;\\n        for (int i = 0; i <  26; i++) {\\n            node->child[i] = NULL;\\n        }\\n        return node;\\n    }\\n    \\n    void addToTrie(string word) {\\n        if (!root) {\\n            root = makeTrieNode();\\n        }\\n        TrieNode* node = root;\\n        for (int i = 0; i < word.length(); i++){\\n            int idx = word[i] - \\'a\\';\\n            if (!node->child[idx]) {\\n                node->child[idx] = makeTrieNode();\\n            }\\n            node = node->child[idx];\\n        }\\n        node->isLeaf = true;\\n    }\\n    \\n    \\n    \\n    int n = 26;\\n    \\n    vector<string> dict;\\n    vector<char> keyData;\\n    vector<int> keyMap;\\n    unordered_map<string,vector<int>> strKeyMap;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        keyData = keys;\\n        dict = values;\\n        \\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        // keep value to index mapping\\n        for (int i = 0; i < values.size(); i++) {\\n            strKeyMap[values[i]].push_back(i);\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            addToTrie(w);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (auto &c : word1) {\\n            int idx = keyMap[c-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result += dict[idx];\\n        }\\n        return result;\\n    }\\n    \\n    int helper(int idx, string &word, TrieNode* node) {\\n        // if no trie node return\\n        if (!node) {\\n            return 0;\\n        }\\n        \\n        // if reached end of the word, check if we are trieNode leaf\\n        if (idx == word.size()) {\\n            if (node->isLeaf) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        // check if current value has a key mapping\\n        string str = word.substr(idx,2);\\n        auto it = strKeyMap.find(str);\\n        if (it == strKeyMap.end())\\n            return 0;\\n        \\n        int ret = 0;\\n        // Iterate on list of possible keys\\n        for (auto &i : it->second) {\\n            int id = keyData[i] - \\'a\\';\\n            ret += helper(idx+2,word,node->child[id]);\\n        }\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n       string dWord;\\n       return helper(0,word2,root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvector<int> keyMap;\\n    unordered_map<string,int> decryptMap;\\n    vector<string> valueArr;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        valueArr = values;\\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            decryptMap[encrypt(w)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        int len = word1.length();\\n        string result(2*len,\\'a\\');\\n        for (int i = 0; i < len; i++) {\\n            int idx = keyMap[word1[i]-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result[2*i]   = valueArr[idx][0];\\n            result[2*i+1] = valueArr[idx][1];\\n        }\\n        return result;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n       auto it = decryptMap.find(word2);\\n       if (it == decryptMap.end())\\n           return 0;\\n       return it->second;\\n    }\\n\\t\\nclass Encrypter {\\npublic:\\n    \\n    // Construct the trie of the given word\\n    struct TrieNode {\\n        bool isLeaf;\\n       TrieNode* child[26];\\n    };\\n    \\n    TrieNode* root = NULL;\\n    TrieNode* makeTrieNode() {\\n        TrieNode* node = new TrieNode();\\n        node->isLeaf = false;\\n        for (int i = 0; i <  26; i++) {\\n            node->child[i] = NULL;\\n        }\\n        return node;\\n    }\\n    \\n    void addToTrie(string word) {\\n        if (!root) {\\n            root = makeTrieNode();\\n        }\\n        TrieNode* node = root;\\n        for (int i = 0; i < word.length(); i++){\\n            int idx = word[i] - \\'a\\';\\n            if (!node->child[idx]) {\\n                node->child[idx] = makeTrieNode();\\n            }\\n            node = node->child[idx];\\n        }\\n        node->isLeaf = true;\\n    }\\n    \\n    \\n    \\n    int n = 26;\\n    \\n    vector<string> dict;\\n    vector<char> keyData;\\n    vector<int> keyMap;\\n    unordered_map<string,vector<int>> strKeyMap;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        keyData = keys;\\n        dict = values;\\n        \\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        // keep value to index mapping\\n        for (int i = 0; i < values.size(); i++) {\\n            strKeyMap[values[i]].push_back(i);\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            addToTrie(w);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (auto &c : word1) {\\n            int idx = keyMap[c-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result += dict[idx];\\n        }\\n        return result;\\n    }\\n    \\n    int helper(int idx, string &word, TrieNode* node) {\\n        // if no trie node return\\n        if (!node) {\\n            return 0;\\n        }\\n        \\n        // if reached end of the word, check if we are trieNode leaf\\n        if (idx == word.size()) {\\n            if (node->isLeaf) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        // check if current value has a key mapping\\n        string str = word.substr(idx,2);\\n        auto it = strKeyMap.find(str);\\n        if (it == strKeyMap.end())\\n            return 0;\\n        \\n        int ret = 0;\\n        // Iterate on list of possible keys\\n        for (auto &i : it->second) {\\n            int id = keyData[i] - \\'a\\';\\n            ret += helper(idx+2,word,node->child[id]);\\n        }\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n       string dWord;\\n       return helper(0,word2,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780295,
                "title": "python-solution-using-trie-and-hash-table-o-len-word1-encrypt-and-o-len-word2-decrypt",
                "content": "\\n\\n# Code\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d1=[None for _ in range(26)]\\n        self.d2={}\\n        for i,item in enumerate(keys):\\n            self.d1[ord(item)-97]=values[i]\\n        self.dict=Trie()\\n        for item in dictionary:\\n            val=self.encrypt(item)\\n            self.dict.insert(val)\\n    def encrypt(self, word1: str) -> str:\\n        ans=[]\\n        for item in word1:\\n            item=ord(item)-97\\n            if(not self.d1[item]):\\n                return \"\"\\n            else:\\n                ans.append(self.d1[item])\\n        return \"\".join(ans)\\n    def decrypt(self, word2: str) -> int:\\n        return self.dict.search(word2)\\n\\nclass Trie:\\n    def __init__(self):\\n        self.child=[None for _ in range(26)]\\n        self.count=0\\n    def insert(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                self.child[j]=Trie()\\n            self=self.child[j]\\n        self.count+=1\\n    def search(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                return 0\\n            self=self.child[j]\\n        return self.count\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d1=[None for _ in range(26)]\\n        self.d2={}\\n        for i,item in enumerate(keys):\\n            self.d1[ord(item)-97]=values[i]\\n        self.dict=Trie()\\n        for item in dictionary:\\n            val=self.encrypt(item)\\n            self.dict.insert(val)\\n    def encrypt(self, word1: str) -> str:\\n        ans=[]\\n        for item in word1:\\n            item=ord(item)-97\\n            if(not self.d1[item]):\\n                return \"\"\\n            else:\\n                ans.append(self.d1[item])\\n        return \"\".join(ans)\\n    def decrypt(self, word2: str) -> int:\\n        return self.dict.search(word2)\\n\\nclass Trie:\\n    def __init__(self):\\n        self.child=[None for _ in range(26)]\\n        self.count=0\\n    def insert(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                self.child[j]=Trie()\\n            self=self.child[j]\\n        self.count+=1\\n    def search(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                return 0\\n            self=self.child[j]\\n        return self.count\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779845,
                "title": "rust-solution-with-hashmap-28-ms-6-3-mb",
                "content": "\\nKey Idea :  encrypt and decrypt will be called around 200 times for one new call, so, even if new is slow, if encrypt and decrypt are relatively fast, the whole process would be fast. \\n\\nEncrypt will have to remain O(N) because, we don\\'t know which all words can be encrypted so we can not cache them prior to it\\'s call.\\n\\nDecrypt on the other hand returns how many Strings upon encryption in Dictionary will return that string. Since the dictionary is only initialized once, and has finite number of words with finite length, we can cache it\\'s results in a hashmap. So, if we have the encrypted string as key, we can use that to get the count or return 0.\\n\\nWith some other minor optimizations, we can get the final Space and Time Complexities of the functions like so\\n\\nnew() -> TC : O(N<sup>2</sup>), SC : O(N)\\nEncrypt -> TC : O(N), SC : O(N)\\nDecrypt -> TC : O*(1), SC : O(1)\\n\\n**Note that since we are using a HashMap, the time complexity can get to O(N), however, here since the number of words in dictionary isn\\'t that much, it\\'s O(1).**\\n\\n```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    value_map : [String; 26],\\n    dict_map : HashMap<String, i32>\\n}\\n\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut value_map : [String; 26] = Default::default();\\n        \\n        keys\\n\\t\\t.into_iter()\\n\\t\\t.zip(values.into_iter())\\n\\t\\t.for_each(\\n\\t\\t\\t#[inline]\\n\\t\\t\\t|(key, value)| \\n\\t\\t\\tvalue_map[(key as u8 - b\\'a\\') as usize] = value\\n\\t\\t);\\n        \\n        let mut res = Self{\\n            value_map,\\n            dict_map : HashMap::with_capacity(5)\\n        };\\n        \\n        for word in dictionary {\\n            let key = res.encrypt(word);\\n            *res.dict_map.entry(key).or_insert(0) += 1;\\n        }\\n        \\n        res\\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res : String = String::with_capacity(word1.len() * 2);\\n        \\n        for b in word1.into_bytes() {\\n            if !self.value_map[(b - b\\'a\\') as usize].is_empty(){\\n                res.push_str(&self.value_map[(b - b\\'a\\') as usize]);\\n            } else {\\n                return String::new()\\n            }\\n        }\\n        \\n        res\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        *self.dict_map.get(&word2).unwrap_or(&0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    value_map : [String; 26],\\n    dict_map : HashMap<String, i32>\\n}\\n\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut value_map : [String; 26] = Default::default();\\n        \\n        keys\\n\\t\\t.into_iter()\\n\\t\\t.zip(values.into_iter())\\n\\t\\t.for_each(\\n\\t\\t\\t#[inline]\\n\\t\\t\\t|(key, value)| \\n\\t\\t\\tvalue_map[(key as u8 - b\\'a\\') as usize] = value\\n\\t\\t);\\n        \\n        let mut res = Self{\\n            value_map,\\n            dict_map : HashMap::with_capacity(5)\\n        };\\n        \\n        for word in dictionary {\\n            let key = res.encrypt(word);\\n            *res.dict_map.entry(key).or_insert(0) += 1;\\n        }\\n        \\n        res\\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res : String = String::with_capacity(word1.len() * 2);\\n        \\n        for b in word1.into_bytes() {\\n            if !self.value_map[(b - b\\'a\\') as usize].is_empty(){\\n                res.push_str(&self.value_map[(b - b\\'a\\') as usize]);\\n            } else {\\n                return String::new()\\n            }\\n        }\\n        \\n        res\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        *self.dict_map.get(&word2).unwrap_or(&0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2779656,
                "title": "javascript-the-hard-way",
                "content": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    var i;\\n    \\n    this.ks = {};\\n    this.sk = {};\\n    \\n    let paintTrie = function(word, key) {\\n        var i;\\n        let sk = this.sk;\\n        \\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in sk) ) sk[word[i]] = {};\\n            sk = sk[word[i]];\\n        }\\n        if( !(\\'key\\' in sk) ) sk.key = new Set();\\n        sk.key.add(key);\\n    }\\n    var sk;\\n    for( i=0; i<keys.length; i++ ) {\\n        this.ks[keys[i]] = values[i];\\n        \\n        paintTrie.bind(this)(values[i], keys[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    this.dictrie = {};\\n    var dt, word;\\n    for( word of this.dict ) {\\n        dt = this.dictrie;\\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in dt) ) dt[word[i]] = {};\\n            dt = dt[word[i]];\\n        }\\n        dt.valid = true;\\n    }\\n};\\n\\nEncrypter.prototype.encrypt = function(word1) {\\n    var i, result=\"\";\\n    for( i=0; i<word1.length; i++ ) {\\n        result += this.ks[word1[i]];\\n    }\\n    return result;\\n};\\n\\nEncrypter.prototype.decrypt = function(word2) {\\n    let ways = function(i=0, ansTrees=null) {\\n        var j, k, y, z;\\n        var sk = this.sk;\\n        var ans = 0;\\n        var res, subtrees, subkeys;\\n        \\n\\n        if( ansTrees === null ) ansTrees = [this.dictrie];\\n        if( i >= word2.length ) {\\n            let count=0;\\n            for( j=0; j<ansTrees.length; j++ ) {\\n                if( ansTrees[j].valid === true )\\n                    count++;\\n            }\\n            return count;\\n        }\\n        \\n        for( j=i; j<word2.length; j++ ) {\\n            if( !(word2[j] in sk) )\\n                break;\\n            sk = sk[word2[j]];\\n            \\n            if( \\'key\\' in sk ) {\\n                subkeys = [];\\n                subtrees = [];\\n                for( res of sk.key ) {\\n                    for( y=0; y<ansTrees.length; y++ ) {\\n                        dt = ansTrees[y];\\n                        for( k=0; k<res.length; k++ ) {\\n                            if( !(res[k] in dt) ) break;\\n                            dt = dt[res[k]];\\n                        }\\n                        if( k<res.length ) continue;\\n                        subkeys.push(res);\\n                        subtrees.push(dt);\\n                    }\\n                }\\n                if( subkeys.length == 0 ) continue;\\n                \\n                let sub = ways.bind(this)( j+1, subtrees );\\n                ans += sub;\\n            }\\n        }\\n        \\n        return ans;\\n    };\\n    \\n    return ways.bind(this)();\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    var i;\\n    \\n    this.ks = {};\\n    this.sk = {};\\n    \\n    let paintTrie = function(word, key) {\\n        var i;\\n        let sk = this.sk;\\n        \\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in sk) ) sk[word[i]] = {};\\n            sk = sk[word[i]];\\n        }\\n        if( !(\\'key\\' in sk) ) sk.key = new Set();\\n        sk.key.add(key);\\n    }\\n    var sk;\\n    for( i=0; i<keys.length; i++ ) {\\n        this.ks[keys[i]] = values[i];\\n        \\n        paintTrie.bind(this)(values[i], keys[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    this.dictrie = {};\\n    var dt, word;\\n    for( word of this.dict ) {\\n        dt = this.dictrie;\\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in dt) ) dt[word[i]] = {};\\n            dt = dt[word[i]];\\n        }\\n        dt.valid = true;\\n    }\\n};\\n\\nEncrypter.prototype.encrypt = function(word1) {\\n    var i, result=\"\";\\n    for( i=0; i<word1.length; i++ ) {\\n        result += this.ks[word1[i]];\\n    }\\n    return result;\\n};\\n\\nEncrypter.prototype.decrypt = function(word2) {\\n    let ways = function(i=0, ansTrees=null) {\\n        var j, k, y, z;\\n        var sk = this.sk;\\n        var ans = 0;\\n        var res, subtrees, subkeys;\\n        \\n\\n        if( ansTrees === null ) ansTrees = [this.dictrie];\\n        if( i >= word2.length ) {\\n            let count=0;\\n            for( j=0; j<ansTrees.length; j++ ) {\\n                if( ansTrees[j].valid === true )\\n                    count++;\\n            }\\n            return count;\\n        }\\n        \\n        for( j=i; j<word2.length; j++ ) {\\n            if( !(word2[j] in sk) )\\n                break;\\n            sk = sk[word2[j]];\\n            \\n            if( \\'key\\' in sk ) {\\n                subkeys = [];\\n                subtrees = [];\\n                for( res of sk.key ) {\\n                    for( y=0; y<ansTrees.length; y++ ) {\\n                        dt = ansTrees[y];\\n                        for( k=0; k<res.length; k++ ) {\\n                            if( !(res[k] in dt) ) break;\\n                            dt = dt[res[k]];\\n                        }\\n                        if( k<res.length ) continue;\\n                        subkeys.push(res);\\n                        subtrees.push(dt);\\n                    }\\n                }\\n                if( subkeys.length == 0 ) continue;\\n                \\n                let sub = ways.bind(this)( j+1, subtrees );\\n                ans += sub;\\n            }\\n        }\\n        \\n        return ans;\\n    };\\n    \\n    return ways.bind(this)();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703218,
                "title": "easy-understanding-map",
                "content": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            // cout<<encrypt(x)<<\" \";\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            if(kmap.find(x) == kmap.end()) return \"\";\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            // cout<<encrypt(x)<<\" \";\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            if(kmap.find(x) == kmap.end()) return \"\";\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2665637,
                "title": "one-hashmap-use",
                "content": "class Encrypter {\\n\\n    String[] key = new String[26];\\n    String[] dictionary;\\n    HashMap<String,Integer> H;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        H = new HashMap<>();\\n        simplyKeys(keys,values);\\n        this.dictionary=dictionary;\\n        addHashMap();\\n    }\\n    \\n    public void simplyKeys(char[] keys,String[] values){\\n        for(int i=0;i<keys.length;i++){\\n            key[keys[i]-\\'a\\']=values[i];\\n        }\\n    }\\n    \\n    public void addHashMap(){\\n        for(String dict : dictionary){\\n            H.put(encrypt(dict),H.getOrDefault(encrypt(dict),0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String res = \"\";\\n        for(char ch : word1.toCharArray()){\\n            if(key[ch-\\'a\\']==null ||key[ch-\\'a\\']==\"\") return \"\";\\n            else res+=key[ch-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return H.containsKey(word2) ? H.get(word2) : 0;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Encrypter {\\n\\n    String[] key = new String[26];\\n    String[] dictionary;\\n    HashMap<String,Integer> H;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        H = new HashMap<>();\\n        simplyKeys(keys,values);\\n        this.dictionary=dictionary;\\n        addHashMap();\\n    }\\n    \\n    public void simplyKeys(char[] keys,String[] values){\\n        for(int i=0;i<keys.length;i++){\\n            key[keys[i]-\\'a\\']=values[i];\\n        }\\n    }\\n    \\n    public void addHashMap(){\\n        for(String dict : dictionary){\\n            H.put(encrypt(dict),H.getOrDefault(encrypt(dict),0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String res = \"\";\\n        for(char ch : word1.toCharArray()){\\n            if(key[ch-\\'a\\']==null ||key[ch-\\'a\\']==\"\") return \"\";\\n            else res+=key[ch-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return H.containsKey(word2) ? H.get(word2) : 0;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 2599073,
                "title": "kotlin-100-time-and-space-saving-dictionary-in-trie-checking-recursively",
                "content": "```\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n\\n    class TrieNode(val next: Array<TrieNode?> = Array(26) { null }, var isEnd: Boolean = false)\\n\\n    val forward = mutableMapOf<Char, String>().also {\\n        keys.forEachIndexed { index, c ->\\n            it[c] = values[index]\\n        }\\n    }\\n    val backward = mutableMapOf<String, MutableList<Char>>().also {\\n        values.forEachIndexed { index, str ->\\n            it[str] = (it[str] ?: mutableListOf()).also {\\n                it.add(keys[index])\\n            }\\n        }\\n    }\\n\\n    // for dictionary [a, aba, acba, abaff] trie will be\\n\\t//\\n    //                        *root*\\n    //                      a (end=true)\\n    //                b            c\\n    //        a (end = true)     b\\n    //          f               a (end = true)\\n    //            f (end = true)\\n    //\\n    val root = TrieNode().also { root ->\\n        dictionary.forEach {dicStr ->\\n            var nowItem = root\\n            dicStr.forEachIndexed { index, ch ->\\n                if (nowItem.next[ch - \\'a\\'] == null) {\\n                    TrieNode(isEnd = (index == dicStr.length-1)).also {\\n                        nowItem.next[ch - \\'a\\'] = it\\n                        nowItem = it\\n                    }\\n                } else {\\n\\n                    nowItem = nowItem.next[ch - \\'a\\']!!.also {\\n                        it.isEnd = it.isEnd || (index == dicStr.length-1)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        return word1.asSequence().map { forward[it] }.joinToString(\"\")\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var cantBeAny = false\\n        val possChars = word2.chunked(2).asSequence().map {\\n            backward[it] ?: mutableListOf<Char>().also {\\n                cantBeAny = true\\n            }\\n        }.toList().toTypedArray()\\n\\n        // odd length or any of pair is not present in \\'values\\' array\\n        if (cantBeAny) return 0\\n\\n        var count = 0\\n\\n        fun tryAdd(nowNode: TrieNode, index: Int) {\\n            if (index == possChars.size - 1) { // last char checking\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        if(nextNode.isEnd) {\\n                            count++\\n                        }\\n                    }\\n                }\\n            } else {\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        tryAdd(nextNode, index + 1)\\n                    }\\n                }\\n            }\\n        }\\n\\n        tryAdd(root, 0)\\n        return count\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n\\n    class TrieNode(val next: Array<TrieNode?> = Array(26) { null }, var isEnd: Boolean = false)\\n\\n    val forward = mutableMapOf<Char, String>().also {\\n        keys.forEachIndexed { index, c ->\\n            it[c] = values[index]\\n        }\\n    }\\n    val backward = mutableMapOf<String, MutableList<Char>>().also {\\n        values.forEachIndexed { index, str ->\\n            it[str] = (it[str] ?: mutableListOf()).also {\\n                it.add(keys[index])\\n            }\\n        }\\n    }\\n\\n    // for dictionary [a, aba, acba, abaff] trie will be\\n\\t//\\n    //                        *root*\\n    //                      a (end=true)\\n    //                b            c\\n    //        a (end = true)     b\\n    //          f               a (end = true)\\n    //            f (end = true)\\n    //\\n    val root = TrieNode().also { root ->\\n        dictionary.forEach {dicStr ->\\n            var nowItem = root\\n            dicStr.forEachIndexed { index, ch ->\\n                if (nowItem.next[ch - \\'a\\'] == null) {\\n                    TrieNode(isEnd = (index == dicStr.length-1)).also {\\n                        nowItem.next[ch - \\'a\\'] = it\\n                        nowItem = it\\n                    }\\n                } else {\\n\\n                    nowItem = nowItem.next[ch - \\'a\\']!!.also {\\n                        it.isEnd = it.isEnd || (index == dicStr.length-1)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        return word1.asSequence().map { forward[it] }.joinToString(\"\")\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var cantBeAny = false\\n        val possChars = word2.chunked(2).asSequence().map {\\n            backward[it] ?: mutableListOf<Char>().also {\\n                cantBeAny = true\\n            }\\n        }.toList().toTypedArray()\\n\\n        // odd length or any of pair is not present in \\'values\\' array\\n        if (cantBeAny) return 0\\n\\n        var count = 0\\n\\n        fun tryAdd(nowNode: TrieNode, index: Int) {\\n            if (index == possChars.size - 1) { // last char checking\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        if(nextNode.isEnd) {\\n                            count++\\n                        }\\n                    }\\n                }\\n            } else {\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        tryAdd(nextNode, index + 1)\\n                    }\\n                }\\n            }\\n        }\\n\\n        tryAdd(root, 0)\\n        return count\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521009,
                "title": "c",
                "content": "```\\npublic class Encrypter {\\n    Trie t;\\n    Dictionary<char,string> d;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        d = new Dictionary<char,string>();\\n        t = new Trie();\\n        for(int i = 0; i < keys.Length; i++){\\n            d[keys[i]] = values[i];\\n        }\\n        foreach(var i in dictionary){\\n            string check = Encrypt(i);\\n            if(!string.IsNullOrEmpty(check))\\n              t.Insert(check);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string res = \"\";\\n        foreach(var i in word1){\\n            if(d.ContainsKey(i))\\n                res+= d[i];\\n            else return string.Empty;\\n        }\\n        return res;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        return t.Search(word2);\\n    }\\n}\\n\\npublic class Trie{\\n    public TrieNode root = new TrieNode();\\n    \\n    public void Insert(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)){\\n                temp.ch.Add(i,new TrieNode());\\n            }\\n            temp = temp.ch[i];\\n        }\\n        temp.end += 1;\\n    }\\n    public int Search(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)) return 0;\\n            temp = temp.ch[i];\\n        }\\n        return temp.end;\\n    }\\n}\\npublic class TrieNode{\\n    public char val;\\n    public Dictionary<char,TrieNode> ch = new ();\\n    public int end;\\n    \\n    public TrieNode(){}\\n    \\n    public TrieNode(char val){\\n        this.val = val;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\npublic class Encrypter {\\n    Trie t;\\n    Dictionary<char,string> d;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        d = new Dictionary<char,string>();\\n        t = new Trie();\\n        for(int i = 0; i < keys.Length; i++){\\n            d[keys[i]] = values[i];\\n        }\\n        foreach(var i in dictionary){\\n            string check = Encrypt(i);\\n            if(!string.IsNullOrEmpty(check))\\n              t.Insert(check);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string res = \"\";\\n        foreach(var i in word1){\\n            if(d.ContainsKey(i))\\n                res+= d[i];\\n            else return string.Empty;\\n        }\\n        return res;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        return t.Search(word2);\\n    }\\n}\\n\\npublic class Trie{\\n    public TrieNode root = new TrieNode();\\n    \\n    public void Insert(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)){\\n                temp.ch.Add(i,new TrieNode());\\n            }\\n            temp = temp.ch[i];\\n        }\\n        temp.end += 1;\\n    }\\n    public int Search(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)) return 0;\\n            temp = temp.ch[i];\\n        }\\n        return temp.end;\\n    }\\n}\\npublic class TrieNode{\\n    public char val;\\n    public Dictionary<char,TrieNode> ch = new ();\\n    public int end;\\n    \\n    public TrieNode(){}\\n    \\n    public TrieNode(char val){\\n        this.val = val;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514185,
                "title": "c-hashmap",
                "content": "```\\nclass Encrypter {\\npublic:\\n    vector<int>hash;\\n    vector<char>keys;\\n    vector<string>dict,values;\\n    unordered_map<string,int>mpEncrpyted;\\n    Encrypter(vector<char>& key, vector<string>& value, vector<string>& dictionary) {\\n        hash=vector<int>(26,-1);\\n        for(int i=0;i<key.size();i++)\\n        {\\n            hash[key[i]-\\'a\\']=i;\\n        }\\n        \\n        keys=key;\\n        values=value;\\n        dict=dictionary;\\n        for(string s:dict)\\n        {\\n            mpEncrpyted[encrypt(s)]++;\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        int n=word1.length();\\n        string ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(hash[word1[i]-\\'a\\']==-1)return \"\";\\n            ans+=values[hash[word1[i]-\\'a\\']];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return mpEncrpyted[word2];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    vector<int>hash;\\n    vector<char>keys;\\n    vector<string>dict,values;\\n    unordered_map<string,int>mpEncrpyted;\\n    Encrypter(vector<char>& key, vector<string>& value, vector<string>& dictionary) {\\n        hash=vector<int>(26,-1);\\n        for(int i=0;i<key.size();i++)\\n        {\\n            hash[key[i]-\\'a\\']=i;\\n        }\\n        \\n        keys=key;\\n        values=value;\\n        dict=dictionary;\\n        for(string s:dict)\\n        {\\n            mpEncrpyted[encrypt(s)]++;\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        int n=word1.length();\\n        string ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(hash[word1[i]-\\'a\\']==-1)return \"\";\\n            ans+=values[hash[word1[i]-\\'a\\']];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return mpEncrpyted[word2];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496934,
                "title": "python-dictionary-solution",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], d: List[str]):\\n        self.look = dict(zip(keys, values))\\n        self.d = Counter(self.encrypt(c) for c in d)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.look.get(c, \\'#\\') for c in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], d: List[str]):\\n        self.look = dict(zip(keys, values))\\n        self.d = Counter(self.encrypt(c) for c in d)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.look.get(c, \\'#\\') for c in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488939,
                "title": "encrypt",
                "content": "class Encrypter {\\npublic:\\n    map<char,string>mp1;\\n    map<string,set<char>>mp2;\\n     vector<string>d;\\n    Encrypter(vector<char>& key, vector<string>& values, vector<string>& dict) {\\n        for(int i=0;i<key.size();i++){\\n            mp1[key[i]]=values[i];\\n            mp2[values[i]].insert(key[i]);\\n        }\\n        d=dict;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(auto x:word1){\\n            if(mp1.find(x)==mp1.end()) return \"\";\\n            res+=mp1[x];\\n        }\\n        return res;\\n    }\\n    int decrypt(string w) {\\n        int n=w.size();\\n        if(n%2) return 0;\\n        int ans=0;\\n        for(auto s:d){\\n            if(w==encrypt(s)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Encrypter {\\npublic:\\n    map<char,string>mp1;\\n    map<string,set<char>>mp2;\\n     vector<string>d;\\n    Encrypter(vector<char>& key, vector<string>& values, vector<string>& dict) {\\n        for(int i=0;i<key.size();i++){\\n            mp1[key[i]]=values[i];\\n            mp2[values[i]].insert(key[i]);\\n        }\\n        d=dict;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(auto x:word1){\\n            if(mp1.find(x)==mp1.end()) return \"\";\\n            res+=mp1[x];\\n        }\\n        return res;\\n    }\\n    int decrypt(string w) {\\n        int n=w.size();\\n        if(n%2) return 0;\\n        int ans=0;\\n        for(auto s:d){\\n            if(w==encrypt(s)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2488362,
                "title": "python-trie",
                "content": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h=defaultdict(lambda:\\'*\\')\\n        for key,value in zip(keys,values):\\n            self.h[key]=value\\n        self.trie=Trie()\\n        for word in dictionary:\\n            self.trie.add(\\'\\'.join(self.h[x] for x in word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.h[x] for x in word1 if self.h[x]!=\\'*\\')\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.trie.get(word2)\\n    \\nclass Trie:\\n    def __init__(self):\\n        self.root={}\\n    def add(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                node[cur]={}\\n            node=node[cur]\\n        if \\'#\\' not in node:\\n            node[\\'#\\']=1\\n        else:\\n            node[\\'#\\']+=1\\n    def get(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                return 0\\n            else:\\n                node=node[cur]\\n        if \\'#\\' in node:\\n            return node[\\'#\\']\\n        else:\\n            return 0\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h=defaultdict(lambda:\\'*\\')\\n        for key,value in zip(keys,values):\\n            self.h[key]=value\\n        self.trie=Trie()\\n        for word in dictionary:\\n            self.trie.add(\\'\\'.join(self.h[x] for x in word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.h[x] for x in word1 if self.h[x]!=\\'*\\')\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.trie.get(word2)\\n    \\nclass Trie:\\n    def __init__(self):\\n        self.root={}\\n    def add(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                node[cur]={}\\n            node=node[cur]\\n        if \\'#\\' not in node:\\n            node[\\'#\\']=1\\n        else:\\n            node[\\'#\\']+=1\\n    def get(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                return 0\\n            else:\\n                node=node[cur]\\n        if \\'#\\' in node:\\n            return node[\\'#\\']\\n        else:\\n            return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483394,
                "title": "just-use-encrypt-for-decrypt-simple-python-solution",
                "content": "```\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = {c : i for i, c in enumerate(keys)}\\n        self.val_list = values\\n        self.dict = set(dictionary)\\n       \\n    def encrypt(self, word1: str) -> str:    \\n        ans = \\'\\'\\n        for c in word1:\\n            if c not in self.keys:\\n                return \\'\\'\\n            ans += self.val_list[self.keys[c]]\\n        return ans \\n\\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        cnt = 0\\n        for c in self.dict:\\n            ans = self.encrypt(c)\\n            if ans == word2:\\n                cnt += 1\\n        \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = {c : i for i, c in enumerate(keys)}\\n        self.val_list = values\\n        self.dict = set(dictionary)\\n       \\n    def encrypt(self, word1: str) -> str:    \\n        ans = \\'\\'\\n        for c in word1:\\n            if c not in self.keys:\\n                return \\'\\'\\n            ans += self.val_list[self.keys[c]]\\n        return ans \\n\\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        cnt = 0\\n        for c in self.dict:\\n            ans = self.encrypt(c)\\n            if ans == word2:\\n                cnt += 1\\n        \\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2471560,
                "title": "python",
                "content": "```\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.dic = {x : i for i, x in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = dictionary\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for i in word1:\\n            if i not in self.dic:\\n                return \\'\\'\\n            res += self.values[self.dic[i]]\\n        return res\\n\\n    def decrypt(self, word2: str) -> int:\\n        cnt = 0\\n        for i in self.dictionary:\\n            s = self.encrypt(i)\\n            if s == word2:\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.dic = {x : i for i, x in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = dictionary\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for i in word1:\\n            if i not in self.dic:\\n                return \\'\\'\\n            res += self.values[self.dic[i]]\\n        return res\\n\\n    def decrypt(self, word2: str) -> int:\\n        cnt = 0\\n        for i in self.dictionary:\\n            s = self.encrypt(i)\\n            if s == word2:\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2402687,
                "title": "java-hashmap-84",
                "content": "```\\nclass Encrypter {\\n    Map<Character,String> encTable;\\n    Map<String,Integer> dictionaryMap;\\n    int decRes;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encTable = new HashMap<>();\\n        dictionaryMap = new HashMap<>();\\n        for(int i = 0; i < keys.length; i++){\\n            encTable.put(keys[i], values[i]);            \\n        }\\n        \\n        for(String s : dictionary){\\n            char[] cArr = s.toCharArray();\\n            StringBuilder sb = new StringBuilder();\\n            boolean appendYn = true;\\n            for(char c : cArr){\\n                if(!encTable.containsKey(c)){\\n                    appendYn = false;\\n                    break;                    \\n                }\\n                sb.append(encTable.get(c));\\n            }            \\n            \\n            if(!appendYn){\\n                continue;\\n            }\\n            \\n            String d = sb.toString();\\n            if(d.length() > 0){\\n                dictionaryMap.put(d,dictionaryMap.getOrDefault(d,0)+1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] cArr = word1.toCharArray();\\n        for(char c : cArr){\\n            sb.append(encTable.get(c));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {        \\n        return dictionaryMap.getOrDefault(word2,0);\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> encTable;\\n    Map<String,Integer> dictionaryMap;\\n    int decRes;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encTable = new HashMap<>();\\n        dictionaryMap = new HashMap<>();\\n        for(int i = 0; i < keys.length; i++){\\n            encTable.put(keys[i], values[i]);            \\n        }\\n        \\n        for(String s : dictionary){\\n            char[] cArr = s.toCharArray();\\n            StringBuilder sb = new StringBuilder();\\n            boolean appendYn = true;\\n            for(char c : cArr){\\n                if(!encTable.containsKey(c)){\\n                    appendYn = false;\\n                    break;                    \\n                }\\n                sb.append(encTable.get(c));\\n            }            \\n            \\n            if(!appendYn){\\n                continue;\\n            }\\n            \\n            String d = sb.toString();\\n            if(d.length() > 0){\\n                dictionaryMap.put(d,dictionaryMap.getOrDefault(d,0)+1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] cArr = word1.toCharArray();\\n        for(char c : cArr){\\n            sb.append(encTable.get(c));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {        \\n        return dictionaryMap.getOrDefault(word2,0);\\n    }\\n    \\n}",
                "codeTag": "Java"
            },
            {
                "id": 2309711,
                "title": "javascript-easy-to-undertand-beats-67",
                "content": "```\\nclass Encrypter {\\n    constructor (keys, values, dictionary) {\\n        this.encryptMap = keys.reduce((map, key, i) => (map[key] = values[i], map), {});\\n        this.encryptedVals = [...new Set(dictionary)].map((w) => this.encrypt(w));\\n    }\\n    \\n    encrypt (word) {\\n        return word.split(``).reduce((s, c) => s + this.encryptMap[c], ``);\\n    }\\n    \\n    decrypt (word) {\\n        return this.encryptedVals.filter((x) => x === word).length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Encrypter {\\n    constructor (keys, values, dictionary) {\\n        this.encryptMap = keys.reduce((map, key, i) => (map[key] = values[i], map), {});\\n        this.encryptedVals = [...new Set(dictionary)].map((w) => this.encrypt(w));\\n    }\\n    \\n    encrypt (word) {\\n        return word.split(``).reduce((s, c) => s + this.encryptMap[c], ``);\\n    }\\n    \\n    decrypt (word) {\\n        return this.encryptedVals.filter((x) => x === word).length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286710,
                "title": "javascript-with-pre-encryption",
                "content": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    this.encryptMap = new Map();\\n    for (let i = 0; i < keys.length; i++) {\\n        this.encryptMap.set(keys[i], values[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    // Encypt the values in dict for easy comparison later\\n    this.encryptedVals = [];\\n    for (let word of this.dict) {\\n        this.encryptedVals.push(this.encrypt(word));\\n    }\\n};\\nEncrypter.prototype.encrypt = function(word1) {\\n    let encrypted = \\'\\';\\n    for (let char of word1) {\\n        encrypted += this.encryptMap.get(char);\\n    }\\n    return encrypted;\\n};\\nEncrypter.prototype.decrypt = function(word2) {\\n    return this.encryptedVals.filter(x => x === word2).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    this.encryptMap = new Map();\\n    for (let i = 0; i < keys.length; i++) {\\n        this.encryptMap.set(keys[i], values[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    // Encypt the values in dict for easy comparison later\\n    this.encryptedVals = [];\\n    for (let word of this.dict) {\\n        this.encryptedVals.push(this.encrypt(word));\\n    }\\n};\\nEncrypter.prototype.encrypt = function(word1) {\\n    let encrypted = \\'\\';\\n    for (let char of word1) {\\n        encrypted += this.encryptMap.get(char);\\n    }\\n    return encrypted;\\n};\\nEncrypter.prototype.decrypt = function(word2) {\\n    return this.encryptedVals.filter(x => x === word2).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2126251,
                "title": "java-easy-solution-without-using-trie",
                "content": "\\n\\n\\n```\\nMap<Character, String> eMap;\\n    Map<String, Integer> dMap;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        eMap = new HashMap<>();\\n        dMap = new HashMap<>();\\n        for (int i = 0; i < keys.length; i++) \\n            eMap.put(keys[i], values[i]);\\n\\n        for (int i = 0; i < dictionary.length; i++) {\\n            String str = encrypt(dictionary[i]);\\n\\t\\t\\t/*\\n\\t\\t\\tInput: [\"Encrypter\",\"decrypt\"]  [[[\"a\"],[\"pq\"],[\"aa\",\"x\"]],[\"null\"]]\\n            Output: [null,1]   <------ wrong o/p\\n           Expected: [null,0]\\n\\t\\t\\tto avoid wrong ans,\\n\\t\\t\\twe need to put \"if condition\" after that we need to add in dMap to update the current value\\n\\t\\t\\t*/\\n            if (!str.equals(\"\") && !str.equals(\"null\"))\\n                dMap.put(str, dMap.getOrDefault(str, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            sb.append(eMap.get(c));\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return dMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nMap<Character, String> eMap;\\n    Map<String, Integer> dMap;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        eMap = new HashMap<>();\\n        dMap = new HashMap<>();\\n        for (int i = 0; i < keys.length; i++) \\n            eMap.put(keys[i], values[i]);\\n\\n        for (int i = 0; i < dictionary.length; i++) {\\n            String str = encrypt(dictionary[i]);\\n\\t\\t\\t/*\\n\\t\\t\\tInput: [\"Encrypter\",\"decrypt\"]  [[[\"a\"],[\"pq\"],[\"aa\",\"x\"]],[\"null\"]]\\n            Output: [null,1]   <------ wrong o/p\\n           Expected: [null,0]\\n\\t\\t\\tto avoid wrong ans,\\n\\t\\t\\twe need to put \"if condition\" after that we need to add in dMap to update the current value\\n\\t\\t\\t*/\\n            if (!str.equals(\"\") && !str.equals(\"null\"))\\n                dMap.put(str, dMap.getOrDefault(str, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            sb.append(eMap.get(c));\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return dMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2101700,
                "title": "kotlin-simple-ds-to-reverse-check-the-elements-without-a-trie",
                "content": "```\\nclass MultiString(val size: Int) {\\n    private val indexList: Array<MutableSet<Char>> = Array(size) {it -> mutableSetOf<Char>()}\\n    \\n    fun addPossibleCharsAtIndex(chars: Collection<Char>, index: Int) {\\n        indexList[index].addAll(chars)\\n    }\\n    \\n    override fun toString(): String {\\n        return indexList.joinToString(\",\")\\n    }\\n    fun match(other: String): Boolean {\\n        if(other.length != size) {\\n            return false\\n        }\\n        for(i in 0 until other.length) {\\n            if(!indexList[i].contains(other[i])) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n    \\n    private val keyMap = mutableMapOf<Char, String>()\\n    private val reverseMap = mutableMapOf<String, MutableSet<Char>>()\\n    private val dictSet = mutableListOf<String>()\\n    \\n    init {\\n        for(i in 0 until keys.size) {\\n            keyMap[keys[i]] = values[i]\\n            val reverseSet = reverseMap[values[i]] ?: mutableSetOf<Char>()\\n            reverseSet.add(keys[i])\\n            reverseMap[values[i]] = reverseSet\\n        }\\n        dictSet.addAll(dictionary)\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        val result = StringBuilder()\\n        var ok = true\\n        for(c in word1) {\\n            val value = keyMap[c] ?: run {\\n                ok = false\\n            }\\n            if(!ok) {\\n                break\\n            }\\n            result.append(value)\\n        }\\n        if(!ok) {\\n            return \"\"\\n        }\\n        return result.toString()\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var count = 0\\n        val word2MultiString = MultiString(word2.length/2)\\n        for(i in 0 until word2.length step 2) {\\n            val currentString = \"\" + word2[i] + word2[i+1]\\n            val chars = reverseMap[currentString] ?: return 0\\n            word2MultiString.addPossibleCharsAtIndex(chars, i/2)\\n        }\\n        //println(word2MultiString)\\n        \\n        for(dict in dictSet) {\\n            if(word2MultiString.match(dict)) {\\n                //println(\"$dict is a match\")\\n                count++\\n            }\\n        }\\n        return count\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MultiString(val size: Int) {\\n    private val indexList: Array<MutableSet<Char>> = Array(size) {it -> mutableSetOf<Char>()}\\n    \\n    fun addPossibleCharsAtIndex(chars: Collection<Char>, index: Int) {\\n        indexList[index].addAll(chars)\\n    }\\n    \\n    override fun toString(): String {\\n        return indexList.joinToString(\",\")\\n    }\\n    fun match(other: String): Boolean {\\n        if(other.length != size) {\\n            return false\\n        }\\n        for(i in 0 until other.length) {\\n            if(!indexList[i].contains(other[i])) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n    \\n    private val keyMap = mutableMapOf<Char, String>()\\n    private val reverseMap = mutableMapOf<String, MutableSet<Char>>()\\n    private val dictSet = mutableListOf<String>()\\n    \\n    init {\\n        for(i in 0 until keys.size) {\\n            keyMap[keys[i]] = values[i]\\n            val reverseSet = reverseMap[values[i]] ?: mutableSetOf<Char>()\\n            reverseSet.add(keys[i])\\n            reverseMap[values[i]] = reverseSet\\n        }\\n        dictSet.addAll(dictionary)\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        val result = StringBuilder()\\n        var ok = true\\n        for(c in word1) {\\n            val value = keyMap[c] ?: run {\\n                ok = false\\n            }\\n            if(!ok) {\\n                break\\n            }\\n            result.append(value)\\n        }\\n        if(!ok) {\\n            return \"\"\\n        }\\n        return result.toString()\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var count = 0\\n        val word2MultiString = MultiString(word2.length/2)\\n        for(i in 0 until word2.length step 2) {\\n            val currentString = \"\" + word2[i] + word2[i+1]\\n            val chars = reverseMap[currentString] ?: return 0\\n            word2MultiString.addPossibleCharsAtIndex(chars, i/2)\\n        }\\n        //println(word2MultiString)\\n        \\n        for(dict in dictSet) {\\n            if(word2MultiString.match(dict)) {\\n                //println(\"$dict is a match\")\\n                count++\\n            }\\n        }\\n        return count\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054508,
                "title": "java-trie",
                "content": "```\\nclass Encrypter {\\n    \\n    Map<Character,Integer> map = new HashMap<>();\\n    Map<String,List<Integer>> valueMap = new HashMap<>();\\n    char [] keys;\\n\\tTrie trie = new Trie();\\n    String[] values;\\n    \\n    class Trie{\\n        Map<Character,Trie> children = new HashMap<>();\\n        boolean leaf = false;\\n        \\n        void insert(String str,int idx){\\n            if(idx>=str.length()){\\n                this.leaf = true;\\n                return;\\n            }\\n            Trie child = children.get(str.charAt(idx));\\n            if(child==null){\\n                children.put(str.charAt(idx),new Trie());\\n            }\\n            children.get(str.charAt(idx)).insert(str,idx+1);\\n        }\\n        \\n        int search(String str, int idx){\\n            if(str.length()%2!=0){\\n                return 0;\\n            }\\n            if(idx>=str.length()){\\n                return this.leaf?1:0;\\n            }\\n            int count = 0;\\n            String next = str.substring(idx,idx+2);\\n            List<Integer> nextIndicies = valueMap.getOrDefault(next,new ArrayList<>());\\n            for(Integer nextIndex:nextIndicies){\\n                if(children.containsKey(keys[nextIndex])){\\n                    count += children.get(keys[nextIndex]).search(str, idx + 2);\\n                }\\n            }\\n            return count;\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        for(int i= 0;i<keys.length;i++){\\n            map.put(keys[i],i);\\n        }\\n        for(int i= 0;i<values.length;i++){\\n            List<Integer> list = valueMap.getOrDefault(values[i],new ArrayList<>());\\n            list.add(i);\\n            valueMap.put(values[i],list);\\n        }\\n        \\n        for(String str : dictionary){\\n            trie.insert(str,0);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuffer b = new StringBuffer();\\n        for(char ch : word1.toCharArray()){\\n            if(map.containsKey(ch)){\\n                b.append(values[map.get(ch)]);\\n            }else{\\n                return \"\";\\n            }\\n        }\\n        return b.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return trie.search(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    \\n    Map<Character,Integer> map = new HashMap<>();\\n    Map<String,List<Integer>> valueMap = new HashMap<>();\\n    char [] keys;\\n\\tTrie trie = new Trie();\\n    String[] values;\\n    \\n    class Trie{\\n        Map<Character,Trie> children = new HashMap<>();\\n        boolean leaf = false;\\n        \\n        void insert(String str,int idx){\\n            if(idx>=str.length()){\\n                this.leaf = true;\\n                return;\\n            }\\n            Trie child = children.get(str.charAt(idx));\\n            if(child==null){\\n                children.put(str.charAt(idx),new Trie());\\n            }\\n            children.get(str.charAt(idx)).insert(str,idx+1);\\n        }\\n        \\n        int search(String str, int idx){\\n            if(str.length()%2!=0){\\n                return 0;\\n            }\\n            if(idx>=str.length()){\\n                return this.leaf?1:0;\\n            }\\n            int count = 0;\\n            String next = str.substring(idx,idx+2);\\n            List<Integer> nextIndicies = valueMap.getOrDefault(next,new ArrayList<>());\\n            for(Integer nextIndex:nextIndicies){\\n                if(children.containsKey(keys[nextIndex])){\\n                    count += children.get(keys[nextIndex]).search(str, idx + 2);\\n                }\\n            }\\n            return count;\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        for(int i= 0;i<keys.length;i++){\\n            map.put(keys[i],i);\\n        }\\n        for(int i= 0;i<values.length;i++){\\n            List<Integer> list = valueMap.getOrDefault(values[i],new ArrayList<>());\\n            list.add(i);\\n            valueMap.put(values[i],list);\\n        }\\n        \\n        for(String str : dictionary){\\n            trie.insert(str,0);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuffer b = new StringBuffer();\\n        for(char ch : word1.toCharArray()){\\n            if(map.containsKey(ch)){\\n                b.append(values[map.get(ch)]);\\n            }else{\\n                return \"\";\\n            }\\n        }\\n        return b.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return trie.search(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2023323,
                "title": "c-without-trie",
                "content": "```\\n#define forup(i,i0,n) for(int i=i0; i<=(int)n; i++)\\n#define fordown(i,n,i0) for(int i=n; i>=(int)i0; i--)\\n\\nclass Encrypter {\\n    map <char, string> keyToVal; \\n    map <string, set <char> > valToKey; \\n    vector <string> d; \\npublic:\\n    Encrypter(vector<char> keys, vector<string> values, vector<string> dict) {\\n        forup(i,0,keys.size()-1) {\\n            keyToVal[keys[i]] = values[i];\\n            valToKey[values[i]].insert(keys[i]);\\n        }\\n        d = dict;\\n    }\\n    \\n    string encrypt(string w) {\\n        string res=\"\";\\n        forup(i,0,w.size()-1) {\\n            if (keyToVal.find(w[i]) == keyToVal.end()) return \"\"; \\n            res += keyToVal[w[i]]; \\n        }\\n        return res; \\n    }\\n    \\n    int decrypt(string w) {\\n        int n = w.size();\\n        if (n%2 == 1) return 0; \\n        int ans = 0;\\n        for(string cand : d) {\\n            if (cand.size() == n/2) {\\n                bool ok = true; \\n                for(int i = 0; i < n; i+=2) {\\n                    string val = \"\"; val+=w[i]; val+=w[i+1]; \\n                    if (valToKey.find(val) != valToKey.end()) {\\n                        if (valToKey[val].find(cand[i/2]) == valToKey[val].end()) ok = false; \\n                    }\\n                    else ok = false; \\n                }\\n                if (ok) ans++;\\n            }\\n        }\\n        return ans;          \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define forup(i,i0,n) for(int i=i0; i<=(int)n; i++)\\n#define fordown(i,n,i0) for(int i=n; i>=(int)i0; i--)\\n\\nclass Encrypter {\\n    map <char, string> keyToVal; \\n    map <string, set <char> > valToKey; \\n    vector <string> d; \\npublic:\\n    Encrypter(vector<char> keys, vector<string> values, vector<string> dict) {\\n        forup(i,0,keys.size()-1) {\\n            keyToVal[keys[i]] = values[i];\\n            valToKey[values[i]].insert(keys[i]);\\n        }\\n        d = dict;\\n    }\\n    \\n    string encrypt(string w) {\\n        string res=\"\";\\n        forup(i,0,w.size()-1) {\\n            if (keyToVal.find(w[i]) == keyToVal.end()) return \"\"; \\n            res += keyToVal[w[i]]; \\n        }\\n        return res; \\n    }\\n    \\n    int decrypt(string w) {\\n        int n = w.size();\\n        if (n%2 == 1) return 0; \\n        int ans = 0;\\n        for(string cand : d) {\\n            if (cand.size() == n/2) {\\n                bool ok = true; \\n                for(int i = 0; i < n; i+=2) {\\n                    string val = \"\"; val+=w[i]; val+=w[i+1]; \\n                    if (valToKey.find(val) != valToKey.end()) {\\n                        if (valToKey[val].find(cand[i/2]) == valToKey[val].end()) ok = false; \\n                    }\\n                    else ok = false; \\n                }\\n                if (ok) ans++;\\n            }\\n        }\\n        return ans;          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973915,
                "title": "c-trie-based-solution",
                "content": "```\\nclass Encrypter {\\n    unordered_map<char, string> map;\\n    unordered_map<string, vector<char>> reverse_map;\\n    class trie {\\n      vector<trie*> next;\\n      bool end;\\n    public:\\n      trie() {\\n        next.resize(26, nullptr);\\n        end = false;\\n      }\\n      ~trie() {\\n        for (trie *t : next) delete t;\\n        next.clear();\\n      }\\n      void add(const std::string &s) {\\n        trie *t = this;\\n        for (int i = 0; i < s.length(); i++) {\\n          if (t->next[s[i]-\\'a\\'] == nullptr) {\\n            t->next[s[i]-\\'a\\'] = new trie;\\n          }\\n          t = t->next[s[i]-\\'a\\'];\\n        }\\n        t->end = true;\\n      }\\n      trie* nextNode(char ch) {\\n        return next[ch-\\'a\\'];\\n      }\\n      bool isValid() { return end; }        \\n    };\\n    trie t;    \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (string &s: dictionary)\\n          t.add(s);\\n        for (int i = 0; i < keys.size(); i++) { \\n            map[keys[i]] = values[i];\\n            reverse_map[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for (char ch: word1) {\\n            auto it = map.find(ch);\\n            if (it != map.end())\\n                ss << it->second;\\n            else ss << ch;\\n        }\\n        return ss.str();\\n    }\\n\\n    void helper(std::string &s, int &cnt, int index, trie* node) {\\n      if (index >= s.length()) {\\n        if (node && node->isValid())\\n            cnt++;\\n        return;\\n      }\\n      string t = s.substr(index, 2);\\n      for (char ch: reverse_map[t]) {\\n        trie *t_node = node->nextNode(ch);\\n        if (t_node != nullptr) {\\n          helper(s, cnt, index+2, t_node);\\n        }\\n      }\\n    }    \\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        helper(word2, cnt, 0, &t);\\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    unordered_map<char, string> map;\\n    unordered_map<string, vector<char>> reverse_map;\\n    class trie {\\n      vector<trie*> next;\\n      bool end;\\n    public:\\n      trie() {\\n        next.resize(26, nullptr);\\n        end = false;\\n      }\\n      ~trie() {\\n        for (trie *t : next) delete t;\\n        next.clear();\\n      }\\n      void add(const std::string &s) {\\n        trie *t = this;\\n        for (int i = 0; i < s.length(); i++) {\\n          if (t->next[s[i]-\\'a\\'] == nullptr) {\\n            t->next[s[i]-\\'a\\'] = new trie;\\n          }\\n          t = t->next[s[i]-\\'a\\'];\\n        }\\n        t->end = true;\\n      }\\n      trie* nextNode(char ch) {\\n        return next[ch-\\'a\\'];\\n      }\\n      bool isValid() { return end; }        \\n    };\\n    trie t;    \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (string &s: dictionary)\\n          t.add(s);\\n        for (int i = 0; i < keys.size(); i++) { \\n            map[keys[i]] = values[i];\\n            reverse_map[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for (char ch: word1) {\\n            auto it = map.find(ch);\\n            if (it != map.end())\\n                ss << it->second;\\n            else ss << ch;\\n        }\\n        return ss.str();\\n    }\\n\\n    void helper(std::string &s, int &cnt, int index, trie* node) {\\n      if (index >= s.length()) {\\n        if (node && node->isValid())\\n            cnt++;\\n        return;\\n      }\\n      string t = s.substr(index, 2);\\n      for (char ch: reverse_map[t]) {\\n        trie *t_node = node->nextNode(ch);\\n        if (t_node != nullptr) {\\n          helper(s, cnt, index+2, t_node);\\n        }\\n      }\\n    }    \\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        helper(word2, cnt, 0, &t);\\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969128,
                "title": "java-trie-based-faster-than-95-mem-less-than-87",
                "content": "```\\nclass Encrypter {\\n    Map<Character, Integer> keysMap;\\n    Map<String, Set<Integer>> valuesMap;\\n    char[] keys;\\n    String[] values;\\n    Trie trie;\\n    Map<String, Integer> decMem;\\n    Map<String, String> encMem;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.keysMap = new HashMap<>();\\n        this.valuesMap = new HashMap<>();\\n        this.trie = new Trie();\\n        decMem = new HashMap<>();\\n        encMem = new HashMap<>();\\n        for(int i=0; i<keys.length; i++){\\n            keysMap.put(keys[i], i);\\n        }\\n        for(int i=0; i< this.values.length; i++){\\n            Set<Integer> st = valuesMap.getOrDefault(values[i], new HashSet<>());\\n            st.add(i);\\n            valuesMap.put(values[i], st);\\n        }\\n        for(String s: dictionary){\\n            trie.add(s);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        if(encMem.containsKey(word1)) return encMem.get(word1);\\n        StringBuilder res = new StringBuilder();\\n        for(int i=0; i<word1.length(); i++){\\n            if(!keysMap.containsKey(word1.charAt(i))) return \"\";\\n            String repl = this.values[keysMap.get(word1.charAt(i))];\\n            res.append(repl);\\n        }\\n        String ans = res.toString();\\n        encMem.put(word1, ans);\\n        return ans;\\n    } \\n     public int decrypt(String word2) {\\n         if(decMem.containsKey(word2)) return decMem.get(word2);\\n         int ans = decryptRec(word2, 0, new StringBuilder(), this.trie);\\n         decMem.put(word2, ans);\\n         return ans;\\n     }\\n    public int decryptRec(String word2, int start, StringBuilder prefix, Trie t) {\\n        //handle base case\\n        if(start>=word2.length()) {\\n            if(this.trie.wordExists(prefix)) return 1;\\n            return 0;\\n        }\\n        String hashed = word2.substring(start, start+2);\\n        Set<Integer> indcs = valuesMap.getOrDefault(hashed, new HashSet<>());\\n        int ans = 0;\\n        for(Integer i: indcs){\\n            char repl = keys[i];\\n            prefix.append(repl);\\n            if(t.links.containsKey(repl)) ans = ans + decryptRec(word2, start+2, prefix, t.links.get(repl));\\n            prefix.deleteCharAt(prefix.length()-1);\\n        }\\n        return ans;\\n    }\\n}\\nclass Trie{\\n    Map<Character, Trie> links = new HashMap<>();\\n    boolean isTerminal = false;\\n    String word = null;\\n    public void add(String s){\\n        Trie cur = this;\\n        for(int i=0; i<s.length(); i++){\\n            Trie next = cur.links.getOrDefault(s.charAt(i), new Trie());\\n            cur.links.put(s.charAt(i), next);\\n            if(i==s.length()-1){\\n                next.isTerminal = true;\\n                next.word = s;\\n            }\\n            cur = next;\\n        }\\n    }\\n    public boolean prefixExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return true;\\n    }\\n    public boolean wordExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            if(i==p.length()-1 && t.links.get(p.charAt(i)).isTerminal) return true;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    Map<Character, Integer> keysMap;\\n    Map<String, Set<Integer>> valuesMap;\\n    char[] keys;\\n    String[] values;\\n    Trie trie;\\n    Map<String, Integer> decMem;\\n    Map<String, String> encMem;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.keysMap = new HashMap<>();\\n        this.valuesMap = new HashMap<>();\\n        this.trie = new Trie();\\n        decMem = new HashMap<>();\\n        encMem = new HashMap<>();\\n        for(int i=0; i<keys.length; i++){\\n            keysMap.put(keys[i], i);\\n        }\\n        for(int i=0; i< this.values.length; i++){\\n            Set<Integer> st = valuesMap.getOrDefault(values[i], new HashSet<>());\\n            st.add(i);\\n            valuesMap.put(values[i], st);\\n        }\\n        for(String s: dictionary){\\n            trie.add(s);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        if(encMem.containsKey(word1)) return encMem.get(word1);\\n        StringBuilder res = new StringBuilder();\\n        for(int i=0; i<word1.length(); i++){\\n            if(!keysMap.containsKey(word1.charAt(i))) return \"\";\\n            String repl = this.values[keysMap.get(word1.charAt(i))];\\n            res.append(repl);\\n        }\\n        String ans = res.toString();\\n        encMem.put(word1, ans);\\n        return ans;\\n    } \\n     public int decrypt(String word2) {\\n         if(decMem.containsKey(word2)) return decMem.get(word2);\\n         int ans = decryptRec(word2, 0, new StringBuilder(), this.trie);\\n         decMem.put(word2, ans);\\n         return ans;\\n     }\\n    public int decryptRec(String word2, int start, StringBuilder prefix, Trie t) {\\n        //handle base case\\n        if(start>=word2.length()) {\\n            if(this.trie.wordExists(prefix)) return 1;\\n            return 0;\\n        }\\n        String hashed = word2.substring(start, start+2);\\n        Set<Integer> indcs = valuesMap.getOrDefault(hashed, new HashSet<>());\\n        int ans = 0;\\n        for(Integer i: indcs){\\n            char repl = keys[i];\\n            prefix.append(repl);\\n            if(t.links.containsKey(repl)) ans = ans + decryptRec(word2, start+2, prefix, t.links.get(repl));\\n            prefix.deleteCharAt(prefix.length()-1);\\n        }\\n        return ans;\\n    }\\n}\\nclass Trie{\\n    Map<Character, Trie> links = new HashMap<>();\\n    boolean isTerminal = false;\\n    String word = null;\\n    public void add(String s){\\n        Trie cur = this;\\n        for(int i=0; i<s.length(); i++){\\n            Trie next = cur.links.getOrDefault(s.charAt(i), new Trie());\\n            cur.links.put(s.charAt(i), next);\\n            if(i==s.length()-1){\\n                next.isTerminal = true;\\n                next.word = s;\\n            }\\n            cur = next;\\n        }\\n    }\\n    public boolean prefixExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return true;\\n    }\\n    public boolean wordExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            if(i==p.length()-1 && t.links.get(p.charAt(i)).isTerminal) return true;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962125,
                "title": "c-2227-encrypt-and-decrypt-strings",
                "content": "\\n```\\nclass Encrypter {\\n    unordered_map<char, string> mp; \\n    unordered_map<string, int> freq; \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) mp[keys[i]] = values[i]; \\n        for (auto& word : dictionary) {\\n            string key; \\n            for (auto& ch : word) \\n                if (!mp.count(ch)) key += \"##\"; \\n                else key += mp[ch]; \\n            ++freq[key]; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans; \\n        for (auto& ch : word1) ans += mp[ch]; \\n        return ans; \\n    }\\n    \\n    int decrypt(string word2) {\\n        return freq[word2]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\n    unordered_map<char, string> mp; \\n    unordered_map<string, int> freq; \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) mp[keys[i]] = values[i]; \\n        for (auto& word : dictionary) {\\n            string key; \\n            for (auto& ch : word) \\n                if (!mp.count(ch)) key += \"##\"; \\n                else key += mp[ch]; \\n            ++freq[key]; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans; \\n        for (auto& ch : word1) ans += mp[ch]; \\n        return ans; \\n    }\\n    \\n    int decrypt(string word2) {\\n        return freq[word2]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947464,
                "title": "simple-python-solution",
                "content": "class Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n\\n        self.values=values\\n        self.keys=keys\\n        self.dic=defaultdict(int)\\n        for i in dictionary:\\n            self.dic[self.encrypt(i)]+=1\\n        \\n        \"\"\"\\n        :type keys: List[str]\\n        :type values: List[str]\\n        :type dictionary: List[str]\\n        \"\"\"\\n        \\n\\n    def encrypt(self, word1):\\n        ans=\"\"\\n        for i in word1:\\n            if i not in self.keys:\\n                return 0\\n            ans+=self.values[(self.keys.index(i))]\\n        return ans\\n        \"\"\"\\n        :type word1: str\\n        :rtype: str\\n        \"\"\"\\n        \\n\\n    def decrypt(self, word2):\\n        return self.dic[word2]\\n        \"\"\"\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        \\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n\\n        self.values=values\\n        self.keys=keys\\n        self.dic=defaultdict(int)\\n        for i in dictionary:\\n            self.dic[self.encrypt(i)]+=1\\n        \\n        \"\"\"\\n        :type keys: List[str]\\n        :type values: List[str]\\n        :type dictionary: List[str]\\n        \"\"\"\\n        \\n\\n    def encrypt(self, word1):\\n        ans=\"\"\\n        for i in word1:\\n            if i not in self.keys:\\n                return 0\\n            ans+=self.values[(self.keys.index(i))]\\n        return ans\\n        \"\"\"\\n        :type word1: str\\n        :rtype: str\\n        \"\"\"\\n        \\n\\n    def decrypt(self, word2):\\n        return self.dic[word2]\\n        \"\"\"\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1942236,
                "title": "trie-bfs",
                "content": "```\\nclass Encrypter \\n{\\nprivate:\\n    unordered_map<char,string> m;\\n    unordered_map<string,vector<char>> ump;\\n    struct Node\\n    {\\n        Node* links[26];\\n        bool flag=false;\\n        \\n        bool containsKey(char ch)\\n        {\\n            return links[ch-\\'a\\']!=nullptr;\\n        }\\n\\n        void put(char ch,Node* node)\\n        {\\n            links[ch-\\'a\\']=node;\\n        }\\n        \\n        Node* get(char ch)\\n        {\\n            return links[ch-\\'a\\'];\\n        }\\n        \\n        void setEnd()\\n        {\\n            flag = true;\\n        }\\n    };\\n    \\n    void insert(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(!node->containsKey(word[i]))\\n            {\\n                node->put(word[i],new Node());\\n            }\\n            node = node->get(word[i]);\\n        }\\n        node->setEnd();\\n    }\\n    \\n    bool search(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(node->containsKey(word[i]))\\n                node=node->get(word[i]);\\n            else\\n                return false;\\n        }\\n        return node->flag;\\n    }\\n    Node* root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) \\n    {\\n        root=new Node();\\n        for(string s:dictionary)\\n            insert(root,s);\\n        ump.clear();\\n        m.clear();\\n        for(int i=0;i<keys.size();i++){\\n            m[keys[i]]=values[i];\\n            ump[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) \\n    {\\n        string ans=\"\";\\n        for(char c : word1)\\n        {\\n            ans+=m[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) \\n    {\\n        int ans=0;\\n        vector<vector<char>> v;        \\n        for(int i=0;i<word2.length();i+=2)\\n        {\\n            string str = word2.substr(i,2);\\n            vector<char> temp;\\n            for(char c : ump[str])\\n            {\\n                temp.push_back(c);\\n            }    \\n            v.push_back(temp);\\n        }\\n        int j=0;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        int f = v.size()-1;\\n        \\n        while(j<v.size() && !q.empty())\\n        {\\n            Node* temp = q.front();\\n            if(temp == nullptr)\\n            {\\n                j++;\\n                q.pop();\\n                if(j!=v.size())\\n                    q.push(nullptr);\\n                continue;\\n            }\\n            if(j != f)\\n            {                \\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        q.push(temp->get(ch));\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        Node* t = temp->get(ch);\\n                        if(t->flag)\\n                            ans++;                        \\n                    }\\n                }\\n            }  \\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Trie",
                    "Queue"
                ],
                "code": "```\\nclass Encrypter \\n{\\nprivate:\\n    unordered_map<char,string> m;\\n    unordered_map<string,vector<char>> ump;\\n    struct Node\\n    {\\n        Node* links[26];\\n        bool flag=false;\\n        \\n        bool containsKey(char ch)\\n        {\\n            return links[ch-\\'a\\']!=nullptr;\\n        }\\n\\n        void put(char ch,Node* node)\\n        {\\n            links[ch-\\'a\\']=node;\\n        }\\n        \\n        Node* get(char ch)\\n        {\\n            return links[ch-\\'a\\'];\\n        }\\n        \\n        void setEnd()\\n        {\\n            flag = true;\\n        }\\n    };\\n    \\n    void insert(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(!node->containsKey(word[i]))\\n            {\\n                node->put(word[i],new Node());\\n            }\\n            node = node->get(word[i]);\\n        }\\n        node->setEnd();\\n    }\\n    \\n    bool search(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(node->containsKey(word[i]))\\n                node=node->get(word[i]);\\n            else\\n                return false;\\n        }\\n        return node->flag;\\n    }\\n    Node* root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) \\n    {\\n        root=new Node();\\n        for(string s:dictionary)\\n            insert(root,s);\\n        ump.clear();\\n        m.clear();\\n        for(int i=0;i<keys.size();i++){\\n            m[keys[i]]=values[i];\\n            ump[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) \\n    {\\n        string ans=\"\";\\n        for(char c : word1)\\n        {\\n            ans+=m[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) \\n    {\\n        int ans=0;\\n        vector<vector<char>> v;        \\n        for(int i=0;i<word2.length();i+=2)\\n        {\\n            string str = word2.substr(i,2);\\n            vector<char> temp;\\n            for(char c : ump[str])\\n            {\\n                temp.push_back(c);\\n            }    \\n            v.push_back(temp);\\n        }\\n        int j=0;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        int f = v.size()-1;\\n        \\n        while(j<v.size() && !q.empty())\\n        {\\n            Node* temp = q.front();\\n            if(temp == nullptr)\\n            {\\n                j++;\\n                q.pop();\\n                if(j!=v.size())\\n                    q.push(nullptr);\\n                continue;\\n            }\\n            if(j != f)\\n            {                \\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        q.push(temp->get(ch));\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        Node* t = temp->get(ch);\\n                        if(t->flag)\\n                            ans++;                        \\n                    }\\n                }\\n            }  \\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936856,
                "title": "c-simple-solution",
                "content": "*The solution is very intuitive.*\\n**1**. **Encrypt**:\\n\\tFor encryption, we need to replace every char of `word1` by its corresponding value. It is best to use a hashmap to store key, value pairs. So, while encrypting, replace every character by its corresponding value stored in the map `k2v`.\\n\\n**2**. **Decrypt**:\\n\\tSince we need to match every possible decryption with the given dictionary to see how many matches are there, it is better to reverse this approach. So, for every word in the dictionary, calculate the encrypted version and store the count of it in another hashmap `dict` . So, when decrypt function is called, we can just return the count of `dict[word2]`. Thing to note is, while calculating encryptions of words in a dictionary, not every char of a word will be in `k2v keys`. So, for those strings, no encryption is possible and hence we do need to store them (as they will never be able form a word with a possible decryption).\\n\\n```\\nclass Encrypter {\\nprivate:\\n    unordered_map<char, string> k2v;\\n    unordered_map<string, int> dict;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++){\\n            k2v[keys[i]] = values[i];\\n        }\\n        for(string d: dictionary){\\n            string enc = \"\";\\n            int flag = 0;\\n            for(char c: d){\\n                if(k2v.find(c) == k2v.end()){\\n                    flag = 1;\\n                    break;\\n                }\\n                enc += k2v[c];\\n            }\\n            if(!flag) dict[enc]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string enc = \"\";\\n        for(char c: word1){\\n            enc += k2v[c];\\n        }\\n        return enc;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dict[word2];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\nprivate:\\n    unordered_map<char, string> k2v;\\n    unordered_map<string, int> dict;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++){\\n            k2v[keys[i]] = values[i];\\n        }\\n        for(string d: dictionary){\\n            string enc = \"\";\\n            int flag = 0;\\n            for(char c: d){\\n                if(k2v.find(c) == k2v.end()){\\n                    flag = 1;\\n                    break;\\n                }\\n                enc += k2v[c];\\n            }\\n            if(!flag) dict[enc]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string enc = \"\";\\n        for(char c: word1){\\n            enc += k2v[c];\\n        }\\n        return enc;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dict[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930872,
                "title": "scala-trie-with-dfs",
                "content": "```scala\\n\\nclass Encrypter(_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n\\n  type int = Int\\n  import scala.collection.mutable.{HashMap, ArrayBuffer}\\n  val keys = new HashMap[Char, Int]\\n  _keys.zipWithIndex.foreach { case (v, i) =>\\n    keys += (v -> i)\\n  }\\n  type ab = ArrayBuffer[int]\\n  val values = new HashMap[String, ab]\\n  _values.zipWithIndex.foreach {\\n    case (x, i) => {\\n      if (!values.contains(x)) values += (x -> new ab)\\n      values(x) += i\\n    }\\n  }\\n\\n  case class Node(\\n      val c: Char,\\n      val chs: HashMap[Char, Node] = new HashMap[Char, Node],\\n      var isEnd: Boolean = false\\n  )\\n\\n  def f(_node: Node, str: String): Unit = {\\n    var node = _node\\n    str.toCharArray\\n      .foreach(c => {\\n        if (!node.chs.contains(c)) node.chs += (c -> (new Node(c)))\\n        node = node.chs(c)\\n      })\\n    node.isEnd = true\\n  }\\n\\n  val root = new Node(\\' \\')\\n  _dictionary.foreach(str => f(root, str))\\n\\n  // println(values )\\n  def encrypt(word1: String): String =\\n    word1.toCharArray\\n      .map(c => _values(keys(c)))\\n      .mkString\\n\\n  def decrypt(word2: String): Int = {\\n\\n    var count    = 0\\n    var continue = true\\n    def f(idx: int, node: Node): Unit = {\\n      if (!continue) return\\n      if (idx == word2.length()) {\\n        if (node.isEnd)\\n          count += 1\\n        return\\n      }\\n      val s = word2.charAt(idx) + \"\" + word2.charAt(idx + 1)\\n      if (!values.contains(s)) {\\n        continue = false\\n        return\\n      }\\n      values(s).foreach(id => if (node.chs.contains(_keys(id))) f(idx + 2, node.chs(_keys(id))))\\n\\n    }\\n\\n    f(0, root)\\n    count\\n\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```scala\\n\\nclass Encrypter(_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n\\n  type int = Int\\n  import scala.collection.mutable.{HashMap, ArrayBuffer}\\n  val keys = new HashMap[Char, Int]\\n  _keys.zipWithIndex.foreach { case (v, i) =>\\n    keys += (v -> i)\\n  }\\n  type ab = ArrayBuffer[int]\\n  val values = new HashMap[String, ab]\\n  _values.zipWithIndex.foreach {\\n    case (x, i) => {\\n      if (!values.contains(x)) values += (x -> new ab)\\n      values(x) += i\\n    }\\n  }\\n\\n  case class Node(\\n      val c: Char,\\n      val chs: HashMap[Char, Node] = new HashMap[Char, Node],\\n      var isEnd: Boolean = false\\n  )\\n\\n  def f(_node: Node, str: String): Unit = {\\n    var node = _node\\n    str.toCharArray\\n      .foreach(c => {\\n        if (!node.chs.contains(c)) node.chs += (c -> (new Node(c)))\\n        node = node.chs(c)\\n      })\\n    node.isEnd = true\\n  }\\n\\n  val root = new Node(\\' \\')\\n  _dictionary.foreach(str => f(root, str))\\n\\n  // println(values )\\n  def encrypt(word1: String): String =\\n    word1.toCharArray\\n      .map(c => _values(keys(c)))\\n      .mkString\\n\\n  def decrypt(word2: String): Int = {\\n\\n    var count    = 0\\n    var continue = true\\n    def f(idx: int, node: Node): Unit = {\\n      if (!continue) return\\n      if (idx == word2.length()) {\\n        if (node.isEnd)\\n          count += 1\\n        return\\n      }\\n      val s = word2.charAt(idx) + \"\" + word2.charAt(idx + 1)\\n      if (!values.contains(s)) {\\n        continue = false\\n        return\\n      }\\n      values(s).foreach(id => if (node.chs.contains(_keys(id))) f(idx + 2, node.chs(_keys(id))))\\n\\n    }\\n\\n    f(0, root)\\n    count\\n\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929920,
                "title": "java-trie-in-40-lines",
                "content": "```\\nprivate static class Node {\\n\\tprivate final String encryptedChar;\\n\\tprivate final Map<String, Node> nexts = new HashMap<>();\\n\\tprivate int wordCount = 0;\\n\\tprivate Node(String encryptedChar) {\\n\\t\\tthis.encryptedChar = encryptedChar;\\n\\t}\\n}\\nprivate final Map<Character, String> forwardMap = new HashMap<>();\\nprivate final Node start = new Node(null);\\npublic Encrypter(char[] keys, String[] values, String[] dictionary) {\\n\\tfor(int i = 0; i < keys.length; i++) {\\n\\t\\tforwardMap.put(keys[i], values[i]);\\n\\t}\\n\\tfor(String word : dictionary) {\\n\\t\\tNode node = start;\\n\\t\\tfor(int i = 0; i<word.length(); i++) {\\n\\t\\t\\tString encryptedChar = forwardMap.get(word.charAt(i));\\n\\t\\t\\tNode nextNode = node.nexts.computeIfAbsent(encryptedChar, key -> new Node(encryptedChar));\\n\\t\\t\\tif(i == word.length() - 1) nextNode.wordCount++;\\n\\t\\t\\tnode = nextNode;\\n\\t\\t}\\n\\t}\\n}\\npublic String encrypt(String word1) {\\n\\tStringBuffer result = new StringBuffer();\\n\\tfor(char c : word1.toCharArray()) result.append(forwardMap.get(c));\\n\\treturn result.toString();\\n}\\npublic int decrypt(String word2) {\\n\\tNode node = start;\\n\\tfor(int i = 0; i<word2.length() / 2; i++) {\\n\\t\\tString encryptedChar = word2.substring(i * 2, i * 2 + 2);\\n\\t\\tnode = node.nexts.get(encryptedChar);\\n\\t\\tif(node == null) return 0;\\n\\t}\\n\\treturn node.wordCount;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nprivate static class Node {\\n\\tprivate final String encryptedChar;\\n\\tprivate final Map<String, Node> nexts = new HashMap<>();\\n\\tprivate int wordCount = 0;\\n\\tprivate Node(String encryptedChar) {\\n\\t\\tthis.encryptedChar = encryptedChar;\\n\\t}\\n}\\nprivate final Map<Character, String> forwardMap = new HashMap<>();\\nprivate final Node start = new Node(null);\\npublic Encrypter(char[] keys, String[] values, String[] dictionary) {\\n\\tfor(int i = 0; i < keys.length; i++) {\\n\\t\\tforwardMap.put(keys[i], values[i]);\\n\\t}\\n\\tfor(String word : dictionary) {\\n\\t\\tNode node = start;\\n\\t\\tfor(int i = 0; i<word.length(); i++) {\\n\\t\\t\\tString encryptedChar = forwardMap.get(word.charAt(i));\\n\\t\\t\\tNode nextNode = node.nexts.computeIfAbsent(encryptedChar, key -> new Node(encryptedChar));\\n\\t\\t\\tif(i == word.length() - 1) nextNode.wordCount++;\\n\\t\\t\\tnode = nextNode;\\n\\t\\t}\\n\\t}\\n}\\npublic String encrypt(String word1) {\\n\\tStringBuffer result = new StringBuffer();\\n\\tfor(char c : word1.toCharArray()) result.append(forwardMap.get(c));\\n\\treturn result.toString();\\n}\\npublic int decrypt(String word2) {\\n\\tNode node = start;\\n\\tfor(int i = 0; i<word2.length() / 2; i++) {\\n\\t\\tString encryptedChar = word2.substring(i * 2, i * 2 + 2);\\n\\t\\tnode = node.nexts.get(encryptedChar);\\n\\t\\tif(node == null) return 0;\\n\\t}\\n\\treturn node.wordCount;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929334,
                "title": "java-sol-2-maps-and-precompute",
                "content": "Approach,\\n1. Make 2 maps\\n2. One for storing <keys[i],values[i]> pairs.\\n3. Second for storing decrypted string frequencies from dictionary array\\n4. While precomputing dictionary array, make sure not to store invalid decrypted strings\\n5. Below is the implementation for the same.\\n```\\nclass Encrypter {\\n    Map<Character,String> en;\\n    Map<String,Integer> deq;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        en = new HashMap<>();\\n        deq = new HashMap<>();\\n        int n = keys.length;\\n        //Encrypt Map\\n        for (int i = 0; i < n; i++) {\\n            en.put(keys[i],values[i]);\\n        }\\n        \\n        // Decrypted Strings from dictionary array\\n        for (String s : dictionary) {\\n            StringBuilder ans = new StringBuilder();\\n            boolean flag = true;\\n            for (char ch : s.toCharArray()) {\\n                if (en.get(ch) == null) {\\n                    flag = false;\\n                    break;\\n                }\\n                ans.append(en.get(ch));\\n            }\\n            String key = ans.toString();\\n            if (key.equals(\"\") || !flag) continue;\\n            deq.put(key,deq.getOrDefault(key,0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder ans = new StringBuilder();\\n        for (char ch : word1.toCharArray()) {\\n            ans.append(en.getOrDefault(ch,\"\"));\\n        }\\n        return ans.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return deq.getOrDefault(word2,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> en;\\n    Map<String,Integer> deq;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        en = new HashMap<>();\\n        deq = new HashMap<>();\\n        int n = keys.length;\\n        //Encrypt Map\\n        for (int i = 0; i < n; i++) {\\n            en.put(keys[i],values[i]);\\n        }\\n        \\n        // Decrypted Strings from dictionary array\\n        for (String s : dictionary) {\\n            StringBuilder ans = new StringBuilder();\\n            boolean flag = true;\\n            for (char ch : s.toCharArray()) {\\n                if (en.get(ch) == null) {\\n                    flag = false;\\n                    break;\\n                }\\n                ans.append(en.get(ch));\\n            }\\n            String key = ans.toString();\\n            if (key.equals(\"\") || !flag) continue;\\n            deq.put(key,deq.getOrDefault(key,0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder ans = new StringBuilder();\\n        for (char ch : word1.toCharArray()) {\\n            ans.append(en.getOrDefault(ch,\"\"));\\n        }\\n        return ans.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return deq.getOrDefault(word2,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928783,
                "title": "c-code-two-hashmap-s-only",
                "content": "```\\nclass Encrypter {\\npublic:\\n    \\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& d) {\\n        m1.clear();\\n        m2.clear();\\n        \\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]] = values[i];\\n        }\\n        \\n        for(int i=0;i<d.size();i++){\\n            string str = encrypt(d[i]);\\n            \\n            if(str != \"\"){\\n                 m2[str]++;\\n            }\\n           \\n            \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string str = \"\";\\n        \\n        for(int i=0;i<word1.size();i++){\\n            if(m1.find(word1[i])==m1.end()) return \"\";\\n            str += m1[word1[i]];\\n        }\\n       \\n        return str;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    \\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& d) {\\n        m1.clear();\\n        m2.clear();\\n        \\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]] = values[i];\\n        }\\n        \\n        for(int i=0;i<d.size();i++){\\n            string str = encrypt(d[i]);\\n            \\n            if(str != \"\"){\\n                 m2[str]++;\\n            }\\n           \\n            \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string str = \"\";\\n        \\n        for(int i=0;i<word1.size();i++){\\n            if(m1.find(word1[i])==m1.end()) return \"\";\\n            str += m1[word1[i]];\\n        }\\n       \\n        return str;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926771,
                "title": "java-hashmap",
                "content": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Encrypter {\\n\\n    private String[] dictionary;\\n    private Map<Character, String> charVsStringMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.dictionary = dictionary;\\n        for (int i = 0; i < keys.length; i++) {\\n            charVsStringMap.putIfAbsent(keys[i], values[i]);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            stringBuilder.append(charVsStringMap.get(c));\\n        }\\n        return stringBuilder.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        int ans = 0;\\n        for (String str : dictionary) {\\n            String newStr = \"\";\\n\\n            for (char ch : str.toCharArray()) {\\n\\n                if (charVsStringMap.containsKey(ch)) {\\n                    newStr += charVsStringMap.get(ch);\\n\\n                } else {\\n                    newStr = \"\";\\n                    break;\\n                }\\n            }\\n            if (newStr.equals(word2)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Encrypter {\\n\\n    private String[] dictionary;\\n    private Map<Character, String> charVsStringMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.dictionary = dictionary;\\n        for (int i = 0; i < keys.length; i++) {\\n            charVsStringMap.putIfAbsent(keys[i], values[i]);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            stringBuilder.append(charVsStringMap.get(c));\\n        }\\n        return stringBuilder.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        int ans = 0;\\n        for (String str : dictionary) {\\n            String newStr = \"\";\\n\\n            for (char ch : str.toCharArray()) {\\n\\n                if (charVsStringMap.containsKey(ch)) {\\n                    newStr += charVsStringMap.get(ch);\\n\\n                } else {\\n                    newStr = \"\";\\n                    break;\\n                }\\n            }\\n            if (newStr.equals(word2)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926295,
                "title": "golang-trie",
                "content": "```\\ntype Encrypter struct {\\n    k2v map[byte]string\\n    v2k map[string][]byte\\n    trie *node\\n}\\n\\ntype node struct {\\n    next []*node\\n    end bool\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    k2v := make(map[byte]string)\\n    v2k := make(map[string][]byte)\\n    \\n    for i, k := range keys {\\n        k2v[k] = values[i]\\n    }\\n    \\n    for i, v := range values {\\n        v2k[v] = append(v2k[v], keys[i])\\n    }\\n    \\n    trie := &node{\\n        next: make([]*node, 26),\\n        end: false,\\n    }\\n    \\n    for _, w := range dictionary {\\n        cur := trie\\n        for _, r := range w {\\n            if cur.next[r - \\'a\\'] == nil {\\n                cur.next[r - \\'a\\'] = &node{\\n                    next: make([]*node, 26),\\n                    end: false,\\n                }\\n            }\\n            cur = cur.next[r - \\'a\\']\\n        }\\n        cur.end = true\\n    }\\n    \\n    return Encrypter{\\n        k2v: k2v,\\n        v2k: v2k,\\n        trie: trie,\\n    }    \\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    var res bytes.Buffer\\n    for i := 0; i < len(word1); i++ {\\n        res.WriteString(this.k2v[word1[i]])\\n    }\\n    return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.dfs(word2)\\n}\\n\\nfunc (this *Encrypter) dfs(word2 string) int {\\n    if len(word2) == 0 {\\n        if this.trie.end {\\n            return 1\\n        } else {\\n            return 0\\n        }\\n    }\\n    \\n    res := 0\\n    for _, b := range this.v2k[word2[:2]] {\\n        if this.trie.next[b - \\'a\\'] != nil {\\n            tmp := this.trie\\n            this.trie = this.trie.next[b - \\'a\\']\\n            res += this.dfs(word2[2:])\\n            this.trie = tmp\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype Encrypter struct {\\n    k2v map[byte]string\\n    v2k map[string][]byte\\n    trie *node\\n}\\n\\ntype node struct {\\n    next []*node\\n    end bool\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    k2v := make(map[byte]string)\\n    v2k := make(map[string][]byte)\\n    \\n    for i, k := range keys {\\n        k2v[k] = values[i]\\n    }\\n    \\n    for i, v := range values {\\n        v2k[v] = append(v2k[v], keys[i])\\n    }\\n    \\n    trie := &node{\\n        next: make([]*node, 26),\\n        end: false,\\n    }\\n    \\n    for _, w := range dictionary {\\n        cur := trie\\n        for _, r := range w {\\n            if cur.next[r - \\'a\\'] == nil {\\n                cur.next[r - \\'a\\'] = &node{\\n                    next: make([]*node, 26),\\n                    end: false,\\n                }\\n            }\\n            cur = cur.next[r - \\'a\\']\\n        }\\n        cur.end = true\\n    }\\n    \\n    return Encrypter{\\n        k2v: k2v,\\n        v2k: v2k,\\n        trie: trie,\\n    }    \\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    var res bytes.Buffer\\n    for i := 0; i < len(word1); i++ {\\n        res.WriteString(this.k2v[word1[i]])\\n    }\\n    return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.dfs(word2)\\n}\\n\\nfunc (this *Encrypter) dfs(word2 string) int {\\n    if len(word2) == 0 {\\n        if this.trie.end {\\n            return 1\\n        } else {\\n            return 0\\n        }\\n    }\\n    \\n    res := 0\\n    for _, b := range this.v2k[word2[:2]] {\\n        if this.trie.next[b - \\'a\\'] != nil {\\n            tmp := this.trie\\n            this.trie = this.trie.next[b - \\'a\\']\\n            res += this.dfs(word2[2:])\\n            this.trie = tmp\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1925491,
                "title": "java-trie-dfs-hashmaps",
                "content": "Runtime: 970 ms, faster than 27.23% of Java online submissions for Encrypt and Decrypt Strings.\\nMemory Usage: 509.4 MB, less than 5.06% of Java online submissions for Encrypt and Decrypt Strings.\\n```\\nclass Encrypter {\\n  class Node{                                            //class for each node in Trie\\n    public Node[] p;                                     //array all neigbours    \\n    public boolean eow;                                  //mark for end of word\\n    \\n    Node (){\\n      p = new Node[26];                                  //whan we construct node\\n      for(int i = 0; i != 26; i++) p[i] = null;          //we inicialize all neigbours as \"null\"  \\n      eow = false;                                       //and check our mark for end of word as false\\n    }\\n  }\\n  public Node root;                                      //root of Trie\\n    \\n  public void insert(String w) { \\n    Node n = root;                                       //node for traversal through Trie\\n    for(int i = 0; i < w.length(); i++){                 \\n      int id = (int)(w.charAt(i) - \\'a\\');                 //fetch current letter from word and calculate index for it\\n      \\n      if(n.p[id] != null) n = n.p[id];                   //if this letter is presented in table move to next\\n      else                                               //if not \\n        for(; i != w.length(); i++){                     //create new nodes\\n          id = (int)(w.charAt(i) - \\'a\\');\\n          n.p[id] = new Node();\\n          n = n.p[id];\\n        }\\n    }\\n    n.eow = true;                                        //check last node as end of word\\n  }\\n      \\n  Map<Character, String> en;                             //for encoding strings\\n  Map<String, List<Integer>> de;                         //{string, list of indexes of letters with this string} \\n  Map<String, Integer> answeres;                         //for coinciding enquiries\\n  int ans;                                               //for counting all possibilities for each enquiry \\n  \\n  public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n    en = new HashMap<>();\\n    de = new HashMap<>();\\n    answeres = new HashMap<>();\\n    root = new Node();                                   //construct new Trie\\n    root.eow = true;                                     //and put string \"\"\\n  \\n    \\n    for(int i = 0; i != keys.length; i++){               //fill our hashmaps\\n      en.put(keys[i], values[i]);\\n      if(!de.containsKey(values[i])){\\n        List<Integer> list = new ArrayList<>();\\n        de.put(values[i], list);\\n      }\\n      de.get(values[i]).add(keys[i] - \\'a\\');\\n    }\\n    \\n    for(int i = 0; i != dictionary.length; i++)          //and construct Trie\\n      insert(dictionary[i]);\\n  }\\n    \\n  public String encrypt(String word1) {                  //construct answer\\n    String ans = \"\";\\n    for(int i = 0; i != word1.length(); i++)\\n      ans += en.get(word1.charAt(i));\\n    \\n    return ans;\\n  }\\n    \\n  public int decrypt(String word2) {\\n    if(answeres.containsKey(word2)) return answeres.get(word2);   //if we already have this inquiry\\n    \\n    ans = 0;                                                      //refrash counter of all possibilities\\n    dfs(0, root, word2);                                          //dfs\\n    answeres.put(word2, ans);                                     //put this answer for next inquiries\\n    \\n    return ans;   \\n  }\\n  \\n  public void dfs(int i, Node node, String w){                    //dfs\\n    String key = w.substring(i, i + 2);                           //fetch current substring\\n    if(de.containsKey(key))                                       //if we have keys for this substring\\n      for(int j = 0; j != de.get(key).size(); j++)                //try to move through Trie\\n        if( node.p[de.get(key).get(j)] != null) {                 //if we dont have node in Trie\\n          if(i + 2 == w.length()){                             //if we reach end of current word\\n            if(node.p[de.get(key).get(j)].eow == true) ans++;     //check : have we this word in Trie?\\n          }\\n          else dfs(i+2, node.p[de.get(key).get(j)], w);        //if we dont reach\\n    }\\n  }\\n  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n  class Node{                                            //class for each node in Trie\\n    public Node[] p;                                     //array all neigbours    \\n    public boolean eow;                                  //mark for end of word\\n    \\n    Node (){\\n      p = new Node[26];                                  //whan we construct node\\n      for(int i = 0; i != 26; i++) p[i] = null;          //we inicialize all neigbours as \"null\"  \\n      eow = false;                                       //and check our mark for end of word as false\\n    }\\n  }\\n  public Node root;                                      //root of Trie\\n    \\n  public void insert(String w) { \\n    Node n = root;                                       //node for traversal through Trie\\n    for(int i = 0; i < w.length(); i++){                 \\n      int id = (int)(w.charAt(i) - \\'a\\');                 //fetch current letter from word and calculate index for it\\n      \\n      if(n.p[id] != null) n = n.p[id];                   //if this letter is presented in table move to next\\n      else                                               //if not \\n        for(; i != w.length(); i++){                     //create new nodes\\n          id = (int)(w.charAt(i) - \\'a\\');\\n          n.p[id] = new Node();\\n          n = n.p[id];\\n        }\\n    }\\n    n.eow = true;                                        //check last node as end of word\\n  }\\n      \\n  Map<Character, String> en;                             //for encoding strings\\n  Map<String, List<Integer>> de;                         //{string, list of indexes of letters with this string} \\n  Map<String, Integer> answeres;                         //for coinciding enquiries\\n  int ans;                                               //for counting all possibilities for each enquiry \\n  \\n  public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n    en = new HashMap<>();\\n    de = new HashMap<>();\\n    answeres = new HashMap<>();\\n    root = new Node();                                   //construct new Trie\\n    root.eow = true;                                     //and put string \"\"\\n  \\n    \\n    for(int i = 0; i != keys.length; i++){               //fill our hashmaps\\n      en.put(keys[i], values[i]);\\n      if(!de.containsKey(values[i])){\\n        List<Integer> list = new ArrayList<>();\\n        de.put(values[i], list);\\n      }\\n      de.get(values[i]).add(keys[i] - \\'a\\');\\n    }\\n    \\n    for(int i = 0; i != dictionary.length; i++)          //and construct Trie\\n      insert(dictionary[i]);\\n  }\\n    \\n  public String encrypt(String word1) {                  //construct answer\\n    String ans = \"\";\\n    for(int i = 0; i != word1.length(); i++)\\n      ans += en.get(word1.charAt(i));\\n    \\n    return ans;\\n  }\\n    \\n  public int decrypt(String word2) {\\n    if(answeres.containsKey(word2)) return answeres.get(word2);   //if we already have this inquiry\\n    \\n    ans = 0;                                                      //refrash counter of all possibilities\\n    dfs(0, root, word2);                                          //dfs\\n    answeres.put(word2, ans);                                     //put this answer for next inquiries\\n    \\n    return ans;   \\n  }\\n  \\n  public void dfs(int i, Node node, String w){                    //dfs\\n    String key = w.substring(i, i + 2);                           //fetch current substring\\n    if(de.containsKey(key))                                       //if we have keys for this substring\\n      for(int j = 0; j != de.get(key).size(); j++)                //try to move through Trie\\n        if( node.p[de.get(key).get(j)] != null) {                 //if we dont have node in Trie\\n          if(i + 2 == w.length()){                             //if we reach end of current word\\n            if(node.p[de.get(key).get(j)].eow == true) ans++;     //check : have we this word in Trie?\\n          }\\n          else dfs(i+2, node.p[de.get(key).get(j)], w);        //if we dont reach\\n    }\\n  }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924906,
                "title": "python-solution-with-explanation",
                "content": "I refrain from using \"+\" operator to concatenate strings in the encrypt method because that would give us the O(word1)**2 squared complexity since strings are immutable and we are basically copying everything to a new string every time. So it would be more efficient and apt to use \"join\" statement as it would cost us just O(word1) time.\\n\\nPlease let me know in the comments if something is not clear.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.mapping = defaultdict(str)\\n        \\n\\t\\t#mapping each key to its respective value\\n        for x, y in zip(keys, values): \\n            self.mapping[x] = y            \\n            \\n        self.frequency = defaultdict(int)\\n        \\n\\t\\t#encrpting every worder by function calling and updating \\n\\t\\t#how many times the encrypted sequene occurs\\n        for word in dictionary:\\n            self.frequency[self.encrypt(word)] += 1  \\n        \\n  \\n    def encrypt(self, word1: str) -> str:\\n\\t    #Using list. So that it would be efficient to concatenate it at the end using join.\\n        res = [] \\n        \\n        for c in word1:\\n            if c in self.mapping:\\n                res.append(self.mapping[c])\\n            else:\\n                return \\'\\' \\n\\t\\t\\t\\t# #it\\'s important that even if one charecter is missing, we should\\n\\t\\t\\t\\t#return an empty string or else it would give wrong output\\n\\t\\t\\t\\t\\n        return \"\".join(res)  \\n        \\n\\t\\t\\n    def decrypt(self, word2: str) -> int:\\n\\t\\n\\t    #return the frequency of the encrypted sequence\\n        return self.frequency[word2]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "I refrain from using \"+\" operator to concatenate strings in the encrypt method because that would give us the O(word1)**2 squared complexity since strings are immutable and we are basically copying everything to a new string every time. So it would be more efficient and apt to use \"join\" statement as it would cost us just O(word1) time.\\n\\nPlease let me know in the comments if something is not clear.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.mapping = defaultdict(str)\\n        \\n\\t\\t#mapping each key to its respective value\\n        for x, y in zip(keys, values): \\n            self.mapping[x] = y            \\n            \\n        self.frequency = defaultdict(int)\\n        \\n\\t\\t#encrpting every worder by function calling and updating \\n\\t\\t#how many times the encrypted sequene occurs\\n        for word in dictionary:\\n            self.frequency[self.encrypt(word)] += 1  \\n        \\n  \\n    def encrypt(self, word1: str) -> str:\\n\\t    #Using list. So that it would be efficient to concatenate it at the end using join.\\n        res = [] \\n        \\n        for c in word1:\\n            if c in self.mapping:\\n                res.append(self.mapping[c])\\n            else:\\n                return \\'\\' \\n\\t\\t\\t\\t# #it\\'s important that even if one charecter is missing, we should\\n\\t\\t\\t\\t#return an empty string or else it would give wrong output\\n\\t\\t\\t\\t\\n        return \"\".join(res)  \\n        \\n\\t\\t\\n    def decrypt(self, word2: str) -> int:\\n\\t\\n\\t    #return the frequency of the encrypted sequence\\n        return self.frequency[word2]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1920939,
                "title": "swift-hash-map-solution",
                "content": "```\\n\\nclass Encrypter {\\n\\n    var dict = [Character: String]()\\n    var map = [String: [String]]()\\n\\n    init(_ keys: [Character], _ values: [String], _ dictionary: [String]) {\\n        let count = keys.count\\n\\n        for i in 0..<count {\\n            dict[keys[i]] = values[i]\\n        }\\n        \\n        for i in dictionary {\\n          map[encrypt(i), default: []].append(i)   \\n        }\\n    }\\n    \\n    func encrypt(_ word1: String) -> String {\\n        var res = \"\"\\n    \\n        for i in word1 {\\n            if let val = dict[i] {\\n                res += val\\n            } else { return \"\" }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func decrypt(_ word2: String) -> Int {\\n        return map[word2, default: []].count     \\n    }\\n}",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\n\\nclass Encrypter {\\n\\n    var dict = [Character: String]()\\n    var map = [String: [String]]()\\n\\n    init(_ keys: [Character], _ values: [String], _ dictionary: [String]) {\\n        let count = keys.count\\n\\n        for i in 0..<count {\\n            dict[keys[i]] = values[i]\\n        }\\n        \\n        for i in dictionary {\\n          map[encrypt(i), default: []].append(i)   \\n        }\\n    }\\n    \\n    func encrypt(_ word1: String) -> String {\\n        var res = \"\"\\n    \\n        for i in word1 {\\n            if let val = dict[i] {\\n                res += val\\n            } else { return \"\" }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func decrypt(_ word2: String) -> Int {\\n        return map[word2, default: []].count     \\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1920424,
                "title": "cpp-simple-and-clean-code",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> hsh;\\n    unordered_map<string, int> box;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            hsh[keys[i]] = values[i];\\n        }\\n        for(string&s: dictionary){\\n            box[encrypt(s)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char c: word1){\\n            if(hsh.find(c) != hsh.end()) ans += hsh[c];\\n            else ans.push_back(\\'.\\');\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return box[word2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> hsh;\\n    unordered_map<string, int> box;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            hsh[keys[i]] = values[i];\\n        }\\n        for(string&s: dictionary){\\n            box[encrypt(s)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char c: word1){\\n            if(hsh.find(c) != hsh.end()) ans += hsh[c];\\n            else ans.push_back(\\'.\\');\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return box[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920343,
                "title": "golang-hash-solution",
                "content": "```go\\n// AC\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tencryptMap    map[string]string\\n\\tresultCounter map[string]int\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tencryptMap := make(map[string]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t}\\n\\tresultCounter := make(map[string]int)\\n\\tfor _, v := range dictionary {\\n\\t\\tencrypted := encryptHelper(v, encryptMap)\\n\\t\\tif len(encrypted) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tresultCounter[encrypted]++\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tencryptMap:    encryptMap,\\n\\t\\tresultCounter: resultCounter,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\treturn encryptHelper(word1, e.encryptMap)\\n}\\n\\nfunc encryptHelper(word string, encryptMap map[string]string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word {\\n\\t\\tif len(encryptMap[string(v)]) == 0 {\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tsb.WriteString(encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\treturn e.resultCounter[word2]\\n}\\n```\\n\\n```go\\n// TLE :(\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tdictionary map[int]map[string]bool\\n\\tencryptMap map[string]string\\n\\tdecryptMap map[string][]string\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tdictionaryHelper := make(map[int]map[string]bool)\\n\\tfor _, v := range dictionary {\\n\\t\\tif dictionaryHelper[len(v)] == nil {\\n\\t\\t\\tdictionaryHelper[len(v)] = make(map[string]bool)\\n\\t\\t}\\n\\t\\tfor i := 1; i <= len(v); i++ {\\n\\t\\t\\tdictionaryHelper[len(v)][v[:i]] = true\\n\\t\\t}\\n\\t}\\n\\tencryptMap := make(map[string]string)\\n\\tdecryptMap := make(map[string][]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t\\tdecryptMap[values[i]] = append(decryptMap[values[i]], string(v))\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tdictionary: dictionaryHelper,\\n\\t\\tencryptMap: encryptMap,\\n\\t\\tdecryptMap: decryptMap,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word1 {\\n\\t\\tsb.WriteString(e.encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\tdictionary := e.dictionary[len(word2)/2]\\n\\tcurrent := make([]string, 0, len(e.decryptMap[word2[:2]]))\\n\\tfor _, v := range e.decryptMap[word2[:2]] {\\n\\t\\tif dictionary[v] == true {\\n\\t\\t\\tcurrent = append(current, v)\\n\\t\\t}\\n\\t}\\n\\tfor i := 2; i < len(word2) && len(current) > 0; i += 2 {\\n\\t\\talphas := e.decryptMap[word2[i:i+2]]\\n\\t\\tnext := make([]string, 0, len(current))\\n\\t\\tfor _, alpha := range alphas {\\n\\t\\t\\tfor _, pre := range current {\\n\\t\\t\\t\\tnewWord := pre + alpha\\n\\t\\t\\t\\tif dictionary[newWord] == true {\\n\\t\\t\\t\\t\\tnext = append(next, newWord)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurrent = next\\n\\t}\\n\\treturn len(current)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n// AC\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tencryptMap    map[string]string\\n\\tresultCounter map[string]int\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tencryptMap := make(map[string]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t}\\n\\tresultCounter := make(map[string]int)\\n\\tfor _, v := range dictionary {\\n\\t\\tencrypted := encryptHelper(v, encryptMap)\\n\\t\\tif len(encrypted) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tresultCounter[encrypted]++\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tencryptMap:    encryptMap,\\n\\t\\tresultCounter: resultCounter,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\treturn encryptHelper(word1, e.encryptMap)\\n}\\n\\nfunc encryptHelper(word string, encryptMap map[string]string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word {\\n\\t\\tif len(encryptMap[string(v)]) == 0 {\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tsb.WriteString(encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\treturn e.resultCounter[word2]\\n}\\n```\n```go\\n// TLE :(\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tdictionary map[int]map[string]bool\\n\\tencryptMap map[string]string\\n\\tdecryptMap map[string][]string\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tdictionaryHelper := make(map[int]map[string]bool)\\n\\tfor _, v := range dictionary {\\n\\t\\tif dictionaryHelper[len(v)] == nil {\\n\\t\\t\\tdictionaryHelper[len(v)] = make(map[string]bool)\\n\\t\\t}\\n\\t\\tfor i := 1; i <= len(v); i++ {\\n\\t\\t\\tdictionaryHelper[len(v)][v[:i]] = true\\n\\t\\t}\\n\\t}\\n\\tencryptMap := make(map[string]string)\\n\\tdecryptMap := make(map[string][]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t\\tdecryptMap[values[i]] = append(decryptMap[values[i]], string(v))\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tdictionary: dictionaryHelper,\\n\\t\\tencryptMap: encryptMap,\\n\\t\\tdecryptMap: decryptMap,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word1 {\\n\\t\\tsb.WriteString(e.encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\tdictionary := e.dictionary[len(word2)/2]\\n\\tcurrent := make([]string, 0, len(e.decryptMap[word2[:2]]))\\n\\tfor _, v := range e.decryptMap[word2[:2]] {\\n\\t\\tif dictionary[v] == true {\\n\\t\\t\\tcurrent = append(current, v)\\n\\t\\t}\\n\\t}\\n\\tfor i := 2; i < len(word2) && len(current) > 0; i += 2 {\\n\\t\\talphas := e.decryptMap[word2[i:i+2]]\\n\\t\\tnext := make([]string, 0, len(current))\\n\\t\\tfor _, alpha := range alphas {\\n\\t\\t\\tfor _, pre := range current {\\n\\t\\t\\t\\tnewWord := pre + alpha\\n\\t\\t\\t\\tif dictionary[newWord] == true {\\n\\t\\t\\t\\t\\tnext = append(next, newWord)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurrent = next\\n\\t}\\n\\treturn len(current)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1915872,
                "title": "using-zip-and-dict-in-python",
                "content": "class Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            print(l)\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "solutionTags": [],
                "code": "class Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            print(l)\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "codeTag": "Java"
            },
            {
                "id": 1915670,
                "title": "rust-hashmap-hashset-search-from-dic-word-o-n",
                "content": "```\\nuse std::collections::{HashMap, HashSet};\\nstruct Encrypter {\\n    ci: HashMap<char, usize>,\\n    vi: HashMap<String, HashSet<usize>>,\\n    values: Vec<String>,\\n    dic: Vec<String>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Encrypter {\\n\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut ci = HashMap::new();\\n        let mut vi = HashMap::new();\\n        for (i, &c) in keys.iter().enumerate() {\\n            ci.insert(c, i);\\n        }\\n        for (i, v) in values.iter().enumerate() {\\n            let list = vi.entry(v.to_string()).or_insert(HashSet::new());\\n            list.insert(i);\\n        }\\n        \\n        // println!(\"ci {:?}\\\\n vi {:#?}\\\\n\", ci, vi);\\n        \\n        Encrypter {\\n            ci,\\n            vi,\\n            values,\\n            dic: dictionary,\\n        }\\n        \\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ans = \"\".to_owned();\\n        for c in word1.chars() {\\n            let i = self.ci[&c];\\n            let v = &self.values[i][..];\\n            ans.push_str(v);\\n        }\\n        ans\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        let mut cnt = 0;\\n        let mut conn:Vec<&HashSet<usize>> = vec![];\\n        let n = word2.len()/2;\\n        for i in 0..n {\\n            let sub = &word2[i*2..i*2+2];\\n            // println!(\"sub {}\", sub);\\n            if !self.vi.contains_key(sub) {\\n                return 0;\\n            }\\n            let ids = &self.vi[sub];\\n            conn.push(ids);\\n        }\\n        // println!(\"conn {:?}\", conn);\\n        \\'dic_loop: for word in self.dic.iter() {\\n            if word.len() != n {\\n                continue\\n            }\\n            for (i, c) in word.chars().enumerate() {\\n                if !self.ci.contains_key(&c) {\\n                    continue \\'dic_loop;\\n                }\\n                let ids = &conn[i];\\n                let id = self.ci[&c];\\n                if !ids.contains(&id) {\\n                    continue \\'dic_loop;\\n                }\\n            }\\n            cnt += 1;\\n        }\\n        \\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::{HashMap, HashSet};\\nstruct Encrypter {\\n    ci: HashMap<char, usize>,\\n    vi: HashMap<String, HashSet<usize>>,\\n    values: Vec<String>,\\n    dic: Vec<String>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Encrypter {\\n\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut ci = HashMap::new();\\n        let mut vi = HashMap::new();\\n        for (i, &c) in keys.iter().enumerate() {\\n            ci.insert(c, i);\\n        }\\n        for (i, v) in values.iter().enumerate() {\\n            let list = vi.entry(v.to_string()).or_insert(HashSet::new());\\n            list.insert(i);\\n        }\\n        \\n        // println!(\"ci {:?}\\\\n vi {:#?}\\\\n\", ci, vi);\\n        \\n        Encrypter {\\n            ci,\\n            vi,\\n            values,\\n            dic: dictionary,\\n        }\\n        \\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ans = \"\".to_owned();\\n        for c in word1.chars() {\\n            let i = self.ci[&c];\\n            let v = &self.values[i][..];\\n            ans.push_str(v);\\n        }\\n        ans\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        let mut cnt = 0;\\n        let mut conn:Vec<&HashSet<usize>> = vec![];\\n        let n = word2.len()/2;\\n        for i in 0..n {\\n            let sub = &word2[i*2..i*2+2];\\n            // println!(\"sub {}\", sub);\\n            if !self.vi.contains_key(sub) {\\n                return 0;\\n            }\\n            let ids = &self.vi[sub];\\n            conn.push(ids);\\n        }\\n        // println!(\"conn {:?}\", conn);\\n        \\'dic_loop: for word in self.dic.iter() {\\n            if word.len() != n {\\n                continue\\n            }\\n            for (i, c) in word.chars().enumerate() {\\n                if !self.ci.contains_key(&c) {\\n                    continue \\'dic_loop;\\n                }\\n                let ids = &conn[i];\\n                let id = self.ci[&c];\\n                if !ids.contains(&id) {\\n                    continue \\'dic_loop;\\n                }\\n            }\\n            cnt += 1;\\n        }\\n        \\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1914609,
                "title": "c-solution",
                "content": "```\\nclass Encrypter {\\npublic:\\n    map<char,string>em;\\n    map<string,set<char>>dm;\\n    set<string>words;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic)     {\\n       for(int i=0;i<keys.size();i++)\\n       {\\n           em[keys[i]]=values[i];\\n           dm[values[i]].insert(keys[i]);\\n       }\\n        for(auto it:dic) words.insert(it);\\n    }\\n    \\n    string encrypt(string w1) {\\n       string s;\\n        for(auto it:w1) s+=em[it];\\n        return s;\\n    }\\n    \\n    int decrypt(string w2) {\\n        int tc=0;\\n        for(auto it:words)\\n        {\\n            if(encrypt(it)==w2) tc++;\\n        }\\n        return tc;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string>em;\\n    map<string,set<char>>dm;\\n    set<string>words;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic)     {\\n       for(int i=0;i<keys.size();i++)\\n       {\\n           em[keys[i]]=values[i];\\n           dm[values[i]].insert(keys[i]);\\n       }\\n        for(auto it:dic) words.insert(it);\\n    }\\n    \\n    string encrypt(string w1) {\\n       string s;\\n        for(auto it:w1) s+=em[it];\\n        return s;\\n    }\\n    \\n    int decrypt(string w2) {\\n        int tc=0;\\n        for(auto it:words)\\n        {\\n            if(encrypt(it)==w2) tc++;\\n        }\\n        return tc;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913855,
                "title": "using-hashmap-java",
                "content": "\\n     class Encrypter {\\n        Map<Character,String> m=new HashMap<>();\\n    String dictionary1[];\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++){\\n            m.put(keys[i],values[i]);\\n        }\\n        dictionary1=new String[dictionary.length];\\n        int i=0;\\n        for(String x:dictionary){\\n            dictionary1[i++]=x;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String x=\"\";\\n        for(char c:word1.toCharArray()){\\n            if(m.containsKey(c)){\\n                x+=m.get(c);\\n            }\\n        }\\n        return x;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int c1=0;\\n        for(String x:dictionary1){\\n           String x1=\"\";\\n            for(char c:x.toCharArray()){\\n                if(m.containsKey(c)){\\n                    x1+=m.get(c);\\n                }\\n            }\\n            if(word2.equals(x1))c1++;\\n        }\\n        return c1;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "\\n     class Encrypter {\\n        Map<Character,String> m=new HashMap<>();\\n    String dictionary1[];\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++){\\n            m.put(keys[i],values[i]);\\n        }\\n        dictionary1=new String[dictionary.length];\\n        int i=0;\\n        for(String x:dictionary){\\n            dictionary1[i++]=x;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String x=\"\";\\n        for(char c:word1.toCharArray()){\\n            if(m.containsKey(c)){\\n                x+=m.get(c);\\n            }\\n        }\\n        return x;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int c1=0;\\n        for(String x:dictionary1){\\n           String x1=\"\";\\n            for(char c:x.toCharArray()){\\n                if(m.containsKey(c)){\\n                    x1+=m.get(c);\\n                }\\n            }\\n            if(word2.equals(x1))c1++;\\n        }\\n        return c1;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1913315,
                "title": "c-solution-using-trie",
                "content": "\\tclass Encrypter {\\n\\tpublic:\\n\\t\\tclass node{\\n\\t\\t\\tpublic:\\n\\t\\t\\tnode* next[26];\\n\\t\\t\\tbool isend;\\n\\t\\t\\tnode(){\\n\\t\\t\\t\\tfor(int i=0; i<26; i++){\\n\\t\\t\\t\\t\\tnext[i] = nullptr;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tisend = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tclass Trie {\\n\\t\\tpublic:\\n\\n\\t\\t\\tnode* root = new node;\\n\\t\\t\\tvoid insert(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) temp->next[c-\\'a\\'] = new node;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp->isend = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool search(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) return false;;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn temp->isend;\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\t\\tTrie t;\\n\\t\\tunordered_map<char,string> mp;\\n\\t\\tunordered_map<string, vector<char>> rmp;\\n\\t\\tunordered_map<string , bool> vis;\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\tfor(int i=0; i<keys.size(); i++){\\n\\t\\t\\t\\tmp[keys[i]] = values[i];\\n\\t\\t\\t\\trmp[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto &w : dictionary){\\n\\t\\t\\t\\tvis[w] = true;\\n\\t\\t\\t\\tt.insert(w);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\tstring str = \"\";\\n\\t\\t\\tfor(auto &c : word1){\\n\\t\\t\\t\\tstr += mp[c];\\n\\t\\t\\t}\\n\\t\\t\\treturn str;\\n\\t\\t}\\n\\t\\tint solve(int i, vector<vector<char>> &vt, node* temp){\\n\\t\\t\\tif(i == vt.size()){\\n\\t\\t\\t\\tif(temp->isend) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int j=0; j<vt[i].size(); j++){\\n\\t\\t\\t\\tif(temp->next[vt[i][j] - \\'a\\'] != NULL){\\n\\t\\t\\t\\t\\tans += solve(i+1, vt, temp->next[vt[i][j] - \\'a\\']);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\tint n = word2.size();\\n\\t\\t\\tvector<vector<char>> vt;\\n\\t\\t\\tvector<char> prev;\\n\\t\\t\\tif(n &1) return 0;\\n\\t\\t\\tfor(int i=0; i<n; i+=2){\\n\\t\\t\\t\\tstring str = \"\";\\n\\t\\t\\t\\tstr += word2[i];\\n\\t\\t\\t\\tstr += word2[i+1];\\n\\t\\t\\t\\tif(rmp.count(str) == 0) return 0;\\n\\t\\t\\t\\tvt.push_back(rmp[str]);\\n\\t\\t\\t}\\n\\t\\t\\tnode* temp = t.root;\\n\\t\\t\\tint ans = solve(0, vt, temp);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "\\tclass Encrypter {\\n\\tpublic:\\n\\t\\tclass node{\\n\\t\\t\\tpublic:\\n\\t\\t\\tnode* next[26];\\n\\t\\t\\tbool isend;\\n\\t\\t\\tnode(){\\n\\t\\t\\t\\tfor(int i=0; i<26; i++){\\n\\t\\t\\t\\t\\tnext[i] = nullptr;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tisend = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tclass Trie {\\n\\t\\tpublic:\\n\\n\\t\\t\\tnode* root = new node;\\n\\t\\t\\tvoid insert(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) temp->next[c-\\'a\\'] = new node;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp->isend = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool search(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) return false;;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn temp->isend;\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\t\\tTrie t;\\n\\t\\tunordered_map<char,string> mp;\\n\\t\\tunordered_map<string, vector<char>> rmp;\\n\\t\\tunordered_map<string , bool> vis;\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\tfor(int i=0; i<keys.size(); i++){\\n\\t\\t\\t\\tmp[keys[i]] = values[i];\\n\\t\\t\\t\\trmp[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto &w : dictionary){\\n\\t\\t\\t\\tvis[w] = true;\\n\\t\\t\\t\\tt.insert(w);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\tstring str = \"\";\\n\\t\\t\\tfor(auto &c : word1){\\n\\t\\t\\t\\tstr += mp[c];\\n\\t\\t\\t}\\n\\t\\t\\treturn str;\\n\\t\\t}\\n\\t\\tint solve(int i, vector<vector<char>> &vt, node* temp){\\n\\t\\t\\tif(i == vt.size()){\\n\\t\\t\\t\\tif(temp->isend) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int j=0; j<vt[i].size(); j++){\\n\\t\\t\\t\\tif(temp->next[vt[i][j] - \\'a\\'] != NULL){\\n\\t\\t\\t\\t\\tans += solve(i+1, vt, temp->next[vt[i][j] - \\'a\\']);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\tint n = word2.size();\\n\\t\\t\\tvector<vector<char>> vt;\\n\\t\\t\\tvector<char> prev;\\n\\t\\t\\tif(n &1) return 0;\\n\\t\\t\\tfor(int i=0; i<n; i+=2){\\n\\t\\t\\t\\tstring str = \"\";\\n\\t\\t\\t\\tstr += word2[i];\\n\\t\\t\\t\\tstr += word2[i+1];\\n\\t\\t\\t\\tif(rmp.count(str) == 0) return 0;\\n\\t\\t\\t\\tvt.push_back(rmp[str]);\\n\\t\\t\\t}\\n\\t\\t\\tnode* temp = t.root;\\n\\t\\t\\tint ans = solve(0, vt, temp);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "codeTag": "Java"
            },
            {
                "id": 1913137,
                "title": "c-hashset-and-trie",
                "content": "Basic ideas:\\n1.TLE issue: using dict1 as cache of Encrypt to avoid TLE.\\n2.Build a trie tree by all valid strings from dictionary. Using valid to mark an acceptable decrypt string.\\n\\n```\\n    public class Encrypter\\n    {\\n        private readonly Dictionary<char, string> encryptDict;\\n        private readonly Dictionary<string, List<char>> decryptDict;\\n        private readonly HashSet<string> set;\\n        private readonly Dictionary<string, string> dict1;\\n        private readonly TrieOfEncrypt root;\\n        public Encrypter(char[] keys, string[] values, string[] dictionary)\\n        {\\n            encryptDict=new Dictionary<char, string>();\\n            decryptDict=new Dictionary<string, List<char>>();\\n            for(int i=0; i<keys.Length; i++)\\n            {\\n                encryptDict.Add(keys[i], values[i]);\\n                if(!decryptDict.ContainsKey(values[i])) decryptDict.Add(values[i],new List<char>());\\n                decryptDict[values[i]].Add(keys[i]);\\n            }\\n            set = new HashSet<string>(dictionary);\\n            dict1 = new Dictionary<string, string>();\\n            root = new TrieOfEncrypt();\\n            BuildTrieTree();\\n        }\\n\\n        private void BuildTrieTree()\\n        {\\n            foreach(var key in set)\\n            {\\n                var curr = root;\\n                foreach(var c in key)\\n                {\\n                    if (!curr.childs.ContainsKey(c)) curr.childs.Add(c, new TrieOfEncrypt());\\n                    curr = curr.childs[c];\\n                }\\n                //only trie node with valid == true count 1 in Decrypt()\\n                curr.valid = true;\\n            }\\n        }\\n\\n        public string Encrypt(string word1)\\n        {\\n            //cache encrypt keys to avoid TLE\\n            if(dict1.ContainsKey(word1))return dict1[word1];\\n            StringBuilder sb= new StringBuilder();\\n            //string res = string.Empty;\\n            foreach (var c in word1)\\n                sb.Append(encryptDict[c]);\\n            var res = sb.ToString();\\n            dict1.Add(word1, res);\\n            return res;\\n        }\\n\\t\\t\\n        public int Decrypt(string word2)\\n        {\\n            var list = new List<TrieOfEncrypt>() { root };\\n            for(int i = 0; i < word2.Length; i += 2)\\n            {\\n                var str=word2.Substring(i, 2);\\n                if (!decryptDict.ContainsKey(str)) return 0;//cannot decrypted\\n                var next = new List<TrieOfEncrypt>();\\n                foreach (var curr in list)\\n                {\\n                    foreach (var c in decryptDict[str])\\n                    {\\n                        if (curr.childs.ContainsKey(c))\\n                            next.Add(curr.childs[c]);//only add available nodes to next loop\\n                    }\\n                }\\n                list = next;\\n                if (list.Count == 0) return 0;//can not decrypted\\n            }\\n            return list.Where(x=>x.valid).Count();\\n        }\\n    }\\n\\n    public class TrieOfEncrypt\\n    {\\n        //indicate if current trie node is valid\\n        public bool valid = false;\\n        public readonly Dictionary<char, TrieOfEncrypt> childs;\\n        public TrieOfEncrypt()\\n        {\\n            childs = new Dictionary<char, TrieOfEncrypt>();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Encrypter\\n    {\\n        private readonly Dictionary<char, string> encryptDict;\\n        private readonly Dictionary<string, List<char>> decryptDict;\\n        private readonly HashSet<string> set;\\n        private readonly Dictionary<string, string> dict1;\\n        private readonly TrieOfEncrypt root;\\n        public Encrypter(char[] keys, string[] values, string[] dictionary)\\n        {\\n            encryptDict=new Dictionary<char, string>();\\n            decryptDict=new Dictionary<string, List<char>>();\\n            for(int i=0; i<keys.Length; i++)\\n            {\\n                encryptDict.Add(keys[i], values[i]);\\n                if(!decryptDict.ContainsKey(values[i])) decryptDict.Add(values[i],new List<char>());\\n                decryptDict[values[i]].Add(keys[i]);\\n            }\\n            set = new HashSet<string>(dictionary);\\n            dict1 = new Dictionary<string, string>();\\n            root = new TrieOfEncrypt();\\n            BuildTrieTree();\\n        }\\n\\n        private void BuildTrieTree()\\n        {\\n            foreach(var key in set)\\n            {\\n                var curr = root;\\n                foreach(var c in key)\\n                {\\n                    if (!curr.childs.ContainsKey(c)) curr.childs.Add(c, new TrieOfEncrypt());\\n                    curr = curr.childs[c];\\n                }\\n                //only trie node with valid == true count 1 in Decrypt()\\n                curr.valid = true;\\n            }\\n        }\\n\\n        public string Encrypt(string word1)\\n        {\\n            //cache encrypt keys to avoid TLE\\n            if(dict1.ContainsKey(word1))return dict1[word1];\\n            StringBuilder sb= new StringBuilder();\\n            //string res = string.Empty;\\n            foreach (var c in word1)\\n                sb.Append(encryptDict[c]);\\n            var res = sb.ToString();\\n            dict1.Add(word1, res);\\n            return res;\\n        }\\n\\t\\t\\n        public int Decrypt(string word2)\\n        {\\n            var list = new List<TrieOfEncrypt>() { root };\\n            for(int i = 0; i < word2.Length; i += 2)\\n            {\\n                var str=word2.Substring(i, 2);\\n                if (!decryptDict.ContainsKey(str)) return 0;//cannot decrypted\\n                var next = new List<TrieOfEncrypt>();\\n                foreach (var curr in list)\\n                {\\n                    foreach (var c in decryptDict[str])\\n                    {\\n                        if (curr.childs.ContainsKey(c))\\n                            next.Add(curr.childs[c]);//only add available nodes to next loop\\n                    }\\n                }\\n                list = next;\\n                if (list.Count == 0) return 0;//can not decrypted\\n            }\\n            return list.Where(x=>x.valid).Count();\\n        }\\n    }\\n\\n    public class TrieOfEncrypt\\n    {\\n        //indicate if current trie node is valid\\n        public bool valid = false;\\n        public readonly Dictionary<char, TrieOfEncrypt> childs;\\n        public TrieOfEncrypt()\\n        {\\n            childs = new Dictionary<char, TrieOfEncrypt>();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913134,
                "title": "pre-count-dictionary-solution",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.m={}\\n        for i in range(len(keys)):\\n            self.m[keys[i]]=values[i]\\n        self.count={}\\n        for word in dictionary:\\n            l=[]\\n            for c in word:\\n                l.append(self.m[c])\\n            possible_string=\"\".join(l)\\n            self.count[possible_string]=self.count.get(possible_string,0)+1\\n\\n                \\n    def encrypt(self, word1: str) -> str:\\n        l=[]\\n        for c in word1:\\n            l.append(self.m[c])\\n        possible_string=\"\".join(l)\\n        return possible_string\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.count.get(word2,0)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.m={}\\n        for i in range(len(keys)):\\n            self.m[keys[i]]=values[i]\\n        self.count={}\\n        for word in dictionary:\\n            l=[]\\n            for c in word:\\n                l.append(self.m[c])\\n            possible_string=\"\".join(l)\\n            self.count[possible_string]=self.count.get(possible_string,0)+1\\n\\n                \\n    def encrypt(self, word1: str) -> str:\\n        l=[]\\n        for c in word1:\\n            l.append(self.m[c])\\n        possible_string=\"\".join(l)\\n        return possible_string\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.count.get(word2,0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912932,
                "title": "scala-simple-problem-so-0-need-for-more-than-5-lines-including-all",
                "content": "`encrypt` is easy. Now you might want to use complex algorithm for `decrypt`, but it turns out *(gotcha)*, the dictionary input is always quite small.\\nSo you could pre-encrypt them and make the histogram of encrypted values. When you hit `decrypt`, you simply return the pre-computed counts.\\n\\n```scala\\nclass Encrypter (_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n  val ktov = (_keys.iterator zip _values.iterator).toMap\\n  val encCounts = _dictionary.groupMapReduce (encrypt (_)) (_ => 1) (_ + _)\\n  def encrypt (word1: String): String = word1.flatMap (ktov (_)).mkString\\n  def decrypt (word2: String): Int = encCounts.getOrElse (word2, 0) }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nclass Encrypter (_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n  val ktov = (_keys.iterator zip _values.iterator).toMap\\n  val encCounts = _dictionary.groupMapReduce (encrypt (_)) (_ => 1) (_ + _)\\n  def encrypt (word1: String): String = word1.flatMap (ktov (_)).mkString\\n  def decrypt (word2: String): Int = encCounts.getOrElse (word2, 0) }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912816,
                "title": "easy-understanding-c-code-trie",
                "content": "https://github.com/kumarmanish03/DSA-Solved-Questions/blob/main/Tree/Encrypt%20and%20Decrypt%20Strings.cpp\\n\\n```\\n// Manish Kumar, IIIT Allahabad\\n// Trie\\n\\nhttps://leetcode.com/problems/encrypt-and-decrypt-strings/\\n\\nclass Encrypter {\\npublic:\\n    struct Trie{\\n        Trie *child[26];\\n        Trie(){\\n            for(int i = 0; i < 26; i++)\\n                child[i] = NULL;\\n        }\\n    };\\n    \\n    Trie* d;\\n    \\n    unordered_map<string, vector<char>> v;\\n    unordered_map<string, int> dict;\\n    vector<string> data;\\n    unordered_map<string, int> decrypted;\\n    \\n    int cnt;\\n    \\n    void insert(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                curr->child[c-\\'a\\'] = new Trie();\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n    }\\n    \\n    bool search(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                return false;\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n        return true;\\n    }\\n    \\n    Encrypter(vector<char>& key, vector<string>& val, vector<string>& dictionary) {\\n        d = new Trie();\\n        v.clear();\\n        cnt = 0;\\n        dict.clear();\\n        data.resize(26, \"\");\\n        decrypted.clear();\\n        \\n        for(string s:dictionary){\\n            insert(s, d);\\n            dict[s]++;\\n        }\\n        \\n        for(int i = 0; i < key.size();i++){\\n            data[key[i]-\\'a\\'] = val[i];\\n                // cout<<val[24];\\n        } \\n        \\n        for(int i = 0; i < val.size(); i++){\\n            v[val[i]].push_back(key[i]);\\n        }\\n        \\n               \\n        \\n    }\\n    \\n    void recur(string s, string t, int i){\\n        if(i >= s.size()){\\n            if(dict[t])\\n                cnt++;\\n            return;\\n        }\\n        \\n        if(search(t, d) == false)\\n            return;\\n        \\n        string q = s.substr(i, 2);\\n        for(char x:v[q])\\n            recur(s, t+x, i+2);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            res += data[word1[i]-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(decrypted.find(word2) != decrypted.end())\\n            return decrypted[word2];\\n        cnt = 0;\\n        string t = \"\";\\n        int i = 0;\\n        recur(word2, t, i);\\n        return decrypted[word2] = cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\n// Manish Kumar, IIIT Allahabad\\n// Trie\\n\\nhttps://leetcode.com/problems/encrypt-and-decrypt-strings/\\n\\nclass Encrypter {\\npublic:\\n    struct Trie{\\n        Trie *child[26];\\n        Trie(){\\n            for(int i = 0; i < 26; i++)\\n                child[i] = NULL;\\n        }\\n    };\\n    \\n    Trie* d;\\n    \\n    unordered_map<string, vector<char>> v;\\n    unordered_map<string, int> dict;\\n    vector<string> data;\\n    unordered_map<string, int> decrypted;\\n    \\n    int cnt;\\n    \\n    void insert(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                curr->child[c-\\'a\\'] = new Trie();\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n    }\\n    \\n    bool search(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                return false;\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n        return true;\\n    }\\n    \\n    Encrypter(vector<char>& key, vector<string>& val, vector<string>& dictionary) {\\n        d = new Trie();\\n        v.clear();\\n        cnt = 0;\\n        dict.clear();\\n        data.resize(26, \"\");\\n        decrypted.clear();\\n        \\n        for(string s:dictionary){\\n            insert(s, d);\\n            dict[s]++;\\n        }\\n        \\n        for(int i = 0; i < key.size();i++){\\n            data[key[i]-\\'a\\'] = val[i];\\n                // cout<<val[24];\\n        } \\n        \\n        for(int i = 0; i < val.size(); i++){\\n            v[val[i]].push_back(key[i]);\\n        }\\n        \\n               \\n        \\n    }\\n    \\n    void recur(string s, string t, int i){\\n        if(i >= s.size()){\\n            if(dict[t])\\n                cnt++;\\n            return;\\n        }\\n        \\n        if(search(t, d) == false)\\n            return;\\n        \\n        string q = s.substr(i, 2);\\n        for(char x:v[q])\\n            recur(s, t+x, i+2);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            res += data[word1[i]-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(decrypted.find(word2) != decrypted.end())\\n            return decrypted[word2];\\n        cnt = 0;\\n        string t = \"\";\\n        int i = 0;\\n        recur(word2, t, i);\\n        return decrypted[word2] = cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1912408,
                "title": "rust-translated-from-lee215-s-solution",
                "content": "```rust\\n\\nuse std::{\\n    cmp::{Ordering, Reverse},\\n    collections::{BinaryHeap, HashMap, HashSet},\\n    fmt::Binary,\\n    hash::Hash,\\n};\\n\\nstruct Encrypter {\\n    encode: HashMap<char, String>,\\n    count: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut encode = HashMap::new();\\n        for i in 0..keys.len() {\\n            encode.insert(keys[i], values[i].clone());\\n        }\\n\\n        let mut count = HashMap::new();\\n        let mut encrypter = Encrypter { encode, count };\\n\\n        for w in dictionary {\\n            let encoded = Self::encrypt(&encrypter, w);\\n            *encrypter.count.entry(encoded).or_insert(0) += 1;\\n        }\\n\\n        encryptera\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res = String::new();\\n        for c in word1.chars() {\\n            let value = self.encode.get(&c).unwrap();\\n            res.push_str(value.as_str())\\n        }\\n        res\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 {\\n        match self.count.get(&word2) {\\n            Some(res) => *res,\\n            None => 0,\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\n\\nuse std::{\\n    cmp::{Ordering, Reverse},\\n    collections::{BinaryHeap, HashMap, HashSet},\\n    fmt::Binary,\\n    hash::Hash,\\n};\\n\\nstruct Encrypter {\\n    encode: HashMap<char, String>,\\n    count: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut encode = HashMap::new();\\n        for i in 0..keys.len() {\\n            encode.insert(keys[i], values[i].clone());\\n        }\\n\\n        let mut count = HashMap::new();\\n        let mut encrypter = Encrypter { encode, count };\\n\\n        for w in dictionary {\\n            let encoded = Self::encrypt(&encrypter, w);\\n            *encrypter.count.entry(encoded).or_insert(0) += 1;\\n        }\\n\\n        encryptera\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res = String::new();\\n        for c in word1.chars() {\\n            let value = self.encode.get(&c).unwrap();\\n            res.push_str(value.as_str())\\n        }\\n        res\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 {\\n        match self.count.get(&word2) {\\n            Some(res) => *res,\\n            None => 0,\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1912223,
                "title": "3-min-hindi-video-simple-hash-solution",
                "content": "3 min Hindi Video | Simple hash Solution \\nyoutube .com/watch?v=3Ev4oM6p-s4\\n\\nPLEASE PLEASE upvote it if you like it. Jaroor upvote karna.",
                "solutionTags": [],
                "code": "3 min Hindi Video | Simple hash Solution \\nyoutube .com/watch?v=3Ev4oM6p-s4\\n\\nPLEASE PLEASE upvote it if you like it. Jaroor upvote karna.",
                "codeTag": "Unknown"
            },
            {
                "id": 1911731,
                "title": "python-simple-use-two-dicts",
                "content": "We just need to use 2 dicts:\\n**dict1**: to map character from *key* to its value in *values* (which will be used in *encrypt*)\\n**dict2**: to map each word in dictionary to its encrypted word using **dict1** and store its count of occurances (which will be used in *decrypt*)\\n\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.pair,self.de = defaultdict(str),defaultdict(int)\\n        for i,j in enumerate(keys):\\n            self.pair[j]=values[i]\\n        for i in dictionary:\\n            key = \"\".join(self.pair[j] for j in i)\\n            self.de[key]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.pair[i] for i in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.de[word2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.pair,self.de = defaultdict(str),defaultdict(int)\\n        for i,j in enumerate(keys):\\n            self.pair[j]=values[i]\\n        for i in dictionary:\\n            key = \"\".join(self.pair[j] for j in i)\\n            self.de[key]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.pair[i] for i in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.de[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911486,
                "title": "c-easy-solution",
                "content": "```\\nclass Encrypter {\\npublic:\\n    //data members\\n    vector<char> keys;\\n    vector<string> values;\\n    vector<string> dictionary;\\n    unordered_map<char, int> keyIndex;\\n    unordered_map<string, vector<int>> valuesIndex;\\n    unordered_map<string, int> freq;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->keys = keys;\\n        this->values = values;\\n        this->dictionary = dictionary;\\n        for(int i = 0; i < keys.size(); i++){\\n            keyIndex[keys[i]] = i;\\n        }\\n        for(int i = 0; i < values.size(); i++){\\n            valuesIndex[values[i]].push_back(i);\\n        }\\n        \\n        for(auto i: dictionary){\\n            string ans = encrypt(i);\\n            freq[ans] += 1;\\n        }\\n    }\\n   \\n\\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto i: word1){\\n            int index = keyIndex[i];\\n            string temp = values[index];\\n            ans += temp;\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       return freq[word2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    //data members\\n    vector<char> keys;\\n    vector<string> values;\\n    vector<string> dictionary;\\n    unordered_map<char, int> keyIndex;\\n    unordered_map<string, vector<int>> valuesIndex;\\n    unordered_map<string, int> freq;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->keys = keys;\\n        this->values = values;\\n        this->dictionary = dictionary;\\n        for(int i = 0; i < keys.size(); i++){\\n            keyIndex[keys[i]] = i;\\n        }\\n        for(int i = 0; i < values.size(); i++){\\n            valuesIndex[values[i]].push_back(i);\\n        }\\n        \\n        for(auto i: dictionary){\\n            string ans = encrypt(i);\\n            freq[ans] += 1;\\n        }\\n    }\\n   \\n\\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto i: word1){\\n            int index = keyIndex[i];\\n            string temp = values[index];\\n            ans += temp;\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       return freq[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911396,
                "title": "python-very-simple-solution",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_val_map=dict()\\n        for i in range(len(keys)):\\n            self.key_val_map[keys[i]]=values[i]\\n        \\n        self.dictionary_freq=defaultdict(int)\\n        for i in dictionary:\\n            ans=\"\"\\n            for char in i:\\n                ans+=self.key_val_map[char]\\n            self.dictionary_freq[ans]+=1\\n                \\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        ans=\"\"\\n        for char in word1:\\n            ans+=self.key_val_map[char]\\n        return ans\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        return self.dictionary_freq[word2]\\n        \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_val_map=dict()\\n        for i in range(len(keys)):\\n            self.key_val_map[keys[i]]=values[i]\\n        \\n        self.dictionary_freq=defaultdict(int)\\n        for i in dictionary:\\n            ans=\"\"\\n            for char in i:\\n                ans+=self.key_val_map[char]\\n            self.dictionary_freq[ans]+=1\\n                \\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        ans=\"\"\\n        for char in word1:\\n            ans+=self.key_val_map[char]\\n        return ans\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        return self.dictionary_freq[word2]\\n        \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911391,
                "title": "python-three-lines-of-code",
                "content": "This is the easiest hard problem ever. It\\'s just three lines of python code with one line in each class method.\\n\\n```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.k2v, self.dict = dict(zip(keys, values)), dictionary\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.k2v[c] for c in word1)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return sum(1 for word in self.dict if self.encrypt(word) == word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.k2v, self.dict = dict(zip(keys, values)), dictionary\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.k2v[c] for c in word1)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return sum(1 for word in self.dict if self.encrypt(word) == word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911346,
                "title": "java-solution-using-trie",
                "content": "```\\nclass TrieNode{\\n    public Map<Character, TrieNode> children = new HashMap();\\n    public boolean isWord;\\n}\\n\\nclass Encrypter {\\n    Map<Character, String> keysToValues  = new HashMap();\\n    Map<String, List<Character>> valuesToKeys = new HashMap();\\n    TrieNode root = new TrieNode();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i  = 0;\\n        for(char key : keys){\\n            keysToValues.put(key, values[i++]);\\n        }\\n        for(i = 0; i < values.length; i++){\\n            valuesToKeys.putIfAbsent(values[i], new ArrayList());\\n            valuesToKeys.get(values[i]).add(keys[i]);\\n        }\\n        \\n        for(String word : dictionary){\\n            construct(root, word);\\n        }\\n    }\\n    \\n    private void construct(TrieNode root, String word){\\n        for(int i = 0; i< word.length(); i++){\\n            char c = word.charAt(i);\\n            if(root.children.containsKey(c)){\\n                root = root.children.get(c);\\n            }else{\\n                TrieNode node = new TrieNode();\\n                root.children.put(c, node);\\n                root = node;\\n            }\\n        }\\n        \\n        root.isWord = true;\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i< word1.length(); i++){\\n            char c = word1.charAt(i);\\n            if(keysToValues.get(c) != null){\\n                sb.append(keysToValues.get(c));\\n            }else{\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n       return count(root, word2, 0);\\n    }\\n    \\n    private int count(TrieNode root, String word2, int index){\\n        if(index == word2.length() && root.isWord) return 1;\\n        if(index == word2.length()) return 0;\\n        String str = word2.substring(index, index+2);\\n        int res = 0;\\n        if( valuesToKeys.get(str) != null){\\n            for(Character c  : valuesToKeys.get(str)){\\n                if(root.children.get(c) != null){\\n                    res += count(root.children.get(c), word2, index+2);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode{\\n    public Map<Character, TrieNode> children = new HashMap();\\n    public boolean isWord;\\n}\\n\\nclass Encrypter {\\n    Map<Character, String> keysToValues  = new HashMap();\\n    Map<String, List<Character>> valuesToKeys = new HashMap();\\n    TrieNode root = new TrieNode();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i  = 0;\\n        for(char key : keys){\\n            keysToValues.put(key, values[i++]);\\n        }\\n        for(i = 0; i < values.length; i++){\\n            valuesToKeys.putIfAbsent(values[i], new ArrayList());\\n            valuesToKeys.get(values[i]).add(keys[i]);\\n        }\\n        \\n        for(String word : dictionary){\\n            construct(root, word);\\n        }\\n    }\\n    \\n    private void construct(TrieNode root, String word){\\n        for(int i = 0; i< word.length(); i++){\\n            char c = word.charAt(i);\\n            if(root.children.containsKey(c)){\\n                root = root.children.get(c);\\n            }else{\\n                TrieNode node = new TrieNode();\\n                root.children.put(c, node);\\n                root = node;\\n            }\\n        }\\n        \\n        root.isWord = true;\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i< word1.length(); i++){\\n            char c = word1.charAt(i);\\n            if(keysToValues.get(c) != null){\\n                sb.append(keysToValues.get(c));\\n            }else{\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n       return count(root, word2, 0);\\n    }\\n    \\n    private int count(TrieNode root, String word2, int index){\\n        if(index == word2.length() && root.isWord) return 1;\\n        if(index == word2.length()) return 0;\\n        String str = word2.substring(index, index+2);\\n        int res = 0;\\n        if( valuesToKeys.get(str) != null){\\n            for(Character c  : valuesToKeys.get(str)){\\n                if(root.children.get(c) != null){\\n                    res += count(root.children.get(c), word2, index+2);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1911321,
                "title": "most-optimized-code-using-dict",
                "content": "\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n\\t\\tself.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\tdef decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "solutionTags": [],
                "code": "\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n\\t\\tself.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\tdef decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "codeTag": "Python3"
            },
            {
                "id": 1911295,
                "title": "easy-c-solution-hashmap-tries",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> encryptMap;\\n    map<string,vector<char>> decryptMap;\\n    struct Trie{\\n        Trie* characters[26];\\n        bool isEnd = false;\\n    }*trie = new Trie();\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int index = 0 ; index < keys.size() ; ++index){\\n            encryptMap[keys[index]] = values[index];\\n        }\\n        for(int index = 0 ; index < values.size() ; ++index){\\n            decryptMap[values[index]].push_back(keys[index]);\\n        }\\n        for(auto word : dictionary){\\n            struct Trie* temp = trie;\\n            for(auto ch : word){\\n                if(!temp->characters[ch - \\'a\\']){\\n                    temp->characters[ch - \\'a\\'] = new Trie();\\n                }\\n                temp = temp->characters[ch - \\'a\\'];\\n            }\\n            temp->isEnd = true;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans;\\n        for(auto ch : word1){\\n            ans.append(encryptMap[ch]);\\n        }\\n        return ans;\\n    }\\n    int decryptCount(string &word2 , int index , struct Trie* trie){\\n        if(index == word2.length()){\\n            if(trie->isEnd){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        int count = 0;\\n        for(auto ch : decryptMap[word2.substr(index , 2)]){\\n            if(trie->characters[ch - \\'a\\']){\\n                count += decryptCount(word2 , index + 2 , trie->characters[ch - \\'a\\']);\\n            }\\n        }\\n        return count;\\n    }\\n    int decrypt(string word2) {\\n        return decryptCount(word2 , 0 , trie);\\n    \\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> encryptMap;\\n    map<string,vector<char>> decryptMap;\\n    struct Trie{\\n        Trie* characters[26];\\n        bool isEnd = false;\\n    }*trie = new Trie();\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int index = 0 ; index < keys.size() ; ++index){\\n            encryptMap[keys[index]] = values[index];\\n        }\\n        for(int index = 0 ; index < values.size() ; ++index){\\n            decryptMap[values[index]].push_back(keys[index]);\\n        }\\n        for(auto word : dictionary){\\n            struct Trie* temp = trie;\\n            for(auto ch : word){\\n                if(!temp->characters[ch - \\'a\\']){\\n                    temp->characters[ch - \\'a\\'] = new Trie();\\n                }\\n                temp = temp->characters[ch - \\'a\\'];\\n            }\\n            temp->isEnd = true;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans;\\n        for(auto ch : word1){\\n            ans.append(encryptMap[ch]);\\n        }\\n        return ans;\\n    }\\n    int decryptCount(string &word2 , int index , struct Trie* trie){\\n        if(index == word2.length()){\\n            if(trie->isEnd){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        int count = 0;\\n        for(auto ch : decryptMap[word2.substr(index , 2)]){\\n            if(trie->characters[ch - \\'a\\']){\\n                count += decryptCount(word2 , index + 2 , trie->characters[ch - \\'a\\']);\\n            }\\n        }\\n        return count;\\n    }\\n    int decrypt(string word2) {\\n        return decryptCount(word2 , 0 , trie);\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911250,
                "title": "python3-stupid-easy-solution-with-counter",
                "content": "```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = dict(zip(keys, values))\\n        self.ctr = Counter(self.encrypt(w) for w in dictionary)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        s = list(word1)\\n        for i, c in enumerate(word1):\\n            s[i] = self.kv[c]\\n        return \\'\\'.join(s)\\n            \\n    def decrypt(self, word2: str) -> int:\\n        return self.ctr[word2]\\n ```",
                "solutionTags": [],
                "code": "```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = dict(zip(keys, values))\\n        self.ctr = Counter(self.encrypt(w) for w in dictionary)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        s = list(word1)\\n        for i, c in enumerate(word1):\\n            s[i] = self.kv[c]\\n        return \\'\\'.join(s)\\n            \\n    def decrypt(self, word2: str) -> int:\\n        return self.ctr[word2]\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1911205,
                "title": "java-hashmaps-with-trick",
                "content": "The way the problem is defined - is probably just Medium:\\n* Encryption - just follow the mapping rules.\\n* Decryption - there\\'s only a finite number of decryption results - encrypt them all in preprocessing and then just lookup input to decrypt.\\n```\\nclass Encrypter {\\n    Map<Character,String> enc;\\n    Map<String,Integer> encDict;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int n= keys.length;\\n        this.enc= new HashMap<>();\\n        for(int i=0; i<n; i++) enc.put(keys[i], values[i]);\\n\\n        this.encDict= new HashMap<>();\\n        for(String word:dictionary){\\n            String encWord= encrypt(word);\\n            encDict.put(encWord, 1+encDict.getOrDefault(encWord, 0));\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] ca= word1.toCharArray();\\n        StringBuilder sb= new StringBuilder();\\n        for(char c:ca) sb.append(enc.get(c));\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encDict.getOrDefault(word2, 0);\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "The way the problem is defined - is probably just Medium:\\n* Encryption - just follow the mapping rules.\\n* Decryption - there\\'s only a finite number of decryption results - encrypt them all in preprocessing and then just lookup input to decrypt.\\n```\\nclass Encrypter {\\n    Map<Character,String> enc;\\n    Map<String,Integer> encDict;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int n= keys.length;\\n        this.enc= new HashMap<>();\\n        for(int i=0; i<n; i++) enc.put(keys[i], values[i]);\\n\\n        this.encDict= new HashMap<>();\\n        for(String word:dictionary){\\n            String encWord= encrypt(word);\\n            encDict.put(encWord, 1+encDict.getOrDefault(encWord, 0));\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] ca= word1.toCharArray();\\n        StringBuilder sb= new StringBuilder();\\n        for(char c:ca) sb.append(enc.get(c));\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encDict.getOrDefault(word2, 0);\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1910749,
                "title": "python-3-hashmap-and-counter",
                "content": "Maintain a hashmap and a counter. Hashmap `c2v` converts keys to values, and garanteed by the question all letters in word1 appear in keys. Counter `en_ct` keeps count of encrypted from all words in the dictionary, if word2 is in `en_ct`, return its count, otherwise 0 - word2 not in the dictionary.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.en_ct = Counter()\\n        self.c2v = {keys[i]: values[i] for i in range(len(keys))}\\n        for word in dictionary:\\n            s = \\'\\'\\n            for c in word:\\n                s += self.c2v[c]\\n            self.en_ct[s] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        s = \\'\\'\\n        for c in word1:\\n            s += self.c2v[c]\\n        return s\\n\\n    def decrypt(self, word2: str) -> int:\\n        if word2 not in self.en_ct:\\n            return 0\\n        return self.en_ct[word2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.en_ct = Counter()\\n        self.c2v = {keys[i]: values[i] for i in range(len(keys))}\\n        for word in dictionary:\\n            s = \\'\\'\\n            for c in word:\\n                s += self.c2v[c]\\n            self.en_ct[s] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        s = \\'\\'\\n        for c in word1:\\n            s += self.c2v[c]\\n        return s\\n\\n    def decrypt(self, word2: str) -> int:\\n        if word2 not in self.en_ct:\\n            return 0\\n        return self.en_ct[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910648,
                "title": "java-trie-hashmap-o-n",
                "content": "The idea is to encrypt all dictionary words and create a trie tree of all of them.\\nRoot nodes of the trie tree should hold the dictionary frequency of each encrypted word \\n\\n```\\nclass Encrypter {\\n\\n    class TrieNode {\\n        public int count;\\n        public TrieNode[] next;\\n\\n        public TrieNode() {\\n            count = 0;\\n            next = new TrieNode[26];\\n        }\\n        public void add(String str) {\\n            TrieNode node = this;\\n            for (int i = 0; i < str.length(); i++) {\\n                int index = str.charAt(i) - \\'a\\';\\n                if (node.next[index] == null) {\\n                    node.next[index] = new TrieNode();\\n                }\\n                node = node.next[index];\\n            }\\n            node.count++;\\n        }\\n    }\\n\\n\\n    HashMap < Character, Integer > keysMap;\\n    String[] values;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        keysMap = new HashMap();\\n        for (int i = 0; i < keys.length; i++) {\\n            keysMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n        root = new TrieNode();\\n        for (String s: dictionary) {\\n            root.add(encrypt(s));\\n        }\\n\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < word1.length(); i++) {\\n            str.append(values[keysMap.get(word1.charAt(i))]);\\n        }\\n\\n        return str.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        TrieNode node = root;\\n        for (int i = 0; i < word2.length(); i++) {\\n            int index = word2.charAt(i) - \\'a\\';\\n            if (node.next[index] == null) return 0;\\n            else node = node.next[index];\\n        }\\n        return node.count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n\\n    class TrieNode {\\n        public int count;\\n        public TrieNode[] next;\\n\\n        public TrieNode() {\\n            count = 0;\\n            next = new TrieNode[26];\\n        }\\n        public void add(String str) {\\n            TrieNode node = this;\\n            for (int i = 0; i < str.length(); i++) {\\n                int index = str.charAt(i) - \\'a\\';\\n                if (node.next[index] == null) {\\n                    node.next[index] = new TrieNode();\\n                }\\n                node = node.next[index];\\n            }\\n            node.count++;\\n        }\\n    }\\n\\n\\n    HashMap < Character, Integer > keysMap;\\n    String[] values;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        keysMap = new HashMap();\\n        for (int i = 0; i < keys.length; i++) {\\n            keysMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n        root = new TrieNode();\\n        for (String s: dictionary) {\\n            root.add(encrypt(s));\\n        }\\n\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < word1.length(); i++) {\\n            str.append(values[keysMap.get(word1.charAt(i))]);\\n        }\\n\\n        return str.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        TrieNode node = root;\\n        for (int i = 0; i < word2.length(); i++) {\\n            int index = word2.charAt(i) - \\'a\\';\\n            if (node.next[index] == null) return 0;\\n            else node = node.next[index];\\n        }\\n        return node.count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910582,
                "title": "java-hashmap-only-easy-understanding",
                "content": "```\\nclass Encrypter {\\n    HashMap<Character, String> map = new HashMap<>(); // key to value\\n    HashMap<String, Integer> map2 = new HashMap<>(); // encrypt every word in dictionary, map it to number of times its found in dictionary\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0;i < keys.length; i++){\\n            map.put(keys[i], values[i]);\\n        }\\n        for(int i = 0;i < dictionary.length; i++){\\n            map2.put(encrypt(dictionary[i]), map2.getOrDefault(encrypt(dictionary[i]), 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String encrypted = \"\";\\n        for(int i = 0;i < word1.length(); i++){\\n            char curr = word1.charAt(i);\\n            encrypted += map.get(curr);\\n        }\\n        return encrypted;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return map2.getOrDefault(word2, 0);\\n    }\\n    \\n    \\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    HashMap<Character, String> map = new HashMap<>(); // key to value\\n    HashMap<String, Integer> map2 = new HashMap<>(); // encrypt every word in dictionary, map it to number of times its found in dictionary\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0;i < keys.length; i++){\\n            map.put(keys[i], values[i]);\\n        }\\n        for(int i = 0;i < dictionary.length; i++){\\n            map2.put(encrypt(dictionary[i]), map2.getOrDefault(encrypt(dictionary[i]), 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String encrypted = \"\";\\n        for(int i = 0;i < word1.length(); i++){\\n            char curr = word1.charAt(i);\\n            encrypted += map.get(curr);\\n        }\\n        return encrypted;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return map2.getOrDefault(word2, 0);\\n    }\\n    \\n    \\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910551,
                "title": "c-hashmap-trie",
                "content": "```\\nclass Trie{\\nprivate:\\n    unordered_map<string, Trie*> next; \\n    bool isWord = false;\\n    int match = 0;\\npublic:\\n    Trie(){}\\n    void insert(string word,vector<string>& ktov)\\n    {\\n        Trie* node = this;\\n        for(char& c:word)\\n        {\\n            if(node->next[ktov[c-\\'a\\']]==nullptr)\\n                node->next[ktov[c-\\'a\\']] = new Trie();\\n            node = node->next[ktov[c-\\'a\\']];\\n        }\\n        node->isWord = true;\\n        node->match++;\\n    }\\n    int search(string word)\\n    {\\n        Trie* node = this;\\n        for(int i=0;i<word.size();i+=2)\\n        {\\n            string now = word.substr(i,2);\\n            if(node->next[now]==nullptr)\\n                return 0;\\n            node = node->next[now];\\n        }\\n        return node->match;\\n    }\\n};\\nclass Encrypter {\\nprivate:\\n    unordered_set<string> dict;\\n    vector<string> ktov;\\n    unordered_map<string,vector<char>> vtok;\\n    Trie* d;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        ktov.assign(26,\"\");\\n        d = new Trie();\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            ktov[keys[i]-\\'a\\'] = values[i];\\n            vtok[values[i]].push_back(keys[i]);\\n        }\\n        for(auto& t:dictionary)\\n        {\\n            d->insert(t,ktov);\\n        }\\n            \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& w:word1)\\n        {\\n            ans += ktov[w-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return d->search(word2);\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\nprivate:\\n    unordered_map<string, Trie*> next; \\n    bool isWord = false;\\n    int match = 0;\\npublic:\\n    Trie(){}\\n    void insert(string word,vector<string>& ktov)\\n    {\\n        Trie* node = this;\\n        for(char& c:word)\\n        {\\n            if(node->next[ktov[c-\\'a\\']]==nullptr)\\n                node->next[ktov[c-\\'a\\']] = new Trie();\\n            node = node->next[ktov[c-\\'a\\']];\\n        }\\n        node->isWord = true;\\n        node->match++;\\n    }\\n    int search(string word)\\n    {\\n        Trie* node = this;\\n        for(int i=0;i<word.size();i+=2)\\n        {\\n            string now = word.substr(i,2);\\n            if(node->next[now]==nullptr)\\n                return 0;\\n            node = node->next[now];\\n        }\\n        return node->match;\\n    }\\n};\\nclass Encrypter {\\nprivate:\\n    unordered_set<string> dict;\\n    vector<string> ktov;\\n    unordered_map<string,vector<char>> vtok;\\n    Trie* d;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        ktov.assign(26,\"\");\\n        d = new Trie();\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            ktov[keys[i]-\\'a\\'] = values[i];\\n            vtok[values[i]].push_back(keys[i]);\\n        }\\n        for(auto& t:dictionary)\\n        {\\n            d->insert(t,ktov);\\n        }\\n            \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& w:word1)\\n        {\\n            ans += ktov[w-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return d->search(word2);\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910411,
                "title": "trie-but-failed-very-hard-time-limit",
                "content": "\\tclass Node{\\n\\tpublic:\\n\\t\\tbool isEnd;\\n\\t\\tNode* arr[26];\\n\\n\\t\\tNode(){\\n\\t\\t\\tisEnd = false;\\n\\t\\t\\tfor(int i=0;i<26;i++) {\\n\\t\\t\\t\\tarr[i] = NULL;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tclass Encrypter {\\n\\t\\tNode* root;\\n\\t\\tunordered_map<char,string> keys;\\n\\t\\tunordered_map<string,vector<char> > values;\\n\\n\\t\\tvoid insert(string& s){\\n\\t\\t\\tNode* t = root;\\n\\t\\t\\tfor(int i=0;i<s.size();i++) {\\n\\t\\t\\t\\tif(t->arr[s[i] - \\'a\\'] == NULL) {\\n\\t\\t\\t\\t\\tt->arr[s[i] - \\'a\\'] = new Node();\\n\\t\\t\\t\\t}            \\n\\t\\t\\t\\tt = t->arr[s[i]-\\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tt->isEnd = true;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string& word,int i,Node* t){\\n\\t\\t\\tif(i >= word.size()) {\\n\\t\\t\\t\\treturn t->isEnd;\\n\\t\\t\\t}\\n\\t\\t\\tstring s = word.substr(i,2);\\n\\t\\t\\tint ans = 0;        \\n\\t\\t\\tfor(char& ch:values[s]) {\\n\\t\\t\\t\\tif(t->arr[ch - \\'a\\'] == NULL) continue;\\n\\t\\t\\t\\tans += decrypt(word, i+2, t->arr[ch - \\'a\\']);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\t// Encrypter\\n\\t\\t\\tfor(int i=0;i<keys.size();i++) {\\n\\t\\t\\t\\tthis->keys[keys[i]] = values[i];\\n\\t\\t\\t\\tthis->values[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\troot = new Node();\\n\\t\\t\\tfor(string& it:dictionary){\\n\\t\\t\\t\\tinsert(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\t// encrypt\\n\\t\\t\\tstring word = \"\";\\n\\t\\t\\tfor(char& c:word1){\\n\\t\\t\\t\\tword = word + keys[c]; \\n\\t\\t\\t}\\n\\t\\t\\treturn word;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\t// decrypt\\n\\t\\t\\treturn decrypt(word2, 0, root);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "solutionTags": [
                    "Trie"
                ],
                "code": "\\tclass Node{\\n\\tpublic:\\n\\t\\tbool isEnd;\\n\\t\\tNode* arr[26];\\n\\n\\t\\tNode(){\\n\\t\\t\\tisEnd = false;\\n\\t\\t\\tfor(int i=0;i<26;i++) {\\n\\t\\t\\t\\tarr[i] = NULL;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tclass Encrypter {\\n\\t\\tNode* root;\\n\\t\\tunordered_map<char,string> keys;\\n\\t\\tunordered_map<string,vector<char> > values;\\n\\n\\t\\tvoid insert(string& s){\\n\\t\\t\\tNode* t = root;\\n\\t\\t\\tfor(int i=0;i<s.size();i++) {\\n\\t\\t\\t\\tif(t->arr[s[i] - \\'a\\'] == NULL) {\\n\\t\\t\\t\\t\\tt->arr[s[i] - \\'a\\'] = new Node();\\n\\t\\t\\t\\t}            \\n\\t\\t\\t\\tt = t->arr[s[i]-\\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tt->isEnd = true;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string& word,int i,Node* t){\\n\\t\\t\\tif(i >= word.size()) {\\n\\t\\t\\t\\treturn t->isEnd;\\n\\t\\t\\t}\\n\\t\\t\\tstring s = word.substr(i,2);\\n\\t\\t\\tint ans = 0;        \\n\\t\\t\\tfor(char& ch:values[s]) {\\n\\t\\t\\t\\tif(t->arr[ch - \\'a\\'] == NULL) continue;\\n\\t\\t\\t\\tans += decrypt(word, i+2, t->arr[ch - \\'a\\']);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\t// Encrypter\\n\\t\\t\\tfor(int i=0;i<keys.size();i++) {\\n\\t\\t\\t\\tthis->keys[keys[i]] = values[i];\\n\\t\\t\\t\\tthis->values[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\troot = new Node();\\n\\t\\t\\tfor(string& it:dictionary){\\n\\t\\t\\t\\tinsert(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\t// encrypt\\n\\t\\t\\tstring word = \"\";\\n\\t\\t\\tfor(char& c:word1){\\n\\t\\t\\t\\tword = word + keys[c]; \\n\\t\\t\\t}\\n\\t\\t\\treturn word;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\t// decrypt\\n\\t\\t\\treturn decrypt(word2, 0, root);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "codeTag": "Java"
            },
            {
                "id": 1910319,
                "title": "c-solution-with-trick-making-it-easiest-hard-problem",
                "content": "\\n\\n```\\n class Encrypter {\\npublic:\\n    //For mappint character with its index\\n    map<char,int> keys_mp;\\n    \\n    //For storing values array\\n    vector<string> val;\\n    //Dictionary map to store reverse mapping of dictonary words and its encryption count.\\n    map<string, int> dict_mp;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++) keys_mp[keys[i]] = i;\\n        val = values;\\n        //Preparing map for encrypted dictionary word and its count\\n        for(string str: dictionary){\\n            dict_mp[encrypt(str)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1){\\n            ans += val[keys_mp[ch]];    \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if (dict_mp.find(word2) == dict_mp.end()) return 0;\\n        return dict_mp[word2];\\n    }\\n};\\n   \\n```",
                "solutionTags": [],
                "code": "```\\n class Encrypter {\\npublic:\\n    //For mappint character with its index\\n    map<char,int> keys_mp;\\n    \\n    //For storing values array\\n    vector<string> val;\\n    //Dictionary map to store reverse mapping of dictonary words and its encryption count.\\n    map<string, int> dict_mp;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++) keys_mp[keys[i]] = i;\\n        val = values;\\n        //Preparing map for encrypted dictionary word and its count\\n        for(string str: dictionary){\\n            dict_mp[encrypt(str)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1){\\n            ans += val[keys_mp[ch]];    \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if (dict_mp.find(word2) == dict_mp.end()) return 0;\\n        return dict_mp[word2];\\n    }\\n};\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910089,
                "title": "map-c",
                "content": "```class Encrypter {\\npublic:\\n    map<string,int>dict;\\n    map<char,string>key;\\n    map<string,vector<char>>value;\\n    map<string,int>mp;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict.clear();\\n        key.clear();\\n        value.clear();\\n        for(auto &a:dictionary) dict[a]++;\\n        for(int i=0;i<keys.size();i++){\\n            key[keys[i]]=values[i];\\n            value[values[i]].push_back(keys[i]);\\n        }\\n        for(auto &a:dictionary){\\n            string ans=\"\";\\n            bool h=false;\\n            for(int i=0;i<a.size();i++){\\n                if(key.count(a[i])) ans+=key[a[i]];\\n                else h=true;\\n            }\\n            if(h) continue;\\n            mp[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(int i=0;i<word1.size();i++){\\n            if(key.count(word1[i])) ans+=key[word1[i]];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        if(!mp.count(word2)) return 0;\\n        return mp[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```class Encrypter {\\npublic:\\n    map<string,int>dict;\\n    map<char,string>key;\\n    map<string,vector<char>>value;\\n    map<string,int>mp;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict.clear();\\n        key.clear();\\n        value.clear();\\n        for(auto &a:dictionary) dict[a]++;\\n        for(int i=0;i<keys.size();i++){\\n            key[keys[i]]=values[i];\\n            value[values[i]].push_back(keys[i]);\\n        }\\n        for(auto &a:dictionary){\\n            string ans=\"\";\\n            bool h=false;\\n            for(int i=0;i<a.size();i++){\\n                if(key.count(a[i])) ans+=key[a[i]];\\n                else h=true;\\n            }\\n            if(h) continue;\\n            mp[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(int i=0;i<word1.size();i++){\\n            if(key.count(word1[i])) ans+=key[word1[i]];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        if(!mp.count(word2)) return 0;\\n        return mp[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1910027,
                "title": "c-solution",
                "content": "\\tclass Encrypter {\\n    unordered_map<char, string> en;\\n    unordered_map<string, int> de;\\n\\n\\tpublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++)\\n            en[keys[i]] = values[i];\\n\\n        for(string s: dictionary)\\n            de[encrypt(s)]++;\\n    }\\n    \\n    string encrypt(string s) {\\n        string ans = \"\";\\n        \\n        for(char c: s)\\n            ans += en[c];\\n        \\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        return de[s];\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "\\tclass Encrypter {\\n    unordered_map<char, string> en;\\n    unordered_map<string, int> de;\\n\\n\\tpublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++)\\n            en[keys[i]] = values[i];\\n\\n        for(string s: dictionary)\\n            de[encrypt(s)]++;\\n    }\\n    \\n    string encrypt(string s) {\\n        string ans = \"\";\\n        \\n        for(char c: s)\\n            ans += en[c];\\n        \\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        return de[s];\\n    }\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 1909945,
                "title": "c-encryption-hashmap-decryption-dfs-trie",
                "content": "**Prerequisite: TRIE**\\nEncrypting the string is straight forward, just store the string for each character in map and You are good to go. Also decryption of string is easy, the only difficult part is verifying the final string from the dictionary. \\n##### TLE for Set: \\nIf we use **set** to store and verify from dictionary, no doubt it will give the correct ans but using so will also increase our runtime. Because, before verifying we will 1st decrypt the whole string and after that we will verify from **Set**. By doing so we are doing redundent searches because its possible that the string doesn\\'t even exists in **set**. \\nSo, we need to find a way to decrypt the string word by word along with verification. Solution to this is Trie, as trie stores the string word by word and level by level.\\n#### Trie Solution:\\n1. Store each word of `dictionary` in trie\\n1. For decryption, use Trie along with DFS. \\n1. Take two character(given) at a time, find it\\'s decryption match from hashmap. Verify the if this character in the word exits in trie or not.\\n*  **Example**: We have a word in Trie, `word` = **\"abbccc\"**,(stored in trie like a->b->b->c->c->c) and we have formed the decrypted string till 3rd character like,`re` = **\"abb\"**. \\n*  Now suppose our next character after decryption is **\\'f\\'**, but **\\'f\\'** does exits in next sequence of characters in **trie**. So, we will stop our search here and **return** **0**. But if it matches, we will continue our search untill there are no more chararcter to decrypt. If we reach at the end of the string, check if the word exits, if it do, **return 1**.\\n\\nBelow is the Implementation.\\n```\\nclass trie {\\npublic:\\n    char c;\\n    int word; trie* arr[26];\\n    trie(char ch) {\\n        c= ch;\\n        word = 0;\\n        for(int i = 0; i<26;++i){\\n            arr[i]=NULL;\\n        }\\n    }\\n    \\n    void addWord(string s) {\\n        trie* temp = this;\\n        for(int i = 0; i<s.size();++i){\\n            if(temp->arr[s[i]-\\'a\\']!=NULL) temp = temp->arr[s[i]-\\'a\\'];\\n            else{\\n                trie* p = new trie(s[i]);\\n                temp->arr[s[i]-\\'a\\'] = p;\\n                temp=p;\\n            }\\n        }\\n        temp->word=1;\\n    }\\n};\\nclass Encrypter {\\n    map<char,string> mp;\\n    map<string,vector<char>> mp1;\\n    trie* root = NULL;\\n    \\n    int dfs(string &s,int in,trie* root){\\n        if(in>=s.size()) return root->word;\\n        string t = string(1,s[in])+string(1,s[in+1]);\\n        int ans = 0;\\n        vector<char>& temp = mp1[t];\\n        for(int i = 0; i<temp.size();++i){\\n            if(root->arr[temp[i]-\\'a\\']!=NULL){\\n                ans+= dfs(s,in+2,root->arr[temp[i]-\\'a\\']);\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        root = new trie(\\'*\\');\\n        for(int i = 0; i<dictionary.size();++i) root->addWord(dictionary[i]);\\n        for(int i = 0; i<keys.size();++i) mp[keys[i]] = values[i];\\n        for(int i = 0; i<values.size();++i) mp1[values[i]].push_back(keys[i]);\\n    }\\n    \\n    string encrypt(string s) {\\n        string re;\\n        for(int i = 0; i<s.size();++i) re+=mp[s[i]];\\n        return re;\\n    }\\n    \\n    int decrypt(string s) {\\n       return dfs(s,0,root);\\n    }\\n};\\n```\\n**Upvote if it Helps**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass trie {\\npublic:\\n    char c;\\n    int word; trie* arr[26];\\n    trie(char ch) {\\n        c= ch;\\n        word = 0;\\n        for(int i = 0; i<26;++i){\\n            arr[i]=NULL;\\n        }\\n    }\\n    \\n    void addWord(string s) {\\n        trie* temp = this;\\n        for(int i = 0; i<s.size();++i){\\n            if(temp->arr[s[i]-\\'a\\']!=NULL) temp = temp->arr[s[i]-\\'a\\'];\\n            else{\\n                trie* p = new trie(s[i]);\\n                temp->arr[s[i]-\\'a\\'] = p;\\n                temp=p;\\n            }\\n        }\\n        temp->word=1;\\n    }\\n};\\nclass Encrypter {\\n    map<char,string> mp;\\n    map<string,vector<char>> mp1;\\n    trie* root = NULL;\\n    \\n    int dfs(string &s,int in,trie* root){\\n        if(in>=s.size()) return root->word;\\n        string t = string(1,s[in])+string(1,s[in+1]);\\n        int ans = 0;\\n        vector<char>& temp = mp1[t];\\n        for(int i = 0; i<temp.size();++i){\\n            if(root->arr[temp[i]-\\'a\\']!=NULL){\\n                ans+= dfs(s,in+2,root->arr[temp[i]-\\'a\\']);\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        root = new trie(\\'*\\');\\n        for(int i = 0; i<dictionary.size();++i) root->addWord(dictionary[i]);\\n        for(int i = 0; i<keys.size();++i) mp[keys[i]] = values[i];\\n        for(int i = 0; i<values.size();++i) mp1[values[i]].push_back(keys[i]);\\n    }\\n    \\n    string encrypt(string s) {\\n        string re;\\n        for(int i = 0; i<s.size();++i) re+=mp[s[i]];\\n        return re;\\n    }\\n    \\n    int decrypt(string s) {\\n       return dfs(s,0,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909917,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * N), for decryption and O(N) for encryption***\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, int> key;\\n    \\n    vector<string> value;\\n    \\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionarys) {\\n        \\n        for(int i = 0; i < keys.size(); i++)\\n        {\\n            key[keys[i]] = i;\\n        }\\n        \\n        value = values;\\n        \\n        dictionary = dictionarys;\\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        int n = word1.size();\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            char c = word1[i];\\n            \\n            int idx = key[c];\\n            \\n            string str = value[idx];\\n            \\n            res += str;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        int res = 0;\\n        \\n        for(auto x : dictionary)\\n        {\\n            if(encrypt(x) == word2)\\n            {\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, int> key;\\n    \\n    vector<string> value;\\n    \\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionarys) {\\n        \\n        for(int i = 0; i < keys.size(); i++)\\n        {\\n            key[keys[i]] = i;\\n        }\\n        \\n        value = values;\\n        \\n        dictionary = dictionarys;\\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        int n = word1.size();\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            char c = word1[i];\\n            \\n            int idx = key[c];\\n            \\n            string str = value[idx];\\n            \\n            res += str;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        int res = 0;\\n        \\n        for(auto x : dictionary)\\n        {\\n            if(encrypt(x) == word2)\\n            {\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909883,
                "title": "java-simple-code-using-hashmap-100-faster-with-explaination",
                "content": "**Time Complexity :-\\nEncrypter:- O(nlog(n))\\nencrypt:- O(mlog(n)) ; m-> length of provided String\\ndecrypt:- O(mlog(n))\\n\\n**\\n\\n**Explanation :-**\\nComming Soon\\n\\n**JAVA Code :-**\\n```\\nclass Encrypter {\\n    HashMap<Character,String> map1;\\n    HashMap<String,ArrayList<Character>> map2;\\n    HashMap<String,Integer> map3;\\n    public Encrypter(char[] keys, String[] values, String[] dict) {\\n        map1 = new HashMap<>();\\n        map2 = new HashMap<>();\\n        map3 = new HashMap<>();\\n        for(int i=0;i<keys.length;i++) {\\n            map1.put(keys[i],values[i]);\\n            if(map2.containsKey(values[i])) {\\n                ArrayList<Character> list = map2.get(values[i]);\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            } else {\\n                ArrayList<Character> list = new ArrayList<>();\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            }\\n        }\\n        for(String s : dict) {\\n            String cd = encrypt(s);\\n            if(map3.containsKey(cd)) {\\n                map3.put(cd,map3.get(cd)+1);\\n            } else {\\n                map3.put(cd,1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<word1.length();i++) {\\n            sb.append(map1.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int ct=0;\\n        for(String k : map3.keySet()) {\\n            if(k.compareTo(word2)==0) {\\n                ct+=map3.get(k);\\n            }\\n        }\\n        return ct;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    HashMap<Character,String> map1;\\n    HashMap<String,ArrayList<Character>> map2;\\n    HashMap<String,Integer> map3;\\n    public Encrypter(char[] keys, String[] values, String[] dict) {\\n        map1 = new HashMap<>();\\n        map2 = new HashMap<>();\\n        map3 = new HashMap<>();\\n        for(int i=0;i<keys.length;i++) {\\n            map1.put(keys[i],values[i]);\\n            if(map2.containsKey(values[i])) {\\n                ArrayList<Character> list = map2.get(values[i]);\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            } else {\\n                ArrayList<Character> list = new ArrayList<>();\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            }\\n        }\\n        for(String s : dict) {\\n            String cd = encrypt(s);\\n            if(map3.containsKey(cd)) {\\n                map3.put(cd,map3.get(cd)+1);\\n            } else {\\n                map3.put(cd,1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<word1.length();i++) {\\n            sb.append(map1.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int ct=0;\\n        for(String k : map3.keySet()) {\\n            if(k.compareTo(word2)==0) {\\n                ct+=map3.get(k);\\n            }\\n        }\\n        return ct;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1909756,
                "title": "c-trie",
                "content": "```\\nclass Encrypter {\\npublic:\\n    string charmap[26];\\n    vector<char> rmap[26][26];\\n    \\n    struct trienode{\\n        char c;\\n        trienode* child[26];\\n        bool isend;\\n        \\n        trienode(char cc){\\n            c = cc;\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n        \\n        \\n        trienode(){\\n            c = \\'#\\';\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n    }*root;\\n    \\n    void insert(trienode* root,string word){\\n        trienode* travel = root;\\n        \\n        for(int i=0;i<word.size();i++){\\n            int c = word[i]-\\'a\\';\\n            if(!travel->child[c]){\\n                travel->child[c] = new trienode(word[i]);\\n            }\\n            travel = travel->child[c];\\n        }\\n        travel->isend = true;\\n    }\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& words) {\\n        \\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                rmap[i][j].clear();\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            charmap[i] = \"\";\\n        }\\n        \\n        for(int i=0;i<keys.size();i++){\\n            charmap[keys[i]-\\'a\\'] = values[i];\\n            rmap[values[i][0]-\\'a\\'][values[i][1]-\\'a\\'].push_back(keys[i]);\\n        }\\n        \\n        root = new trienode(\\'$\\');\\n        for(auto word : words){\\n            insert(root,word);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c : word1){\\n            ans+=charmap[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int dfs(string &word,int idx,trienode* travel){\\n        int n = word.size();\\n        \\n        if(!travel)return 0;\\n        \\n        if(idx==n){\\n            return travel->isend;\\n        }\\n        \\n        if(rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\'].size()==0)return 0;\\n        \\n        int ans = 0;\\n        for(char c : rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\']){\\n            ans+=dfs(word,idx+2,travel->child[c-\\'a\\']);  \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dfs(word2,0,root);\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */``\\n```\\n\\n**TIme Complexity of Encrypt : o(no of chars in given word)\\nTime Complexity of Decrypt : O((no_of chars in given word/2) * size_of_dictionary)**\\n\\nSince we are using Trie, there lies atmost size of dictionary paths at the end of last recursion call and other would have been pruned.\\n\\nThe max depth of recursion tree is no_of_chars/2 and max paths is size_of_dictionary.\\nHence Complexity is O((no_of chars in given word/2) * size_of_dictionary).\\n\\n**Note: If you dont pass word by reference in Decrypt dfs function call you would get TLE**",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    string charmap[26];\\n    vector<char> rmap[26][26];\\n    \\n    struct trienode{\\n        char c;\\n        trienode* child[26];\\n        bool isend;\\n        \\n        trienode(char cc){\\n            c = cc;\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n        \\n        \\n        trienode(){\\n            c = \\'#\\';\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n    }*root;\\n    \\n    void insert(trienode* root,string word){\\n        trienode* travel = root;\\n        \\n        for(int i=0;i<word.size();i++){\\n            int c = word[i]-\\'a\\';\\n            if(!travel->child[c]){\\n                travel->child[c] = new trienode(word[i]);\\n            }\\n            travel = travel->child[c];\\n        }\\n        travel->isend = true;\\n    }\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& words) {\\n        \\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                rmap[i][j].clear();\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            charmap[i] = \"\";\\n        }\\n        \\n        for(int i=0;i<keys.size();i++){\\n            charmap[keys[i]-\\'a\\'] = values[i];\\n            rmap[values[i][0]-\\'a\\'][values[i][1]-\\'a\\'].push_back(keys[i]);\\n        }\\n        \\n        root = new trienode(\\'$\\');\\n        for(auto word : words){\\n            insert(root,word);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c : word1){\\n            ans+=charmap[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int dfs(string &word,int idx,trienode* travel){\\n        int n = word.size();\\n        \\n        if(!travel)return 0;\\n        \\n        if(idx==n){\\n            return travel->isend;\\n        }\\n        \\n        if(rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\'].size()==0)return 0;\\n        \\n        int ans = 0;\\n        for(char c : rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\']){\\n            ans+=dfs(word,idx+2,travel->child[c-\\'a\\']);  \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dfs(word2,0,root);\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */``\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1834851,
                "content": [
                    {
                        "username": "matthewwdaly",
                        "content": "Testcases do not allow encrypting a word containing a letter not in the keys, even though we are specifically told to handle that edge case."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Think about storing dictionary in encrypted form."
                    }
                ]
            },
            {
                "id": 2043619,
                "content": [
                    {
                        "username": "matthewwdaly",
                        "content": "Testcases do not allow encrypting a word containing a letter not in the keys, even though we are specifically told to handle that edge case."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Think about storing dictionary in encrypted form."
                    }
                ]
            }
        ]
    },
    {
        "title": " Check if There Is a Valid Parentheses String Path",
        "question_content": "<p>A parentheses string is a <strong>non-empty</strong> string consisting only of <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>. It is <strong>valid</strong> if <strong>any</strong> of the following conditions is <strong>true</strong>:</p>\n\n<ul>\n\t<li>It is <code>()</code>.</li>\n\t<li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid parentheses strings.</li>\n\t<li>It can be written as <code>(A)</code>, where <code>A</code> is a valid parentheses string.</li>\n</ul>\n\n<p>You are given an <code>m x n</code> matrix of parentheses <code>grid</code>. A <strong>valid parentheses string path</strong> in the grid is a path satisfying <strong>all</strong> of the following conditions:</p>\n\n<ul>\n\t<li>The path starts from the upper left cell <code>(0, 0)</code>.</li>\n\t<li>The path ends at the bottom-right cell <code>(m - 1, n - 1)</code>.</li>\n\t<li>The path only ever moves <strong>down</strong> or <strong>right</strong>.</li>\n\t<li>The resulting parentheses string formed by the path is <strong>valid</strong>.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if there exists a <strong>valid parentheses string path</strong> in the grid.</em> Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png\" style=\"width: 521px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> grid = [[&quot;(&quot;,&quot;(&quot;,&quot;(&quot;],[&quot;)&quot;,&quot;(&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;,&quot;)&quot;]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The above diagram shows two possible paths that form valid parentheses strings.\nThe first path shown results in the valid parentheses string &quot;()(())&quot;.\nThe second path shown results in the valid parentheses string &quot;((()))&quot;.\nNote that there may be other valid parentheses string paths.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png\" style=\"width: 165px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> grid = [[&quot;)&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The two possible paths form the parentheses strings &quot;))(&quot; and &quot;)((&quot;. Since neither of them are valid parentheses strings, we return false.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code> is either <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2017937,
                "title": "simple-dfs-dp",
                "content": "This problem can be solved by simply applying a DFS from top of the grid to bottom and keeping a count of \\'(\\' and \\')\\' as k.\\n\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int dp[100][100][205];\\n    bool solve(vector<vector<char>>& grid, int i, int j, int k)\\n    {\\n        if(i>=n || j>=m)\\n            return 0;\\n        \\n        if(grid[i][j]==\\'(\\')\\n            k++;\\n        else\\n            k--;\\n        \\n        if(k<0)\\n            return 0;\\n        \\n        if(i==n-1 && j==m-1)\\n            return (k==0);\\n        \\n        if(dp[i][j][k]!=-1)\\n            return dp[i][j][k];\\n        \\n        return dp[i][j][k]=(solve(grid, i+1, j, k) | solve(grid, i, j+1, k));\\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid)\\n    {\\n        n=grid.size();\\n        m=grid[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int dp[100][100][205];\\n    bool solve(vector<vector<char>>& grid, int i, int j, int k)\\n    {\\n        if(i>=n || j>=m)\\n            return 0;\\n        \\n        if(grid[i][j]==\\'(\\')\\n            k++;\\n        else\\n            k--;\\n        \\n        if(k<0)\\n            return 0;\\n        \\n        if(i==n-1 && j==m-1)\\n            return (k==0);\\n        \\n        if(dp[i][j][k]!=-1)\\n            return dp[i][j][k];\\n        \\n        return dp[i][j][k]=(solve(grid, i+1, j, k) | solve(grid, i, j+1, k));\\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid)\\n    {\\n        n=grid.size();\\n        m=grid[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017740,
                "title": "dfs",
                "content": "We run normal DFS, going left and right.\\n- We track the balance `bal` to check if the path is valid.\\n- If `bal` goes negative - we prune: orphan \\')\\'.\\n- if `bal` exceeds `(m + n) / 2` - we prune: too many \\'(\\' to close.\\n- If we reach the bottom-right corner, and `bal` is zero - we found a valid path.\\n\\nWe need to use memoisation (`visited`) so we do not explore the same cell with the same balance - otherwise we\\'ll get TLE.\\n\\n**C++**\\n```cpp\\nint visited[100][100][101] = {};\\nbool hasValidPath(vector<vector<char>>& grid, int i = 0, int j = 0, int bal = 0) {\\n    int m = grid.size(), n = grid[0].size();\\n    bal += grid[i][j] == \\'(\\' ? 1 : -1;\\n    if (bal < 0 || bal > (m + n) / 2 || visited[i][j][bal])\\n        return false;\\n    visited[i][j][bal] = true;\\n    if (i == m - 1 && j == n - 1 && bal == 0)\\n        return true;\\n    if (i < m - 1 && hasValidPath(grid, i + 1, j, bal))\\n        return true;\\n    if (j < n - 1 && hasValidPath(grid, i, j + 1, bal))\\n        return true;\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint visited[100][100][101] = {};\\nbool hasValidPath(vector<vector<char>>& grid, int i = 0, int j = 0, int bal = 0) {\\n    int m = grid.size(), n = grid[0].size();\\n    bal += grid[i][j] == \\'(\\' ? 1 : -1;\\n    if (bal < 0 || bal > (m + n) / 2 || visited[i][j][bal])\\n        return false;\\n    visited[i][j][bal] = true;\\n    if (i == m - 1 && j == n - 1 && bal == 0)\\n        return true;\\n    if (i < m - 1 && hasValidPath(grid, i + 1, j, bal))\\n        return true;\\n    if (j < n - 1 && hasValidPath(grid, i, j + 1, bal))\\n        return true;\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2017872,
                "title": "java-c-python-dp-solution",
                "content": "# **Explanation**\\nFor each ceel `A[i][j]`\\nwe count the number of open parenthese for the path reaching `A[i][j]`.\\nIf it\\'s negative, it\\'s not valid already.\\nFinally we check if there is a path to `A[m-1][n-1]` that has no open parenthese,\\nthat means a valid parentheses string path reaching `A[m-1][n-1]`.\\n<br>\\n\\n# **Optimisation**\\nI usually don\\'t handle edge cases specially,\\nsince they can be correctly handled by itself.\\nAnd usually the short cut only improve edge case, not general case,\\n\\nHere are 3 quick fail case:\\nIf `(n + m) % 2 == 0`, the length of path to `A[m-1][n-1]` is odd, can return false.\\nIf `A[-1][-1] == \\'(\\'`, no valid start can return false.\\nIf `A[0][0] == \\')\\'`, no valid end, can return false.\\n<br>\\n\\n# **Complexity**\\nTime `O(mn(m+n))`\\nSpace `O(mn(m+n))`\\n<br>\\n\\n**Java**\\nEdited from @arignote solution.\\n\\nTrick 1: \\nA[i][j][0] for the path count -1,\\nA[i][j][1] for the path count 0, etc.\\nNo need to handle negative specially.\\n\\nTrick 2: \\nUse something like `A[i+1] += A[i]` instead of `A[i] = A[i-1]`\\nNo need to handle `i == 0` and `j == 0` specially.\\n\\nTrick 3: \\n`dp[m][n - 1]` and `dp[m - 1][n]` are from `dp[m - 1][n - 1]`,\\nreturn `dp[m][n - 1][1]` for the result.\\n\\n```java\\n    public boolean hasValidPath(char[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][][] dp = new boolean[m + 1][n + 1][103];\\n        dp[0][0][1] = true;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= 101; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];\\n    }\\n```\\n**C++**\\nEdited from @agrinote, explained above.\\n```cpp\\n    bool hasValidPath(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), maxk = (m + n + 1) / 2;\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(maxk + 10)));\\n        dp[0][0][1] = 1;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= maxk; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];        \\n    }\\n```\\n\\n**Python**\\nUsing `set` are faster, since most path are not valid.\\n```py\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        dp = defaultdict(set)\\n        dp[0, -1] = dp[-1, 0] = {0}\\n        for i in range(m):\\n            for j in range(n):\\n                d = 1 if A[i][j] == \\'(\\' else -1\\n                dp[i,j] |= {a + d for a in dp[i-1,j] | dp[i,j-1] if a + d >= 0}\\n        return 0 in dp[m - 1, n - 1]\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public boolean hasValidPath(char[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][][] dp = new boolean[m + 1][n + 1][103];\\n        dp[0][0][1] = true;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= 101; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];\\n    }\\n```\n```cpp\\n    bool hasValidPath(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), maxk = (m + n + 1) / 2;\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(maxk + 10)));\\n        dp[0][0][1] = 1;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= maxk; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];        \\n    }\\n```\n```py\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        dp = defaultdict(set)\\n        dp[0, -1] = dp[-1, 0] = {0}\\n        for i in range(m):\\n            for j in range(n):\\n                d = 1 if A[i][j] == \\'(\\' else -1\\n                dp[i,j] |= {a + d for a in dp[i-1,j] | dp[i,j-1] if a + d >= 0}\\n        return 0 in dp[m - 1, n - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2018503,
                "title": "c-extremely-fast-short-2-loops-dp",
                "content": "You can refer to other posts for basic 3D DP solution. Here I optimize the 3D DP with two tricks:\\n\\n* Early return if the length of path is odd\\n* Use `bitset` with each bit representing a possible number of open parenthesis. When we meet a new opening `\\'(\\'`, we should add one more open parenthesis to all previous memorized result. With `bitset` we simply left shift. Similarly, For `\\')\\'` we right shift.\\n\\n```\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    if ((m + n - 1) % 2) // early return for odd length path\\n        return false;\\n    vector<bitset<100>> dp(n + 1);\\n    for (int i = 0; i < m; i++) {\\n        dp[0][0] = !i;\\n        for (int j = 0; j < n; j++)\\n            dp[j + 1] = grid[i][j] == \\'(\\' ? (dp[j] | dp[j + 1]) << 1: (dp[j] | dp[j + 1]) >> 1;\\n    }\\n    return dp[n][0];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    if ((m + n - 1) % 2) // early return for odd length path\\n        return false;\\n    vector<bitset<100>> dp(n + 1);\\n    for (int i = 0; i < m; i++) {\\n        dp[0][0] = !i;\\n        for (int j = 0; j < n; j++)\\n            dp[j + 1] = grid[i][j] == \\'(\\' ? (dp[j] | dp[j + 1]) << 1: (dp[j] | dp[j + 1]) >> 1;\\n    }\\n    return dp[n][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018005,
                "title": "python-simple-memoisation-caching",
                "content": "There are two main parts of the solution:\\n1. Logic to determine whether a sequence is [Balanced Paranteses](https://leetcode.com/problems/valid-parentheses/). This can be achieved using `Stack`(`O(N) space`) or using a `counter` variable(`O(1) space`). I will be using the latter.\\n2. A recursive function to check the existence of a valid parantheses sequence in the input `grid`.\\n\\n\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:  \\n        m = len(grid)\\n        n = len(grid[0])\\n        @lru_cache(maxsize=None)\\n        def hasValidPathInner(x, y, cnt):\\n            # cnt variable would act as a counter to track \\n            # the balance of parantheses sequence\\n            if x == m or y == n or cnt < 0:\\n                return False\\n            \\n            # logic to check the balance of sequence\\n            cnt += 1 if grid[x][y] == \\'(\\' else -1\\n            \\n            # if balanced and end of grid, return True\\n            if x == m - 1 and y == n - 1 and not cnt:\\n                return True\\n            \\n            return hasValidPathInner(x + 1, y, cnt) or hasValidPathInner(x, y + 1, cnt)\\n\\n        return hasValidPathInner(0, 0, 0)\\n```\\n\\n**Time = O(mn(m+n))** - Due to memoization, the same path won\\'t be visited twice. `M + N` is the max length of a sequence or max depth of recursive stack from `0,0` to `m-1,n-1` in the `grid` \\n**Space = O(mn(m+n))**\\n\\n\\n----\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:  \\n        m = len(grid)\\n        n = len(grid[0])\\n        @lru_cache(maxsize=None)\\n        def hasValidPathInner(x, y, cnt):\\n            # cnt variable would act as a counter to track \\n            # the balance of parantheses sequence\\n            if x == m or y == n or cnt < 0:\\n                return False\\n            \\n            # logic to check the balance of sequence\\n            cnt += 1 if grid[x][y] == \\'(\\' else -1\\n            \\n            # if balanced and end of grid, return True\\n            if x == m - 1 and y == n - 1 and not cnt:\\n                return True\\n            \\n            return hasValidPathInner(x + 1, y, cnt) or hasValidPathInner(x, y + 1, cnt)\\n\\n        return hasValidPathInner(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018115,
                "title": "memoization",
                "content": "**if at any point open < 0 then the path is not balanced.**\\n\\n```\\nclass Solution {\\n    int m, n;\\n    int memo[101][101][201];\\npublic:\\n    bool doit(vector<vector<char>>& grid, int i, int j, int open) {\\n        \\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if (open < 0)   return false;\\n        if (memo[i][j][open] != -1) return memo[i][j][open];\\n        if (i == m-1 and j == n-1 and open == 0)    return true;\\n        if (i < m-1 and doit(grid, i+1, j, open))   return memo[i][j][open] = true;\\n        if (j < n-1 and doit(grid, i, j+1, open))   return memo[i][j][open] = true;\\n        return memo[i][j][open] = false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        memset(memo, -1, sizeof memo);\\n        m = size(grid), n = size(grid[0]);\\n        if((m+n-1)&1) return false;\\n        return doit(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    int memo[101][101][201];\\npublic:\\n    bool doit(vector<vector<char>>& grid, int i, int j, int open) {\\n        \\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if (open < 0)   return false;\\n        if (memo[i][j][open] != -1) return memo[i][j][open];\\n        if (i == m-1 and j == n-1 and open == 0)    return true;\\n        if (i < m-1 and doit(grid, i+1, j, open))   return memo[i][j][open] = true;\\n        if (j < n-1 and doit(grid, i, j+1, open))   return memo[i][j][open] = true;\\n        return memo[i][j][open] = false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        memset(memo, -1, sizeof memo);\\n        m = size(grid), n = size(grid[0]);\\n        if((m+n-1)&1) return false;\\n        return doit(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017812,
                "title": "same-as-valid-parenthesis-string-but-with-memo-o-mn-m-n",
                "content": "**Intuition:** Same as checking valid parenthesis in a string. Need to maintain a counter \"open\" to mark the number of opening/closing braces encountered. If \\'(\\' is encountered incr. open by 1, else decrement open by 1. Now as there can be several paths possible from each cell in a grid, so there can be multiple repeated calculations done from each cell. To avoid that use DP/Memoisation.\\nDP array has 3 states: row, col, open count. Since open count can be maximum of 199(complete first row + complete last column), so taking 201.\\n\\n```\\nCode: \\nclass Solution {\\npublic:\\n    int dp[101][101][201];\\t\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp, -1, sizeof(dp));\\n        return isPossible(grid, 0, 0, 0);\\n    }\\n    \\n    bool isPossible(vector<vector<char>>& grid, int i, int j, int open) {\\n        if(i == grid.size() || j == grid[0].size())\\n            return false;\\n        if(grid[i][j] == \\')\\' && open == 0)\\n            return false;\\n        if(i == grid.size()-1 && j == grid[0].size()-1) \\n            return open+(grid[i][j] == \\'(\\' ? 1 : -1) == 0;\\n        if(dp[i][j][open] != -1)\\n            return dp[i][j][open];\\n        return dp[i][j][open] = isPossible(grid, i+1, j, open+(grid[i][j] == \\'(\\' ? 1 : -1)) ||  // down\\n                                isPossible(grid, i, j+1, open+(grid[i][j] == \\'(\\' ? 1 : -1));\\t// right\\n    }\\n};\\n```\\n\\nKindly upvote if helpful to keep me motivated ^-^. Also comment down for any doubts.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nCode: \\nclass Solution {\\npublic:\\n    int dp[101][101][201];\\t\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp, -1, sizeof(dp));\\n        return isPossible(grid, 0, 0, 0);\\n    }\\n    \\n    bool isPossible(vector<vector<char>>& grid, int i, int j, int open) {\\n        if(i == grid.size() || j == grid[0].size())\\n            return false;\\n        if(grid[i][j] == \\')\\' && open == 0)\\n            return false;\\n        if(i == grid.size()-1 && j == grid[0].size()-1) \\n            return open+(grid[i][j] == \\'(\\' ? 1 : -1) == 0;\\n        if(dp[i][j][open] != -1)\\n            return dp[i][j][open];\\n        return dp[i][j][open] = isPossible(grid, i+1, j, open+(grid[i][j] == \\'(\\' ? 1 : -1)) ||  // down\\n                                isPossible(grid, i, j+1, open+(grid[i][j] == \\'(\\' ? 1 : -1));\\t// right\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017824,
                "title": "java-solution-using-dp",
                "content": "```\\nclass Solution {\\n    static Boolean[][][] dp;\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        dp = new Boolean[101][101][201];  // [row][col][open-close]\\n        if(grid[0][0] == \\')\\'){   // cannot start with \\')\\'\\n            return false;\\n        }\\n        if(grid[m-1][n-1] == \\'(\\'){  // cannot end with \\'(\\' \\n            return false;\\n        }\\n        return solve(grid,0,0,m,n,0,0);\\n    }\\n    public static boolean solve(char[][] grid,int i,int j,int m,int n,int open,int close){\\n        if(grid[i][j] == \\'(\\'){\\n            open++;\\n        }\\n        else{\\n            close++;\\n        }\\n        if(close > open){  // at any point if closeBracket count exceeds openBracket count then return false since this path can never lead to valid paranthesis string\\n            return false;\\n        }\\n        if(i == m-1 && j == n-1){  // on reaching bottom right cell if openCount == closeCount return true else return false\\n            return open == close;\\n        }\\n        if(dp[i][j][open-close] != null){  // check for precomputed overlapping subproblem\\n            return dp[i][j][open-close];\\n        }\\n        if(i == m-1){   // make sure to not go out of the grid in last row\\n            return dp[i][j][open-close] = solve(grid,i,j+1,m,n,open,close);\\n        }\\n        if(j == n-1){  // make sure to not go out of the grid in last col\\n            return dp[i][j][open-close] = solve(grid,i+1,j,m,n,open,close);\\n        }\\n        boolean op = solve(grid,i+1,j,m,n,open,close) || solve(grid,i,j+1,m,n,open,close); // we have two choices to move forward, [i+1][j] or [i][j+1]\\n        return dp[i][j][open-close] = op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    static Boolean[][][] dp;\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        dp = new Boolean[101][101][201];  // [row][col][open-close]\\n        if(grid[0][0] == \\')\\'){   // cannot start with \\')\\'\\n            return false;\\n        }\\n        if(grid[m-1][n-1] == \\'(\\'){  // cannot end with \\'(\\' \\n            return false;\\n        }\\n        return solve(grid,0,0,m,n,0,0);\\n    }\\n    public static boolean solve(char[][] grid,int i,int j,int m,int n,int open,int close){\\n        if(grid[i][j] == \\'(\\'){\\n            open++;\\n        }\\n        else{\\n            close++;\\n        }\\n        if(close > open){  // at any point if closeBracket count exceeds openBracket count then return false since this path can never lead to valid paranthesis string\\n            return false;\\n        }\\n        if(i == m-1 && j == n-1){  // on reaching bottom right cell if openCount == closeCount return true else return false\\n            return open == close;\\n        }\\n        if(dp[i][j][open-close] != null){  // check for precomputed overlapping subproblem\\n            return dp[i][j][open-close];\\n        }\\n        if(i == m-1){   // make sure to not go out of the grid in last row\\n            return dp[i][j][open-close] = solve(grid,i,j+1,m,n,open,close);\\n        }\\n        if(j == n-1){  // make sure to not go out of the grid in last col\\n            return dp[i][j][open-close] = solve(grid,i+1,j,m,n,open,close);\\n        }\\n        boolean op = solve(grid,i+1,j,m,n,open,close) || solve(grid,i,j+1,m,n,open,close); // we have two choices to move forward, [i+1][j] or [i][j+1]\\n        return dp[i][j][open-close] = op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017743,
                "title": "c-two-solution-bfs-and-dp-dp-and-memoization",
                "content": "**first bfs solution**\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    bool hasValidPath(vector<vector<char>>& mat) \\n    {\\n        vector<pair<int,int>>d={{0,1},{1,0}};\\n        n=mat.size();\\n        m=mat[0].size();\\n        queue<tuple<int,int,int>>q;\\n        if(mat[0][0]==\\'(\\')\\n        {\\n        q.push({0,0,1});\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        int dp[111][111][311];\\n        memset(dp,-1,sizeof(dp));\\n        dp[0][0][1]=1;\\n        while(q.size())\\n        {\\n            auto [x,y,b]=q.front();\\n            q.pop();\\n            if(b<0)\\n            {\\n                continue;\\n            }\\n            if(x==n-1&&y==m-1)\\n            {\\n                if(b==0)\\n                {\\n                    return true;\\n                }\\n            }\\n            for(auto it:d)\\n            {\\n                int nx=x+it.first;\\n                int ny=y+it.second;\\n                if(b<0)\\n                {\\n                    continue;\\n                }\\n                if(nx>=0&&ny>=0&&nx<n&&ny<m&&dp[nx][ny][b]==-1)\\n                {\\n                    if(b>=0&&b<=n*m)\\n                    dp[nx][ny][b]=1;\\n                    if(mat[nx][ny]==\\'(\\')\\n                    {\\n                        q.push({nx,ny,b+1});\\n                    }\\n                    else\\n                    {\\n                        q.push({nx,ny,b-1});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n**second dp solution using memoization**\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dp[101][101][200];\\n    bool find(vector<vector<char>>& mat,int row,int col,int open)\\n    {\\n        if(row<0||col<0||row>=n||col>=m||open<0)\\n        {\\n            return false;\\n        }\\n        if(dp[row][col][open]!=-1)\\n        {\\n            return dp[row][col][open];\\n        }\\n        if(row==n-1&&col==m-1)\\n        {\\n            if(mat[row][col]==\\'(\\')\\n            {\\n                open++;\\n            }\\n            else \\n            {\\n                open--;\\n            }\\n            return open==0;\\n        }\\n        if(mat[row][col]==\\'(\\')\\n        {\\n            if(find(mat,row+1,col,open+1)||find(mat,row,col+1,open+1))\\n            {\\n                return true;\\n            }\\n        }\\n        else\\n        {\\n            if(find(mat,row+1,col,open-1)||find(mat,row,col+1,open-1))\\n            {\\n                return true;\\n            }\\n        }\\n        return dp[row][col][open]=false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& mat) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=mat.size();\\n        m=mat[0].size();\\n        return find(mat,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    bool hasValidPath(vector<vector<char>>& mat) \\n    {\\n        vector<pair<int,int>>d={{0,1},{1,0}};\\n        n=mat.size();\\n        m=mat[0].size();\\n        queue<tuple<int,int,int>>q;\\n        if(mat[0][0]==\\'(\\')\\n        {\\n        q.push({0,0,1});\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        int dp[111][111][311];\\n        memset(dp,-1,sizeof(dp));\\n        dp[0][0][1]=1;\\n        while(q.size())\\n        {\\n            auto [x,y,b]=q.front();\\n            q.pop();\\n            if(b<0)\\n            {\\n                continue;\\n            }\\n            if(x==n-1&&y==m-1)\\n            {\\n                if(b==0)\\n                {\\n                    return true;\\n                }\\n            }\\n            for(auto it:d)\\n            {\\n                int nx=x+it.first;\\n                int ny=y+it.second;\\n                if(b<0)\\n                {\\n                    continue;\\n                }\\n                if(nx>=0&&ny>=0&&nx<n&&ny<m&&dp[nx][ny][b]==-1)\\n                {\\n                    if(b>=0&&b<=n*m)\\n                    dp[nx][ny][b]=1;\\n                    if(mat[nx][ny]==\\'(\\')\\n                    {\\n                        q.push({nx,ny,b+1});\\n                    }\\n                    else\\n                    {\\n                        q.push({nx,ny,b-1});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dp[101][101][200];\\n    bool find(vector<vector<char>>& mat,int row,int col,int open)\\n    {\\n        if(row<0||col<0||row>=n||col>=m||open<0)\\n        {\\n            return false;\\n        }\\n        if(dp[row][col][open]!=-1)\\n        {\\n            return dp[row][col][open];\\n        }\\n        if(row==n-1&&col==m-1)\\n        {\\n            if(mat[row][col]==\\'(\\')\\n            {\\n                open++;\\n            }\\n            else \\n            {\\n                open--;\\n            }\\n            return open==0;\\n        }\\n        if(mat[row][col]==\\'(\\')\\n        {\\n            if(find(mat,row+1,col,open+1)||find(mat,row,col+1,open+1))\\n            {\\n                return true;\\n            }\\n        }\\n        else\\n        {\\n            if(find(mat,row+1,col,open-1)||find(mat,row,col+1,open-1))\\n            {\\n                return true;\\n            }\\n        }\\n        return dp[row][col][open]=false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& mat) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=mat.size();\\n        m=mat[0].size();\\n        return find(mat,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018172,
                "title": "dfs-memo",
                "content": "* If `g[i][j] == \\'(\\'` then o++ (increment openings)\\nelse o-- (decrement openings) \\n* At max brackets will be manhattan distance from last cell to 0th cell\\n\\t i.e., `r-1 + c-1 => r+c-2`\\n* Prune when `o>max or o<0`\\n```\\nclass Solution {\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        max = (r + c) - 2;\\n        dp = new Boolean[r + 1][c + 1][max + 1];\\n        return solve(0, 0, grid, 0);\\n    }\\n\\n    int max = 0;\\n    Boolean dp[][][];\\n\\n    private boolean solve(int i, int j, char g[][], int open) {\\n        if (i < 0 || j < 0 || i >= g.length || j >= g[0].length) return false;\\n        if (open < 0 || open > max) return false;\\n        if (dp[i][j][open] != null) return dp[i][j][open];\\n        if (i == g.length - 1 && j == g[0].length - 1) {\\n            if (g[i][j] == \\'(\\') open++; else open--;\\n            return open == 0;\\n        }\\n        if (g[i][j] == \\'(\\') return dp[i][j][open] = solve(i + 1, j, g, open + 1) || solve(i, j + 1, g, open + 1);\\n        return dp[i][j][open] = solve(i + 1, j, g, open - 1) || solve(i, j + 1, g, open - 1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        max = (r + c) - 2;\\n        dp = new Boolean[r + 1][c + 1][max + 1];\\n        return solve(0, 0, grid, 0);\\n    }\\n\\n    int max = 0;\\n    Boolean dp[][][];\\n\\n    private boolean solve(int i, int j, char g[][], int open) {\\n        if (i < 0 || j < 0 || i >= g.length || j >= g[0].length) return false;\\n        if (open < 0 || open > max) return false;\\n        if (dp[i][j][open] != null) return dp[i][j][open];\\n        if (i == g.length - 1 && j == g[0].length - 1) {\\n            if (g[i][j] == \\'(\\') open++; else open--;\\n            return open == 0;\\n        }\\n        if (g[i][j] == \\'(\\') return dp[i][j][open] = solve(i + 1, j, g, open + 1) || solve(i, j + 1, g, open + 1);\\n        return dp[i][j][open] = solve(i + 1, j, g, open - 1) || solve(i, j + 1, g, open - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021277,
                "title": "6-short-lines-python-bitsets",
                "content": "Using ints as bitsets, where bit `i` being 1 means that we can reach the grid cell with `i` parentheses opened. Always take the union of the left cell\\'s and upper cell\\'s bitset, and shift it left or right depending on the cell\\'s parenthesis.\\n\\n**Solution 1, bottom-up DP**\\n\\nInstead of a 2D dp array, I just keep its latest row. \\n\\n    def hasValidPath(_, A):\\n        dp = [1] + [0] * 99\\n        for row in A:\\n            L = 0\\n            dp = [L := (lshift, rshift)[a == \\')\\'](L | U, 1)\\n                  for a, U in zip(row, dp)]\\n        return dp[-1] & 1\\n\\n**Solution 2, top-down with memoization**\\n\\n    def hasValidPath(_, A):\\n        @cache\\n        def dp(i, j):\\n            if i < 0 or j < 0:\\n                return i == 0\\n            return (lshift, rshift)[A[i][j] == \\')\\'](dp(i-1, j) | dp(i, j-1), 1)\\n        return dp(len(A)-1, len(A[0])-1) & 1",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "Using ints as bitsets, where bit `i` being 1 means that we can reach the grid cell with `i` parentheses opened. Always take the union of the left cell\\'s and upper cell\\'s bitset, and shift it left or right depending on the cell\\'s parenthesis.\\n\\n**Solution 1, bottom-up DP**\\n\\nInstead of a 2D dp array, I just keep its latest row. \\n\\n    def hasValidPath(_, A):\\n        dp = [1] + [0] * 99\\n        for row in A:\\n            L = 0\\n            dp = [L := (lshift, rshift)[a == \\')\\'](L | U, 1)\\n                  for a, U in zip(row, dp)]\\n        return dp[-1] & 1\\n\\n**Solution 2, top-down with memoization**\\n\\n    def hasValidPath(_, A):\\n        @cache\\n        def dp(i, j):\\n            if i < 0 or j < 0:\\n                return i == 0\\n            return (lshift, rshift)[A[i][j] == \\')\\'](dp(i-1, j) | dp(i, j-1), 1)\\n        return dp(len(A)-1, len(A[0])-1) & 1",
                "codeTag": "Python3"
            },
            {
                "id": 2018906,
                "title": "c-simple-bfs-dp-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        queue<tuple<int,int,int>> q;\\n        int visited[100][100][101] = {};\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n        \\n        if(grid[0][0]==\\'(\\') q.push({0,0,1});\\n        else return false;\\n        \\n        while(!q.empty()){\\n            \\n            auto [Nx,Ny,b]=q.front();\\n            q.pop();\\n            \\n            if(b<0 or b>(row+col)/2 or visited[Nx][Ny][b]) continue;\\n            visited[Nx][Ny][b] = true;\\n\\n            if(Nx==row-1 and Ny==col-1 and b==0) return true;\\n            \\n            if(Nx+1<row){\\n                if(grid[Nx+1][Ny]==\\'(\\') q.push({Nx+1,Ny,b+1});\\n                else q.push({Nx+1,Ny,b-1});\\n            }\\n            if(Ny+1<col){\\n                if(grid[Nx][Ny+1]==\\'(\\') q.push({Nx,Ny+1,b+1});\\n                else q.push({Nx,Ny+1,b-1});\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        queue<tuple<int,int,int>> q;\\n        int visited[100][100][101] = {};\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n        \\n        if(grid[0][0]==\\'(\\') q.push({0,0,1});\\n        else return false;\\n        \\n        while(!q.empty()){\\n            \\n            auto [Nx,Ny,b]=q.front();\\n            q.pop();\\n            \\n            if(b<0 or b>(row+col)/2 or visited[Nx][Ny][b]) continue;\\n            visited[Nx][Ny][b] = true;\\n\\n            if(Nx==row-1 and Ny==col-1 and b==0) return true;\\n            \\n            if(Nx+1<row){\\n                if(grid[Nx+1][Ny]==\\'(\\') q.push({Nx+1,Ny,b+1});\\n                else q.push({Nx+1,Ny,b-1});\\n            }\\n            if(Ny+1<col){\\n                if(grid[Nx][Ny+1]==\\'(\\') q.push({Nx,Ny+1,b+1});\\n                else q.push({Nx,Ny+1,b-1});\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018305,
                "title": "java-dfs-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\n    boolean[][][] vis = new boolean[100][100][101];\\n    boolean isValid(char[][] grid, int i, int j, int count){\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        count += grid[i][j]==\\'(\\' ? 1 : -1;\\n        if(count < 0 || count > (n+m)/2 || vis[i][j][count]) return false;\\n        vis[i][j][count] = true;\\n\\t\\t\\n        if(count==0 && i==n-1 &&  j==m-1) return true;\\n        if(i < n-1 && isValid(grid,i+1,j,count)) return true;\\n        if(j < m-1 && isValid(grid,i,j+1,count)) return true;\\n        return false;\\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        return isValid(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean[][][] vis = new boolean[100][100][101];\\n    boolean isValid(char[][] grid, int i, int j, int count){\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        count += grid[i][j]==\\'(\\' ? 1 : -1;\\n        if(count < 0 || count > (n+m)/2 || vis[i][j][count]) return false;\\n        vis[i][j][count] = true;\\n\\t\\t\\n        if(count==0 && i==n-1 &&  j==m-1) return true;\\n        if(i < n-1 && isValid(grid,i+1,j,count)) return true;\\n        if(j < m-1 && isValid(grid,i,j+1,count)) return true;\\n        return false;\\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        return isValid(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018132,
                "title": "python3-short-dp-6-lines-explained",
                "content": "### Explanation:\\n* `k` denotes the running sum of the parentheses. For each `(`, add +1 for each `)` add -1\\n* At any point `k` should not be less than 0 else valid parentheses beyond that point is not possible\\n*  If `(A[i][j] == \\')\\' and k < 1)` k will become < 0 when we perform k - 1, so we return `False`\\n*  `if i == m - 1 and j == n - 1: return A[i][j] == \\')\\' and k == 1` If we are on the last cell return `True` if last cell contains `)` and `k == 1`. `k - 1` will be `= 0` which will mean parentheses are balanced. For every other case on last cell, we return `False` \\n*  The `any()` function returns True if any item in an iterable are true, otherwise it returns False.\\n\\n```\\ndef hasValidPath(self, A: List[List[str]]) -> bool:\\n\\t@cache\\n\\tdef dfs(i, j, k):\\n\\t\\tif i >= len(A) or j >= len(A[0]) or (A[i][j] == \\')\\' and k < 1): return False\\n\\t\\tif i == len(A) - 1 and j == len(A[0]) - 1: return A[i][j] == \\')\\' and k == 1\\n\\t\\treturn any(dfs(i + x, j + y, k + (1 if A[i][j] == \\'(\\' else -1)) for x, y in [[0, 1], [1, 0]])\\n\\treturn dfs(0, 0, 0)\\n```\\nTime complexity: O(mn(m+n))",
                "solutionTags": [],
                "code": "```\\ndef hasValidPath(self, A: List[List[str]]) -> bool:\\n\\t@cache\\n\\tdef dfs(i, j, k):\\n\\t\\tif i >= len(A) or j >= len(A[0]) or (A[i][j] == \\')\\' and k < 1): return False\\n\\t\\tif i == len(A) - 1 and j == len(A[0]) - 1: return A[i][j] == \\')\\' and k == 1\\n\\t\\treturn any(dfs(i + x, j + y, k + (1 if A[i][j] == \\'(\\' else -1)) for x, y in [[0, 1], [1, 0]])\\n\\treturn dfs(0, 0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2017796,
                "title": "simple-top-down-code",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if(grid[0][0]==\")\"):return False\\n        @lru_cache(None)\\n        def fun(s,i,j):\\n            if(s<0):return False\\n            if(i==(len(grid)-1) and j==(len(grid[0])-1)):return s==0\\n            if(i+1<len(grid)):\\n                if(grid[i+1][j]==\")\"):\\n                    if(fun(s-1,i+1,j)):return True\\n                if(grid[i+1][j]==\"(\"):\\n                    if(fun(s+1,i+1,j)):return True\\n            if(j+1<len(grid[0])):\\n                if(grid[i][j+1]==\")\"):\\n                    if(fun(s-1,i,j+1)):return True\\n                if(grid[i][j+1]==\"(\"):\\n                    if(fun(s+1,i,j+1)):return True\\n            return False\\n        return fun(1,0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if(grid[0][0]==\")\"):return False\\n        @lru_cache(None)\\n        def fun(s,i,j):\\n            if(s<0):return False\\n            if(i==(len(grid)-1) and j==(len(grid[0])-1)):return s==0\\n            if(i+1<len(grid)):\\n                if(grid[i+1][j]==\")\"):\\n                    if(fun(s-1,i+1,j)):return True\\n                if(grid[i+1][j]==\"(\"):\\n                    if(fun(s+1,i+1,j)):return True\\n            if(j+1<len(grid[0])):\\n                if(grid[i][j+1]==\")\"):\\n                    if(fun(s-1,i,j+1)):return True\\n                if(grid[i][j+1]==\"(\"):\\n                    if(fun(s+1,i,j+1)):return True\\n            return False\\n        return fun(1,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020278,
                "title": "c-bottom-up-dp-solution-faster-than-100-o-mn-m-n-64",
                "content": "The solution uses a similar idea to all the other current solutions. Since int_128 seems to be unavailable, we can simply use a bitset to achieve O(mn(m+n) / 64) time complexity.\\n\\nIdea:\\nWe know from valid parantheses question all we need to do is maintain the number of left brackets. Here, `dp[i][j][k]` represents whether there is a valid way of reaching i, j with k left brackets remaining. The bit operations here just help speedup the solution but the logic is similar to all other DP solutions.\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector<vector<bitset<101>>> dp;\\n        int r = grid.size(), c = grid[0].size();\\n        dp.assign(r, vector<bitset<101>>(c, bitset<101>()));\\n        \\n        if (grid[0][0] == \\'(\\') dp[0][0][1] = 1;\\n        else return false;\\n        \\n        for (int i = 1; i < r; i++) {\\n            if (grid[i][0] == \\'(\\') dp[i][0] = (dp[i-1][0] << 1);\\n            else dp[i][0] = (dp[i-1][0] >> 1);\\n        }\\n        \\n        for (int j = 1; j < c; j++) {\\n            if (grid[0][j] == \\'(\\') dp[0][j] = (dp[0][j-1] << 1);\\n            else dp[0][j] = (dp[0][j-1] >> 1);\\n        }\\n        \\n        for (int i = 1; i < r; i++) {\\n            for (int j = 1; j < c; j++) {\\n                dp[i][j] = dp[i-1][j] | dp[i][j-1];\\n                if (grid[i][j] == \\'(\\') dp[i][j] <<= 1;\\n                else dp[i][j] >>= 1;\\n            }\\n        }\\n        \\n        return dp[r-1][c-1][0];\\n    }\\n};\\n```\\n\\nFurther optimization: we can simply compress it to a vector of bitsets instead :)\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector<bitset<101>> dp;\\n        int r = grid.size(), c = grid[0].size();\\n        if (grid[0][0] != \\'(\\') return false;\\n        dp.assign(c, bitset<101>()); dp[0][0] = 1;\\n        \\n        for (int i = 0; i < r; i++) {\\n            if (grid[i][0] == \\'(\\') dp[0] <<= 1;\\n            else dp[0] >>= 1;\\n            for (int j = 1; j < c; j++) {\\n                dp[j] |= dp[j-1];\\n                if (grid[i][j] == \\'(\\') dp[j] <<= 1;\\n                else dp[j] >>= 1;\\n            }\\n        }\\n        \\n        return dp[c-1][0];\\n    }\\n};\\n```\\n\\nDo upvote if you think the solution helped you! And do leave any questions below :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector<vector<bitset<101>>> dp;\\n        int r = grid.size(), c = grid[0].size();\\n        dp.assign(r, vector<bitset<101>>(c, bitset<101>()));\\n        \\n        if (grid[0][0] == \\'(\\') dp[0][0][1] = 1;\\n        else return false;\\n        \\n        for (int i = 1; i < r; i++) {\\n            if (grid[i][0] == \\'(\\') dp[i][0] = (dp[i-1][0] << 1);\\n            else dp[i][0] = (dp[i-1][0] >> 1);\\n        }\\n        \\n        for (int j = 1; j < c; j++) {\\n            if (grid[0][j] == \\'(\\') dp[0][j] = (dp[0][j-1] << 1);\\n            else dp[0][j] = (dp[0][j-1] >> 1);\\n        }\\n        \\n        for (int i = 1; i < r; i++) {\\n            for (int j = 1; j < c; j++) {\\n                dp[i][j] = dp[i-1][j] | dp[i][j-1];\\n                if (grid[i][j] == \\'(\\') dp[i][j] <<= 1;\\n                else dp[i][j] >>= 1;\\n            }\\n        }\\n        \\n        return dp[r-1][c-1][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector<bitset<101>> dp;\\n        int r = grid.size(), c = grid[0].size();\\n        if (grid[0][0] != \\'(\\') return false;\\n        dp.assign(c, bitset<101>()); dp[0][0] = 1;\\n        \\n        for (int i = 0; i < r; i++) {\\n            if (grid[i][0] == \\'(\\') dp[0] <<= 1;\\n            else dp[0] >>= 1;\\n            for (int j = 1; j < c; j++) {\\n                dp[j] |= dp[j-1];\\n                if (grid[i][j] == \\'(\\') dp[j] <<= 1;\\n                else dp[j] >>= 1;\\n            }\\n        }\\n        \\n        return dp[c-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017789,
                "title": "python3-dfs-iterative",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\':\\n            return False\\n        \\n        m, n = len(grid), len(grid[0])\\n        DIRS = [[0,1],[1,0]]\\n        \\n        stack = []\\n        \\n        # bal for tracking parenthesis balance\\n        bal = 1\\n        stack.append([0, 0, bal])\\n        seen = set()\\n        seen.add((0, 0, bal))\\n        while stack:\\n            x, y, curr_bal = stack.pop()\\n            if x == m - 1 and y == n - 1 and curr_bal == 0:\\n                return True\\n            curr = grid[x][y]\\n            for d in DIRS:\\n                r = x + d[0]\\n                c = y + d[1]\\n                if 0<=r<m and 0<=c<n:\\n                    if (r,c,curr_bal) not in seen:\\n                        seen.add((r,c,curr_bal))\\n                        next_p = grid[r][c]\\n                        if next_p == \"(\":\\n                            curr_bal += 1\\n                            stack.append([r, c, curr_bal])\\n                            curr_bal -= 1\\n                        else:\\n                            if curr_bal > 0:\\n                                curr_bal -= 1\\n                                stack.append([r, c, curr_bal])\\n                                curr_bal += 1\\n        return False\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\':\\n            return False\\n        \\n        m, n = len(grid), len(grid[0])\\n        DIRS = [[0,1],[1,0]]\\n        \\n        stack = []\\n        \\n        # bal for tracking parenthesis balance\\n        bal = 1\\n        stack.append([0, 0, bal])\\n        seen = set()\\n        seen.add((0, 0, bal))\\n        while stack:\\n            x, y, curr_bal = stack.pop()\\n            if x == m - 1 and y == n - 1 and curr_bal == 0:\\n                return True\\n            curr = grid[x][y]\\n            for d in DIRS:\\n                r = x + d[0]\\n                c = y + d[1]\\n                if 0<=r<m and 0<=c<n:\\n                    if (r,c,curr_bal) not in seen:\\n                        seen.add((r,c,curr_bal))\\n                        next_p = grid[r][c]\\n                        if next_p == \"(\":\\n                            curr_bal += 1\\n                            stack.append([r, c, curr_bal])\\n                            curr_bal -= 1\\n                        else:\\n                            if curr_bal > 0:\\n                                curr_bal -= 1\\n                                stack.append([r, c, curr_bal])\\n                                curr_bal += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017723,
                "title": "3d-dp-simple-intuition",
                "content": "**Approach :-**\\n\\nWe try to find a path such that there will be always opening bracket >= closing bracket and finally at the end opening bracket == closing bracket. We use third changing variable as the opening bracket + closing bracket and hence we can solve this using 3D DP.\\n\\n```\\nCode:\\n\\nclass Solution {\\npublic:\\n    bool isSafe(int i,int j,int m,int n){\\n        return i >= 0 and i < m and j >= 0 and j < n;\\n    }\\n    bool solve(vector<vector<char>>& grid,int i,int j,int curr,vector<vector<vector<int>>>&dp){\\n        if(curr < 0) return false;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(i == m-1 and j == n-1){\\n            if(grid[i][j] == \\'(\\'){\\n                curr += 1;\\n            }else{\\n                curr -= 1;\\n            }\\n            if(curr == 0) return true;\\n            return false;\\n        }\\n        if(dp[i][j][curr] != -1) return dp[i][j][curr];\\n        int temp;\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\'){\\n            temp = 1;\\n        }else{\\n            temp = -1;\\n        }\\n        \\n        if(isSafe(i+1,j,m,n)){\\n            ans |= solve(grid,i+1,j,curr+temp,dp);\\n        }\\n        if(isSafe(i,j+1,m,n)){\\n            ans |= solve(grid,i,j+1,curr+temp,dp);\\n        }\\n        return dp[i][j][curr] = ans;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(201,-1)));\\n        return solve(grid,0,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nCode:\\n\\nclass Solution {\\npublic:\\n    bool isSafe(int i,int j,int m,int n){\\n        return i >= 0 and i < m and j >= 0 and j < n;\\n    }\\n    bool solve(vector<vector<char>>& grid,int i,int j,int curr,vector<vector<vector<int>>>&dp){\\n        if(curr < 0) return false;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(i == m-1 and j == n-1){\\n            if(grid[i][j] == \\'(\\'){\\n                curr += 1;\\n            }else{\\n                curr -= 1;\\n            }\\n            if(curr == 0) return true;\\n            return false;\\n        }\\n        if(dp[i][j][curr] != -1) return dp[i][j][curr];\\n        int temp;\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\'){\\n            temp = 1;\\n        }else{\\n            temp = -1;\\n        }\\n        \\n        if(isSafe(i+1,j,m,n)){\\n            ans |= solve(grid,i+1,j,curr+temp,dp);\\n        }\\n        if(isSafe(i,j+1,m,n)){\\n            ans |= solve(grid,i,j+1,curr+temp,dp);\\n        }\\n        return dp[i][j][curr] = ans;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(201,-1)));\\n        return solve(grid,0,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389353,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int n, m;\\n    bool dfs(int x, int y, int open, vector<vector<char>>& grid, vector<vector<vector<int>>> &dp)\\n    {\\n        if(x >= n || y >= m) return false;\\n        if(grid[x][y] == \\'(\\')\\n            open++;\\n        else\\n            open--;\\n        if(open < 0)\\n            return false;\\n        if(dp[x][y][open] != -1)\\n            return dp[x][y][open];\\n        if(x == n-1 && y == m-1)\\n        {\\n            if(open == 0)\\n                return true;\\n            return false;\\n        }\\n        bool val = dfs(x+1, y, open, grid, dp) || dfs(x, y+1, open, grid, dp);\\n        return dp[x][y][open] = val;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>> (m+1, vector<int> (201, -1)));\\n        return dfs(0,0,0,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int n, m;\\n    bool dfs(int x, int y, int open, vector<vector<char>>& grid, vector<vector<vector<int>>> &dp)\\n    {\\n        if(x >= n || y >= m) return false;\\n        if(grid[x][y] == \\'(\\')\\n            open++;\\n        else\\n            open--;\\n        if(open < 0)\\n            return false;\\n        if(dp[x][y][open] != -1)\\n            return dp[x][y][open];\\n        if(x == n-1 && y == m-1)\\n        {\\n            if(open == 0)\\n                return true;\\n            return false;\\n        }\\n        bool val = dfs(x+1, y, open, grid, dp) || dfs(x, y+1, open, grid, dp);\\n        return dp[x][y][open] = val;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>> (m+1, vector<int> (201, -1)));\\n        return dfs(0,0,0,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034492,
                "title": "3d-dp-intuitive-easy-to-understand",
                "content": "**Key Points** - We have to take care of the open parenthesis we are left with till now in our path.\\nSo, for any given indeces i and j we can have atmost n+m open braces i.e, the sum of the matrix dimensions. Whenever we calculate our answer for a given combination of \\'i\\' , \\'j\\' and \\'open\\' (open stands for unclosed brackets we have till now), we store that answer in the dp array.\\n\\nNote :- pls refer the code for more clarity\\n\\n\\n```class Solution {\\npublic:\\n    int t[101][101][201];                              //Dp array \\n    bool helper(vector<vector<char>>& grid,int open,int i,int j)\\n    {\\n        if(i>=grid.size() || j>=grid[0].size())   //Base Case  - out of bound\\n            return false;\\n        \\n        \\n        if(i==grid.size()-1 && j==grid[0].size()-1) // reached the n-1,m-1 cell\\n            {\\n                if(open==1 && grid[i][j]==\\')\\')   // true only if last element is \\'{\\' and number of open brackets left if 1 \\n                    return t[i][j][open]=true;  \\n                else\\n                    return t[i][j][open]=false;      // false otherwise\\n            }\\n        \\n        if(t[i][j][open]!=-1)   // if calculated previously \\n            return t[i][j][open];\\n        \\n        if(grid[i][j]==\\'(\\')  // if we encounter an open bracket\\n        {\\n            return  t[i][j][open]=helper(grid,open+1,i+1,j) || helper(grid,open+1,i,j+1);  // moving down and right\\n        }\\n        else     // if we encounter an open bracket\\n        {\\n            if(open<=0)                          //when closing bracket is encountered without any previous open bracket\\n                return t[i][j][open]=false;\\n                                                                                   // open count will decrease when closed bracket is encountered\\n                return t[i][j][open]=helper(grid,open-1,i+1,j) || helper(grid,open-1,i,j+1);   // moving down and right\\n        }\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(t,-1,sizeof(t));               // intializing the dp array\\n        return helper(grid,0,0,0);           // initially  i=0 , j=0 i.e; starting point and open is also 0\\n    }\\n};```\\n\\nDo upvote if you found this to be helpful \\uD83D\\uDE0A\\uD83D\\uDE0A.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```class Solution {\\npublic:\\n    int t[101][101][201];                              //Dp array \\n    bool helper(vector<vector<char>>& grid,int open,int i,int j)\\n    {\\n        if(i>=grid.size() || j>=grid[0].size())   //Base Case  - out of bound\\n            return false;\\n        \\n        \\n        if(i==grid.size()-1 && j==grid[0].size()-1) // reached the n-1,m-1 cell\\n            {\\n                if(open==1 && grid[i][j]==\\')\\')   // true only if last element is \\'{\\' and number of open brackets left if 1 \\n                    return t[i][j][open]=true;  \\n                else\\n                    return t[i][j][open]=false;      // false otherwise\\n            }\\n        \\n        if(t[i][j][open]!=-1)   // if calculated previously \\n            return t[i][j][open];\\n        \\n        if(grid[i][j]==\\'(\\')  // if we encounter an open bracket\\n        {\\n            return  t[i][j][open]=helper(grid,open+1,i+1,j) || helper(grid,open+1,i,j+1);  // moving down and right\\n        }\\n        else     // if we encounter an open bracket\\n        {\\n            if(open<=0)                          //when closing bracket is encountered without any previous open bracket\\n                return t[i][j][open]=false;\\n                                                                                   // open count will decrease when closed bracket is encountered\\n                return t[i][j][open]=helper(grid,open-1,i+1,j) || helper(grid,open-1,i,j+1);   // moving down and right\\n        }\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(t,-1,sizeof(t));               // intializing the dp array\\n        return helper(grid,0,0,0);           // initially  i=0 , j=0 i.e; starting point and open is also 0\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2020540,
                "title": "simple-dp-solution-with-c-bitset",
                "content": "At dp[i][j] we count how many excess open parenthesis we have till ```i,j``` (>= 0, negative means that particular path can be ignored from now on).  Now, at ```i,j``` if it\\'s open, we increase all counts by 1 (i.e left-shift) otherwise decrease all counts by 1.  \\nC++ bitset<201> can simulate this directly. increase can be left-shift etc.\\n```\\ntypedef bitset<201> sp;\\ntypedef vector<sp> vsp;\\ntypedef vector<vsp> vvsp;\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vvsp dp = vvsp(m, vsp(n, sp()));\\n        dp[0][0] = grid[0][0] == \\'(\\';\\n        for (int i=0;i<m;++i) for (int j=0;j<n;++j) {\\n            dp[i][j] = dp[i][j] | (j ? dp[i][j-1] : 0) | (i ? dp[i-1][j] : 0 );\\n            if (grid[i][j] == \\'(\\') dp[i][j] <<= 1;\\n            else dp[i][j] >>= 1;\\n        }\\n        return dp.back().back().test(0) > 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```i,j```\n```i,j```\n```\\ntypedef bitset<201> sp;\\ntypedef vector<sp> vsp;\\ntypedef vector<vsp> vvsp;\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vvsp dp = vvsp(m, vsp(n, sp()));\\n        dp[0][0] = grid[0][0] == \\'(\\';\\n        for (int i=0;i<m;++i) for (int j=0;j<n;++j) {\\n            dp[i][j] = dp[i][j] | (j ? dp[i][j-1] : 0) | (i ? dp[i-1][j] : 0 );\\n            if (grid[i][j] == \\'(\\') dp[i][j] <<= 1;\\n            else dp[i][j] >>= 1;\\n        }\\n        return dp.back().back().test(0) > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019994,
                "title": "fully-explained-recursion-memoization-cpp",
                "content": "we can solve this question easily by taking \\'(\\' as +1 and \\')\\' as -1.Now start adding the cell values in right or down direction and if sum is negative that means it cant be a valid path as it can not be balanced at any condition.\\nNow do a recursion and check if we have already visited this node with th current sum, if yes then return the memoized value otherwise go to the right and down and return OR of both paths.\\nBase condition: if we will reach at the bottom right cell then sum should be 0 for a correct path otherwise the paranthesis must be unbalanced.\\n\\nPFB my code for your reference:)\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int n,int m,int score,vector<vector<int>>& g,vector<vector<vector<int>>>& dp){\\n        if(i>=n || j>=m) return false;\\n        score+=g[i][j];\\n        if(i==n-1 && j==m-1) return score==0;\\n        if(score<0) return false;\\n        if(dp[i][j][score] != -1) return dp[i][j][score];\\n        return dp[i][j][score]=dfs(i+1,j,n,m,score,g,dp) || dfs(i,j+1,n,m,score,g,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        if((n+m-1)&1) return false;\\n        vector<vector<int>> g(n,vector<int>(m,-1));\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(n+m+5,-1)));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid[i][j]==\\'(\\') g[i][j]=1;\\n        return dfs(0,0,n,m,0,g,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int n,int m,int score,vector<vector<int>>& g,vector<vector<vector<int>>>& dp){\\n        if(i>=n || j>=m) return false;\\n        score+=g[i][j];\\n        if(i==n-1 && j==m-1) return score==0;\\n        if(score<0) return false;\\n        if(dp[i][j][score] != -1) return dp[i][j][score];\\n        return dp[i][j][score]=dfs(i+1,j,n,m,score,g,dp) || dfs(i,j+1,n,m,score,g,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        if((n+m-1)&1) return false;\\n        vector<vector<int>> g(n,vector<int>(m,-1));\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(n+m+5,-1)));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid[i][j]==\\'(\\') g[i][j]=1;\\n        return dfs(0,0,n,m,0,g,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019857,
                "title": "c-solution-with-visitedflag-array",
                "content": "\\tpublic class Solution {\\n\\n\\t\\tprivate bool[,,] _visited;\\n\\t\\tprivate int _rowLength;\\n\\t\\tprivate int _colLength;\\n\\t\\tprivate int _midLength;\\n\\t\\tprivate char[][] _grid;\\n\\n\\t\\tpublic bool ValidPath(int row, int col,int bal){\\n\\t\\t\\tbal += _grid[row][col]==\\'(\\'?1:-1;\\n\\t\\t\\tif(bal < 0 || bal > _midLength || _visited[row,col,bal])\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t_visited[row,col,bal]=true;\\n\\t\\t\\tif(row == _rowLength-1 && col == _colLength-1){\\n\\t\\t\\t\\tif(bal == 0)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(row<_rowLength-1 && ValidPath(row+1,col,bal))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif(col<_colLength-1 && ValidPath(row,col+1,bal))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tpublic bool HasValidPath(char[][] grid) {\\n\\t\\t\\t_rowLength = grid.Length;\\n\\t\\t\\t_colLength = grid[0].Length;\\n\\t\\t\\t_midLength = (_rowLength+_colLength)/2;\\n\\t\\t\\t_visited = new bool[_rowLength,_colLength,_midLength+1];\\n\\t\\t\\t_grid = grid;\\n\\n\\t\\t\\treturn ValidPath(0,0,0);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\t\\tprivate bool[,,] _visited;\\n\\t\\tprivate int _rowLength;\\n\\t\\tprivate int _colLength;\\n\\t\\tprivate int _midLength;\\n\\t\\tprivate char[][] _grid;\\n\\n\\t\\tpublic bool ValidPath(int row, int col,int bal){\\n\\t\\t\\tbal += _grid[row][col]==\\'(\\'?1:-1;\\n\\t\\t\\tif(bal < 0 || bal > _midLength || _visited[row,col,bal])\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t_visited[row,col,bal]=true;\\n\\t\\t\\tif(row == _rowLength-1 && col == _colLength-1){\\n\\t\\t\\t\\tif(bal == 0)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2019037,
                "title": "c-solution-dfs-3d-dp-memoization",
                "content": "The approach is based on simple dfs on the given matrix. We start from the very first cell `matrix[0][0]` and consider both the two choices to go right or down from the current cell. On the fly we track the balancing of the parenthesis by taking a variable (Here `s`) and adding one to it if we encounter an opening `\\'(\\'` parentheses and subtracting one from it if we encounter a closing parenthesis `\\')\\'`. \\n\\nOn reaching the last cell i.e., `matrix[n - 1][m - 1]` we check if `s` becomes equal to zero, we found a valid parenthesis string path.\\n\\n```\\nclass Solution {\\npublic:\\n    bool ff(vector<vector<vector<int>>> &dp, int i, int j, int n, int m, int s, vector<vector<char>> &a)\\n    {\\n        if(i == n || j == m || s < 0) return false;\\n        if(i == n - 1 && j == m - 1) \\n        {\\n            int sum = (a[i][j] == \\'(\\' ? s + 1 : s - 1);\\n            return (sum == 0);\\n        }\\n        if(dp[i][j][s] != -1) return dp[i][j][s];\\n        // Go Down\\n        if(ff(dp, i + 1, j, n, m, ((a[i][j] == \\'(\\') ? s + 1 : s - 1), a)) return dp[i][j][s] = true;\\n        // Go Right\\n        if(ff(dp, i, j + 1, n, m, ((a[i][j] == \\'(\\') ? s + 1 : s - 1), a)) return dp[i][j][s] = true;\\n        return dp[i][j][s] = false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& a) \\n    {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (m, vector<int> (n + m + 2, -1)));\\n        return ff(dp, 0, 0, n, m, 0, a);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ff(vector<vector<vector<int>>> &dp, int i, int j, int n, int m, int s, vector<vector<char>> &a)\\n    {\\n        if(i == n || j == m || s < 0) return false;\\n        if(i == n - 1 && j == m - 1) \\n        {\\n            int sum = (a[i][j] == \\'(\\' ? s + 1 : s - 1);\\n            return (sum == 0);\\n        }\\n        if(dp[i][j][s] != -1) return dp[i][j][s];\\n        // Go Down\\n        if(ff(dp, i + 1, j, n, m, ((a[i][j] == \\'(\\') ? s + 1 : s - 1), a)) return dp[i][j][s] = true;\\n        // Go Right\\n        if(ff(dp, i, j + 1, n, m, ((a[i][j] == \\'(\\') ? s + 1 : s - 1), a)) return dp[i][j][s] = true;\\n        return dp[i][j][s] = false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& a) \\n    {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (m, vector<int> (n + m + 2, -1)));\\n        return ff(dp, 0, 0, n, m, 0, a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018216,
                "title": "python-3-pruned-bfs-with-memo-counting-brackets",
                "content": "**BFS solution with count open bracket and closing bracket**\\n\\nFalse case + pruning case to skip the addition to the queue\\n- if starting with close bracket -> False\\n- if ending with open bracket -> False\\n- if memo at the current position has less number of open bracket, no need to check as both path will end up same result -> skip\\n- if current number of unmatched open bracket has more then the steps left to the target -> this path is invalid -> skip\\n- We can\\'t have closing bracket when current path has no open bracket left to be matched -> skip\\n- if we didn\\'t find the answer until try all the path -> False\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        rLen, cLen = len(grid), len(grid[0])\\n        direc = [(1, 0), (0, 1)]\\n        q = deque()\\n        maxStep = rLen + cLen - 2\\n        visited = {}\\n        \\n        # starting with closing bracket = invalid parentheses return False\\n        if grid[0][0] == \\')\\':\\n            return False\\n        # can\\'t end with closing bracket\\n        elif grid[rLen - 1][cLen - 1] == \\'(\\':\\n            return False\\n        elif grid[0][0] == \\'(\\':\\n            q.append((0, 0, 1))\\n        \\n        while q:\\n            currR, currC, currCount = q.popleft()\\n            # memo skip if currCount > then previous as we will find answer anyways\\n            if (currR, currC) in visited:\\n                if visited[(currR, currC)] <= currCount:\\n                    continue\\n            visited[(currR, currC)] = currCount\\n            # if curr number of open count has more than possible steps left to target then skip\\n            if (maxStep - currR + currC) < currCount:\\n                continue\\n            # reach to target? -> make sure our count == 0 and return True\\n            if currR == rLen - 1 and currC == cLen - 1:\\n                if currCount == 0:\\n                    return True\\n            for dr, dc in direc:\\n                newR, newC = currR + dr, currC + dc\\n                if newR < rLen and newC < cLen:\\n                    if grid[newR][newC] == \\'(\\':\\n                        q.append((newR, newC, currCount + 1))\\n                    elif grid[newR][newC] == \\')\\':\\n                        # if currCount is 0 then we can\\'t take path with closing bracket\\n                        if currCount > 0:\\n                            q.append((newR, newC, currCount - 1))\\n        # we didnt find solution for all possible path return False\\n        return False\\n```\\n\\n**Please UPVOTE if you find this solution helpful !\\nHappy algo!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        rLen, cLen = len(grid), len(grid[0])\\n        direc = [(1, 0), (0, 1)]\\n        q = deque()\\n        maxStep = rLen + cLen - 2\\n        visited = {}\\n        \\n        # starting with closing bracket = invalid parentheses return False\\n        if grid[0][0] == \\')\\':\\n            return False\\n        # can\\'t end with closing bracket\\n        elif grid[rLen - 1][cLen - 1] == \\'(\\':\\n            return False\\n        elif grid[0][0] == \\'(\\':\\n            q.append((0, 0, 1))\\n        \\n        while q:\\n            currR, currC, currCount = q.popleft()\\n            # memo skip if currCount > then previous as we will find answer anyways\\n            if (currR, currC) in visited:\\n                if visited[(currR, currC)] <= currCount:\\n                    continue\\n            visited[(currR, currC)] = currCount\\n            # if curr number of open count has more than possible steps left to target then skip\\n            if (maxStep - currR + currC) < currCount:\\n                continue\\n            # reach to target? -> make sure our count == 0 and return True\\n            if currR == rLen - 1 and currC == cLen - 1:\\n                if currCount == 0:\\n                    return True\\n            for dr, dc in direc:\\n                newR, newC = currR + dr, currC + dc\\n                if newR < rLen and newC < cLen:\\n                    if grid[newR][newC] == \\'(\\':\\n                        q.append((newR, newC, currCount + 1))\\n                    elif grid[newR][newC] == \\')\\':\\n                        # if currCount is 0 then we can\\'t take path with closing bracket\\n                        if currCount > 0:\\n                            q.append((newR, newC, currCount - 1))\\n        # we didnt find solution for all possible path return False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018050,
                "title": "dfs-3-d-dp-memoization",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL**\\n\\n```\\nclass Solution {\\n    bool f=0;\\n    int c=0;\\n    //int dp[101][101][201];\\n    bool dfs(vector<vector<char>>& grid,int i,int j,int &n,int &m, vector<vector<vector<int>>>& dp)\\n    {\\n        if(f)return 1;\\n        if(i>=n||j>=m)return 0;\\n        \\n        if(i==n-1&&j==m-1)\\n        {\\n            if(c==1){f=1;return 1;}\\n            return 0;\\n        }\\n        \\n        if(dp[i][j][c]!=-1)\\n            return dp[i][j][c];\\n        \\n        if(grid[i][j]==\\'(\\')\\n            c++;\\n        else\\n        {\\n            if(c)c--;\\n            else\\n                return 0;\\n        }\\n        \\n        bool flag=0;\\n        flag|=dfs(grid,i+1,j,n,m,dp);\\n        flag|=dfs(grid,i,j+1,n,m,dp);\\n        \\n        c=grid[i][j]==\\'(\\'?c-1:c+1;\\n        return dp[i][j][c]=flag?1:0;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        int n=grid.size(),m=grid[0].size();\\n        if(grid[0][0]==\\')\\'||grid[n-1][m-1]==\\'(\\')return 0;\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(m+n-1,-1)));\\n        return dfs(grid,0,0,n,m,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool f=0;\\n    int c=0;\\n    //int dp[101][101][201];\\n    bool dfs(vector<vector<char>>& grid,int i,int j,int &n,int &m, vector<vector<vector<int>>>& dp)\\n    {\\n        if(f)return 1;\\n        if(i>=n||j>=m)return 0;\\n        \\n        if(i==n-1&&j==m-1)\\n        {\\n            if(c==1){f=1;return 1;}\\n            return 0;\\n        }\\n        \\n        if(dp[i][j][c]!=-1)\\n            return dp[i][j][c];\\n        \\n        if(grid[i][j]==\\'(\\')\\n            c++;\\n        else\\n        {\\n            if(c)c--;\\n            else\\n                return 0;\\n        }\\n        \\n        bool flag=0;\\n        flag|=dfs(grid,i+1,j,n,m,dp);\\n        flag|=dfs(grid,i,j+1,n,m,dp);\\n        \\n        c=grid[i][j]==\\'(\\'?c-1:c+1;\\n        return dp[i][j][c]=flag?1:0;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        int n=grid.size(),m=grid[0].size();\\n        if(grid[0][0]==\\')\\'||grid[n-1][m-1]==\\'(\\')return 0;\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(m+n-1,-1)));\\n        return dfs(grid,0,0,n,m,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017898,
                "title": "c-hashset-dp-w-crappy-image-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/c8a67b6a-e11b-420d-94e2-eef687da5e05_1651983094.751082.png)\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if (grid[m-1][n-1] == \\'(\\' || (m+n)%2 == 0)\\n            return false;\\n        vector<vector<unordered_set<int>>> dp(m+1, vector<unordered_set<int>>(n+1));\\n        dp[m][n-1].insert(0);\\n        dp[m-1][n].insert(0);\\n        for (int i = m-1; i >= 0; --i) {\\n            for (int j = n-1; j >= 0; --j) {\\n                int p = (grid[i][j] == \\')\\') ? 1 : -1;\\n                for (int v: dp[i+1][j]) {\\n                    v += p;\\n                    if (v >= 0)\\n                        dp[i][j].insert(v);\\n                }\\n                for (int v: dp[i][j+1]) {\\n                    v += p;\\n                    if (v >= 0)\\n                        dp[i][j].insert(v);\\n                }\\n            }\\n        }\\n        return dp[0][0].find(0) != dp[0][0].end();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if (grid[m-1][n-1] == \\'(\\' || (m+n)%2 == 0)\\n            return false;\\n        vector<vector<unordered_set<int>>> dp(m+1, vector<unordered_set<int>>(n+1));\\n        dp[m][n-1].insert(0);\\n        dp[m-1][n].insert(0);\\n        for (int i = m-1; i >= 0; --i) {\\n            for (int j = n-1; j >= 0; --j) {\\n                int p = (grid[i][j] == \\')\\') ? 1 : -1;\\n                for (int v: dp[i+1][j]) {\\n                    v += p;\\n                    if (v >= 0)\\n                        dp[i][j].insert(v);\\n                }\\n                for (int v: dp[i][j+1]) {\\n                    v += p;\\n                    if (v >= 0)\\n                        dp[i][j].insert(v);\\n                }\\n            }\\n        }\\n        return dp[0][0].find(0) != dp[0][0].end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017736,
                "title": "cpp-dfs-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<vector<int>>> dp;\\n    bool dfs(int i,int j,vector<vector<char>>& g,int cnt){     // cnt = number of opening brackets remaining\\n        if(i<0 || j<0 || i>=n || j>=m) return 0;\\n        \\n        if(dp[i][j][cnt]!=-1) return dp[i][j][cnt];\\n        \\n        if(i==n-1 && j==m-1){\\n            if(g[i][j]==\\'(\\') cnt++;\\n            else cnt--;\\n            \\n            if(cnt<0) return 0;\\n            if(cnt==0) return 1;\\n            \\n            return dp[i][j][cnt] = 0;\\n        }\\n        \\n        if(g[i][j] == \\'(\\'){\\n            if(dfs(i+1,j,g,cnt+1)) return 1;\\n            if(dfs(i,j+1,g,cnt+1)) return 1;\\n        }\\n        else{\\n            if(cnt == 0) return dp[i][j][cnt] = 0;\\n            if(dfs(i+1,j,g,cnt-1)) return 1;\\n            if(dfs(i,j+1,g,cnt-1)) return 1;\\n        }\\n        \\n        return dp[i][j][cnt]=0;\\n    }\\n\\t\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        n = g.size(), m = g[0].size();\\n        dp = vector<vector<vector<int>>>(n,vector<vector<int>>(m,vector<int>(m+n+1,-1)));\\n        return dfs(0,0,g,0);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int n,m;\\n    vector<vector<vector<int>>> dp;\\n    bool dfs(int i,int j,vector<vector<char>>& g,int cnt){     // cnt = number of opening brackets remaining\\n        if(i<0 || j<0 || i>=n || j>=m) return 0;\\n        \\n        if(dp[i][j][cnt]!=-1) return dp[i][j][cnt];\\n        \\n        if(i==n-1 && j==m-1){\\n            if(g[i][j]==\\'(\\') cnt++;\\n            else cnt--;\\n            \\n            if(cnt<0) return 0;\\n            if(cnt==0) return 1;\\n            \\n            return dp[i][j][cnt] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3724881,
                "title": "3-d-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int r, int c, int count, vector<vector<char>> &grid, vector<vector<vector<int>>> &dp)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    if (r == n - 1 and c == m - 1)\\n    {\\n        return count == 1;\\n    }\\n\\n    if (r < 0 or r >= n or c < 0 or c >= m or count < 0 or count > ((m + n) / 2))\\n    {\\n        return false;\\n    }\\n\\n    if (dp[r][c][count] != -1)\\n    {\\n        return dp[r][c][count];\\n    }\\n\\n    int tot = count;\\n    if (grid[r][c] == \\'(\\')\\n    {\\n        tot++;\\n    }\\n    else\\n    {\\n        tot--;\\n    }\\n\\n    bool right = solve(r, c + 1, tot, grid, dp);\\n    bool down = solve(r + 1, c, tot, grid, dp);\\n\\n    return dp[r][c][count] = right or down;\\n}\\n\\nbool hasValidPath(vector<vector<char>> &grid)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    if (n % 2 == m % 2)\\n    {\\n        return false;\\n    }\\n    if (grid[0][0] == \\')\\' or grid[n - 1][m - 1] == \\'(\\')\\n    {\\n        return false;\\n    }\\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(((m + n) / 2) + 1, -1)));\\n\\n    return solve(0, 0, 0, grid, dp);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int r, int c, int count, vector<vector<char>> &grid, vector<vector<vector<int>>> &dp)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    if (r == n - 1 and c == m - 1)\\n    {\\n        return count == 1;\\n    }\\n\\n    if (r < 0 or r >= n or c < 0 or c >= m or count < 0 or count > ((m + n) / 2))\\n    {\\n        return false;\\n    }\\n\\n    if (dp[r][c][count] != -1)\\n    {\\n        return dp[r][c][count];\\n    }\\n\\n    int tot = count;\\n    if (grid[r][c] == \\'(\\')\\n    {\\n        tot++;\\n    }\\n    else\\n    {\\n        tot--;\\n    }\\n\\n    bool right = solve(r, c + 1, tot, grid, dp);\\n    bool down = solve(r + 1, c, tot, grid, dp);\\n\\n    return dp[r][c][count] = right or down;\\n}\\n\\nbool hasValidPath(vector<vector<char>> &grid)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    if (n % 2 == m % 2)\\n    {\\n        return false;\\n    }\\n    if (grid[0][0] == \\')\\' or grid[n - 1][m - 1] == \\'(\\')\\n    {\\n        return false;\\n    }\\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(((m + n) / 2) + 1, -1)));\\n\\n    return solve(0, 0, 0, grid, dp);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434922,
                "title": "100-faster-using-recursion-3d-dp-dp-row-column-count-of",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool helper(int i, int j, int count, vector<vector<char>>& grid,  vector< vector< vector<int> > > &dp) {\\n        if(i == grid.size() || j == grid[0].size()) return false;\\n        if(i == grid.size() -1 && j == grid[0].size() - 1) {\\n            if(grid[i][j] == \\'(\\') return false;\\n            return count - 1 == 0;\\n        }\\n        if(dp[i][j][count] != -1) return dp[i][j][count];\\n\\n        if(grid[i][j] == \\'(\\') {\\n            return dp[i][j][count] = helper(i+1, j, count+1, grid, dp) || helper(i, j+1, count+1, grid, dp);\\n        }\\n        if(count > 0) return dp[i][j][count] = helper(i+1, j, count-1, grid, dp) || helper(i, j+1, count-1, grid, dp);\\n\\n        return dp[i][j][count] =false;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector< vector< vector<int> > > dp(grid.size(), vector< vector< int > > (grid[0].size(), vector< int > (grid.size()+grid[0].size(), -1)));\\n        return helper(0, 0, 0, grid, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(int i, int j, int count, vector<vector<char>>& grid,  vector< vector< vector<int> > > &dp) {\\n        if(i == grid.size() || j == grid[0].size()) return false;\\n        if(i == grid.size() -1 && j == grid[0].size() - 1) {\\n            if(grid[i][j] == \\'(\\') return false;\\n            return count - 1 == 0;\\n        }\\n        if(dp[i][j][count] != -1) return dp[i][j][count];\\n\\n        if(grid[i][j] == \\'(\\') {\\n            return dp[i][j][count] = helper(i+1, j, count+1, grid, dp) || helper(i, j+1, count+1, grid, dp);\\n        }\\n        if(count > 0) return dp[i][j][count] = helper(i+1, j, count-1, grid, dp) || helper(i, j+1, count-1, grid, dp);\\n\\n        return dp[i][j][count] =false;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector< vector< vector<int> > > dp(grid.size(), vector< vector< int > > (grid[0].size(), vector< int > (grid.size()+grid[0].size(), -1)));\\n        return helper(0, 0, 0, grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353083,
                "title": "2d-dp-solution-in-java",
                "content": "### Approach\\nThe approach used in the given code is to solve the problem using dynamic programming. The idea is to create a 2D array called dp, where each cell stores the set of possible balance values at that position. We start by initializing the set at the top-left cell with the value 1 if the path starts with a \\'(\\' character.\\n\\nThen, we iterate over each cell of the dp array and update the set of balances at each cell based on the direction of the paths. For each neighboring cell, we check the set of possible balances at that cell and add or subtract 1 to get the new balance value. We then add the new balance value to the set of balances at the current cell if it is non-negative.\\n\\nFinally, we check if the set of balances at the bottom-right cell of the dp array contains 0, which means that there exists a path from the top-left cell to the bottom-right cell with a balanced set of parentheses. If the set contains 0, we return `true`. Otherwise, we return `false`.\\n\\n# Complexity\\n- Time complexity: $$O(mn(m+n))$$\\n- Space complexity: $$O(mn)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] path = new int[][]{{-1, 0}, {0, -1}};\\n\\n        Set<Integer>[][] dp = new HashSet[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = new HashSet<>();\\n            }\\n        }\\n\\n        if (grid[0][0] == \\'(\\') dp[0][0].add(1);\\n\\n        /*This is the main logic of the program. \\n        \\n        We iterate over each cell of the dp array and calculate the balance of \\n        the parentheses at that cell.The variable cur is set to 1 if the current cell\\n        contains an open parenthesis, and -1 otherwise.*/\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n                for (int[] d : path) {\\n                    int x = i + d[0], y = j + d[1];\\n                    if (x < 0 || y < 0) continue;\\n\\n                    for (int bal : dp[x][y]) {\\n                        bal += cur;\\n                        if (bal < 0) continue;\\n                        dp[i][j].add(bal);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1].contains(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] path = new int[][]{{-1, 0}, {0, -1}};\\n\\n        Set<Integer>[][] dp = new HashSet[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = new HashSet<>();\\n            }\\n        }\\n\\n        if (grid[0][0] == \\'(\\') dp[0][0].add(1);\\n\\n        /*This is the main logic of the program. \\n        \\n        We iterate over each cell of the dp array and calculate the balance of \\n        the parentheses at that cell.The variable cur is set to 1 if the current cell\\n        contains an open parenthesis, and -1 otherwise.*/\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n                for (int[] d : path) {\\n                    int x = i + d[0], y = j + d[1];\\n                    if (x < 0 || y < 0) continue;\\n\\n                    for (int bal : dp[x][y]) {\\n                        bal += cur;\\n                        if (bal < 0) continue;\\n                        dp[i][j].add(bal);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1].contains(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731709,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool hasValidPath(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), maxk = (m + n + 1) / 2;\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(maxk + 10)));\\n        dp[0][0][1] = 1;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= maxk; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool hasValidPath(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), maxk = (m + n + 1) / 2;\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(maxk + 10)));\\n        dp[0][0][1] = 1;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= maxk; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263853,
                "title": "c-memomization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool f(vector<vector<char>>&g,int i,int j,int st,vector<vector<vector<int>>>&dp)\\n    { \\n        if(i==0&&j==0)\\n        {\\n            if(st==1)\\n            {\\n                if(g[i][j]==\\'(\\')\\n                    return true;\\n                else\\n                    return false;\\n            }\\n            else\\n                return false;\\n        }\\n        if(i<0||j<0)\\n        {\\n          return false;\\n        }   \\n        if(g[i][j]==\\')\\')\\n            st+=1;\\n        else\\n        {\\n           if(st==0)\\n               return dp[i][j][st]=false;\\n           else\\n               st--;\\n        }\\n        if(dp[i][j][st]!=-1)\\n            return dp[i][j][st];\\n        return dp[i][j][st]=f(g,i-1,j,st,dp)||f(g,i,j-1,st,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>&g) {\\n        int st=0;\\n        vector<vector<vector<int>>>dp(g.size()+1,vector<vector<int>>(g[0].size()+1,vector<int>(g.size()+g[0].size()+2,-1)));\\n        return f(g,g.size()-1,g[0].size()-1,st,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<vector<char>>&g,int i,int j,int st,vector<vector<vector<int>>>&dp)\\n    { \\n        if(i==0&&j==0)\\n        {\\n            if(st==1)\\n            {\\n                if(g[i][j]==\\'(\\')\\n                    return true;\\n                else\\n                    return false;\\n            }\\n            else\\n                return false;\\n        }\\n        if(i<0||j<0)\\n        {\\n          return false;\\n        }   \\n        if(g[i][j]==\\')\\')\\n            st+=1;\\n        else\\n        {\\n           if(st==0)\\n               return dp[i][j][st]=false;\\n           else\\n               st--;\\n        }\\n        if(dp[i][j][st]!=-1)\\n            return dp[i][j][st];\\n        return dp[i][j][st]=f(g,i-1,j,st,dp)||f(g,i,j-1,st,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>&g) {\\n        int st=0;\\n        vector<vector<vector<int>>>dp(g.size()+1,vector<vector<int>>(g[0].size()+1,vector<int>(g.size()+g[0].size()+2,-1)));\\n        return f(g,g.size()-1,g[0].size()-1,st,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162698,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nLet `k` be the amount of open parenthesis `\\'(\\'` *not* paired with a close parenthesis `\\')\\'` on the path from the top-left cell `0`,`0` ending at cell `i`,`j`.  Note: `k` must *not* be negative at any point in the path (otherwise there\\'s too many close parenthesis `\\')\\'` for a valid path)\\n\\n**Top-Down:** let `D` and `R` denote adjacent cells \"down\" and \"right\" correspondingly.\\n\\n**Bottom-Up:** let `U` and `L` denote adjacent cells \"up\" and \"left\" correspondingly, let `dp[i][j]` denote the set of all `k` possibilities of open parenthesis `\\'(\\'` for paths ending at cell `i`,`j`.  And we formulate the future from the past by considering all `k` candidates `cands`. \\n\\n---\\n\\n**Kotlin Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        fun go(i: Int = 0, j: Int = 0, k_: Int = 0): Boolean {\\n            if (i == M || j == N)\\n                return false\\n            var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n            if (k < 0)\\n                return false\\n            if (i == M - 1 && j == N - 1)\\n                return k == 0\\n            var D = go(i + 1, j, k)\\n            var R = go(i, j + 1, k)\\n            return D || R\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        var m = mutableMapOf<String, Boolean>()\\n        fun go(i: Int = 0, j: Int = 0, k_: Int = 0): Boolean {\\n            if (i == M || j == N)\\n                return false\\n            var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n            if (k < 0)\\n                return false\\n            if (i == M - 1 && j == N - 1)\\n                return k == 0\\n            var key = \"$i,$j,$k\"\\n            if (!m.contains(key)) {\\n                var D = go(i + 1, j, k)\\n                var R = go(i, j + 1, k)\\n                m[key] = D || R\\n            }\\n            return m[key]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        var dp = Array(M) { Array(N) { mutableSetOf<Int>() } }\\n        if (A[0][0] == \\'(\\')\\n            dp[0][0].add(1)\\n        for (i in 0 until M) {\\n            for (j in 0 until N) {\\n                var U = if (0 <= i - 1) dp[i - 1][j] else mutableSetOf<Int>()\\n                var L = if (0 <= j - 1) dp[i][j - 1] else mutableSetOf<Int>()\\n                var cands = U union L\\n                for (k_ in cands) {\\n                    var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n                    if (0 <= k)\\n                        dp[i][j].add(k)\\n                }\\n            }\\n        }\\n        return dp[M - 1][N - 1].contains(0)\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet hasValidPath = A => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let go = (i = 0, j = 0, k = 0) => {\\n        if (i == M || j == N)\\n            return false;\\n        k += A[i][j] == \\'(\\' ? 1 : -1;\\n        if (k < 0)\\n            return false;\\n        if (i == M - 1 && j == N - 1)\\n            return !k;\\n        let D = go(i + 1, j, k),\\n            R = go(i, j + 1, k);\\n        return D || R;\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet hasValidPath = (A, m = new Map()) => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let go = (i = 0, j = 0, k = 0) => {\\n        if (i == M || j == N)\\n            return false;\\n        k += A[i][j] == \\'(\\' ? 1 : -1;\\n        if (k < 0)\\n            return false;\\n        if (i == M - 1 && j == N - 1)\\n            return !k;\\n        let key = `${i},${j},${k}`;\\n        if (!m.has(key)) {\\n            let D = go(i + 1, j, k),\\n                R = go(i, j + 1, k);\\n            m.set(key, D || R);\\n        }\\n        return m.get(key);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet hasValidPath = A => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let dp = [...Array(M)].map(_ => [...Array(N)].map(_ => new Set()));\\n    if (A[0][0] == \\'(\\')\\n        dp[0][0].add(1);\\n    for (let i = 0; i < M; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            let U = 0 <= i - 1 ? dp[i - 1][j] : new Set(),\\n                L = 0 <= j - 1 ? dp[i][j - 1] : new Set();\\n            let cands = new Set([...U, ...L]);\\n            for (let k of cands) {\\n                k += A[i][j] == \\'(\\' ? 1 : -1;\\n                if (0 <= k)\\n                    dp[i][j].add(k);\\n            }\\n        }\\n    }\\n    return dp[M - 1][N - 1].has(0);\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        def go(i = 0, j = 0, k = 0):\\n            if i == M or j == N:\\n                return False\\n            k += 1 if A[i][j] == \\'(\\' else -1\\n            if k < 0:\\n                return False\\n            if i == M - 1 and j == N - 1:\\n                return not k\\n            D = go(i + 1, j, k)\\n            R = go(i, j + 1, k)\\n            return D or R\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        @cache\\n        def go(i = 0, j = 0, k = 0):\\n            if i == M or j == N:\\n                return False\\n            k += 1 if A[i][j] == \\'(\\' else -1\\n            if k < 0:\\n                return False\\n            if i == M - 1 and j == N - 1:\\n                return not k\\n            D = go(i + 1, j, k)\\n            R = go(i, j + 1, k)\\n            return D or R\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        dp = [[set() for _ in range(N)] for _ in range(M)]\\n        if A[0][0] == \\'(\\':\\n            dp[0][0].add(1)\\n        for i in range(M):\\n            for j in range(N):\\n                U = dp[i - 1][j] if 0 <= i - 1 else set()\\n                L = dp[i][j - 1] if 0 <= j - 1 else set()\\n                for k in U.union(L):\\n                    k += 1 if A[i][j] == \\'(\\' else -1\\n                    if 0 <= k:\\n                        dp[i][j].add(k)\\n        return 0 in dp[M - 1][N - 1]\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        fn go(A: &VVC, i: usize, j: usize, mut k: i32) -> bool {\\n            if i == A.len() || j == A[0].len() {\\n                return false;\\n            }\\n            k += if A[i][j] == \\'(\\' { 1 } else { -1 };\\n            if k < 0 {\\n                return false;\\n            }\\n            if i == A.len() - 1 && j == A[0].len() - 1 {\\n                return k == 0;\\n            }\\n            let D = go(A, i + 1, j, k);\\n            let R = go(A, i, j + 1, k);\\n            return D || R;\\n        }\\n        go(&A, 0, 0, 0)\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        fn go(A: &VVC, i: usize, j: usize, mut k: i32, m: &mut HashMap::<String, bool>) -> bool {\\n            if i == A.len() || j == A[0].len() {\\n                return false;\\n            }\\n            k += if A[i][j] == \\'(\\' { 1 } else { -1 };\\n            if k < 0 {\\n                return false;\\n            }\\n            if i == A.len() - 1 && j == A[0].len() - 1 {\\n                return k == 0;\\n            }\\n            let key = format!(\"{},{},{}\", i, j, k);\\n            if !m.contains_key(&key) {\\n                let D = go(A, i + 1, j, k, m);\\n                let R = go(A, i, j + 1, k, m);\\n                m.insert(key.clone(), D || R);\\n            }\\n            *m.get(&key).unwrap()\\n        }\\n        let mut m = HashMap::new();\\n        go(&A, 0, 0, 0, &mut m)\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        let M = A.len();\\n        let N = A[0].len();\\n        let mut dp = vec![vec![HashSet::new(); N]; M];\\n        if A[0][0] == \\'(\\' {\\n            dp[0][0].insert(1);\\n        }\\n        for i in 0..M {\\n            for j in 0..N {\\n                let U = if 0 <= i as i32 - 1 { dp[i - 1][j].clone() } else { HashSet::new() };\\n                let L = if 0 <= j as i32 - 1 { dp[i][j - 1].clone() } else { HashSet::new() };\\n                let cands = U.union(&L);\\n                for k_ in cands {\\n                    let k = k_ + if A[i][j] == \\'(\\' { 1 } else { -1 };\\n                    if 0 <= k {\\n                        dp[i][j].insert(k);\\n                    }\\n                }\\n            }\\n        }\\n        dp[M - 1][N - 1].contains(&0)\\n    }\\n}\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<bool(int, int, int)>;\\n    bool hasValidPath(VVC& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun go = [&](auto i, auto j, auto k) {\\n            if (i == M || j == N)\\n                return false;\\n            k += A[i][j] == \\'(\\' ? 1 : -1;\\n            if (k < 0)\\n                return false;\\n            if (i == M - 1 && j == N - 1)\\n                return !k;\\n            auto D = go(i + 1, j, k),\\n                 R = go(i, j + 1, k);\\n            return D || R;\\n        };\\n        return go(0, 0, 0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<bool(int, int, int)>;\\n    using Map = unordered_map<string, bool>;\\n    bool hasValidPath(VVC& A, Map m = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto hash = [](auto i, auto j, auto k) {\\n            stringstream ss; ss << i << \",\" << j << \",\" << k;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j, auto k) {\\n            if (i == M || j == N)\\n                return false;\\n            k += A[i][j] == \\'(\\' ? 1 : -1;\\n            if (k < 0)\\n                return false;\\n            if (i == M - 1 && j == N - 1)\\n                return !k;\\n            auto key = hash(i, j, k);\\n            if (m.find(key) == m.end()) {\\n                auto D = go(i + 1, j, k),\\n                     R = go(i, j + 1, k);\\n                m[key] = D || R;\\n            }\\n            return m[key];\\n        };\\n        return go(0, 0, 0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using Set = unordered_set<int>;\\n    using VS = vector<Set>;\\n    using VVS = vector<VS>;\\n    bool hasValidPath(VVC& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        VVS dp(M, VS(N));\\n        if (A[0][0] == \\'(\\')\\n            dp[0][0].insert(1);\\n        for (auto i{ 0 }; i < M; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                auto U = 0 <= i - 1 ? dp[i - 1][j] : Set{},\\n                     L = 0 <= j - 1 ? dp[i][j - 1] : Set{};\\n                Set cands;\\n                set_union(U.begin(), U.end(),\\n                          L.begin(), L.end(), inserter(cands, cands.end()));\\n                for (auto k: cands) {\\n                    k += A[i][j] == \\'(\\' ? 1 : -1;\\n                    if (0 <= k)\\n                        dp[i][j].insert(k);\\n                }\\n            }\\n        }\\n        return dp[M - 1][N - 1].find(0) != dp[M - 1][N - 1].end();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        fun go(i: Int = 0, j: Int = 0, k_: Int = 0): Boolean {\\n            if (i == M || j == N)\\n                return false\\n            var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n            if (k < 0)\\n                return false\\n            if (i == M - 1 && j == N - 1)\\n                return k == 0\\n            var D = go(i + 1, j, k)\\n            var R = go(i, j + 1, k)\\n            return D || R\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        var m = mutableMapOf<String, Boolean>()\\n        fun go(i: Int = 0, j: Int = 0, k_: Int = 0): Boolean {\\n            if (i == M || j == N)\\n                return false\\n            var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n            if (k < 0)\\n                return false\\n            if (i == M - 1 && j == N - 1)\\n                return k == 0\\n            var key = \"$i,$j,$k\"\\n            if (!m.contains(key)) {\\n                var D = go(i + 1, j, k)\\n                var R = go(i, j + 1, k)\\n                m[key] = D || R\\n            }\\n            return m[key]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        var dp = Array(M) { Array(N) { mutableSetOf<Int>() } }\\n        if (A[0][0] == \\'(\\')\\n            dp[0][0].add(1)\\n        for (i in 0 until M) {\\n            for (j in 0 until N) {\\n                var U = if (0 <= i - 1) dp[i - 1][j] else mutableSetOf<Int>()\\n                var L = if (0 <= j - 1) dp[i][j - 1] else mutableSetOf<Int>()\\n                var cands = U union L\\n                for (k_ in cands) {\\n                    var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n                    if (0 <= k)\\n                        dp[i][j].add(k)\\n                }\\n            }\\n        }\\n        return dp[M - 1][N - 1].contains(0)\\n    }\\n}\\n```\n```\\nlet hasValidPath = A => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let go = (i = 0, j = 0, k = 0) => {\\n        if (i == M || j == N)\\n            return false;\\n        k += A[i][j] == \\'(\\' ? 1 : -1;\\n        if (k < 0)\\n            return false;\\n        if (i == M - 1 && j == N - 1)\\n            return !k;\\n        let D = go(i + 1, j, k),\\n            R = go(i, j + 1, k);\\n        return D || R;\\n    };\\n    return go();\\n};\\n```\n```\\nlet hasValidPath = (A, m = new Map()) => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let go = (i = 0, j = 0, k = 0) => {\\n        if (i == M || j == N)\\n            return false;\\n        k += A[i][j] == \\'(\\' ? 1 : -1;\\n        if (k < 0)\\n            return false;\\n        if (i == M - 1 && j == N - 1)\\n            return !k;\\n        let key = `${i},${j},${k}`;\\n        if (!m.has(key)) {\\n            let D = go(i + 1, j, k),\\n                R = go(i, j + 1, k);\\n            m.set(key, D || R);\\n        }\\n        return m.get(key);\\n    };\\n    return go();\\n};\\n```\n```\\nlet hasValidPath = A => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let dp = [...Array(M)].map(_ => [...Array(N)].map(_ => new Set()));\\n    if (A[0][0] == \\'(\\')\\n        dp[0][0].add(1);\\n    for (let i = 0; i < M; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            let U = 0 <= i - 1 ? dp[i - 1][j] : new Set(),\\n                L = 0 <= j - 1 ? dp[i][j - 1] : new Set();\\n            let cands = new Set([...U, ...L]);\\n            for (let k of cands) {\\n                k += A[i][j] == \\'(\\' ? 1 : -1;\\n                if (0 <= k)\\n                    dp[i][j].add(k);\\n            }\\n        }\\n    }\\n    return dp[M - 1][N - 1].has(0);\\n};\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        def go(i = 0, j = 0, k = 0):\\n            if i == M or j == N:\\n                return False\\n            k += 1 if A[i][j] == \\'(\\' else -1\\n            if k < 0:\\n                return False\\n            if i == M - 1 and j == N - 1:\\n                return not k\\n            D = go(i + 1, j, k)\\n            R = go(i, j + 1, k)\\n            return D or R\\n        return go()\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        @cache\\n        def go(i = 0, j = 0, k = 0):\\n            if i == M or j == N:\\n                return False\\n            k += 1 if A[i][j] == \\'(\\' else -1\\n            if k < 0:\\n                return False\\n            if i == M - 1 and j == N - 1:\\n                return not k\\n            D = go(i + 1, j, k)\\n            R = go(i, j + 1, k)\\n            return D or R\\n        return go()\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        dp = [[set() for _ in range(N)] for _ in range(M)]\\n        if A[0][0] == \\'(\\':\\n            dp[0][0].add(1)\\n        for i in range(M):\\n            for j in range(N):\\n                U = dp[i - 1][j] if 0 <= i - 1 else set()\\n                L = dp[i][j - 1] if 0 <= j - 1 else set()\\n                for k in U.union(L):\\n                    k += 1 if A[i][j] == \\'(\\' else -1\\n                    if 0 <= k:\\n                        dp[i][j].add(k)\\n        return 0 in dp[M - 1][N - 1]\\n```\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        fn go(A: &VVC, i: usize, j: usize, mut k: i32) -> bool {\\n            if i == A.len() || j == A[0].len() {\\n                return false;\\n            }\\n            k += if A[i][j] == \\'(\\' { 1 } else { -1 };\\n            if k < 0 {\\n                return false;\\n            }\\n            if i == A.len() - 1 && j == A[0].len() - 1 {\\n                return k == 0;\\n            }\\n            let D = go(A, i + 1, j, k);\\n            let R = go(A, i, j + 1, k);\\n            return D || R;\\n        }\\n        go(&A, 0, 0, 0)\\n    }\\n}\\n```\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        fn go(A: &VVC, i: usize, j: usize, mut k: i32, m: &mut HashMap::<String, bool>) -> bool {\\n            if i == A.len() || j == A[0].len() {\\n                return false;\\n            }\\n            k += if A[i][j] == \\'(\\' { 1 } else { -1 };\\n            if k < 0 {\\n                return false;\\n            }\\n            if i == A.len() - 1 && j == A[0].len() - 1 {\\n                return k == 0;\\n            }\\n            let key = format!(\"{},{},{}\", i, j, k);\\n            if !m.contains_key(&key) {\\n                let D = go(A, i + 1, j, k, m);\\n                let R = go(A, i, j + 1, k, m);\\n                m.insert(key.clone(), D || R);\\n            }\\n            *m.get(&key).unwrap()\\n        }\\n        let mut m = HashMap::new();\\n        go(&A, 0, 0, 0, &mut m)\\n    }\\n}\\n```\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        let M = A.len();\\n        let N = A[0].len();\\n        let mut dp = vec![vec![HashSet::new(); N]; M];\\n        if A[0][0] == \\'(\\' {\\n            dp[0][0].insert(1);\\n        }\\n        for i in 0..M {\\n            for j in 0..N {\\n                let U = if 0 <= i as i32 - 1 { dp[i - 1][j].clone() } else { HashSet::new() };\\n                let L = if 0 <= j as i32 - 1 { dp[i][j - 1].clone() } else { HashSet::new() };\\n                let cands = U.union(&L);\\n                for k_ in cands {\\n                    let k = k_ + if A[i][j] == \\'(\\' { 1 } else { -1 };\\n                    if 0 <= k {\\n                        dp[i][j].insert(k);\\n                    }\\n                }\\n            }\\n        }\\n        dp[M - 1][N - 1].contains(&0)\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<bool(int, int, int)>;\\n    bool hasValidPath(VVC& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun go = [&](auto i, auto j, auto k) {\\n            if (i == M || j == N)\\n                return false;\\n            k += A[i][j] == \\'(\\' ? 1 : -1;\\n            if (k < 0)\\n                return false;\\n            if (i == M - 1 && j == N - 1)\\n                return !k;\\n            auto D = go(i + 1, j, k),\\n                 R = go(i, j + 1, k);\\n            return D || R;\\n        };\\n        return go(0, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<bool(int, int, int)>;\\n    using Map = unordered_map<string, bool>;\\n    bool hasValidPath(VVC& A, Map m = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto hash = [](auto i, auto j, auto k) {\\n            stringstream ss; ss << i << \",\" << j << \",\" << k;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j, auto k) {\\n            if (i == M || j == N)\\n                return false;\\n            k += A[i][j] == \\'(\\' ? 1 : -1;\\n            if (k < 0)\\n                return false;\\n            if (i == M - 1 && j == N - 1)\\n                return !k;\\n            auto key = hash(i, j, k);\\n            if (m.find(key) == m.end()) {\\n                auto D = go(i + 1, j, k),\\n                     R = go(i, j + 1, k);\\n                m[key] = D || R;\\n            }\\n            return m[key];\\n        };\\n        return go(0, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using Set = unordered_set<int>;\\n    using VS = vector<Set>;\\n    using VVS = vector<VS>;\\n    bool hasValidPath(VVC& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        VVS dp(M, VS(N));\\n        if (A[0][0] == \\'(\\')\\n            dp[0][0].insert(1);\\n        for (auto i{ 0 }; i < M; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                auto U = 0 <= i - 1 ? dp[i - 1][j] : Set{},\\n                     L = 0 <= j - 1 ? dp[i][j - 1] : Set{};\\n                Set cands;\\n                set_union(U.begin(), U.end(),\\n                          L.begin(), L.end(), inserter(cands, cands.end()));\\n                for (auto k: cands) {\\n                    k += A[i][j] == \\'(\\' ? 1 : -1;\\n                    if (0 <= k)\\n                        dp[i][j].insert(k);\\n                }\\n            }\\n        }\\n        return dp[M - 1][N - 1].find(0) != dp[M - 1][N - 1].end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136427,
                "title": "c-easy-to-understand-dp-code-3d-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<vector<char>> &grid,int i,int j,int n,int m,vector<vector<vector<int>>> &dp,int count)\\n    {\\n        if(i>=n||j>=m)\\n        {\\n            return false;\\n        }\\n        if(count>(n+m)/2)\\n        {\\n            return dp[i][j][count]=false;\\n        }\\n        if(grid[i][j]==\\'(\\')\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            count--;\\n        }\\n        if(count<0)\\n        {\\n            return false;\\n        }\\n        if(dp[i][j][count]!=-1)\\n        {\\n            return dp[i][j][count];\\n        }\\n        if(i==n-1&&j==m-1&&count==0)\\n        {\\n            return dp[i][j][count]=true;\\n        }\\n        bool ans=false;\\n        if(solve(grid,i+1,j,n,m,dp,count)||solve(grid,i,j+1,n,m,dp,count))\\n        {\\n            ans=true;\\n        }\\n        return dp[i][j][count]=ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(m+1,vector<int>(202,-1)));\\n        return solve(grid,0,0,n,m,dp,0);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<vector<char>> &grid,int i,int j,int n,int m,vector<vector<vector<int>>> &dp,int count)\\n    {\\n        if(i>=n||j>=m)\\n        {\\n            return false;\\n        }\\n        if(count>(n+m)/2)\\n        {\\n            return dp[i][j][count]=false;\\n        }\\n        if(grid[i][j]==\\'(\\')\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            count--;\\n        }\\n        if(count<0)\\n        {\\n            return false;\\n        }\\n        if(dp[i][j][count]!=-1)\\n        {\\n            return dp[i][j][count];\\n        }\\n        if(i==n-1&&j==m-1&&count==0)\\n        {\\n            return dp[i][j][count]=true;\\n        }\\n        bool ans=false;\\n        if(solve(grid,i+1,j,n,m,dp,count)||solve(grid,i,j+1,n,m,dp,count))\\n        {\\n            ans=true;\\n        }\\n        return dp[i][j][count]=ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(m+1,vector<int>(202,-1)));\\n        return solve(grid,0,0,n,m,dp,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128202,
                "title": "c-simple-and-correct-solution-dp",
                "content": "**r :- rows, c :- columns, o :- number of opening brackets**\\nwhen we reach at the last index i.e (grid[m-1][n-1]) ,after following the path we check that \\n1- there should be closed bracket in cell [m-1][n-1].\\n2 - after reaching the last cell there should only be 1 opening bracket left that will be balanced by the closed bracket in the last cell.\\nif this 2 condition are true the we store true.\\n\\nFor optimization we use memoization to store the state of the recursion.\\n\\n**If you liked the solution . please upvote!!!** \\uD83D\\uDE0E\\n\\n\\tclass Solution {\\n\\tpublic:\\n    bool ans= false;\\n    int t[101][101][1001];\\n    void solve(vector<vector<char>>& g,int r,int c,int o)\\n    {\\n        if(t[r][c][o]!=0)\\n            return;\\n        if(r>g.size()-1||c>g[0].size()-1)\\n            return;\\n        if(r==g.size()-1&&c==g[0].size()-1)\\n        {\\n            if(g[r][c]==\\')\\'&& o==1)\\n                ans=true;\\n            return;\\n        }\\n            if(g[r][c]==\\'(\\')\\n            {\\n                int t = o+1;\\n                solve(g,r,c+1,t);\\n                solve(g,r+1,c,t);\\n            }\\n            else if(o>0 && g[r][c]==\\')\\')\\n            {\\n                int t = o-1;\\n                solve(g,r,c+1,t);\\n                solve(g,r+1,c,t);\\n            }\\n        t[r][c][o] = 1;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(t,0,sizeof(t));\\n        solve(grid,0,0,0);\\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool ans= false;\\n    int t[101][101][1001];\\n    void solve(vector<vector<char>>& g,int r,int c,int o)\\n    {\\n        if(t[r][c][o]!=0)\\n            return;\\n        if(r>g.size()-1||c>g[0].size()-1)\\n            return;\\n        if(r==g.size()-1&&c==g[0].size()-1)\\n        {\\n            if(g[r][c]==\\')\\'&& o==1)\\n                ans=true;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2067060,
                "title": "memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<char>>& grid,int count,int n,int m,int i,int j,vector<vector<vector<int>>>&dp){\\n        if(i<0 || i>=n || j<0 || j>=m)return false;\\n       // cout<<grid[i][j]<<count<<\" \";\\n        if(grid[i][j]==\\')\\'){\\n            if(count<=0)return 0;\\n            else count--;\\n        }\\n        \\n        \\n        if(grid[i][j]==\\'(\\')count++;\\n         \\n        \\n        if(i==n-1 && j==m-1){\\n            if(count==0){\\n                return 1;\\n            }\\n        }\\n        if(dp[i][j][count]!=-1)return dp[i][j][count];\\n        \\n        //down \\n        if(solve(grid,count,n,m,i+1,j,dp)==1)return dp[i][j][count] = 1;\\n        if(solve(grid,count,n,m,i,j+1,dp)==1)return dp[i][j][count]=1; //left\\n        \\n        \\n        \\n        \\n       \\n        return dp[i][j][count]=0;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n       vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(m+n,-1)));\\n        int count=0;\\n       \\n        int sol = solve(grid,count,n,m,0,0,dp);\\n       \\n        \\n        if(sol==1)return true;\\n    \\n        return false;\\n    }\\n};\\n```\\nI\\'m so proud of me for solving this. Literally lost a night\\'s sleep over this one",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<char>>& grid,int count,int n,int m,int i,int j,vector<vector<vector<int>>>&dp){\\n        if(i<0 || i>=n || j<0 || j>=m)return false;\\n       // cout<<grid[i][j]<<count<<\" \";\\n        if(grid[i][j]==\\')\\'){\\n            if(count<=0)return 0;\\n            else count--;\\n        }\\n        \\n        \\n        if(grid[i][j]==\\'(\\')count++;\\n         \\n        \\n        if(i==n-1 && j==m-1){\\n            if(count==0){\\n                return 1;\\n            }\\n        }\\n        if(dp[i][j][count]!=-1)return dp[i][j][count];\\n        \\n        //down \\n        if(solve(grid,count,n,m,i+1,j,dp)==1)return dp[i][j][count] = 1;\\n        if(solve(grid,count,n,m,i,j+1,dp)==1)return dp[i][j][count]=1; //left\\n        \\n        \\n        \\n        \\n       \\n        return dp[i][j][count]=0;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n       vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(m+n,-1)));\\n        int count=0;\\n       \\n        int sol = solve(grid,count,n,m,0,0,dp);\\n       \\n        \\n        if(sol==1)return true;\\n    \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2060185,
                "title": "the-one-optimization-to-speed-up-your-memoization",
                "content": "Intuition behind optimizing memoization-\\nThe path length in any scenario irrespective of the path we take would always be equal to n+m-1 since we can only move right or downwards and we\\'ll have to cover n depth and m width.\\nSince we know that the number of open and closed brackets would be same in the end we can conclude that at any moment, the open brackets would be less than or equal to (n+m-1)/2.\\nAs most of the solutions are using the no. of open brackets for memoization we can reduce the size of our vector signifcantly by making the max no. of open brackets as (n+m-1)/2 instead of n * m.\\n\\n``\\nclass Solution {\\npublic:\\nbool helper(int i,int j,int o,vector<vector<char>>&grid,vector<vector<vector<int>>>&memo){  \\n    int n=grid.size();\\n    int m=grid[0].size();\\n    if(o>(n+m)/2)  return false; \\n    if(i>=n or i<0 or j>=m or j<0)return false;\\n                                                                                                     if(i==n-1 and j==m-1){\\n        if(o==1)return true;\\n        return false;\\n    }         \\n    if(memo[i][j][o]!=-1)return memo[i][j][o];\\n    char curr=grid[i][j];\\n    \\n    if(curr==\\')\\'){\\n        if(o>=1)\\n             return memo[i][j][o]=helper(i+1,j,o-1,grid,memo) or helper(i,j+1,o-1,grid,memo);\\n        else return memo[i][j][o]=false;\\n    }\\n      else  return memo[i][j][o]=helper(i+1,j,o+1,grid,memo) or helper(i,j+1,o+1,grid,memo);\\n      \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>>memo(n,vector<vector<int>>(m,vector<int>((n+m)/2+1,-1)));\\n        if(grid[n-1][m-1]==\\'(\\')return false;\\n        \\n        return helper(0,0,0,grid,memo);\\n        \\n    }\\n};\\n``",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\nbool helper(int i,int j,int o,vector<vector<char>>&grid,vector<vector<vector<int>>>&memo){  \\n    int n=grid.size();\\n    int m=grid[0].size();\\n    if(o>(n+m)/2)  return false; \\n    if(i>=n or i<0 or j>=m or j<0)return false;\\n                                                                                                     if(i==n-1 and j==m-1){\\n        if(o==1)return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2050921,
                "title": "c-classic-dfs-dp",
                "content": "* **If at any point in our traversal we find that open has become negative then return false as there is no way to balance a `)` bracket if it arrives before `(`.** \\n \\n```\\nclass Solution {\\npublic:\\n    int r ,c ;\\n    int dp[101][101][1001] ;\\n    bool solve(int x , int y , vector<vector<char>>&grid , int open ){\\n        if(x >= r || y >= c) return false ;\\n        open += grid[x][y] == \\'(\\' ? 1 : -1 ;\\n        if(open < 0) return false ;\\n        if(x == r - 1 and y == c - 1 ) return (open == 0) ;\\n        \\n        if(dp[x][y][open] != -1) return dp[x][y][open] ;\\n        \\n        bool path1 = solve(x,y+1,grid,open) ;\\n        bool path2 = solve(x+1,y,grid,open) ;\\n        return dp[x][y][open] = (path1 or path2) ;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        r = grid.size() ;\\n        c = grid[0].size() ;\\n        memset(dp,-1,sizeof(dp)) ;\\n        return solve(0,0,grid,0) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r ,c ;\\n    int dp[101][101][1001] ;\\n    bool solve(int x , int y , vector<vector<char>>&grid , int open ){\\n        if(x >= r || y >= c) return false ;\\n        open += grid[x][y] == \\'(\\' ? 1 : -1 ;\\n        if(open < 0) return false ;\\n        if(x == r - 1 and y == c - 1 ) return (open == 0) ;\\n        \\n        if(dp[x][y][open] != -1) return dp[x][y][open] ;\\n        \\n        bool path1 = solve(x,y+1,grid,open) ;\\n        bool path2 = solve(x+1,y,grid,open) ;\\n        return dp[x][y][open] = (path1 or path2) ;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        r = grid.size() ;\\n        c = grid[0].size() ;\\n        memset(dp,-1,sizeof(dp)) ;\\n        return solve(0,0,grid,0) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031616,
                "title": "simple-dp-memomization-faster-and-easy-to-understand",
                "content": "Simple Intution ,It is same as to find the Path from top left corner to right down corner but here the catch is to find the valid path which should statisfy the given conditions like **()** (parentheses)\\n\\nAnd there is a condition we should take care \\n1. The Path should not start with **)**. \\n2. The path should not end with **(**.\\n\\n**DP Approach**\\n* First take a variable lets say **start**  which will count the parentheses i.e if \"**(**\" then start++  if \"**)**\" start--.\\n* Traverse the all possible paths with right and down.\\n* Until it statisfy the condition i.e (n-1,m-1 and start=0)\\n* if the start is 0 at the end that means we got a path with equal no of parentheses.\\n* To Optimize the code Use Memomization.\\n\\n```\\nclass Solution {\\n    Boolean dp[][][];\\n    public boolean hasValidPath(char[][] grid) \\n    {\\n        dp=new Boolean[grid.length][grid[0].length][grid.length+grid[0].length];\\n        return helper(grid,0,0,0);\\n    }\\n    public boolean helper(char[][] grid,int i,int j,int start)\\n    {\\n        if(i>=grid.length || j>=grid[0].length) return false;\\n        if(grid[i][j]==\\'(\\')\\n            start++;\\n        else\\n            start--;\\n        if(start<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1) return start==0;\\n        if(dp[i][j][start]!=null) return dp[i][j][start];\\n        dp[i][j][start]=(helper(grid,i+1,j,start) || helper(grid,i,j+1,start));\\n        return dp[i][j][start];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Boolean dp[][][];\\n    public boolean hasValidPath(char[][] grid) \\n    {\\n        dp=new Boolean[grid.length][grid[0].length][grid.length+grid[0].length];\\n        return helper(grid,0,0,0);\\n    }\\n    public boolean helper(char[][] grid,int i,int j,int start)\\n    {\\n        if(i>=grid.length || j>=grid[0].length) return false;\\n        if(grid[i][j]==\\'(\\')\\n            start++;\\n        else\\n            start--;\\n        if(start<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1) return start==0;\\n        if(dp[i][j][start]!=null) return dp[i][j][start];\\n        dp[i][j][start]=(helper(grid,i+1,j,start) || helper(grid,i,j+1,start));\\n        return dp[i][j][start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028833,
                "title": "python-simple-dp-solution-top-down",
                "content": "Here is a simple solution\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m,n=len(grid), len(grid[0])\\n        \\n        # first value in the grid should be \\'(\\' and last value be \\')\\'\\n        if grid[0][0]!=\\'(\\' or grid[-1][-1]!=\\')\\':\\n            return False\\n\\n        @lru_cache(None)\\n        def dp(i,j,c):\\n            # When we reach the last cell, the number of open brackets should be 1.\\n            # \\')\\' from last cell balances it\\n            if i==m-1 and j==n-1:\\n                if c==1:\\n                    return True\\n                else:\\n                    return False\\n            # i,j should be within the range of m,n\\n            if i>=m or j>=n:\\n                return False\\n            \\n            res=False\\n            # From every cell, we can move right(j+1) or down(i+1)\\n            if grid[i][j]==\\'(\\':\\n                # When we encounter \\'(\\' we increment count by 1\\n                res=res or dp(i+1, j, c+1) or dp(i, j+1, c+1)\\n            else:\\n                # When we encounter \\')\\' number of of open brackets must be greater than 0\\n                if c>0:\\n                    # Decrement the count by 1\\n                    res=res or dp(i+1, j, c-1) or dp(i, j+1, c-1)\\n            return res\\n        return dp(0,0,0)\\n        \\n\\t",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "Here is a simple solution\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m,n=len(grid), len(grid[0])\\n        \\n        # first value in the grid should be \\'(\\' and last value be \\')\\'\\n        if grid[0][0]!=\\'(\\' or grid[-1][-1]!=\\')\\':\\n            return False\\n\\n        @lru_cache(None)\\n        def dp(i,j,c):\\n            # When we reach the last cell, the number of open brackets should be 1.\\n            # \\')\\' from last cell balances it\\n            if i==m-1 and j==n-1:\\n                if c==1:\\n                    return True\\n                else:\\n                    return False\\n            # i,j should be within the range of m,n\\n            if i>=m or j>=n:\\n                return False\\n            \\n            res=False\\n            # From every cell, we can move right(j+1) or down(i+1)\\n            if grid[i][j]==\\'(\\':\\n                # When we encounter \\'(\\' we increment count by 1\\n                res=res or dp(i+1, j, c+1) or dp(i, j+1, c+1)\\n            else:\\n                # When we encounter \\')\\' number of of open brackets must be greater than 0\\n                if c>0:\\n                    # Decrement the count by 1\\n                    res=res or dp(i+1, j, c-1) or dp(i, j+1, c-1)\\n            return res\\n        return dp(0,0,0)\\n        \\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 2026194,
                "title": "python-and-memorize",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == \\')\\':\\n            return False\\n        if grid[-1][-1] == \\'(\\':\\n            return False\\n        if (m + n) % 2 == 0:\\n            return False\\n        \\n        halfLen = (m + n) // 2\\n        \\n        helper = [[set([]) for _ in range(n)] for _ in range(m)]\\n        helper[0][0].add(1)\\n        \\n        for c in range(1, n):\\n            for e in helper[0][c-1]:\\n                if halfLen >= e + (1 if grid[0][c] == \\'(\\' else -1) >= 0:\\n                    helper[0][c].add(  e + (1 if grid[0][c] == \\'(\\' else -1) )\\n            \\n        for r in range(1, m):\\n            lst = [e + ( 1 if grid[r][0] == \\'(\\' else -1 ) for e in helper[r-1][0] if halfLen >= e + (1 if grid[r][0] == \\'(\\' else -1) >= 0]\\n            for e in lst:\\n                helper[r][0].add(e)\\n            \\n            for c in range(1, n):\\n                lst = [e + ( 1 if grid[r][c] == \\'(\\' else -1 ) for e in helper[r-1][c].union(helper[r][c-1]) if halfLen >= e + (1 if grid[r][c] == \\'(\\' else -1) >= 0]\\n                \\n                for e in lst:\\n                    helper[r][c].add(e)\\n                    \\n        \\n        return 0 in helper[-1][-1]\\n                \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == \\')\\':\\n            return False\\n        if grid[-1][-1] == \\'(\\':\\n            return False\\n        if (m + n) % 2 == 0:\\n            return False\\n        \\n        halfLen = (m + n) // 2\\n        \\n        helper = [[set([]) for _ in range(n)] for _ in range(m)]\\n        helper[0][0].add(1)\\n        \\n        for c in range(1, n):\\n            for e in helper[0][c-1]:\\n                if halfLen >= e + (1 if grid[0][c] == \\'(\\' else -1) >= 0:\\n                    helper[0][c].add(  e + (1 if grid[0][c] == \\'(\\' else -1) )\\n            \\n        for r in range(1, m):\\n            lst = [e + ( 1 if grid[r][0] == \\'(\\' else -1 ) for e in helper[r-1][0] if halfLen >= e + (1 if grid[r][0] == \\'(\\' else -1) >= 0]\\n            for e in lst:\\n                helper[r][0].add(e)\\n            \\n            for c in range(1, n):\\n                lst = [e + ( 1 if grid[r][c] == \\'(\\' else -1 ) for e in helper[r-1][c].union(helper[r][c-1]) if halfLen >= e + (1 if grid[r][c] == \\'(\\' else -1) >= 0]\\n                \\n                for e in lst:\\n                    helper[r][c].add(e)\\n                    \\n        \\n        return 0 in helper[-1][-1]\\n                \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024969,
                "title": "cpp-explanation-99-faster-using-0-1-knapsack-and-dp-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dp[101][101][101]; \\n    // dp[i][j][k] stores the ans at position i,j where the difference between the number of left and the right brackets is k\\n    int vis[101][101][101];\\n    // vis[i][j][k] stores of we ever visit the position i, j where the difference between the number of left and the right brackets is k\\n    int n, m;\\n    bool find(int x, int y, vector<vector<char>>&grid, int l, int r){\\n        if(r > l) return false; // for optimizatin if right brackets if > left bracketthen obviously we can\\'t reach to an ans eg:- ()) \\n        if(l > (n+m-1)/2) return false; // in our final ans l will be equals to (n+m-1)/2 in case it is more than our required value we are on the wrong path\\n        if(vis[x][y][l-r] != -1) return dp[x][y][l-r];  // using memorization\\n        vis[x][y][l-r] = 1; // mark this position as visited\\n        if(x == n-1 && y == m-1){   // if we reach at bottom right\\n            return dp[x][y][l-r] = (l == r);    // return if l==r or not\\n        }\\n        bool ans = false; \\n        if(x != n-1){ // if we can go down then try going down\\n            ans |= find(x+1, y, grid, l + (grid[x+1][y] == \\'(\\'), r + (grid[x+1][y] == \\')\\'));\\n        }\\n        if(ans) return dp[x][y][l-r] = ans; // if we find the ans return true no need to go to the right side now\\n        if(y != m-1){\\n            // in case we do not find the ans go right\\n            ans |= find(x, y+1, grid, l + (grid[x][y+1] == \\'(\\'), r + (grid[x][y+1] == \\')\\'));\\n        }\\n        return dp[x][y][l-r] = ans; //return the ans\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\') return false; // if 1st grid is right bracket then return false;\\n        n = grid.size();\\n        m = grid[0].size();\\n        if((n + m - 1)&1) return false; // if the path contains odd number of grid return false\\n        memset(dp, false, sizeof(dp));\\n        memset(vis, -1, sizeof(vis));\\n        return find(0, 0, grid, 1, 0);  // return the ans\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dp[101][101][101]; \\n    // dp[i][j][k] stores the ans at position i,j where the difference between the number of left and the right brackets is k\\n    int vis[101][101][101];\\n    // vis[i][j][k] stores of we ever visit the position i, j where the difference between the number of left and the right brackets is k\\n    int n, m;\\n    bool find(int x, int y, vector<vector<char>>&grid, int l, int r){\\n        if(r > l) return false; // for optimizatin if right brackets if > left bracketthen obviously we can\\'t reach to an ans eg:- ()) \\n        if(l > (n+m-1)/2) return false; // in our final ans l will be equals to (n+m-1)/2 in case it is more than our required value we are on the wrong path\\n        if(vis[x][y][l-r] != -1) return dp[x][y][l-r];  // using memorization\\n        vis[x][y][l-r] = 1; // mark this position as visited\\n        if(x == n-1 && y == m-1){   // if we reach at bottom right\\n            return dp[x][y][l-r] = (l == r);    // return if l==r or not\\n        }\\n        bool ans = false; \\n        if(x != n-1){ // if we can go down then try going down\\n            ans |= find(x+1, y, grid, l + (grid[x+1][y] == \\'(\\'), r + (grid[x+1][y] == \\')\\'));\\n        }\\n        if(ans) return dp[x][y][l-r] = ans; // if we find the ans return true no need to go to the right side now\\n        if(y != m-1){\\n            // in case we do not find the ans go right\\n            ans |= find(x, y+1, grid, l + (grid[x][y+1] == \\'(\\'), r + (grid[x][y+1] == \\')\\'));\\n        }\\n        return dp[x][y][l-r] = ans; //return the ans\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\') return false; // if 1st grid is right bracket then return false;\\n        n = grid.size();\\n        m = grid[0].size();\\n        if((n + m - 1)&1) return false; // if the path contains odd number of grid return false\\n        memset(dp, false, sizeof(dp));\\n        memset(vis, -1, sizeof(vis));\\n        return find(0, 0, grid, 1, 0);  // return the ans\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024123,
                "title": "java-dp-solution-with-explanation",
                "content": "\\n**Explanation**\\nFor each ceel A[i][j]\\nwe count the number of open parenthese for the path reaching A[i][j].\\nIf it\\'s negative, it\\'s not valid already.\\nFinally we check if there is a path to A[m-1][n-1] that has no open parenthese,\\nthat means a valid parentheses string path reaching A[m-1][n-1].\\n\\n\\n**Optimisation**\\nI usually don\\'t handle edge cases specially,\\nsince they can be correctly handled by itself.\\nAnd usually the short cut only improve edge case, not general case,\\n\\nHere are 3 quick fail case:\\nIf (n + m) % 2 == 0, the length of path to A[m-1][n-1] is odd, can return false.\\nIf A[-1][-1] == \\'(\\', no valid start can return false.\\nIf A[0][0] == \\')\\', no valid end, can return false.\\n\\n```\\n    public boolean hasValidPath(char[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][][] dp = new boolean[m + 1][n + 1][103];\\n        dp[0][0][1] = true;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= 101; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];\\n    }\\n```\\n\\nTrick 1:\\nA[i][j][0] for the path count -1,\\nA[i][j][1] for the path count 0, etc.\\nNo need to handle negative specially.\\n\\nTrick 2:\\nUse something like A[i+1] += A[i] instead of A[i] = A[i-1]\\nNo need to handle i == 0 and j == 0 specially.\\n\\nTrick 3:\\ndp[m][n - 1] and dp[m - 1][n] are from dp[m - 1][n - 1],\\nreturn dp[m][n - 1][1] for the result.\\n\\nBy help of @lee215",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public boolean hasValidPath(char[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][][] dp = new boolean[m + 1][n + 1][103];\\n        dp[0][0][1] = true;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= 101; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2022808,
                "title": "easy-dfs-java-soln",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        return helper(grid, 0, 0, 0, new Boolean[m][n][m + n]);\\n    }\\n    \\n    private boolean helper(char[][] grid, int i, int j, int bal, Boolean [][][] visit){\\n        if(i >= grid.length || j >= grid[0].length || bal < 0){\\n            return false;\\n        }\\n        \\n        if(visit[i][j][bal] != null){\\n            return visit[i][j][bal];\\n        }\\n        \\n        int updateBal = bal + (grid[i][j] == \\'(\\' ? 1 : -1);\\n        \\n        if(i == grid.length - 1 && j == grid[0].length - 1 && updateBal == 0){\\n            return true;\\n        }\\n        \\n        boolean d = helper(grid, i + 1, j, updateBal, visit);\\n        boolean r = helper(grid, i, j + 1, updateBal, visit);\\n        visit[i][j][bal] = d || r;\\n        return d || r;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        return helper(grid, 0, 0, 0, new Boolean[m][n][m + n]);\\n    }\\n    \\n    private boolean helper(char[][] grid, int i, int j, int bal, Boolean [][][] visit){\\n        if(i >= grid.length || j >= grid[0].length || bal < 0){\\n            return false;\\n        }\\n        \\n        if(visit[i][j][bal] != null){\\n            return visit[i][j][bal];\\n        }\\n        \\n        int updateBal = bal + (grid[i][j] == \\'(\\' ? 1 : -1);\\n        \\n        if(i == grid.length - 1 && j == grid[0].length - 1 && updateBal == 0){\\n            return true;\\n        }\\n        \\n        boolean d = helper(grid, i + 1, j, updateBal, visit);\\n        boolean r = helper(grid, i, j + 1, updateBal, visit);\\n        visit[i][j][bal] = d || r;\\n        return d || r;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022762,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    HashMap<String, Boolean> mem = new HashMap();\\n    public boolean hasValidPath(char[][] grid) {\\n        return dfs(grid, 0, 0, 0);\\n    }\\n    \\n    \\n    boolean dfs(char[][] g, int r, int c, int v) {\\n        if (r == g.length-1 && c == g[0].length-1) {\\n            if (g[r][c] == \\'(\\') v++;\\n            else v--;\\n            if (v == 0) return true;\\n            else return false;\\n        } \\n        if (r < 0 || c < 0 || r>g.length-1 || c > g[0].length-1) return false;\\n        \\n        String key = (r * g.length + c) + \"_\" + v;\\n        if (mem.containsKey(key)) return mem.get(key);\\n        boolean ans = false;\\n        if (g[r][c] == \\'(\\') v++;\\n        else {\\n            v--;\\n            if (v < 0) {\\n                mem.put(key, false);\\n                return false;\\n            }\\n        }\\n        ans = ans || dfs(g, r+1,c,v);\\n        ans = ans || dfs(g, r, c+1, v);\\n\\n        mem.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, Boolean> mem = new HashMap();\\n    public boolean hasValidPath(char[][] grid) {\\n        return dfs(grid, 0, 0, 0);\\n    }\\n    \\n    \\n    boolean dfs(char[][] g, int r, int c, int v) {\\n        if (r == g.length-1 && c == g[0].length-1) {\\n            if (g[r][c] == \\'(\\') v++;\\n            else v--;\\n            if (v == 0) return true;\\n            else return false;\\n        } \\n        if (r < 0 || c < 0 || r>g.length-1 || c > g[0].length-1) return false;\\n        \\n        String key = (r * g.length + c) + \"_\" + v;\\n        if (mem.containsKey(key)) return mem.get(key);\\n        boolean ans = false;\\n        if (g[r][c] == \\'(\\') v++;\\n        else {\\n            v--;\\n            if (v < 0) {\\n                mem.put(key, false);\\n                return false;\\n            }\\n        }\\n        ans = ans || dfs(g, r+1,c,v);\\n        ans = ans || dfs(g, r, c+1, v);\\n\\n        mem.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022322,
                "title": "c-recursion-memoization-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int row, col;\\n    int dp[101][101][202];\\n    \\n    bool solve(vector<vector<char>>& grid, int i, int j, int score){\\n        // if out of grid, return false\\n         if(i >= row || j >= col) return false ;\\n        \\n        // calculate score\\n         if(grid[i][j] == \\'(\\') score++;\\n         else score--;\\n         \\n        // if score is negative than it means that this parentheses is not valid, return false\\n         if(score < 0) return false;\\n        \\n        // if we reach to the destination with score = 0, it is a valid path, return true;\\n         if(i == grid.size() - 1 && j == grid[0].size() - 1 && score == 0){\\n              return true;\\n         }\\n         \\n         // if we already know the answer, return that\\n         if(dp[i][j][score] != -1) return dp[i][j][score];\\n        \\n         // else calulate the answer in moving down, right, and calculate the answer and return\\n         return dp[i][j][score] = solve(grid, i + 1, j , score) || solve(grid, i , j + 1, score);\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n         row = grid.size(), col = grid[0].size();\\n         memset(dp,-1, sizeof(dp));\\n         return  solve(grid, 0,0, 0);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int row, col;\\n    int dp[101][101][202];\\n    \\n    bool solve(vector<vector<char>>& grid, int i, int j, int score){\\n        // if out of grid, return false\\n         if(i >= row || j >= col) return false ;\\n        \\n        // calculate score\\n         if(grid[i][j] == \\'(\\') score++;\\n         else score--;\\n         \\n        // if score is negative than it means that this parentheses is not valid, return false\\n         if(score < 0) return false;\\n        \\n        // if we reach to the destination with score = 0, it is a valid path, return true;\\n         if(i == grid.size() - 1 && j == grid[0].size() - 1 && score == 0){\\n              return true;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2021722,
                "title": "java-maintain-the-number-of-opening-and-closing-the-brackets-and-memoize-it",
                "content": "```\\nclass Solution {\\n    private int R;\\n    private int C;\\n    private int[][][] dp;\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        \\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n        this.dp = new int[R+1][C+1][201];\\n        \\n        for(int[][] i : dp){\\n            for(int[] j : i){\\n                Arrays.fill(j, -1);\\n            }\\n        }\\n        \\n        if(find(0, 0, 0, 0, grid)) return true;\\n        \\n        return false;\\n    }\\n    \\n    private boolean find(int r, int c, int left, int right, char[][] grid){\\n        if(r < 0 || r >= R ||c < 0 || c >= C){\\n            return false;\\n        }\\n        \\n        if(grid[r][c] == \\'(\\'){\\n            left++;\\n        }else right++;\\n        \\n        if(left == right && r == R-1 && c == C-1){\\n            return true;\\n        }\\n        \\n        // System.out.println(r + \" \" + c + \" \" + left + \" \" + right + \" \");\\n        if(left >= right){\\n            if(dp[r][c][left-right] != -1){\\n                return dp[r][c][left-right] == 1 ? true : false;\\n            }\\n        }else return false;\\n        \\n        \\n        boolean isPossible = false;\\n        isPossible = find(r, c+1, left, right, grid) || find(r+1, c, left, right, grid);\\n        dp[r][c][left-right] = isPossible ==  true ? 1 : 0;\\n        \\n        return isPossible;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int R;\\n    private int C;\\n    private int[][][] dp;\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        \\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n        this.dp = new int[R+1][C+1][201];\\n        \\n        for(int[][] i : dp){\\n            for(int[] j : i){\\n                Arrays.fill(j, -1);\\n            }\\n        }\\n        \\n        if(find(0, 0, 0, 0, grid)) return true;\\n        \\n        return false;\\n    }\\n    \\n    private boolean find(int r, int c, int left, int right, char[][] grid){\\n        if(r < 0 || r >= R ||c < 0 || c >= C){\\n            return false;\\n        }\\n        \\n        if(grid[r][c] == \\'(\\'){\\n            left++;\\n        }else right++;\\n        \\n        if(left == right && r == R-1 && c == C-1){\\n            return true;\\n        }\\n        \\n        // System.out.println(r + \" \" + c + \" \" + left + \" \" + right + \" \");\\n        if(left >= right){\\n            if(dp[r][c][left-right] != -1){\\n                return dp[r][c][left-right] == 1 ? true : false;\\n            }\\n        }else return false;\\n        \\n        \\n        boolean isPossible = false;\\n        isPossible = find(r, c+1, left, right, grid) || find(r+1, c, left, right, grid);\\n        dp[r][c][left-right] = isPossible ==  true ? 1 : 0;\\n        \\n        return isPossible;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020033,
                "title": "go-dp",
                "content": "```\\nvar dp[101][101][110]bool\\n\\nfunc hasValidPath(a [][]byte) bool {\\n    if a[0][0] == \\')\\' {\\n        return false\\n    }\\n    \\n    var n, m int = len(a), len(a[0])\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            for k := 0; k < 101; k++ {\\n                dp[i][j][k] = false\\n            }\\n        }\\n    }\\n    \\n    dp[0][0][1] = true\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            if i - 1 >= 0 {\\n                if a[i][j] == \\'(\\' {\\n                    for open := 1; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i - 1][j][open - 1]\\n                    }\\n                } else {\\n                    for open := 0; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i - 1][j][open + 1]\\n                    }\\n                }\\n            }\\n            if j - 1 >= 0 {\\n                if a[i][j] == \\'(\\' {\\n                    for open := 1; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i][j - 1][open - 1]\\n                    }\\n                } else {\\n                    for open := 0; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i][j - 1][open + 1]\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n - 1][m - 1][0]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar dp[101][101][110]bool\\n\\nfunc hasValidPath(a [][]byte) bool {\\n    if a[0][0] == \\')\\' {\\n        return false\\n    }\\n    \\n    var n, m int = len(a), len(a[0])\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            for k := 0; k < 101; k++ {\\n                dp[i][j][k] = false\\n            }\\n        }\\n    }\\n    \\n    dp[0][0][1] = true\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            if i - 1 >= 0 {\\n                if a[i][j] == \\'(\\' {\\n                    for open := 1; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i - 1][j][open - 1]\\n                    }\\n                } else {\\n                    for open := 0; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i - 1][j][open + 1]\\n                    }\\n                }\\n            }\\n            if j - 1 >= 0 {\\n                if a[i][j] == \\'(\\' {\\n                    for open := 1; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i][j - 1][open - 1]\\n                    }\\n                } else {\\n                    for open := 0; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i][j - 1][open + 1]\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n - 1][m - 1][0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019810,
                "title": "python3-dfs-solution",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\': return False\\n        \\n        RC = [len(grid), len(grid[0])]\\n        seen = set()\\n        result = [False]\\n        \\n        def dfs(x, y, balance, seen):\\n            if result[0] == True: return\\n            R, C = RC[0], RC[1]\\n            \\n            if x == R - 1 and y == C - 1 and balance == 0:\\n                result[0] = True\\n                return\\n            \\n            for d in [[0,1], [1,0]]:\\n                new_x, new_y = x + d[0], y + d[1]\\n                \\n                if 0<=new_x<R and 0<=new_y<C:\\n                    \\n                    if grid[new_x][new_y] != \\'#\\':\\n                        prev_balance = balance\\n                        balance += 1 if grid[new_x][new_y] == \\'(\\' else -1\\n                        \\n                        if balance > -1 and balance < (R + C) // 2 + 1:\\n\\n                            if (new_x, new_y, balance) not in seen:\\n                                seen.add((new_x, new_y, balance))\\n                                \\n                                temp = grid[new_x][new_y]\\n                                grid[new_x][new_y] = \\'#\\'\\n                                dfs(new_x, new_y, balance, seen)\\n                                grid[new_x][new_y] = temp\\n                        \\n                        balance = prev_balance\\n        \\n        grid[0][0] = \\'#\\'\\n        seen.add((0,0,1))\\n        dfs(0, 0, 1, seen)\\n        \\n        return result[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\': return False\\n        \\n        RC = [len(grid), len(grid[0])]\\n        seen = set()\\n        result = [False]\\n        \\n        def dfs(x, y, balance, seen):\\n            if result[0] == True: return\\n            R, C = RC[0], RC[1]\\n            \\n            if x == R - 1 and y == C - 1 and balance == 0:\\n                result[0] = True\\n                return\\n            \\n            for d in [[0,1], [1,0]]:\\n                new_x, new_y = x + d[0], y + d[1]\\n                \\n                if 0<=new_x<R and 0<=new_y<C:\\n                    \\n                    if grid[new_x][new_y] != \\'#\\':\\n                        prev_balance = balance\\n                        balance += 1 if grid[new_x][new_y] == \\'(\\' else -1\\n                        \\n                        if balance > -1 and balance < (R + C) // 2 + 1:\\n\\n                            if (new_x, new_y, balance) not in seen:\\n                                seen.add((new_x, new_y, balance))\\n                                \\n                                temp = grid[new_x][new_y]\\n                                grid[new_x][new_y] = \\'#\\'\\n                                dfs(new_x, new_y, balance, seen)\\n                                grid[new_x][new_y] = temp\\n                        \\n                        balance = prev_balance\\n        \\n        grid[0][0] = \\'#\\'\\n        seen.add((0,0,1))\\n        dfs(0, 0, 1, seen)\\n        \\n        return result[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019487,
                "title": "simple-dfs-memo",
                "content": "We will create a valid variable to see if the current path is valid or not .\\nIf valid variable is positive it means we have more open bracket and hence we can close it but if it becomes negative at any point means close bracket are more and hence path is invalid.\\n\\nWe have a 3d dp of 3 variables row column and valid.\\n\\n```\\nint n,m;\\n    int dp[102][102][201];\\n    bool f(vector<vector<char>>&grid,int i,int j,int valid)\\n    {\\n        if(i<0 or i>=n or j<0 or j>=m)return false;\\n        if(grid[i][j]==\\'(\\')valid++;\\n        else valid--;\\n        if(valid<0)return false;\\n        if(i==n-1 and j==m-1)return valid==0;//we have reached the end see if valid= =0 means open==close bracket\\n        if(dp[i][j][valid]!=-1)\\n        {\\n            return dp[i][j][valid]==1;\\n        }\\n        return dp[i][j][valid]=f(grid,i+1,j,valid) or f(grid,i,j+1,valid);\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        n=grid.size();\\n        m=grid[0].size();\\n        return f(grid,0,0,0);   \\n    }\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint n,m;\\n    int dp[102][102][201];\\n    bool f(vector<vector<char>>&grid,int i,int j,int valid)\\n    {\\n        if(i<0 or i>=n or j<0 or j>=m)return false;\\n        if(grid[i][j]==\\'(\\')valid++;\\n        else valid--;\\n        if(valid<0)return false;\\n        if(i==n-1 and j==m-1)return valid==0;//we have reached the end see if valid= =0 means open==close bracket\\n        if(dp[i][j][valid]!=-1)\\n        {\\n            return dp[i][j][valid]==1;\\n        }\\n        return dp[i][j][valid]=f(grid,i+1,j,valid) or f(grid,i,j+1,valid);\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        n=grid.size();\\n        m=grid[0].size();\\n        return f(grid,0,0,0);   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018832,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        @cache\\n        \\n        def helper(i,j,cnt):\\n            if i<0 or j<0:\\n                return False\\n            \\n            if i==0 and j==0:\\n                if grid[i][j]==\"(\":\\n                    cnt-=1\\n                else:\\n                    cnt+=1\\n                return cnt==0\\n                \\n            \\n            if grid[i][j]==\")\":\\n                cnt+=1\\n            else:\\n                cnt-=1\\n                if cnt<0:\\n                    return False\\n                    \\n            \\n            return helper(i-1,j,cnt) or helper(i,j-1,cnt)\\n        \\n        \\n        m=len(grid)\\n        n=len(grid[0])\\n        return helper(m-1,n-1,0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        @cache\\n        \\n        def helper(i,j,cnt):\\n            if i<0 or j<0:\\n                return False\\n            \\n            if i==0 and j==0:\\n                if grid[i][j]==\"(\":\\n                    cnt-=1\\n                else:\\n                    cnt+=1\\n                return cnt==0\\n                \\n            \\n            if grid[i][j]==\")\":\\n                cnt+=1\\n            else:\\n                cnt-=1\\n                if cnt<0:\\n                    return False\\n                    \\n            \\n            return helper(i-1,j,cnt) or helper(i,j-1,cnt)\\n        \\n        \\n        m=len(grid)\\n        n=len(grid[0])\\n        return helper(m-1,n-1,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018364,
                "title": "java-dfs-memo-vs-dp-with-explanation",
                "content": "Share two approaches:\\n- DFS + memo (top-down)\\n- DP (bottom-up)\\n\\n#### DFS + memo\\n##### Steps\\n1. Track the `bal` to check if the path is valid\\n2. When `bal < 0`, prune it\\n3. If the `bal == 0` in the bottom-right corner, we find the valid path\\n\\nuse `memo` to enhance the performance.\\n\\n##### Solution\\n- time complexity: `O(mn(m+n))`\\n- space complexity: `O(mn(m+n))`\\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    Boolean[][][] memo = new Boolean[m][n][m + n];\\n    return dfs(grid, 0, 0, 0, memo);\\n}\\n\\nboolean dfs(char[][] grid, int i, int j, int bal, Boolean[][][] memo) {\\n    int m = grid.length, n = grid[0].length;\\n    if (i < 0 || i >= m || j < 0 || j >= n || bal < 0) return false;\\n    int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n    if (i == m - 1 && j == n - 1 && bal + cur == 0) return true;\\n\\n    if (memo[i][j][bal] != null) return memo[i][j][bal];\\n    boolean valid = dfs(grid, i + 1, j, bal + cur, memo) || dfs(grid, i, j + 1, bal + cur, memo);\\n\\n    if (valid) memo[i][j][bal] = true;\\n    else memo[i][j][bal] = false;\\n    return valid;\\n}\\n```\\n------\\n#### DP\\n##### Steps\\n1. For every `grid[i][j]`, we track all possible `bal` \\n2. If the left or top of current grid has balance `bal`, then the current grid can have `bal +- 1` depends on the current grid is `(` or `)`\\n  Fomular is: \\n  ```\\n  grid[i][j][bal] = grid[i-1][j][bal-cur] || grid[i][j-1][bal-cur] where cur = grid[i][j] == 1 ? 1 : 0\\n  ```\\n3. If the `bal < 0`, prune it\\n4. If the `bal == 0` in the bottom-right corner, we find the valid path\\n\\nNote:\\nWe can implement it use 2D set or 3D array to track the balance\\n\\n##### Solution (2D Set)\\n- time complexity: `O(mn(m+n))`\\n- space complexity: `O(mn(m+n))`\\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] directions = new int[][]{{-1, 0}, {0, -1}};\\n\\n    Set<Integer>[][] dp = new HashSet[m][n];\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[i][j] = new HashSet<>();\\n        }\\n    }\\n\\n    if (grid[0][0] == \\'(\\') dp[0][0].add(1);\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n            for (int[] d : directions) {\\n                int x = i + d[0], y = j + d[1];\\n                if (x < 0 || y < 0) continue;\\n\\n                for (int bal : dp[x][y]) {\\n                    bal += cur;\\n                    if (bal < 0) continue;\\n                    dp[i][j].add(bal);\\n                }\\n            }\\n        }\\n    }\\n    return dp[m-1][n-1].contains(0);\\n}\\n```\\n\\n##### Solution (3D Array)\\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] dirs = new int[][]{{-1, 0}, {0, -1}};\\n    boolean[][][] dp = new boolean[m][n][m + n + 1];\\n\\n\\n    if (grid[0][0] == \\'(\\') dp[0][0][1] = true;\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n            for (int bal = 0; bal < m + n; bal++) {\\n                if (i > 0 && bal - cur >= 0) {\\n                    dp[i][j][bal] |= dp[i - 1][j][bal - cur];\\n                }\\n                if (j > 0 && bal - cur >= 0) {\\n                    dp[i][j][bal] |= dp[i][j - 1][bal - cur];\\n                }\\n            }\\n        }\\n    }\\n    return dp[m-1][n-1][0];\\n}\\n```\\n\\nPleaes let me know if this explanation is helpful for you, thanks!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    Boolean[][][] memo = new Boolean[m][n][m + n];\\n    return dfs(grid, 0, 0, 0, memo);\\n}\\n\\nboolean dfs(char[][] grid, int i, int j, int bal, Boolean[][][] memo) {\\n    int m = grid.length, n = grid[0].length;\\n    if (i < 0 || i >= m || j < 0 || j >= n || bal < 0) return false;\\n    int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n    if (i == m - 1 && j == n - 1 && bal + cur == 0) return true;\\n\\n    if (memo[i][j][bal] != null) return memo[i][j][bal];\\n    boolean valid = dfs(grid, i + 1, j, bal + cur, memo) || dfs(grid, i, j + 1, bal + cur, memo);\\n\\n    if (valid) memo[i][j][bal] = true;\\n    else memo[i][j][bal] = false;\\n    return valid;\\n}\\n```\n```\\n  grid[i][j][bal] = grid[i-1][j][bal-cur] || grid[i][j-1][bal-cur] where cur = grid[i][j] == 1 ? 1 : 0\\n  ```\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] directions = new int[][]{{-1, 0}, {0, -1}};\\n\\n    Set<Integer>[][] dp = new HashSet[m][n];\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[i][j] = new HashSet<>();\\n        }\\n    }\\n\\n    if (grid[0][0] == \\'(\\') dp[0][0].add(1);\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n            for (int[] d : directions) {\\n                int x = i + d[0], y = j + d[1];\\n                if (x < 0 || y < 0) continue;\\n\\n                for (int bal : dp[x][y]) {\\n                    bal += cur;\\n                    if (bal < 0) continue;\\n                    dp[i][j].add(bal);\\n                }\\n            }\\n        }\\n    }\\n    return dp[m-1][n-1].contains(0);\\n}\\n```\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] dirs = new int[][]{{-1, 0}, {0, -1}};\\n    boolean[][][] dp = new boolean[m][n][m + n + 1];\\n\\n\\n    if (grid[0][0] == \\'(\\') dp[0][0][1] = true;\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n            for (int bal = 0; bal < m + n; bal++) {\\n                if (i > 0 && bal - cur >= 0) {\\n                    dp[i][j][bal] |= dp[i - 1][j][bal - cur];\\n                }\\n                if (j > 0 && bal - cur >= 0) {\\n                    dp[i][j][bal] |= dp[i][j - 1][bal - cur];\\n                }\\n            }\\n        }\\n    }\\n    return dp[m-1][n-1][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018333,
                "title": "too-tight-bounds-tle-for-same-complexity-solutions",
                "content": "```\\nclass Solution {\\nprivate: \\n    unordered_map<int, unordered_map<int, unordered_map<int, int>>> dp;\\n    int r, c;\\n    bool valid(int x, int y, int dif, vector<vector<char>> &grid) {\\n        if (x < 0 || y < 0 || x >= r || y >= c) return false;\\n        if (grid[x][y] == \\'(\\') dif++;\\n        else dif--;\\n        if (dif < 0 || dif > (r + c) / 2)    return false;\\n        if (x == r - 1 && y == c - 1 && !dif)   return true;\\n        if (dp[x][y].find(dif) != dp[x][y].end())    return dp[x][y][dif];\\n        return dp[x][y][dif] = valid(x, y + 1, dif, grid) || valid(x + 1, y, dif, grid);\\n        \\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        r = grid.size(), c = grid[0].size();\\n        return valid(0, 0, 0, grid);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate: \\n    unordered_map<int, unordered_map<int, unordered_map<int, int>>> dp;\\n    int r, c;\\n    bool valid(int x, int y, int dif, vector<vector<char>> &grid) {\\n        if (x < 0 || y < 0 || x >= r || y >= c) return false;\\n        if (grid[x][y] == \\'(\\') dif++;\\n        else dif--;\\n        if (dif < 0 || dif > (r + c) / 2)    return false;\\n        if (x == r - 1 && y == c - 1 && !dif)   return true;\\n        if (dp[x][y].find(dif) != dp[x][y].end())    return dp[x][y][dif];\\n        return dp[x][y][dif] = valid(x, y + 1, dif, grid) || valid(x + 1, y, dif, grid);\\n        \\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        r = grid.size(), c = grid[0].size();\\n        return valid(0, 0, 0, grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018259,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[102][102][204];\\n    int f(int r, int c, int o1, int o2, int n, int m, vector<vector<char>>& g){\\n        if(o1<o2){\\n         return 0;\\n        }\\n        if(dp[r][c][o1-o2]!=-1)return dp[r][c][o1-o2];\\n        int val = 0;\\n        if(r<n-1){\\n            val = val || f(r+1, c, o1 + (g[r][c] == \\'(\\'), o2 + (g[r][c] == \\')\\'), n, m, g);\\n        }\\n        if(c<m-1){\\n            val = val || f(r, c+1, o1 + (g[r][c] == \\'(\\'), o2 + (g[r][c] == \\')\\'), n, m, g);\\n        }\\n        if(r==n-1 && c == m-1){\\n            return o1 + (g[r][c] == \\'(\\') == o2 +( g[r][c] == \\')\\');\\n        }\\n        return dp[r][c][o1-o2] = val;     \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,0,0,n,m, grid);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[102][102][204];\\n    int f(int r, int c, int o1, int o2, int n, int m, vector<vector<char>>& g){\\n        if(o1<o2){\\n         return 0;\\n        }\\n        if(dp[r][c][o1-o2]!=-1)return dp[r][c][o1-o2];\\n        int val = 0;\\n        if(r<n-1){\\n            val = val || f(r+1, c, o1 + (g[r][c] == \\'(\\'), o2 + (g[r][c] == \\')\\'), n, m, g);\\n        }\\n        if(c<m-1){\\n            val = val || f(r, c+1, o1 + (g[r][c] == \\'(\\'), o2 + (g[r][c] == \\')\\'), n, m, g);\\n        }\\n        if(r==n-1 && c == m-1){\\n            return o1 + (g[r][c] == \\'(\\') == o2 +( g[r][c] == \\')\\');\\n        }\\n        return dp[r][c][o1-o2] = val;     \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,0,0,n,m, grid);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018247,
                "title": "python-simple-but-slow-using-bfs",
                "content": "```python\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # Three quick failure cases\\n        if grid[0][0]==\")\": return False\\n        if grid[-1][-1]==\"(\": return False\\n        if (m+n)%2==0: return False\\n        \\n        # Let\\'s start!\\n        queue=[(0,0,1)] # row, col, acc.sum (must be 0 at the destination); assuming that \"(\"=1 and \")\"=-1\\n        visited=set()\\n        visited.add((0,0,1))\\n        while(queue):\\n            row, col, acc_sum = queue.pop(0)\\n            if row==m-1 and col==n-1 and acc_sum==0:\\n                return True\\n            \\n            # move down\\n            if row < m-1:\\n                next_item=1 if grid[row+1][col]==\"(\" else -1\\n                next_sum = acc_sum+next_item\\n                if next_sum>=0 and (row+1, col, next_sum) not in visited:\\n                    queue.append((row+1, col, next_sum))\\n                    visited.add((row+1, col, next_sum))\\n            \\n            # move right\\n            if col < n-1:\\n                next_item=1 if grid[row][col+1]==\"(\" else -1\\n                next_sum = acc_sum+next_item\\n                if next_sum>=0 and (row, col+1, next_sum) not in visited:\\n                    queue.append((row, col+1, next_sum))\\n                    visited.add((row, col+1, next_sum))\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # Three quick failure cases\\n        if grid[0][0]==\")\": return False\\n        if grid[-1][-1]==\"(\": return False\\n        if (m+n)%2==0: return False\\n        \\n        # Let\\'s start!\\n        queue=[(0,0,1)] # row, col, acc.sum (must be 0 at the destination); assuming that \"(\"=1 and \")\"=-1\\n        visited=set()\\n        visited.add((0,0,1))\\n        while(queue):\\n            row, col, acc_sum = queue.pop(0)\\n            if row==m-1 and col==n-1 and acc_sum==0:\\n                return True\\n            \\n            # move down\\n            if row < m-1:\\n                next_item=1 if grid[row+1][col]==\"(\" else -1\\n                next_sum = acc_sum+next_item\\n                if next_sum>=0 and (row+1, col, next_sum) not in visited:\\n                    queue.append((row+1, col, next_sum))\\n                    visited.add((row+1, col, next_sum))\\n            \\n            # move right\\n            if col < n-1:\\n                next_item=1 if grid[row][col+1]==\"(\" else -1\\n                next_sum = acc_sum+next_item\\n                if next_sum>=0 and (row, col+1, next_sum) not in visited:\\n                    queue.append((row, col+1, next_sum))\\n                    visited.add((row, col+1, next_sum))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018234,
                "title": "c-dp-recursive-memoization-full-explanation-o-nm-n-m",
                "content": "Before to explain my solution, let\\'s solve a simpler problem.\\n\\nHow to check if a parenthesis string is balanced, well this is a classic problem that can be solved using a stack but let\\'s try another approach.\\n\\nWe are going to maintain a int variable initialize with zero and traverse the string from left to right and for each character:\\n\\n* if the current char is \\'(\\' we add +1\\n* if the current char is \\')\\' we add -1\\n\\nIf at some point the sum becomes negative then the string is not balanced, also at the end the total sum needs to be zero (try different examples to convince you that is true).\\n\\nNow using this knowledge how can solve the problem?\\n\\nWe can use a dp approach similar to other grid problems for example [62. Unique Paths](https://leetcode.com/problems/unique-paths/)\\n\\ndp(i, j, s) = the path that finish at position (i, j) with sum s\\n\\nAs i stated before if the sum is negative we can return false, the other states are\\n\\n    dp(n - 1, m - 1, s) = if s == 0 return true otherwise false // Base case\\n    dp(i, j, s) = dp(i + 1, j, s + value of char in new position) or dp(i, j + 1, s + s + value of char in new position) // general case\\n\\nFinally, how many different states exist? i goes from [0, n) and j goes from [0, m) but the case of s is tricky, if you notice because only are allowed to move down or right the size of any path is n + m, this is more clear in the following example:\\n\\n![image](https://assets.leetcode.com/users/images/f84d5c25-68ae-4cc3-9b27-54e5db39556e_1651986492.763448.png)\\n\\nThen our final complexity is O(nm(n + m)).\\n\\nHere is my code:\\n```cpp\\nclass Solution {\\n    \\n    int n, m, memo[102][102][205];\\n\\n    int dp(vector<vector<char>>& grid, int i, int j, int sum) {\\n        if (i == n - 1 and j == m - 1) // Reach the final position\\n\\t\\t\\treturn (sum == 0); \\n        if (sum < 0) return false;\\n        if (memo[i][j][sum] != -1) return memo[i][j][sum];\\n\\t\\t\\n        if (i == n - 1 and j != m - 1) // Last row\\n            return memo[i][j][sum] = dp(grid, i, j + 1, sum + (grid[i][j + 1] == \\'(\\'? 1 : -1));\\n        if (i != n - 1 and j == m - 1) // Lats column\\n            return memo[i][j][sum] = dp(grid, i + 1, j, sum + (grid[i + 1][j] == \\'(\\' ? 1 : -1));\\n\\t\\t\\t\\n        return memo[i][j][sum] = dp(grid, i, j + 1, sum + (grid[i][j + 1] == \\'(\\'? 1 : -1)) or dp(grid, i + 1, j, sum + (grid[i + 1][j] == \\'(\\' ? 1 : -1));\\n    }\\n    \\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {        \\n        n = grid.size();\\n        m = grid[0].size();\\n        memset(memo, -1, sizeof(memo));\\n        return dp(grid, 0, 0, grid[0][0] == \\'(\\' ? 1 : -1);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    int n, m, memo[102][102][205];\\n\\n    int dp(vector<vector<char>>& grid, int i, int j, int sum) {\\n        if (i == n - 1 and j == m - 1) // Reach the final position\\n\\t\\t\\treturn (sum == 0); \\n        if (sum < 0) return false;\\n        if (memo[i][j][sum] != -1) return memo[i][j][sum];\\n\\t\\t\\n        if (i == n - 1 and j != m - 1) // Last row\\n            return memo[i][j][sum] = dp(grid, i, j + 1, sum + (grid[i][j + 1] == \\'(\\'? 1 : -1));\\n        if (i != n - 1 and j == m - 1) // Lats column\\n            return memo[i][j][sum] = dp(grid, i + 1, j, sum + (grid[i + 1][j] == \\'(\\' ? 1 : -1));\\n\\t\\t\\t\\n        return memo[i][j][sum] = dp(grid, i, j + 1, sum + (grid[i][j + 1] == \\'(\\'? 1 : -1)) or dp(grid, i + 1, j, sum + (grid[i + 1][j] == \\'(\\' ? 1 : -1));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2018101,
                "title": "javascript-dfs",
                "content": "```js\\n\\n\\n/**\\n * @param {character[][]} grid\\n * @return {boolean}\\n */\\nconst hasValidPath = function (grid) {\\n  const memo = {}\\n  const dfs = (row, col, diff) => {\\n    const key = `${row}-${col}-${diff}`\\n    if (memo[key] !== undefined) {\\n      return memo[key]\\n    }\\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[row].length) {\\n      return false\\n    }\\n    if (grid[row][col] === \\'(\\') {\\n      diff += 1\\n    } else {\\n      diff -= 1\\n    }\\n    if (diff < 0) {\\n      return false\\n    }\\n    if (row === grid.length - 1 && col === grid[row].length - 1 && diff === 0) {\\n      return true\\n    }\\n    let result = false\\n\\n    result = result || dfs(row + 1, col, diff)\\n    result = result || dfs(row, col + 1, diff)\\n    memo[key] = result\\n    return result\\n  }\\n  return dfs(0, 0, 0, 0)\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```js\\n\\n\\n/**\\n * @param {character[][]} grid\\n * @return {boolean}\\n */\\nconst hasValidPath = function (grid) {\\n  const memo = {}\\n  const dfs = (row, col, diff) => {\\n    const key = `${row}-${col}-${diff}`\\n    if (memo[key] !== undefined) {\\n      return memo[key]\\n    }\\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[row].length) {\\n      return false\\n    }\\n    if (grid[row][col] === \\'(\\') {\\n      diff += 1\\n    } else {\\n      diff -= 1\\n    }\\n    if (diff < 0) {\\n      return false\\n    }\\n    if (row === grid.length - 1 && col === grid[row].length - 1 && diff === 0) {\\n      return true\\n    }\\n    let result = false\\n\\n    result = result || dfs(row + 1, col, diff)\\n    result = result || dfs(row, col + 1, diff)\\n    memo[key] = result\\n    return result\\n  }\\n  return dfs(0, 0, 0, 0)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018011,
                "title": "java-3d-dp",
                "content": "```\\nclass Solution {\\n    int counter = 0;\\n    Boolean[][][] dp = new Boolean[101][101][201];\\n    public boolean hasValidPath(char[][] grid) {\\n        int row = grid.length-1;\\n        int col = grid[0].length-1;\\n        if(grid[0][0] !=\\'(\\' || grid[row][col] != \\')\\'){\\n            return false;\\n        }\\n        boolean res =  helper(grid, 0, 0, 0, 0, row, col);\\n        return res;\\n    }\\n    \\n    public boolean helper(char[][] grid, int i, int j, int open, int close, int row, int col){\\n        if(i<0 || j < 0 || i>row || j > col){\\n            \\n            return false;\\n        }\\n        else if((i==row) && (j==col) && (open==close+1)){\\n            dp[i][j][open - close] = true;\\n            return true;\\n        }\\n        else if(dp[i][j][open - close] != null){\\n            return dp[i][j][open - close];\\n        }\\n        else if(grid[i][j] == \\'(\\'){\\n            boolean res =  helper(grid, i+1, j, open+1, close, row, col) || helper(grid, i, j+1, open+1, close, row, col);\\n            dp[i][j][open - close] = res;\\n            return res;\\n        }\\n        else if( (open > close) && (grid[i][j] == \\')\\')){\\n            boolean res = helper(grid, i+1, j, open, close+1, row, col) || helper(grid, i, j+1, open, close+1, row, col);\\n            dp[i][j][open - close] = res;\\n            return res;\\n        }\\n        else{\\n            dp[i][j][open-close] = false;\\n            return false;\\n        }\\n\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int counter = 0;\\n    Boolean[][][] dp = new Boolean[101][101][201];\\n    public boolean hasValidPath(char[][] grid) {\\n        int row = grid.length-1;\\n        int col = grid[0].length-1;\\n        if(grid[0][0] !=\\'(\\' || grid[row][col] != \\')\\'){\\n            return false;\\n        }\\n        boolean res =  helper(grid, 0, 0, 0, 0, row, col);\\n        return res;\\n    }\\n    \\n    public boolean helper(char[][] grid, int i, int j, int open, int close, int row, int col){\\n        if(i<0 || j < 0 || i>row || j > col){\\n            \\n            return false;\\n        }\\n        else if((i==row) && (j==col) && (open==close+1)){\\n            dp[i][j][open - close] = true;\\n            return true;\\n        }\\n        else if(dp[i][j][open - close] != null){\\n            return dp[i][j][open - close];\\n        }\\n        else if(grid[i][j] == \\'(\\'){\\n            boolean res =  helper(grid, i+1, j, open+1, close, row, col) || helper(grid, i, j+1, open+1, close, row, col);\\n            dp[i][j][open - close] = res;\\n            return res;\\n        }\\n        else if( (open > close) && (grid[i][j] == \\')\\')){\\n            boolean res = helper(grid, i+1, j, open, close+1, row, col) || helper(grid, i, j+1, open, close+1, row, col);\\n            dp[i][j][open - close] = res;\\n            return res;\\n        }\\n        else{\\n            dp[i][j][open-close] = false;\\n            return false;\\n        }\\n\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018007,
                "title": "dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int vis[101][101][200], n, m;\\n    bool possible = 0;\\n    int fx[2] = {+1, +0};\\n    int fy[2] = {+0, +1};\\n    \\n    void dfs(int x, int y, int cum, vector<vector<char>>& grid) {  \\n        if (possible) return;\\n        vis[x][y][cum] = true;\\n        int sum = cum + (grid[x][y] == \\'(\\' ? 1 : -1);\\n        \\n        if (sum < 0) return ;\\n        \\n        if (x == n - 1 && y == m - 1) {\\n            possible |= (sum == 0);\\n            return ;\\n        }\\n                      \\n        for (int i = 0; i < 2; i++) {\\n            int nx = x + fx[i];\\n            int ny = y + fy[i];\\n            if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;\\n            if (!vis[nx][ny][sum]) {\\n                dfs(nx, ny, sum, grid);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dfs(0, 0, 0, grid);\\n        return possible;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int vis[101][101][200], n, m;\\n    bool possible = 0;\\n    int fx[2] = {+1, +0};\\n    int fy[2] = {+0, +1};\\n    \\n    void dfs(int x, int y, int cum, vector<vector<char>>& grid) {  \\n        if (possible) return;\\n        vis[x][y][cum] = true;\\n        int sum = cum + (grid[x][y] == \\'(\\' ? 1 : -1);\\n        \\n        if (sum < 0) return ;\\n        \\n        if (x == n - 1 && y == m - 1) {\\n            possible |= (sum == 0);\\n            return ;\\n        }\\n                      \\n        for (int i = 0; i < 2; i++) {\\n            int nx = x + fx[i];\\n            int ny = y + fy[i];\\n            if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;\\n            if (!vis[nx][ny][sum]) {\\n                dfs(nx, ny, sum, grid);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dfs(0, 0, 0, grid);\\n        return possible;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017880,
                "title": "c-dp-solution-easy-to-understand",
                "content": "```\\nint dp[100][100][101];\\n    bool findans(int x,int y,vector<vector<char> >&grid,int all){\\n        if(x==grid.size()-1&&y==grid[0].size()-1){\\n            if(all==-1){\\n                return false;\\n            }\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n            if(all+add==0){\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(all<0){\\n            return false;\\n        }\\n        if(all>100){\\n            return false;\\n        }\\n        if(dp[x][y][all]!=-1){\\n            return dp[x][y][all];\\n        }\\n        // cout<<all<<\" \"<<x<<\" \"<<y<<endl;\\n        bool ans=false,ans2=false;\\n        if(x+1<grid.size()){\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n           ans=findans(x+1,y,grid,all+add); \\n        }\\n        if(ans)return dp[x][y][all]= true;\\n        if(y+1<grid[0].size()){\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n            ans=findans(x,y+1,grid,all+add); \\n        }\\n        return dp[x][y][all]=ans;\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        return findans(0,0,grid,0);\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint dp[100][100][101];\\n    bool findans(int x,int y,vector<vector<char> >&grid,int all){\\n        if(x==grid.size()-1&&y==grid[0].size()-1){\\n            if(all==-1){\\n                return false;\\n            }\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n            if(all+add==0){\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(all<0){\\n            return false;\\n        }\\n        if(all>100){\\n            return false;\\n        }\\n        if(dp[x][y][all]!=-1){\\n            return dp[x][y][all];\\n        }\\n        // cout<<all<<\" \"<<x<<\" \"<<y<<endl;\\n        bool ans=false,ans2=false;\\n        if(x+1<grid.size()){\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n           ans=findans(x+1,y,grid,all+add); \\n        }\\n        if(ans)return dp[x][y][all]= true;\\n        if(y+1<grid[0].size()){\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n            ans=findans(x,y+1,grid,all+add); \\n        }\\n        return dp[x][y][all]=ans;\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        return findans(0,0,grid,0);\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 2017845,
                "title": "python3-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/9aa0edb0815f3e0a75a47808e1690ca424f169e5) for solutions of weekly 292. \\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def fn(i, j, v): \\n            \"\"\"Return True if value of v at (i, j) is possible.\"\"\"\\n            if i == m-1 and j == n-1: return v == 0 \\n            for ii, jj in (i+1, j), (i, j+1): \\n                if 0 <= ii < m and 0 <= jj < n: \\n                    if grid[ii][jj] == \\'(\\': vv = v+1\\n                    else: vv = v-1\\n                    if 0 <= vv <= min(ii+jj+1, m+n-ii-jj) and fn(ii, jj, vv): return True \\n            return False \\n        \\n        return fn(0, 0, 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def fn(i, j, v): \\n            \"\"\"Return True if value of v at (i, j) is possible.\"\"\"\\n            if i == m-1 and j == n-1: return v == 0 \\n            for ii, jj in (i+1, j), (i, j+1): \\n                if 0 <= ii < m and 0 <= jj < n: \\n                    if grid[ii][jj] == \\'(\\': vv = v+1\\n                    else: vv = v-1\\n                    if 0 <= vv <= min(ii+jj+1, m+n-ii-jj) and fn(ii, jj, vv): return True \\n            return False \\n        \\n        return fn(0, 0, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017770,
                "title": "recursion-memorization-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dp[101][101][502];\\npublic:\\n    bool solve(int i,int j,vector<vector<char>> &grid,int close){\\n        if(i < 0 or j < 0 or i >= grid.size() or j >= grid[0].size()) return false;\\n        if(close < 0) return false;\\n        if(i == grid.size()-1 and j == grid[0].size()-1){\\n            close += grid[i][j] == \\')\\' ? -1 : 1;\\n            return close == 0;\\n        }\\n        \\n        if(dp[i][j][close] != -1) return dp[i][j][close];\\n        \\n        int new_close = grid[i][j] == \\')\\' ? close - 1 : close + 1;\\n        \\n        bool op1 = solve(i+1,j,grid,new_close);\\n        bool op2 = solve(i,j+1,grid,new_close);\\n        \\n        return dp[i][j][close] = (op1 or op2);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\') return false;\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,0,grid,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[101][101][502];\\npublic:\\n    bool solve(int i,int j,vector<vector<char>> &grid,int close){\\n        if(i < 0 or j < 0 or i >= grid.size() or j >= grid[0].size()) return false;\\n        if(close < 0) return false;\\n        if(i == grid.size()-1 and j == grid[0].size()-1){\\n            close += grid[i][j] == \\')\\' ? -1 : 1;\\n            return close == 0;\\n        }\\n        \\n        if(dp[i][j][close] != -1) return dp[i][j][close];\\n        \\n        int new_close = grid[i][j] == \\')\\' ? close - 1 : close + 1;\\n        \\n        bool op1 = solve(i+1,j,grid,new_close);\\n        bool op2 = solve(i,j+1,grid,new_close);\\n        \\n        return dp[i][j][close] = (op1 or op2);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\') return false;\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,0,grid,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017763,
                "title": "why-recursion-is-not-working",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0]==\\')\\') return false;\\n        return path(grid,0,1,1)||path(grid,1,0,1);\\n    }\\n    public boolean path(char[][] grid,int i,int j,int cnt)\\n    {\\n        if(i>=grid.length || j>=grid[0].length) return false;\\n        if(grid[i][j]==\\')\\') cnt--;\\n        else cnt++;\\n        if(cnt<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1)\\n        {\\n            if(cnt!=0)return false;\\n            return true;\\n        }\\n        return path(grid,i+1,j,cnt)||path(grid,i,j+1,cnt);\\n    }\\n}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0]==\\')\\') return false;\\n        return path(grid,0,1,1)||path(grid,1,0,1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2017724,
                "title": "python-clean-top-down-dp-with-explanation-t-o-mn-m-n",
                "content": "A pretty straightforward while naive solution for this kind of problem would be traversing and backtracking. But since `1 <= m, n <= 100`, the naive solution has `T = O(comb(m + n - 2, m - 1))` worst-case time complexity, which is `comb(198, 99) > 2^193` in the case. That is certainly unbearable.\\n\\nWe can improve it hugely by using Dynamic Programming techniques.\\n\\nThe `DP(x, y, open_left_parentheses)` implies whether there is a valid Parentheses String Path starting from the pos `(x, y)` with some `open_left_parentheses`. \\n\\nAt every DP step, we examine the character at `grid[x][y]`:\\n\\n- If the current parenthesis is left `(`, we just increment the `open_left_parentheses` count by 1.\\n- If the current parenthesis is left `)`, we check if there are already some open left parentheses on the path so far.\\n  - If there is open `(`, we decrement the `open_left_parentheses` count by 1 to indicate the match of a pair of parentheses.\\n  - Otherwise, the current path is determined to be invalid (e.g. `)`, `()())`).\\n\\nThen we try moving downwards or rightwards if the next step is in still within borders. The DP function returns true if and only if **either** of the two direction could lead to a valid path.\\n\\n**Code:**\\n\\n```\\nfrom functools import cache\\n\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        if grid[m-1][n-1] == \"(\":\\n            return False\\n        \\n        @cache\\n        def dp(x, y, o):\\n            if x == m - 1 and y == n - 1:\\n                return o == 1 # assert grid[m-1][n-1] == \")\"\\n            if grid[x][y] == \"(\":\\n                o += 1\\n            else: # \")\"\\n                if o == 0:\\n                    return False\\n                o -= 1\\n            if x + 1 < m and dp(x + 1, y, o):\\n                return True\\n            if y + 1 < n and dp(x, y + 1, o):\\n                return True\\n            # unreachable branch\\n                \\n        return dp(0, 0, 0)\\n```\\n\\n**Time complexity:**\\n\\n`T = O(m * n * (m + n))`\\n\\n(`o` in the `DP(x, y, o)` is at most `m + n`)",
                "solutionTags": [],
                "code": "```\\nfrom functools import cache\\n\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        if grid[m-1][n-1] == \"(\":\\n            return False\\n        \\n        @cache\\n        def dp(x, y, o):\\n            if x == m - 1 and y == n - 1:\\n                return o == 1 # assert grid[m-1][n-1] == \")\"\\n            if grid[x][y] == \"(\":\\n                o += 1\\n            else: # \")\"\\n                if o == 0:\\n                    return False\\n                o -= 1\\n            if x + 1 < m and dp(x + 1, y, o):\\n                return True\\n            if y + 1 < n and dp(x, y + 1, o):\\n                return True\\n            # unreachable branch\\n                \\n        return dp(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074317,
                "title": "bitmask-bottom-up-c-bitset-and-optional",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        typedef std::bitset<100> v1_t;\\n        typedef std::optional<v1_t> v_t;\\n        int m=grid.size(),n=grid[0].size();\\n        std::vector<std::vector<v_t>> dp(m,std::vector<v_t>(n));\\n        for(auto i=0;i<m;++i)for(auto j=0;j<n;++j)\\n        {\\n            v_t v1=std::nullopt,v2=std::nullopt;\\n            auto& u=dp[i][j];\\n            if(i==0&&j==0)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=1<<1;\\n                else\\n                    return false;\\n                continue;\\n            }\\n            if(i>0)\\n                v2=dp[i-1][j];\\n            if(j>0)\\n                v1=dp[i][j-1];\\n                \\n            if(grid[i][j]==\\')\\')\\n            {\\n                if(v1&&v1->none())\\n                    v1=std::nullopt;\\n                if(v2&&v2->none())\\n                    v2=std::nullopt;\\n            }\\n            \\n            if(v1&&v2)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v1<<1|*v2<<1;\\n                else\\n                    u=*v1>>1|*v2>>1;\\n            }\\n            else if(v1)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v1<<1;\\n                else\\n                    u=*v1>>1;\\n            }\\n            else if(v2)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v2<<1;\\n                else\\n                    u=*v2>>1;\\n            }\\n            else\\n                u=std::nullopt;\\n        }\\n        auto& v=dp[m-1][n-1];\\n        if(v)\\n            return v->test(0);\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        typedef std::bitset<100> v1_t;\\n        typedef std::optional<v1_t> v_t;\\n        int m=grid.size(),n=grid[0].size();\\n        std::vector<std::vector<v_t>> dp(m,std::vector<v_t>(n));\\n        for(auto i=0;i<m;++i)for(auto j=0;j<n;++j)\\n        {\\n            v_t v1=std::nullopt,v2=std::nullopt;\\n            auto& u=dp[i][j];\\n            if(i==0&&j==0)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=1<<1;\\n                else\\n                    return false;\\n                continue;\\n            }\\n            if(i>0)\\n                v2=dp[i-1][j];\\n            if(j>0)\\n                v1=dp[i][j-1];\\n                \\n            if(grid[i][j]==\\')\\')\\n            {\\n                if(v1&&v1->none())\\n                    v1=std::nullopt;\\n                if(v2&&v2->none())\\n                    v2=std::nullopt;\\n            }\\n            \\n            if(v1&&v2)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v1<<1|*v2<<1;\\n                else\\n                    u=*v1>>1|*v2>>1;\\n            }\\n            else if(v1)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v1<<1;\\n                else\\n                    u=*v1>>1;\\n            }\\n            else if(v2)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v2<<1;\\n                else\\n                    u=*v2>>1;\\n            }\\n            else\\n                u=std::nullopt;\\n        }\\n        auto& v=dp[m-1][n-1];\\n        if(v)\\n            return v->test(0);\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002800,
                "title": "easy-peasy-c-using-recursion-memoisation-hard-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public:\\n    int m;\\n    int n;\\n    bool solve(int i , int j , int countopen , vector<vector<char>> &grid , vector<vector<vector<int>>> &dp){\\n        if(i<0 || i>=n || j<0 || j>=m) return false;\\n\\n        if(grid[i][j] == \\'(\\') countopen++;\\n\\n        else if(grid[i][j] == \\')\\') countopen--;\\n\\n        if(i == n-1 && j== m-1) return countopen==0;\\n\\n        if(countopen < 0) return false;\\n\\n        if(dp[i][j][countopen] != -1) return dp[i][j][countopen];\\n\\n        bool down = solve(i+1 , j , countopen , grid , dp);\\n        bool right = solve(i , j+1 , countopen , grid, dp);\\n\\n        return dp[i][j][countopen] = down || right;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n= grid.size();\\n        m= grid[0].size();\\n        vector<vector<vector<int>>> dp(n , vector<vector<int>>(m, vector<int>(201, -1)));\\n        return solve(0 , 0 , 0 , grid , dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    int m;\\n    int n;\\n    bool solve(int i , int j , int countopen , vector<vector<char>> &grid , vector<vector<vector<int>>> &dp){\\n        if(i<0 || i>=n || j<0 || j>=m) return false;\\n\\n        if(grid[i][j] == \\'(\\') countopen++;\\n\\n        else if(grid[i][j] == \\')\\') countopen--;\\n\\n        if(i == n-1 && j== m-1) return countopen==0;\\n\\n        if(countopen < 0) return false;\\n\\n        if(dp[i][j][countopen] != -1) return dp[i][j][countopen];\\n\\n        bool down = solve(i+1 , j , countopen , grid , dp);\\n        bool right = solve(i , j+1 , countopen , grid, dp);\\n\\n        return dp[i][j][countopen] = down || right;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n= grid.size();\\n        m= grid[0].size();\\n        vector<vector<vector<int>>> dp(n , vector<vector<int>>(m, vector<int>(201, -1)));\\n        return solve(0 , 0 , 0 , grid , dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829609,
                "title": "c-top-down-3d-dp-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m;\\n    int n;\\n    vector<vector<vector<int>>> dp; \\n    vector<pair<int,int>> dirs{{1,0},{0,1}};\\n    bool solve(vector<vector<char>>& grid,int cr,int cc,int balance){\\n        if(balance<0) return false;\\n        if(cr==m-1 && cc==n-1) return (balance==0);\\n        if(dp[cr][cc][balance]!=-1) return dp[cr][cc][balance];\\n        bool answer=false;\\n        for(auto dir : dirs){\\n            int nr=cr+dir.first;\\n            int nc=cc+dir.second;\\n            if(nr>=0 &&nr<m && nc>=0 &&nc<n)\\n                answer|=solve(grid,nr,nc,balance+(grid[nr][nc]==\\'(\\')-(grid[nr][nc]==\\')\\'));\\n            if(answer) break;\\n        }\\n        return dp[cr][cc][balance]=answer;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        dp.resize(m,vector<vector<int>>(n,vector<int>(1000,-1)));\\n        return solve(grid,0,0,0+(grid[0][0]==\\'(\\')-(grid[0][0]==\\')\\'));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m;\\n    int n;\\n    vector<vector<vector<int>>> dp; \\n    vector<pair<int,int>> dirs{{1,0},{0,1}};\\n    bool solve(vector<vector<char>>& grid,int cr,int cc,int balance){\\n        if(balance<0) return false;\\n        if(cr==m-1 && cc==n-1) return (balance==0);\\n        if(dp[cr][cc][balance]!=-1) return dp[cr][cc][balance];\\n        bool answer=false;\\n        for(auto dir : dirs){\\n            int nr=cr+dir.first;\\n            int nc=cc+dir.second;\\n            if(nr>=0 &&nr<m && nc>=0 &&nc<n)\\n                answer|=solve(grid,nr,nc,balance+(grid[nr][nc]==\\'(\\')-(grid[nr][nc]==\\')\\'));\\n            if(answer) break;\\n        }\\n        return dp[cr][cc][balance]=answer;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        dp.resize(m,vector<vector<int>>(n,vector<int>(1000,-1)));\\n        return solve(grid,0,0,0+(grid[0][0]==\\'(\\')-(grid[0][0]==\\')\\'));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823909,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(rows * cols * (rows + cols))\\n * Space Complexity: O(rows * cols * (rows + cols))\\n * where `rows` is the number of the rows of the matrix `grid`\\n *       `cols` is the number of the columns of the matrix `grid`\\n */\\nclass Solution {\\n public:\\n  bool hasValidPath(const vector<vector<char>> &grid) {\\n    constexpr int range = 2;\\n    constexpr char open = \\'(\\';\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    bool dp[range][cols][rows + cols];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0][0] = true;\\n    for (const vector<char> &row : grid) {\\n      for (int c = 0; c < cols; ++c) {\\n        const int cell = row[c] == open ? 1 : -1;\\n        for (int previous_cell = max(0, -cell); previous_cell < rows + cols; ++previous_cell) {\\n          const int current_cell = previous_cell + cell;\\n          if (dp[previous][c][previous_cell] || (c > 0 && dp[current][c - 1][previous_cell])) {\\n            dp[current][c][current_cell] = true;\\n          }\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    return dp[previous][cols - 1][0];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(rows * cols * (rows + cols))\\n * Space Complexity: O(rows * cols * (rows + cols))\\n * where `rows` is the number of the rows of the matrix `grid`\\n *       `cols` is the number of the columns of the matrix `grid`\\n */\\nclass Solution {\\n public:\\n  bool hasValidPath(const vector<vector<char>> &grid) {\\n    constexpr int range = 2;\\n    constexpr char open = \\'(\\';\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    bool dp[range][cols][rows + cols];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0][0] = true;\\n    for (const vector<char> &row : grid) {\\n      for (int c = 0; c < cols; ++c) {\\n        const int cell = row[c] == open ? 1 : -1;\\n        for (int previous_cell = max(0, -cell); previous_cell < rows + cols; ++previous_cell) {\\n          const int current_cell = previous_cell + cell;\\n          if (dp[previous][c][previous_cell] || (c > 0 && dp[current][c - 1][previous_cell])) {\\n            dp[current][c][current_cell] = true;\\n          }\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    return dp[previous][cols - 1][0];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808009,
                "title": "java-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea here is simple..Just try all possible path !\\nBut  trying all possible path using DFS **always** have repeated sub problem which results can be stored and used later when faced again!\\n\\nThe `is_visited `   is used to store whether we have visisted the cell with `open` number of open brackets. if it is true then we have vissited and the further journey will not give any valid parenthesis.\\n\\n\\nThe dp combination is no.of.open brackets possible at any moment * i*j; \\n`is_visited = new boolean[201][grid.length][grid[0].length];\\n`\\n\\nEg : is_visited[10][12][15] can be taken as When we have 5 open brackets reamining at grid[12][15] and is we have encountered the secenario or not ! ... if the is_visited[10][12][15] is `false` then we have to explore this path ..if not we have already explored and exploring the same path is unnecessary. \\n\\n\\n# Complexity\\n- Time complexity: O( (m+n) * m * n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O( (m+n) * m * n) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean[][][] is_visited ;\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] != \\'(\\' && grid[grid.length-1][grid[0].length-1] !=\\')\\') return false ;\\n        is_visited = new boolean[201][grid.length][grid[0].length];\\n        \\n        return algo(0 , 0 , grid ,0 );  \\n    }\\n    public boolean algo(int i , int j , char[][] grid , int open ){\\n        if( i>= grid.length || i< 0 || j>= grid[0].length || j<0) return false;\\n\\n        if(grid[i][j] == \\'(\\') open++; \\n        else open--;\\n        if( i== grid.length-1 && j== grid[0].length-1) {\\n            if(open != 0) return false ;\\n            return true;\\n        };\\n\\n        if(open < 0 || is_visited[open][i][j] != false) return false;\\n        //right \\n        if( algo(i+1 ,j ,grid , open)) return true;\\n        //down\\n        if(algo(i , j+1 , grid , open)) return true ;\\n        is_visited[open][i][j] = true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean[][][] is_visited ;\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] != \\'(\\' && grid[grid.length-1][grid[0].length-1] !=\\')\\') return false ;\\n        is_visited = new boolean[201][grid.length][grid[0].length];\\n        \\n        return algo(0 , 0 , grid ,0 );  \\n    }\\n    public boolean algo(int i , int j , char[][] grid , int open ){\\n        if( i>= grid.length || i< 0 || j>= grid[0].length || j<0) return false;\\n\\n        if(grid[i][j] == \\'(\\') open++; \\n        else open--;\\n        if( i== grid.length-1 && j== grid[0].length-1) {\\n            if(open != 0) return false ;\\n            return true;\\n        };\\n\\n        if(open < 0 || is_visited[open][i][j] != false) return false;\\n        //right \\n        if( algo(i+1 ,j ,grid , open)) return true;\\n        //down\\n        if(algo(i , j+1 , grid , open)) return true ;\\n        is_visited[open][i][j] = true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684064,
                "title": "c-recursive-solution",
                "content": "# Intuition\\nCan br done by recursive function because we have to check all cases.\\nSince overlapping subproblems are here, thus we can use DP \\n\\n# Approach\\n1. if m+n is even then length od string will be odd and that can\\'t be valid\\n2. In anywhere path if opening bracket numbers fall below zero, is also invalid path\\n3. if opening bracket number goes above (m+n)/2, this will be also invalid path.\\n4. if first char is \\')\\' or last char is \\'(\\', this will be also discarded\\n5. take or of both the cases (right and down).\\n6. memoise it vith 3-D dp array\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(vector<vector<char>>& grid, int i, int j, int m , int n, int open, vector<vector<vector<int>>> &dp){\\n        if(i==n-1 && j==m-1 ){\\n            if(open==0) return true;\\n            return false;\\n        } \\n        if(open<0 || open>(m+n)/2) return false;\\n\\n        if(dp[i][j][open]!=-1) return dp[i][j][open];\\n        bool a=false, b=false;\\n        if(j<m-1){\\n            if(grid[i][j+1]==\\'(\\') a=f(grid, i, j+1, m, n, open+1, dp);\\n            else a=f(grid, i, j+1, m, n, open-1, dp);\\n        }\\n        if(i<n-1){\\n            if(grid[i+1][j]==\\'(\\') b=f(grid, i+1, j, m, n, open+1, dp);\\n            else b=f(grid, i+1, j, m, n, open-1, dp);\\n        }\\n\\n        return dp[i][j][open]= a||b;\\n        \\n\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if((m+n)%2==0) return false;\\n        if(grid[0][0]==\\')\\' || grid[n-1][m-1]==\\'(\\') return false;\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m, vector<int>((m+n)/2+1, -1)));\\n        return f(grid, 0,0,m, n, 1, dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<vector<char>>& grid, int i, int j, int m , int n, int open, vector<vector<vector<int>>> &dp){\\n        if(i==n-1 && j==m-1 ){\\n            if(open==0) return true;\\n            return false;\\n        } \\n        if(open<0 || open>(m+n)/2) return false;\\n\\n        if(dp[i][j][open]!=-1) return dp[i][j][open];\\n        bool a=false, b=false;\\n        if(j<m-1){\\n            if(grid[i][j+1]==\\'(\\') a=f(grid, i, j+1, m, n, open+1, dp);\\n            else a=f(grid, i, j+1, m, n, open-1, dp);\\n        }\\n        if(i<n-1){\\n            if(grid[i+1][j]==\\'(\\') b=f(grid, i+1, j, m, n, open+1, dp);\\n            else b=f(grid, i+1, j, m, n, open-1, dp);\\n        }\\n\\n        return dp[i][j][open]= a||b;\\n        \\n\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if((m+n)%2==0) return false;\\n        if(grid[0][0]==\\')\\' || grid[n-1][m-1]==\\'(\\') return false;\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m, vector<int>((m+n)/2+1, -1)));\\n        return f(grid, 0,0,m, n, 1, dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670177,
                "title": "why-it-should-be-dp-not-a-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nI got tons of TLE with Backtracking and Passed after add memoizaion\\n\\nSure, I used params as dp way, shrink parmas size and limit string\\'s size (Like minus when `)` comes)\\n\\nBut as i thought, it doesn\\'t matter with DP or DFS, cause all the cases could be feed-forward `Right Or Down` and it\\'s constraints is `M*N <= 10**4`\\n\\nAnyone knows why it should be DP ?\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] != \"(\" or grid[-1][-1] != \")\":\\n            return False\\n        \\n        dp = defaultdict(lambda : -1)\\n\\n        \\n        def backtracking(i,j, stack):\\n            if dp[(i,j, stack)] != -1:\\n                return dp[(i,j, stack)]\\n            \\n            if i == m-1 and j == n-1:\\n                if len(stack)==0:\\n                    dp[(i,j, stack)]= True\\n                    return True\\n                dp[(i,j, stack)] = False\\n                return False\\n            \\n            \\n            if i+1 < m:\\n                if len(stack) and grid[i+1][j] == \")\":\\n                    if backtracking(i+1, j, stack[:-1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n                elif (len(stack) == 0 and grid[i+1][j] != \")\" ) or grid[i+1][j] == \"(\":\\n                    if backtracking(i+1, j, stack+grid[i+1][j]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n\\n            if j+1 < n:\\n                if len(stack) and grid[i][j+1] == \")\":\\n                    if backtracking(i, j+1, stack[:-1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n                elif (len(stack) == 0 and grid[i][j+1] != \")\" )  or grid[i][j+1] == \"(\":\\n                    if backtracking(i, j+1, stack+grid[i][j+1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n            dp[(i,j, stack)]= False\\n            return False\\n        \\n        return backtracking(0,0, grid[0][0])\\n                \\n\\n                \\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] != \"(\" or grid[-1][-1] != \")\":\\n            return False\\n        \\n        dp = defaultdict(lambda : -1)\\n\\n        \\n        def backtracking(i,j, stack):\\n            if dp[(i,j, stack)] != -1:\\n                return dp[(i,j, stack)]\\n            \\n            if i == m-1 and j == n-1:\\n                if len(stack)==0:\\n                    dp[(i,j, stack)]= True\\n                    return True\\n                dp[(i,j, stack)] = False\\n                return False\\n            \\n            \\n            if i+1 < m:\\n                if len(stack) and grid[i+1][j] == \")\":\\n                    if backtracking(i+1, j, stack[:-1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n                elif (len(stack) == 0 and grid[i+1][j] != \")\" ) or grid[i+1][j] == \"(\":\\n                    if backtracking(i+1, j, stack+grid[i+1][j]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n\\n            if j+1 < n:\\n                if len(stack) and grid[i][j+1] == \")\":\\n                    if backtracking(i, j+1, stack[:-1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n                elif (len(stack) == 0 and grid[i][j+1] != \")\" )  or grid[i][j+1] == \"(\":\\n                    if backtracking(i, j+1, stack+grid[i][j+1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n            dp[(i,j, stack)]= False\\n            return False\\n        \\n        return backtracking(0,0, grid[0][0])\\n                \\n\\n                \\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650686,
                "title": "simple-fast-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        dp = defaultdict(set)\\n        dp[0, -1] = dp[-1, 0] = {0}\\n        for i in range(m):\\n            for j in range(n):\\n                d = 1 if A[i][j] == \\'(\\' else -1\\n                dp[i,j] |= {a + d for a in dp[i-1,j] | dp[i,j-1] if a + d >= 0}\\n        return 0 in dp[m - 1, n - 1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        dp = defaultdict(set)\\n        dp[0, -1] = dp[-1, 0] = {0}\\n        for i in range(m):\\n            for j in range(n):\\n                d = 1 if A[i][j] == \\'(\\' else -1\\n                dp[i,j] |= {a + d for a in dp[i-1,j] | dp[i,j-1] if a + d >= 0}\\n        return 0 in dp[m - 1, n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644364,
                "title": "dp-with-sets",
                "content": "# Intuition\\n\\nEach path can be described by a walk $S$ on integers. If the the path goes through a field of the grid containing `\\'(\\'` then the walk steps up otherwise down. \\nSo $S_k$ is the difference of the opening and closing parantheses among the first $k$ element of the path.\\n\\nA path is valid if $S$ stays on the non-negative half-line.\\n\\n \\nFor each position in the grid let `dp[i][j]` be the set of final positions of possible valid paths connecting `0,0` and `i,j`.\\n\\nThe answer is `true` if $0\\\\in \\\\text{dp}_{m-1,n-1}$ and `false` otherwise.\\n\\nThe relation for computing `dp` is\\n$$\\n    \\\\text{dp}_{i,j} = \\\\{p+d\\\\colon p \\\\in \\\\text{dp}_{i-1, j}\\\\cup \\\\text{dp}_{i, j-1}\\\\}, \\\\quad\\\\text{where $d=\\\\pm1$ depending on  $\\\\text{grid}_{i,j}$}\\n$$\\n\\n# Complexity\\n- Time complexity: $$O(m*n*(m+n))$$, where $(m,n)$ is the size of the grid\\n\\n- Space complexity: $$O(n*(m+n))$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n\\n        if (m+n)&1==0 or grid[0][0]!=\"(\" or grid[-1][-1]!=\")\":\\n            return False\\n\\n        dp = [{0}] + [set() for _ in range(1, n)]\\n        for i in range(m):\\n            prev_set = set()\\n            all_empty = True\\n            for j in range(n):\\n                d = 1 if grid[i][j] == \"(\" else -1\\n                max_pos = n-j+m-i-2\\n                prev_set = {pos + d for pos in prev_set.union(dp[j]) if 0 <= pos + d <= max_pos}\\n                dp[j] = prev_set\\n                if prev_set:\\n                    all_empty = False\\n            if all_empty:\\n                return False\\n        return 0 in dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n\\n        if (m+n)&1==0 or grid[0][0]!=\"(\" or grid[-1][-1]!=\")\":\\n            return False\\n\\n        dp = [{0}] + [set() for _ in range(1, n)]\\n        for i in range(m):\\n            prev_set = set()\\n            all_empty = True\\n            for j in range(n):\\n                d = 1 if grid[i][j] == \"(\" else -1\\n                max_pos = n-j+m-i-2\\n                prev_set = {pos + d for pos in prev_set.union(dp[j]) if 0 <= pos + d <= max_pos}\\n                dp[j] = prev_set\\n                if prev_set:\\n                    all_empty = False\\n            if all_empty:\\n                return False\\n        return 0 in dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604560,
                "title": "c-bottomup-dp",
                "content": "```\\npublic class Solution {\\n    int MIN=-9999;\\n    public bool HasValidPath(char[][] grid) {\\n        int n=grid.Length; int m=grid[0].Length;\\n        HashSet<int>[] dp=new  HashSet<int>[m];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                HashSet<int> hs=new HashSet<int>();\\n                int t=grid[i][j] == \\'(\\' ? 1 :-1;\\n                if(i>0){\\n                    foreach(int s in dp[j])\\n                        if(s+t>=0) hs.Add(s+t);\\n                }\\n                \\n                if(j>0){\\n                    foreach(int s in dp[j-1])\\n                        if(s+t>=0)  hs.Add(s+t);\\n                }\\n                if(i==0 && j==0)\\n                    if(t>0 ) hs.Add(t); else return false;\\n                \\n                if(hs.Count==0)\\n                    hs.Add(MIN);\\n                \\n                dp[j]=hs;\\n                \\n            }\\n            \\n        }\\n        \\n        foreach(int s in dp[m-1])\\n            if(s==0)\\n                return true;\\n        \\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int MIN=-9999;\\n    public bool HasValidPath(char[][] grid) {\\n        int n=grid.Length; int m=grid[0].Length;\\n        HashSet<int>[] dp=new  HashSet<int>[m];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                HashSet<int> hs=new HashSet<int>();\\n                int t=grid[i][j] == \\'(\\' ? 1 :-1;\\n                if(i>0){\\n                    foreach(int s in dp[j])\\n                        if(s+t>=0) hs.Add(s+t);\\n                }\\n                \\n                if(j>0){\\n                    foreach(int s in dp[j-1])\\n                        if(s+t>=0)  hs.Add(s+t);\\n                }\\n                if(i==0 && j==0)\\n                    if(t>0 ) hs.Add(t); else return false;\\n                \\n                if(hs.Count==0)\\n                    hs.Add(MIN);\\n                \\n                dp[j]=hs;\\n                \\n            }\\n            \\n        }\\n        \\n        foreach(int s in dp[m-1])\\n            if(s==0)\\n                return true;\\n        \\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594206,
                "title": "python-easy-pfs",
                "content": "# bfs solution\\n  bfs solution but a bit slow \\n```\\nclass Solution(object):\\n    def hasValidPath(self, grid):\\n      #get number of rows and columns \\n      r,n=len(grid),len(grid[0])\\n      #start point     \\n      i,j=0,0 \\n      #direction down ,right   \\n      directions=[(1,0),(0,1)]\\n      #quick failure test cases \\n      if grid[0][0]==\")\": return False\\n      if grid[-1][-1]==\"(\": return False\\n      if (r+n)%2==0: return False     \\n      visited=set()\\n      # x,y,number of barenthese \\n      queue=[[i,j,0]]\\n      while queue:\\n        i,j,num=queue.pop(0)\\n        num+=1 if grid[i][j]==\"(\" else -1\\n        if i==r-1 and j==n-1 and not num:\\n            return True\\n        for x,y in  directions:\\n          next_x,next_y=x+i,j+y\\n          if 0<=next_x<r and 0<=next_y<n and num>=0 and (next_x,next_y,num) not in s:\\n              queue.append([next_x,next_y,num])\\n              s.add((next_x,next_y,num))\\n      return False\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def hasValidPath(self, grid):\\n      #get number of rows and columns \\n      r,n=len(grid),len(grid[0])\\n      #start point     \\n      i,j=0,0 \\n      #direction down ,right   \\n      directions=[(1,0),(0,1)]\\n      #quick failure test cases \\n      if grid[0][0]==\")\": return False\\n      if grid[-1][-1]==\"(\": return False\\n      if (r+n)%2==0: return False     \\n      visited=set()\\n      # x,y,number of barenthese \\n      queue=[[i,j,0]]\\n      while queue:\\n        i,j,num=queue.pop(0)\\n        num+=1 if grid[i][j]==\"(\" else -1\\n        if i==r-1 and j==n-1 and not num:\\n            return True\\n        for x,y in  directions:\\n          next_x,next_y=x+i,j+y\\n          if 0<=next_x<r and 0<=next_y<n and num>=0 and (next_x,next_y,num) not in s:\\n              queue.append([next_x,next_y,num])\\n              s.add((next_x,next_y,num))\\n      return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453294,
                "title": "java-o-m-n-m-n-c-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntotal forward and backward bracket in a valid path will be (M+N)/2 each.\\nincrease variable sum when forward bracket comes and add backward only when sum is greater than 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int M,N, MID;\\n    Boolean[][][] dp;\\n    public boolean hasValidPath(char[][] grid) {\\n        M = grid.length;\\n        N = grid[0].length;\\n        MID = (M+N)/2;\\n        dp = new Boolean[M][N][MID+1];\\n        return rec(0, 0, grid, 0);\\n    }\\n\\n    boolean rec(int i, int j, char[][] grid, int sum) {\\n        if(i==M-1 && j==N-1) {\\n            if(sum==1 && grid[i][j]==\\')\\') {\\n                return true;\\n            }\\n            return false;\\n        }\\n        \\n        if(dp[i][j][sum]!=null)\\n        return dp[i][j][sum];\\n\\n        boolean ans = false;\\n        if(grid[i][j]==\\'(\\' && sum<MID) {\\n            if(i<M-1)\\n            ans = ans || rec(i+1,j, grid, sum+1);\\n            if(j<N-1)\\n            ans = ans || rec(i, j+1, grid, sum+1);\\n        } else if(grid[i][j]==\\')\\' && sum>0){\\n            if(i<M-1)\\n            ans = ans || rec(i+1,j, grid, sum-1);\\n            if(j<N-1)\\n            ans = ans || rec(i, j+1, grid, sum-1);\\n        }\\n        dp[i][j][sum]=ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int M,N, MID;\\n    Boolean[][][] dp;\\n    public boolean hasValidPath(char[][] grid) {\\n        M = grid.length;\\n        N = grid[0].length;\\n        MID = (M+N)/2;\\n        dp = new Boolean[M][N][MID+1];\\n        return rec(0, 0, grid, 0);\\n    }\\n\\n    boolean rec(int i, int j, char[][] grid, int sum) {\\n        if(i==M-1 && j==N-1) {\\n            if(sum==1 && grid[i][j]==\\')\\') {\\n                return true;\\n            }\\n            return false;\\n        }\\n        \\n        if(dp[i][j][sum]!=null)\\n        return dp[i][j][sum];\\n\\n        boolean ans = false;\\n        if(grid[i][j]==\\'(\\' && sum<MID) {\\n            if(i<M-1)\\n            ans = ans || rec(i+1,j, grid, sum+1);\\n            if(j<N-1)\\n            ans = ans || rec(i, j+1, grid, sum+1);\\n        } else if(grid[i][j]==\\')\\' && sum>0){\\n            if(i<M-1)\\n            ans = ans || rec(i+1,j, grid, sum-1);\\n            if(j<N-1)\\n            ans = ans || rec(i, j+1, grid, sum-1);\\n        }\\n        dp[i][j][sum]=ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439212,
                "title": "add-a-little-pruning-for-the-dp-solution-to-make-it-a-little-bit-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObservations:\\n1. if grid[0][0] == \")\" or grid[-1][-1] == \"(\", it would not work--> False\\n2. The total number of items in the path would be row + col -1. This number has to be even in order for the parenthese to be valid.\\n3. Using dp set, use defaultdict(set) is much faster\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn*(m + n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n \\n        row, col = len(grid), len(grid[0])\\n        if grid[0][0] == \")\" or grid[-1][-1] == \"(\" or (row + col - 1) % 2:\\n            return False\\n\\n        dp = defaultdict(set)\\n        dp[0, 0] = {1}\\n\\n        for r in range(row):\\n            for c in range(col):\\n                sign = 1 if grid[r][c] == \"(\" else -1\\n                dp[r, c] |= set([val + sign  for val in dp[(r -1, c)] | dp[(r, c- 1)] if val + sign >= 0])\\n        \\n        return 0 in dp[(row-1, col -1)]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n \\n        row, col = len(grid), len(grid[0])\\n        if grid[0][0] == \")\" or grid[-1][-1] == \"(\" or (row + col - 1) % 2:\\n            return False\\n\\n        dp = defaultdict(set)\\n        dp[0, 0] = {1}\\n\\n        for r in range(row):\\n            for c in range(col):\\n                sign = 1 if grid[r][c] == \"(\" else -1\\n                dp[r, c] |= set([val + sign  for val in dp[(r -1, c)] | dp[(r, c- 1)] if val + sign >= 0])\\n        \\n        return 0 in dp[(row-1, col -1)]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437743,
                "title": "java-easy-to-understand-dfs-dp",
                "content": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    private boolean solve(char[][] grid, int i, int j, int path){\\n        if(i == grid.length || j == grid[0].length) return false;\\n        path += (grid[i][j] == \\'(\\' ? 1 : -1);\\n        if(i == grid.length - 1 && j == grid[0].length - 1)\\n            return path == 0;\\n        if(path < 0) return false;\\n        if(dp[i][j][path] != null) return dp[i][j][path];\\n        return dp[i][j][path] = solve(grid, i + 1, j, path) || solve(grid, i, j + 1, path);\\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        dp = new Boolean[grid.length][grid[0].length][210];\\n        return solve(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    private boolean solve(char[][] grid, int i, int j, int path){\\n        if(i == grid.length || j == grid[0].length) return false;\\n        path += (grid[i][j] == \\'(\\' ? 1 : -1);\\n        if(i == grid.length - 1 && j == grid[0].length - 1)\\n            return path == 0;\\n        if(path < 0) return false;\\n        if(dp[i][j][path] != null) return dp[i][j][path];\\n        return dp[i][j][path] = solve(grid, i + 1, j, path) || solve(grid, i, j + 1, path);\\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        dp = new Boolean[grid.length][grid[0].length][210];\\n        return solve(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386251,
                "title": "bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if(grid[0][0] == \\')\\' || grid[n-1][m-1] == \\'(\\'){\\n            return false;\\n        }\\n        \\n        // \\'(\\' -> + 1\\n        // \\')\\' -> -1\\n        vector<vector<vector<bool>>> dp(n,vector<vector<bool>> (m,vector<bool> (203,false)));\\n        \\n        dp[0][0][1] = true;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0){\\n                    continue;\\n                }\\n                \\n                for(int k=0;k<202;k++){\\n                    if(i>0){\\n                        if(grid[i][j] == \\'(\\'){\\n                            if(k>0){\\n                               dp[i][j][k] = dp[i][j][k] | dp[i-1][j][k-1]; \\n                            }\\n                        }else{\\n                            dp[i][j][k] = dp[i][j][k] | dp[i-1][j][k+1];\\n                        }\\n                        \\n                    }\\n                    if(j>0){\\n                        if(grid[i][j] == \\'(\\'){\\n                            if(k>0){\\n                               dp[i][j][k] = dp[i][j][k] | dp[i][j-1][k-1]; \\n                            }\\n                        }else{\\n                            dp[i][j][k] = dp[i][j][k] | dp[i][j-1][k+1];\\n                        }\\n                    }\\n                        \\n                }\\n                \\n            }\\n        }\\n        return dp[n-1][m-1][0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if(grid[0][0] == \\')\\' || grid[n-1][m-1] == \\'(\\'){\\n            return false;\\n        }\\n        \\n        // \\'(\\' -> + 1\\n        // \\')\\' -> -1\\n        vector<vector<vector<bool>>> dp(n,vector<vector<bool>> (m,vector<bool> (203,false)));\\n        \\n        dp[0][0][1] = true;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0){\\n                    continue;\\n                }\\n                \\n                for(int k=0;k<202;k++){\\n                    if(i>0){\\n                        if(grid[i][j] == \\'(\\'){\\n                            if(k>0){\\n                               dp[i][j][k] = dp[i][j][k] | dp[i-1][j][k-1]; \\n                            }\\n                        }else{\\n                            dp[i][j][k] = dp[i][j][k] | dp[i-1][j][k+1];\\n                        }\\n                        \\n                    }\\n                    if(j>0){\\n                        if(grid[i][j] == \\'(\\'){\\n                            if(k>0){\\n                               dp[i][j][k] = dp[i][j][k] | dp[i][j-1][k-1]; \\n                            }\\n                        }else{\\n                            dp[i][j][k] = dp[i][j][k] | dp[i][j-1][k+1];\\n                        }\\n                    }\\n                        \\n                }\\n                \\n            }\\n        }\\n        return dp[n-1][m-1][0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295403,
                "title": "easy-dfs-dp-solution-approach-cpp",
                "content": "# Intuition and Approach\\n* write simple dfs recursion for traversing.\\n* for valid parenthessis string keep a variable which is initialize from zero.it will increse by 1 if current cell char is \\'(\\' and decrease by 1 if current cell char is \\')\\'.\\n* whenever u find this variable becomes negative return false. because there must be one open bracket before we include one close bracket.\\n* if you reach to bottom right and your variable is zero then return true else return false.\\n* short your dfs calls by using or gate.\\n* take care of index if it goes beyond bounds.\\n* prepare a 3d dp array of size rows x cols x (rows+cols+1).\\n* (rows+ cols)==> for the variable which we initialize from zero. its max value is row + cols, because this is max no of moves to reach bottom right from top left.\\n* keep ans in dp whenever calculated before returning.\\n* check ans in dp before entering recursion.  \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check (vector<vector<char>>& grid,int m,int n,int i,int j,int flag,vector<vector<vector<int>>>& dp){\\n        \\n        if(flag<0 || i>=m || j>=n)return false;\\n        if(dp[i][j][flag]!=-1)return dp[i][j][flag];\\n        int temp=flag;\\n        if(grid[i][j]==\\'(\\')flag++;\\n        else flag--;\\n        if(i==m-1 && j==n-1){\\n            if(flag==0)return true;\\n            else return false;\\n        }\\n        \\n        return dp[i][j][temp]=(check(grid,m,n,i+1,j,flag,dp) || check(grid,m,n,i,j+1,flag,dp));\\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int k=(m+n+10);\\n        int flag=0;\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n        return check(grid,grid.size(),grid[0].size(),0,0,flag,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check (vector<vector<char>>& grid,int m,int n,int i,int j,int flag,vector<vector<vector<int>>>& dp){\\n        \\n        if(flag<0 || i>=m || j>=n)return false;\\n        if(dp[i][j][flag]!=-1)return dp[i][j][flag];\\n        int temp=flag;\\n        if(grid[i][j]==\\'(\\')flag++;\\n        else flag--;\\n        if(i==m-1 && j==n-1){\\n            if(flag==0)return true;\\n            else return false;\\n        }\\n        \\n        return dp[i][j][temp]=(check(grid,m,n,i+1,j,flag,dp) || check(grid,m,n,i,j+1,flag,dp));\\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int k=(m+n+10);\\n        int flag=0;\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n        return check(grid,grid.size(),grid[0].size(),0,0,flag,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236615,
                "title": "very-to-understand-simple-dfs-memoization",
                "content": "# Code\\n```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>>dp;\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        //initializing the dp form memoization\\n        dp.resize(grid.size()+1,vector<vector<int>>(grid[0].size()+1,vector<int>(205,-1)));\\n\\n        //row and col for traversing the grid\\n        int row = 0;\\n        int col = 0;\\n        \\n        //mainitng a variable to keep the track of the open and the close bracket\\n        int k = 0;\\n\\n        //fun function will return if there exist any path from top to bottom with valid vps\\n        return fun(grid,row,col,k);    \\n    }\\n    int fun(vector<vector<char>>&grid,int row,int col,int k)\\n    {\\n          if(row<0 or row>=grid.size() or col<0 or col>=grid[0].size())\\n          {\\n              return false;\\n          }\\n\\n          if(grid[row][col] == \\'(\\')\\n          {\\n              k++;\\n          }      \\n          else if(grid[row][col] == \\')\\')\\n          {\\n              k--;\\n          }\\n\\n          if(k < 0) //no of cloing brackets are now more than no of opening brackets return flase\\n          return false;\\n\\n          if(row == grid.size()-1 and col == grid[0].size()-1)   //if we reach the destination\\n          {\\n                if(k > 0)  //this means no of opening are more than closing \\n                return false;\\n\\n                if(k == 0)  //this means all the brackets are balances\\n                return true;\\n\\n                if(k < 0)   //no of closing brackets are more than no of opening brackets\\n                return false;\\n          }\\n          \\n          //if the state is currently computed\\n          if(dp[row][col][k]!=-1)\\n          return dp[row][col][k];\\n     \\n          //checking all the possibility \\n          int choise1 = fun(grid,row+1,col,k);\\n          int choise2 = fun(grid,row,col+1,k);\\n\\n          return dp[row][col][k] = choise1 or choise2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>>dp;\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        //initializing the dp form memoization\\n        dp.resize(grid.size()+1,vector<vector<int>>(grid[0].size()+1,vector<int>(205,-1)));\\n\\n        //row and col for traversing the grid\\n        int row = 0;\\n        int col = 0;\\n        \\n        //mainitng a variable to keep the track of the open and the close bracket\\n        int k = 0;\\n\\n        //fun function will return if there exist any path from top to bottom with valid vps\\n        return fun(grid,row,col,k);    \\n    }\\n    int fun(vector<vector<char>>&grid,int row,int col,int k)\\n    {\\n          if(row<0 or row>=grid.size() or col<0 or col>=grid[0].size())\\n          {\\n              return false;\\n          }\\n\\n          if(grid[row][col] == \\'(\\')\\n          {\\n              k++;\\n          }      \\n          else if(grid[row][col] == \\')\\')\\n          {\\n              k--;\\n          }\\n\\n          if(k < 0) //no of cloing brackets are now more than no of opening brackets return flase\\n          return false;\\n\\n          if(row == grid.size()-1 and col == grid[0].size()-1)   //if we reach the destination\\n          {\\n                if(k > 0)  //this means no of opening are more than closing \\n                return false;\\n\\n                if(k == 0)  //this means all the brackets are balances\\n                return true;\\n\\n                if(k < 0)   //no of closing brackets are more than no of opening brackets\\n                return false;\\n          }\\n          \\n          //if the state is currently computed\\n          if(dp[row][col][k]!=-1)\\n          return dp[row][col][k];\\n     \\n          //checking all the possibility \\n          int choise1 = fun(grid,row+1,col,k);\\n          int choise2 = fun(grid,row,col+1,k);\\n\\n          return dp[row][col][k] = choise1 or choise2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3131177,
                "title": "c-dp-recursive-fast-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<vector<int>>> &dp, vector<vector<char>> &grid, int i, int j, int open)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        if(open < 0)return false;\\n        if(dp[i][j][open]!=-1)return dp[i][j][open];\\n        if(i == n-1 && j == m-1)\\n        {\\n            if(grid[i][j] == \\')\\' && open == 1)return dp[i][j][open] = true;\\n            return dp[i][j][open] = false;\\n        }\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\')\\n        {\\n            if(i+1 < n)ans = ans | solve(dp, grid, i+1, j, open+1);\\n            if(j+1 < m)ans = ans | solve(dp, grid, i, j+1, open+1);\\n        }\\n        else\\n        {\\n            if(i+1 < n)ans = ans | solve(dp, grid, i+1, j, open-1);\\n            if(j+1 < m)ans = ans | solve(dp, grid, i, j+1, open-1);\\n        }\\n        return dp[i][j][open] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid){\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (m, vector<int> (m+n, -1)));\\n        return solve(dp, grid, 0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<vector<int>>> &dp, vector<vector<char>> &grid, int i, int j, int open)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        if(open < 0)return false;\\n        if(dp[i][j][open]!=-1)return dp[i][j][open];\\n        if(i == n-1 && j == m-1)\\n        {\\n            if(grid[i][j] == \\')\\' && open == 1)return dp[i][j][open] = true;\\n            return dp[i][j][open] = false;\\n        }\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\')\\n        {\\n            if(i+1 < n)ans = ans | solve(dp, grid, i+1, j, open+1);\\n            if(j+1 < m)ans = ans | solve(dp, grid, i, j+1, open+1);\\n        }\\n        else\\n        {\\n            if(i+1 < n)ans = ans | solve(dp, grid, i+1, j, open-1);\\n            if(j+1 < m)ans = ans | solve(dp, grid, i, j+1, open-1);\\n        }\\n        return dp[i][j][open] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid){\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (m, vector<int> (m+n, -1)));\\n        return solve(dp, grid, 0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030477,
                "title": "best-optimised-c-coolution-please-upvote-if-u-like-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*M)+O(N+M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int n, m;\\n    bool solve(int x, int y, int open, vector<vector<char>>& grid, vector<vector<vector<int>>> &dp)\\n    {\\n        if(x >= n || y >= m) return false;\\n        if(grid[x][y] == \\'(\\')\\n            open++;\\n        else\\n            open--;\\n        if(open < 0)\\n            return false;\\n        if(dp[x][y][open] != -1)\\n            return dp[x][y][open];\\n        if(x == n-1 && y == m-1)\\n        {\\n           return open==0;\\n        }\\n        bool ans = solve(x+1, y, open, grid, dp) ||solve(x, y+1, open, grid, dp);\\n        return dp[x][y][open] = ans;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>> (m+1, vector<int> (201, -1)));\\n        return solve(0,0,0,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Stack",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int n, m;\\n    bool solve(int x, int y, int open, vector<vector<char>>& grid, vector<vector<vector<int>>> &dp)\\n    {\\n        if(x >= n || y >= m) return false;\\n        if(grid[x][y] == \\'(\\')\\n            open++;\\n        else\\n            open--;\\n        if(open < 0)\\n            return false;\\n        if(dp[x][y][open] != -1)\\n            return dp[x][y][open];\\n        if(x == n-1 && y == m-1)\\n        {\\n           return open==0;\\n        }\\n        bool ans = solve(x+1, y, open, grid, dp) ||solve(x, y+1, open, grid, dp);\\n        return dp[x][y][open] = ans;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>> (m+1, vector<int> (201, -1)));\\n        return solve(0,0,0,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019025,
                "title": "dfs-dp",
                "content": "# Intuition\\nsimple DP+DFS;\\n\\n# Approach\\nApply DFS and memoize all the places and count k which is count of \\'(\\' if current position in \\'(\\' then k++ else k--. if it goes to end and k==0 then we get a valid  parenthesis path other wise not a valid parenthesis;\\n\\n# Complexity\\n- Time complexity:\\nO(n*m*k);\\n\\n- Space complexity:\\no(n*m);\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[100][100][205];\\n    int n,m;\\n    bool getSolution(vector<vector<char>>& grid , int i, int j , int k){\\n        if(i>=n|| j>=m){\\n            return false;\\n        }\\n        if(grid[i][j]==\\'(\\'){\\n            k++;\\n        }\\n        else{\\n            k--;\\n        }\\n        if(k<0){\\n            return false;\\n        }\\n        if(i==(n-1)&&j==(m-1)){\\n            return k==0;\\n        }\\n        int &ans=dp[i][j][k];\\n        if(ans!=-1){\\n            return ans;\\n        }\\n        return ans = getSolution(grid,i+1,j,k)| getSolution(grid,i,j+1,k);  \\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n    memset(dp,-1,sizeof(dp));\\n    return getSolution(grid,0,0,0);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100][100][205];\\n    int n,m;\\n    bool getSolution(vector<vector<char>>& grid , int i, int j , int k){\\n        if(i>=n|| j>=m){\\n            return false;\\n        }\\n        if(grid[i][j]==\\'(\\'){\\n            k++;\\n        }\\n        else{\\n            k--;\\n        }\\n        if(k<0){\\n            return false;\\n        }\\n        if(i==(n-1)&&j==(m-1)){\\n            return k==0;\\n        }\\n        int &ans=dp[i][j][k];\\n        if(ans!=-1){\\n            return ans;\\n        }\\n        return ans = getSolution(grid,i+1,j,k)| getSolution(grid,i,j+1,k);  \\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n    memset(dp,-1,sizeof(dp));\\n    return getSolution(grid,0,0,0);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975133,
                "title": "python3-java-top-down-dp",
                "content": "```\\nPython3\\n\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m,n = len(grid),len(grid[0])\\n        @cache\\n        def dp(r,c,k):\\n            if r == m or c == n:\\n                return False\\n            if grid[r][c] == \"(\":\\n                k += 1\\n            else:\\n                k -= 1\\n            if k < 0:\\n                return False\\n            if r == m-1 and c == n-1:\\n                return k == 0\\n            return dp(r+1,c,k) or dp(r,c+1,k)\\n        return dp(0,0,0)\\n```\\n```\\nJava\\n\\nclass Solution {\\n    int m,n;\\n    Boolean[][][] dp = new Boolean[100][100][200];\\n    public boolean dfs(int r,int c,int k,char[][] grid){\\n        if( r == m || c == n){\\n            return false;\\n        }\\n        if (grid[r][c] == \\'(\\'){\\n            k++;\\n        }\\n        else{\\n            k--;\\n        }\\n        if( k < 0){\\n            return false;\\n        }\\n        if (r == m - 1 && c == n - 1){\\n            return k == 0 ? true : false;\\n        }\\n        if (dp[r][c][k] != null){\\n            return dp[r][c][k];\\n        }\\n        return dp[r][c][k] = dfs(r+1,c,k,grid) || dfs(r,c+1,k,grid);\\n        \\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        m = grid.length ; n = grid[0].length;\\n        return dfs(0,0,0,grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nPython3\\n\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m,n = len(grid),len(grid[0])\\n        @cache\\n        def dp(r,c,k):\\n            if r == m or c == n:\\n                return False\\n            if grid[r][c] == \"(\":\\n                k += 1\\n            else:\\n                k -= 1\\n            if k < 0:\\n                return False\\n            if r == m-1 and c == n-1:\\n                return k == 0\\n            return dp(r+1,c,k) or dp(r,c+1,k)\\n        return dp(0,0,0)\\n```\n```\\nJava\\n\\nclass Solution {\\n    int m,n;\\n    Boolean[][][] dp = new Boolean[100][100][200];\\n    public boolean dfs(int r,int c,int k,char[][] grid){\\n        if( r == m || c == n){\\n            return false;\\n        }\\n        if (grid[r][c] == \\'(\\'){\\n            k++;\\n        }\\n        else{\\n            k--;\\n        }\\n        if( k < 0){\\n            return false;\\n        }\\n        if (r == m - 1 && c == n - 1){\\n            return k == 0 ? true : false;\\n        }\\n        if (dp[r][c][k] != null){\\n            return dp[r][c][k];\\n        }\\n        return dp[r][c][k] = dfs(r+1,c,k,grid) || dfs(r,c+1,k,grid);\\n        \\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        m = grid.length ; n = grid[0].length;\\n        return dfs(0,0,0,grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957808,
                "title": "3d-dynamic-programming-c-fast-simple-clean-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[101][101][201];\\n\\n    ll solve(vector<vector<char>>&grid,ll i,ll j,ll count,ll n,ll m){\\n        if(i==n-1 && j==m-1){\\n            if(grid[i][j]==\\'(\\' || count!=1){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        if(dp[i][j][count]!=-1){\\n            return dp[i][j][count];\\n        }\\n        bool answer=0;\\n        if(i+1<n){\\n            if(grid[i][j]==\\'(\\'){\\n                answer+=solve(grid,i+1,j,count+1,n,m);\\n            }\\n            else if(count>0){\\n                answer+=solve(grid,i+1,j,count-1,n,m);\\n            }\\n        }\\n        if(j+1<m){\\n            if(grid[i][j]==\\'(\\'){\\n                answer+=solve(grid,i,j+1,count+1,n,m);\\n            }\\n            else if(count>0){\\n                answer+=solve(grid,i,j+1,count-1,n,m);\\n            }\\n        }\\n        return dp[i][j][count]=answer;\\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        ll n=grid.size(),m=grid[0].size();memset(dp,-1,sizeof(dp));\\n        return solve(grid,0,0,0,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[101][101][201];\\n\\n    ll solve(vector<vector<char>>&grid,ll i,ll j,ll count,ll n,ll m){\\n        if(i==n-1 && j==m-1){\\n            if(grid[i][j]==\\'(\\' || count!=1){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        if(dp[i][j][count]!=-1){\\n            return dp[i][j][count];\\n        }\\n        bool answer=0;\\n        if(i+1<n){\\n            if(grid[i][j]==\\'(\\'){\\n                answer+=solve(grid,i+1,j,count+1,n,m);\\n            }\\n            else if(count>0){\\n                answer+=solve(grid,i+1,j,count-1,n,m);\\n            }\\n        }\\n        if(j+1<m){\\n            if(grid[i][j]==\\'(\\'){\\n                answer+=solve(grid,i,j+1,count+1,n,m);\\n            }\\n            else if(count>0){\\n                answer+=solve(grid,i,j+1,count-1,n,m);\\n            }\\n        }\\n        return dp[i][j][count]=answer;\\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        ll n=grid.size(),m=grid[0].size();memset(dp,-1,sizeof(dp));\\n        return solve(grid,0,0,0,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942771,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\n/**\\n * @param {character[][]} grid\\n * @return {boolean}\\n */\\nvar hasValidPath = function(grid) {\\n  let visiting = new Set();\\n  let cache = new Set();\\n  return dfs([0, 0], grid, visiting, 0, cache);\\n};\\n\\nfunction dfs(cell, grid, visiting, currentSum, cache) {\\n  let [row, col] = cell;\\n  let val = grid[row][col] === \"(\" ? 1 : -1;\\n  let remainingSum = 0 - (currentSum + val);\\n  if (cache.has(`${row}_${col}_${remainingSum}`)) {\\n    return false;\\n  }\\n  if (currentSum + val < 0) {\\n    return false;\\n  }\\n  \\n  if (row === grid.length - 1 && col === grid[0].length - 1) {\\n    // reached the end\\n    return (currentSum + val === 0);\\n  }\\n  \\n  // add it to visiting\\n  visiting.add(`${row}_${col}`);\\n  \\n  // visit all neighbors\\n  for (let [i, j] of [[1, 0], [0, 1]]) {\\n    if (isValid(grid, row + i, col + j) &&\\n      !visiting.has(`${row + i}_${col + j}`)) {\\n      \\n      // add neighbor to search\\n      if (dfs([row + i, col + j], grid, visiting, currentSum + val, cache)) {\\n        return true;\\n      }\\n    }\\n  }\\n  \\n  visiting.delete(`${row}_${col}`);\\n  cache.add(`${row}_${col}_${remainingSum}`);\\n  \\n  return false;\\n}\\n\\nfunction isValid(grid, row, col) {\\n  if (row >= 0 && col >= 0 && row < grid.length && col < grid[0].length) {\\n    return true;\\n  }\\n  return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n\\n/**\\n * @param {character[][]} grid\\n * @return {boolean}\\n */\\nvar hasValidPath = function(grid) {\\n  let visiting = new Set();\\n  let cache = new Set();\\n  return dfs([0, 0], grid, visiting, 0, cache);\\n};\\n\\nfunction dfs(cell, grid, visiting, currentSum, cache) {\\n  let [row, col] = cell;\\n  let val = grid[row][col] === \"(\" ? 1 : -1;\\n  let remainingSum = 0 - (currentSum + val);\\n  if (cache.has(`${row}_${col}_${remainingSum}`)) {\\n    return false;\\n  }\\n  if (currentSum + val < 0) {\\n    return false;\\n  }\\n  \\n  if (row === grid.length - 1 && col === grid[0].length - 1) {\\n    // reached the end\\n    return (currentSum + val === 0);\\n  }\\n  \\n  // add it to visiting\\n  visiting.add(`${row}_${col}`);\\n  \\n  // visit all neighbors\\n  for (let [i, j] of [[1, 0], [0, 1]]) {\\n    if (isValid(grid, row + i, col + j) &&\\n      !visiting.has(`${row + i}_${col + j}`)) {\\n      \\n      // add neighbor to search\\n      if (dfs([row + i, col + j], grid, visiting, currentSum + val, cache)) {\\n        return true;\\n      }\\n    }\\n  }\\n  \\n  visiting.delete(`${row}_${col}`);\\n  cache.add(`${row}_${col}_${remainingSum}`);\\n  \\n  return false;\\n}\\n\\nfunction isValid(grid, row, col) {\\n  if (row >= 0 && col >= 0 && row < grid.length && col < grid[0].length) {\\n    return true;\\n  }\\n  return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2937462,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        @lru_cache(None)\\n        def dfs(i,j,total):\\n            if grid[i][j] == \"(\":\\n                total += 1\\n            else:\\n                total -= 1  \\n \\n            if total < 0:\\n                return False\\n\\n            if i == m-1 and j == n-1 and total == 0:\\n                return True\\n\\n            if i+1 < m and dfs(i+1,j,total):\\n                return True\\n\\n            if j+1 < n and dfs(i,j+1,total):\\n                return True\\n\\n        return dfs(0,0,0)\\n\\n        \\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        @lru_cache(None)\\n        def dfs(i,j,total):\\n            if grid[i][j] == \"(\":\\n                total += 1\\n            else:\\n                total -= 1  \\n \\n            if total < 0:\\n                return False\\n\\n            if i == m-1 and j == n-1 and total == 0:\\n                return True\\n\\n            if i+1 < m and dfs(i+1,j,total):\\n                return True\\n\\n            if j+1 < n and dfs(i,j+1,total):\\n                return True\\n\\n        return dfs(0,0,0)\\n\\n        \\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724242,
                "title": "python-dfs-faster-than-100",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def dfs(y, x, t):\\n            if ans[0] or (y, x, t) in seen: return\\n            if x + y + 1 == l:\\n                if t == 0: ans[0] = True\\n                return\\n            if t + x + y + 1 > l: return\\n            seen.add((y, x, t))\\n            for yy, xx in (y + 1, x), (y, x + 1):\\n                if not (0 <= xx < n and 0 <= yy < m): continue\\n                tt = t + (-1) ** (grid[yy][xx] == \\')\\')\\n                if (yy, xx, tt) in seen or tt < 0: continue\\n                dfs(yy, xx, tt)\\n                \\n        m, n, l = len(grid), len(grid[0]), len(grid) + len(grid[0]) - 1\\n        if l % 2: return False\\n        seen, ans = set(), [False]\\n        dfs(0, -1, 0)\\n        return ans[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def dfs(y, x, t):\\n            if ans[0] or (y, x, t) in seen: return\\n            if x + y + 1 == l:\\n                if t == 0: ans[0] = True\\n                return\\n            if t + x + y + 1 > l: return\\n            seen.add((y, x, t))\\n            for yy, xx in (y + 1, x), (y, x + 1):\\n                if not (0 <= xx < n and 0 <= yy < m): continue\\n                tt = t + (-1) ** (grid[yy][xx] == \\')\\')\\n                if (yy, xx, tt) in seen or tt < 0: continue\\n                dfs(yy, xx, tt)\\n                \\n        m, n, l = len(grid), len(grid[0]), len(grid) + len(grid[0]) - 1\\n        if l % 2: return False\\n        seen, ans = set(), [False]\\n        dfs(0, -1, 0)\\n        return ans[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666464,
                "title": "greedy-dp-concepts",
                "content": "```\\nif it is \\'(\\' increment score else decrement it\\nif you don\\'t know why i am doing that check out these problems first \\nhttps://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/\\nhttps://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/\\nhttps://leetcode.com/problems/valid-parenthesis-string/\\n\\n\\n\\nnow, for every valid cell, we can either move down or move right \\nat the end of the moves, i.e right end of the cell\\nif score == 0, we are good to go else return false;\\n\\nclass Solution {\\npublic:\\n    \\n    bool solve(int x, int y, int x_bound, int y_bound, int score,vector<vector<char>>&table, vector<vector<vector<int>>>&dp){\\n           // at each point score must be greater than or equal to 0\\n         bool move_down=false, move_right= false;\\n          \\n          if(x < x_bound && y < y_bound){\\n                   \\n                \\n                  if(table[x][y]==\\'(\\')++score;\\n                  else score --;\\n                  \\n                  if(score < 0)return false;\\n                 \\n                    if(dp[x][y][score]!=-1)return dp[x][y][score];\\n              \\n                   move_down = solve(x+1,y,x_bound,y_bound, score,table,dp);\\n                   move_right = solve(x, y+1, x_bound, y_bound, score, table,dp);\\n          }\\n          \\n          else if( (x==x_bound-1 && y==y_bound ) || (x==x_bound && y==y_bound-1)){\\n               \\n                 return score==0;\\n          }\\n          \\n        \\n          return dp[x][y][score]=move_down|| move_right;\\n           \\n          \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n         \\n        vector<vector<vector<int>>>dp(grid.size()+1, vector<vector<int>>(grid[0].size()+1,vector<int>(grid.size()+grid[0].size(),-1)));\\n        \\n        return solve(0,0,grid.size(), grid[0].size(),0,grid,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nif it is \\'(\\' increment score else decrement it\\nif you don\\'t know why i am doing that check out these problems first \\nhttps://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/\\nhttps://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/\\nhttps://leetcode.com/problems/valid-parenthesis-string/\\n\\n\\n\\nnow, for every valid cell, we can either move down or move right \\nat the end of the moves, i.e right end of the cell\\nif score == 0, we are good to go else return false;\\n\\nclass Solution {\\npublic:\\n    \\n    bool solve(int x, int y, int x_bound, int y_bound, int score,vector<vector<char>>&table, vector<vector<vector<int>>>&dp){\\n           // at each point score must be greater than or equal to 0\\n         bool move_down=false, move_right= false;\\n          \\n          if(x < x_bound && y < y_bound){\\n                   \\n                \\n                  if(table[x][y]==\\'(\\')++score;\\n                  else score --;\\n                  \\n                  if(score < 0)return false;\\n                 \\n                    if(dp[x][y][score]!=-1)return dp[x][y][score];\\n              \\n                   move_down = solve(x+1,y,x_bound,y_bound, score,table,dp);\\n                   move_right = solve(x, y+1, x_bound, y_bound, score, table,dp);\\n          }\\n          \\n          else if( (x==x_bound-1 && y==y_bound ) || (x==x_bound && y==y_bound-1)){\\n               \\n                 return score==0;\\n          }\\n          \\n        \\n          return dp[x][y][score]=move_down|| move_right;\\n           \\n          \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n         \\n        vector<vector<vector<int>>>dp(grid.size()+1, vector<vector<int>>(grid[0].size()+1,vector<int>(grid.size()+grid[0].size(),-1)));\\n        \\n        return solve(0,0,grid.size(), grid[0].size(),0,grid,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644712,
                "title": "simple-dfs-dp-solution-2-ways",
                "content": "Normal DFS + DP, Java/C++/JS folk friendly\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        numRows, numCols = len(grid), len(grid[0])\\n        dp = [[[-1] * (numRows + numCols + 1) for _ in range(numCols)] for _ in range(numRows)]\\n        \\n        def dfs(row: int, col: int, balance: int) -> bool:\\n            nonlocal grid, dp\\n            if row >= numRows or col >= numCols:\\n                return 0\\n            if grid[row][col] == \\'(\\':\\n                balance += 1\\n            else:\\n                balance -= 1\\n            if balance < 0:\\n                return 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return balance == 0\\n            if dp[row][col][balance] != -1:\\n                return dp[row][col][balance]\\n            dp[row][col][balance] = dfs(row + 1, col, balance) or dfs(row, col + 1, balance)\\n            return dp[row][col][balance]\\n        \\n        return dfs(0, 0, 0)\\n```\\n\\nUsing @cache: Python-specific\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        numRows, numCols = len(grid), len(grid[0])\\n        \\n        @cache\\n        def dfs(row: int, col: int, balance: int) -> bool:\\n            nonlocal grid\\n            if row >= numRows or col >= numCols:\\n                return 0\\n            if grid[row][col] == \\'(\\':\\n                balance += 1\\n            else:\\n                balance -= 1\\n            if balance < 0:\\n                return 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return balance == 0\\n            return dfs(row + 1, col, balance) or dfs(row, col + 1, balance)\\n        \\n        return dfs(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        numRows, numCols = len(grid), len(grid[0])\\n        dp = [[[-1] * (numRows + numCols + 1) for _ in range(numCols)] for _ in range(numRows)]\\n        \\n        def dfs(row: int, col: int, balance: int) -> bool:\\n            nonlocal grid, dp\\n            if row >= numRows or col >= numCols:\\n                return 0\\n            if grid[row][col] == \\'(\\':\\n                balance += 1\\n            else:\\n                balance -= 1\\n            if balance < 0:\\n                return 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return balance == 0\\n            if dp[row][col][balance] != -1:\\n                return dp[row][col][balance]\\n            dp[row][col][balance] = dfs(row + 1, col, balance) or dfs(row, col + 1, balance)\\n            return dp[row][col][balance]\\n        \\n        return dfs(0, 0, 0)\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        numRows, numCols = len(grid), len(grid[0])\\n        \\n        @cache\\n        def dfs(row: int, col: int, balance: int) -> bool:\\n            nonlocal grid\\n            if row >= numRows or col >= numCols:\\n                return 0\\n            if grid[row][col] == \\'(\\':\\n                balance += 1\\n            else:\\n                balance -= 1\\n            if balance < 0:\\n                return 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return balance == 0\\n            return dfs(row + 1, col, balance) or dfs(row, col + 1, balance)\\n        \\n        return dfs(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597457,
                "title": "python3",
                "content": "class Solution:\\n\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        cache = {}\\n        m,n = len(grid),len(grid[0])\\n        lRow,lCol = m-1,n-1\\n        \\n        def dfs(i,j,bal):\\n            if i in [-1,m] or j in [-1,n] or bal<0:\\n                return False\\n            if (i,j,bal) not in cache:\\n                updatedBal = bal+(1 if grid[i][j]==\\'(\\' else -1)\\n                if (i,j) == (lRow,lCol) and updatedBal==0:\\n                    return True\\n                valid = dfs(i+1,j,updatedBal) or dfs(i,j+1,updatedBal)\\n                cache[(i,j,bal)] = valid\\n            return cache[(i,j,bal)]\\n        \\n        return dfs(0,0,0)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        cache = {}",
                "codeTag": "Java"
            },
            {
                "id": 2489279,
                "title": "dp-cpp-solution",
                "content": "`****`\\nclass Solution {\\npublic:\\n    bool fun(vector<vector<char>> &grid,int i,int j,int a,int m,int n,vector<vector<vector<int>>> &dp){\\n        if(i==(m-1) && j==(n-1)){\\n            if(grid[i][j]==\\')\\' && a==1)\\n                return true;\\n            return false;\\n        }\\n        if(a<0)\\n            return false;\\n        if(dp[i][j][a]!=-1)\\n            return dp[i][j][a];\\n        int p=a;\\n        if(grid[i][j]==\\'(\\')\\n            p+=1;\\n        else\\n            p-=1;\\n        if(i<(m-1) && j<(n-1))\\n            return dp[i][j][a]=(fun(grid,i,j+1,p,m,n,dp) || fun(grid,i+1,j,p,m,n,dp));\\n        if(i<(m-1))\\n            return dp[i][j][a]=fun(grid,i+1,j,p,m,n,dp);\\n        else\\n            return dp[i][j][a]=fun(grid,i,j+1,p,m,n,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m,vector<vector<int>>(n,vector<int>(m+n,-1)));\\n        return fun(grid,0,0,0,m,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool fun(vector<vector<char>> &grid,int i,int j,int a,int m,int n,vector<vector<vector<int>>> &dp){\\n        if(i==(m-1) && j==(n-1)){\\n            if(grid[i][j]==\\')\\' && a==1)\\n                return true;\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2453497,
                "title": "rust-dynamic-programming",
                "content": "~~~\\n// the important step is to use the first index to trace: # of \\'(\\' - # of \\')\\' and\\n// to ignore those invalid cases where  # of \\'(\\' < # of \\')\\'\\nimpl Solution {\\n    pub fn has_valid_path(grid: Vec<Vec<char>>) -> bool {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut dp = vec![vec![vec![-1; m + n]; n] ; m];\\n        \\n        Self::solve(&grid, &mut dp, 0, 0, 0) == 1\\n    }\\n    \\n    fn solve(grid: &Vec<Vec<char>>, dp: &mut Vec<Vec<Vec<i32>>>, i: usize, j: usize, k: usize) -> i32 {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        if i == m || j == n { return 0 }\\n        \\n        let mut k = k as i32;\\n        k += if grid[i][j] == \\'(\\' { 1 } else { -1 };\\n        if (k < 0) { return 0 }\\n        let k = k as usize;\\n        \\n        if i == m - 1 && j == n - 1 { \\n            return if k == 0 { 1 } else { 0 }\\n        }\\n        \\n        if dp[i][j][k] != -1 { return dp[i][j][k] }\\n        dp[i][j][k] = if Self::solve(grid, dp, i + 1, j, k) == 1 || Self::solve(grid, dp, i, j + 1, k) == 1 { 1 } else { 0 };\\n        \\n        dp[i][j][k]\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "~~~\\n// the important step is to use the first index to trace: # of \\'(\\' - # of \\')\\' and\\n// to ignore those invalid cases where  # of \\'(\\' < # of \\')\\'\\nimpl Solution {\\n    pub fn has_valid_path(grid: Vec<Vec<char>>) -> bool {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut dp = vec![vec![vec![-1; m + n]; n] ; m];\\n        \\n        Self::solve(&grid, &mut dp, 0, 0, 0) == 1\\n    }\\n    \\n    fn solve(grid: &Vec<Vec<char>>, dp: &mut Vec<Vec<Vec<i32>>>, i: usize, j: usize, k: usize) -> i32 {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        if i == m || j == n { return 0 }\\n        \\n        let mut k = k as i32;\\n        k += if grid[i][j] == \\'(\\' { 1 } else { -1 };\\n        if (k < 0) { return 0 }\\n        let k = k as usize;\\n        \\n        if i == m - 1 && j == n - 1 { \\n            return if k == 0 { 1 } else { 0 }\\n        }\\n        \\n        if dp[i][j][k] != -1 { return dp[i][j][k] }\\n        dp[i][j][k] = if Self::solve(grid, dp, i + 1, j, k) == 1 || Self::solve(grid, dp, i, j + 1, k) == 1 { 1 } else { 0 };\\n        \\n        dp[i][j][k]\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2443083,
                "title": "simple-and-clean-python-solution-with-dp-o-mn-m-n",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        R, C = len(grid), len(grid[0])\\n        dp = [[[False for i in range(R+C+1)] for c in range(C+1)] for r in range(R+1)]\\n        dp[R][C-1][0] = True\\n        dp[R-1][C][0] = True\\n        for r in range(R-1, -1, -1):\\n            for c in range(C-1, -1, -1):\\n                for i in range(R+C):\\n                    nxt = [1,-1][grid[r][c] == \")\"]\\n                    dp[r][c][i] = dp[r+1][c][i+nxt] or dp[r][c+1][i+nxt]\\n        return dp[0][0][0]\\n                    \\n```\\n**EDIT:**\\nThe solution can be made 2 times faster by running the innermost loop only till ```(R+C)//2 + 1``` as the bracket overhead above it can never be fulfilled. It really makes a difference particularly in this question.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        R, C = len(grid), len(grid[0])\\n        dp = [[[False for i in range(R+C+1)] for c in range(C+1)] for r in range(R+1)]\\n        dp[R][C-1][0] = True\\n        dp[R-1][C][0] = True\\n        for r in range(R-1, -1, -1):\\n            for c in range(C-1, -1, -1):\\n                for i in range(R+C):\\n                    nxt = [1,-1][grid[r][c] == \")\"]\\n                    dp[r][c][i] = dp[r+1][c][i+nxt] or dp[r][c+1][i+nxt]\\n        return dp[0][0][0]\\n                    \\n```\n```(R+C)//2 + 1```",
                "codeTag": "Java"
            },
            {
                "id": 2379590,
                "title": "javascript-beat-100",
                "content": "```\\nvar hasValidPath = function (grid) {\\n  let m = grid.length;\\n  let n = grid[0].length;\\n  let visited = {};\\n\\n  if ((m + n - 1) % 2 !== 0) return false;\\n  if (grid[0][0] !== \"(\" || grid[m - 1][n - 1] !== \")\") return false;\\n\\n  function helper(i, j, bal) {\\n    if (i >= m || j >= n) return false;\\n    if (bal > m + n - i - j) return false;\\n\\n    if (grid[i][j] === \"(\") bal++;\\n    else bal--;\\n    if (bal < 0) return false;\\n    if (i === m - 1 && j === n - 1) return bal === 0;\\n\\n    let key = `${i},${j},${bal}`;\\n    if (visited[key] !== undefined) return visited[key];\\n    return (visited[key] = helper(i + 1, j, bal) || helper(i, j + 1, bal));\\n  }\\n  return helper(0, 0, 0);\\n};",
                "solutionTags": [],
                "code": "```\\nvar hasValidPath = function (grid) {\\n  let m = grid.length;\\n  let n = grid[0].length;\\n  let visited = {};\\n\\n  if ((m + n - 1) % 2 !== 0) return false;\\n  if (grid[0][0] !== \"(\" || grid[m - 1][n - 1] !== \")\") return false;\\n\\n  function helper(i, j, bal) {\\n    if (i >= m || j >= n) return false;\\n    if (bal > m + n - i - j) return false;\\n\\n    if (grid[i][j] === \"(\") bal++;\\n    else bal--;\\n    if (bal < 0) return false;\\n    if (i === m - 1 && j === n - 1) return bal === 0;\\n\\n    let key = `${i},${j},${bal}`;\\n    if (visited[key] !== undefined) return visited[key];\\n    return (visited[key] = helper(i + 1, j, bal) || helper(i, j + 1, bal));\\n  }\\n  return helper(0, 0, 0);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2377927,
                "title": "simple-c-solution-no-showoff",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ans = false;\\n    int dp[100][100][200];\\n    bool solve(int i, int j, int balance, vector<vector<char>>& g) {\\n        \\n        if(balance < 0) return false;\\n\\n        if(i == g.size() - 1 && j == g[0].size() - 1)  return balance == 0;\\n        if(dp[i][j][balance] != -1) return dp[i][j][balance];\\n        \\n        \\n        \\n        bool ans = false;\\n        if(i + 1 < g.size()) {\\n            int newBalance = (g[i + 1][j] == \\'(\\' ? balance + 1 : balance - 1);\\n            if(newBalance >= 0) ans = ans or solve(i + 1, j, newBalance, g);\\n            if(ans) return dp[i][j][balance] = ans;\\n        } \\n        \\n        if(j + 1 < g[0].size()) {\\n            int newBalance = (g[i][j + 1] == \\'(\\' ? balance + 1 : balance - 1);\\n            if(newBalance >= 0) ans = ans or solve(i, j + 1, newBalance, g);\\n            if(ans) return dp[i][j][balance] = ans;\\n        }\\n        \\n        return dp[i][j][balance] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        memset(dp, -1, sizeof(dp));\\n        int balance = g[0][0] == \\'(\\' ? 1 : -1;\\n        if(balance < 0) return false;\\n        return solve(0, 0, balance, g);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ans = false;\\n    int dp[100][100][200];\\n    bool solve(int i, int j, int balance, vector<vector<char>>& g) {\\n        \\n        if(balance < 0) return false;\\n\\n        if(i == g.size() - 1 && j == g[0].size() - 1)  return balance == 0;\\n        if(dp[i][j][balance] != -1) return dp[i][j][balance];\\n        \\n        \\n        \\n        bool ans = false;\\n        if(i + 1 < g.size()) {\\n            int newBalance = (g[i + 1][j] == \\'(\\' ? balance + 1 : balance - 1);\\n            if(newBalance >= 0) ans = ans or solve(i + 1, j, newBalance, g);\\n            if(ans) return dp[i][j][balance] = ans;\\n        } \\n        \\n        if(j + 1 < g[0].size()) {\\n            int newBalance = (g[i][j + 1] == \\'(\\' ? balance + 1 : balance - 1);\\n            if(newBalance >= 0) ans = ans or solve(i, j + 1, newBalance, g);\\n            if(ans) return dp[i][j][balance] = ans;\\n        }\\n        \\n        return dp[i][j][balance] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        memset(dp, -1, sizeof(dp));\\n        int balance = g[0][0] == \\'(\\' ? 1 : -1;\\n        if(balance < 0) return false;\\n        return solve(0, 0, balance, g);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300021,
                "title": "leetcode-the-hard-way-dfs-dp-with-memo",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), mxN = 105;\\n        vector<vector<vector<int>>> dp(mxN, vector<vector<int>>(mxN, vector<int>(mxN * 2, -1)));\\n        function<bool(int, int, int)> dfs = [&](int i, int j, int k) -> bool {\\n            // out of bound - return false\\n            if (i == n || j == m) return false;\\n            // count the overall balance\\n            k += grid[i][j] == \\'(\\' ? 1 : -1;\\n            // negative balance - return false\\n            // e.g. ()) is invalid (k = -1)\\n            if (k < 0) return false;\\n            // if it reaches the target cell \\n            // and the balance is 0, e.g. ((()))\\n            // then return true \\n            if (i == n - 1 && j == m - 1 && k == 0) return true;\\n            // if the result is calculated before, return it directly\\n            if (dp[i][j][k] != -1) return dp[i][j][k];\\n            // otherwise, we either move right or move down\\n            return dp[i][j][k] = dfs(i + 1, j, k) || dfs(i, j + 1, k);\\n        };\\n        // starting from top left cell with balance = 0\\n        return dfs(0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), mxN = 105;\\n        vector<vector<vector<int>>> dp(mxN, vector<vector<int>>(mxN, vector<int>(mxN * 2, -1)));\\n        function<bool(int, int, int)> dfs = [&](int i, int j, int k) -> bool {\\n            // out of bound - return false\\n            if (i == n || j == m) return false;\\n            // count the overall balance\\n            k += grid[i][j] == \\'(\\' ? 1 : -1;\\n            // negative balance - return false\\n            // e.g. ()) is invalid (k = -1)\\n            if (k < 0) return false;\\n            // if it reaches the target cell \\n            // and the balance is 0, e.g. ((()))\\n            // then return true \\n            if (i == n - 1 && j == m - 1 && k == 0) return true;\\n            // if the result is calculated before, return it directly\\n            if (dp[i][j][k] != -1) return dp[i][j][k];\\n            // otherwise, we either move right or move down\\n            return dp[i][j][k] = dfs(i + 1, j, k) || dfs(i, j + 1, k);\\n        };\\n        // starting from top left cell with balance = 0\\n        return dfs(0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281138,
                "title": "c-solution",
                "content": "Approach:\\n```\\n#define vvvi vector<vector<vector<int>>>\\n#define vvc vector<vector<char>> \\n\\nclass Solution {\\npublic:\\n    \\n    bool f(int i, int j, int close, vvc &grid, vvvi &dp) {\\n        if(i < 0 || j < 0 || close < 0) return 0;\\n        \\n        // What did u encounter at current cell? \\n        // Rem: Traversing right to left in a potential Valid VPS\\n        if(grid[i][j] == \\')\\') close++;\\n        else close--;\\n        \\n        if(i == 0 and j == 0) {\\n            // Top-Left cell\\n            return (close == 0);\\n        }\\n        \\n        if(close < 0) return 0;\\n        \\n        if(dp[i][j][close] != -1) return dp[i][j][close];\\n        \\n        // Move up(i-1, j) or move left(i, j-1)\\n        // Now u should move up or left only when u are still satisfying vps\\n        \\n        return dp[i][j][close] = (f(i-1, j, close, grid, dp) || f(i, j-1, close, grid, dp));\\n    }\\n    \\n    \\n    // Idea is while moving left or right, go only where u can make a valid path\\n    // Check validity while choosing.\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vvvi dp(m, vector<vector<int>> (n, vector<int> (201, -1)));\\n        \\n        // I am starting from bottom-right cell meaning back of a possible vps\\n        // So, I should encounter closing brackets from end )\\n        \\n        return f(m-1, n-1, 0, grid, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define vvvi vector<vector<vector<int>>>\\n#define vvc vector<vector<char>> \\n\\nclass Solution {\\npublic:\\n    \\n    bool f(int i, int j, int close, vvc &grid, vvvi &dp) {\\n        if(i < 0 || j < 0 || close < 0) return 0;\\n        \\n        // What did u encounter at current cell? \\n        // Rem: Traversing right to left in a potential Valid VPS\\n        if(grid[i][j] == \\')\\') close++;\\n        else close--;\\n        \\n        if(i == 0 and j == 0) {\\n            // Top-Left cell\\n            return (close == 0);\\n        }\\n        \\n        if(close < 0) return 0;\\n        \\n        if(dp[i][j][close] != -1) return dp[i][j][close];\\n        \\n        // Move up(i-1, j) or move left(i, j-1)\\n        // Now u should move up or left only when u are still satisfying vps\\n        \\n        return dp[i][j][close] = (f(i-1, j, close, grid, dp) || f(i, j-1, close, grid, dp));\\n    }\\n    \\n    \\n    // Idea is while moving left or right, go only where u can make a valid path\\n    // Check validity while choosing.\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vvvi dp(m, vector<vector<int>> (n, vector<int> (201, -1)));\\n        \\n        // I am starting from bottom-right cell meaning back of a possible vps\\n        // So, I should encounter closing brackets from end )\\n        \\n        return f(m-1, n-1, 0, grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174607,
                "title": "why-bfs-wth-backtracking-got-tle-how-can-i-memoise",
                "content": "class Solution {\\npublic:\\n    int m,n;\\n    int dx[2]={1,0};\\n    int dy[2]={0,1};\\n    vector<vector<int>>vis;\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        m=grid.size();\\n        n=grid[0].size();\\n        vis.resize(m,vector<int>(n,false));\\n        if(grid[0][0]==\\')\\')\\n        {\\n            return false;\\n        }\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,1}});\\n        vis[0][0]=true;\\n        while(!q.empty())\\n        {   \\n            auto it=q.front();\\n            q.pop();\\n            int i=it.first;\\n            int j=it.second.first;\\n            int cnt=it.second.second;\\n            if(i==m-1 && j==n-1 && cnt==0)\\n            {\\n                return true;\\n            }\\n            for(int k=0;k<2;k++)\\n            {\\n                int newi=i+dx[k];\\n                int newj=j+dy[k];\\n                if(newi>=0 && newi<m && newj>=0 && newj<n && grid[newi][newj]==\\')\\' && !vis[newi][newj])\\n                {\\n                    vis[newi][newj]=true;\\n                    q.push({newi,{newj,cnt-1}});\\n                    vis[newi][newj]=false;\\n                }\\n                else if(newi>=0 && newi<m && newj>=0 && newj<n && grid[newi][newj]==\\'(\\' && !vis[newi][newj])\\n                {\\n                    vis[newi][newj]=true;\\n                    q.push({newi,{newj,cnt+1}});\\n                    vis[newi][newj]=false;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int m,n;\\n    int dx[2]={1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2169233,
                "title": "python-go-blazing-fast-dp-w-backtracking-o-mn-m-n",
                "content": "*Python* solution w/ bitset in 321ms beat 98% :)\\n\\n```python\\ndef hasValidPath(self, grid):\\n    dp = [[0] * 101 for _ in range(101)]\\n    dp[0][1] = 1\\n    for i, row in enumerate(grid, 1):                               # O(M)\\n        for j, c in enumerate(row, 1):                              # O(N)\\n            dp[i][j] = dp[i][j - 1] | dp[i - 1][j]                  # O(M+N) bitset union\\n            dp[i][j] = dp[i][j] << 1 if c == \"(\" else dp[i][j] >> 1 # O(M+N) bitset shift\\n    return dp[i][j] & 1\\n```\\n\\n*Go* solution w/ bitset in 3ms beat 100% :)\\n\\n```go\\ntype bitset [2]uint64\\n\\nfunc (x *bitset) set0()        { x[0] = 1 }\\nfunc (x *bitset) get0() uint64 { return x[0] & 1 }\\nfunc (x *bitset) union(y bitset) bitset {\\n\\tvar z bitset\\n\\tz[0] = x[0] | y[0]\\n\\tz[1] = x[1] | y[1]\\n\\treturn z\\n}\\nfunc (x *bitset) lsh1() {\\n\\ty := x[0]\\n\\ty >>= 63\\n\\tx[0] <<= 1\\n\\tx[1] <<= 1\\n\\tx[1] |= y\\n}\\nfunc (x *bitset) rsh1() {\\n\\ty := x[1]\\n\\ty <<= 63\\n\\tx[1] >>= 1\\n\\tx[0] >>= 1\\n\\tx[0] |= y\\n}\\n\\nfunc hasValidPath(grid [][]byte) bool {\\n\\tvar (\\n\\t\\tm  = len(grid)\\n\\t\\tn  = len(grid[0])\\n\\t\\tdp [101][101]bitset\\n\\t)\\n\\tdp[0][1].set0()\\n\\tfor i, x := 0, 1; i < m; i, x = i+1, x+1 {\\n\\t\\tfor j, y := 0, 1; j < n; j, y = j+1, y+1 {\\n\\t\\t\\tdp[x][y] = dp[i][y].union(dp[x][j])\\n\\t\\t\\tif grid[i][j] == \\'(\\' {\\n\\t\\t\\t\\tdp[x][y].lsh1()\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[x][y].rsh1()\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n].get0() == 1\\n}\\n```\\n\\n*Go* solution w/ boolean array\\n\\n```go\\nfunc hasValidPath(grid [][]byte) bool {\\n\\tvar (\\n\\t\\tm = len(grid)\\n\\t\\tn = len(grid[0])\\n\\t\\tl = m + n\\n\\t)\\n\\tdp := make([][][]bool, m+1)\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tdp[i] = make([][]bool, n+1)\\n\\t\\tfor j := 0; j <= n; j++ {\\n\\t\\t\\tdp[i][j] = make([]bool, l+1)\\n\\t\\t}\\n\\t}\\n\\tdp[0][1][0] = true\\n\\tfor i, x := 0, 1; i < m; i, x = i+1, x+1 {\\n\\t\\tfor j, y := 0, 1; j < n; j, y = j+1, y+1 {\\n\\t\\t\\tfor k := 0; k <= l; k++ {\\n\\t\\t\\t\\tdp[x][y][k] = dp[i][y][k] || dp[x][j][k]\\n\\t\\t\\t}\\n\\t\\t\\tif grid[i][j] == \\'(\\' {\\n\\t\\t\\t\\tfor k := l; k >= 1; k-- {\\n\\t\\t\\t\\t\\tdp[x][y][k] = dp[x][y][k-1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[x][y][0] = false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor k := 0; k < l; k++ {\\n\\t\\t\\t\\t\\tdp[x][y][k] = dp[x][y][k+1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n][0]\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef hasValidPath(self, grid):\\n    dp = [[0] * 101 for _ in range(101)]\\n    dp[0][1] = 1\\n    for i, row in enumerate(grid, 1):                               # O(M)\\n        for j, c in enumerate(row, 1):                              # O(N)\\n            dp[i][j] = dp[i][j - 1] | dp[i - 1][j]                  # O(M+N) bitset union\\n            dp[i][j] = dp[i][j] << 1 if c == \"(\" else dp[i][j] >> 1 # O(M+N) bitset shift\\n    return dp[i][j] & 1\\n```\n```go\\ntype bitset [2]uint64\\n\\nfunc (x *bitset) set0()        { x[0] = 1 }\\nfunc (x *bitset) get0() uint64 { return x[0] & 1 }\\nfunc (x *bitset) union(y bitset) bitset {\\n\\tvar z bitset\\n\\tz[0] = x[0] | y[0]\\n\\tz[1] = x[1] | y[1]\\n\\treturn z\\n}\\nfunc (x *bitset) lsh1() {\\n\\ty := x[0]\\n\\ty >>= 63\\n\\tx[0] <<= 1\\n\\tx[1] <<= 1\\n\\tx[1] |= y\\n}\\nfunc (x *bitset) rsh1() {\\n\\ty := x[1]\\n\\ty <<= 63\\n\\tx[1] >>= 1\\n\\tx[0] >>= 1\\n\\tx[0] |= y\\n}\\n\\nfunc hasValidPath(grid [][]byte) bool {\\n\\tvar (\\n\\t\\tm  = len(grid)\\n\\t\\tn  = len(grid[0])\\n\\t\\tdp [101][101]bitset\\n\\t)\\n\\tdp[0][1].set0()\\n\\tfor i, x := 0, 1; i < m; i, x = i+1, x+1 {\\n\\t\\tfor j, y := 0, 1; j < n; j, y = j+1, y+1 {\\n\\t\\t\\tdp[x][y] = dp[i][y].union(dp[x][j])\\n\\t\\t\\tif grid[i][j] == \\'(\\' {\\n\\t\\t\\t\\tdp[x][y].lsh1()\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[x][y].rsh1()\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n].get0() == 1\\n}\\n```\n```go\\nfunc hasValidPath(grid [][]byte) bool {\\n\\tvar (\\n\\t\\tm = len(grid)\\n\\t\\tn = len(grid[0])\\n\\t\\tl = m + n\\n\\t)\\n\\tdp := make([][][]bool, m+1)\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tdp[i] = make([][]bool, n+1)\\n\\t\\tfor j := 0; j <= n; j++ {\\n\\t\\t\\tdp[i][j] = make([]bool, l+1)\\n\\t\\t}\\n\\t}\\n\\tdp[0][1][0] = true\\n\\tfor i, x := 0, 1; i < m; i, x = i+1, x+1 {\\n\\t\\tfor j, y := 0, 1; j < n; j, y = j+1, y+1 {\\n\\t\\t\\tfor k := 0; k <= l; k++ {\\n\\t\\t\\t\\tdp[x][y][k] = dp[i][y][k] || dp[x][j][k]\\n\\t\\t\\t}\\n\\t\\t\\tif grid[i][j] == \\'(\\' {\\n\\t\\t\\t\\tfor k := l; k >= 1; k-- {\\n\\t\\t\\t\\t\\tdp[x][y][k] = dp[x][y][k-1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[x][y][0] = false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor k := 0; k < l; k++ {\\n\\t\\t\\t\\t\\tdp[x][y][k] = dp[x][y][k+1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n][0]\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2164785,
                "title": "python-lru-cache",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, x: List[List[str]]) -> bool:\\n        m,n=len(x),len(x[0])    \\n        @lru_cache(None)\\n        def f(i,j,c):\\n            if i==m-1 and j==n-1:return not c\\n            ans=False\\n            for d,e in ((i+1,j),(i,j+1)):\\n                if d<m and e<n:\\n                    if x[d][e]==\\'(\\':\\n                        ans=ans or f(d,e,c+1)\\n                    else:\\n                        if c:\\n                            ans=ans or f(d,e,c-1)\\n            return ans\\n        return False if x[0][0]==\\')\\' else f(0,0,1) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, x: List[List[str]]) -> bool:\\n        m,n=len(x),len(x[0])    \\n        @lru_cache(None)\\n        def f(i,j,c):\\n            if i==m-1 and j==n-1:return not c\\n            ans=False\\n            for d,e in ((i+1,j),(i,j+1)):\\n                if d<m and e<n:\\n                    if x[d][e]==\\'(\\':\\n                        ans=ans or f(d,e,c+1)\\n                    else:\\n                        if c:\\n                            ans=ans or f(d,e,c-1)\\n            return ans\\n        return False if x[0][0]==\\')\\' else f(0,0,1) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159103,
                "title": "python-solution-easy-to-understand-caching",
                "content": "The way this solution works is\\n1. There is a stack variable which acts as a Counter, so if the value of stack is 0 it means the stack is empty. On \"(\" we increment the value (append) of stack and on \")\" we decrement the value (pop) from stack.\\n2. lru_cache is used to avoid the calculation of same values again (Memoization). \\n```\\nn,m=len(grid),len(grid[0])\\nstack=0\\n@lru_cache(None)\\ndef recursion(row,col,stack):\\n\\t#Checking the indexes are within the range\\n\\tif row<0 or row>=n or col<0 or col>=m:\\n\\t\\treturn False\\n\\n\\t#Check that on reaching the last block value of stack is 1 and the parenthesis is closing\\t\\n\\tif row==n-1 and col==m-1:\\n\\t\\tif stack==1 and grid[row][col]==\")\":\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t#Updating the stack based on the input\\n\\tif grid[row][col]==\"(\":\\n\\t\\tstack+=1\\n\\telse:\\n\\t\\tif stack:\\n\\t\\t\\tstack-=1\\n\\t\\telse:\\n\\t\\t\\treturn False\\n\\n\\tfor index in [[row+1,col],[row,col+1]]:\\n\\t#if a valid path is found we don\\'t calculate for other paths and return\\n\\t\\tif recursion(index[0],index[1],stack):\\n\\t\\t\\treturn True\\n\\treturn False\\nreturn recursion(0,0,stack)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "The way this solution works is\\n1. There is a stack variable which acts as a Counter, so if the value of stack is 0 it means the stack is empty. On \"(\" we increment the value (append) of stack and on \")\" we decrement the value (pop) from stack.\\n2. lru_cache is used to avoid the calculation of same values again (Memoization). \\n```\\nn,m=len(grid),len(grid[0])\\nstack=0\\n@lru_cache(None)\\ndef recursion(row,col,stack):\\n\\t#Checking the indexes are within the range\\n\\tif row<0 or row>=n or col<0 or col>=m:\\n\\t\\treturn False\\n\\n\\t#Check that on reaching the last block value of stack is 1 and the parenthesis is closing\\t\\n\\tif row==n-1 and col==m-1:\\n\\t\\tif stack==1 and grid[row][col]==\")\":\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t#Updating the stack based on the input\\n\\tif grid[row][col]==\"(\":\\n\\t\\tstack+=1\\n\\telse:\\n\\t\\tif stack:\\n\\t\\t\\tstack-=1\\n\\t\\telse:\\n\\t\\t\\treturn False\\n\\n\\tfor index in [[row+1,col],[row,col+1]]:\\n\\t#if a valid path is found we don\\'t calculate for other paths and return\\n\\t\\tif recursion(index[0],index[1],stack):\\n\\t\\t\\treturn True\\n\\treturn False\\nreturn recursion(0,0,stack)",
                "codeTag": "Python3"
            },
            {
                "id": 2130285,
                "title": "c-simple-dfs",
                "content": "```\\nclass Solution {\\n    int dp[100][100][200];\\n    bool dfs(vector<vector<char>>& g, int x, int y, int balance) {\\n        if (x == g.size() || y == g[0].size())\\n            return false;\\n        if (g[x][y] == \\'(\\')\\n            balance++;\\n        else\\n            balance--;\\n        if (balance < 0)\\n            return false;\\n        if (x == g.size() - 1 && y == g[0].size() - 1)\\n            return balance == 0;\\n        if (dp[x][y][balance] == -1)\\n            dp[x][y][balance] = dfs(g, x + 1, y, balance) || dfs(g, x, y + 1, balance);\\n        return dp[x][y][balance];\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(g, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[100][100][200];\\n    bool dfs(vector<vector<char>>& g, int x, int y, int balance) {\\n        if (x == g.size() || y == g[0].size())\\n            return false;\\n        if (g[x][y] == \\'(\\')\\n            balance++;\\n        else\\n            balance--;\\n        if (balance < 0)\\n            return false;\\n        if (x == g.size() - 1 && y == g[0].size() - 1)\\n            return balance == 0;\\n        if (dp[x][y][balance] == -1)\\n            dp[x][y][balance] = dfs(g, x + 1, y, balance) || dfs(g, x, y + 1, balance);\\n        return dp[x][y][balance];\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(g, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119954,
                "title": "java-recursion-with-memorization",
                "content": "It\\'s more like a top-down DP.\\n\\nI find that TLE is very strict. If I use set or map to memorize it will get TLE while 3D array pass.\\n\\n```\\n    public boolean hasValidPath(char[][] grid) {\\n        if (null==grid) {\\n            return false;\\n        }\\n        int rc=grid.length;\\n        int cc=grid[0].length;\\n        if (grid[0][0]!=\\'(\\'||grid[rc-1][cc-1]!=\\')\\') {\\n            return false;\\n        }\\n        int[][][] dp=new int[101][101][202];\\n        for (int i=0;i<101;i++) {\\n            for (int j=0;j<101;j++) {\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        int b=helper(1,0,0,rc,cc,grid,dp);\\n        return b==1;\\n    }\\n\\n    private int helper(int count, int ri, int ci, int rc, int cc, char[][] grid, int[][][] dp) {\\n        if (count<0) {\\n            return 0;\\n        }\\n        if (-1!=dp[ri][ci][count]) {\\n            return dp[ri][ci][count];\\n        }\\n        if (count==0&&ri==rc-1&&ci==cc-1) {\\n            return 1;\\n        }\\n        int ret=-1;\\n        if (ri<rc-1) {\\n            if (grid[ri+1][ci]==\\'(\\') {\\n                ret=helper(count+1,ri+1,ci,rc,cc,grid,dp);\\n            }\\n            if (ret!=1&&grid[ri+1][ci]==\\')\\') {\\n                ret=helper(count-1,ri+1,ci,rc,cc,grid,dp);\\n            }\\n        }\\n        if (ret!=1&&ci<cc-1) {\\n            if (grid[ri][ci+1]==\\'(\\') {\\n                ret=helper(count+1,ri,ci+1,rc,cc,grid,dp);\\n            }\\n            if (ret!=1&&grid[ri][ci+1]==\\')\\') {\\n                ret=helper(count-1,ri,ci+1,rc,cc,grid,dp);\\n            }\\n        }\\n        if (ret!=1) {\\n            dp[ri][ci][count]=0;\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean hasValidPath(char[][] grid) {\\n        if (null==grid) {\\n            return false;\\n        }\\n        int rc=grid.length;\\n        int cc=grid[0].length;\\n        if (grid[0][0]!=\\'(\\'||grid[rc-1][cc-1]!=\\')\\') {\\n            return false;\\n        }\\n        int[][][] dp=new int[101][101][202];\\n        for (int i=0;i<101;i++) {\\n            for (int j=0;j<101;j++) {\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        int b=helper(1,0,0,rc,cc,grid,dp);\\n        return b==1;\\n    }\\n\\n    private int helper(int count, int ri, int ci, int rc, int cc, char[][] grid, int[][][] dp) {\\n        if (count<0) {\\n            return 0;\\n        }\\n        if (-1!=dp[ri][ci][count]) {\\n            return dp[ri][ci][count];\\n        }\\n        if (count==0&&ri==rc-1&&ci==cc-1) {\\n            return 1;\\n        }\\n        int ret=-1;\\n        if (ri<rc-1) {\\n            if (grid[ri+1][ci]==\\'(\\') {\\n                ret=helper(count+1,ri+1,ci,rc,cc,grid,dp);\\n            }\\n            if (ret!=1&&grid[ri+1][ci]==\\')\\') {\\n                ret=helper(count-1,ri+1,ci,rc,cc,grid,dp);\\n            }\\n        }\\n        if (ret!=1&&ci<cc-1) {\\n            if (grid[ri][ci+1]==\\'(\\') {\\n                ret=helper(count+1,ri,ci+1,rc,cc,grid,dp);\\n            }\\n            if (ret!=1&&grid[ri][ci+1]==\\')\\') {\\n                ret=helper(count-1,ri,ci+1,rc,cc,grid,dp);\\n            }\\n        }\\n        if (ret!=1) {\\n            dp[ri][ci][count]=0;\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2119317,
                "title": "c-beginners-dp-dfs-easy-understanding",
                "content": "TL DR : **if at any point open < 0 then the path is not balanced**\\n\\n**Q ) int dp[101][101][201] ? Why 201 ?**\\nA ) As the longest possible path from top left to bottom right is of (m+n-1) length.\\n(The path only ever moves down or right.)\\n\\nNow, we have to go from the top left to bottom right by moving either down or right, the first point we get is to have a valid parantheses, the count of open = close, so if at any point the count of open < 0, then the path is not balanced and we return false.\\n\\nHere the changing variables are i, j ( curr grid pos ) and the count of open and close brackets, it\\'ll be much complex to consider anothet variable for closed brackets count so we add +1 to open when we see a \\'( \\' & subtract -1 when we see a \\')\\'.\\n\\nfrom each position we can go either to the down (i+1, j) or right ( i, j+1), so we make 2 calls and we return true if either one of them returns true and assign it to dp[i][j][open].\\n\\nIf we somehow reach the bottom left, then we return true only when the count of open == 0 else we return false.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[100][100][201];\\n    bool helper(vector<vector<char>>& grid, int i, int j, int open){\\n        if(i >= grid.size() || j >= grid[0].size()){\\n            return false;\\n        }\\n        \\n        if(grid[i][j] == \\'(\\'){\\n            open++;\\n        }\\n        else{\\n            open--;\\n        }\\n        if(open < 0){\\n            return false;\\n        }\\n        if(dp[i][j][open] != -1){\\n            return dp[i][j][open];\\n        }\\n        if(i == grid.size() - 1 && j == grid[0].size() - 1){\\n            if(open == 0){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        int next = helper(grid, i+1, j, open) || helper(grid, i, j+1, open);\\n        return dp[i][j][open] = next;\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\'){\\n            return false;\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        bool ans = helper(grid, 0, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100][100][201];\\n    bool helper(vector<vector<char>>& grid, int i, int j, int open){\\n        if(i >= grid.size() || j >= grid[0].size()){\\n            return false;\\n        }\\n        \\n        if(grid[i][j] == \\'(\\'){\\n            open++;\\n        }\\n        else{\\n            open--;\\n        }\\n        if(open < 0){\\n            return false;\\n        }\\n        if(dp[i][j][open] != -1){\\n            return dp[i][j][open];\\n        }\\n        if(i == grid.size() - 1 && j == grid[0].size() - 1){\\n            if(open == 0){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        int next = helper(grid, i+1, j, open) || helper(grid, i, j+1, open);\\n        return dp[i][j][open] = next;\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\'){\\n            return false;\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        bool ans = helper(grid, 0, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068029,
                "title": "python-dp-easy-top-down-recursive",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def dfs(i, j, trace):\\n            nonlocal m, n\\n            trace += (1 if grid[i][j] == \\'(\\' else -1)\\n            if trace < 0:\\n                return False\\n            if i == m-1 and j == n-1 and trace == 0:\\n                return True\\n            right = down = False\\n            if i + 1 < m:\\n                right = dfs(i+1, j, trace)\\n            if j + 1 < n:\\n                down = dfs(i, j+1, trace)\\n            return right or down\\n        \\n        return dfs(0,0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def dfs(i, j, trace):\\n            nonlocal m, n\\n            trace += (1 if grid[i][j] == \\'(\\' else -1)\\n            if trace < 0:\\n                return False\\n            if i == m-1 and j == n-1 and trace == 0:\\n                return True\\n            right = down = False\\n            if i + 1 < m:\\n                right = dfs(i+1, j, trace)\\n            if j + 1 < n:\\n                down = dfs(i, j+1, trace)\\n            return right or down\\n        \\n        return dfs(0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065236,
                "title": "c-dp-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int r,c;\\n    int dp[101][101][205];\\n    bool solve(vector<vector<char>>& g,int i,int j,int op){\\n        if(i<0 || i>=r || j<0 || j>=c) return false;\\n        if(g[i][j]==\\'(\\')op++;\\n        else op--;        \\n        if(op<0) return false;\\n        if(dp[i][j][op]!=-1) return  dp[i][j][op]==1;\\n        if(i==r-1 && j==c-1 && op==0){\\n           dp[i][j][op]=1; \\n           return true; \\n        }  \\n        return dp[i][j][op]=solve(g,i+1,j,op)||solve(g,i,j+1,op);        \\n    }\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        r=g.size(),c=g[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        if(g[0][0]==\\')\\' || g[r-1][c-1]==\\'(\\') return false;\\n        solve(g,0,0,0);\\n        return dp[r-1][c-1][0]==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r,c;\\n    int dp[101][101][205];\\n    bool solve(vector<vector<char>>& g,int i,int j,int op){\\n        if(i<0 || i>=r || j<0 || j>=c) return false;\\n        if(g[i][j]==\\'(\\')op++;\\n        else op--;        \\n        if(op<0) return false;\\n        if(dp[i][j][op]!=-1) return  dp[i][j][op]==1;\\n        if(i==r-1 && j==c-1 && op==0){\\n           dp[i][j][op]=1; \\n           return true; \\n        }  \\n        return dp[i][j][op]=solve(g,i+1,j,op)||solve(g,i,j+1,op);        \\n    }\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        r=g.size(),c=g[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        if(g[0][0]==\\')\\' || g[r-1][c-1]==\\'(\\') return false;\\n        solve(g,0,0,0);\\n        return dp[r-1][c-1][0]==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046814,
                "title": "java-dfs-dp",
                "content": "\\n```\\nclass Solution {\\n    char[][] grid;\\n    int m, n;\\n    public static final char LFTPAR = \\'(\\';\\n    public static final char RGTPAR = \\')\\';\\n    public boolean hasValidPath(char[][] grid) {\\n        this.grid = grid;\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        \\n        Boolean[][][] dp = new Boolean[m][n][m+n+1];\\n        \\n        if (grid[0][0] == RGTPAR)\\n            return false;\\n        if (grid[m-1][n-1] == LFTPAR)\\n            return false;\\n        \\n        if ( (m + n) % 2 == 0)\\n            return false;\\n        \\n        return dfs(0, 0, 0, 0, dp);\\n    }\\n    private boolean dfs(int u, int v, int open, int close,  Boolean[][][] dp){\\n        if (grid[u][v] == LFTPAR){\\n            open++;\\n        } else {\\n            close++;\\n        }\\n        if (u == m-1 && v == n -1){\\n            return open == close;\\n        }\\n        if (open < close){\\n            return false;\\n        }\\n        if (dp[u][v][open-close] != null){\\n            return dp[u][v][open - close];\\n        }\\n        if (u == m - 1){\\n            if (grid[u][v] == LFTPAR){\\n                return dp[u][v][open-close] = dfs(u, v+1, open, close, dp);\\n            } else {\\n                return dp[u][v][open-close] = dfs(u, v+1, open, close, dp);\\n            }\\n        }\\n        if (v == n-1){\\n            if (grid[u][v] == LFTPAR){\\n                return dfs(u+1, v, open, close, dp);\\n            } else {\\n                return dfs(u+1, v, open, close, dp);\\n            }\\n        }\\n            \\n        boolean rslt = false;\\n        if (grid[u][v] == LFTPAR){\\n            rslt = dfs(u+1, v, open, close, dp) || \\n                    dfs(u, v+1, open, close, dp);\\n        } else {\\n            rslt = dfs(u, v+1, open, close, dp) ||\\n                    dfs(u + 1, v, open, close, dp);\\n        }\\n        dp[u][v][open-close] = rslt;\\n        return rslt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[][] grid;\\n    int m, n;\\n    public static final char LFTPAR = \\'(\\';\\n    public static final char RGTPAR = \\')\\';\\n    public boolean hasValidPath(char[][] grid) {\\n        this.grid = grid;\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        \\n        Boolean[][][] dp = new Boolean[m][n][m+n+1];\\n        \\n        if (grid[0][0] == RGTPAR)\\n            return false;\\n        if (grid[m-1][n-1] == LFTPAR)\\n            return false;\\n        \\n        if ( (m + n) % 2 == 0)\\n            return false;\\n        \\n        return dfs(0, 0, 0, 0, dp);\\n    }\\n    private boolean dfs(int u, int v, int open, int close,  Boolean[][][] dp){\\n        if (grid[u][v] == LFTPAR){\\n            open++;\\n        } else {\\n            close++;\\n        }\\n        if (u == m-1 && v == n -1){\\n            return open == close;\\n        }\\n        if (open < close){\\n            return false;\\n        }\\n        if (dp[u][v][open-close] != null){\\n            return dp[u][v][open - close];\\n        }\\n        if (u == m - 1){\\n            if (grid[u][v] == LFTPAR){\\n                return dp[u][v][open-close] = dfs(u, v+1, open, close, dp);\\n            } else {\\n                return dp[u][v][open-close] = dfs(u, v+1, open, close, dp);\\n            }\\n        }\\n        if (v == n-1){\\n            if (grid[u][v] == LFTPAR){\\n                return dfs(u+1, v, open, close, dp);\\n            } else {\\n                return dfs(u+1, v, open, close, dp);\\n            }\\n        }\\n            \\n        boolean rslt = false;\\n        if (grid[u][v] == LFTPAR){\\n            rslt = dfs(u+1, v, open, close, dp) || \\n                    dfs(u, v+1, open, close, dp);\\n        } else {\\n            rslt = dfs(u, v+1, open, close, dp) ||\\n                    dfs(u + 1, v, open, close, dp);\\n        }\\n        dp[u][v][open-close] = rslt;\\n        return rslt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046560,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef hasValidPath(self, grid: List[List[str]]) -> bool:\\n\\t\\t\\tm = len(grid)\\n\\t\\t\\tn = len(grid[0])\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dfs(i, j, cnt):\\n\\t\\t\\t\\tif i < 0 or i > m - 1 or j < 0 or j > n - 1 or grid[i][j] == \"#\":\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif grid[i][j] == \"(\":\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\tif grid[i][j] == \")\":\\n\\t\\t\\t\\t\\tcnt -= 1\\n\\t\\t\\t\\tif cnt < 0:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif i == m - 1 and j == n - 1 and cnt == 0:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tcur = grid[i][j]\\n\\t\\t\\t\\tgrid[i][j] = \"#\"\\n\\t\\t\\t\\tif dfs(i + 1, j, cnt) or dfs(i, j + 1, cnt):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tgrid[i][j] = cur\\n\\t\\t\\treturn dfs(0, 0, 0)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef hasValidPath(self, grid: List[List[str]]) -> bool:\\n\\t\\t\\tm = len(grid)\\n\\t\\t\\tn = len(grid[0])\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dfs(i, j, cnt):\\n\\t\\t\\t\\tif i < 0 or i > m - 1 or j < 0 or j > n - 1 or grid[i][j] == \"#\":\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif grid[i][j] == \"(\":\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\tif grid[i][j] == \")\":\\n\\t\\t\\t\\t\\tcnt -= 1\\n\\t\\t\\t\\tif cnt < 0:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif i == m - 1 and j == n - 1 and cnt == 0:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tcur = grid[i][j]\\n\\t\\t\\t\\tgrid[i][j] = \"#\"\\n\\t\\t\\t\\tif dfs(i + 1, j, cnt) or dfs(i, j + 1, cnt):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tgrid[i][j] = cur\\n\\t\\t\\treturn dfs(0, 0, 0)",
                "codeTag": "Java"
            },
            {
                "id": 2046276,
                "title": "c-dp-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        bool f[m][n][101];\\n        for(int i=0;i<m;i++)for(int j=0;j<n;j++)for(int k=0;k<=100;k++)f[i][j][k]=false;\\n        if(grid[0][0]==\\')\\')return false;\\n        f[0][0][1]=true;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                for(int k=0;k<=100;k++)\\n                {\\n                    if(grid[i][j]==\\'(\\')\\n                    {\\n                        if(i-1>=0&&f[i-1][j][k]&&k+1<=100)f[i][j][k+1]=true;\\n                        if(j-1>=0&&f[i][j-1][k]&&k+1<=100)f[i][j][k+1]=true;\\n                    }else\\n                    {\\n                        if(i-1>=0&&f[i-1][j][k]&&k-1>=0)f[i][j][k-1]=true;\\n                        if(j-1>=0&&f[i][j-1][k]&&k-1>=0)f[i][j][k-1]=true;\\n                    }\\n                }\\n        return f[m-1][n-1][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        bool f[m][n][101];\\n        for(int i=0;i<m;i++)for(int j=0;j<n;j++)for(int k=0;k<=100;k++)f[i][j][k]=false;\\n        if(grid[0][0]==\\')\\')return false;\\n        f[0][0][1]=true;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                for(int k=0;k<=100;k++)\\n                {\\n                    if(grid[i][j]==\\'(\\')\\n                    {\\n                        if(i-1>=0&&f[i-1][j][k]&&k+1<=100)f[i][j][k+1]=true;\\n                        if(j-1>=0&&f[i][j-1][k]&&k+1<=100)f[i][j][k+1]=true;\\n                    }else\\n                    {\\n                        if(i-1>=0&&f[i-1][j][k]&&k-1>=0)f[i][j][k-1]=true;\\n                        if(j-1>=0&&f[i][j-1][k]&&k-1>=0)f[i][j][k-1]=true;\\n                    }\\n                }\\n        return f[m-1][n-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039382,
                "title": "java-dp-bottom-up-approach",
                "content": "\\n```\\nclass Solution {\\n    \\n     Boolean dp[][][];\\n     public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\' || grid[grid.length-1][grid[0].length -1] == \\'(\\') return false;\\n        dp = new Boolean[grid.length][grid[0].length][101];\\n\\n        int rows = grid.length;\\n        int col = grid[0].length;\\n\\n        Arrays.fill(dp[rows - 1][col - 1],false);\\n        dp[rows - 1][col -1][0] = true;\\n\\n        for(int i = rows - 1;i>=0;i--){\\n            for(int j = col - 1;j>=0;j--){\\n                if(i == rows - 1 && j == col -1) continue;\\n                if(j + 1 < col){\\n                    for(int k = 0; k <= 100; k++){\\n                        if(dp[i][j+1][k]!=null && dp[i][j+1][k]){\\n                            if(grid[i][j+1]==\\'(\\' ){\\n                                if(k-1>=0) {\\n                                    dp[i][j][k - 1] = true;\\n                                }\\n                            }else {\\n                                if(k+1<=100) {\\n                                dp[i][j][k+1] = true;\\n                                }\\n                            }\\n                        }\\n\\n                    }\\n                }\\n                if(i+1 < rows){\\n                    for(int k = 0; k <= 100; k++){\\n                        if(dp[i+1][j][k]!=null && dp[i+1][j][k]){\\n                            if(grid[i+1][j]==\\'(\\' ){\\n                                if(k-1>=0) {\\n                                    dp[i][j][k - 1] = true;\\n                                }\\n                            }else {\\n                                if(k+1<=100) {\\n                                dp[i][j][k+1] = true;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n            }\\n        }\\n\\n        return dp[0][0][1]!=null && dp[0][0][1];\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n     Boolean dp[][][];\\n     public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\' || grid[grid.length-1][grid[0].length -1] == \\'(\\') return false;\\n        dp = new Boolean[grid.length][grid[0].length][101];\\n\\n        int rows = grid.length;\\n        int col = grid[0].length;\\n\\n        Arrays.fill(dp[rows - 1][col - 1],false);\\n        dp[rows - 1][col -1][0] = true;\\n\\n        for(int i = rows - 1;i>=0;i--){\\n            for(int j = col - 1;j>=0;j--){\\n                if(i == rows - 1 && j == col -1) continue;\\n                if(j + 1 < col){\\n                    for(int k = 0; k <= 100; k++){\\n                        if(dp[i][j+1][k]!=null && dp[i][j+1][k]){\\n                            if(grid[i][j+1]==\\'(\\' ){\\n                                if(k-1>=0) {\\n                                    dp[i][j][k - 1] = true;\\n                                }\\n                            }else {\\n                                if(k+1<=100) {\\n                                dp[i][j][k+1] = true;\\n                                }\\n                            }\\n                        }\\n\\n                    }\\n                }\\n                if(i+1 < rows){\\n                    for(int k = 0; k <= 100; k++){\\n                        if(dp[i+1][j][k]!=null && dp[i+1][j][k]){\\n                            if(grid[i+1][j]==\\'(\\' ){\\n                                if(k-1>=0) {\\n                                    dp[i][j][k - 1] = true;\\n                                }\\n                            }else {\\n                                if(k+1<=100) {\\n                                dp[i][j][k+1] = true;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n            }\\n        }\\n\\n        return dp[0][0][1]!=null && dp[0][0][1];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039247,
                "title": "dfs-memorize",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Boolean[][][] memory = new Boolean[m][n][(m+n)/2 + 1];\\n        return dfs(0, 0, 0, grid, memory);\\n    }\\n    \\n    private boolean dfs(int leftCnt, int x, int y, char[][] grid, Boolean[][][] memory) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        // boundary check\\n        if(x < 0 || y < 0 || x >= m || y >= n) {\\n            return false;\\n        }\\n        \\n        if(grid[x][y] == \\'(\\') {\\n            leftCnt++;\\n        } else if (grid[x][y] == \\')\\') {\\n            leftCnt--;\\n        }\\n        \\n            \\n        if(leftCnt < 0 || leftCnt > (m+n)/2) {\\n            // memory[x][y][leftCnt] = false;\\n            return false; \\n        }\\n        \\n       if(memory[x][y][leftCnt] != null) return memory[x][y][leftCnt]; \\n        \\n        if(x == m -1 && y == n -1 && leftCnt == 0) {\\n            memory[x][y][leftCnt]  = true;\\n            return true;\\n        }\\n        \\n        boolean valid =  dfs(leftCnt, x + 1, y, grid, memory) || dfs(leftCnt, x, y + 1, grid, memory);\\n        memory[x][y][leftCnt]  = valid;\\n        return valid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Boolean[][][] memory = new Boolean[m][n][(m+n)/2 + 1];\\n        return dfs(0, 0, 0, grid, memory);\\n    }\\n    \\n    private boolean dfs(int leftCnt, int x, int y, char[][] grid, Boolean[][][] memory) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        // boundary check\\n        if(x < 0 || y < 0 || x >= m || y >= n) {\\n            return false;\\n        }\\n        \\n        if(grid[x][y] == \\'(\\') {\\n            leftCnt++;\\n        } else if (grid[x][y] == \\')\\') {\\n            leftCnt--;\\n        }\\n        \\n            \\n        if(leftCnt < 0 || leftCnt > (m+n)/2) {\\n            // memory[x][y][leftCnt] = false;\\n            return false; \\n        }\\n        \\n       if(memory[x][y][leftCnt] != null) return memory[x][y][leftCnt]; \\n        \\n        if(x == m -1 && y == n -1 && leftCnt == 0) {\\n            memory[x][y][leftCnt]  = true;\\n            return true;\\n        }\\n        \\n        boolean valid =  dfs(leftCnt, x + 1, y, grid, memory) || dfs(leftCnt, x, y + 1, grid, memory);\\n        memory[x][y][leftCnt]  = valid;\\n        return valid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036439,
                "title": "python-faster-than-99-dp",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[-1][-1] == \"(\": return False\\n        if grid[0][0] == \")\": return False\\n        m, n = len(grid), len(grid[0])\\n        if (m+n) % 2 == 0: return False\\n        @cache\\n        def pos(i, j, cur):\\n            if cur == \")\": return False\\n            if i == m-1 and j == n-1:\\n                if cur == \"(\": return True\\n                return False\\n            if i >= m: return False\\n            if j >= n: return False\\n            if cur and grid[i][j] == \")\" and cur[-1] == \"(\":\\n                cur = cur[:-1]\\n            else:\\n                cur += grid[i][j]\\n            return pos(i+1, j, cur) or pos(i, j+1, cur)\\n        return pos(0,0,\"\")\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[-1][-1] == \"(\": return False\\n        if grid[0][0] == \")\": return False\\n        m, n = len(grid), len(grid[0])\\n        if (m+n) % 2 == 0: return False\\n        @cache\\n        def pos(i, j, cur):\\n            if cur == \")\": return False\\n            if i == m-1 and j == n-1:\\n                if cur == \"(\": return True\\n                return False\\n            if i >= m: return False\\n            if j >= n: return False\\n            if cur and grid[i][j] == \")\" and cur[-1] == \"(\":\\n                cur = cur[:-1]\\n            else:\\n                cur += grid[i][j]\\n            return pos(i+1, j, cur) or pos(i, j+1, cur)\\n        return pos(0,0,\"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032799,
                "title": "help-needed-memo-with-tle",
                "content": "For the below JS code still getting a TLE\\nPlease help.\\n```\\nvar hasValidPath = function(a) {\\n    const [m, n] = [a.length-1, a[a.length-1].length - 1]\\n    const me = {}\\n    const getNeighbours = ([i, j]) => [[i+1, j], [i, j+1]].filter(([i, j]) => a[i]?.[j])\\n    const hasValidPathUtil = ([i, j], s) => {\\n        if(me[[i, j, s]] !== undefined) {\\n            return me[[i, j, s]]\\n        }\\n        let result = false;\\n        const val = a[i][j]\\n        if (val === \\'\\\\)\\') {\\n            if(s.length) s.pop()\\n            else {\\n                me[[i, j, s]] = result;\\n                return result;\\n            }\\n        } else {\\n            s.push(\\'\\\\(\\')\\n        }\\n        if(i === m && j === n && s.length === 0) {\\n            \\n            result = true\\n        } else {\\n            const neighbours = getNeighbours([i, j])\\n            for(let x = 0; x< neighbours.length; x++) {\\n                const [i, j] = neighbours[x]\\n                if(hasValidPathUtil([i, j], [...s])) {\\n                    result = true\\n                    break\\n                }\\n            }\\n        }\\n        me[[i, j, s]] = result;\\n        return result;\\n    }\\n\\n    let res = hasValidPathUtil([0, 0], [])\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasValidPath = function(a) {\\n    const [m, n] = [a.length-1, a[a.length-1].length - 1]\\n    const me = {}\\n    const getNeighbours = ([i, j]) => [[i+1, j], [i, j+1]].filter(([i, j]) => a[i]?.[j])\\n    const hasValidPathUtil = ([i, j], s) => {\\n        if(me[[i, j, s]] !== undefined) {\\n            return me[[i, j, s]]\\n        }\\n        let result = false;\\n        const val = a[i][j]\\n        if (val === \\'\\\\)\\') {\\n            if(s.length) s.pop()\\n            else {\\n                me[[i, j, s]] = result;\\n                return result;\\n            }\\n        } else {\\n            s.push(\\'\\\\(\\')\\n        }\\n        if(i === m && j === n && s.length === 0) {\\n            \\n            result = true\\n        } else {\\n            const neighbours = getNeighbours([i, j])\\n            for(let x = 0; x< neighbours.length; x++) {\\n                const [i, j] = neighbours[x]\\n                if(hasValidPathUtil([i, j], [...s])) {\\n                    result = true\\n                    break\\n                }\\n            }\\n        }\\n        me[[i, j, s]] = result;\\n        return result;\\n    }\\n\\n    let res = hasValidPathUtil([0, 0], [])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2032444,
                "title": "3d-dynamic-programming-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\nint dp[101][101][210];\\npublic:\\n//     // Method 1: Backtracking\\n//     bool solve(vector<vector<char>> &grid, int m, int n, int i, int j, stack<char> &st, vector<vector<bool>> &vis)\\n//     {\\n//         char poop = \\'*\\';\\n//         if (st.empty())\\n//             st.push(grid[i][j]);\\n//         else\\n//         {\\n//             if (st.top() == \\'(\\' && grid[i][j] == \\')\\')\\n//             {\\n//                 st.pop();\\n//                 poop = \\'(\\';\\n//             }\\n//             else if (st.top() == \\')\\' && grid[i][j] == \\'(\\')\\n//                 return false;\\n//             else\\n//                 st.push(grid[i][j]);\\n//         }\\n        \\n//         // cout << \"i: \" << i << \" j: \" << j << endl;\\n//         if (i == m - 1 && j == n - 1)\\n//         {\\n//             if (st.empty())\\n//                 return true;\\n//         }\\n//         else\\n//         {\\n//             vector<pair<int, int>> dir = {{1, 0}, {0, 1}};\\n//             for (int a = 0; a < 2; a++)\\n//             {\\n//                 int ni = i + dir[a].first;\\n//                 int nj = j + dir[a].second;\\n                \\n//                 if (ni >= 0 && ni < m && nj >= 0 && nj < n && !vis[ni][nj])\\n//                 {\\n//                     vis[ni][nj] = true;\\n//                     if (solve(grid, m, n, ni, nj, st, vis) == true)\\n//                         return true;\\n//                     vis[ni][nj] = false;\\n//                 }\\n//             }\\n//         }\\n//         if (poop == \\'(\\')\\n//             st.push(\\'(\\');\\n//         else\\n//             st.pop();\\n//         return false;\\n//     }\\n//     bool hasValidPath(vector<vector<char>>& grid) {\\n//         int m = grid.size();\\n//         int n = grid[0].size();\\n        \\n//         vector<vector<bool>> vis(m, vector<bool> (n, false));\\n        \\n//         stack<char> st;\\n        \\n//         vis[0][0] = true;\\n//         bool ans = solve(grid, m, n, 0, 0, st, vis);\\n//         vis[0][0] = true;\\n//         return ans;\\n//     }\\n \\n    // DP\\n    int solve(vector<vector<char>> &grid, int m, int n, int i, int j, int k)\\n    {\\n        if (i >= m || j >= n)\\n            return 0;\\n        \\n        // First we need to update k and then only see if dp[][][] != -1\\n        if (grid[i][j] == \\'(\\')\\n            k++;\\n        else\\n        {\\n            k--;\\n            if (k < 0)\\n                return 0;\\n        }\\n       \\n        if (dp[i][j][k] != -1)\\n            return dp[i][j][k];\\n        \\n        if (i == m - 1 && j == n - 1)\\n            return dp[i][j][k] = (k == 0);\\n        else       \\n        {\\n            int o1 = solve(grid, m, n, i + 1, j, k);\\n            int o2 = solve(grid, m, n, i, j + 1, k);\\n            \\n            dp[i][j][k] = (o1 | o2);\\n            return dp[i][j][k];\\n        }\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return solve(grid, m, n, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\nint dp[101][101][210];\\npublic:\\n//     // Method 1: Backtracking\\n//     bool solve(vector<vector<char>> &grid, int m, int n, int i, int j, stack<char> &st, vector<vector<bool>> &vis)\\n//     {\\n//         char poop = \\'*\\';\\n//         if (st.empty())\\n//             st.push(grid[i][j]);\\n//         else\\n//         {\\n//             if (st.top() == \\'(\\' && grid[i][j] == \\')\\')\\n//             {\\n//                 st.pop();\\n//                 poop = \\'(\\';\\n//             }\\n//             else if (st.top() == \\')\\' && grid[i][j] == \\'(\\')\\n//                 return false;\\n//             else\\n//                 st.push(grid[i][j]);\\n//         }\\n        \\n//         // cout << \"i: \" << i << \" j: \" << j << endl;\\n//         if (i == m - 1 && j == n - 1)\\n//         {\\n//             if (st.empty())\\n//                 return true;\\n//         }\\n//         else\\n//         {\\n//             vector<pair<int, int>> dir = {{1, 0}, {0, 1}};\\n//             for (int a = 0; a < 2; a++)\\n//             {\\n//                 int ni = i + dir[a].first;\\n//                 int nj = j + dir[a].second;\\n                \\n//                 if (ni >= 0 && ni < m && nj >= 0 && nj < n && !vis[ni][nj])\\n//                 {\\n//                     vis[ni][nj] = true;\\n//                     if (solve(grid, m, n, ni, nj, st, vis) == true)\\n//                         return true;\\n//                     vis[ni][nj] = false;\\n//                 }\\n//             }\\n//         }\\n//         if (poop == \\'(\\')\\n//             st.push(\\'(\\');\\n//         else\\n//             st.pop();\\n//         return false;\\n//     }\\n//     bool hasValidPath(vector<vector<char>>& grid) {\\n//         int m = grid.size();\\n//         int n = grid[0].size();\\n        \\n//         vector<vector<bool>> vis(m, vector<bool> (n, false));\\n        \\n//         stack<char> st;\\n        \\n//         vis[0][0] = true;\\n//         bool ans = solve(grid, m, n, 0, 0, st, vis);\\n//         vis[0][0] = true;\\n//         return ans;\\n//     }\\n \\n    // DP\\n    int solve(vector<vector<char>> &grid, int m, int n, int i, int j, int k)\\n    {\\n        if (i >= m || j >= n)\\n            return 0;\\n        \\n        // First we need to update k and then only see if dp[][][] != -1\\n        if (grid[i][j] == \\'(\\')\\n            k++;\\n        else\\n        {\\n            k--;\\n            if (k < 0)\\n                return 0;\\n        }\\n       \\n        if (dp[i][j][k] != -1)\\n            return dp[i][j][k];\\n        \\n        if (i == m - 1 && j == n - 1)\\n            return dp[i][j][k] = (k == 0);\\n        else       \\n        {\\n            int o1 = solve(grid, m, n, i + 1, j, k);\\n            int o2 = solve(grid, m, n, i, j + 1, k);\\n            \\n            dp[i][j][k] = (o1 | o2);\\n            return dp[i][j][k];\\n        }\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return solve(grid, m, n, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2032255,
                "title": "python-3-simple-recursive-memoization",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @lru_cache(None)\\n        def helper(i, j, score):\\n            if i == m or j == n:\\n                return False\\n            if i == m - 1 and j == n - 1:\\n                return score == 1 and grid[i][j] == \\')\\'\\n            \\n            if grid[i][j] == \\'(\\':\\n                return helper(i + 1, j, score + 1) or helper(i, j + 1, score + 1)\\n            if score == 0:\\n                return False\\n            return helper(i + 1, j, score - 1) or helper(i, j + 1, score - 1)\\n        \\n        return helper(0, 0, 0)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @lru_cache(None)\\n        def helper(i, j, score):\\n            if i == m or j == n:\\n                return False\\n            if i == m - 1 and j == n - 1:\\n                return score == 1 and grid[i][j] == \\')\\'\\n            \\n            if grid[i][j] == \\'(\\':\\n                return helper(i + 1, j, score + 1) or helper(i, j + 1, score + 1)\\n            if score == 0:\\n                return False\\n            return helper(i + 1, j, score - 1) or helper(i, j + 1, score - 1)\\n        \\n        return helper(0, 0, 0)",
                "codeTag": "Java"
            },
            {
                "id": 2032043,
                "title": "simple-python-solution-dp-o-mn-time-and-space-complexity",
                "content": "```\\n\"\"\"\\nBasic idea:\\n===========\\n1.  For a parenthesis to be valid:\\n    As we traverse the path, we count the total left and right brackets encountered so far.\\n    At any point along the path, the following must always be true:\\n\\n        total left brackets >= total right brackets \\n\\n2.  We define a list of lists of m x n dimensions named \"brackets\". \\n    Each element in \"brackets\" contains a set of tuples.\\n    Each tuple is defined as (total left brackets, total right brackets).\\n    The set represents all the possible combinations of the tuples at the current row / column.\\n\\n3.  brackets@current position = brackets@top + brackets@left\\n    => brackets[r][c] = brackets[r-1][c] + brackets[r+1][c]\\n    We allow addition only if before and after adding, total left brackets >= total right brackets.\\n\\n4.  At the bottom right of the grid, return:\\n    True - if there exists a tuple such that total left brackets == total right brackets;\\n    False- if there are no tuples where total left brackets == total right brackets.\\n\"\"\"\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def addBracket(r, c, prev_r, prev_c):\\n            nonlocal brackets\\n            if 0 <= prev_r < m and 0 <= prev_c < n:                \\n                for left, right in brackets[prev_r][prev_c]:\\n                    if left >= right:\\n                        new_left = left + (1 if grid[r][c] == \\'(\\' else 0)\\n                        new_right = right + (1 if grid[r][c] == \\')\\' else 0)\\n                        if new_left >= new_right:\\n                            brackets[r][c].add((new_left, new_right))\\n            \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        brackets = [[set() for i in range(n)] for j in range(m)]\\n        brackets[0][0].add((1 if grid[0][0] == \\'(\\' else 0, 1 if grid[0][0] == \\')\\' else 0))\\n        for i in range(m):\\n            for j in range(n):\\n                addBracket(i, j, i-1, j)\\n                addBracket(i, j, i, j-1)\\n        \\n        pathFound = False\\n        for left, right in brackets[m-1][n-1]:\\n            if left == right:\\n                pathFound = True\\n                break\\n        return pathFound\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nBasic idea:\\n===========\\n1.  For a parenthesis to be valid:\\n    As we traverse the path, we count the total left and right brackets encountered so far.\\n    At any point along the path, the following must always be true:\\n\\n        total left brackets >= total right brackets \\n\\n2.  We define a list of lists of m x n dimensions named \"brackets\". \\n    Each element in \"brackets\" contains a set of tuples.\\n    Each tuple is defined as (total left brackets, total right brackets).\\n    The set represents all the possible combinations of the tuples at the current row / column.\\n\\n3.  brackets@current position = brackets@top + brackets@left\\n    => brackets[r][c] = brackets[r-1][c] + brackets[r+1][c]\\n    We allow addition only if before and after adding, total left brackets >= total right brackets.\\n\\n4.  At the bottom right of the grid, return:\\n    True - if there exists a tuple such that total left brackets == total right brackets;\\n    False- if there are no tuples where total left brackets == total right brackets.\\n\"\"\"\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def addBracket(r, c, prev_r, prev_c):\\n            nonlocal brackets\\n            if 0 <= prev_r < m and 0 <= prev_c < n:                \\n                for left, right in brackets[prev_r][prev_c]:\\n                    if left >= right:\\n                        new_left = left + (1 if grid[r][c] == \\'(\\' else 0)\\n                        new_right = right + (1 if grid[r][c] == \\')\\' else 0)\\n                        if new_left >= new_right:\\n                            brackets[r][c].add((new_left, new_right))\\n            \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        brackets = [[set() for i in range(n)] for j in range(m)]\\n        brackets[0][0].add((1 if grid[0][0] == \\'(\\' else 0, 1 if grid[0][0] == \\')\\' else 0))\\n        for i in range(m):\\n            for j in range(n):\\n                addBracket(i, j, i-1, j)\\n                addBracket(i, j, i, j-1)\\n        \\n        pathFound = False\\n        for left, right in brackets[m-1][n-1]:\\n            if left == right:\\n                pathFound = True\\n                break\\n        return pathFound\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031202,
                "title": "c-dfs-dp",
                "content": "```\\npublic class Solution\\n{\\n    private int[][][] dp = new int[100][][];\\n\\n    public bool DFS(char[][] grid, int i, int j, int k)\\n    {\\n        if (i >= grid.Length || j >= grid[0].Length)\\n        {\\n            return false;\\n        }\\n\\n        if (grid[i][j] == \\'(\\')\\n        {\\n            k++;\\n        }\\n        else\\n        {\\n            k--;\\n        }\\n\\n        if (k < 0)\\n        {\\n            return false;\\n        }\\n\\n        if (i == grid.Length - 1 && j == grid[0].Length - 1)\\n        {\\n            return k == 0;\\n        }\\n\\n        if (dp[i][j][k] != -1)\\n        {\\n            return Convert.ToBoolean(dp[i][j][k]);\\n        }\\n\\n        dp[i][j][k] = Convert.ToInt32(DFS(grid, i + 1, j, k) | DFS(grid, i, j + 1, k));\\n        return Convert.ToBoolean(dp[i][j][k]);\\n    }\\n    \\n    public bool HasValidPath(char[][] grid)\\n    {\\n        for (int i = 0; i < dp.Length; i++)\\n        {\\n            dp[i] = new int[100][];\\n            for (int j = 0; j < dp[i].Length; j++)\\n            {\\n                dp[i][j] = new int[205];\\n                Array.Fill(dp[i][j], -1);\\n            }\\n        }\\n        return DFS(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution\\n{\\n    private int[][][] dp = new int[100][][];\\n\\n    public bool DFS(char[][] grid, int i, int j, int k)\\n    {\\n        if (i >= grid.Length || j >= grid[0].Length)\\n        {\\n            return false;\\n        }\\n\\n        if (grid[i][j] == \\'(\\')\\n        {\\n            k++;\\n        }\\n        else\\n        {\\n            k--;\\n        }\\n\\n        if (k < 0)\\n        {\\n            return false;\\n        }\\n\\n        if (i == grid.Length - 1 && j == grid[0].Length - 1)\\n        {\\n            return k == 0;\\n        }\\n\\n        if (dp[i][j][k] != -1)\\n        {\\n            return Convert.ToBoolean(dp[i][j][k]);\\n        }\\n\\n        dp[i][j][k] = Convert.ToInt32(DFS(grid, i + 1, j, k) | DFS(grid, i, j + 1, k));\\n        return Convert.ToBoolean(dp[i][j][k]);\\n    }\\n    \\n    public bool HasValidPath(char[][] grid)\\n    {\\n        for (int i = 0; i < dp.Length; i++)\\n        {\\n            dp[i] = new int[100][];\\n            for (int j = 0; j < dp[i].Length; j++)\\n            {\\n                dp[i][j] = new int[205];\\n                Array.Fill(dp[i][j], -1);\\n            }\\n        }\\n        return DFS(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031136,
                "title": "c-solution",
                "content": "```\\nvoid right(int i, int j, int** list, int* count){\\n    int copy[200];\\n    int Count = 0;\\n    int a = 0;\\n    int b = 0;\\n    while (a < count[j] || b < count[j+1]){\\n        if (a >= count[j]){\\n            while (b < count[j+1]){\\n                copy[Count] = list[j+1][b];\\n                Count++;\\n                b++;\\n            }\\n        } else if (b >= count[j+1]){\\n            while (a < count[j]){\\n                copy[Count] = list[j][a];\\n                Count++;\\n                a++;\\n            }\\n        } else if (list[j][a] > list[j+1][b]){\\n            copy[Count] = list[j+1][b];\\n            Count++;\\n            b++;\\n        } else if (list[j][a] < list[j+1][b]){\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n        } else {\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n            b++;\\n        }\\n    }\\n    while (Count > 0 && copy[Count-1] > 99){\\n        Count--;\\n    }\\n    for (int i = 0 ; i < Count ; i++){\\n        list[j][i] = copy[i]+1;\\n    }\\n    count[j] = Count;\\n}\\n\\nvoid left(int i, int j, int** list, int* count){\\n    int copy[200];\\n    int Count = 0;\\n    int a = 0;\\n    int b = 0;\\n    while (a < count[j] || b < count[j+1]){\\n        if (a >= count[j]){\\n            while (b < count[j+1]){\\n                copy[Count] = list[j+1][b];\\n                Count++;\\n                b++;\\n            }\\n        } else if (b >= count[j+1]){\\n            while (a < count[j]){\\n                copy[Count] = list[j][a];\\n                Count++;\\n                a++;\\n            }\\n        } else if (list[j][a] > list[j+1][b]){\\n            copy[Count] = list[j+1][b];\\n            Count++;\\n            b++;\\n        } else if (list[j][a] < list[j+1][b]){\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n        } else {\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n            b++;\\n        }\\n    }\\n    int h = 0;\\n    while (h < Count && copy[h] < 1){\\n        h++;\\n    }\\n    count[j] = 0;\\n    for (; h < Count ; h++){\\n        list[j][count[j]] = copy[h]-1;\\n        count[j]++;\\n    }\\n}\\n\\nbool hasValidPath(char** grid, int gridSize, int* gridColSize){\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    if (grid[x][y] == \\'(\\' || grid[0][0] == \\')\\'  || (x+y) % 2 == 0){\\n        return false;\\n    }\\n    \\n    int** list = malloc(sizeof(int*)*(*gridColSize));\\n    for (int i = 0 ; i < (*gridColSize) ; i++){\\n        list[i] = malloc(sizeof(int)*100);\\n    }\\n    int* count = calloc(101,sizeof(int));\\n    list[y][0] = 1;\\n    count[y]++;\\n    \\n    for (int j = y-1 ; j >= 0 ; j--){\\n        if (list[j+1][0] >= 0){\\n            if (grid[x][j] == \\')\\'){\\n                list[j][0] = list[j+1][0]+1;\\n                count[j]++;\\n            } else {\\n                list[j][0] = list[j+1][0]-1;\\n                if (list[j][count[j]] >= 0){\\n                    count[j]++;\\n                }\\n            }\\n        } else {\\n            list[j][0] = -1;\\n        }\\n    }\\n    \\n    for (int i = x-1 ; i >= 0 ; i--){\\n        if (list[y][0] >= 0){\\n            if (grid[i][y] == \\')\\'){\\n                list[y][0]++;\\n            } else {\\n                list[y][0]--;\\n                if (list[y][0] < 0){\\n                    count[y]--;\\n                }\\n            }\\n        }\\n        for (int j = y-1 ; j >= 0 ; j--){\\n            if (grid[i][j] == \\')\\'){\\n                right( i, j, list, count);\\n            } else {\\n                left( i, j, list, count);\\n            }\\n        }\\n    }\\n    int ans = list[0][0];\\n    for (int i = 0 ; i < *gridColSize ; i++){\\n        free(list[i]);\\n    }\\n    free(list);\\n    return ans == 0 ? true : false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid right(int i, int j, int** list, int* count){\\n    int copy[200];\\n    int Count = 0;\\n    int a = 0;\\n    int b = 0;\\n    while (a < count[j] || b < count[j+1]){\\n        if (a >= count[j]){\\n            while (b < count[j+1]){\\n                copy[Count] = list[j+1][b];\\n                Count++;\\n                b++;\\n            }\\n        } else if (b >= count[j+1]){\\n            while (a < count[j]){\\n                copy[Count] = list[j][a];\\n                Count++;\\n                a++;\\n            }\\n        } else if (list[j][a] > list[j+1][b]){\\n            copy[Count] = list[j+1][b];\\n            Count++;\\n            b++;\\n        } else if (list[j][a] < list[j+1][b]){\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n        } else {\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n            b++;\\n        }\\n    }\\n    while (Count > 0 && copy[Count-1] > 99){\\n        Count--;\\n    }\\n    for (int i = 0 ; i < Count ; i++){\\n        list[j][i] = copy[i]+1;\\n    }\\n    count[j] = Count;\\n}\\n\\nvoid left(int i, int j, int** list, int* count){\\n    int copy[200];\\n    int Count = 0;\\n    int a = 0;\\n    int b = 0;\\n    while (a < count[j] || b < count[j+1]){\\n        if (a >= count[j]){\\n            while (b < count[j+1]){\\n                copy[Count] = list[j+1][b];\\n                Count++;\\n                b++;\\n            }\\n        } else if (b >= count[j+1]){\\n            while (a < count[j]){\\n                copy[Count] = list[j][a];\\n                Count++;\\n                a++;\\n            }\\n        } else if (list[j][a] > list[j+1][b]){\\n            copy[Count] = list[j+1][b];\\n            Count++;\\n            b++;\\n        } else if (list[j][a] < list[j+1][b]){\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n        } else {\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n            b++;\\n        }\\n    }\\n    int h = 0;\\n    while (h < Count && copy[h] < 1){\\n        h++;\\n    }\\n    count[j] = 0;\\n    for (; h < Count ; h++){\\n        list[j][count[j]] = copy[h]-1;\\n        count[j]++;\\n    }\\n}\\n\\nbool hasValidPath(char** grid, int gridSize, int* gridColSize){\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    if (grid[x][y] == \\'(\\' || grid[0][0] == \\')\\'  || (x+y) % 2 == 0){\\n        return false;\\n    }\\n    \\n    int** list = malloc(sizeof(int*)*(*gridColSize));\\n    for (int i = 0 ; i < (*gridColSize) ; i++){\\n        list[i] = malloc(sizeof(int)*100);\\n    }\\n    int* count = calloc(101,sizeof(int));\\n    list[y][0] = 1;\\n    count[y]++;\\n    \\n    for (int j = y-1 ; j >= 0 ; j--){\\n        if (list[j+1][0] >= 0){\\n            if (grid[x][j] == \\')\\'){\\n                list[j][0] = list[j+1][0]+1;\\n                count[j]++;\\n            } else {\\n                list[j][0] = list[j+1][0]-1;\\n                if (list[j][count[j]] >= 0){\\n                    count[j]++;\\n                }\\n            }\\n        } else {\\n            list[j][0] = -1;\\n        }\\n    }\\n    \\n    for (int i = x-1 ; i >= 0 ; i--){\\n        if (list[y][0] >= 0){\\n            if (grid[i][y] == \\')\\'){\\n                list[y][0]++;\\n            } else {\\n                list[y][0]--;\\n                if (list[y][0] < 0){\\n                    count[y]--;\\n                }\\n            }\\n        }\\n        for (int j = y-1 ; j >= 0 ; j--){\\n            if (grid[i][j] == \\')\\'){\\n                right( i, j, list, count);\\n            } else {\\n                left( i, j, list, count);\\n            }\\n        }\\n    }\\n    int ans = list[0][0];\\n    for (int i = 0 ; i < *gridColSize ; i++){\\n        free(list[i]);\\n    }\\n    free(list);\\n    return ans == 0 ? true : false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030005,
                "title": "easy-and-intuitive-java-memoization-and-tabulation-codes",
                "content": "Method 1 : Memoization \\n\\n```\\nclass Solution {\\n    Boolean dp[][][];\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        dp = new Boolean[rows][cols][rows+cols];\\n        return hasValidPath(grid,0,0,rows,cols,0);\\n    }\\n    \\n    private boolean hasValidPath(char grid[][],int row,int col,int rows,int cols,int count){\\n        if(row>=rows||col>=cols) return false;\\n        \\n        char bracket = grid[row][col];\\n        \\n        if(bracket==\\'(\\') count++;\\n        else count--;\\n        \\n        if(count<0) return false;\\n        \\n        if(row==rows-1&&col==cols-1) return count==0;\\n        \\n        if(dp[row][col][count]!=null) return dp[row][col][count];\\n        \\n        return dp[row][col][count] = hasValidPath(grid,row,col+1,rows,cols,count)\\n                                   ||hasValidPath(grid,row+1,col,rows,cols,count);\\n    }\\n}\\n```\\n\\nMethod 2 : Tabulation\\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        boolean dp[][][] = new boolean[rows][cols][rows+cols];\\n        \\n        for(int row=rows-1;row>=0;row--){\\n            \\n            for(int col=cols-1;col>=0;col--){\\n                char bracket = grid[row][col];\\n                \\n                for(int count = 0;count<rows+cols;count++){\\n                    int nextCount = count;\\n                    if(bracket==\\'(\\') nextCount++;\\n                    else nextCount--;\\n                    \\n                    if(nextCount<0) continue;\\n                    \\n                    if(row==rows-1&&col==cols-1) dp[row][col][count] = (nextCount==0);\\n                    else if(nextCount<rows+cols){\\n                        if(col+1<cols) dp[row][col][count]|=dp[row][col+1][nextCount];\\n                        if(row+1<rows) dp[row][col][count]|=dp[row+1][col][nextCount];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][0];\\n    }\\n}\\n```\\n\\nBoth codes have time and space complexity of O(rows*cols*(rows+cols))\\n\\nEdit : Method 2 space optimized , works in O(cols*(rows+cols)) space : \\n\\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        boolean dp[][][] = new boolean[2][cols][rows+cols];\\n        \\n        for(int row=rows-1;row>=0;row--){\\n            \\n            for(int col=cols-1;col>=0;col--){\\n                char bracket = grid[row][col];\\n                \\n                for(int count = 0;count<rows+cols;count++){\\n                    int nextCount = count;\\n                    if(bracket==\\'(\\') nextCount++;\\n                    else nextCount--;\\n                    \\n                    if(nextCount<0) continue;\\n                    \\n                    if(row==rows-1&&col==cols-1) dp[0][col][count] = (nextCount==0);\\n                    else if(nextCount<rows+cols){\\n                        if(col+1<cols) dp[0][col][count]|=dp[0][col+1][nextCount];\\n                        if(row+1<rows) dp[0][col][count]|=dp[1][col][nextCount];\\n                    }\\n                }\\n            }\\n            \\n            if(row>0){\\n                for(int col=cols-1;col>=0;col--){\\n                    for(int count = 0;count<rows+cols;count++){\\n                        dp[1][col][count] = dp[0][col][count];\\n                        dp[0][col][count] = false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    Boolean dp[][][];\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        dp = new Boolean[rows][cols][rows+cols];\\n        return hasValidPath(grid,0,0,rows,cols,0);\\n    }\\n    \\n    private boolean hasValidPath(char grid[][],int row,int col,int rows,int cols,int count){\\n        if(row>=rows||col>=cols) return false;\\n        \\n        char bracket = grid[row][col];\\n        \\n        if(bracket==\\'(\\') count++;\\n        else count--;\\n        \\n        if(count<0) return false;\\n        \\n        if(row==rows-1&&col==cols-1) return count==0;\\n        \\n        if(dp[row][col][count]!=null) return dp[row][col][count];\\n        \\n        return dp[row][col][count] = hasValidPath(grid,row,col+1,rows,cols,count)\\n                                   ||hasValidPath(grid,row+1,col,rows,cols,count);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        boolean dp[][][] = new boolean[rows][cols][rows+cols];\\n        \\n        for(int row=rows-1;row>=0;row--){\\n            \\n            for(int col=cols-1;col>=0;col--){\\n                char bracket = grid[row][col];\\n                \\n                for(int count = 0;count<rows+cols;count++){\\n                    int nextCount = count;\\n                    if(bracket==\\'(\\') nextCount++;\\n                    else nextCount--;\\n                    \\n                    if(nextCount<0) continue;\\n                    \\n                    if(row==rows-1&&col==cols-1) dp[row][col][count] = (nextCount==0);\\n                    else if(nextCount<rows+cols){\\n                        if(col+1<cols) dp[row][col][count]|=dp[row][col+1][nextCount];\\n                        if(row+1<rows) dp[row][col][count]|=dp[row+1][col][nextCount];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        boolean dp[][][] = new boolean[2][cols][rows+cols];\\n        \\n        for(int row=rows-1;row>=0;row--){\\n            \\n            for(int col=cols-1;col>=0;col--){\\n                char bracket = grid[row][col];\\n                \\n                for(int count = 0;count<rows+cols;count++){\\n                    int nextCount = count;\\n                    if(bracket==\\'(\\') nextCount++;\\n                    else nextCount--;\\n                    \\n                    if(nextCount<0) continue;\\n                    \\n                    if(row==rows-1&&col==cols-1) dp[0][col][count] = (nextCount==0);\\n                    else if(nextCount<rows+cols){\\n                        if(col+1<cols) dp[0][col][count]|=dp[0][col+1][nextCount];\\n                        if(row+1<rows) dp[0][col][count]|=dp[1][col][nextCount];\\n                    }\\n                }\\n            }\\n            \\n            if(row>0){\\n                for(int col=cols-1;col>=0;col--){\\n                    for(int count = 0;count<rows+cols;count++){\\n                        dp[1][col][count] = dp[0][col][count];\\n                        dp[0][col][count] = false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029706,
                "title": "brute-force",
                "content": "This works due to small constraints. Save all possible balances at every cell. Use these balances to populate all possible balances in the right and down cell. Then return true if 0 balance is possible in bottom right cell \\n\\n```import java.util.*;\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Set<Integer>[][] sets = new Set[m][n];\\n\\n        if (grid[0][0] != \\'(\\' || grid[m-1][n-1] != \\')\\') {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sets[i][j] = new HashSet<>();\\n                if(i == 0 && j == 0) {\\n                    sets[0][0].add(1);\\n                    continue;\\n                }\\n                int toAdd = grid[i][j] == \\')\\' ? -1 : 1;\\n\\n                if (i-1 >= 0) {\\n                    Iterator<Integer> it = sets[i-1][j].iterator();\\n                    while(it.hasNext()) {\\n                        int val = it.next() + toAdd;\\n                        if (val >= 0) {\\n                            sets[i][j].add(val);\\n                        }\\n                        \\n                    }\\n                }\\n                if (j-1 >= 0) {\\n                    Iterator<Integer> it = sets[i][j-1].iterator();\\n                    while (it.hasNext()) {\\n                        int val = it.next() + toAdd;\\n                        if (val >= 0) {\\n                            sets[i][j].add(val);\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n        return sets[m-1][n-1].contains(0);\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```import java.util.*;\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Set<Integer>[][] sets = new Set[m][n];\\n\\n        if (grid[0][0] != \\'(\\' || grid[m-1][n-1] != \\')\\') {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sets[i][j] = new HashSet<>();\\n                if(i == 0 && j == 0) {\\n                    sets[0][0].add(1);\\n                    continue;\\n                }\\n                int toAdd = grid[i][j] == \\')\\' ? -1 : 1;\\n\\n                if (i-1 >= 0) {\\n                    Iterator<Integer> it = sets[i-1][j].iterator();\\n                    while(it.hasNext()) {\\n                        int val = it.next() + toAdd;\\n                        if (val >= 0) {\\n                            sets[i][j].add(val);\\n                        }\\n                        \\n                    }\\n                }\\n                if (j-1 >= 0) {\\n                    Iterator<Integer> it = sets[i][j-1].iterator();\\n                    while (it.hasNext()) {\\n                        int val = it.next() + toAdd;\\n                        if (val >= 0) {\\n                            sets[i][j].add(val);\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n        return sets[m-1][n-1].contains(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029374,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        boolean[][][] visited = new boolean[grid.length][grid[0].length][grid.length + grid[0].length];\\n        return dfs(0, 0, grid, visited, 0);\\n    }\\n\\n    private boolean dfs(int col, int row, char[][] grid, boolean[][][] visited, int parenthesesCounter) {\\n        if (col > grid.length - 1 || row > grid[0].length - 1) return false;\\n        parenthesesCounter += grid[col][row] == \\'(\\' ? 1 : - 1;\\n        if (parenthesesCounter < 0 || parenthesesCounter > (grid.length + grid[0].length) / 2 || visited[col][row][parenthesesCounter]) return false;\\n        visited[col][row][parenthesesCounter] = true;\\n        if (col == grid.length - 1 && row == grid[0].length - 1 && parenthesesCounter == 0) return true;\\n        return dfs(col + 1, row, grid, visited, parenthesesCounter) || dfs(col, row + 1, grid, visited, parenthesesCounter);\\n\\t\\t}\\n\\t}\\n  \\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        boolean[][][] visited = new boolean[grid.length][grid[0].length][grid.length + grid[0].length];\\n        return dfs(0, 0, grid, visited, 0);\\n    }\\n\\n    private boolean dfs(int col, int row, char[][] grid, boolean[][][] visited, int parenthesesCounter) {\\n        if (col > grid.length - 1 || row > grid[0].length - 1) return false;\\n        parenthesesCounter += grid[col][row] == \\'(\\' ? 1 : - 1;\\n        if (parenthesesCounter < 0 || parenthesesCounter > (grid.length + grid[0].length) / 2 || visited[col][row][parenthesesCounter]) return false;\\n        visited[col][row][parenthesesCounter] = true;\\n        if (col == grid.length - 1 && row == grid[0].length - 1 && parenthesesCounter == 0) return true;\\n        return dfs(col + 1, row, grid, visited, parenthesesCounter) || dfs(col, row + 1, grid, visited, parenthesesCounter);\\n\\t\\t}\\n\\t}\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027606,
                "title": "java-dp-set",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        char L = \\'(\\';\\n        char R = \\')\\';\\n        \\n        if(!(grid[0][0] == L && grid[n - 1][m - 1] == R)) return false;\\n\\n        Set<Integer>[][] dp = new HashSet[n][m];\\n        Set<Integer> init = new HashSet<>();\\n        init.add(1);\\n        dp[0][0] = init;\\n        \\n        // top\\n        for(int j = 1; j < m; j++){\\n            Set<Integer> curr = new HashSet<>();\\n            \\n            if(grid[0][j] == R){\\n                for(int val : dp[0][j - 1]){\\n                    if(val >= 0){\\n                        curr.add(val - 1);\\n                    }\\n                }\\n            }else{\\n                for(int val : dp[0][j - 1]){\\n                    if(val >= 0){\\n                        curr.add(val + 1);\\n                    }\\n                }\\n            }\\n            dp[0][j] = curr;\\n        }\\n        \\n        // left\\n        for(int i = 1; i < n; i++){\\n            Set<Integer> curr = new HashSet<>();\\n            if(dp[i - 1][0].contains(-1)){\\n                curr.add(-1);\\n                dp[i][0] = curr;\\n                continue;\\n            }\\n            \\n            \\n            if(grid[i][0] == R){\\n                for(int val : dp[i - 1][0]){\\n                    if(val >= 0){\\n                        curr.add(val - 1);\\n                    }\\n                }\\n            }else{\\n                for(int val : dp[i - 1][0]){\\n                    if(val >= 0){\\n                        curr.add(val + 1);\\n                    }\\n                }\\n            }\\n            dp[i][0] = curr;\\n        }\\n        \\n        // regular\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                Set<Integer> curr = new HashSet<>();\\n                \\n                if(dp[i - 1][j].contains(-1) && dp[i][j - 1].contains(-1)){\\n                    curr.add(-1);\\n                    dp[i][j] = curr;\\n                    continue;\\n                }\\n                \\n                if(grid[i][j] == R){\\n                    for(int val : dp[i][j - 1]){\\n                        if(val - 1 >= 0){\\n                            curr.add(val - 1);\\n                        }\\n                    }\\n                    \\n                    for(int val : dp[i - 1][j]){\\n                        if(val - 1 >= 0){\\n                            curr.add(val - 1);\\n                        }\\n                    }\\n                    \\n                }else{\\n                    for(int val : dp[i][j - 1]){\\n                        if(val >= 0){\\n                            curr.add(val + 1);\\n                        }\\n                    }\\n                    \\n                    for(int val : dp[i - 1][j]){\\n                        if(val >= 0){\\n                            curr.add(val + 1);\\n                        }\\n                    }\\n                }\\n                \\n                dp[i][j] = curr;\\n            }\\n        }\\n        \\n        return dp[n - 1][m - 1].contains(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        char L = \\'(\\';\\n        char R = \\')\\';\\n        \\n        if(!(grid[0][0] == L && grid[n - 1][m - 1] == R)) return false;\\n\\n        Set<Integer>[][] dp = new HashSet[n][m];\\n        Set<Integer> init = new HashSet<>();\\n        init.add(1);\\n        dp[0][0] = init;\\n        \\n        // top\\n        for(int j = 1; j < m; j++){\\n            Set<Integer> curr = new HashSet<>();\\n            \\n            if(grid[0][j] == R){\\n                for(int val : dp[0][j - 1]){\\n                    if(val >= 0){\\n                        curr.add(val - 1);\\n                    }\\n                }\\n            }else{\\n                for(int val : dp[0][j - 1]){\\n                    if(val >= 0){\\n                        curr.add(val + 1);\\n                    }\\n                }\\n            }\\n            dp[0][j] = curr;\\n        }\\n        \\n        // left\\n        for(int i = 1; i < n; i++){\\n            Set<Integer> curr = new HashSet<>();\\n            if(dp[i - 1][0].contains(-1)){\\n                curr.add(-1);\\n                dp[i][0] = curr;\\n                continue;\\n            }\\n            \\n            \\n            if(grid[i][0] == R){\\n                for(int val : dp[i - 1][0]){\\n                    if(val >= 0){\\n                        curr.add(val - 1);\\n                    }\\n                }\\n            }else{\\n                for(int val : dp[i - 1][0]){\\n                    if(val >= 0){\\n                        curr.add(val + 1);\\n                    }\\n                }\\n            }\\n            dp[i][0] = curr;\\n        }\\n        \\n        // regular\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                Set<Integer> curr = new HashSet<>();\\n                \\n                if(dp[i - 1][j].contains(-1) && dp[i][j - 1].contains(-1)){\\n                    curr.add(-1);\\n                    dp[i][j] = curr;\\n                    continue;\\n                }\\n                \\n                if(grid[i][j] == R){\\n                    for(int val : dp[i][j - 1]){\\n                        if(val - 1 >= 0){\\n                            curr.add(val - 1);\\n                        }\\n                    }\\n                    \\n                    for(int val : dp[i - 1][j]){\\n                        if(val - 1 >= 0){\\n                            curr.add(val - 1);\\n                        }\\n                    }\\n                    \\n                }else{\\n                    for(int val : dp[i][j - 1]){\\n                        if(val >= 0){\\n                            curr.add(val + 1);\\n                        }\\n                    }\\n                    \\n                    for(int val : dp[i - 1][j]){\\n                        if(val >= 0){\\n                            curr.add(val + 1);\\n                        }\\n                    }\\n                }\\n                \\n                dp[i][j] = curr;\\n            }\\n        }\\n        \\n        return dp[n - 1][m - 1].contains(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025540,
                "title": "one-pass-over-all-cells-88-speed",
                "content": "![image](https://assets.leetcode.com/users/images/43f1130f-7346-4900-a3ce-711a6a37be3d_1652181745.882908.png)\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        rows, cols = len(grid), len(grid[0])\\n        if ((rows + cols - 1) % 2 or grid[0][0] == \")\"\\n                or grid[rows - 1][cols - 1] == \"(\"):\\n            return False\\n        opened = [[set() for _ in range(cols)] for _ in range(rows)]\\n        opened[0][0].add(1)\\n        row = 0\\n        for col in range(1, cols):\\n            if grid[row][col] == \"(\":\\n                opened[row][col].update(n + 1 for n in opened[row][col - 1])\\n            else:\\n                opened[row][col].update(n - 1 for n in opened[row][col - 1]\\n                                        if n > 0)\\n        col = 0\\n        for row in range(1, rows):\\n            if grid[row][col] == \"(\":\\n                opened[row][col].update(n + 1 for n in opened[row - 1][col])\\n            else:\\n                opened[row][col].update(n - 1 for n in opened[row - 1][col]\\n                                        if n > 0)\\n        for row in range(1, rows):\\n            for col in range(1, cols):\\n                opened[row - 1][col].update(opened[row][col - 1])\\n                if grid[row][col] == \"(\":\\n                    opened[row][col].update(n + 1 for n in\\n                                            opened[row - 1][col])\\n                else:\\n                    opened[row][col].update(n - 1 for n in\\n                                            opened[row - 1][col] if n > 0)\\n        return 0 in opened[rows - 1][cols - 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        rows, cols = len(grid), len(grid[0])\\n        if ((rows + cols - 1) % 2 or grid[0][0] == \")\"\\n                or grid[rows - 1][cols - 1] == \"(\"):\\n            return False\\n        opened = [[set() for _ in range(cols)] for _ in range(rows)]\\n        opened[0][0].add(1)\\n        row = 0\\n        for col in range(1, cols):\\n            if grid[row][col] == \"(\":\\n                opened[row][col].update(n + 1 for n in opened[row][col - 1])\\n            else:\\n                opened[row][col].update(n - 1 for n in opened[row][col - 1]\\n                                        if n > 0)\\n        col = 0\\n        for row in range(1, rows):\\n            if grid[row][col] == \"(\":\\n                opened[row][col].update(n + 1 for n in opened[row - 1][col])\\n            else:\\n                opened[row][col].update(n - 1 for n in opened[row - 1][col]\\n                                        if n > 0)\\n        for row in range(1, rows):\\n            for col in range(1, cols):\\n                opened[row - 1][col].update(opened[row][col - 1])\\n                if grid[row][col] == \"(\":\\n                    opened[row][col].update(n + 1 for n in\\n                                            opened[row - 1][col])\\n                else:\\n                    opened[row][col].update(n - 1 for n in\\n                                            opened[row - 1][col] if n > 0)\\n        return 0 in opened[rows - 1][cols - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024346,
                "title": "java-hashsets-clean-code",
                "content": "```java\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Set<Integer>[][] dp = new Set[m][n];\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                dp[i][j] = new HashSet<Integer>();\\n            }   \\n        }\\n        dp[0][0].add(grid[0][0] == \\'(\\' ? 1 : -1);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int inc = grid[i][j] == \\'(\\' ? 1 : -1;\\n                if (i-1 >= 0) addValue(dp[i-1][j], dp[i][j], inc);\\n                if (j-1 >= 0) addValue(dp[i][j-1], dp[i][j], inc);\\n            }\\n        }\\n        \\n        return dp[m-1][n-1].contains(0);\\n    }\\n    \\n    private void addValue(Set<Integer> src, Set<Integer> dst, int inc) {\\n        for(Integer value : src) {\\n            if (value.intValue() < 0) continue;\\n            int val = value.intValue() + inc;\\n            if (val >= 0) dst.add(val);\\n        } \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Set<Integer>[][] dp = new Set[m][n];\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                dp[i][j] = new HashSet<Integer>();\\n            }   \\n        }\\n        dp[0][0].add(grid[0][0] == \\'(\\' ? 1 : -1);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int inc = grid[i][j] == \\'(\\' ? 1 : -1;\\n                if (i-1 >= 0) addValue(dp[i-1][j], dp[i][j], inc);\\n                if (j-1 >= 0) addValue(dp[i][j-1], dp[i][j], inc);\\n            }\\n        }\\n        \\n        return dp[m-1][n-1].contains(0);\\n    }\\n    \\n    private void addValue(Set<Integer> src, Set<Integer> dst, int inc) {\\n        for(Integer value : src) {\\n            if (value.intValue() < 0) continue;\\n            int val = value.intValue() + inc;\\n            if (val >= 0) dst.add(val);\\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024304,
                "title": "rust-dfs-hashmap-o-rows-cols-rows-cols",
                "content": "Simplify \\n`*f.get(&(r, c, cnt)).unwrap_or(&false);`\\nto\\n`f[&(r, c, cnt)];`\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn has_valid_path(grid: Vec<Vec<char>>) -> bool {\\n        fn dfs(r: usize, c: usize, mut cnt: i32, grid: &Vec<Vec<char>>, f: &mut HashMap<(usize, usize, i32), bool>) -> bool {\\n            let rows = grid.len();\\n            let cols = grid[0].len();\\n            let mut ans = false;\\n            \\n            if r >= rows || c >= cols {\\n                f.insert((r,c,cnt), false);\\n                return false;\\n            }\\n            if grid[r][c] == \\'(\\' {\\n                cnt += 1;\\n            } else {\\n                cnt -= 1;\\n            }\\n            if cnt < 0 {\\n                f.insert((r,c,cnt), false);\\n                return false;\\n            }\\n            if r == rows - 1 && c == cols - 1 && cnt == 0 {\\n                f.insert((r,c,cnt), true);\\n                return true;\\n            }\\n            \\n            if f.contains_key(&(r, c, cnt)) {\\n                return f[&(r, c, cnt)];\\n            }\\n\\n            let ans = dfs(r+1, c, cnt, &grid, f) || dfs(r, c+1, cnt, &grid, f);\\n            f.insert((r,c,cnt), ans);\\n            ans\\n        }\\n        \\n        let mut f: HashMap<(usize, usize, i32), bool> = HashMap::new();\\n        \\n        let ans = dfs(0, 0, 0, &grid, &mut f);\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn has_valid_path(grid: Vec<Vec<char>>) -> bool {\\n        fn dfs(r: usize, c: usize, mut cnt: i32, grid: &Vec<Vec<char>>, f: &mut HashMap<(usize, usize, i32), bool>) -> bool {\\n            let rows = grid.len();\\n            let cols = grid[0].len();\\n            let mut ans = false;\\n            \\n            if r >= rows || c >= cols {\\n                f.insert((r,c,cnt), false);\\n                return false;\\n            }\\n            if grid[r][c] == \\'(\\' {\\n                cnt += 1;\\n            } else {\\n                cnt -= 1;\\n            }\\n            if cnt < 0 {\\n                f.insert((r,c,cnt), false);\\n                return false;\\n            }\\n            if r == rows - 1 && c == cols - 1 && cnt == 0 {\\n                f.insert((r,c,cnt), true);\\n                return true;\\n            }\\n            \\n            if f.contains_key(&(r, c, cnt)) {\\n                return f[&(r, c, cnt)];\\n            }\\n\\n            let ans = dfs(r+1, c, cnt, &grid, f) || dfs(r, c+1, cnt, &grid, f);\\n            f.insert((r,c,cnt), ans);\\n            ans\\n        }\\n        \\n        let mut f: HashMap<(usize, usize, i32), bool> = HashMap::new();\\n        \\n        let ans = dfs(0, 0, 0, &grid, &mut f);\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2023737,
                "title": "python-dp-memoization-simple-solution",
                "content": "```\\nclass Solution:\\n    def dp(self, grid, r, c, balance, lookup):\\n        if grid[r][c] == \\'(\\':\\n            balance += 1\\n        else:\\n            balance -= 1\\n        \\n        if r == len(grid)-1 and c == len(grid[0])-1:\\n            return balance == 0\\n        \\n        key = (r, c, balance)\\n        if key not in lookup:\\n            isValid = False\\n\\n            for dr, dc in [[r, c+1], [r+1, c]]:\\n                if dr < len(grid) and dc < len(grid[0]) and (balance > 0 or grid[dr][dc] == \\'(\\'):\\n                    if self.dp(grid, dr, dc, balance, lookup) or self.dp(grid, dr, dc, balance, lookup):\\n                        isValid = True\\n                        break\\n            lookup[key] = isValid\\n        return lookup[key]\\n    \\n    \\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\' or grid[-1][-1] == \\'(\\' or len(grid) == len(grid[0]) == 1:\\n            return False\\n        \\n        return self.dp(grid, 0, 0, 0, {})\\n        \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self, grid, r, c, balance, lookup):\\n        if grid[r][c] == \\'(\\':\\n            balance += 1\\n        else:\\n            balance -= 1\\n        \\n        if r == len(grid)-1 and c == len(grid[0])-1:\\n            return balance == 0\\n        \\n        key = (r, c, balance)\\n        if key not in lookup:\\n            isValid = False\\n\\n            for dr, dc in [[r, c+1], [r+1, c]]:\\n                if dr < len(grid) and dc < len(grid[0]) and (balance > 0 or grid[dr][dc] == \\'(\\'):\\n                    if self.dp(grid, dr, dc, balance, lookup) or self.dp(grid, dr, dc, balance, lookup):\\n                        isValid = True\\n                        break\\n            lookup[key] = isValid\\n        return lookup[key]\\n    \\n    \\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\' or grid[-1][-1] == \\'(\\' or len(grid) == len(grid[0]) == 1:\\n            return False\\n        \\n        return self.dp(grid, 0, 0, 0, {})\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023546,
                "title": "java-dfs-memo",
                "content": "```java\\nclass Solution {\\n    private int m;\\n    private int n;\\n    private char[][] grid;\\n    private Map<String, Boolean> memo;\\n\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        this.grid = grid;\\n        memo = new HashMap<>();\\n\\n        // basic case: the path should start with \\'(\\' and end with \\')\\'\\n        if (grid[0][0] != \\'(\\' || grid[m - 1][n - 1] != \\')\\') {\\n            return false;\\n        }\\n\\n        // basic case: the count of value in the path should be even.\\n        // so m+n should be odd\\n        if ((m + n) % 2 == 0) {\\n            return false;\\n        }\\n\\n        // dfs\\n        return traverse(0, 0, 0);\\n    }\\n\\n\\n    private boolean traverse(int i, int j, int count) {\\n        if (i >= m || j >= n) {\\n            return false;\\n        }\\n\\n        // calculate the number of \\'(\\'\\n        char c = grid[i][j];\\n        if (c == \\'(\\') {\\n            count++;\\n        } else {\\n            // when encounter with \\')\\', offset one \\'(\\'\\n            count--;\\n        }\\n\\n        // arrive the end position\\n        if (i == m - 1 && j == n - 1) {\\n            // perfect pair\\n            if (count == 0) {\\n                return true;\\n            }\\n        }\\n\\n        // if count < 0, the path will start with \\')\\', illegal.\\n        // if count > (m + n - 1) / 2, there would be no enough \\')\\' left to offset the \\'(\\'\\n        if (count < 0 || count > (m + n - 1) / 2) {\\n            return false;\\n        }\\n\\n        // check the memo\\n        String key = generateKey(i, j, count);\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n\\n        // traverse next position. right or down.\\n        boolean ans = traverse(i, j + 1, count) || traverse(i + 1, j, count);\\n        // add to memo\\n        memo.put(key, ans);\\n        return ans;\\n    }\\n\\n    /**\\n     * generate some kind of key. we use \\'-\\' to split elements here.\\n     *\\n     * @param i\\n     * @param j\\n     * @param currentCount\\n     * @return\\n     */\\n    private String generateKey(int i, int j, int currentCount) {\\n        return i + \"-\" + j + \"-\" + currentCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    private int m;\\n    private int n;\\n    private char[][] grid;\\n    private Map<String, Boolean> memo;\\n\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        this.grid = grid;\\n        memo = new HashMap<>();\\n\\n        // basic case: the path should start with \\'(\\' and end with \\')\\'\\n        if (grid[0][0] != \\'(\\' || grid[m - 1][n - 1] != \\')\\') {\\n            return false;\\n        }\\n\\n        // basic case: the count of value in the path should be even.\\n        // so m+n should be odd\\n        if ((m + n) % 2 == 0) {\\n            return false;\\n        }\\n\\n        // dfs\\n        return traverse(0, 0, 0);\\n    }\\n\\n\\n    private boolean traverse(int i, int j, int count) {\\n        if (i >= m || j >= n) {\\n            return false;\\n        }\\n\\n        // calculate the number of \\'(\\'\\n        char c = grid[i][j];\\n        if (c == \\'(\\') {\\n            count++;\\n        } else {\\n            // when encounter with \\')\\', offset one \\'(\\'\\n            count--;\\n        }\\n\\n        // arrive the end position\\n        if (i == m - 1 && j == n - 1) {\\n            // perfect pair\\n            if (count == 0) {\\n                return true;\\n            }\\n        }\\n\\n        // if count < 0, the path will start with \\')\\', illegal.\\n        // if count > (m + n - 1) / 2, there would be no enough \\')\\' left to offset the \\'(\\'\\n        if (count < 0 || count > (m + n - 1) / 2) {\\n            return false;\\n        }\\n\\n        // check the memo\\n        String key = generateKey(i, j, count);\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n\\n        // traverse next position. right or down.\\n        boolean ans = traverse(i, j + 1, count) || traverse(i + 1, j, count);\\n        // add to memo\\n        memo.put(key, ans);\\n        return ans;\\n    }\\n\\n    /**\\n     * generate some kind of key. we use \\'-\\' to split elements here.\\n     *\\n     * @param i\\n     * @param j\\n     * @param currentCount\\n     * @return\\n     */\\n    private String generateKey(int i, int j, int currentCount) {\\n        return i + \"-\" + j + \"-\" + currentCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023471,
                "title": "c-simple-recursive-solution-with-dp",
                "content": "class Solution {\\n    int m, n;\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<vector<int>>> dp(100, vector<vector<int>> (100, vector<int> (205, -1)));\\n        return helper(grid, 0, 0, 0, dp);\\n    }\\n    \\n    bool helper(vector<vector<char>> &grid, int i, int j, int a, vector<vector<vector<int>>> &dp)\\n    {\\n        if(i >= m || j >= n)\\n            return !a && (i == m - 1 || j == n - 1);\\n        \\n        if(grid[i][j] == \\'(\\')\\n            a++;\\n        else\\n            a--;\\n        \\n        if(a < 0)\\n            return false;\\n        \\n        if(dp[i][j][a] != -1)\\n            return dp[i][j][a];\\n        \\n        return dp[i][j][a] = helper(grid, i + 1, j, a, dp) || helper(grid, i, j + 1, a, dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    int m, n;\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<vector<int>>> dp(100, vector<vector<int>> (100, vector<int> (205, -1)));\\n        return helper(grid, 0, 0, 0, dp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2023371,
                "title": "python3-solution-with-explanation-from-bottom-right-to-top-left",
                "content": "```\\ndef hasValidPath(self, grid: List[List[str]]) -> bool:\\n        # in this function we check how many \"(\" are needed at location [i][j]\\n        # starting from grid[m-1][n-1], and move up and left\\n        # if grid[m-1][n-1]==\"(\", there is no way to form a valid parentheses string path\\n        # else, the \"(\" needed is 1. so we start with 1\\n        # if grid[i][j]==\")\", add 1 to the value\\n        # if grid[i][j]==\"(\", minus 1 to the value\\n        # only keep records of values greater or equal to 0\\n        m = len(grid)\\n        n = len(grid[0])\\n        # use a matrix brackets to keep records of how many \"(\" are needed at each location\\n        brackets = [[0]*n for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                brackets[i][j] = set()\\n            \\n        \\n        j = n-1\\n        i = m-1\\n        if grid[i][j]==\")\":\\n            # 1. initialize brackets[m-1][n-1]\\n            brackets[i][j].add(1)\\n            # 2. initialize the last column of values based on brackets[i+1][j]. note that we only need to keep values greater or equal to 0.\\n            i -= 1\\n            while i>=0:\\n                if grid[i][j]==\")\":\\n                    if len(brackets[i+1][j])>0:\\n                        brackets[i][j].add(list(brackets[i+1][j])[0] + 1)\\n                else:\\n                    if len(brackets[i+1][j])>0:\\n                        if list(brackets[i+1][j])[0] - 1>=0:\\n                            brackets[i][j].add(list(brackets[i+1][j])[0] - 1)\\n                i -= 1\\n            # 3. initialize the last row of values based on brackets[i][j+1]\\n            j = n-2\\n            i = m-1\\n            while j>=0:\\n                if grid[i][j]==\")\":\\n                    if len(brackets[i][j+1])>0:\\n                        brackets[i][j].add(list(brackets[i][j+1])[0] + 1)\\n                else:\\n                    if len(brackets[i][j+1])>0:\\n                        if list(brackets[i][j+1])[0] - 1>=0:\\n                            brackets[i][j].add(list(brackets[i][j+1])[0] - 1)\\n                j -= 1\\n            \\n            # 4. from brackets[m-2][n-2], for brackets[i][j]: obtain how many \"(\" are needed based on numbers from brackets[i][j+1] and brackets[i+1][j]\\n            i = m-2\\n            while i>=0:\\n                j = n-2\\n                while j>=0:\\n                    if grid[i][j]==\")\":\\n                        for x in brackets[i][j+1]|brackets[i+1][j]:\\n                            brackets[i][j].add(x + 1)\\n                        \\n                    else:\\n                        for x in brackets[i][j+1]|brackets[i+1][j]:\\n                            if x-1>=0:\\n                                brackets[i][j].add(x - 1)\\n                        \\n                    j -= 1\\n                i -= 1    \\n                \\n            # 5. if 0 is needed, then return True; otherwise, return False\\n            return (0 in brackets[0][0])\\n        else:\\n            # if the last element is \"(\", then there\\'s no way to form a valid parentheses string path\\n            return False\\n\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef hasValidPath(self, grid: List[List[str]]) -> bool:\\n        # in this function we check how many \"(\" are needed at location [i][j]\\n        # starting from grid[m-1][n-1], and move up and left\\n        # if grid[m-1][n-1]==\"(\", there is no way to form a valid parentheses string path\\n        # else, the \"(\" needed is 1. so we start with 1\\n        # if grid[i][j]==\")\", add 1 to the value\\n        # if grid[i][j]==\"(\", minus 1 to the value\\n        # only keep records of values greater or equal to 0\\n        m = len(grid)\\n        n = len(grid[0])\\n        # use a matrix brackets to keep records of how many \"(\" are needed at each location\\n        brackets = [[0]*n for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                brackets[i][j] = set()\\n            \\n        \\n        j = n-1\\n        i = m-1\\n        if grid[i][j]==\")\":\\n            # 1. initialize brackets[m-1][n-1]\\n            brackets[i][j].add(1)\\n            # 2. initialize the last column of values based on brackets[i+1][j]. note that we only need to keep values greater or equal to 0.\\n            i -= 1\\n            while i>=0:\\n                if grid[i][j]==\")\":\\n                    if len(brackets[i+1][j])>0:\\n                        brackets[i][j].add(list(brackets[i+1][j])[0] + 1)\\n                else:\\n                    if len(brackets[i+1][j])>0:\\n                        if list(brackets[i+1][j])[0] - 1>=0:\\n                            brackets[i][j].add(list(brackets[i+1][j])[0] - 1)\\n                i -= 1\\n            # 3. initialize the last row of values based on brackets[i][j+1]\\n            j = n-2\\n            i = m-1\\n            while j>=0:\\n                if grid[i][j]==\")\":\\n                    if len(brackets[i][j+1])>0:\\n                        brackets[i][j].add(list(brackets[i][j+1])[0] + 1)\\n                else:\\n                    if len(brackets[i][j+1])>0:\\n                        if list(brackets[i][j+1])[0] - 1>=0:\\n                            brackets[i][j].add(list(brackets[i][j+1])[0] - 1)\\n                j -= 1\\n            \\n            # 4. from brackets[m-2][n-2], for brackets[i][j]: obtain how many \"(\" are needed based on numbers from brackets[i][j+1] and brackets[i+1][j]\\n            i = m-2\\n            while i>=0:\\n                j = n-2\\n                while j>=0:\\n                    if grid[i][j]==\")\":\\n                        for x in brackets[i][j+1]|brackets[i+1][j]:\\n                            brackets[i][j].add(x + 1)\\n                        \\n                    else:\\n                        for x in brackets[i][j+1]|brackets[i+1][j]:\\n                            if x-1>=0:\\n                                brackets[i][j].add(x - 1)\\n                        \\n                    j -= 1\\n                i -= 1    \\n                \\n            # 5. if 0 is needed, then return True; otherwise, return False\\n            return (0 in brackets[0][0])\\n        else:\\n            # if the last element is \"(\", then there\\'s no way to form a valid parentheses string path\\n            return False\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2023210,
                "title": "3d-dp",
                "content": "int dp[105][105][105]; // dp[i][j][k]=> 0 or 1 accordingly if we are at i,j and have k opening bracket \\n    \\n    int sol(int x,int y,int ob,int cb,int &p,vector<vector<char>>& grid)\\n    {\\n        if(cb>ob || (ob>p || cb>p))\\n        {\\n            return 0;\\n        }\\n        \\n        if(x==grid.size()-1 && y==grid[0].size()-1)\\n        {\\n            if(ob==cb)\\n            {\\n                return 1;\\n            }\\n            \\n            return 0;\\n        }\\n        \\n        if(dp[x][y][ob]!=-1)\\n        {\\n            return dp[x][y][ob];\\n        }\\n        \\n        int ans=0;\\n        \\n        if(x+1<grid.size())\\n        {\\n            if(grid[x+1][y]==\\'(\\')\\n            ans=ans|sol(x+1,y,ob+1,cb,p,grid);\\n            else\\n            ans=ans|sol(x+1,y,ob,cb+1,p,grid);\\n        }\\n        \\n        if(y+1<grid[0].size())\\n        {\\n            if(grid[x][y+1]==\\'(\\')\\n            ans=ans|sol(x,y+1,ob+1,cb,p,grid);\\n            else\\n            ans=ans|sol(x,y+1,ob,cb+1,p,grid);\\n        }\\n        \\n        return dp[x][y][ob]=ans;\\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int n=grid.size(),m=grid[0].size();\\n        if((n+m-1)%2 || grid[0][0]==\\')\\' || grid[n-1][m-1]==\\'(\\')\\n        {\\n            return false;\\n        }\\n        \\n        int p=(n+m-1)/2; // this is the size of final valid string and it must have (n+m-1)/2 opening bracket and closing bracket and hence opening and closing bracket should not cross (n+m-1)/2.\\n\\n        return sol(0,0,1,0,p,grid);\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "int dp[105][105][105]; // dp[i][j][k]=> 0 or 1 accordingly if we are at i,j and have k opening bracket \\n    \\n    int sol(int x,int y,int ob,int cb,int &p,vector<vector<char>>& grid)\\n    {\\n        if(cb>ob || (ob>p || cb>p))\\n        {\\n            return 0;\\n        }\\n        \\n        if(x==grid.size()-1 && y==grid[0].size()-1)\\n        {\\n            if(ob==cb)\\n            {\\n                return 1;\\n            }\\n            \\n            return 0;\\n        }\\n        \\n        if(dp[x][y][ob]!=-1)\\n        {\\n            return dp[x][y][ob];\\n        }\\n        \\n        int ans=0;\\n        \\n        if(x+1<grid.size())\\n        {\\n            if(grid[x+1][y]==\\'(\\')\\n            ans=ans|sol(x+1,y,ob+1,cb,p,grid);\\n            else\\n            ans=ans|sol(x+1,y,ob,cb+1,p,grid);\\n        }\\n        \\n        if(y+1<grid[0].size())\\n        {\\n            if(grid[x][y+1]==\\'(\\')\\n            ans=ans|sol(x,y+1,ob+1,cb,p,grid);\\n            else\\n            ans=ans|sol(x,y+1,ob,cb+1,p,grid);\\n        }\\n        \\n        return dp[x][y][ob]=ans;\\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int n=grid.size(),m=grid[0].size();\\n        if((n+m-1)%2 || grid[0][0]==\\')\\' || grid[n-1][m-1]==\\'(\\')\\n        {\\n            return false;\\n        }\\n        \\n        int p=(n+m-1)/2; // this is the size of final valid string and it must have (n+m-1)/2 opening bracket and closing bracket and hence opening and closing bracket should not cross (n+m-1)/2.\\n\\n        return sol(0,0,1,0,p,grid);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2022904,
                "title": "python-dfs-memo-ignoring-bad-paths-with-counters",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        size = m+n-1\\n        if size % 2 == 1 or grid[0][0] == \\')\\' or grid[m-1][n-1] == \\'(\\':\\n            return False\\n        \\n        @cache\\n        def trav(r, c, cnt, step):\\n            if grid[r][c] == \\'(\\':\\n                newCnt = cnt+1\\n            else:\\n                newCnt = cnt-1\\n            \\n            if step == size:\\n                if newCnt == 0:\\n                    return True\\n                return False\\n        \\n            diffs = [(0,1), (1,0)]\\n            for dr, dc in diffs:\\n                newR, newC = r+dr, c+dc\\n                \\n                if newR < m and newC < n:\\n                    if newCnt > 0:\\n                        if trav(newR, newC, newCnt, step+1):\\n                            return True\\n                    elif grid[newR][newC] == \\'(\\':\\n                        if trav(newR, newC, newCnt, step+1):\\n                            return True\\n                        \\n            return False\\n                    \\n        return trav(0, 0, 0, 1)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        size = m+n-1\\n        if size % 2 == 1 or grid[0][0] == \\')\\' or grid[m-1][n-1] == \\'(\\':\\n            return False\\n        \\n        @cache\\n        def trav(r, c, cnt, step):\\n            if grid[r][c] == \\'(\\':\\n                newCnt = cnt+1\\n            else:\\n                newCnt = cnt-1\\n            \\n            if step == size:\\n                if newCnt == 0:\\n                    return True\\n                return False\\n        \\n            diffs = [(0,1), (1,0)]\\n            for dr, dc in diffs:\\n                newR, newC = r+dr, c+dc\\n                \\n                if newR < m and newC < n:\\n                    if newCnt > 0:\\n                        if trav(newR, newC, newCnt, step+1):\\n                            return True\\n                    elif grid[newR][newC] == \\'(\\':\\n                        if trav(newR, newC, newCnt, step+1):\\n                            return True\\n                        \\n            return False\\n                    \\n        return trav(0, 0, 0, 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022500,
                "title": "java-bottom-up-dp-using-hashset",
                "content": "**Intuition**\\nFor any given cell (x,y), it is possible to have a valid string starting from (0,0) only if number of open brackets upto (x,y) are 0. A path is invalid if number of \\')\\' exceeds number of \\'(\\'. \\n\\n**Approach**\\nFor each cell (i,j) of dp array, maintain a hashset and store the number of open brackets, updating the values in the hashset from dp[i-1][j] and dp[i][j-1].\\nif current character is \\'(\\', then increment the values from hashsets of dp[i-1][j] and dp[i][j-1].\\nif current character is \\')\\', thendecrement the values from hashsets of dp[i-1][j] and dp[i][j-1], ignoring negative values.\\nTrue is returned only if hashset of last cell has 0.\\n**Code**\\n```\\nclass Solution {\\n    class hs{\\n        HashSet<Integer> s;\\n        public hs(){\\n            s = new HashSet<>();\\n        }\\n       \\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        hs[][] dp = new hs[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j] = new hs();\\n            }\\n        }\\n        dp[0][0].s.add(1);\\n        for(int i=1;i<m;i++){\\n            int k = (grid[0][i]==\\'(\\'?1:-1);\\n            for(int x: dp[0][i-1].s){\\n                if(x+k<0){\\n                    continue;\\n                }\\n                dp[0][i].s.add(x+k);\\n                \\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            int k = (grid[i][0]==\\'(\\'?1:-1);\\n               \\n            for(int x: dp[i-1][0].s){\\n                if(x+k<0){\\n                    continue;\\n                }\\n                dp[i][0].s.add(x+k);\\n                \\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n               int k = (grid[i][j]==\\'(\\'?1:-1);\\n                for(int x: dp[i-1][j].s){\\n                    if(x+k<0){\\n                        continue;\\n                    }\\n                    dp[i][j].s.add(x+k);\\n                }\\n                for(int x: dp[i][j-1].s){\\n                    if(x+k<0){\\n                        continue;\\n                    }\\n                    dp[i][j].s.add(x+k);\\n                    }\\n                \\n            }\\n        }\\n        \\n        \\n        return dp[n-1][m-1].s.contains(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    class hs{\\n        HashSet<Integer> s;\\n        public hs(){\\n            s = new HashSet<>();\\n        }\\n       \\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        hs[][] dp = new hs[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j] = new hs();\\n            }\\n        }\\n        dp[0][0].s.add(1);\\n        for(int i=1;i<m;i++){\\n            int k = (grid[0][i]==\\'(\\'?1:-1);\\n            for(int x: dp[0][i-1].s){\\n                if(x+k<0){\\n                    continue;\\n                }\\n                dp[0][i].s.add(x+k);\\n                \\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            int k = (grid[i][0]==\\'(\\'?1:-1);\\n               \\n            for(int x: dp[i-1][0].s){\\n                if(x+k<0){\\n                    continue;\\n                }\\n                dp[i][0].s.add(x+k);\\n                \\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n               int k = (grid[i][j]==\\'(\\'?1:-1);\\n                for(int x: dp[i-1][j].s){\\n                    if(x+k<0){\\n                        continue;\\n                    }\\n                    dp[i][j].s.add(x+k);\\n                }\\n                for(int x: dp[i][j-1].s){\\n                    if(x+k<0){\\n                        continue;\\n                    }\\n                    dp[i][j].s.add(x+k);\\n                    }\\n                \\n            }\\n        }\\n        \\n        \\n        return dp[n-1][m-1].s.contains(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022400,
                "title": "getting-tle-don-t-know-why",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101][202];\\n    int m, n;\\n    bool rec(int i , int j, int cnt, vector<vector<char>>& grid)\\n    {\\n        if(i >= m || j >= n || cnt < 0)return 0;\\n        if(i == m-1 && j == n-1){\\n            if(grid[i][j] == \\'(\\')cnt++;\\n            else cnt--;\\n            return cnt == 0;\\n        }\\n        if(dp[i][j][cnt]!=-1)return dp[i][j][cnt];\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\')cnt++;\\n        else cnt--;\\n        ans = rec(i+1, j, cnt, grid) || rec(i,j+1, cnt, grid);\\n        if(cnt < 0)return false;\\n        return dp[i][j][cnt] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0,0,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101][202];\\n    int m, n;\\n    bool rec(int i , int j, int cnt, vector<vector<char>>& grid)\\n    {\\n        if(i >= m || j >= n || cnt < 0)return 0;\\n        if(i == m-1 && j == n-1){\\n            if(grid[i][j] == \\'(\\')cnt++;\\n            else cnt--;\\n            return cnt == 0;\\n        }\\n        if(dp[i][j][cnt]!=-1)return dp[i][j][cnt];\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\')cnt++;\\n        else cnt--;\\n        ans = rec(i+1, j, cnt, grid) || rec(i,j+1, cnt, grid);\\n        if(cnt < 0)return false;\\n        return dp[i][j][cnt] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0,0,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021904,
                "title": "python-easy-to-read-and-understand",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def check(i, j, x, memo=set()):\\n            if i >= n or j >= m:\\n                return False\\n            \\n\\t\\t\\t# x is the parenthesis score till now; add by 1 if the cell is ( else subtract by 1\\n            x += 1 if grid[i][j] == \\'(\\' else -1\\n            \\n\\t\\t\\t# If the score is negative then the sequence is already invalid\\n\\t\\t\\t# or if the score is greater than half of the path length then the sequence is invalid\\n\\t\\t\\t# or if it is already visited then return False\\n            if x < 0 or x > (m+n)//2 or (i,j,x) in memo:\\n                return False\\n            \\n            memo.add((i,j,x))\\n            \\n\\t\\t\\t\\n\\t\\t\\t# if it\\'s the last cell and score is 0 then it is a valid sequence\\n            if i == n-1 and j == m-1 and x == 0:\\n                return True\\n            \\n            return check(i+1, j, x, memo) or check(i, j+1, x, memo)\\n    \\n        n, m = len(grid), len(grid[0])\\n\\t\\t\\n\\t\\t# if the path length is odd: return False\\n\\t\\t# if the first cell is ): return False\\n\\t\\t# if the last cell is (: return False\\n        if (n+m-1)%2 or grid[0][0] == \\')\\' or grid[-1][-1] == \\'(\\':\\n            return False\\n        \\n        return check(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def check(i, j, x, memo=set()):\\n            if i >= n or j >= m:\\n                return False\\n            \\n\\t\\t\\t# x is the parenthesis score till now; add by 1 if the cell is ( else subtract by 1\\n            x += 1 if grid[i][j] == \\'(\\' else -1\\n            \\n\\t\\t\\t# If the score is negative then the sequence is already invalid\\n\\t\\t\\t# or if the score is greater than half of the path length then the sequence is invalid\\n\\t\\t\\t# or if it is already visited then return False\\n            if x < 0 or x > (m+n)//2 or (i,j,x) in memo:\\n                return False\\n            \\n            memo.add((i,j,x))\\n            \\n\\t\\t\\t\\n\\t\\t\\t# if it\\'s the last cell and score is 0 then it is a valid sequence\\n            if i == n-1 and j == m-1 and x == 0:\\n                return True\\n            \\n            return check(i+1, j, x, memo) or check(i, j+1, x, memo)\\n    \\n        n, m = len(grid), len(grid[0])\\n\\t\\t\\n\\t\\t# if the path length is odd: return False\\n\\t\\t# if the first cell is ): return False\\n\\t\\t# if the last cell is (: return False\\n        if (n+m-1)%2 or grid[0][0] == \\')\\' or grid[-1][-1] == \\'(\\':\\n            return False\\n        \\n        return check(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021889,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        n=len(grid)-1\\n        m=len(grid[0])-1\\n        @cache\\n        def dp(i,j,o):\\n            if i==n and j==m:return o==0\\n            ni=i+1\\n            if ni<=n:\\n                if grid[ni][j]==\"(\":\\n                    if dp(ni,j,o+1):return True\\n                elif (o-1)>=0:\\n                    if dp(ni,j,o-1):return True\\n            nj=j+1\\n            if nj<=m:\\n                if grid[i][nj]==\"(\":\\n                    if dp(i,nj,o+1):return True\\n                elif (o-1)>=0:\\n                    if dp(i,nj,o-1):return True\\n            return False\\n        if grid[0][0]!=\"(\":return False\\n        return dp(0,0,1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        n=len(grid)-1\\n        m=len(grid[0])-1\\n        @cache\\n        def dp(i,j,o):\\n            if i==n and j==m:return o==0\\n            ni=i+1\\n            if ni<=n:\\n                if grid[ni][j]==\"(\":\\n                    if dp(ni,j,o+1):return True\\n                elif (o-1)>=0:\\n                    if dp(ni,j,o-1):return True\\n            nj=j+1\\n            if nj<=m:\\n                if grid[i][nj]==\"(\":\\n                    if dp(i,nj,o+1):return True\\n                elif (o-1)>=0:\\n                    if dp(i,nj,o-1):return True\\n            return False\\n        if grid[0][0]!=\"(\":return False\\n        return dp(0,0,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021334,
                "title": "dfs-dp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint dp[101][101][1001],m,n;\\n\\n\\t\\tint path(vector<vector<char>>&grid, int i, int j,int total){\\n\\t\\t\\tif(i==n or j==m) return 0;\\n\\t\\t\\tgrid[i][j]==\\')\\'?total--:total++;\\n\\t\\t\\tif(total<0) return 0;\\n\\t\\t\\tif(i == n-1 and j == m-1) return total==0;\\n\\t\\t\\tif(dp[i][j][total]!=-1) return dp[i][j][total];\\n\\t\\t\\treturn dp[i][j][total] = path(grid,i+1,j,total) or path(grid,i,j+1,total);\\n\\t\\t}\\n\\n\\t\\tbool hasValidPath(vector<vector<char>>& grid) {\\n\\t\\t\\t memset(dp,-1,sizeof dp);\\n\\t\\t\\t n = grid.size();\\n\\t\\t\\t m = grid[0].size();\\n\\t\\t\\t if(grid[0][0]==\\')\\') return false;\\n\\t\\t\\t return path(grid,0,0,0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint dp[101][101][1001],m,n;\\n\\n\\t\\tint path(vector<vector<char>>&grid, int i, int j,int total){\\n\\t\\t\\tif(i==n or j==m) return 0;\\n\\t\\t\\tgrid[i][j]==\\')\\'?total--:total++;\\n\\t\\t\\tif(total<0) return 0;\\n\\t\\t\\tif(i == n-1 and j == m-1) return total==0;\\n\\t\\t\\tif(dp[i][j][total]!=-1) return dp[i][j][total];\\n\\t\\t\\treturn dp[i][j][total] = path(grid,i+1,j,total) or path(grid,i,j+1,total);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2021274,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    public boolean valid(int r,  int c , int balance , char[][] grid){\\n        if(balance < 0) return false; // if closing brackets exceeds open then it can never be a valid path\\n        if(r == grid.length - 1 && c == grid[0].length - 1) return balance == 0; \\n        if(dp[r][c][balance] != null) return dp[r][c][balance];\\n        boolean res = false;\\n        if(r + 1 < grid.length){\\n            res |= valid(r + 1 , c , balance + (grid[r+1][c] == \\'(\\' ? 1 : -1) , grid);\\n        }\\n        if(c + 1 < grid[0].length){\\n            res |= valid(r, c + 1 , balance + (grid[r][c+1] == \\'(\\' ? 1 : -1) , grid);\\n        }\\n        dp[r][c][balance] = res;\\n        return res;\\n    }\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\') return false; // if first character in path is ) then its not a valid path\\n        dp = new Boolean[101][101][202];\\n        return valid(0,0,1,grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    public boolean valid(int r,  int c , int balance , char[][] grid){\\n        if(balance < 0) return false; // if closing brackets exceeds open then it can never be a valid path\\n        if(r == grid.length - 1 && c == grid[0].length - 1) return balance == 0; \\n        if(dp[r][c][balance] != null) return dp[r][c][balance];\\n        boolean res = false;\\n        if(r + 1 < grid.length){\\n            res |= valid(r + 1 , c , balance + (grid[r+1][c] == \\'(\\' ? 1 : -1) , grid);\\n        }\\n        if(c + 1 < grid[0].length){\\n            res |= valid(r, c + 1 , balance + (grid[r][c+1] == \\'(\\' ? 1 : -1) , grid);\\n        }\\n        dp[r][c][balance] = res;\\n        return res;\\n    }\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\') return false; // if first character in path is ) then its not a valid path\\n        dp = new Boolean[101][101][202];\\n        return valid(0,0,1,grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020914,
                "title": "c-17-fast-and-easy-to-understand-bottom-up-dp-using-bitset-and-bit-shifts-in-60ms",
                "content": "### [C++17] fast and easy-to-understand Bottom-Up DP using bitset and bit-shifts, in ~60ms\\n\\n#### Approach and Ideas:\\n##### helper ideas:\\n* parenthesis-path-sum:\\n  Let `(` be +1, and `)` be `-1`, then the parenthesis path sum is a simple sum of these `+1`s\\n  and `-1`s.\\n* classification of paths wrt the parenthesis-path-sum:\\n  A path is invalid if its path-sum becomes negative.\\n  A path is perfect if its path-sum is 0.\\n  A path is quasi-valid if its path-sum is positive.\\n#### Core Ideas:\\n1. DP:\\nLet f[r][c] be the set of integers where each integer representing the parenthesis-path-sum of\\nsome path(s) from [0][0] to [r][c]. In other words, f maps [r][c] to bitset<N>.\\nIn the general case, we have:\\n f[r][c] =\\n     a) add one element-wise, to (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\'(\\';\\n     b) subtract one element-wise, from (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\')\\'; Note that\\n     here we\\'ll remove all negative parenthesis-path-sums because they are invalid paths.\\nThe original problem becomes checking whether 0 is in the set at f[m-1][n-1].\\n\\n2. Accelerating the computation by ~25X, using bitset<N>:\\n* Using bitset<N> instead of unordered_set<int> to represent the set of valid\\nparenthesis-path-sums.\\n* Using bitset\\'s left-shifts `<<` for the element-wise `+1` operation, and using right-shifts\\n`>>` for the element-wise `-1` operation, and using the xor `^` operation to clear the bits.\\n\\n3. There are several cases where we can return early. Please see the code for details.\\n\\n##### Running time:\\n* Using bitset<100>:        59ms ~ 63ms\\n* using unordered_set<int>: ~1500ms\\n\\n\\n```\\n// 2267. Check if There Is a Valid Parentheses String Path\\n// Approach and Ideas:\\n// helper ideas:\\n// * parenthesis-path-sum:\\n//   Let `(` be +1, and `)` be `-1`, then the parenthesis path sum is a simple sum of these `+1`s\\n//   and `-1`s.\\n// * classification of paths wrt the parenthesis-path-sum:\\n//   A path is invalid if its path-sum becomes negative.\\n//   A path is perfect if its path-sum is 0.\\n//   A path is quasi-valid if its path-sum is positive.\\n//\\n// Core Ideas:\\n// 1. DP:\\n// Let f[r][c] be the set of integers where each integer representing the parenthesis-path-sum of\\n// some path(s) from [0][0] to [r][c]. In other words, f maps [r][c] to bitset<N>.\\n// In the general case, we have:\\n//  f[r][c] =\\n//      a) add one element-wise, to (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\'(\\';\\n//      b) subtract one element-wise, from (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\')\\'; Note that\\n//      here we\\'ll remove all negative parenthesis-path-sums because they are invalid paths.\\n// The original problem becomes checking whether 0 is in the set at f[m-1][n-1].\\n//\\n// 2. Accelerating the computation by ~25X, using bitset<N>:\\n// * Using bitset<N> instead of unordered_set<int> to represent the set of valid\\n// parenthesis-path-sums.\\n// * Using bitset\\'s left-shifts `<<` for the element-wise `+1` operation, and using right-shifts\\n// `>>` for the element-wise `-1` operation, and using the xor `^` operation to clear the bits.\\n//\\n// Running times:\\n// * Using bitset<100>:        59ms ~ 63ms\\n// * using unordered_set<int>: ~1500ms\\nclass Solution { // DP with BitSets and Shifts ops\\n    // the problem constraint says that: 1 <= m, n <= 100.\\n    // so there are at most 100 left-parentheses in a valid path.\\n    // We can adjust this constant if the problem-size goes up.\\n    constexpr static int ProblemSize = 100;\\n    using BitSet = bitset<ProblemSize>;\\n\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        const int maxPathLen = m + n - 1;\\n        if (maxPathLen & 1) { // if this is odd, it\\'s impossible to have valid parenthesis-path\\n            return false;\\n        }\\n\\n        // DP tables:\\n        // f is the `previous` row, g is the `current` row\\n        vector<BitSet> f(n), g(n);\\n        // initialize\\n        {\\n            if (ToNumeric(grid[0][0]) < 0) {\\n                return false; // if the starting point is invalid, all paths are invalid.\\n            }\\n            f[0][1] = true;\\n            for (int c = 1; c < n; ++c) {\\n                AddToEachElementAndRemoveInvalidElement(f[c - 1], ToNumeric(grid[0][c]), f[c]);\\n            }\\n        }\\n        // general cases for each row\\n        for (int r = 1; r < m; ++r) {\\n            // first element of the row\\n            AddToEachElementAndRemoveInvalidElement(f[0], ToNumeric(grid[r][0]), g[0]);\\n            bool allEmpty = (g[0].count() == 0);\\n            for (int c = 1; c < n; ++c) {\\n                int parenNumeric = ToNumeric(grid[r][c]);\\n                // paths from grid[r-1][c]\\n                AddToEachElementAndRemoveInvalidElement(f[c], parenNumeric, g[c]);\\n                // paths from grid[r][c-1]\\n                AddToEachElementAndRemoveInvalidElement(g[c - 1], parenNumeric, g[c]);\\n                allEmpty &= (g[c].count() == 0);\\n            }\\n            if (allEmpty) { // since this row is all empty, there won\\'t be valid path.\\n                return false; // so, return earlier.\\n            }\\n            g.swap(f);\\n            ClearEachSet(g);\\n        }\\n        // the set of the parenthesis-path-sums for the destination cell contains 0,\\n        // it means there is a valid parenthesis path.\\n        return f[n - 1][0];\\n    }\\n\\nprivate:\\n    static void ClearEachSet(vector<BitSet>& dpRow) {\\n        for (auto& theSet : dpRow) {\\n            theSet ^= theSet;\\n        }\\n    }\\n    static void AddToEachElementAndRemoveInvalidElement(\\n            const BitSet& originalSet,\\n            const int parenNumeric,\\n            BitSet& resultingSet) {\\n        if (parenNumeric == 1) { // +1: left-shift\\n            resultingSet |= (originalSet << 1);\\n        } else { // -1: right-shift\\n            resultingSet |= (originalSet >> 1);\\n        }\\n    }\\n\\n    static inline int ToNumeric(char parenthesis) {\\n        if (parenthesis == \\'(\\') {\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// 2267. Check if There Is a Valid Parentheses String Path\\n// Approach and Ideas:\\n// helper ideas:\\n// * parenthesis-path-sum:\\n//   Let `(` be +1, and `)` be `-1`, then the parenthesis path sum is a simple sum of these `+1`s\\n//   and `-1`s.\\n// * classification of paths wrt the parenthesis-path-sum:\\n//   A path is invalid if its path-sum becomes negative.\\n//   A path is perfect if its path-sum is 0.\\n//   A path is quasi-valid if its path-sum is positive.\\n//\\n// Core Ideas:\\n// 1. DP:\\n// Let f[r][c] be the set of integers where each integer representing the parenthesis-path-sum of\\n// some path(s) from [0][0] to [r][c]. In other words, f maps [r][c] to bitset<N>.\\n// In the general case, we have:\\n//  f[r][c] =\\n//      a) add one element-wise, to (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\'(\\';\\n//      b) subtract one element-wise, from (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\')\\'; Note that\\n//      here we\\'ll remove all negative parenthesis-path-sums because they are invalid paths.\\n// The original problem becomes checking whether 0 is in the set at f[m-1][n-1].\\n//\\n// 2. Accelerating the computation by ~25X, using bitset<N>:\\n// * Using bitset<N> instead of unordered_set<int> to represent the set of valid\\n// parenthesis-path-sums.\\n// * Using bitset\\'s left-shifts `<<` for the element-wise `+1` operation, and using right-shifts\\n// `>>` for the element-wise `-1` operation, and using the xor `^` operation to clear the bits.\\n//\\n// Running times:\\n// * Using bitset<100>:        59ms ~ 63ms\\n// * using unordered_set<int>: ~1500ms\\nclass Solution { // DP with BitSets and Shifts ops\\n    // the problem constraint says that: 1 <= m, n <= 100.\\n    // so there are at most 100 left-parentheses in a valid path.\\n    // We can adjust this constant if the problem-size goes up.\\n    constexpr static int ProblemSize = 100;\\n    using BitSet = bitset<ProblemSize>;\\n\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        const int maxPathLen = m + n - 1;\\n        if (maxPathLen & 1) { // if this is odd, it\\'s impossible to have valid parenthesis-path\\n            return false;\\n        }\\n\\n        // DP tables:\\n        // f is the `previous` row, g is the `current` row\\n        vector<BitSet> f(n), g(n);\\n        // initialize\\n        {\\n            if (ToNumeric(grid[0][0]) < 0) {\\n                return false; // if the starting point is invalid, all paths are invalid.\\n            }\\n            f[0][1] = true;\\n            for (int c = 1; c < n; ++c) {\\n                AddToEachElementAndRemoveInvalidElement(f[c - 1], ToNumeric(grid[0][c]), f[c]);\\n            }\\n        }\\n        // general cases for each row\\n        for (int r = 1; r < m; ++r) {\\n            // first element of the row\\n            AddToEachElementAndRemoveInvalidElement(f[0], ToNumeric(grid[r][0]), g[0]);\\n            bool allEmpty = (g[0].count() == 0);\\n            for (int c = 1; c < n; ++c) {\\n                int parenNumeric = ToNumeric(grid[r][c]);\\n                // paths from grid[r-1][c]\\n                AddToEachElementAndRemoveInvalidElement(f[c], parenNumeric, g[c]);\\n                // paths from grid[r][c-1]\\n                AddToEachElementAndRemoveInvalidElement(g[c - 1], parenNumeric, g[c]);\\n                allEmpty &= (g[c].count() == 0);\\n            }\\n            if (allEmpty) { // since this row is all empty, there won\\'t be valid path.\\n                return false; // so, return earlier.\\n            }\\n            g.swap(f);\\n            ClearEachSet(g);\\n        }\\n        // the set of the parenthesis-path-sums for the destination cell contains 0,\\n        // it means there is a valid parenthesis path.\\n        return f[n - 1][0];\\n    }\\n\\nprivate:\\n    static void ClearEachSet(vector<BitSet>& dpRow) {\\n        for (auto& theSet : dpRow) {\\n            theSet ^= theSet;\\n        }\\n    }\\n    static void AddToEachElementAndRemoveInvalidElement(\\n            const BitSet& originalSet,\\n            const int parenNumeric,\\n            BitSet& resultingSet) {\\n        if (parenNumeric == 1) { // +1: left-shift\\n            resultingSet |= (originalSet << 1);\\n        } else { // -1: right-shift\\n            resultingSet |= (originalSet >> 1);\\n        }\\n    }\\n\\n    static inline int ToNumeric(char parenthesis) {\\n        if (parenthesis == \\'(\\') {\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020643,
                "title": "python-3-dp-with-pruning",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == \\')\\' or (m + n - 1) % 2: return False\\n        \\n        @lru_cache(None)\\n        def dp(x, y, ops):\\n\\t\\t\\t# if unpaired close bracket or remaining cannot match open brackets\\n            if ops < 0 or ops > (m + n - 1) // 2: return False\\n            if x == m - 1 and y == n - 1:\\n                return not ops\\n            \\n            for dx, dy in [(0, 1), (1, 0)]:\\n                nx, ny = x + dx, y + dy\\n                if not(0 <= nx < m and 0 <= ny < n): continue\\n                tmp = 1 if grid[nx][ny] == \\'(\\' else -1\\n                if dp(nx, ny, ops + tmp):\\n                    return True\\n            return False\\n        \\n        \\n        return dp(0, 0, 1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == \\')\\' or (m + n - 1) % 2: return False\\n        \\n        @lru_cache(None)\\n        def dp(x, y, ops):\\n\\t\\t\\t# if unpaired close bracket or remaining cannot match open brackets\\n            if ops < 0 or ops > (m + n - 1) // 2: return False\\n            if x == m - 1 and y == n - 1:\\n                return not ops\\n            \\n            for dx, dy in [(0, 1), (1, 0)]:\\n                nx, ny = x + dx, y + dy\\n                if not(0 <= nx < m and 0 <= ny < n): continue\\n                tmp = 1 if grid[nx][ny] == \\'(\\' else -1\\n                if dp(nx, ny, ops + tmp):\\n                    return True\\n            return False\\n        \\n        \\n        return dp(0, 0, 1)",
                "codeTag": "Java"
            },
            {
                "id": 2020499,
                "title": "java-dp-o-mn-m-n-2",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int MID = (row + col + 1) / 2;\\n        if(grid[0][0] != \\'(\\' || grid[row - 1][col - 1] != \\')\\') return false;\\n        boolean[][][] dp = new boolean[row][col][MID + 1];\\n        dp[0][0][1] = true;\\n        for(int i = 1; i < row; i++) {\\n            for(int j = 0; j <= MID; j++) {\\n                if(grid[i][0] == \\'(\\' && j - 1 >= 0) {\\n                    dp[i][0][j] = dp[i - 1][0][j - 1];\\n                }\\n                else if(grid[i][0] == \\')\\' && j + 1 <= MID) {\\n                    dp[i][0][j] = dp[i - 1][0][j + 1];\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < col; i++) {\\n            for(int j = 0; j <= MID; j++) {\\n                if(grid[0][i] == \\'(\\' && j - 1 >= 0) {\\n                    dp[0][i][j] = dp[0][i - 1][j - 1];\\n                }\\n                else if(grid[0][i] == \\')\\' && j + 1 <= MID) {\\n                    dp[0][i][j] = dp[0][i - 1][j + 1];\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++) {\\n            for(int j = 1; j < col; j++) {\\n                for(int k = 0; k <= MID; k++) {\\n                    if(grid[i][j] == \\'(\\' && k - 1 >= 0) {\\n                        dp[i][j][k] = dp[i - 1][j][k - 1] || dp[i][j - 1][k - 1];\\n                    }\\n                    else if(grid[i][j] == \\')\\' && k + 1 <= MID) {\\n                        dp[i][j][k] = dp[i - 1][j][k + 1] || dp[i][j - 1][k + 1];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[row - 1][col - 1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int MID = (row + col + 1) / 2;\\n        if(grid[0][0] != \\'(\\' || grid[row - 1][col - 1] != \\')\\') return false;\\n        boolean[][][] dp = new boolean[row][col][MID + 1];\\n        dp[0][0][1] = true;\\n        for(int i = 1; i < row; i++) {\\n            for(int j = 0; j <= MID; j++) {\\n                if(grid[i][0] == \\'(\\' && j - 1 >= 0) {\\n                    dp[i][0][j] = dp[i - 1][0][j - 1];\\n                }\\n                else if(grid[i][0] == \\')\\' && j + 1 <= MID) {\\n                    dp[i][0][j] = dp[i - 1][0][j + 1];\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < col; i++) {\\n            for(int j = 0; j <= MID; j++) {\\n                if(grid[0][i] == \\'(\\' && j - 1 >= 0) {\\n                    dp[0][i][j] = dp[0][i - 1][j - 1];\\n                }\\n                else if(grid[0][i] == \\')\\' && j + 1 <= MID) {\\n                    dp[0][i][j] = dp[0][i - 1][j + 1];\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++) {\\n            for(int j = 1; j < col; j++) {\\n                for(int k = 0; k <= MID; k++) {\\n                    if(grid[i][j] == \\'(\\' && k - 1 >= 0) {\\n                        dp[i][j][k] = dp[i - 1][j][k - 1] || dp[i][j - 1][k - 1];\\n                    }\\n                    else if(grid[i][j] == \\')\\' && k + 1 <= MID) {\\n                        dp[i][j][k] = dp[i - 1][j][k + 1] || dp[i][j - 1][k + 1];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[row - 1][col - 1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020475,
                "title": "my-c-solution-time-space-beat-100",
                "content": "A \\'(\\' will add the count by 1, and a \\')\\' will decrease the count by 1.\\nTrack whether a certain position in the matrix with a certain count has been visited or not to prune the dfs.\\n\\n```\\nclass Solution {\\nprivate:\\n    bool v[100][100][100];\\n    \\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        return dfs(grid, 0, 0, 0);\\n    }\\n    \\n    bool dfs(vector<vector<char>>& grid, int i, int j, int cnt) {\\n        if (i >= grid.size() || j >= grid[0].size()) {\\n            return false;\\n        }\\n        \\n        cnt += (grid[i][j] == \\'(\\' ? 1 : -1);\\n        \\n        if (cnt < 0 || cnt >= 100 || v[i][j][cnt]) {\\n            return false;\\n        }\\n                \\n        if (i == grid.size()-1 && j == grid[0].size()-1 && cnt == 0) {\\n            return true;\\n        }\\n        \\n        if (dfs(grid, i, j+1, cnt) || dfs(grid, i+1, j, cnt)) {\\n            return true;\\n        }\\n        else {\\n            v[i][j][cnt] = true;\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool v[100][100][100];\\n    \\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        return dfs(grid, 0, 0, 0);\\n    }\\n    \\n    bool dfs(vector<vector<char>>& grid, int i, int j, int cnt) {\\n        if (i >= grid.size() || j >= grid[0].size()) {\\n            return false;\\n        }\\n        \\n        cnt += (grid[i][j] == \\'(\\' ? 1 : -1);\\n        \\n        if (cnt < 0 || cnt >= 100 || v[i][j][cnt]) {\\n            return false;\\n        }\\n                \\n        if (i == grid.size()-1 && j == grid[0].size()-1 && cnt == 0) {\\n            return true;\\n        }\\n        \\n        if (dfs(grid, i, j+1, cnt) || dfs(grid, i+1, j, cnt)) {\\n            return true;\\n        }\\n        else {\\n            v[i][j][cnt] = true;\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020462,
                "title": "java-from-recursion-memoization-easy",
                "content": "Recursion-->>\\n\\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\' || grid[grid.length-1][grid[0].length-1]==\\'(\\')return false;\\n        return solve(0,0,grid,0);\\n    }\\n    public boolean solve(int i, int j ,char[][] grid,int open){\\n        if(i>=grid.length || j>=grid[0].length)return false;\\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if(open<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1){\\n            if(open==0)\\n            return true;\\n        }\\n        \\n        \\n        \\n        if( solve(i+1,j,grid,open))\\n            return true;\\n        if( solve(i,j+1,grid,open))\\n            return true;\\n            \\n        return false;\\n        }\\n}\\n```\\n\\nMemoization -->>\\n\\n```\\nclass Solution {\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        if (grid[0][0] == \\')\\' || grid[grid.length - 1][grid[0].length - 1] == \\'(\\') return false;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Boolean[][][] dp = new Boolean[n][m][n + m];\\n        return solve(0, 0, grid, 0, dp);\\n    }\\n\\n    public boolean solve(int i, int j, char[][] grid, int open, Boolean[][][] dp) {\\n        if (i >= grid.length || j >= grid[0].length) return false;\\n\\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if (open < 0) return false;\\n\\n        if (i == grid.length - 1 && j == grid[0].length - 1) {\\n            if (open == 0) return true;\\n        }\\n        if (dp[i][j][open] != null) return dp[i][j][open];\\n\\n        if (solve(i + 1, j, grid, open, dp)) {\\n            return dp[i][j][open] = true;\\n        }\\n        if (solve(i, j + 1, grid, open, dp)) {\\n            return dp[i][j][open] = true;\\n        }\\n\\n        return dp[i][j][open] = false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\' || grid[grid.length-1][grid[0].length-1]==\\'(\\')return false;\\n        return solve(0,0,grid,0);\\n    }\\n    public boolean solve(int i, int j ,char[][] grid,int open){\\n        if(i>=grid.length || j>=grid[0].length)return false;\\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if(open<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1){\\n            if(open==0)\\n            return true;\\n        }\\n        \\n        \\n        \\n        if( solve(i+1,j,grid,open))\\n            return true;\\n        if( solve(i,j+1,grid,open))\\n            return true;\\n            \\n        return false;\\n        }\\n}\\n```\n```\\nclass Solution {\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        if (grid[0][0] == \\')\\' || grid[grid.length - 1][grid[0].length - 1] == \\'(\\') return false;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Boolean[][][] dp = new Boolean[n][m][n + m];\\n        return solve(0, 0, grid, 0, dp);\\n    }\\n\\n    public boolean solve(int i, int j, char[][] grid, int open, Boolean[][][] dp) {\\n        if (i >= grid.length || j >= grid[0].length) return false;\\n\\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if (open < 0) return false;\\n\\n        if (i == grid.length - 1 && j == grid[0].length - 1) {\\n            if (open == 0) return true;\\n        }\\n        if (dp[i][j][open] != null) return dp[i][j][open];\\n\\n        if (solve(i + 1, j, grid, open, dp)) {\\n            return dp[i][j][open] = true;\\n        }\\n        if (solve(i, j + 1, grid, open, dp)) {\\n            return dp[i][j][open] = true;\\n        }\\n\\n        return dp[i][j][open] = false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020399,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        int i, j, k;\\n        vector<vector<vector<bool>>> dp(rows, vector<vector<bool>> (cols, vector<bool> (rows + cols)));\\n        \\n        if(grid[0][0] == \\')\\' || grid[rows - 1][cols - 1] == \\'(\\'){\\n            return false;\\n        }\\n        \\n        dp[0][0][1] = true;\\n        for(i = 1; i < cols; i++){\\n            if(grid[0][i] == \\')\\'){\\n                for(j = 0; j < rows + cols - 1; j++){\\n                    dp[0][i][j] = dp[0][i - 1][j + 1];\\n                }\\n            }\\n            else{\\n                for(j = 1; j < rows + cols; j++){\\n                    dp[0][i][j] = dp[0][i - 1][j - 1];\\n                }\\n            }\\n        }\\n        \\n        for(i = 1; i < rows; i++){\\n            if(grid[i][0] == \\')\\'){\\n                for(j = 0; j < rows + cols - 1; j++){\\n                    dp[i][0][j] = dp[i - 1][0][j + 1];\\n                }\\n            }\\n            else{\\n                for(j = 1; j < rows + cols; j++){\\n                    dp[i][0][j] = dp[i - 1][0][j - 1];\\n                }\\n            }\\n        }\\n                \\n        for(i = 1; i < rows; i++){\\n            for(j = 1; j < cols; j++){\\n                if(grid[i][j] == \\')\\'){\\n                    for(k = 0; k < rows + cols - 1; k++){\\n                        dp[i][j][k] = dp[i][j - 1][k + 1] || dp[i - 1][j][k + 1];\\n                    }\\n                }\\n                else{\\n                    for(k = 1; k < rows + cols; k++){\\n                        dp[i][j][k] = dp[i][j - 1][k - 1] || dp[i - 1][j][k - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[rows - 1][cols - 1][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        int i, j, k;\\n        vector<vector<vector<bool>>> dp(rows, vector<vector<bool>> (cols, vector<bool> (rows + cols)));\\n        \\n        if(grid[0][0] == \\')\\' || grid[rows - 1][cols - 1] == \\'(\\'){\\n            return false;\\n        }\\n        \\n        dp[0][0][1] = true;\\n        for(i = 1; i < cols; i++){\\n            if(grid[0][i] == \\')\\'){\\n                for(j = 0; j < rows + cols - 1; j++){\\n                    dp[0][i][j] = dp[0][i - 1][j + 1];\\n                }\\n            }\\n            else{\\n                for(j = 1; j < rows + cols; j++){\\n                    dp[0][i][j] = dp[0][i - 1][j - 1];\\n                }\\n            }\\n        }\\n        \\n        for(i = 1; i < rows; i++){\\n            if(grid[i][0] == \\')\\'){\\n                for(j = 0; j < rows + cols - 1; j++){\\n                    dp[i][0][j] = dp[i - 1][0][j + 1];\\n                }\\n            }\\n            else{\\n                for(j = 1; j < rows + cols; j++){\\n                    dp[i][0][j] = dp[i - 1][0][j - 1];\\n                }\\n            }\\n        }\\n                \\n        for(i = 1; i < rows; i++){\\n            for(j = 1; j < cols; j++){\\n                if(grid[i][j] == \\')\\'){\\n                    for(k = 0; k < rows + cols - 1; k++){\\n                        dp[i][j][k] = dp[i][j - 1][k + 1] || dp[i - 1][j][k + 1];\\n                    }\\n                }\\n                else{\\n                    for(k = 1; k < rows + cols; k++){\\n                        dp[i][j][k] = dp[i][j - 1][k - 1] || dp[i - 1][j][k - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[rows - 1][cols - 1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576750,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 1570877,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 1576729,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 2072858,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 1922483,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 1732637,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            }
        ]
    }
]