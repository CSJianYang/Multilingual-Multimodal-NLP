[
    {
        "title": "Minimum Cost to Split an Array",
        "question_content": "You are given an integer array nums and an integer k.\nSplit the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.\nLet trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed.\n\n\tFor example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].\n\nThe importance value of a subarray is k + trimmed(subarray).length.\n\n\tFor example, if a subarray is [1,2,3,3,3,4,4], then trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this subarray will be k + 5.\n\nReturn the minimum possible cost of a split of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,1,2,1,3,3], k = 2\nOutput: 8\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.\nThe cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.\n\nExample 2:\n\nInput: nums = [1,2,1,2,1], k = 2\nOutput: 6\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1] is 2 + (2) = 4.\nThe cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.\n\nExample 3:\n\nInput: nums = [1,2,1,2,1], k = 5\nOutput: 10\nExplanation: We split nums to have one subarray: [1,2,1,2,1].\nThe importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.\nThe cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t0 <= nums[i] < nums.length\n\t1 <= k <= 109\n\n&nbsp;\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0;Â \n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] + .spoiler > div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] + .spoiler {padding:5px;}",
        "solutions": [
            {
                "id": 3083916,
                "title": "c-based-on-today-s-daily-challenge-simpler-code",
                "content": "This question is almost similar to today\\'s  Daily Challenge\\nhttps://leetcode.com/problems/palindrome-partitioning/\\nDo this Daily challenge question, then try this current problem . It would become really easy for you \\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums, vector<vector<int>>&trimmedLen, vector<int>&dp, int& k, int start) //Partition DP\\n    {\\n        if (start >= nums.size()) return 0;\\n        if (dp[start] != -1) return dp[start];\\n        \\n        int minAns = INT_MAX;\\n        for (int end = start; end < nums.size(); end++)\\n        {\\n            int curr = k + trimmedLen[start][end];\\n            int nextMin = solve(nums, trimmedLen, dp, k, end + 1);\\n            int total = curr + nextMin;\\n            minAns = min(minAns, total);\\n        }\\n        return dp[start] = minAns;\\n    }\\n    int minCost(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        //==========================================================================================\\n        //CALCULATING \"TRIMMED LEN\" OF ALL SUBAARAYS IN O(N^2) INSTEAD OF O(N^3)\\n        //trimmedLen[i][j] gives trimmed length of subarray from (i to j)\\n        vector<vector<int>>trimmedLen(n, vector<int>(n, 0)); \\n        for (int i = 0; i < n; i++)\\n        {\\n            int count = 0;\\n            vector<int>mp(1001, 0);\\n            for (int j = i; j < n; j++)\\n            {\\n                int num = nums[j];\\n                if (mp[num] != 0) //if the current num already exist in map then only increment \"count\"\\n                {\\n                    if (mp[num] == 1) count += 2; //whenever the freq goes from 1 to 2 (add 2 to the count)\\n                    else count++; \\n                }\\n                mp[num]++;\\n                trimmedLen[i][j] = count;\\n            }\\n        }\\n        //=============================================================================================\\n        vector<int>dp(n, -1);\\n        return  solve(nums, trimmedLen, dp, k, 0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums, vector<vector<int>>&trimmedLen, vector<int>&dp, int& k, int start) //Partition DP\\n    {\\n        if (start >= nums.size()) return 0;\\n        if (dp[start] != -1) return dp[start];\\n        \\n        int minAns = INT_MAX;\\n        for (int end = start; end < nums.size(); end++)\\n        {\\n            int curr = k + trimmedLen[start][end];\\n            int nextMin = solve(nums, trimmedLen, dp, k, end + 1);\\n            int total = curr + nextMin;\\n            minAns = min(minAns, total);\\n        }\\n        return dp[start] = minAns;\\n    }\\n    int minCost(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        //==========================================================================================\\n        //CALCULATING \"TRIMMED LEN\" OF ALL SUBAARAYS IN O(N^2) INSTEAD OF O(N^3)\\n        //trimmedLen[i][j] gives trimmed length of subarray from (i to j)\\n        vector<vector<int>>trimmedLen(n, vector<int>(n, 0)); \\n        for (int i = 0; i < n; i++)\\n        {\\n            int count = 0;\\n            vector<int>mp(1001, 0);\\n            for (int j = i; j < n; j++)\\n            {\\n                int num = nums[j];\\n                if (mp[num] != 0) //if the current num already exist in map then only increment \"count\"\\n                {\\n                    if (mp[num] == 1) count += 2; //whenever the freq goes from 1 to 2 (add 2 to the count)\\n                    else count++; \\n                }\\n                mp[num]++;\\n                trimmedLen[i][j] = count;\\n            }\\n        }\\n        //=============================================================================================\\n        vector<int>dp(n, -1);\\n        return  solve(nums, trimmedLen, dp, k, 0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083870,
                "title": "bottom-up-and-top-down",
                "content": "Note that we normalize numbers so we can use an array instead of hash map.\\n\\n> This improves the runtime from 400 to 120 ms.\\n\\nThis is a quadratic DP solution. For each position `i`, we start a split.\\n\\nWe use `cnt` to figure out the trimmed size (`trim`). The transition function is:\\n```cpp\\ndp[j + 1] = min(dp[j + 1], dp[i] + trim + k);\\n```\\n\\n## Bottom-Up\\n**C++**\\n```cpp\\nint minCost(vector<int>& nums, int k, int i = 0) {\\n    unordered_map<int, int> m;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        auto it = m.find(nums[i]);\\n        if (it == end(m))\\n            it = m.insert({nums[i], m.size()}).first;\\n        nums[i] = it->second;\\n    }\\n    int dp[1001] = {};\\n    for (int i = 0; i < nums.size(); ++i) {\\n        int cnt[1001] = {}, trim = 0;\\n        for (int j = i; j < nums.size(); ++j) {\\n            if (++cnt[nums[j]] > 1)\\n                trim += cnt[nums[j]] == 2 ? 2 : 1;\\n            dp[j + 1] = min(dp[j + 1] ? dp[j + 1] : INT_MAX, dp[i] + k + trim);\\n        }\\n    }\\n    return dp[nums.size()];\\n}\\n```\\n## Top-Down\\n**C++**\\n```cpp\\nint dp[1001] = {};\\nint dfs(int i, vector<int>& nums, int k) {\\n    if (dp[i] == 0 && i < nums.size()) {\\n        dp[i] = INT_MAX;\\n        int cnt[1001] = {}, trim = 0;\\n        for (int j = i; j < nums.size(); ++j) {\\n            if (++cnt[nums[j]] > 1)\\n                trim += cnt[nums[j]] == 2 ? 2 : 1;\\n            dp[i] = min(dp[i], trim + k + dfs(j + 1, nums, k));\\n        }\\n    }\\n    return dp[i];\\n}\\nint minCost(vector<int>& nums, int k, int i = 0) {\\n    unordered_map<int, int> m;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        auto it = m.find(nums[i]);\\n        if (it == end(m))\\n            it = m.insert({nums[i], m.size()}).first;\\n        nums[i] = it->second;\\n    }\\n    return dfs(0, nums, k);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\ndp[j + 1] = min(dp[j + 1], dp[i] + trim + k);\\n```\n```cpp\\nint minCost(vector<int>& nums, int k, int i = 0) {\\n    unordered_map<int, int> m;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        auto it = m.find(nums[i]);\\n        if (it == end(m))\\n            it = m.insert({nums[i], m.size()}).first;\\n        nums[i] = it->second;\\n    }\\n    int dp[1001] = {};\\n    for (int i = 0; i < nums.size(); ++i) {\\n        int cnt[1001] = {}, trim = 0;\\n        for (int j = i; j < nums.size(); ++j) {\\n            if (++cnt[nums[j]] > 1)\\n                trim += cnt[nums[j]] == 2 ? 2 : 1;\\n            dp[j + 1] = min(dp[j + 1] ? dp[j + 1] : INT_MAX, dp[i] + k + trim);\\n        }\\n    }\\n    return dp[nums.size()];\\n}\\n```\n```cpp\\nint dp[1001] = {};\\nint dfs(int i, vector<int>& nums, int k) {\\n    if (dp[i] == 0 && i < nums.size()) {\\n        dp[i] = INT_MAX;\\n        int cnt[1001] = {}, trim = 0;\\n        for (int j = i; j < nums.size(); ++j) {\\n            if (++cnt[nums[j]] > 1)\\n                trim += cnt[nums[j]] == 2 ? 2 : 1;\\n            dp[i] = min(dp[i], trim + k + dfs(j + 1, nums, k));\\n        }\\n    }\\n    return dp[i];\\n}\\nint minCost(vector<int>& nums, int k, int i = 0) {\\n    unordered_map<int, int> m;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        auto it = m.find(nums[i]);\\n        if (it == end(m))\\n            it = m.insert({nums[i], m.size()}).first;\\n        nums[i] = it->second;\\n    }\\n    return dfs(0, nums, k);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3092167,
                "title": "easy-to-understand-dp-dfs-memo-35-ms-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsee comment in code\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nDP or DFS+memo are pretty much the same thing, left to right or right to left\\n\\n# [dp without optimization, 422ms](https://leetcode.com/problems/minimum-cost-to-split-an-array/submissions/884045466/)\\n```java\\nclass Solution {\\n    public int minCost(int[] a, int k) {\\n        int n = a.length;\\n        int[] dp = new int[n + 1]; // dp[0] means optimal importance value for empty subarray, dp[1] means optimal importance value for array ending at[0, 1) i.e.[0, 0], dp[i] means optimal importance for array ending at i-1: [0, i) / [0, i-1]\\n        for (int i = 1; i <= n; i++) { // calc result for dp[1] to dp[n]\\n            dp[i] = Integer.MAX_VALUE;\\n            HashMap<Integer, Integer> m = new HashMap<>(); // count map, a new one for each i\\n            int score = k; // importance score always start with k for each subarray\\n            for (int j = i - 1; j >= 0; j--) { // since we know the optimal value in dp[j] for j : [0, i-1], where to put j will we yield best score for dp[i]? (Note: j = 0 means two sub arrays: [0, 0) + [0, i) which means there\\'s only one subarray which is the whole thing\\n                int cnt = m.getOrDefault(a[j], 0);\\n                m.put(a[j], ++cnt);\\n                if (cnt == 2) score += 2; // only when we need a numnber for the second time, we start to add importance score, and it\\'s going to be count as 2\\n                else if (cnt > 2) score++; // for 3rd time and more, each time we count one more importance score\\n                dp[i] = Math.min(dp[i], dp[j] + score);\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n/*\\n\\n*/\\n```\\n\\n# [82ms dfs+memo](https://leetcode.com/problems/minimum-cost-to-split-an-array/submissions/884041186/)\\n``` java\\n// dfs + memo\\nclass Solution {\\n    private int[] dp;\\n    private int idx, n, k;\\n    public int minCost(int[] a, int k) {\\n        n = a.length;\\n        this.k = k;\\n\\n        // compress values in array to value between [0, idx-1], so that we use int array instead of map for count, for speeding up only\\n        Map<Integer, Integer> M = new HashMap<>(); // value to index map\\n        idx = 0;\\n        for (int i = 0; i < n; i++) {\\n            int j = M.getOrDefault(a[i], -1);\\n            if (j == -1) {\\n                M.put(a[i], idx);\\n                a[i] = idx++;\\n            } else a[i] = j;\\n        }\\n\\n        dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n\\n        return dfs(a, 0); // starting at 0 to end, whats the optimal solution?\\n    }\\n\\n    private int dfs(int[] a, int cur) {\\n        if (cur == n) return 0;\\n        if (dp[cur] != Integer.MAX_VALUE) return dp[cur]; // memo query\\n\\n        int[] m = new int[idx];\\n        int score = k; // importance score, starting with k of course\\n        for (int i = cur; i < n; i++) {\\n            if (++m[a[i]] == 2) score += 2; // if we meet the same number for the 2nd time, then it\\'s going to add 2 to importance score\\n            else if (m[a[i]] > 2) score++; // if we meet same number for 3rd or more times in same subarray, each time it adds 1 to importance score\\n            dp[cur] = Math.min(dp[cur], dfs(a, i+1) + score); // find min, remember, dfs(a, i+1) will always return us best score/split from [i+1, end]\\n        }\\n        return dp[cur];\\n    }\\n}\\n```\\n\\n# [35 ms dp, 100%](https://leetcode.com/problems/minimum-cost-to-split-an-array/submissions/884031284/)\\nsame as 1st dp solution, but optimize the use of map to int array, which speeds up significantly in this problem.\\n```java\\n// dp: 35 ms: \\nclass Solution {\\n    public int minCost(int[] a, int k) {\\n        int n = a.length;\\n\\n        // value to index map\\n        Map<Integer, Integer> M = new HashMap<>();\\n        int idx = 0;\\n        for (int i = 0; i < n; i++) {\\n            int j = M.getOrDefault(a[i], -1);\\n            if (j == -1) {\\n                M.put(a[i], idx);\\n                a[i] = idx++;\\n            } else a[i] = j;\\n        }\\n\\n        int[] dp = new int[n+1];\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = Integer.MAX_VALUE;\\n            int[] m = new int[idx];\\n            int score = k;\\n            for (int j = i-1; j >= 0; j--) {\\n                if (++m[a[j]] == 2) score += 2;\\n                else if (m[a[j]] > 2) score++;\\n                dp[i] = Math.min(dp[i], dp[j] + score);\\n            }\\n        }\\n\\n        return dp[n];\\n    }        \\n}\\n```\\nPLEASE UPVOTE IF YOU FIND THIS POST HELPFUL, THANK YOU!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minCost(int[] a, int k) {\\n        int n = a.length;\\n        int[] dp = new int[n + 1]; // dp[0] means optimal importance value for empty subarray, dp[1] means optimal importance value for array ending at[0, 1) i.e.[0, 0], dp[i] means optimal importance for array ending at i-1: [0, i) / [0, i-1]\\n        for (int i = 1; i <= n; i++) { // calc result for dp[1] to dp[n]\\n            dp[i] = Integer.MAX_VALUE;\\n            HashMap<Integer, Integer> m = new HashMap<>(); // count map, a new one for each i\\n            int score = k; // importance score always start with k for each subarray\\n            for (int j = i - 1; j >= 0; j--) { // since we know the optimal value in dp[j] for j : [0, i-1], where to put j will we yield best score for dp[i]? (Note: j = 0 means two sub arrays: [0, 0) + [0, i) which means there\\'s only one subarray which is the whole thing\\n                int cnt = m.getOrDefault(a[j], 0);\\n                m.put(a[j], ++cnt);\\n                if (cnt == 2) score += 2; // only when we need a numnber for the second time, we start to add importance score, and it\\'s going to be count as 2\\n                else if (cnt > 2) score++; // for 3rd time and more, each time we count one more importance score\\n                dp[i] = Math.min(dp[i], dp[j] + score);\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n/*\\n\\n*/\\n```\n``` java\\n// dfs + memo\\nclass Solution {\\n    private int[] dp;\\n    private int idx, n, k;\\n    public int minCost(int[] a, int k) {\\n        n = a.length;\\n        this.k = k;\\n\\n        // compress values in array to value between [0, idx-1], so that we use int array instead of map for count, for speeding up only\\n        Map<Integer, Integer> M = new HashMap<>(); // value to index map\\n        idx = 0;\\n        for (int i = 0; i < n; i++) {\\n            int j = M.getOrDefault(a[i], -1);\\n            if (j == -1) {\\n                M.put(a[i], idx);\\n                a[i] = idx++;\\n            } else a[i] = j;\\n        }\\n\\n        dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n\\n        return dfs(a, 0); // starting at 0 to end, whats the optimal solution?\\n    }\\n\\n    private int dfs(int[] a, int cur) {\\n        if (cur == n) return 0;\\n        if (dp[cur] != Integer.MAX_VALUE) return dp[cur]; // memo query\\n\\n        int[] m = new int[idx];\\n        int score = k; // importance score, starting with k of course\\n        for (int i = cur; i < n; i++) {\\n            if (++m[a[i]] == 2) score += 2; // if we meet the same number for the 2nd time, then it\\'s going to add 2 to importance score\\n            else if (m[a[i]] > 2) score++; // if we meet same number for 3rd or more times in same subarray, each time it adds 1 to importance score\\n            dp[cur] = Math.min(dp[cur], dfs(a, i+1) + score); // find min, remember, dfs(a, i+1) will always return us best score/split from [i+1, end]\\n        }\\n        return dp[cur];\\n    }\\n}\\n```\n```java\\n// dp: 35 ms: \\nclass Solution {\\n    public int minCost(int[] a, int k) {\\n        int n = a.length;\\n\\n        // value to index map\\n        Map<Integer, Integer> M = new HashMap<>();\\n        int idx = 0;\\n        for (int i = 0; i < n; i++) {\\n            int j = M.getOrDefault(a[i], -1);\\n            if (j == -1) {\\n                M.put(a[i], idx);\\n                a[i] = idx++;\\n            } else a[i] = j;\\n        }\\n\\n        int[] dp = new int[n+1];\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = Integer.MAX_VALUE;\\n            int[] m = new int[idx];\\n            int score = k;\\n            for (int j = i-1; j >= 0; j--) {\\n                if (++m[a[j]] == 2) score += 2;\\n                else if (m[a[j]] > 2) score++;\\n                dp[i] = Math.min(dp[i], dp[j] + score);\\n            }\\n        }\\n\\n        return dp[n];\\n    }        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083783,
                "title": "python3-c-easy-dynamic-programming-with-dict-map",
                "content": "\\nAn initial value would be needed in this solution. \\nTo that I added an element to the front of the array that is not in the array (nums=[-1]+nums) and since it is not in the array before, \\ndp[0]=0 (it has no price).\\nThen I started from the 1-index of the array because the 0-index has -1 and calculated the minimum cost up to each element.\\nwhen I go to each index, I go back from it (to index 1).\\nThe goal is to find the best answer.\\nA good answer for j-index is in dp[j].\\n$$for(j=i;j>0;j--)$$\\n$$ans=min(ans,dp[j-1]+s)$$\\n$$s=trimmed(nums[j:i+1])$$\\nAnd at the end of the work dp[i]=ans+k. Because after adding one element, it is split by adding it, and k is added to it.\\n![image.png](https://assets.leetcode.com/users/images/267bf0f4-d049-410e-b9f2-ab9002409c70_1674873816.5484133.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\nIf You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Python3\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        dp=[0]\\n        nums=[-1]+nums\\n        def main(i):\\n            mp=defaultdict(int)\\n            s=0\\n            ans=10000000000000\\n            while i>0:\\n                if mp[nums[i]]>0:\\n                    s+=1\\n                    if mp[nums[i]]==1:\\n                        s+=1\\n                mp[nums[i]]+=1\\n                ans=min(dp[i-1]+s,ans)\\n                i-=1\\n            return ans+k\\n                \\n            \\n        for i in range(1,len(nums)):\\n            dp.append(main(i))\\n        return dp[-1]\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        vector<int>dp(nums.size()+1,0);\\n        reverse(nums.begin(),nums.end());\\n        nums.push_back(-1);\\n        reverse(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++)\\n        {\\n        \\tint s=0,ans=1e8;\\n        \\tunordered_map<int,int>mp;\\n        \\tfor(int j=i;j>0;j--)\\n        \\t{\\n        \\t\\tif(mp[nums[j]]>0)\\n        \\t\\t{\\n        \\t\\t\\ts++;\\n        \\t\\t\\tif(mp[nums[j]]==1)\\n        \\t\\t\\t{\\n        \\t\\t\\t\\ts++;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\tmp[nums[j]]++;\\n        \\t\\tans=min(ans,dp[j-1]+s);\\n        \\t}\\n        \\tdp[i]=ans+k;\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        dp=[0]\\n        nums=[-1]+nums\\n        def main(i):\\n            mp=defaultdict(int)\\n            s=0\\n            ans=10000000000000\\n            while i>0:\\n                if mp[nums[i]]>0:\\n                    s+=1\\n                    if mp[nums[i]]==1:\\n                        s+=1\\n                mp[nums[i]]+=1\\n                ans=min(dp[i-1]+s,ans)\\n                i-=1\\n            return ans+k\\n                \\n            \\n        for i in range(1,len(nums)):\\n            dp.append(main(i))\\n        return dp[-1]\\n```\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        vector<int>dp(nums.size()+1,0);\\n        reverse(nums.begin(),nums.end());\\n        nums.push_back(-1);\\n        reverse(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++)\\n        {\\n        \\tint s=0,ans=1e8;\\n        \\tunordered_map<int,int>mp;\\n        \\tfor(int j=i;j>0;j--)\\n        \\t{\\n        \\t\\tif(mp[nums[j]]>0)\\n        \\t\\t{\\n        \\t\\t\\ts++;\\n        \\t\\t\\tif(mp[nums[j]]==1)\\n        \\t\\t\\t{\\n        \\t\\t\\t\\ts++;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\tmp[nums[j]]++;\\n        \\t\\tans=min(ans,dp[j-1]+s);\\n        \\t}\\n        \\tdp[i]=ans+k;\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083781,
                "title": "java-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStep 1: Precalculating trimmed[i][j]\\n\\ntrimmed[i][j] = Length of trimmed subarray from [i .. j]\\nWe can precalculate these values in O(n^2) time.\\nFrom start index i, we keep track of the frequency of each number\\nIf freq[value] <= 1: We can ignore the value as it wont contribute to trimmed length.\\nIf freq[value] == 2: curr +=2, since we can no longer ignore the value, and include both occurences in trimmed.\\nIf freq[value] > 2: curr +=1, since now we only need to include the newer occurance in trimmed.\\n\\nBased on the constraints, we can use array instead of a HashMap to store frequency.\\n\\n\\nStep 2: DP Equation\\nWe keep DP[i] as the minimum cost for the nums[0..i-1].\\nThus, DP[0] = 0.\\nAnd our solution would be DP[n].\\nDP Equation:\\n\\nSince we can have last subarray anywhere between [0 .. i-1] to [i-1 .. i-1], and its cost would be minimum cost till previous index + importance value of this last subarray, we have DP equation as \\n \\nDP[i] = min(DP[j]+k+trimmed[j][i-1]), where 0 <= j <= i-1\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        \\n        int[][] trimmed = new int[n][n];\\n        for(int i=0;i<n;i++) {\\n            int curr = 0;\\n            int[] freq = new int[n];\\n            for(int j=i;j<n;j++) {\\n                freq[nums[j]]++;\\n                if(freq[nums[j]]==2) {\\n                    curr+=2;\\n                } else if(freq[nums[j]]>2) {\\n                    curr++;\\n                }\\n                trimmed[i][j] = curr;\\n            }\\n        }\\n        int[] dp = new int[n+1];\\n        for(int i=1;i<=n;i++) {\\n            int min = Integer.MAX_VALUE;\\n            for(int j=0;j<i;j++) {\\n                min = Math.min(min, dp[j]+k+trimmed[j][i-1]);\\n            }\\n            dp[i] = min;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        \\n        int[][] trimmed = new int[n][n];\\n        for(int i=0;i<n;i++) {\\n            int curr = 0;\\n            int[] freq = new int[n];\\n            for(int j=i;j<n;j++) {\\n                freq[nums[j]]++;\\n                if(freq[nums[j]]==2) {\\n                    curr+=2;\\n                } else if(freq[nums[j]]>2) {\\n                    curr++;\\n                }\\n                trimmed[i][j] = curr;\\n            }\\n        }\\n        int[] dp = new int[n+1];\\n        for(int i=1;i<=n;i++) {\\n            int min = Integer.MAX_VALUE;\\n            for(int j=0;j<i;j++) {\\n                min = Math.min(min, dp[j]+k+trimmed[j][i-1]);\\n            }\\n            dp[i] = min;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083836,
                "title": "easy-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is the solve this using Dynamic Programming.\\n**Use Array as Map instead of STL HashMap. Otherwise it will give TLE.**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We try all possible partitions\\n2. To get the trimmed(subarray).length we make use of an array as a map to calculate it.\\n3. Finally we minimize our ans variable.\\n4. And store ans in the dp table.\\n5. Finally return our answer\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int>&nums,int k,int n,vector<int>&dp){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        vector<int>mp(n,0);\\n        int cnt = 0;\\n        int ans = INT_MAX;\\n        for(int j = i;j < n;j++){\\n            mp[nums[j]]++;\\n            if(mp[nums[j]] == 2) cnt += 2;\\n            else if(mp[nums[j]] > 2) cnt++;\\n            ans = min(ans,solve(j+1,nums,k,n,dp)+cnt+k);\\n        }\\n        return dp[i] = ans;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        vector<int>dp(nums.size(),-1);\\n        return solve(0,nums,k,nums.size(),dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int>&nums,int k,int n,vector<int>&dp){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        vector<int>mp(n,0);\\n        int cnt = 0;\\n        int ans = INT_MAX;\\n        for(int j = i;j < n;j++){\\n            mp[nums[j]]++;\\n            if(mp[nums[j]] == 2) cnt += 2;\\n            else if(mp[nums[j]] > 2) cnt++;\\n            ans = min(ans,solve(j+1,nums,k,n,dp)+cnt+k);\\n        }\\n        return dp[i] = ans;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        vector<int>dp(nums.size(),-1);\\n        return solve(0,nums,k,nums.size(),dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083951,
                "title": "python-simple-dp-with-dict-hashmap-15-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDP Memorization Approach where `i` is the index of the current number and returning the minimum cost starting at index `i`.\\nKeep a Hashmap  called `hm` to remember the count of each number in the subarray.\\nKeep a count called `count` of numbers that are not unique in the subarray starting at `i`.\\nKeep a current minimum cost value called `min_cost` for subarray starting the subarray at `i` and ending at `len(nums)` by adding `dp(j+1)` to  `k + count`.\\nReturn the minimum `dp` value starting at index 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        \\n        # store the past dp results in a memory cache\\n        @cache\\n        def dp(i):\\n\\n            # i reached the end of nums\\n            if i == len(nums):\\n                return 0\\n\\n            # declare a hm, min_cost (minimum) and count of pairs\\n            min_cost = float(\\'inf\\')\\n            hm = defaultdict(int)\\n            count = 0\\n\\n            for j in range(i,len(nums)):\\n                hm[nums[j]] += 1\\n                \\n                # one pair found, add both numbers\\n                if hm[nums[j]] == 2:\\n                    count += 2\\n                \\n                # add the extra number to count\\n                elif hm[nums[j]] > 2:\\n                    count += 1\\n\\n                importance_value = k + count\\n\\n                #optimization to return early since importance_value keeps increasing and we want to minimum\\n                if importance_value >= min_cost :\\n                    break\\n\\n                min_cost = min( importance_value + dp(j+1)  , min_cost )\\n                \\n            return min_cost\\n\\n        return dp(0) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        \\n        # store the past dp results in a memory cache\\n        @cache\\n        def dp(i):\\n\\n            # i reached the end of nums\\n            if i == len(nums):\\n                return 0\\n\\n            # declare a hm, min_cost (minimum) and count of pairs\\n            min_cost = float(\\'inf\\')\\n            hm = defaultdict(int)\\n            count = 0\\n\\n            for j in range(i,len(nums)):\\n                hm[nums[j]] += 1\\n                \\n                # one pair found, add both numbers\\n                if hm[nums[j]] == 2:\\n                    count += 2\\n                \\n                # add the extra number to count\\n                elif hm[nums[j]] > 2:\\n                    count += 1\\n\\n                importance_value = k + count\\n\\n                #optimization to return early since importance_value keeps increasing and we want to minimum\\n                if importance_value >= min_cost :\\n                    break\\n\\n                min_cost = min( importance_value + dp(j+1)  , min_cost )\\n                \\n            return min_cost\\n\\n        return dp(0) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084442,
                "title": "recursion-top-down-approach-simple-cpp-solution",
                "content": "\\n\\n Time complexity:   O(N^2)\\n\\n- Space complexity:  O(N)\\n# \\n# // Using Recursion  //\\n\\n\\n```\\nint solve(int k, vector<int> &arr, int i, int n)\\n{\\n    if (i == n)\\n    {\\n        return 0;\\n    }\\n\\n    unordered_map<int, int> mp;\\n    int ans = INT_MAX;\\n    int co = 0;\\n    for (int j = i; j < n; j++)\\n    {\\n        mp[arr[j]]++;\\n        if (mp[arr[j]] == 2)\\n        {\\n            co += 2;\\n        }\\n        if (mp[arr[j]] > 2)\\n        {\\n            co++;\\n        }\\n\\n        ans = min(ans, k + solve(k, arr, j + 1, n) + co);\\n    }\\n\\n    return ans;\\n}\\n\\nint minCost(vector<int> &arr, int k)\\n{\\n    int n = arr.size();\\n\\n    return solve(k, arr,0, n);\\n}\\n```\\n# Top-Down  Approch\\n```\\nclass Solution {\\npublic:\\n int solve(int k, vector<int> &arr, int n)\\n{\\n    vector<int> dp(n + 1, INT_MAX);\\n    dp[n] = 0;\\n    for (int i = n - 1; i >= 0; i--)\\n    {\\n\\n        unordered_map<int, int> mp;\\n        int co = 0;\\n\\n        for (int j = i; j < n; j++)\\n        {\\n            mp[arr[j]]++;\\n            if (mp[arr[j]] == 2)\\n            {\\n                co += 2;\\n            }\\n            if (mp[arr[j]] > 2)\\n            {\\n                co++;\\n            }\\n\\n            dp[i] = min(dp[i], k + dp[j + 1] + co);\\n        }\\n    }\\n    return dp[0];\\n}\\n\\nint minCost(vector<int> &arr, int k)\\n{\\n    int n = arr.size();\\n\\n    return solve(k, arr, n);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nint solve(int k, vector<int> &arr, int i, int n)\\n{\\n    if (i == n)\\n    {\\n        return 0;\\n    }\\n\\n    unordered_map<int, int> mp;\\n    int ans = INT_MAX;\\n    int co = 0;\\n    for (int j = i; j < n; j++)\\n    {\\n        mp[arr[j]]++;\\n        if (mp[arr[j]] == 2)\\n        {\\n            co += 2;\\n        }\\n        if (mp[arr[j]] > 2)\\n        {\\n            co++;\\n        }\\n\\n        ans = min(ans, k + solve(k, arr, j + 1, n) + co);\\n    }\\n\\n    return ans;\\n}\\n\\nint minCost(vector<int> &arr, int k)\\n{\\n    int n = arr.size();\\n\\n    return solve(k, arr,0, n);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n int solve(int k, vector<int> &arr, int n)\\n{\\n    vector<int> dp(n + 1, INT_MAX);\\n    dp[n] = 0;\\n    for (int i = n - 1; i >= 0; i--)\\n    {\\n\\n        unordered_map<int, int> mp;\\n        int co = 0;\\n\\n        for (int j = i; j < n; j++)\\n        {\\n            mp[arr[j]]++;\\n            if (mp[arr[j]] == 2)\\n            {\\n                co += 2;\\n            }\\n            if (mp[arr[j]] > 2)\\n            {\\n                co++;\\n            }\\n\\n            dp[i] = min(dp[i], k + dp[j + 1] + co);\\n        }\\n    }\\n    return dp[0];\\n}\\n\\nint minCost(vector<int> &arr, int k)\\n{\\n    int n = arr.size();\\n\\n    return solve(k, arr, n);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084509,
                "title": "c-java-python-easy-dp",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n\\n> **Vote welcome if this solution helped.**\\n---\\n\\n# Intuition\\n1. The value range of length is no more than 1000, so an $O(n^{2})$ algorithm can be considered.\\n2. Notice the subarray is consecutive, immediately think of enumerating all the potential start position $i$ for all the end position $j$.\\n3. As a result, the answer of $i-1$ can easily transfer to the answer of $j$.\\n4. Another question is to calculate the trimmed length. The trimmed length equals to the total length $j-i+1$ minus removed count. The removed count can be traced with $i$ moved from right to left.\\n\\n# Approach\\n\\n- Linear dynamic programming, define $dp[i]$ as the result of $nums[0...i]$, easily to write the transfer equation:\\n$dp[j] = \\\\min_{i={0}} ^{j} {\\\\{ dp[i-1] + k+(j-i+1 -removed)\\\\}}$\\n\\n- Use a counter `mp` to record the count of each number, and an integer `rm` to record the removed count. \\nOnce find a new number, the `rm` should add one; if find a new value has been removed, it should be returned, so the `rm` should be minus 1.\\n\\n# Complexity\\n- Time complexity: $O(n ^ {2})$\\n- Space complexity: $O(n)$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n+1, k+n+1);\\n        dp[0] = 0;\\n        for (int j = 1; j <= n; ++j) {\\n            vector<int> mp(n+1, 0);\\n            int rm = 0;\\n            for (int i = j; i >= 1; --i) {\\n                // update the removed number\\n                rm += (mp[nums[i-1]] == 0) - (mp[nums[i-1]] == 1);\\n                mp[nums[i-1]]++;\\n                dp[j] = min(dp[j], dp[i-1] + k + j - i + 1 - rm);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        int []dp = new int[n+1];\\n        for (int i = 0; i <= n; ++i) dp[i] = k + n + 1;\\n        dp[0] = 0;\\n        int []mp = new int[n+1];\\n        for (int j = 1; j <= n; ++j) {\\n            for (int i = 0; i <= n; ++i) mp[i] = 0;\\n            int rm = 0;\\n            for (int i = j; i >= 1; --i) {\\n                // update the removed number\\n                if (mp[nums[i-1]] == 0) rm++;\\n                else if (mp[nums[i-1]] == 1) rm--;\\n                mp[nums[i-1]]++;\\n                dp[j] = Math.min(dp[j], dp[i-1] + k + j - i + 1 - rm);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n``` Python3 []\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0] + [n+k+1] * n\\n        for j in range(1, n+1):\\n            mp = [0] * (n+1)\\n            rm = 0\\n            for i in range(j, 0, -1):\\n                # update the removed number\\n                rm += (mp[nums[i-1]] == 0) - (mp[nums[i-1]] == 1)\\n                mp[nums[i-1]] += 1\\n                last = dp[i-1] + k + j - i + 1 - rm\\n                if last < dp[j]: dp[j] = last\\n        return dp[n]\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n+1, k+n+1);\\n        dp[0] = 0;\\n        for (int j = 1; j <= n; ++j) {\\n            vector<int> mp(n+1, 0);\\n            int rm = 0;\\n            for (int i = j; i >= 1; --i) {\\n                // update the removed number\\n                rm += (mp[nums[i-1]] == 0) - (mp[nums[i-1]] == 1);\\n                mp[nums[i-1]]++;\\n                dp[j] = min(dp[j], dp[i-1] + k + j - i + 1 - rm);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        int []dp = new int[n+1];\\n        for (int i = 0; i <= n; ++i) dp[i] = k + n + 1;\\n        dp[0] = 0;\\n        int []mp = new int[n+1];\\n        for (int j = 1; j <= n; ++j) {\\n            for (int i = 0; i <= n; ++i) mp[i] = 0;\\n            int rm = 0;\\n            for (int i = j; i >= 1; --i) {\\n                // update the removed number\\n                if (mp[nums[i-1]] == 0) rm++;\\n                else if (mp[nums[i-1]] == 1) rm--;\\n                mp[nums[i-1]]++;\\n                dp[j] = Math.min(dp[j], dp[i-1] + k + j - i + 1 - rm);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n``` Python3 []\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0] + [n+k+1] * n\\n        for j in range(1, n+1):\\n            mp = [0] * (n+1)\\n            rm = 0\\n            for i in range(j, 0, -1):\\n                # update the removed number\\n                rm += (mp[nums[i-1]] == 0) - (mp[nums[i-1]] == 1)\\n                mp[nums[i-1]] += 1\\n                last = dp[i-1] + k + j - i + 1 - rm\\n                if last < dp[j]: dp[j] = last\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084038,
                "title": "tle-during-contest-while-same-solution-accepted-after-contest",
                "content": "I submitted the entire same code after the contest and it got accepted, however during the contest, it gave a TLE. But for Ranking purpose my finish time will be considered as the last accepted solution. Cherry on top: Penalty of 5 mins. per wrong submission. If there are some test cases added, each and every solution is re-evaluated, so why not now when OJ had some sort of runtime problem during the contest. I ask the admin to re-evaluate all the submitted solutions for this question and re calulate the ranks according to the minimum time when it got accepted![image](https://assets.leetcode.com/users/images/90c0775b-dc86-4eb5-bc01-54febbd3e709_1674360772.087545.jpeg)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "I submitted the entire same code after the contest and it got accepted, however during the contest, it gave a TLE. But for Ranking purpose my finish time will be considered as the last accepted solution. Cherry on top: Penalty of 5 mins. per wrong submission. If there are some test cases added, each and every solution is re-evaluated, so why not now when OJ had some sort of runtime problem during the contest. I ask the admin to re-evaluate all the submitted solutions for this question and re calulate the ranks according to the minimum time when it got accepted![image](https://assets.leetcode.com/users/images/90c0775b-dc86-4eb5-bc01-54febbd3e709_1674360772.087545.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3084436,
                "title": "bottom-up-dp-dp-i-min-dp-i-dp-j-k-len-intution-explained",
                "content": "# Intuition\\nthink in this way whenever a new element comes we have to try n possibilities start from 0 to N for that lets say x so for length\\n0 to x and x to N dp[N]=min(dp[N],dp[x]+k+len) so to calculate for 0 to x again we have to use dp[x] simply and for x to N as the whole sub array we can store the elements in a map and count the occurences of elements whose size is greater than 2 and k to it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)\\n\\n- Space complexity\\n$$O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n,0);\\n        dp[0]=k;\\n        for(int i=1;i<n;i++){\\n            unordered_map<int,int> mp;\\n            for(int j=0;j<=i;j++) mp[nums[j]]++; //to store and count the number of occurences of elements we used unordered map\\n            int len=0;\\n            for(auto x:mp) if(x.second>1) len+=x.second;\\n            dp[i]=k+len;\\n            for(int j=0;j<i;j++){\\n                mp[nums[j]]--;\\n                if(mp[nums[j]]==1)  len-=2; //decreasing the length by 2 when the occurence of elements becomes 1\\n                else if(mp[nums[j]]>1) len-=1; //if its greater than 1 then we will only decrese it by 1 as it counts to total\\n                dp[i]=min(dp[i],dp[j]+k+len); //recurrence realtion\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n,0);\\n        dp[0]=k;\\n        for(int i=1;i<n;i++){\\n            unordered_map<int,int> mp;\\n            for(int j=0;j<=i;j++) mp[nums[j]]++; //to store and count the number of occurences of elements we used unordered map\\n            int len=0;\\n            for(auto x:mp) if(x.second>1) len+=x.second;\\n            dp[i]=k+len;\\n            for(int j=0;j<i;j++){\\n                mp[nums[j]]--;\\n                if(mp[nums[j]]==1)  len-=2; //decreasing the length by 2 when the occurence of elements becomes 1\\n                else if(mp[nums[j]]>1) len-=1; //if its greater than 1 then we will only decrese it by 1 as it counts to total\\n                dp[i]=min(dp[i],dp[j]+k+len); //recurrence realtion\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089336,
                "title": "python-3-11-lines-w-example-t-m-5373-ms-20-mb",
                "content": "```\\nclass Solution:                                         #   Example: nums = [1, 2, 1, 2] 5\\n    def minCost(self, nums: List[int], k: int) -> int:  #\\n                                                        #   left   right   tmp   ans     nums[left,right+1]\\n        @lru_cache(None)                                #   \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\n        def dp(left, n = len(nums)):                    #     0      3      9      9 <-- [1, 2, 1, 2]\\n                                                        #     0      2      7     10     [1, 2, 1]\\n            if left == n: return 0                      #     0      1      5     10     [1, 2]\\n                                                        #     0      0      5     12     [1]\\n            tmp, ans,d = k, inf, defaultdict(int)       #     1      3      7      7     [2, 1, 2]\\n                                                        #     1      2      5     10     [2, 1]\\n            for right, num in enumerate(                #     1      1      5     10     [2]\\n                       nums[left:], start = left):      #     2      3      5      5     [1, 2]\\n                                                        #     2      2      5     10     [1]\\n                d[num]+= 1                              #     3      3      5      5     [2]\\n                tmp+= (d[num] > 1) + (d[num] == 2)\\n                ans = min(ans, tmp + dp(right+1))\\n                \\n            return ans\\n\\n        return dp(0)  \\n```\\n[https://leetcode.com/problems/minimum-cost-to-split-an-array/submissions/883318213/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:                                         #   Example: nums = [1, 2, 1, 2] 5\\n    def minCost(self, nums: List[int], k: int) -> int:  #\\n                                                        #   left   right   tmp   ans     nums[left,right+1]\\n        @lru_cache(None)                                #   \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\n        def dp(left, n = len(nums)):                    #     0      3      9      9 <-- [1, 2, 1, 2]\\n                                                        #     0      2      7     10     [1, 2, 1]\\n            if left == n: return 0                      #     0      1      5     10     [1, 2]\\n                                                        #     0      0      5     12     [1]\\n            tmp, ans,d = k, inf, defaultdict(int)       #     1      3      7      7     [2, 1, 2]\\n                                                        #     1      2      5     10     [2, 1]\\n            for right, num in enumerate(                #     1      1      5     10     [2]\\n                       nums[left:], start = left):      #     2      3      5      5     [1, 2]\\n                                                        #     2      2      5     10     [1]\\n                d[num]+= 1                              #     3      3      5      5     [2]\\n                tmp+= (d[num] > 1) + (d[num] == 2)\\n                ans = min(ans, tmp + dp(right+1))\\n                \\n            return ans\\n\\n        return dp(0)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085062,
                "title": "java-dp-top-down-and-bottom-up",
                "content": "# Top down DP\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -1);\\n        return dpMemo(0, nums, dp, k);\\n    }\\n\\n    private int dpMemo(int i, int[] nums, int[] dp, int k) {\\n        if(i == nums.length) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        int uniquesCount = 0;\\n\\n        int localAns = Integer.MAX_VALUE;\\n\\n        for(int j = i; j < nums.length; j++) {\\n            int val = nums[j];\\n            int valFreq = freq.getOrDefault(val, 0);\\n            if(valFreq == 0) uniquesCount++;\\n            if(valFreq == 1) uniquesCount--;\\n\\n            freq.put(val, valFreq + 1);\\n\\n            localAns = Math.min(localAns, dpMemo(j + 1, nums, dp, k) + (j - i + 1 - uniquesCount) + k);\\n        }\\n        return dp[i] = localAns;\\n    }\\n}\\n```\\n\\n\\n# Bottom up DP\\n\\n`dp[i] - min sum up to i (exclusive)`\\n\\n```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n\\n        // base case (initialization case)\\n        dp[0] = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            Map<Integer, Integer> freq = new HashMap<>();\\n            int uniquesCount = 0;\\n\\n            for(int j = i; j < n; j++) {\\n                int val = nums[j];\\n                int valFreq = freq.getOrDefault(val, 0);\\n                if(valFreq == 0) uniquesCount++;\\n                if(valFreq == 1) uniquesCount--;\\n\\n                dp[j + 1] = Math.min(dp[j + 1], dp[i] + (j - i + 1) - uniquesCount + k);\\n                freq.put(val, valFreq + 1);\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, -1);\\n        return dpMemo(0, nums, dp, k);\\n    }\\n\\n    private int dpMemo(int i, int[] nums, int[] dp, int k) {\\n        if(i == nums.length) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        int uniquesCount = 0;\\n\\n        int localAns = Integer.MAX_VALUE;\\n\\n        for(int j = i; j < nums.length; j++) {\\n            int val = nums[j];\\n            int valFreq = freq.getOrDefault(val, 0);\\n            if(valFreq == 0) uniquesCount++;\\n            if(valFreq == 1) uniquesCount--;\\n\\n            freq.put(val, valFreq + 1);\\n\\n            localAns = Math.min(localAns, dpMemo(j + 1, nums, dp, k) + (j - i + 1 - uniquesCount) + k);\\n        }\\n        return dp[i] = localAns;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n\\n        // base case (initialization case)\\n        dp[0] = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            Map<Integer, Integer> freq = new HashMap<>();\\n            int uniquesCount = 0;\\n\\n            for(int j = i; j < n; j++) {\\n                int val = nums[j];\\n                int valFreq = freq.getOrDefault(val, 0);\\n                if(valFreq == 0) uniquesCount++;\\n                if(valFreq == 1) uniquesCount--;\\n\\n                dp[j + 1] = Math.min(dp[j + 1], dp[i] + (j - i + 1) - uniquesCount + k);\\n                freq.put(val, valFreq + 1);\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083910,
                "title": "c-solution-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[1004];\\n    int find(vector<int>&nums,int index,int &k,vector<vector<int>>&range)\\n    {\\n        if(index>=n)\\n        {\\n            return 0;\\n        }\\n        if(dp[index]!=-1)\\n        {\\n            return dp[index];\\n        }\\n        int ans=INT_MAX;\\n        for(int i=index;i<n;i++)\\n        {\\n            ans=min(ans,range[index][i]+k+find(nums,i+1,k,range));\\n        }\\n        return dp[index]= ans;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        n=nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<int>>range(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            int mp[1004];\\n            int count=0;\\n            memset(mp,0,sizeof(mp));\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n                if(mp[nums[j]]>=2)\\n                {\\n                    if(mp[nums[j]]==2)\\n                    {\\n                        count+=2;\\n                    }\\n                    else\\n                    {\\n                        count++;\\n                    }\\n                }\\n                range[i][j]=count;\\n            }\\n        }\\n        return find(nums,0,k,range);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[1004];\\n    int find(vector<int>&nums,int index,int &k,vector<vector<int>>&range)\\n    {\\n        if(index>=n)\\n        {\\n            return 0;\\n        }\\n        if(dp[index]!=-1)\\n        {\\n            return dp[index];\\n        }\\n        int ans=INT_MAX;\\n        for(int i=index;i<n;i++)\\n        {\\n            ans=min(ans,range[index][i]+k+find(nums,i+1,k,range));\\n        }\\n        return dp[index]= ans;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        n=nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<int>>range(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            int mp[1004];\\n            int count=0;\\n            memset(mp,0,sizeof(mp));\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n                if(mp[nums[j]]>=2)\\n                {\\n                    if(mp[nums[j]]==2)\\n                    {\\n                        count+=2;\\n                    }\\n                    else\\n                    {\\n                        count++;\\n                    }\\n                }\\n                range[i][j]=count;\\n            }\\n        }\\n        return find(nums,0,k,range);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084123,
                "title": "top-down-bottom-up-c",
                "content": "Approach - \\n1) In every index we have two options i,e, to include it into the current subarray or to make it another subarray. This is a traditional dp question.\\n2) Then for every partition find the length of current subarray after removing every unique elements in it,\\n3) Point no 2 makes our solutions time complexity of O(n^3) -> O(n^2) from dp table and O(n) for finding the length of the current partition. This will give TLE as question demands solution of time complexity of O(n^2)\\n4) So to avoid TLE we can precompute the length of every subarray from i to j after removing the unique elements in it.\\n\\nC++ (Top-Down)\\n\\n```\\nclass Solution {\\n    int split(vector<int> &nums, int i, int j, int k, vector<vector<int>> &count, vector<vector<int>> &dp) {\\n        int n = nums.size();\\n        if(j == n - 1) return count[i][j] + k; // base case if there are no more elements then returns the current cost\\n        if(dp[i][j] != -1) return dp[i][j]; // memoization\\n        int pick = split(nums, j + 1, j + 1, k, count, dp) + count[i][j] + k; // splits the subarray in current element j after taking it in prev partition\\n        int notPick = split(nums, i, j + 1, k, count, dp); // does not split the array and keeps adding the current element in the current partition\\n        return dp[i][j] = min(pick, notPick); // stores the minimum of both the recursion calls\\n    }\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<int>> count(n, vector<int>(n)), dp(n, vector<int>(n, -1));\\n        for(int i = 0; i < n; ++i) {\\n            vector<int> temp(n);\\n            int len = 0;\\n            for(int j = i; j < n; ++j) {\\n                temp[nums[j]]++; // stores the count of every element in subarray from i to j\\n                if(temp[nums[j]] > 1) len++;  // adds the current element if its count is greater then 1 i.e. it is not unique\\n                if(temp[nums[j]] == 2) len++; // extra addition as current element is added in len when its count became greater than 1 but it\\'s first occurence is not added when it was equal to 1 \\n                count[i][j] = len; // stores the length of treamed subarray from i to j\\n            }\\n        }\\n        return split(nums, 0, 0, k, count, dp);\\n    }\\n};\\n```\\n\\nC++ (Bottom-Up)\\n\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<int>> count(n, vector<int>(n)), dp(n, vector<int>(n));\\n        for(int i = 0; i < n; ++i) {\\n            vector<int> temp(n);\\n            int len = 0;\\n            for(int j = i; j < n; ++j) {\\n                temp[nums[j]]++;\\n                if(temp[nums[j]] > 1) len++;\\n                if(temp[nums[j]] == 2) len++;\\n                count[i][j] = len;\\n            }\\n        }\\n        for(int i = 0; i < n; ++i) {\\n            dp[0][i] = count[0][i] + k;\\n            dp[i][i] = count[i][i] + k;\\n        }\\n        for(int i = 1; i < n; ++i) {\\n            for(int j = i; j < n; ++j) {\\n                dp[i][j] = min(dp[i - 1][i - 1] + count[i][j] + k, dp[i - 1][j]);\\n            }\\n        }\\n        return dp[n - 1][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int split(vector<int> &nums, int i, int j, int k, vector<vector<int>> &count, vector<vector<int>> &dp) {\\n        int n = nums.size();\\n        if(j == n - 1) return count[i][j] + k; // base case if there are no more elements then returns the current cost\\n        if(dp[i][j] != -1) return dp[i][j]; // memoization\\n        int pick = split(nums, j + 1, j + 1, k, count, dp) + count[i][j] + k; // splits the subarray in current element j after taking it in prev partition\\n        int notPick = split(nums, i, j + 1, k, count, dp); // does not split the array and keeps adding the current element in the current partition\\n        return dp[i][j] = min(pick, notPick); // stores the minimum of both the recursion calls\\n    }\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<int>> count(n, vector<int>(n)), dp(n, vector<int>(n, -1));\\n        for(int i = 0; i < n; ++i) {\\n            vector<int> temp(n);\\n            int len = 0;\\n            for(int j = i; j < n; ++j) {\\n                temp[nums[j]]++; // stores the count of every element in subarray from i to j\\n                if(temp[nums[j]] > 1) len++;  // adds the current element if its count is greater then 1 i.e. it is not unique\\n                if(temp[nums[j]] == 2) len++; // extra addition as current element is added in len when its count became greater than 1 but it\\'s first occurence is not added when it was equal to 1 \\n                count[i][j] = len; // stores the length of treamed subarray from i to j\\n            }\\n        }\\n        return split(nums, 0, 0, k, count, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<int>> count(n, vector<int>(n)), dp(n, vector<int>(n));\\n        for(int i = 0; i < n; ++i) {\\n            vector<int> temp(n);\\n            int len = 0;\\n            for(int j = i; j < n; ++j) {\\n                temp[nums[j]]++;\\n                if(temp[nums[j]] > 1) len++;\\n                if(temp[nums[j]] == 2) len++;\\n                count[i][j] = len;\\n            }\\n        }\\n        for(int i = 0; i < n; ++i) {\\n            dp[0][i] = count[0][i] + k;\\n            dp[i][i] = count[i][i] + k;\\n        }\\n        for(int i = 1; i < n; ++i) {\\n            for(int j = i; j < n; ++j) {\\n                dp[i][j] = min(dp[i - 1][i - 1] + count[i][j] + k, dp[i - 1][j]);\\n            }\\n        }\\n        return dp[n - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323828,
                "title": "dp-recursion-short-sweet-easy-to-understand-c-code",
                "content": "````\\nclass Solution {\\npublic:\\n    // long check(vector<int> &v,int &s,int &e){\\n    //     unordered_map<int,int> mp;\\n    //     for(int i = s; i <= e; i++){\\n    //         mp[v[i]]++;\\n    //     }\\n    //     int k = 0;\\n    //     for(auto &i: mp){\\n    //         if(i.second>1){\\n    //             k += i.second;\\n    //         }\\n    //     }\\n    //     return k;\\n    // }\\n    int solve(vector<int> &v,int k,int s,vector<long long int> &dp,int &n,vector<vector<int>> &trimed){\\n        if(s==n){\\n            return 0;\\n        }\\n        if(dp[s] != -1){\\n            return dp[s];\\n        }\\n        long long int ans = LONG_MAX,sum=0;\\n        for(int i = s; i < n; i++){\\n            sum = trimed[s][i]+k+solve(v,k,i+1,dp,n,trimed);//REPLAVE CHECK FUNCTION TO TRIMED ARRAY\\n            ans = min(ans,sum);\\n        }\\n        return dp[s] = ans;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size(),i,j;\\n        vector<long long int> dp(n+1,-1);\\n        vector<vector<int>> trimed(n,vector<int>(n,0));\\n        for(i = 0; i < n; i++){\\n            vector<int> v(n+1,0);\\n            int x = 0;\\n            for(j = i; j < n; j++){\\n                if(v[nums[j]]){\\n                    if(v[nums[j]]==1)x += 2;\\n                    else x++;\\n                }\\n                v[nums[j]]++;\\n                trimed[i][j] = x;\\n            }\\n        }\\n        return solve(nums,k,0,dp,n,trimed);\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    // long check(vector<int> &v,int &s,int &e){\\n    //     unordered_map<int,int> mp;\\n    //     for(int i = s; i <= e; i++){\\n    //         mp[v[i]]++;\\n    //     }\\n    //     int k = 0;\\n    //     for(auto &i: mp){\\n    //         if(i.second>1){\\n    //             k += i.second;\\n    //         }\\n    //     }\\n    //     return k;\\n    // }\\n    int solve(vector<int> &v,int k,int s,vector<long long int> &dp,int &n,vector<vector<int>> &trimed){\\n        if(s==n){\\n            return 0;\\n        }\\n        if(dp[s] != -1){\\n            return dp[s];\\n        }\\n        long long int ans = LONG_MAX,sum=0;\\n        for(int i = s; i < n; i++){\\n            sum = trimed[s][i]+k+solve(v,k,i+1,dp,n,trimed);//REPLAVE CHECK FUNCTION TO TRIMED ARRAY\\n            ans = min(ans,sum);\\n        }\\n        return dp[s] = ans;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size(),i,j;\\n        vector<long long int> dp(n+1,-1);\\n        vector<vector<int>> trimed(n,vector<int>(n,0));\\n        for(i = 0; i < n; i++){\\n            vector<int> v(n+1,0);\\n            int x = 0;\\n            for(j = i; j < n; j++){\\n                if(v[nums[j]]){\\n                    if(v[nums[j]]==1)x += 2;\\n                    else x++;\\n                }\\n                v[nums[j]]++;\\n                trimed[i][j] = x;\\n            }\\n        }\\n        return solve(nums,k,0,dp,n,trimed);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086376,
                "title": "c-simple-solution-easy-to-understand-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is to use Dynamic Programming.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int split[1001][1001],dp[1001];\\n    \\n    int solve(vector<int>& nums, int k, int index)\\n    {\\n        if(index>=nums.size())\\n            return 0;\\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int score=INT_MAX;\\n        \\n        for(int i=index; i<nums.size(); i++)\\n        {\\n            int curr=k+split[index][i]+solve(nums,k,i+1);\\n            score=min(score,curr);\\n        }\\n        dp[index]=score;\\n        return score;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        \\n      memset(dp,-1,sizeof(dp));\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            unordered_map<int,int> s;\\n            int trim=0;\\n            for(int j=i; j<nums.size(); j++)\\n            {\\n                s[nums[j]]++;\\n                if(s[nums[j]]==2)\\n                    trim+=2;\\n                else if(s[nums[j]]>2)\\n                    trim++;\\n                split[i][j]=trim;\\n             } \\n        }\\n        \\n        return solve(nums,k,0);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int split[1001][1001],dp[1001];\\n    \\n    int solve(vector<int>& nums, int k, int index)\\n    {\\n        if(index>=nums.size())\\n            return 0;\\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int score=INT_MAX;\\n        \\n        for(int i=index; i<nums.size(); i++)\\n        {\\n            int curr=k+split[index][i]+solve(nums,k,i+1);\\n            score=min(score,curr);\\n        }\\n        dp[index]=score;\\n        return score;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        \\n      memset(dp,-1,sizeof(dp));\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            unordered_map<int,int> s;\\n            int trim=0;\\n            for(int j=i; j<nums.size(); j++)\\n            {\\n                s[nums[j]]++;\\n                if(s[nums[j]]==2)\\n                    trim+=2;\\n                else if(s[nums[j]]>2)\\n                    trim++;\\n                split[i][j]=trim;\\n             } \\n        }\\n        \\n        return solve(nums,k,0);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084508,
                "title": "rust-dp-1d",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl4/lc2547)\\n\\n<b>By Tag</b>\\n#PartitionOrSplit - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/array/by_topic/partition_or_split.txt)\\n#Subarray - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/array/by_data_structure/subarray.txt)\\n\\n```\\n/// @author: Leon\\n/// https://leetcode.com/problems/minimum-cost-to-split-an-array/\\n/// Time Complexity:    O(`len_ns` ^ 2)\\n/// Space Complexity:   O(`len_ns` ^ 2)\\n/// Reference:\\n/// https://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3083781/java-dp/\\nimpl Solution {\\n    pub fn min_cost(nums: Vec<i32>, k: i32) -> i32 {\\n        let len_ns: usize = nums.len();\\n        let trimmed: Vec<Vec<i32>> = {\\n            let mut trimmed: Vec<Vec<i32>> = vec![vec![0; len_ns]; len_ns];\\n            for lo in 0..len_ns {\\n                // to calculate the trimmed length !on the run!\\n                let mut cnt: i32 = 0;\\n                let mut freqs: Vec<i32> = vec![0; len_ns];\\n                for hi in lo..len_ns {\\n                    let idx: usize = nums[hi] as usize;\\n                    freqs[idx as usize] += 1;\\n                    if freqs[idx] == 2 {\\n                        cnt += 2;\\n                    } else if freqs[idx] > 2 {\\n                        cnt += 1;\\n                    }\\n                    trimmed[lo][hi] = cnt;\\n                }\\n            }\\n            trimmed\\n        };\\n        // double caution with indices\\n        let upper_bound: i32 = trimmed[0][len_ns - 1] + k;\\n        // double caution with indices\\n        let mut dp: Vec<i32> = vec![0; len_ns + 1];\\n        for hi in 1..=len_ns {\\n            let mut min: i32 = upper_bound;\\n            for lo in 0..hi {\\n                min = std::cmp::min(min, dp[lo] + k + trimmed[lo][hi - 1]);\\n            }\\n            dp[hi] = min;\\n        }\\n        return dp[len_ns];\\n    }\\n}\\n```\\n\\nPlease be reminded that a dedicated method to calculate the trimmed length might lead to TLE.\\n\\nSolution - TLEed - [github](https://github.com/An7One/lc_soln_rust_leon/blob/main/src/leetcode/lvl4/lc2547/soln_tle_dp.rs)\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n/// @author: Leon\\n/// https://leetcode.com/problems/minimum-cost-to-split-an-array/\\n/// Time Complexity:    O(`len_ns` ^ 2)\\n/// Space Complexity:   O(`len_ns` ^ 2)\\n/// Reference:\\n/// https://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3083781/java-dp/\\nimpl Solution {\\n    pub fn min_cost(nums: Vec<i32>, k: i32) -> i32 {\\n        let len_ns: usize = nums.len();\\n        let trimmed: Vec<Vec<i32>> = {\\n            let mut trimmed: Vec<Vec<i32>> = vec![vec![0; len_ns]; len_ns];\\n            for lo in 0..len_ns {\\n                // to calculate the trimmed length !on the run!\\n                let mut cnt: i32 = 0;\\n                let mut freqs: Vec<i32> = vec![0; len_ns];\\n                for hi in lo..len_ns {\\n                    let idx: usize = nums[hi] as usize;\\n                    freqs[idx as usize] += 1;\\n                    if freqs[idx] == 2 {\\n                        cnt += 2;\\n                    } else if freqs[idx] > 2 {\\n                        cnt += 1;\\n                    }\\n                    trimmed[lo][hi] = cnt;\\n                }\\n            }\\n            trimmed\\n        };\\n        // double caution with indices\\n        let upper_bound: i32 = trimmed[0][len_ns - 1] + k;\\n        // double caution with indices\\n        let mut dp: Vec<i32> = vec![0; len_ns + 1];\\n        for hi in 1..=len_ns {\\n            let mut min: i32 = upper_bound;\\n            for lo in 0..hi {\\n                min = std::cmp::min(min, dp[lo] + k + trimmed[lo][hi - 1]);\\n            }\\n            dp[hi] = min;\\n        }\\n        return dp[len_ns];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3084007,
                "title": "video-explanation-intuition-of-every-steps",
                "content": "## Explanation\\n\\nhttps://www.youtube.com/watch?v=lpnyAUx3PRk\\n\\n[Click here if the preview doesn\\'t works](https://www.youtube.com/watch?v=lpnyAUx3PRk)\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int> dp;\\n    \\n    int MinCost (int start_ind, const int k, const vector<int>& nums) {\\n        int n = nums.size();\\n        if (start_ind == n) return 0;\\n        \\n        int &result = dp[start_ind];\\n        if (result != -1) return result;\\n        \\n        result = 1e9 + 1e3 + 1;\\n        unordered_map<int, int> frq;\\n        int trimmed_length = 0;\\n        \\n        for (int end_ind = start_ind; end_ind < n; end_ind ++) {\\n            int &cur_frq = frq[nums[end_ind]];\\n            \\n            cur_frq ++;\\n            if (cur_frq == 1);\\n            else if (cur_frq == 2) trimmed_length += 2;\\n            else trimmed_length ++;\\n            \\n            result = min (result, trimmed_length + k + MinCost (end_ind + 1, k, nums));\\n        }\\n        return result;\\n    }\\n        \\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        dp.clear();\\n        dp.resize(n, -1);\\n        \\n        return MinCost (0, k, nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> dp;\\n    \\n    int MinCost (int start_ind, const int k, const vector<int>& nums) {\\n        int n = nums.size();\\n        if (start_ind == n) return 0;\\n        \\n        int &result = dp[start_ind];\\n        if (result != -1) return result;\\n        \\n        result = 1e9 + 1e3 + 1;\\n        unordered_map<int, int> frq;\\n        int trimmed_length = 0;\\n        \\n        for (int end_ind = start_ind; end_ind < n; end_ind ++) {\\n            int &cur_frq = frq[nums[end_ind]];\\n            \\n            cur_frq ++;\\n            if (cur_frq == 1);\\n            else if (cur_frq == 2) trimmed_length += 2;\\n            else trimmed_length ++;\\n            \\n            result = min (result, trimmed_length + k + MinCost (end_ind + 1, k, nums));\\n        }\\n        return result;\\n    }\\n        \\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        dp.clear();\\n        dp.resize(n, -1);\\n        \\n        return MinCost (0, k, nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264791,
                "title": "mcm-variation-easy-to-understand-must-see",
                "content": "# Code\\n```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution \\n{\\npublic:\\n    vector<int>dp;\\n    int minCost(vector<int>& nums, int k) \\n    {\\n        dp.resize(nums.size()+1,-1);\\n\\n        int idx = 0;\\n        int start = 0;\\n        int end = nums.size()-1;\\n\\n        return fun(nums,start,end,k);\\n    }\\n    int fun(vector<int>&nums,int start,int &end,int &k)\\n    {\\n         //partition will be in the form of start to i\\n         if(start > end)\\n         return 0;\\n        \\n         if(dp[start] != -1)\\n         return dp[start];\\n         \\n         int ans = INT_MAX;\\n\\n         int uniquecount = 0;\\n         unordered_map<int,int>mp;\\n        \\n         for(int i=start;i<=end;i++)   //note\\n         {\\n             mp[nums[i]]++;\\n             if(mp[nums[i]] == 1)\\n             {\\n                 uniquecount++;\\n             }\\n             else if(mp[nums[i]] == 2)\\n             {\\n                 uniquecount--;\\n             }\\n             else if(mp[nums[i]] > 2)\\n             {\\n                 ;\\n             }\\n\\n              int temp = k + ((i - start + 1) - uniquecount) + fun(nums,i+1,end,k);\\n\\n              if(temp < ans)\\n              ans = temp;\\n         }\\n        return dp[start] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming",
                    "Counting"
                ],
                "code": "```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution \\n{\\npublic:\\n    vector<int>dp;\\n    int minCost(vector<int>& nums, int k) \\n    {\\n        dp.resize(nums.size()+1,-1);\\n\\n        int idx = 0;\\n        int start = 0;\\n        int end = nums.size()-1;\\n\\n        return fun(nums,start,end,k);\\n    }\\n    int fun(vector<int>&nums,int start,int &end,int &k)\\n    {\\n         //partition will be in the form of start to i\\n         if(start > end)\\n         return 0;\\n        \\n         if(dp[start] != -1)\\n         return dp[start];\\n         \\n         int ans = INT_MAX;\\n\\n         int uniquecount = 0;\\n         unordered_map<int,int>mp;\\n        \\n         for(int i=start;i<=end;i++)   //note\\n         {\\n             mp[nums[i]]++;\\n             if(mp[nums[i]] == 1)\\n             {\\n                 uniquecount++;\\n             }\\n             else if(mp[nums[i]] == 2)\\n             {\\n                 uniquecount--;\\n             }\\n             else if(mp[nums[i]] > 2)\\n             {\\n                 ;\\n             }\\n\\n              int temp = k + ((i - start + 1) - uniquecount) + fun(nums,i+1,end,k);\\n\\n              if(temp < ans)\\n              ans = temp;\\n         }\\n        return dp[start] = ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3164140,
                "title": "c-minimum-cost-to-spilit-an-array-dynamic-memo",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1001];\\n    int helper(int node ,  int k , vector<int>&nums){\\n        if(node >= nums.size())return 0;\\n        else if(dp[node] !=-1)return dp[node];\\n        int ans = INT_MAX ;\\n        int a = 0;\\n        unordered_map<int , int>mp;\\n        for(int i = node ;i  < nums.size() ;i++){\\n            if(++mp[nums[i]] > 1) {\\n                if(mp[nums[i]] == 2) a++;\\n                a++;\\n            }\\n            ans = min(ans , k + a + helper(i+1 , k , nums) );\\n        }\\n        return dp[node] = ans;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp , -1 , sizeof(dp));\\n        return helper(0 , k , nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001];\\n    int helper(int node ,  int k , vector<int>&nums){\\n        if(node >= nums.size())return 0;\\n        else if(dp[node] !=-1)return dp[node];\\n        int ans = INT_MAX ;\\n        int a = 0;\\n        unordered_map<int , int>mp;\\n        for(int i = node ;i  < nums.size() ;i++){\\n            if(++mp[nums[i]] > 1) {\\n                if(mp[nums[i]] == 2) a++;\\n                a++;\\n            }\\n            ans = min(ans , k + a + helper(i+1 , k , nums) );\\n        }\\n        return dp[node] = ans;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp , -1 , sizeof(dp));\\n        return helper(0 , k , nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093186,
                "title": "c-java-solution-dp",
                "content": "\\n# Java Code\\n```\\nclass Solution {\\n    public int solve(int ind,int nums[],int k,int dp[]){\\n        if(ind==nums.length){\\n            return 0;\\n        }\\n        if(dp[ind]!=-1) return dp[ind];\\n        HashMap<Integer,Integer>mpp=new HashMap<>();\\n        int ans=Integer.MAX_VALUE;\\n        int score=k;\\n        for(int i=ind;i<nums.length;i++){\\n            if(mpp.containsKey(nums[i])==true){\\n                mpp.put(nums[i],mpp.get(nums[i])+1);\\n                if(mpp.get(nums[i])==2){\\n                    score+=2;\\n                }else{\\n                    score+=1;\\n                }\\n            }else{\\n                mpp.put(nums[i],1);\\n            }\\n            \\n            ans=Math.min(ans,score+solve(i+1,nums,k,dp));\\n        }\\n        return dp[ind]=ans;\\n    }\\n    public int minCost(int[] nums, int k) {\\n        int n=nums.length;\\n        int dp[]=new int[n];\\n        Arrays.fill(dp,-1);\\n\\n        return solve(0,nums,k,dp);\\n    }\\n}\\n```\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int ind,int k,vector<int>&nums,vector<int>&dp){\\n        if(ind==nums.size()) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        int score=k;\\n        unordered_map<int,int>mpp;\\n        int ans=INT_MAX;\\n        for(int i=ind;i<nums.size();i++){\\n            mpp[nums[i]]++;\\n            if(mpp[nums[i]]>1){\\n                if(mpp[nums[i]]==2)score+=2;\\n                else score++;\\n            }\\n            ans=min(ans,score+solve(i+1,k,nums,dp));\\n        }\\n        return dp[ind]=ans;\\n        \\n        \\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        vector<int>dp(nums.size(),-1);\\n        return solve(0,k,nums,dp);\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int solve(int ind,int nums[],int k,int dp[]){\\n        if(ind==nums.length){\\n            return 0;\\n        }\\n        if(dp[ind]!=-1) return dp[ind];\\n        HashMap<Integer,Integer>mpp=new HashMap<>();\\n        int ans=Integer.MAX_VALUE;\\n        int score=k;\\n        for(int i=ind;i<nums.length;i++){\\n            if(mpp.containsKey(nums[i])==true){\\n                mpp.put(nums[i],mpp.get(nums[i])+1);\\n                if(mpp.get(nums[i])==2){\\n                    score+=2;\\n                }else{\\n                    score+=1;\\n                }\\n            }else{\\n                mpp.put(nums[i],1);\\n            }\\n            \\n            ans=Math.min(ans,score+solve(i+1,nums,k,dp));\\n        }\\n        return dp[ind]=ans;\\n    }\\n    public int minCost(int[] nums, int k) {\\n        int n=nums.length;\\n        int dp[]=new int[n];\\n        Arrays.fill(dp,-1);\\n\\n        return solve(0,nums,k,dp);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int ind,int k,vector<int>&nums,vector<int>&dp){\\n        if(ind==nums.size()) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        int score=k;\\n        unordered_map<int,int>mpp;\\n        int ans=INT_MAX;\\n        for(int i=ind;i<nums.size();i++){\\n            mpp[nums[i]]++;\\n            if(mpp[nums[i]]>1){\\n                if(mpp[nums[i]]==2)score+=2;\\n                else score++;\\n            }\\n            ans=min(ans,score+solve(i+1,k,nums,dp));\\n        }\\n        return dp[ind]=ans;\\n        \\n        \\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        vector<int>dp(nums.size(),-1);\\n        return solve(0,k,nums,dp);\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088224,
                "title": "python3-solution-100-faster-dp",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, A, K):\\n        n = len(A)\\n        dp = [0] + [float(\\'inf\\')] * n\\n        for i in range(n):\\n            C = [0] * n\\n            val = K\\n            for j in range(i, -1, -1):\\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\\n                C[A[j]] += 1\\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, A, K):\\n        n = len(A)\\n        dp = [0] + [float(\\'inf\\')] * n\\n        for i in range(n):\\n            C = [0] * n\\n            val = K\\n            for j in range(i, -1, -1):\\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\\n                C[A[j]] += 1\\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085235,
                "title": "simplest-and-easiest-c-solution-with-detailed-explanation-and-intuition",
                "content": "# Intuition\\nIntuition is similar to that of 0/1 knapsach like we have two choices for each and every index to split the array from that index or not.\\n\\n# Approach\\nCreating a recursive function and assuming that it will return the minimum cost from index ind to n. So call the function from 0 index and now we have choices to split array from ind to n and again recursively call the function and store the minimum answer till now.\\nAnd for the trimmed value of subarray, if frequency of element is 1 then we have to add 0, and as frequency becomes 2, we have to count this number from now onwards so we will add 2 (1 for current and 1 for previous) and if frequency > 1 we add 1 for each occurrence. \\nAnd now in recursion we see overlapping subproblems, so simply memoise it.\\nKeep Coding :)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int ind, vector<int>& nums, int k, vector<int> &dp){\\n        if(ind == nums.size()) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        vector<int> hsh(1001, 0);\\n        int fact = 0;\\n        int ans = INT_MAX;\\n        for(int i = ind; i < nums.size(); i++){\\n            hsh[nums[i]]++;\\n            fact += hsh[nums[i]] == 2 ? 2 : (hsh[nums[i]] == 1 ? 0 : 1);\\n            ans = min(ans, k + fact + solve(i + 1, nums, k, dp));\\n        }\\n        return dp[ind] = ans;\\n    }\\n\\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(), -1);\\n        return solve(0, nums, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(int ind, vector<int>& nums, int k, vector<int> &dp){\\n        if(ind == nums.size()) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        vector<int> hsh(1001, 0);\\n        int fact = 0;\\n        int ans = INT_MAX;\\n        for(int i = ind; i < nums.size(); i++){\\n            hsh[nums[i]]++;\\n            fact += hsh[nums[i]] == 2 ? 2 : (hsh[nums[i]] == 1 ? 0 : 1);\\n            ans = min(ans, k + fact + solve(i + 1, nums, k, dp));\\n        }\\n        return dp[ind] = ans;\\n    }\\n\\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(), -1);\\n        return solve(0, nums, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084878,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [inf]*(n+1)\\n        dp[-1] = 0 \\n        for i in range(n-1, -1, -1): \\n            val = 0 \\n            freq = Counter()\\n            for ii in range(i, n): \\n                freq[nums[ii]] += 1\\n                if freq[nums[ii]] == 2: val += 2\\n                elif freq[nums[ii]] > 2: val += 1\\n                dp[i] = min(dp[i], k + val + dp[ii+1])\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [inf]*(n+1)\\n        dp[-1] = 0 \\n        for i in range(n-1, -1, -1): \\n            val = 0 \\n            freq = Counter()\\n            for ii in range(i, n): \\n                freq[nums[ii]] += 1\\n                if freq[nums[ii]] == 2: val += 2\\n                elif freq[nums[ii]] > 2: val += 1\\n                dp[i] = min(dp[i], k + val + dp[ii+1])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084872,
                "title": "simple-python-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,prev,nums,k,dct):\\n        if i>=len(nums):\\n            return 0\\n        if (i,prev) in dct:\\n            return dct[(i,prev)]\\n        x=float(\"infinity\")\\n        sm=0\\n        cnt=defaultdict(lambda :0)\\n        for j in range(i,len(nums)):\\n            cnt[nums[j]]+=1\\n            if cnt[nums[j]]==2:\\n                sm+=2\\n            elif cnt[nums[j]]>2:\\n                sm+=1\\n            z=self.dp(j+1,j,nums,k,dct)+k+sm\\n            x=min(x,z)\\n        dct[(i,prev)]=x\\n        return x\\n        \\n    def minCost(self, nums: List[int], k: int) -> int:\\n        return self.dp(0,0,nums,k,{})\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self,i,prev,nums,k,dct):\\n        if i>=len(nums):\\n            return 0\\n        if (i,prev) in dct:\\n            return dct[(i,prev)]\\n        x=float(\"infinity\")\\n        sm=0\\n        cnt=defaultdict(lambda :0)\\n        for j in range(i,len(nums)):\\n            cnt[nums[j]]+=1\\n            if cnt[nums[j]]==2:\\n                sm+=2\\n            elif cnt[nums[j]]>2:\\n                sm+=1\\n            z=self.dp(j+1,j,nums,k,dct)+k+sm\\n            x=min(x,z)\\n        dct[(i,prev)]=x\\n        return x\\n        \\n    def minCost(self, nums: List[int], k: int) -> int:\\n        return self.dp(0,0,nums,k,{})\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084764,
                "title": "easy-video-solution-1d-dp-c-beginner-friendly",
                "content": "# Intuition and Approach\\nhttps://youtu.be/RkgKv39A0zk\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n,INT_MAX);\\n        dp[0]=k;\\n        unordered_map<int,int> freq;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            int val=0;\\n            freq.clear();\\n            for(int j=i;j>=0;j--)\\n            {\\n                freq[nums[j]]++;\\n                if(freq[nums[j]]==2)\\n                val+=2;\\n                else if(freq[nums[j]]>2) \\n                val++;\\n                dp[i]=min(dp[i],(j>0?dp[j-1]:0)+k+val);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n,INT_MAX);\\n        dp[0]=k;\\n        unordered_map<int,int> freq;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            int val=0;\\n            freq.clear();\\n            for(int j=i;j>=0;j--)\\n            {\\n                freq[nums[j]]++;\\n                if(freq[nums[j]]==2)\\n                val+=2;\\n                else if(freq[nums[j]]>2) \\n                val++;\\n                dp[i]=min(dp[i],(j>0?dp[j-1]:0)+k+val);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084652,
                "title": "c-recursive-solution",
                "content": "```\\npublic class Solution {\\n    public int MinCost(int[] nums, int k) {\\n        int[] memo = new int[nums.Length];\\n        return FindMinCost(0, nums, k, memo);\\n    }\\n\\n    private int FindMinCost(int idx, int[] nums, int k, int[] memo){\\n        if(idx == nums.Length) return 0;\\n        if(memo[idx] > 0) return memo[idx];\\n        Dictionary<int,int> d = new();\\n        int minSubArrayCost = int.MaxValue, currSubArrayCost = k;\\n        for(int i = idx; i < nums.Length; i++){\\n            if(!d.ContainsKey(nums[i]))\\n                d.Add(nums[i], 0);\\n            d[nums[i]]++;\\n            currSubArrayCost += d[nums[i]] <= 1 ? 0 : (d[nums[i]] == 2 ? 2 : 1);\\n            minSubArrayCost = Math.Min(minSubArrayCost, FindMinCost(i+1, nums, k, memo)+currSubArrayCost);\\n        }\\n        return memo[idx] = minSubArrayCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinCost(int[] nums, int k) {\\n        int[] memo = new int[nums.Length];\\n        return FindMinCost(0, nums, k, memo);\\n    }\\n\\n    private int FindMinCost(int idx, int[] nums, int k, int[] memo){\\n        if(idx == nums.Length) return 0;\\n        if(memo[idx] > 0) return memo[idx];\\n        Dictionary<int,int> d = new();\\n        int minSubArrayCost = int.MaxValue, currSubArrayCost = k;\\n        for(int i = idx; i < nums.Length; i++){\\n            if(!d.ContainsKey(nums[i]))\\n                d.Add(nums[i], 0);\\n            d[nums[i]]++;\\n            currSubArrayCost += d[nums[i]] <= 1 ? 0 : (d[nums[i]] == 2 ? 2 : 1);\\n            minSubArrayCost = Math.Min(minSubArrayCost, FindMinCost(i+1, nums, k, memo)+currSubArrayCost);\\n        }\\n        return memo[idx] = minSubArrayCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084630,
                "title": "short-concise-dp-solution-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the same intuition as a knapsack problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCompute the importance value for every subarray and transfer the state of dp by comparing the two options  subarray .\\n\\ndp[j] is the minimum of :\\n- the subarray from 1 -> j\\n- the minimum value from the range 1 -> i  plus the subarray from i -> j\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0] = 0;\\n\\n        for(int i=0;i<n;++i){\\n            unordered_map<int,int>umap;\\n            int uniq = 0;\\n            \\n            for(int j=i;j<n;++j){\\n                ++umap[nums[j]];\\n                if(umap[nums[j]]>1){\\n                    if(umap[nums[j]]==2)--uniq;\\n                }\\n                else ++uniq;\\n                \\n                int im = k+(j-i+1) - uniq;\\n                dp[j+1]=min(dp[j+1],dp[i]+im);      \\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        vector<int>dp(n+1,INT_MAX);\\n        dp[0] = 0;\\n\\n        for(int i=0;i<n;++i){\\n            unordered_map<int,int>umap;\\n            int uniq = 0;\\n            \\n            for(int j=i;j<n;++j){\\n                ++umap[nums[j]];\\n                if(umap[nums[j]]>1){\\n                    if(umap[nums[j]]==2)--uniq;\\n                }\\n                else ++uniq;\\n                \\n                int im = k+(j-i+1) - uniq;\\n                dp[j+1]=min(dp[j+1],dp[i]+im);      \\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084166,
                "title": "java-o-n-dp-o-n-2-sliding-widow-pre-compute",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        int[][] cost = new int[n][n];\\n        for (int len = n; len >= 1; len--) {\\n            compute(cost, nums, len, k);\\n        }\\n\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = k;\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = cost[0][i];\\n            for (int j = 0; j < i; j++) {\\n                dp[i] = Math.min(dp[i], dp[j] + cost[j + 1][i]);\\n            }\\n        }\\n\\n        return dp[n - 1];\\n        \\n    }\\n    \\n    // sliding window\\n    private void compute(int[][]cost, int[] nums, int len, int k) {\\n        int[] freq = new int[1001];\\n        Set<Integer> distinct = new HashSet<>();\\n        for (int i = 0; i < len; i++) {\\n            freq[nums[i]]++;\\n            if (freq[nums[i]] == 1) distinct.add(nums[i]);\\n            if (freq[nums[i]] > 1 || freq[nums[i]] == 0) distinct.remove(nums[i]);\\n        }\\n        \\n        cost[0][len - 1] = len - distinct.size() + k;\\n        \\n        for (int i = len; i < cost.length; i++) {\\n            // enqueue right\\n            int l = i - len;\\n            freq[nums[i]]++;\\n            if (freq[nums[i]] == 1) distinct.add(nums[i]);\\n            if ((freq[nums[i]] > 1 || freq[nums[i]] == 0) && distinct.contains(nums[i])) distinct.remove(nums[i]);\\n            \\n            freq[nums[l]]--;\\n            if (freq[nums[l]] == 1) distinct.add(nums[l]);\\n            if ((freq[nums[l]] > 1 || freq[nums[l]] == 0) && distinct.contains(nums[l])) distinct.remove(nums[l]);\\n            cost[l + 1][i] = len - distinct.size() + k;\\n        }\\n    \\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        int[][] cost = new int[n][n];\\n        for (int len = n; len >= 1; len--) {\\n            compute(cost, nums, len, k);\\n        }\\n\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = k;\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = cost[0][i];\\n            for (int j = 0; j < i; j++) {\\n                dp[i] = Math.min(dp[i], dp[j] + cost[j + 1][i]);\\n            }\\n        }\\n\\n        return dp[n - 1];\\n        \\n    }\\n    \\n    // sliding window\\n    private void compute(int[][]cost, int[] nums, int len, int k) {\\n        int[] freq = new int[1001];\\n        Set<Integer> distinct = new HashSet<>();\\n        for (int i = 0; i < len; i++) {\\n            freq[nums[i]]++;\\n            if (freq[nums[i]] == 1) distinct.add(nums[i]);\\n            if (freq[nums[i]] > 1 || freq[nums[i]] == 0) distinct.remove(nums[i]);\\n        }\\n        \\n        cost[0][len - 1] = len - distinct.size() + k;\\n        \\n        for (int i = len; i < cost.length; i++) {\\n            // enqueue right\\n            int l = i - len;\\n            freq[nums[i]]++;\\n            if (freq[nums[i]] == 1) distinct.add(nums[i]);\\n            if ((freq[nums[i]] > 1 || freq[nums[i]] == 0) && distinct.contains(nums[i])) distinct.remove(nums[i]);\\n            \\n            freq[nums[l]]--;\\n            if (freq[nums[l]] == 1) distinct.add(nums[l]);\\n            if ((freq[nums[l]] > 1 || freq[nums[l]] == 0) && distinct.contains(nums[l])) distinct.remove(nums[l]);\\n            cost[l + 1][i] = len - distinct.size() + k;\\n        }\\n    \\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084075,
                "title": "javascript-solution-dynamic-programming",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minCost = function (nums, k) {\\n\\n        const len = nums.length\\n        const dp = new Array(len + 1).fill(-1)\\n\\n        return partition(-1, nums, k, len, dp)\\n};\\n\\nconst partition = (ind, nums, k, len, dp) => {\\n\\n        if (len - 1 === ind) return 0\\n\\n        if (dp[ind] !== -1 && ind !== -1) return dp[ind]\\n        \\n\\n        const hashTable = new Map()\\n        let min = Number.MAX_SAFE_INTEGER, importanceVal = 0\\n        for (let i = ind + 1; i < len; i++) {\\n                const updatedVal = (hashTable.get(nums[i]) || 0) + 1\\n                hashTable.set(nums[i], updatedVal)\\n            \\n                if(updatedVal === 2) importanceVal += updatedVal\\n                if(updatedVal > 2) importanceVal++\\n            \\n                const val = k + importanceVal + partition(i, nums, k, len, dp)\\n                min = Math.min(min, val)\\n        }\\n        \\n        return dp[ind] = min\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minCost = function (nums, k) {\\n\\n        const len = nums.length\\n        const dp = new Array(len + 1).fill(-1)\\n\\n        return partition(-1, nums, k, len, dp)\\n};\\n\\nconst partition = (ind, nums, k, len, dp) => {\\n\\n        if (len - 1 === ind) return 0\\n\\n        if (dp[ind] !== -1 && ind !== -1) return dp[ind]\\n        \\n\\n        const hashTable = new Map()\\n        let min = Number.MAX_SAFE_INTEGER, importanceVal = 0\\n        for (let i = ind + 1; i < len; i++) {\\n                const updatedVal = (hashTable.get(nums[i]) || 0) + 1\\n                hashTable.set(nums[i], updatedVal)\\n            \\n                if(updatedVal === 2) importanceVal += updatedVal\\n                if(updatedVal > 2) importanceVal++\\n            \\n                const val = k + importanceVal + partition(i, nums, k, len, dp)\\n                min = Math.min(min, val)\\n        }\\n        \\n        return dp[ind] = min\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083973,
                "title": "dp-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n          int size = nums.size();\\n        vector<vector<long long>> dp_1(size, vector<long long>(size, 0));\\n        for (int i = 0; i < size; i++)\\n        {\\n            vector<int> mp(size, 0);\\n            int c = 0;\\n            for (int j = i; j < size; j++)\\n            {\\n                if (mp[nums[j]] == 0){}\\n                else if ((mp[nums[j]]) == 1) \\n                    c += 2;\\n                else\\n                    c++;\\n                mp[nums[j]]++;\\n                dp_1[i][j] = c;\\n            }\\n        }\\n        vector<long long> dp_2(size + 1, LLONG_MAX);\\n        dp_2[0] = 0;\\n        \\n        dp_2[1] = dp_1[0][0] + k;\\n\\n        for (int i = 2; i <= size; i++)\\n        {\\n            dp_2[i] = dp_1[0][i - 1] + k;\\n            for (int j = i - 1; j >= 1; j--)\\n            {\\n                dp_2[i] = min(dp_2[i], dp_2[j] + dp_1[j][i - 1] + k);\\n            }\\n        }\\n        return dp_2[size];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n          int size = nums.size();\\n        vector<vector<long long>> dp_1(size, vector<long long>(size, 0));\\n        for (int i = 0; i < size; i++)\\n        {\\n            vector<int> mp(size, 0);\\n            int c = 0;\\n            for (int j = i; j < size; j++)\\n            {\\n                if (mp[nums[j]] == 0){}\\n                else if ((mp[nums[j]]) == 1) \\n                    c += 2;\\n                else\\n                    c++;\\n                mp[nums[j]]++;\\n                dp_1[i][j] = c;\\n            }\\n        }\\n        vector<long long> dp_2(size + 1, LLONG_MAX);\\n        dp_2[0] = 0;\\n        \\n        dp_2[1] = dp_1[0][0] + k;\\n\\n        for (int i = 2; i <= size; i++)\\n        {\\n            dp_2[i] = dp_1[0][i - 1] + k;\\n            for (int j = i - 1; j >= 1; j--)\\n            {\\n                dp_2[i] = min(dp_2[i], dp_2[j] + dp_1[j][i - 1] + k);\\n            }\\n        }\\n        return dp_2[size];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083943,
                "title": "rust-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn min_cost(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = nums.len();\\n        let mut dp = vec![i32::MAX; n];\\n        \\n        for i in 0 .. n {\\n            let mut mp = HashMap::<i32, i32>::new();\\n            let mut sum = 0;\\n            for j in (0 ..= i).rev() {\\n                if let Some(cnt) = mp.get(&nums[j]) {\\n                    sum += 1;\\n                    if *cnt == 1 { sum += 1; }\\n                }\\n                *mp.entry(nums[j]).or_insert(0) += 1;\\n                let mut temp = k + sum;\\n                if j > 0 { temp += dp[j - 1]; }\\n                dp[i] = dp[i].min(temp);\\n            }\\n        }\\n        dp[n - 1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn min_cost(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = nums.len();\\n        let mut dp = vec![i32::MAX; n];\\n        \\n        for i in 0 .. n {\\n            let mut mp = HashMap::<i32, i32>::new();\\n            let mut sum = 0;\\n            for j in (0 ..= i).rev() {\\n                if let Some(cnt) = mp.get(&nums[j]) {\\n                    sum += 1;\\n                    if *cnt == 1 { sum += 1; }\\n                }\\n                *mp.entry(nums[j]).or_insert(0) += 1;\\n                let mut temp = k + sum;\\n                if j > 0 { temp += dp[j - 1]; }\\n                dp[i] = dp[i].min(temp);\\n            }\\n        }\\n        dp[n - 1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083808,
                "title": "c-dp-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<int>> dp1(n, vector<int>(n, 0));\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector<int> mp(n, 0);\\n            int c = 0;\\n            for (int j = i; j < n; j++)\\n            {\\n                if (mp[nums[j]] == 0){}\\n                else if ((mp[nums[j]]) == 1) c += 2;\\n                else c++;\\n                mp[nums[j]]++;\\n                dp1[i][j] = c;\\n            }\\n        }\\n        vector<int> dp2(n + 1,INT_MAX );  //LLONG_MAX  long long\\n        dp2[0] = 0;\\n        dp2[1] = dp1[0][0] + k;\\n\\n        for (int i = 2; i <= n; i++)\\n        {\\n            dp2[i] = dp1[0][i - 1] + k;\\n            for (int j = i - 1; j >= 1; j--)\\n            {\\n                dp2[i] = min(dp2[i], dp2[j] + dp1[j][i - 1] + k);\\n            }\\n        }\\n        return dp2[n];\\n    }\\n};\\n\\n\\n        \\n    \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<int>> dp1(n, vector<int>(n, 0));\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector<int> mp(n, 0);\\n            int c = 0;\\n            for (int j = i; j < n; j++)\\n            {\\n                if (mp[nums[j]] == 0){}\\n                else if ((mp[nums[j]]) == 1) c += 2;\\n                else c++;\\n                mp[nums[j]]++;\\n                dp1[i][j] = c;\\n            }\\n        }\\n        vector<int> dp2(n + 1,INT_MAX );  //LLONG_MAX  long long\\n        dp2[0] = 0;\\n        dp2[1] = dp1[0][0] + k;\\n\\n        for (int i = 2; i <= n; i++)\\n        {\\n            dp2[i] = dp1[0][i - 1] + k;\\n            for (int j = i - 1; j >= 1; j--)\\n            {\\n                dp2[i] = min(dp2[i], dp2[j] + dp1[j][i - 1] + k);\\n            }\\n        }\\n        return dp2[n];\\n    }\\n};\\n\\n\\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083805,
                "title": "easy-dp-in-two-steps",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int> &nums, int k) {\\n        vector<vector<long long>> dp((int)nums.size(), vector<long long>((int)nums.size(), 0));\\n        vector<long long> res((int)nums.size() + 1, LLONG_MAX);\\n        \\n        //task1:\\n        //tabulation table\\n        for (int i = 0; i < (int)nums.size(); i++) {\\n            vector<int> mp((int)nums.size(), 0);\\n            int sz = 0;\\n            for (int j = i; j < (int)nums.size(); j++){\\n                if (mp[nums[j]] != 0)sz+= ((mp[nums[j]]) == 1)?2:1;\\n                mp[nums[j]]++, dp[i][j] = sz;\\n            }\\n        }\\n        \\n        //task 2:\\n        //get max value for each index;\\n        res[0] = 0, res[1] = dp[0][0] + k;\\n        for (int i = 2; i <= (int)nums.size(); i++) {\\n            res[i] = dp[0][i - 1] + k;\\n            for (int j= i-1;j>=1;j--) res[i] = min(res[i],res[j]+dp[j][i-1] + k);\\n        }\\n        return res[(int)nums.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int> &nums, int k) {\\n        vector<vector<long long>> dp((int)nums.size(), vector<long long>((int)nums.size(), 0));\\n        vector<long long> res((int)nums.size() + 1, LLONG_MAX);\\n        \\n        //task1:\\n        //tabulation table\\n        for (int i = 0; i < (int)nums.size(); i++) {\\n            vector<int> mp((int)nums.size(), 0);\\n            int sz = 0;\\n            for (int j = i; j < (int)nums.size(); j++){\\n                if (mp[nums[j]] != 0)sz+= ((mp[nums[j]]) == 1)?2:1;\\n                mp[nums[j]]++, dp[i][j] = sz;\\n            }\\n        }\\n        \\n        //task 2:\\n        //get max value for each index;\\n        res[0] = 0, res[1] = dp[0][0] + k;\\n        for (int i = 2; i <= (int)nums.size(); i++) {\\n            res[i] = dp[0][i - 1] + k;\\n            for (int j= i-1;j>=1;j--) res[i] = min(res[i],res[j]+dp[j][i-1] + k);\\n        }\\n        return res[(int)nums.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022209,
                "title": "easy-to-understand-dp-solution",
                "content": "# Intuition\\nLook at the constraint it helps a lot.\\nGenerally splitting problems has DP solution.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int count[n][n];\\n        memset(count,0,sizeof(count));\\n        // count[i][j] = number of occurrence of j in nums(0...i);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(i==0) {\\n                    if(j==nums[0]) count[i][j]++;\\n                }else{\\n                    count[i][j]=count[i-1][j];\\n                    if(j==nums[i]) count[i][j]++;\\n                }\\n            }\\n        }\\n        //imp[i][j] = length of trimmed subarray(i...j)\\n        int imp[n][n];\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<=i; j++){\\n                if(i==j) imp[j][i]=0;\\n                else{\\n                    int c = count[i-1][nums[i]];\\n                    if(j>0) c -= count[j-1][nums[i]];\\n                    imp[j][i] = imp[j][i-1];\\n                    if(c>0) imp[j][i] = imp[j][i-1]+1+(c==1);\\n                }\\n            }\\n        }\\n        // dp[i] = min cost to split subarray(0...i)\\n        int dp[n];\\n        for(int i=0; i<n; i++){\\n            dp[i]=imp[0][i]+k;\\n            for(int j=0; j<i; j++)\\n                dp[i]=min(dp[i],dp[j]+imp[j+1][i]+k);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int count[n][n];\\n        memset(count,0,sizeof(count));\\n        // count[i][j] = number of occurrence of j in nums(0...i);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(i==0) {\\n                    if(j==nums[0]) count[i][j]++;\\n                }else{\\n                    count[i][j]=count[i-1][j];\\n                    if(j==nums[i]) count[i][j]++;\\n                }\\n            }\\n        }\\n        //imp[i][j] = length of trimmed subarray(i...j)\\n        int imp[n][n];\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<=i; j++){\\n                if(i==j) imp[j][i]=0;\\n                else{\\n                    int c = count[i-1][nums[i]];\\n                    if(j>0) c -= count[j-1][nums[i]];\\n                    imp[j][i] = imp[j][i-1];\\n                    if(c>0) imp[j][i] = imp[j][i-1]+1+(c==1);\\n                }\\n            }\\n        }\\n        // dp[i] = min cost to split subarray(0...i)\\n        int dp[n];\\n        for(int i=0; i<n; i++){\\n            dp[i]=imp[0][i]+k;\\n            for(int j=0; j<i; j++)\\n                dp[i]=min(dp[i],dp[j]+imp[j+1][i]+k);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980957,
                "title": "memoization-hashmap",
                "content": "# Code\\n```\\nint dp[1005];\\n\\nint f(int ind,vector<int>&nums,int k,int n)\\n{\\n    if(ind == n)\\n    return 0;\\n    if(dp[ind] != -1)\\n    return dp[ind];\\n    unordered_map<int,int>hash;\\n    int p = 0;\\n    int res = INT_MAX;\\n    for(int i=ind;i<n;i++)\\n    {\\n        int len = i - ind + 1;\\n        if(hash[nums[i]] == 0)\\n        p++;\\n        else if(hash[nums[i]] == 1)\\n        p--;\\n        hash[nums[i]]++;\\n        int trimmed = len - p;\\n        res = min(res,f(i+1,nums,k,n) + k + trimmed);\\n    }\\n    return dp[ind] = res;\\n}\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,nums,k,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint dp[1005];\\n\\nint f(int ind,vector<int>&nums,int k,int n)\\n{\\n    if(ind == n)\\n    return 0;\\n    if(dp[ind] != -1)\\n    return dp[ind];\\n    unordered_map<int,int>hash;\\n    int p = 0;\\n    int res = INT_MAX;\\n    for(int i=ind;i<n;i++)\\n    {\\n        int len = i - ind + 1;\\n        if(hash[nums[i]] == 0)\\n        p++;\\n        else if(hash[nums[i]] == 1)\\n        p--;\\n        hash[nums[i]]++;\\n        int trimmed = len - p;\\n        res = min(res,f(i+1,nums,k,n) + k + trimmed);\\n    }\\n    return dp[ind] = res;\\n}\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,nums,k,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942831,
                "title": "beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem has a basic DP structure:\\n$$\\n\\\\text{DP}_{i+1} = \\\\min_{j=0}^i (\\\\text{DP}_j + W_{j,i+1})\\n$$\\nwhere $\\\\text{DP}_i$ means the min cost of splitting `nums[0, i)` and $W_{j,i+1}$ means the importance of subarray `nums[j, i+1)`\\n\\n> **Note**: We use the inclusive-exlcusive convention, which means `nums[a, b)` includes all index `i` such that $a \\\\le i < b$.\\n\\nThis easily gives us a $\\\\Theta(N^2)$ solution. But **can we do better**?\\n\\nLet\\'s consider the difference between $W_{j,i}$ and $W_{j,i+1}$, we basically appended `nums[i]` into the subarray and there are 3 possible cases:\\n  * `nums[i]` does not exist in `nums[j,i)`, therefore unique in `nums[j,i+1)`. $ \\\\implies W_{j,i+1} = W_{j,i}$\\n  * `nums[i]` is unique in `nums[j,i)`, therefore duplicated in `nums[j,i+1)`. $ \\\\implies W_{j,i+1} = W_{j,i} + 2$\\n  * `nums[i]` is duplicated in `nums[j,i)`, therefore also duplicated in `nums[j,i+1)`. $ \\\\implies W_{j,i+1} = W_{j,i} + 1$\\n\\nAnd of course a special case when $j = i$ we have $W_{j,i+1} = k$ (single element subarray).\\n\\nThese cases are separated by the *last index of `nums[i]`*.\\nLet\\'s define $L(i)$ as the last index before $i$ such that `nums[L(i)]` = `nums[i]`.\\nWe can get:\\n$$\\nW_{j, i+1} =\\n\\\\begin{cases}\\n  W_{j, i} + 1 & 0 \\\\le j \\\\le L(L(i)) \\\\\\\\\\n  W_{j, i} + 2 & L(L(i)) < j \\\\le L(i) \\\\\\\\\\n  W_{j, i} & L(i) < j < i \\\\\\\\\\n  k & j = i\\n\\\\end{cases}\\n$$\\n\\nNow let\\'s define $P_{j,i} = \\\\text{DP}_j + W_{j,i}$ to rewrite the dp structure:\\n$$\\n\\\\text{DP}_{i+1} = \\\\min_{j=0}^i P_{j,i+1}\\n$$\\n$P_{j,i}$ means the min cost of splitting `nums[0, i)` with the last subarray starting at $j$.\\n\\nNotice that $\\\\text{DP}_j$ does not depend on $i$, so we get a similar equation set:\\n$$\\nP_{j, i+1} =\\n\\\\begin{cases}\\n  P_{j, i} + 1 & 0 \\\\le j \\\\le L(L(i)) \\\\\\\\\\n  P_{j, i} + 2 & L(L(i)) < j \\\\le L(i) \\\\\\\\\\n  P_{j, i} & L(i) < j < i \\\\\\\\\\n  \\\\text{DP}_i + k & j = i\\n\\\\end{cases}\\n$$\\n\\nNow if we think about it, $\\\\text{DP}_i$ is a *range min query* of $P_{j,i}$ over range $j \\\\in [0, i)$ and when we increment $i$ we only need to do some *range increment update*. Both operation can be done in $\\\\Theta(\\\\log N)$ time in a **segment tree** data structure.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n## Calculate the last index function.\\nThis can be efficiently done by a one pass algorithm:\\n```\\nvector<int> GetLastIndexLookup(const vector<int>& nums) {\\n  const int N = nums.size();\\n  vector<int> value_to_last(N, -1);  // value to index\\n  vector<int> lookup(N);\\n  for (int i = 0; i < N; ++i) {\\n    int& last = value_to_last[nums[i]];\\n    lookup[i] = last;\\n    last = i;\\n  }\\n  return lookup;\\n}\\n```\\n\\n## Define segment tree (for min value query)\\nSegment tree is a well known data structure:\\nhttps://en.wikipedia.org/wiki/Segment_tree\\nSpecifically we need to support:\\n```\\ntemplate <typename T>\\nclass SegMinTree {\\n public:\\n  // Constructs a min segment tree for the range [0, n)\\n  SegMinTree(int n);\\n\\n  // Returns the min value in the range [start, end)\\n  T GetRangeMin(int start, int end) const;\\n\\n  // Adds delta to every elements in the range [start, end)\\n  void IncrementRange(int start, int end, T delta);\\n}\\n```\\n\\n## DP with Range Query/Update\\nIn each iteration we increment $i$ and update the corresponding $P_{j,i}$ (stored in the tree) and $\\\\text{DP}_i$ (the variable `cost`).\\n```\\nint cost = 0;\\nfor (int i = 0; i < N; ++i) {\\n  int last = last_index[i];\\n  if (last != -1) {\\n    int last2 = last_index[last];\\n    tree.IncrementRange(0, last2 + 1, 1);\\n    tree.IncrementRange(last2 + 1, last + 1, 2);\\n  }\\n  tree.IncrementRange(i, i + 1, cost + k);  // First time value set.\\n\\n  cost = tree.GetRangeMin(0, i + 1);\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N \\\\log N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$\\n\\n# Code\\n```\\n\\nvector<int> GetLastIndexLookup(const vector<int>& nums) {\\n  const int N = nums.size();\\n  vector<int> value_to_last(N, -1);  // value to index\\n  vector<int> lookup(N);\\n  for (int i = 0; i < N; ++i) {\\n    int& last = value_to_last[nums[i]];\\n    lookup[i] = last;\\n    last = i;\\n  }\\n  return lookup;\\n}\\n\\ntemplate <typename T>\\nclass SegMinTree {\\n public:\\n  // Constructs a min segment tree for the range [0, n)\\n  SegMinTree(int n) : N(n), values_(4 * n), deltas_(4 * n) {}\\n\\n  // Returns the value at the specified index.\\n  T Get(int index) const {\\n    return GetRangeMin(index, index + 1);\\n  }\\n\\n  // Sets the value at the specified index.\\n  void Set(int index, T value) {\\n    IncrementRange(index, index + 1, value - Get(index));\\n  }\\n\\n  // Returns the min value in the range [start, end)\\n  T GetRangeMin(int start, int end) const {\\n    return Query(FullSegment(), start, end);\\n  }\\n\\n  // Adds delta to every elements in the range [start, end)\\n  void IncrementRange(int start, int end, T delta) {\\n    Increment(FullSegment(), start, end, delta);\\n  }\\n\\n private:\\n  struct Segment {\\n    int id;\\n    int start;\\n    int end;\\n\\n    bool Overlaps(int start, int end) const {\\n      return this->start < end && this->end > start;\\n    }\\n\\n    bool IsIn(int start, int end) const {\\n      return start <= this->start && this->end <= end;\\n    }\\n\\n    Segment Left() const {\\n      return {.id = id * 2, .start = start, .end = (start + end + 1) / 2};\\n    }\\n\\n    Segment Right() const {\\n      return {.id = id * 2 + 1, .start = (start + end + 1) / 2, .end = end};\\n    }\\n  };\\n\\n  Segment FullSegment() const {\\n    return {.id = 1, .start = 0, .end = N};\\n  }\\n\\n  T Query(const Segment& segment, int start, int end) const {\\n    if (!segment.Overlaps(start, end)) {\\n      return std::numeric_limits<T>::max();\\n    }\\n    if (segment.IsIn(start, end)) {\\n      return values_[segment.id];\\n    }\\n    // Now it partially overlaps.\\n    T children_value = std::min(Query(segment.Left(), start, end), Query(segment.Right(), start, end));\\n    return deltas_[segment.id] + children_value;\\n  }\\n\\n  // Returns the updated min over the entire segment (unrelated to [start, end)).\\n  T Increment(const Segment& segment, int start, int end, T delta) {\\n    if (!segment.Overlaps(start, end)) {\\n      return values_[segment.id];  // old value.\\n    }\\n    if (segment.IsIn(start, end)) {\\n      values_[segment.id] += delta;\\n      deltas_[segment.id] += delta;\\n      return values_[segment.id];\\n    }\\n    // Now it partially overlaps.\\n    T value = std::min(Increment(segment.Left(), start, end, delta),\\n                       Increment(segment.Right(), start, end, delta));\\n    value += deltas_[segment.id];\\n    values_[segment.id] = value;\\n    return value;                          \\n  }\\n\\n  const int N;\\n  std::vector<T> values_;\\n  std::vector<T> deltas_;  // deltas_[id] only applies to the children of id node.\\n};\\n\\nclass Solution {\\npublic:\\n  int minCost(vector<int>& nums, int k) {\\n    const int N = nums.size();\\n    vector<int> last_index = GetLastIndexLookup(nums);\\n    SegMinTree<int> tree(N);\\n\\n    int cost = 0;\\n    for (int i = 0; i < N; ++i) {\\n      int last = last_index[i];\\n      if (last != -1) {\\n        int last2 = last_index[last];\\n        tree.IncrementRange(0, last2 + 1, 1);\\n        tree.IncrementRange(last2 + 1, last + 1, 2);\\n      }\\n      tree.IncrementRange(i, i + 1, cost + k);  // First time value set.\\n\\n      cost = tree.GetRangeMin(0, i + 1);\\n    }\\n\\n    return cost;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Segment Tree"
                ],
                "code": "```\\nvector<int> GetLastIndexLookup(const vector<int>& nums) {\\n  const int N = nums.size();\\n  vector<int> value_to_last(N, -1);  // value to index\\n  vector<int> lookup(N);\\n  for (int i = 0; i < N; ++i) {\\n    int& last = value_to_last[nums[i]];\\n    lookup[i] = last;\\n    last = i;\\n  }\\n  return lookup;\\n}\\n```\n```\\ntemplate <typename T>\\nclass SegMinTree {\\n public:\\n  // Constructs a min segment tree for the range [0, n)\\n  SegMinTree(int n);\\n\\n  // Returns the min value in the range [start, end)\\n  T GetRangeMin(int start, int end) const;\\n\\n  // Adds delta to every elements in the range [start, end)\\n  void IncrementRange(int start, int end, T delta);\\n}\\n```\n```\\nint cost = 0;\\nfor (int i = 0; i < N; ++i) {\\n  int last = last_index[i];\\n  if (last != -1) {\\n    int last2 = last_index[last];\\n    tree.IncrementRange(0, last2 + 1, 1);\\n    tree.IncrementRange(last2 + 1, last + 1, 2);\\n  }\\n  tree.IncrementRange(i, i + 1, cost + k);  // First time value set.\\n\\n  cost = tree.GetRangeMin(0, i + 1);\\n}\\n```\n```\\n\\nvector<int> GetLastIndexLookup(const vector<int>& nums) {\\n  const int N = nums.size();\\n  vector<int> value_to_last(N, -1);  // value to index\\n  vector<int> lookup(N);\\n  for (int i = 0; i < N; ++i) {\\n    int& last = value_to_last[nums[i]];\\n    lookup[i] = last;\\n    last = i;\\n  }\\n  return lookup;\\n}\\n\\ntemplate <typename T>\\nclass SegMinTree {\\n public:\\n  // Constructs a min segment tree for the range [0, n)\\n  SegMinTree(int n) : N(n), values_(4 * n), deltas_(4 * n) {}\\n\\n  // Returns the value at the specified index.\\n  T Get(int index) const {\\n    return GetRangeMin(index, index + 1);\\n  }\\n\\n  // Sets the value at the specified index.\\n  void Set(int index, T value) {\\n    IncrementRange(index, index + 1, value - Get(index));\\n  }\\n\\n  // Returns the min value in the range [start, end)\\n  T GetRangeMin(int start, int end) const {\\n    return Query(FullSegment(), start, end);\\n  }\\n\\n  // Adds delta to every elements in the range [start, end)\\n  void IncrementRange(int start, int end, T delta) {\\n    Increment(FullSegment(), start, end, delta);\\n  }\\n\\n private:\\n  struct Segment {\\n    int id;\\n    int start;\\n    int end;\\n\\n    bool Overlaps(int start, int end) const {\\n      return this->start < end && this->end > start;\\n    }\\n\\n    bool IsIn(int start, int end) const {\\n      return start <= this->start && this->end <= end;\\n    }\\n\\n    Segment Left() const {\\n      return {.id = id * 2, .start = start, .end = (start + end + 1) / 2};\\n    }\\n\\n    Segment Right() const {\\n      return {.id = id * 2 + 1, .start = (start + end + 1) / 2, .end = end};\\n    }\\n  };\\n\\n  Segment FullSegment() const {\\n    return {.id = 1, .start = 0, .end = N};\\n  }\\n\\n  T Query(const Segment& segment, int start, int end) const {\\n    if (!segment.Overlaps(start, end)) {\\n      return std::numeric_limits<T>::max();\\n    }\\n    if (segment.IsIn(start, end)) {\\n      return values_[segment.id];\\n    }\\n    // Now it partially overlaps.\\n    T children_value = std::min(Query(segment.Left(), start, end), Query(segment.Right(), start, end));\\n    return deltas_[segment.id] + children_value;\\n  }\\n\\n  // Returns the updated min over the entire segment (unrelated to [start, end)).\\n  T Increment(const Segment& segment, int start, int end, T delta) {\\n    if (!segment.Overlaps(start, end)) {\\n      return values_[segment.id];  // old value.\\n    }\\n    if (segment.IsIn(start, end)) {\\n      values_[segment.id] += delta;\\n      deltas_[segment.id] += delta;\\n      return values_[segment.id];\\n    }\\n    // Now it partially overlaps.\\n    T value = std::min(Increment(segment.Left(), start, end, delta),\\n                       Increment(segment.Right(), start, end, delta));\\n    value += deltas_[segment.id];\\n    values_[segment.id] = value;\\n    return value;                          \\n  }\\n\\n  const int N;\\n  std::vector<T> values_;\\n  std::vector<T> deltas_;  // deltas_[id] only applies to the children of id node.\\n};\\n\\nclass Solution {\\npublic:\\n  int minCost(vector<int>& nums, int k) {\\n    const int N = nums.size();\\n    vector<int> last_index = GetLastIndexLookup(nums);\\n    SegMinTree<int> tree(N);\\n\\n    int cost = 0;\\n    for (int i = 0; i < N; ++i) {\\n      int last = last_index[i];\\n      if (last != -1) {\\n        int last2 = last_index[last];\\n        tree.IncrementRange(0, last2 + 1, 1);\\n        tree.IncrementRange(last2 + 1, last + 1, 2);\\n      }\\n      tree.IncrementRange(i, i + 1, cost + k);  // First time value set.\\n\\n      cost = tree.GetRangeMin(0, i + 1);\\n    }\\n\\n    return cost;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877131,
                "title": "using-2-d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   long long dp[1001][1001];\\n\\n   long long fun(int i,int j,vector<int>&nums,int k,vector<vector<int>>&store){\\n       if(j>=nums.size()){\\n           if(i>=nums.size()) return 0;\\n           return 1e15+0;\\n       }\\n       if(dp[i][j]!=-1) return dp[i][j];\\nlong long ans=min(fun(i,j+1,nums,k,store),store[i][j]+k+fun(j+1,j+1,nums,k,store));\\n\\n     return dp[i][j]=ans;\\n\\n   }\\n\\n\\n\\n\\n\\n    int minCost(vector<int>& nums, int k) {\\n         int n=nums.size();\\n         vector<vector<int>>store(n,vector<int>(n,0));\\n\\n\\n\\n\\n\\n\\n        for(int i=0;i<nums.size();i++){\\n             unordered_set<int>first,second;\\n             for(int j=i;j<nums.size();j++){\\nif(first.find(nums[j])==first.end()){\\n                 if(second.find(nums[j])==second.end())\\n                     first.insert(nums[j]);\\n                 }\\n                 else{\\n                     first.erase(nums[j]);\\n                     second.insert(nums[j]);\\n\\n                 }\\n\\n                 int len=(j-i+1);\\n                 len-=(first.size());\\n                 store[i][j]=len;\\n\\n             }\\n        }\\n\\n        memset(dp,-1,sizeof(dp));\\n\\n        return fun(0,0,nums,k,store);\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   long long dp[1001][1001];\\n\\n   long long fun(int i,int j,vector<int>&nums,int k,vector<vector<int>>&store){\\n       if(j>=nums.size()){\\n           if(i>=nums.size()) return 0;\\n           return 1e15+0;\\n       }\\n       if(dp[i][j]!=-1) return dp[i][j];\\nlong long ans=min(fun(i,j+1,nums,k,store),store[i][j]+k+fun(j+1,j+1,nums,k,store));\\n\\n     return dp[i][j]=ans;\\n\\n   }\\n\\n\\n\\n\\n\\n    int minCost(vector<int>& nums, int k) {\\n         int n=nums.size();\\n         vector<vector<int>>store(n,vector<int>(n,0));\\n\\n\\n\\n\\n\\n\\n        for(int i=0;i<nums.size();i++){\\n             unordered_set<int>first,second;\\n             for(int j=i;j<nums.size();j++){\\nif(first.find(nums[j])==first.end()){\\n                 if(second.find(nums[j])==second.end())\\n                     first.insert(nums[j]);\\n                 }\\n                 else{\\n                     first.erase(nums[j]);\\n                     second.insert(nums[j]);\\n\\n                 }\\n\\n                 int len=(j-i+1);\\n                 len-=(first.size());\\n                 store[i][j]=len;\\n\\n             }\\n        }\\n\\n        memset(dp,-1,sizeof(dp));\\n\\n        return fun(0,0,nums,k,store);\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867712,
                "title": "key-idea-of-dp-fully-explained",
                "content": "**Intuition**:\\nLets say ideal number of splits for `Array[0,n-1]` is three: `[[0,i], [i,j], [j,n-1]]`\\nWhat is the ideal split for `Array[0, j]`? It has to be `[[0,i], [i,j]]`\\nThis means we can combine our solution from smaller solutions\\n\\n**Solution:**\\nconsider each index `j` to be end of \"first split\",\\nso split `[i,j]` is first split for the solution of `Array[i,n-1]`\\n`j` can be anything in `[i,...,n-1]`\\n\\n\\n`sol(i) = min(cost(i,j) + sol(j+1) for j in [i,..,n-1])`\\n`sol(i) is the solution for Array[i,n-1]`\\n\\nWe are considering ever combination of \"first split\" so correct solutions is guranteed.\\n\\nThe recurrence formula above naturally leads to a DP solution.\\n\\n\\n**Recurssive Solution:\\nTime O(n^2)\\nSpace O(n) (counter gets destroyed after each loop)**\\n```\\ndef minCost(self, nums: List[int], k: int) -> int:\\n    n = len(nums)\\n\\n    @lru_cache(None)\\n    def importance(i):\\n        if i == n:\\n            return 0\\n        \\n        ans = inf\\n        c_cost = k\\n        counter = defaultdict(int)\\n        for j in range(i, n):\\n            if counter[nums[j]] >= 1:\\n                c_cost += 1\\n            c_cost += (counter[nums[j]] == 1)\\n            counter[nums[j]] += 1\\n            ans = min(ans, c_cost + importance(j+1))\\n        return ans\\n    \\n    return importance(0)\\n```\\n\\n**Iterative Solution:\\nTime O(n^2)\\nSpace O(n) (counter gets destroyed after loop finishes)**\\n```\\ndef minCost(self, nums: List[int], k: int) -> int:\\n    n = len(nums)\\n\\n    importance = [inf]*n + [0]\\n    for i in range(n-1, -1, -1):\\n        ans = inf\\n        c_cost = k\\n        counter = defaultdict(int)\\n        for j in range(i, n):\\n            if counter[nums[j]] >= 1:\\n                c_cost += 1\\n            c_cost += (counter[nums[j]]==1)\\n            counter[nums[j]] += 1\\n            ans = min(ans, c_cost + importance[j+1])\\n        importance[i] = ans\\n    \\n    return importance[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Dynamic Programming",
                    "Counting"
                ],
                "code": "```\\ndef minCost(self, nums: List[int], k: int) -> int:\\n    n = len(nums)\\n\\n    @lru_cache(None)\\n    def importance(i):\\n        if i == n:\\n            return 0\\n        \\n        ans = inf\\n        c_cost = k\\n        counter = defaultdict(int)\\n        for j in range(i, n):\\n            if counter[nums[j]] >= 1:\\n                c_cost += 1\\n            c_cost += (counter[nums[j]] == 1)\\n            counter[nums[j]] += 1\\n            ans = min(ans, c_cost + importance(j+1))\\n        return ans\\n    \\n    return importance(0)\\n```\n```\\ndef minCost(self, nums: List[int], k: int) -> int:\\n    n = len(nums)\\n\\n    importance = [inf]*n + [0]\\n    for i in range(n-1, -1, -1):\\n        ans = inf\\n        c_cost = k\\n        counter = defaultdict(int)\\n        for j in range(i, n):\\n            if counter[nums[j]] >= 1:\\n                c_cost += 1\\n            c_cost += (counter[nums[j]]==1)\\n            counter[nums[j]] += 1\\n            ans = min(ans, c_cost + importance[j+1])\\n        importance[i] = ans\\n    \\n    return importance[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3778493,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n;\\nint f(vector<int>& nums,vector<vector<int>>&a,int i,vector<int>&dp){\\n    if(i>=a.size())return 0;\\n    if(dp[i]!=-1)return dp[i];\\n    int c=1e9+1e9;\\n    for(int ind=i;ind<n;ind++){\\n        int t=a[i][ind]+f(nums,a,ind+1,dp);\\n        c=min(c,t);\\n    }\\n    return dp[i]= c;\\n}\\n    int minCost(vector<int>& nums, int k) {\\n       n=nums.size();\\n      // if(k==999999958)return 1000000613;\\n       vector<vector<int>>a(n,vector<int>(n,k)); \\n       for(int i=0;i<n;i++){\\n           vector<int>b(n+1,0);\\n           int s=0;\\n           for(int j=i;j<n;j++){\\n               b[nums[j]]++;\\n              if(b[nums[j]]==2)s+=2;\\n              else if(b[nums[j]]>2)s+=1;\\n\\n              a[i][j]+=s;\\n           }\\n          // return s;\\n       }\\n      vector<int>dp(n,-1);\\n       return f(nums,a,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n;\\nint f(vector<int>& nums,vector<vector<int>>&a,int i,vector<int>&dp){\\n    if(i>=a.size())return 0;\\n    if(dp[i]!=-1)return dp[i];\\n    int c=1e9+1e9;\\n    for(int ind=i;ind<n;ind++){\\n        int t=a[i][ind]+f(nums,a,ind+1,dp);\\n        c=min(c,t);\\n    }\\n    return dp[i]= c;\\n}\\n    int minCost(vector<int>& nums, int k) {\\n       n=nums.size();\\n      // if(k==999999958)return 1000000613;\\n       vector<vector<int>>a(n,vector<int>(n,k)); \\n       for(int i=0;i<n;i++){\\n           vector<int>b(n+1,0);\\n           int s=0;\\n           for(int j=i;j<n;j++){\\n               b[nums[j]]++;\\n              if(b[nums[j]]==2)s+=2;\\n              else if(b[nums[j]]>2)s+=1;\\n\\n              a[i][j]+=s;\\n           }\\n          // return s;\\n       }\\n      vector<int>dp(n,-1);\\n       return f(nums,a,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760537,
                "title": "easy-dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int k,int prev,int ind,vector<vector<int>> &dp,vector<vector<int>> &cost){\\n        int n = nums.size();\\n        if(ind==n-1){\\n            return k+cost[prev][ind];\\n        }\\n        if(dp[prev][ind]!=-1){\\n            return dp[prev][ind];\\n        }\\n        int take = k+cost[prev][ind] + solve(nums,k,ind+1,ind+1,dp,cost);\\n        int nottake = solve(nums,k,prev,ind+1,dp,cost);\\n        return dp[prev][ind] = min(take,nottake);\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        int n  =nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        vector<vector<int>> cost(n,vector<int>(n,0));\\n        for(int i = 0; i < n; i++){\\n            int ans=0;\\n            vector<int> v(n+1,0);\\n            for(int j=i;j<n;j++){\\n                v[nums[j]]++;\\n                if(v[nums[j]]==2){\\n                    ans+=2;\\n                }else if(v[nums[j]]>2){\\n                    ans++;\\n                }\\n                cost[i][j] = ans;\\n            }\\n        }\\n        return solve(nums,k,0,0,dp,cost);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int k,int prev,int ind,vector<vector<int>> &dp,vector<vector<int>> &cost){\\n        int n = nums.size();\\n        if(ind==n-1){\\n            return k+cost[prev][ind];\\n        }\\n        if(dp[prev][ind]!=-1){\\n            return dp[prev][ind];\\n        }\\n        int take = k+cost[prev][ind] + solve(nums,k,ind+1,ind+1,dp,cost);\\n        int nottake = solve(nums,k,prev,ind+1,dp,cost);\\n        return dp[prev][ind] = min(take,nottake);\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        int n  =nums.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        vector<vector<int>> cost(n,vector<int>(n,0));\\n        for(int i = 0; i < n; i++){\\n            int ans=0;\\n            vector<int> v(n+1,0);\\n            for(int j=i;j<n;j++){\\n                v[nums[j]]++;\\n                if(v[nums[j]]==2){\\n                    ans+=2;\\n                }else if(v[nums[j]]>2){\\n                    ans++;\\n                }\\n                cost[i][j] = ans;\\n            }\\n        }\\n        return solve(nums,k,0,0,dp,cost);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714933,
                "title": "python-recursion-simple",
                "content": "# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        m=len(nums)\\n\\n        @cache\\n        def dfs(ind):\\n            if ind>=m: return 0\\n            count=Counter(); val=0; ans=inf\\n            for i in range(ind, m):\\n                count[nums[i]] += 1\\n                if count[nums[i]] ==2: val+=2\\n                elif count[nums[i]]>2: val+=1\\n                ans=min(ans, dfs(i+1)+val+k) \\n            return ans\\n\\n        return dfs(0)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        m=len(nums)\\n\\n        @cache\\n        def dfs(ind):\\n            if ind>=m: return 0\\n            count=Counter(); val=0; ans=inf\\n            for i in range(ind, m):\\n                count[nums[i]] += 1\\n                if count[nums[i]] ==2: val+=2\\n                elif count[nums[i]]>2: val+=1\\n                ans=min(ans, dfs(i+1)+val+k) \\n            return ans\\n\\n        return dfs(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662141,
                "title": "98-3-in-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        length = len(nums)\\n        dp = [0] * (length + 1)\\n        for i in range(length):\\n            visited = [0] * length\\n            trimmed_count = 0\\n            min_cost = dp[i]\\n            visited[nums[i]] = 1\\n            for j in range(i - 1, -1, -1):\\n                n = nums[j]\\n                if visited[n] == 1:\\n                    trimmed_count += 2\\n                elif visited[n] >= 2:\\n                    trimmed_count += 1\\n                visited[n] += 1\\n                cost = dp[j] + trimmed_count\\n                if cost < min_cost:\\n                    min_cost = cost\\n            dp[i + 1] = k + min_cost\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        length = len(nums)\\n        dp = [0] * (length + 1)\\n        for i in range(length):\\n            visited = [0] * length\\n            trimmed_count = 0\\n            min_cost = dp[i]\\n            visited[nums[i]] = 1\\n            for j in range(i - 1, -1, -1):\\n                n = nums[j]\\n                if visited[n] == 1:\\n                    trimmed_count += 2\\n                elif visited[n] >= 2:\\n                    trimmed_count += 1\\n                visited[n] += 1\\n                cost = dp[j] + trimmed_count\\n                if cost < min_cost:\\n                    min_cost = cost\\n            dp[i + 1] = k + min_cost\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659201,
                "title": "clean-easy-to-understand-efficient-and-concise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDynamic programming! Let\\'s observe that $minCost(nums[0...j], k)$ can help solve $minCost(nums[0...i], k)$ where $i > j$. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to efficiently calculate the trimmed function. We can compute all values of trimmed for $nums[i : j]$ where $j >= i$. We do this in $O(n^2)$ with a nested for-loop and maintaining a HashMap. We can use these values in our DP relation! $dp[i] = min(k + dp[j] + notSingle[j][i-1])$ where $j < i$. **Note that $dp[0]$ represents an empty array which obviously has a cost of zero.** \\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$ from our 2D $notSingle$ array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int[][] notSingle = new int[nums.length][nums.length]; //notSingle[i][j] -> count of elements that occur more than once in subarray nums[i:j]\\n        for (int i = 0; i < nums.length; i++) {\\n            int nonSingleCnt = 0;\\n            HashMap<Integer,Integer> map = new HashMap<>();\\n            for (int j = i; j < nums.length; j++) {\\n                if(!map.containsKey(nums[j])) {\\n                    map.put(nums[j], 1);\\n                }\\n                else {\\n                    if(map.get(nums[j]) == 1) nonSingleCnt++; //add the initial element\\n                    map.put(nums[j], map.get(nums[j]) + 1);\\n                    nonSingleCnt++;\\n                }\\n                notSingle[i][j] = nonSingleCnt; //record count\\n            }\\n        }\\n        int[] dp = new int[nums.length+1]; //dp[i] -> min cost to split array just before index i\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        for (int i = 1; i < dp.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                //whats the cost if we split at index j\\n                dp[i] = Math.min(dp[i], k + dp[j] + notSingle[j][i - 1]);\\n            }\\n        }\\n        return dp[nums.length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int[][] notSingle = new int[nums.length][nums.length]; //notSingle[i][j] -> count of elements that occur more than once in subarray nums[i:j]\\n        for (int i = 0; i < nums.length; i++) {\\n            int nonSingleCnt = 0;\\n            HashMap<Integer,Integer> map = new HashMap<>();\\n            for (int j = i; j < nums.length; j++) {\\n                if(!map.containsKey(nums[j])) {\\n                    map.put(nums[j], 1);\\n                }\\n                else {\\n                    if(map.get(nums[j]) == 1) nonSingleCnt++; //add the initial element\\n                    map.put(nums[j], map.get(nums[j]) + 1);\\n                    nonSingleCnt++;\\n                }\\n                notSingle[i][j] = nonSingleCnt; //record count\\n            }\\n        }\\n        int[] dp = new int[nums.length+1]; //dp[i] -> min cost to split array just before index i\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        for (int i = 1; i < dp.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                //whats the cost if we split at index j\\n                dp[i] = Math.min(dp[i], k + dp[j] + notSingle[j][i - 1]);\\n            }\\n        }\\n        return dp[nums.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617762,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size() ;\\n        vector<int>dp(n, INT_MAX) ;\\n        \\n        for(int i = 0; i < n; i++){\\n            unordered_map<int, int>Map ;\\n            int score = 0 ;\\n            for(int j = i; j >= 0; j--){\\n                Map[nums[j]]++ ;\\n                if(Map[nums[j]] == 2)\\n                    score += 2 ;\\n                else if(Map[nums[j]] > 2)\\n                    score += 1 ;\\n                if(j >= 1)\\n                    dp[i] = min(dp[i], dp[j-1] + score + k) ;\\n                else\\n                    dp[i] = min(dp[i], score + k) ;\\n            }\\n        }\\n        return dp[n-1] ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size() ;\\n        vector<int>dp(n, INT_MAX) ;\\n        \\n        for(int i = 0; i < n; i++){\\n            unordered_map<int, int>Map ;\\n            int score = 0 ;\\n            for(int j = i; j >= 0; j--){\\n                Map[nums[j]]++ ;\\n                if(Map[nums[j]] == 2)\\n                    score += 2 ;\\n                else if(Map[nums[j]] > 2)\\n                    score += 1 ;\\n                if(j >= 1)\\n                    dp[i] = min(dp[i], dp[j-1] + score + k) ;\\n                else\\n                    dp[i] = min(dp[i], score + k) ;\\n            }\\n        }\\n        return dp[n-1] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543286,
                "title": "python-dynamic-programming-solution-beats-100",
                "content": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        length = len(nums)\\n        dp = [0] * (length + 1)\\n        for i in range(length):\\n            visited = [0] * length\\n            trimmed_count = 0\\n            min_cost = dp[i]\\n            visited[nums[i]] = 1\\n            for j in range(i - 1, -1, -1):\\n                n = nums[j]\\n                if visited[n] == 1:\\n                    trimmed_count += 2\\n                elif visited[n] >= 2:\\n                    trimmed_count += 1\\n                visited[n] += 1\\n                cost = dp[j] + trimmed_count\\n                if cost < min_cost:\\n                    min_cost = cost\\n            dp[i + 1] = k + min_cost\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        length = len(nums)\\n        dp = [0] * (length + 1)\\n        for i in range(length):\\n            visited = [0] * length\\n            trimmed_count = 0\\n            min_cost = dp[i]\\n            visited[nums[i]] = 1\\n            for j in range(i - 1, -1, -1):\\n                n = nums[j]\\n                if visited[n] == 1:\\n                    trimmed_count += 2\\n                elif visited[n] >= 2:\\n                    trimmed_count += 1\\n                visited[n] += 1\\n                cost = dp[j] + trimmed_count\\n                if cost < min_cost:\\n                    min_cost = cost\\n            dp[i + 1] = k + min_cost\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460995,
                "title": "java-solution-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n= nums.length;\\n        int dp[]=new int[n];\\n        Arrays.fill(dp,-1);\\n        int len[][] = new int[n][n];\\n        for(int r[]:len)Arrays.fill(r,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int count[]=new int[n];\\n            Arrays.fill(count,0);\\n            int c=0;\\n            for(int j=i;j<n;j++)\\n            {\\n                count[nums[j]]+=1;\\n                if(count[nums[j]]==2)c+=2;\\n                else if(count[nums[j]]>2)c+=1;\\n                len[i][j]=c;\\n            }\\n        }\\n        return f(0,nums,k,len,dp);\\n    }\\n    public int f(int ind,int nums[],int k,int len[][],int dp[])\\n    {\\n        if(ind >= nums.length)return 0;\\n        if(dp[ind]!=-1)return dp[ind];\\n        dp[ind]=Integer.MAX_VALUE;\\n        for(int i=ind;i<nums.length;i++)\\n        {\\n            int current = len[ind][i]+k;\\n            int next = f(i+1,nums,k,len,dp);\\n            dp[ind]=(int)Math.min(dp[ind],current+next);\\n        }\\n        return dp[ind];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n= nums.length;\\n        int dp[]=new int[n];\\n        Arrays.fill(dp,-1);\\n        int len[][] = new int[n][n];\\n        for(int r[]:len)Arrays.fill(r,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int count[]=new int[n];\\n            Arrays.fill(count,0);\\n            int c=0;\\n            for(int j=i;j<n;j++)\\n            {\\n                count[nums[j]]+=1;\\n                if(count[nums[j]]==2)c+=2;\\n                else if(count[nums[j]]>2)c+=1;\\n                len[i][j]=c;\\n            }\\n        }\\n        return f(0,nums,k,len,dp);\\n    }\\n    public int f(int ind,int nums[],int k,int len[][],int dp[])\\n    {\\n        if(ind >= nums.length)return 0;\\n        if(dp[ind]!=-1)return dp[ind];\\n        dp[ind]=Integer.MAX_VALUE;\\n        for(int i=ind;i<nums.length;i++)\\n        {\\n            int current = len[ind][i]+k;\\n            int next = f(i+1,nums,k,len,dp);\\n            dp[ind]=(int)Math.min(dp[ind],current+next);\\n        }\\n        return dp[ind];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438382,
                "title": "java-dp-hashmap-basic",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n=nums.length;\\n        int []dp=new int[n];\\n        Arrays.fill(dp,-1);\\n        return min(nums,k,dp,0);\\n    }\\n\\n    public int min(int []nums,int k,int []dp,int idx){\\n        if(idx==nums.length){\\n            return 0;\\n        }\\n\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int cnt=0;\\n       int cost=Integer.MAX_VALUE;\\n        for(int i=idx;i<nums.length;i++){\\n            int val=nums[i];\\n            if(map.containsKey(val)==false){\\n                cnt++;\\n                map.put(val,1);\\n            }\\n            else if(map.get(val)==1){\\n                cnt--;\\n                map.put(val,map.get(val)+1);\\n            }\\n           \\n            int single=cnt;\\n            int total=i-idx+1;\\n            cost=Math.min(cost,k+total-single+min(nums,k,dp,i+1));\\n            \\n\\n        }\\n        return dp[idx]=cost;\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int n=nums.length;\\n        int []dp=new int[n];\\n        Arrays.fill(dp,-1);\\n        return min(nums,k,dp,0);\\n    }\\n\\n    public int min(int []nums,int k,int []dp,int idx){\\n        if(idx==nums.length){\\n            return 0;\\n        }\\n\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int cnt=0;\\n       int cost=Integer.MAX_VALUE;\\n        for(int i=idx;i<nums.length;i++){\\n            int val=nums[i];\\n            if(map.containsKey(val)==false){\\n                cnt++;\\n                map.put(val,1);\\n            }\\n            else if(map.get(val)==1){\\n                cnt--;\\n                map.put(val,map.get(val)+1);\\n            }\\n           \\n            int single=cnt;\\n            int total=i-idx+1;\\n            cost=Math.min(cost,k+total-single+min(nums,k,dp,i+1));\\n            \\n\\n        }\\n        return dp[idx]=cost;\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373860,
                "title": "memoised-dp",
                "content": "\\n\\n# Code\\n```\\nint dp[1001][1001];\\nint solve(vector<int>&nums,int i,int j,int k){\\n    if(i>j)    return 0;\\n    if(dp[i][j]!=-1)    return dp[i][j];\\n    unordered_map<int,int>f;\\n    int size=0;\\n    int ans=INT_MAX;\\n    for(int x=i;x<=j;x++){\\n        if(f[nums[x]]==1)   size+=2;\\n        else if(f[nums[x]]>=2)  size+=1;\\n        f[nums[x]]+=1;\\n        ans=min(ans,k+size+solve(nums,x+1,j,k));\\n    }\\n    return dp[i][j]=ans;\\n}\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,0,nums.size()-1,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint dp[1001][1001];\\nint solve(vector<int>&nums,int i,int j,int k){\\n    if(i>j)    return 0;\\n    if(dp[i][j]!=-1)    return dp[i][j];\\n    unordered_map<int,int>f;\\n    int size=0;\\n    int ans=INT_MAX;\\n    for(int x=i;x<=j;x++){\\n        if(f[nums[x]]==1)   size+=2;\\n        else if(f[nums[x]]>=2)  size+=1;\\n        f[nums[x]]+=1;\\n        ans=min(ans,k+size+solve(nums,x+1,j,k));\\n    }\\n    return dp[i][j]=ans;\\n}\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,0,nums.size()-1,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178983,
                "title": "dp-i-min-dp-j-k-trim-nums-j-i-j-in-0-i-10-lines-python-bottom-up-dp",
                "content": "# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        dp = [math.inf] * (len(nums)+1)\\n        dp[0] = 0\\n        for i in range(1, len(nums)+1):\\n            d = collections.defaultdict(int)\\n            cnt = 0\\n            for j in range(i, 0, -1):\\n                d[nums[j-1]] += 1\\n                cnt += int(d[nums[j-1]] > 1) + int(d[nums[j-1]] == 2)\\n                dp[i] = min(dp[i], dp[j-1] + cnt + k)\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        dp = [math.inf] * (len(nums)+1)\\n        dp[0] = 0\\n        for i in range(1, len(nums)+1):\\n            d = collections.defaultdict(int)\\n            cnt = 0\\n            for j in range(i, 0, -1):\\n                d[nums[j-1]] += 1\\n                cnt += int(d[nums[j-1]] > 1) + int(d[nums[j-1]] == 2)\\n                dp[i] = min(dp[i], dp[j-1] + cnt + k)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153525,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minCost(const vector<int> &nums, const int k) {\\n    const int n = static_cast<int>(nums.size());\\n    int dp[n + 1];\\n    dp[0] = 0;\\n    for (int i = 1; i < n + 1; ++i) {\\n      dp[i] = numeric_limits<int>::max();\\n      unordered_map<int, int> num_to_count;\\n      int cost = 0;\\n      for (int j = i; j > 0; --j) {\\n        auto itr = num_to_count.find(nums[j - 1]);\\n        if (itr == num_to_count.end()) {\\n          itr = num_to_count.emplace(nums[j - 1], 0).first;\\n        }\\n        const int delta = ++itr->second;\\n        if (delta > 1) {\\n          cost += delta == 2 ? 2 : 1;\\n        }\\n        dp[i] = min(dp[i], dp[j - 1] + k + cost);\\n      }\\n    }\\n    return dp[n];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minCost(const vector<int> &nums, const int k) {\\n    const int n = static_cast<int>(nums.size());\\n    int dp[n + 1];\\n    dp[0] = 0;\\n    for (int i = 1; i < n + 1; ++i) {\\n      dp[i] = numeric_limits<int>::max();\\n      unordered_map<int, int> num_to_count;\\n      int cost = 0;\\n      for (int j = i; j > 0; --j) {\\n        auto itr = num_to_count.find(nums[j - 1]);\\n        if (itr == num_to_count.end()) {\\n          itr = num_to_count.emplace(nums[j - 1], 0).first;\\n        }\\n        const int delta = ++itr->second;\\n        if (delta > 1) {\\n          cost += delta == 2 ? 2 : 1;\\n        }\\n        dp[i] = min(dp[i], dp[j - 1] + k + cost);\\n      }\\n    }\\n    return dp[n];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146576,
                "title": "java-dp-bottom-up-beats-98-38-ms",
                "content": "# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int[] dp = new int[nums.length + 1];\\n        for (int startPos = nums.length - 1; startPos >= 0; startPos--) {\\n            dp[startPos] = Integer.MAX_VALUE;\\n            int[] freq = new int[nums.length + 1];\\n            int nRepeated = 0;\\n            for(int pos = startPos; pos < nums.length; pos++) {\\n                int curNum = nums[pos];\\n                if (freq[curNum] == 1) {\\n                    nRepeated += 2;\\n                } else if(freq[curNum] > 0) {\\n                    nRepeated++;\\n                }\\n                freq[curNum]++;\\n                dp[startPos] = Math.min(dp[startPos], k + nRepeated + dp[pos + 1]);\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int[] dp = new int[nums.length + 1];\\n        for (int startPos = nums.length - 1; startPos >= 0; startPos--) {\\n            dp[startPos] = Integer.MAX_VALUE;\\n            int[] freq = new int[nums.length + 1];\\n            int nRepeated = 0;\\n            for(int pos = startPos; pos < nums.length; pos++) {\\n                int curNum = nums[pos];\\n                if (freq[curNum] == 1) {\\n                    nRepeated += 2;\\n                } else if(freq[curNum] > 0) {\\n                    nRepeated++;\\n                }\\n                freq[curNum]++;\\n                dp[startPos] = Math.min(dp[startPos], k + nRepeated + dp[pos + 1]);\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144448,
                "title": "c-recursive-dp-precompute-trim-dp-memoisation-beginners-friendly-code",
                "content": "![image](https://assets.leetcode.com/users/images/a8e4cabf-509b-42c0-b757-a88dce63d174_1675576340.5439298.png)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> trimDP;\\n    vector<int> dp;\\n    \\n    int helper(vector<int> &nums, int curr, int k){\\n        if(curr==nums.size()){\\n            return 0;\\n        }\\n        if(dp[curr]!=-1){\\n            return dp[curr];\\n        }\\n        int res=INT_MAX;\\n        for(int i=curr;i<nums.size();i++){\\n            int trimmedLen=trimDP[curr][i];\\n            res=min(res,k+trimmedLen+helper(nums,i+1,k));\\n        }\\n        return dp[curr]=res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        trimDP.resize(n,vector<int>(n,0));\\n        dp.resize(n,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            int dirt=0;\\n            int freq[1000]={0};\\n            int unique=0;\\n            for(int j=i;j<n;j++){\\n                freq[nums[j]]++;\\n                if(freq[nums[j]]==1){\\n                    unique++;\\n                }\\n                if(freq[nums[j]]==2){\\n                    dirt++;\\n                }\\n                int totalLen=j-i+1;\\n                trimDP[i][j]=totalLen-unique+dirt;\\n            }\\n        }\\n        \\n        return helper(nums,0,k);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> trimDP;\\n    vector<int> dp;\\n    \\n    int helper(vector<int> &nums, int curr, int k){\\n        if(curr==nums.size()){\\n            return 0;\\n        }\\n        if(dp[curr]!=-1){\\n            return dp[curr];\\n        }\\n        int res=INT_MAX;\\n        for(int i=curr;i<nums.size();i++){\\n            int trimmedLen=trimDP[curr][i];\\n            res=min(res,k+trimmedLen+helper(nums,i+1,k));\\n        }\\n        return dp[curr]=res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        trimDP.resize(n,vector<int>(n,0));\\n        dp.resize(n,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            int dirt=0;\\n            int freq[1000]={0};\\n            int unique=0;\\n            for(int j=i;j<n;j++){\\n                freq[nums[j]]++;\\n                if(freq[nums[j]]==1){\\n                    unique++;\\n                }\\n                if(freq[nums[j]]==2){\\n                    dirt++;\\n                }\\n                int totalLen=j-i+1;\\n                trimDP[i][j]=totalLen-unique+dirt;\\n            }\\n        }\\n        \\n        return helper(nums,0,k);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126660,
                "title": "dp-python",
                "content": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        \\n        dp = [float(\"inf\") for i in range(len(nums))]\\n        dp[-1] = k\\n        for i in range(len(nums)-2,-1,-1):\\n            hashset = set()\\n            hashmap = {}\\n            hashset.add(nums[i])\\n            hashmap[nums[i]] = True\\n            dp[i] = k+ dp[i+1]\\n            for j in range(i+1,len(nums)):\\n                \\n                \\n                \\n                if nums[j] in hashmap.keys():\\n                    if nums[j] in hashset:\\n                        hashset.remove(nums[j])\\n\\n                elif nums[j] not in hashmap.keys():\\n                    hashset.add(nums[j])\\n                    hashmap[nums[j]] = True\\n\\n                x = 0 if j+1 >= len(nums) else dp[j+1]\\n                dp[i] = min(dp[i],k+j-i+1-len(hashset)+x)\\n\\n        \\n        return  dp[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        \\n        dp = [float(\"inf\") for i in range(len(nums))]\\n        dp[-1] = k\\n        for i in range(len(nums)-2,-1,-1):\\n            hashset = set()\\n            hashmap = {}\\n            hashset.add(nums[i])\\n            hashmap[nums[i]] = True\\n            dp[i] = k+ dp[i+1]\\n            for j in range(i+1,len(nums)):\\n                \\n                \\n                \\n                if nums[j] in hashmap.keys():\\n                    if nums[j] in hashset:\\n                        hashset.remove(nums[j])\\n\\n                elif nums[j] not in hashmap.keys():\\n                    hashset.add(nums[j])\\n                    hashmap[nums[j]] = True\\n\\n                x = 0 if j+1 >= len(nums) else dp[j+1]\\n                dp[i] = min(dp[i],k+j-i+1-len(hashset)+x)\\n\\n        \\n        return  dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126464,
                "title": "python3-o-n-2-precompute-trimmed-array-length-and-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a dict to precompute all trimmed array length.\\ndp[r] is the min cost to split array nums[0...r],\\ndp[r] = min{trimmed[l + 1][r] + k + dp[l] for l in range(r)}.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nPrecompute is O(n^2), DP is O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        trimmed = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            cost, cnt = 0, {nums[i] : 1}\\n            for j in range(i + 1, n):\\n                if nums[j] not in cnt: cnt[nums[j]] = 1\\n                else: cnt[nums[j]] += 1\\n                if cnt[nums[j]] == 2: cost += 2\\n                elif cnt[nums[j]] > 2: cost += 1\\n                trimmed[i][j] = cost\\n        @lru_cache(None)\\n        def dp(r):\\n            ret = trimmed[0][r] + k\\n            for l in range(r): ret = min(ret, trimmed[l + 1][r] + k + dp(l))\\n            return ret\\n        return dp(n - 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        trimmed = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            cost, cnt = 0, {nums[i] : 1}\\n            for j in range(i + 1, n):\\n                if nums[j] not in cnt: cnt[nums[j]] = 1\\n                else: cnt[nums[j]] += 1\\n                if cnt[nums[j]] == 2: cost += 2\\n                elif cnt[nums[j]] > 2: cost += 1\\n                trimmed[i][j] = cost\\n        @lru_cache(None)\\n        def dp(r):\\n            ret = trimmed[0][r] + k\\n            for l in range(r): ret = min(ret, trimmed[l + 1][r] + k + dp(l))\\n            return ret\\n        return dp(n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113330,
                "title": "top-down-memoization-precomputation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe use dp to split our array into subgroups . but to find the score we need to compute the given subarray . splitting array into different subgroups already takes O(n^2) time , computing the score takes O(n) time , combined this method would take O(n^3) time which would give tle under the given constarints .\\nso we precompute the score of each subarray possible .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n we precompute the score from a subarray and then use dp to divide the array into subarrays and finding the minimum score of them.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint solve(vector<int>& nums,int idx, int last,int &n,vector<vector<int>>&dp,vector<vector<int>>&range){\\nif(idx==n){\\n    return range[last][n-1];\\n}\\nif(dp[idx][last]!=-1)\\nreturn dp[idx][last];\\nint l=INT_MAX;\\n\\nint r=INT_MAX;\\n// end segment\\nl= range[last][idx-1]+ solve(nums,idx+1,idx,n,dp,range);\\n\\nr=solve(nums,idx+1,last,n,dp,range);\\n\\nreturn dp[idx][last]= min(l,r);\\n}\\n\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        vector<vector<int>>dp(n,vector<int>(n+1,-1));\\n        vector<vector<int>>range(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            int mp[1004];\\n            int count=0;\\n            memset(mp,0,sizeof(mp));\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n                if(mp[nums[j]]>=2)\\n                {\\n                    if(mp[nums[j]]==2)\\n                    {\\n                        count+=2;\\n                    }\\n                    else\\n                    {\\n                        count++;\\n                    }\\n                }\\n                range[i][j]=count+k;\\n            }\\n        }\\n        return solve(nums,1,0,n,dp,range);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint solve(vector<int>& nums,int idx, int last,int &n,vector<vector<int>>&dp,vector<vector<int>>&range){\\nif(idx==n){\\n    return range[last][n-1];\\n}\\nif(dp[idx][last]!=-1)\\nreturn dp[idx][last];\\nint l=INT_MAX;\\n\\nint r=INT_MAX;\\n// end segment\\nl= range[last][idx-1]+ solve(nums,idx+1,idx,n,dp,range);\\n\\nr=solve(nums,idx+1,last,n,dp,range);\\n\\nreturn dp[idx][last]= min(l,r);\\n}\\n\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        vector<vector<int>>dp(n,vector<int>(n+1,-1));\\n        vector<vector<int>>range(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            int mp[1004];\\n            int count=0;\\n            memset(mp,0,sizeof(mp));\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n                if(mp[nums[j]]>=2)\\n                {\\n                    if(mp[nums[j]]==2)\\n                    {\\n                        count+=2;\\n                    }\\n                    else\\n                    {\\n                        count++;\\n                    }\\n                }\\n                range[i][j]=count+k;\\n            }\\n        }\\n        return solve(nums,1,0,n,dp,range);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112525,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums, k):\\n        n = len(nums)\\n\\n        @lru_cache(None)\\n        def dfs(i):\\n            if i >= n:\\n                return 0\\n\\n            min_val = float(\"inf\")\\n\\n            total, dict1 = 0, collections.defaultdict(int)\\n\\n            for j in range(i,n):\\n                dict1[nums[j]] += 1\\n\\n                if dict1[nums[j]] == 2:\\n                    total += 2\\n                elif dict1[nums[j]] > 1:\\n                    total += 1\\n\\n                min_val = min(min_val,k + total + dfs(j+1))\\n\\n            return min_val\\n\\n        return dfs(0)\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums, k):\\n        n = len(nums)\\n\\n        @lru_cache(None)\\n        def dfs(i):\\n            if i >= n:\\n                return 0\\n\\n            min_val = float(\"inf\")\\n\\n            total, dict1 = 0, collections.defaultdict(int)\\n\\n            for j in range(i,n):\\n                dict1[nums[j]] += 1\\n\\n                if dict1[nums[j]] == 2:\\n                    total += 2\\n                elif dict1[nums[j]] > 1:\\n                    total += 1\\n\\n                min_val = min(min_val,k + total + dfs(j+1))\\n\\n            return min_val\\n\\n        return dfs(0)\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110134,
                "title": "java-dp",
                "content": "```\\npublic int minCost(int[] nums, int k) {\\n        int l = nums.length;\\n        int[] dp = new int[l];\\n        dp[0] = k;\\n        for(int i=1; i<l; i++){\\n            dp[i] = k+dp[i-1];\\n            int cur = 0;\\n            int[] arr = new int[l+1];\\n            arr[nums[i]] = 1;\\n            for(int j=i-1; j>=0; j--){\\n                arr[nums[j]]+=1;\\n                if(arr[nums[j]]==2)\\n                    cur+=2;\\n                else if(arr[nums[j]]>2)\\n                    cur+=1;\\n                dp[i] = Math.min(dp[i], (j>0?dp[j-1]:0)+k+cur);\\n            }\\n        }\\n        return dp[l-1];\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int minCost(int[] nums, int k) {\\n        int l = nums.length;\\n        int[] dp = new int[l];\\n        dp[0] = k;\\n        for(int i=1; i<l; i++){\\n            dp[i] = k+dp[i-1];\\n            int cur = 0;\\n            int[] arr = new int[l+1];\\n            arr[nums[i]] = 1;\\n            for(int j=i-1; j>=0; j--){\\n                arr[nums[j]]+=1;\\n                if(arr[nums[j]]==2)\\n                    cur+=2;\\n                else if(arr[nums[j]]>2)\\n                    cur+=1;\\n                dp[i] = Math.min(dp[i], (j>0?dp[j-1]:0)+k+cur);\\n            }\\n        }\\n        return dp[l-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3108801,
                "title": "python3-dp-with-explanation-and-thoughts",
                "content": "**Approach: DP**\\n\\n(Idea taken from [here](https://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3084509/c-java-python-easy-dp/?orderBy=most_votes)).\\n* `dp[j]` represents the minimum cost to split `nums[:j]`.\\n* Computing `dp[j]`:\\n\\t* In determining the best split for `nums[:j]`, we focus on determining the last subarray, `nums[i:j]`, in the split. (for `i` from `j-1` *down to* `1`)\\n\\t\\t* For a particular value of `i`, we already have `dp[i]`-- the minimum cost to split `nums[:i]`.\\n\\t\\t* Note that `dp[i]` is itself the sum of importance values of some subarrays that comprise a split of `nums[:i]` (Let\\'s denote the split (a collection of those subarrays) as `I`.)\\n\\t* We need to determine that `i` such that the importance value of `nums[i:j]` when added to `dp[i]` results in the minimum cost to split `nums[:j]`.\\n\\t* When such an `i` is found, the split `I` along with `nums[i:j]` forms a split of `nums[:j]` the cost of which is minimum.\\n* Initialization of `dp`:\\n\\t* Although, it\\'s a given constraint that `n >= 1`, what we store in `dp[0]` is important. We must initialize `dp[0]` with `0`. (Trace the program for `n = 1`, to see why. (Note that when `n = 1`, the output, `dp[1]`, must be `k`.))\\n\\t* The other elements are simply initialized with a large enough value so that `cur < dp[i]` initially.\\n\\t\\t* Side note: the answer can be atmost `n+k`. So, we could\\'ve initialized them with `n+k+1`.\\n* `Importance_value(nums[i:j]) = k + (j-i) - remove`\\n\\t* `remove` represents the number of elements removed in `nums[i:j]` because they appear only once in it.\\n\\t* When an element appears the first time, we assume it\\'ll appear exactly once. So, remove it. `remove += 1`\\n\\t* If it appears again, we were wrong in our assumption. So, put it back. `remove -= 1`\\n* `freq` computes the frequency of an element in a subarray.\\n\\t* It has to be reinitialized each time because the frequency of an element can change depending on the subarray under consideration.\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0] + [float(\\'inf\\')]*n\\n        for j in range(1, n+1):\\n            freq = defaultdict(int)\\n            remove = 0\\n            for i in range(j-1, -1, -1):\\n                remove += (freq[nums[i]] == 0) - (freq[nums[i]] == 1)\\n                freq[nums[i]] += 1\\n                cur = dp[i] + (k + j-i - remove)\\n                if cur < dp[j]: dp[j] = cur\\n\\n        return dp[n]\\n```\\n\\n* I thought it would be saving time and, more importantly, space to declare `freq` as dictionary.\\n* But it turns out declaring it as a list is better!\\n* We can declare it as a list of `len(nums)` elements because we\\'re given the constraint that `nums[i] < len(nums)`\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0] + [float(\\'inf\\')]*n\\n        for j in range(1, n+1):\\n            freq = [0]*n\\n            remove = 0\\n            for i in range(j-1, -1, -1):\\n                remove += (freq[nums[i]] == 0) - (freq[nums[i]] == 1)\\n                freq[nums[i]] += 1\\n                cur = dp[i] + (k + j-i - remove)\\n                if cur < dp[j]: dp[j] = cur\\n\\n        return dp[n]\\n```\\n* Initially, when I was still trying to understand the problem, I wondered why was `k` given at all.\\n\\t* Imagine if `k` weren\\'t there, or, equivalently, that `k = 0`.\\n\\t* Then, we could simply consider the split where each element of `nums` comprises a single-element subarray.\\n\\t* The cost of this split is 0.\\n\\t* Obviously, that must be the minimum cost among all possible splits.",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0] + [float(\\'inf\\')]*n\\n        for j in range(1, n+1):\\n            freq = defaultdict(int)\\n            remove = 0\\n            for i in range(j-1, -1, -1):\\n                remove += (freq[nums[i]] == 0) - (freq[nums[i]] == 1)\\n                freq[nums[i]] += 1\\n                cur = dp[i] + (k + j-i - remove)\\n                if cur < dp[j]: dp[j] = cur\\n\\n        return dp[n]\\n```\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0] + [float(\\'inf\\')]*n\\n        for j in range(1, n+1):\\n            freq = [0]*n\\n            remove = 0\\n            for i in range(j-1, -1, -1):\\n                remove += (freq[nums[i]] == 0) - (freq[nums[i]] == 1)\\n                freq[nums[i]] += 1\\n                cur = dp[i] + (k + j-i - remove)\\n                if cur < dp[j]: dp[j] = cur\\n\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107587,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n+1, k+n+1);\\n        dp[0] = 0;\\n        for (int j = 1; j <= n; ++j) {\\n            vector<int> mp(n+1, 0);\\n            int rm = 0;\\n            for (int i = j; i >= 1; --i) {\\n                rm += (mp[nums[i-1]] == 0) - (mp[nums[i-1]] == 1);\\n                mp[nums[i-1]]++;\\n                dp[j] = min(dp[j], dp[i-1] + k + j - i + 1 - rm);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n+1, k+n+1);\\n        dp[0] = 0;\\n        for (int j = 1; j <= n; ++j) {\\n            vector<int> mp(n+1, 0);\\n            int rm = 0;\\n            for (int i = j; i >= 1; --i) {\\n                rm += (mp[nums[i-1]] == 0) - (mp[nums[i-1]] == 1);\\n                mp[nums[i-1]]++;\\n                dp[j] = min(dp[j], dp[i-1] + k + j - i + 1 - rm);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107133,
                "title": "python3-simple-dp-with-greedy-optimization-faster-than-98",
                "content": "This follows the basic idea of dynamic programming. One very important optimization heuristic used here is that:\\nwhen we include a new elem in our current partition, if the cost doesn\\'t change, then this current plan must be better than previous one. In other words, as long as the new elem is different from others, we should make our current partition as large as possible. \\nFor implementation, I only make a recursive call when the cost changes.\\nThis optimization changes the running time from 7700ms to 2800ms at my end.\\n\\n\\n```python\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        \\n        @cache\\n        def dfs(i):\\n            if i >= n:\\n                return 0\\n            \\n            \\n            cnt = defaultdict(int)\\n            cost = k\\n            res = inf\\n            \\n            for j in range(i,n):\\n                prev_cost = cost\\n                v = nums[j]\\n                cnt[v] += 1\\n                \\n                if cnt[v] == 2:\\n                    cost += 2\\n                elif cnt[v] > 2:\\n                    cost += 1\\n                \\n\\t\\t\\t\\t# if the cost changes, we try previous configuration, make this j as part of new array\\n                if cost > prev_cost:\\n                    res = min(res, prev_cost + dfs(j))\\n                    \\n            res = min(res, cost)\\n            return res \\n        \\n        return dfs(0)\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        \\n        @cache\\n        def dfs(i):\\n            if i >= n:\\n                return 0\\n            \\n            \\n            cnt = defaultdict(int)\\n            cost = k\\n            res = inf\\n            \\n            for j in range(i,n):\\n                prev_cost = cost\\n                v = nums[j]\\n                cnt[v] += 1\\n                \\n                if cnt[v] == 2:\\n                    cost += 2\\n                elif cnt[v] > 2:\\n                    cost += 1\\n                \\n\\t\\t\\t\\t# if the cost changes, we try previous configuration, make this j as part of new array\\n                if cost > prev_cost:\\n                    res = min(res, prev_cost + dfs(j))\\n                    \\n            res = min(res, cost)\\n            return res \\n        \\n        return dfs(0)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106436,
                "title": "c-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrecalculate the trimmed length for each subarray in $$O(n^2)$$ time and space complexity.\\nThen use the standard dp technique to try out all possible ways and find the minimum value.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        // trimmed length\\n        vector<vector<int>> trl(n, vector<int>(n, 0));\\n        for(int i = 0; i < n; i++) {\\n            vector<int> mp(n, 0);\\n            int unique = 0;\\n            for(int j = i; j < n; j++) {\\n                int num = nums[j];\\n                if(mp[num] == 1) \\n                    unique -= 1;\\n                else if(mp[num] == 0) \\n                    unique += 1;\\n\\n                mp[num] += 1;\\n                trl[i][j] = (j-i+1) - unique;\\n            }\\n        }\\n\\n        // for(int i = 0; i < n; i++) {\\n        //     for(int j = 0; j < n; j++) \\n        //         cout << trl[i][j] << \" \";\\n        //     cout << endl;\\n        // }\\n\\n        vector<int> dp(n, INT_MAX);\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i; j < n; j++) {\\n                if(i == 0)\\n                    dp[j] = min(dp[j], k+trl[i][j]);\\n                else \\n                    dp[j] = min(dp[j], k+trl[i][j]+dp[i-1]);\\n            } \\n        }\\n\\n        return dp[n-1];\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        // trimmed length\\n        vector<vector<int>> trl(n, vector<int>(n, 0));\\n        for(int i = 0; i < n; i++) {\\n            vector<int> mp(n, 0);\\n            int unique = 0;\\n            for(int j = i; j < n; j++) {\\n                int num = nums[j];\\n                if(mp[num] == 1) \\n                    unique -= 1;\\n                else if(mp[num] == 0) \\n                    unique += 1;\\n\\n                mp[num] += 1;\\n                trl[i][j] = (j-i+1) - unique;\\n            }\\n        }\\n\\n        // for(int i = 0; i < n; i++) {\\n        //     for(int j = 0; j < n; j++) \\n        //         cout << trl[i][j] << \" \";\\n        //     cout << endl;\\n        // }\\n\\n        vector<int> dp(n, INT_MAX);\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i; j < n; j++) {\\n                if(i == 0)\\n                    dp[j] = min(dp[j], k+trl[i][j]);\\n                else \\n                    dp[j] = min(dp[j], k+trl[i][j]+dp[i-1]);\\n            } \\n        }\\n\\n        return dp[n-1];\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3103238,
                "title": "dp-beats-94-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s understand this with the example of an array:\\n\\n- [1,2,1,2,1,2], k=1. Now what could be the minimum cost ? There are many ways in which this array could be split. Some of them are:\\n   - [1,2] + [1,2,1,2], cost = 2 * 1(k) + 0 (left split) + 4 (right split) = 6\\n   - [1,2,1,2] + [1,2], cost = 2 * 1(k) + 4 (left split) + 0 (right split) = 6\\n   - [1,2,1] + [2,1,2], cost = 2 * 1(k) + 2 (left split) + 2 (right split) = 6\\n   - $$[1,2] + [1,2] + [1,2], cost = 3 * 1(k) + 0 + 0 + 0 = 3$$\\n   - [1,2,1,2,1] + [2], cost = 2 * 1(k) + 5 (left split) + 0 (right split) = 7\\n   - etc...\\nAs you can see, the fourth case has minimum value when compared to all others.\\n\\nLets deal with the same array with k=5\\n- [1,2] + [1,2] + [1,2], cost = 15\\n- [1,2,1,2] + [1,2], cost = 14\\n- [1,2,1] + [2,1,2], cost = 14\\n- etc...\\n\\nThe test case that yeilded minimum value with k=1 is yeilding maximum with k=5. Hence, the minium cost value not only changes with the contents of the array but also k.\\n\\nThe minimum cost is dependent on 3 factors:\\n- splits made.\\n- Value of the K.\\n- No. of duplicates in each split.\\n\\nThe best thing can be done is to try out all possible cases and come up with the best case. i.e. Dynamic programming.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- Iterate the array from the start, once the duplicate element is found, there are two possible cases:\\n    - Split the array to 2 parts.\\n    - Do not split it and continue ignoring the dupliate value\\n\\nDo the above 2 operators for each duplicate.\\n\\ncost = min(cost upon splitting, cost without splitting)\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2) in the worst case.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        cc, hh = {}, {}\\n        # Mapping all elements to their frequencies.\\n        for i in nums:\\n            cc[i] = cc.get(i, 0) + 1\\n\\n        def dp(ind):\\n            # dp function to get minimum cost.\\n            if ind in hh: \\n                # if cost already calculated for index, return the cost.\\n                return hh[ind]\\n            hm, l, cos = {}, 0, float(\\'inf\\')\\n            for i in range(ind, len(nums)):\\n                if nums[i] in hm:\\n                    # if duplicate element found split it and find the cost.\\n                    cos = min(cos, k + l + dp(i))\\n                    l = l+2 if hm[nums[i]] == 1 else l+1\\n                    hm[nums[i]] += 1\\n                else:\\n                    hm[nums[i]] = 1\\n            # get minimum cost of splitting and not splitting.\\n            hh[ind] = min(cos, l) if ind != 0 else cos\\n            return hh[ind]\\n        # return minimum cost of splitting and not splitting.\\n        return k + min(dp(0), sum([cc[i] for i in cc.keys() if cc[i] > 1]))\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        cc, hh = {}, {}\\n        # Mapping all elements to their frequencies.\\n        for i in nums:\\n            cc[i] = cc.get(i, 0) + 1\\n\\n        def dp(ind):\\n            # dp function to get minimum cost.\\n            if ind in hh: \\n                # if cost already calculated for index, return the cost.\\n                return hh[ind]\\n            hm, l, cos = {}, 0, float(\\'inf\\')\\n            for i in range(ind, len(nums)):\\n                if nums[i] in hm:\\n                    # if duplicate element found split it and find the cost.\\n                    cos = min(cos, k + l + dp(i))\\n                    l = l+2 if hm[nums[i]] == 1 else l+1\\n                    hm[nums[i]] += 1\\n                else:\\n                    hm[nums[i]] = 1\\n            # get minimum cost of splitting and not splitting.\\n            hh[ind] = min(cos, l) if ind != 0 else cos\\n            return hh[ind]\\n        # return minimum cost of splitting and not splitting.\\n        return k + min(dp(0), sum([cc[i] for i in cc.keys() if cc[i] > 1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102695,
                "title": "partition-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<int>&nums,int k,vector<vector<int>>&dp){\\n        if(i>=(nums.size())){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int mini=INT_MAX;\\n        \\n         vector<int>mp(10001,0);\\n            int cnt=0;\\n        for(int p=i;p<=(j);p++){\\n           \\n            \\n            mp[nums[p]]++;\\n            if(mp[nums[p]]>2){\\n                cnt+=1;\\n            }\\n            if(mp[nums[p]]==2){\\n                cnt+=2;\\n            }\\n            int ans=cnt+k+solve(p+1,j,nums,k,dp);\\n            mini=min(mini,ans);\\n            \\n        }\\n        return dp[i][j]=mini;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return solve(0,n-1,nums,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<int>&nums,int k,vector<vector<int>>&dp){\\n        if(i>=(nums.size())){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int mini=INT_MAX;\\n        \\n         vector<int>mp(10001,0);\\n            int cnt=0;\\n        for(int p=i;p<=(j);p++){\\n           \\n            \\n            mp[nums[p]]++;\\n            if(mp[nums[p]]>2){\\n                cnt+=1;\\n            }\\n            if(mp[nums[p]]==2){\\n                cnt+=2;\\n            }\\n            int ans=cnt+k+solve(p+1,j,nums,k,dp);\\n            mini=min(mini,ans);\\n            \\n        }\\n        return dp[i][j]=mini;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return solve(0,n-1,nums,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099363,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\ncount function will have time complexity log(n)\\ntotal time complexity will be O(n^2 log n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector <int> dp(n , INT_MAX );\\n        dp[0] = k;\\n        for(int r = 1 ; r < n ; r++){\\n            int value = k;\\n            map <int , int> mp;\\n            for(int l = r; l >= 0 ; l--){\\n                if(mp.count(nums[l])){\\n                    if(mp[nums[l]] >= 2) value++;\\n                    else if(mp[nums[l]] == 1)value+=2;\\n                }\\n            mp[nums[l]]++;\\n            if(l == 0){\\n                dp[r] = min(dp[r] , value);\\n            }\\n            else\\n            dp[r] = min(dp[r] , dp[l-1] + value);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector <int> dp(n , INT_MAX );\\n        dp[0] = k;\\n        for(int r = 1 ; r < n ; r++){\\n            int value = k;\\n            map <int , int> mp;\\n            for(int l = r; l >= 0 ; l--){\\n                if(mp.count(nums[l])){\\n                    if(mp[nums[l]] >= 2) value++;\\n                    else if(mp[nums[l]] == 1)value+=2;\\n                }\\n            mp[nums[l]]++;\\n            if(l == 0){\\n                dp[r] = min(dp[r] , value);\\n            }\\n            else\\n            dp[r] = min(dp[r] , dp[l-1] + value);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099324,
                "title": "python-dynamic-programming-o-n2-beats-95",
                "content": "# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        \\n        dp = [0]*(len(nums)+1)\\n        \\n        # Assuming new elements are added at the starting postion of the array\\n        for i in range(len(nums)-1,-1,-1):\\n            count_di = defaultdict(int)\\n            ans = 10**10\\n\\n            left_sub_cost = 0\\n\\n            for j in range(i,len(nums)):\\n                count_di[nums[j]] +=1\\n\\n                if count_di[nums[j]] == 2:\\n                    left_sub_cost += 2\\n                elif count_di[nums[j]] > 2:\\n                    left_sub_cost += 1\\n\\n                cost = left_sub_cost + k\\n\\n                ans = min(cost+dp[j+1],ans)\\n\\n            dp[i] = ans\\n\\n        return dp[0]       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        \\n        dp = [0]*(len(nums)+1)\\n        \\n        # Assuming new elements are added at the starting postion of the array\\n        for i in range(len(nums)-1,-1,-1):\\n            count_di = defaultdict(int)\\n            ans = 10**10\\n\\n            left_sub_cost = 0\\n\\n            for j in range(i,len(nums)):\\n                count_di[nums[j]] +=1\\n\\n                if count_di[nums[j]] == 2:\\n                    left_sub_cost += 2\\n                elif count_di[nums[j]] > 2:\\n                    left_sub_cost += 1\\n\\n                cost = left_sub_cost + k\\n\\n                ans = min(cost+dp[j+1],ans)\\n\\n            dp[i] = ans\\n\\n        return dp[0]       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099205,
                "title": "dp-top-down",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe try to partition every possible subarray and get the minimum answer\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`sum` will keep track the size of the repeated elements.\\nMemoization to cache the minimum answer at index i\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mem[1001]{};\\n    int k;\\npublic:\\n    int partition(vector<int>& nums, int idx){\\n        if(idx >= nums.size()) return 0;\\n        auto& ret = mem[idx];\\n        if(ret != -1) return ret;\\n        unordered_map<int, int> freq{};\\n        int ans = INT_MAX;\\n        int sum = 0;\\n        for(int i = idx; i < nums.size(); ++i){\\n            auto& numFreq = freq[nums[i]];\\n            ++numFreq;\\n            if(numFreq > 1) sum += (numFreq == 2) ? 2 : 1;\\n            ans = min(ans, sum + k + partition(nums, i+1));\\n        }\\n        return ret = ans;\\n    }\\n    int minCost(vector<int>& nums, int _k) {\\n        memset(mem, -1, sizeof mem);\\n        k = _k;\\n        return partition(nums, 0);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mem[1001]{};\\n    int k;\\npublic:\\n    int partition(vector<int>& nums, int idx){\\n        if(idx >= nums.size()) return 0;\\n        auto& ret = mem[idx];\\n        if(ret != -1) return ret;\\n        unordered_map<int, int> freq{};\\n        int ans = INT_MAX;\\n        int sum = 0;\\n        for(int i = idx; i < nums.size(); ++i){\\n            auto& numFreq = freq[nums[i]];\\n            ++numFreq;\\n            if(numFreq > 1) sum += (numFreq == 2) ? 2 : 1;\\n            ans = min(ans, sum + k + partition(nums, i+1));\\n        }\\n        return ret = ans;\\n    }\\n    int minCost(vector<int>& nums, int _k) {\\n        memset(mem, -1, sizeof mem);\\n        k = _k;\\n        return partition(nums, 0);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097680,
                "title": "c-dfs-memo",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = size(nums), dp[1000];\\n        fill(dp, dp+n, -1);\\n        function<int(int)> dfs = [&] (int i) {\\n            if (i == n)\\n                return 0;\\n            if (dp[i] != -1)\\n                return dp[i];\\n            int mn = n, t = 0;\\n            vector<int> cnt(n);\\n            for (int j = i; j < n; j++) {\\n                int &v = ++cnt[nums[j]];\\n                if (v > 2)\\n                    t++;\\n                else if (v == 2)\\n                    t += 2;\\n                mn = min(mn, t + dfs(j+1));\\n            }\\n            return dp[i] = mn + k;\\n        };\\n        return dfs(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = size(nums), dp[1000];\\n        fill(dp, dp+n, -1);\\n        function<int(int)> dfs = [&] (int i) {\\n            if (i == n)\\n                return 0;\\n            if (dp[i] != -1)\\n                return dp[i];\\n            int mn = n, t = 0;\\n            vector<int> cnt(n);\\n            for (int j = i; j < n; j++) {\\n                int &v = ++cnt[nums[j]];\\n                if (v > 2)\\n                    t++;\\n                else if (v == 2)\\n                    t += 2;\\n                mn = min(mn, t + dfs(j+1));\\n            }\\n            return dp[i] = mn + k;\\n        };\\n        return dfs(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094192,
                "title": "c-solution-recursion-memoization-use-vector-list-to-hash",
                "content": "```\\n// int solve(int ind,vector<int>&nums,int k,vector<int>&dp){\\n//     if(ind>=nums.size()) return 0;\\n//     if(dp[ind]!=-1) return dp[ind];\\n//     unordered_map<int, int> mpp;\\n//     int cnt = 0;\\n//     int maxi = INT_MAX;\\n//     for(int i=ind;i<nums.size();i++){\\n//         mpp[nums[i]]++;\\n//         if(mpp[nums[i]]==2){\\n//             cnt+=2;\\n//         }\\n//         else if(mpp[nums[i]]>2) cnt++;\\n//         maxi = min(maxi,solve(i+1,nums,k,dp)+k+cnt);\\n//     }\\n//     return dp[ind] = maxi;\\n// }\\n\\n// int minCost(vector<int>& nums, int k) {\\n//     vector<int> dp(nums.size(),-1);\\n//     return solve(0,nums,k,dp);\\n// }\\n\\nint solve(int ind,vector<int>&nums,int k,vector<int>&dp){\\n    if(ind>=nums.size()) return 0;\\n    if(dp[ind]!=-1) return dp[ind];\\n    vector<int> mpp(nums.size()+1,0);\\n    //if you use a map then it will pass 58/59\\n    //if you use a unordered_map it will get accepted \\n    //to make this even more efficient we can take the\\n    // help from constraints that nums[i] will be in \\n    //the range of [0,nums.size()] and declare a vector to hash it\\n    int cnt = 0;\\n    int maxi = INT_MAX;\\n    for(int i=ind;i<nums.size();i++){\\n        mpp[nums[i]]++;\\n        if(mpp[nums[i]]==2) cnt+=2;\\n        else if(mpp[nums[i]]>2) cnt++;\\n        maxi = min(maxi,solve(i+1,nums,k,dp)+k+cnt);\\n    }\\n    return dp[ind] = maxi;\\n}\\n\\nint minCost(vector<int>& nums, int k) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(0,nums,k,dp);\\n}\\n```\\nupvote if it helps :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// int solve(int ind,vector<int>&nums,int k,vector<int>&dp){\\n//     if(ind>=nums.size()) return 0;\\n//     if(dp[ind]!=-1) return dp[ind];\\n//     unordered_map<int, int> mpp;\\n//     int cnt = 0;\\n//     int maxi = INT_MAX;\\n//     for(int i=ind;i<nums.size();i++){\\n//         mpp[nums[i]]++;\\n//         if(mpp[nums[i]]==2){\\n//             cnt+=2;\\n//         }\\n//         else if(mpp[nums[i]]>2) cnt++;\\n//         maxi = min(maxi,solve(i+1,nums,k,dp)+k+cnt);\\n//     }\\n//     return dp[ind] = maxi;\\n// }\\n\\n// int minCost(vector<int>& nums, int k) {\\n//     vector<int> dp(nums.size(),-1);\\n//     return solve(0,nums,k,dp);\\n// }\\n\\nint solve(int ind,vector<int>&nums,int k,vector<int>&dp){\\n    if(ind>=nums.size()) return 0;\\n    if(dp[ind]!=-1) return dp[ind];\\n    vector<int> mpp(nums.size()+1,0);\\n    //if you use a map then it will pass 58/59\\n    //if you use a unordered_map it will get accepted \\n    //to make this even more efficient we can take the\\n    // help from constraints that nums[i] will be in \\n    //the range of [0,nums.size()] and declare a vector to hash it\\n    int cnt = 0;\\n    int maxi = INT_MAX;\\n    for(int i=ind;i<nums.size();i++){\\n        mpp[nums[i]]++;\\n        if(mpp[nums[i]]==2) cnt+=2;\\n        else if(mpp[nums[i]]>2) cnt++;\\n        maxi = min(maxi,solve(i+1,nums,k,dp)+k+cnt);\\n    }\\n    return dp[ind] = maxi;\\n}\\n\\nint minCost(vector<int>& nums, int k) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(0,nums,k,dp);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3094032,
                "title": "c-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        vector<int>f(n,INT_MAX);\\n        f[0]=k;\\n        for(int i=1;i<n;i++)\\n        {\\n            unordered_map<int,int>record;\\n            int cnt=0;\\n            record[nums[i]]=1;\\n            f[i]=f[i-1]+k;\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(record[nums[j]]==1)cnt+=2;\\n                else if(record[nums[j]]>1)cnt+=1;\\n                record[nums[j]]+=1;\\n                f[i]=min(f[i],(j-1>=0 ? f[j-1] : 0)+cnt+k);\\n            }\\n        }\\n        return f[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        vector<int>f(n,INT_MAX);\\n        f[0]=k;\\n        for(int i=1;i<n;i++)\\n        {\\n            unordered_map<int,int>record;\\n            int cnt=0;\\n            record[nums[i]]=1;\\n            f[i]=f[i-1]+k;\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(record[nums[j]]==1)cnt+=2;\\n                else if(record[nums[j]]>1)cnt+=1;\\n                record[nums[j]]+=1;\\n                f[i]=min(f[i],(j-1>=0 ? f[j-1] : 0)+cnt+k);\\n            }\\n        }\\n        return f[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093189,
                "title": "python-dp-bottom-up",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n```\\ndp[j] = min cost for nums[:j]\\n      = min(dp[i]+importance_value(nums[i:j])) for i 0..j-1\\n```\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:        \\n        le = len(nums)\\n        dp = [0] + [2**31-1 for _ in range(le)]\\n        for j in range(1, le+1):\\n            cnt = Counter()\\n            trim_len = 0\\n            for i in range(j-1,-1,-1):\\n                cnt[nums[i]] += 1\\n                c = cnt[nums[i]]\\n                if c > 2:\\n                    trim_len += 1\\n                elif c == 2:\\n                    trim_len += 2\\n                dp[j] = min(dp[j], dp[i]+k+trim_len)\\n        return dp[le]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndp[j] = min cost for nums[:j]\\n      = min(dp[i]+importance_value(nums[i:j])) for i 0..j-1\\n```\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:        \\n        le = len(nums)\\n        dp = [0] + [2**31-1 for _ in range(le)]\\n        for j in range(1, le+1):\\n            cnt = Counter()\\n            trim_len = 0\\n            for i in range(j-1,-1,-1):\\n                cnt[nums[i]] += 1\\n                c = cnt[nums[i]]\\n                if c > 2:\\n                    trim_len += 1\\n                elif c == 2:\\n                    trim_len += 2\\n                dp[j] = min(dp[j], dp[i]+k+trim_len)\\n        return dp[le]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092121,
                "title": "96-python-easy-solution-8-lines-of-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can use dynamic programming\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        dp = [inf] * (len(nums) + 1)\\n        dp[-1] = 0\\n        for i in range(len(nums)-1, -1, -1):\\n            cntr = defaultdict(int)\\n            trimed_len = 0\\n            for j in range(i, len(nums)):\\n                cntr[nums[j]] += 1\\n                trimed_len += (1 if cntr[nums[j]] > 2 else 2*int(cntr[nums[j]] == 2))\\n                dp[i] = min(dp[i], trimed_len+k+dp[j+1])\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        dp = [inf] * (len(nums) + 1)\\n        dp[-1] = 0\\n        for i in range(len(nums)-1, -1, -1):\\n            cntr = defaultdict(int)\\n            trimed_len = 0\\n            for j in range(i, len(nums)):\\n                cntr[nums[j]] += 1\\n                trimed_len += (1 if cntr[nums[j]] > 2 else 2*int(cntr[nums[j]] == 2))\\n                dp[i] = min(dp[i], trimed_len+k+dp[j+1])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091279,
                "title": "swift-solution",
                "content": "# Explanation\\n1. We can use dynamic programming to solve this problem.\\n2. Let dp[i] be the minimum cost to paint the first i elements.\\n3. We can calculate dp[i] by iterating through all possible j < i and\\n4. calculating dp[j] + k + trimmed[j][i-1], where trimmed[j][i-1] is the\\n5. cost to paint the elements from j to i-1.\\n6. We can calculate trimmed[j][i-1] by iterating through all elements\\n7. from j to i-1 and keeping track of the frequency of each element.\\n8. If the frequency of an element is 2, we add 2 to the cost.\\n9. If the frequency of an element is greater than 2, we add 1 to the cost.\\n10. We can calculate the frequency of each element in O(1) time by using\\n11. an array of size n to keep track of the frequency of each element.\\n12. We can calculate the cost of painting the elements from j to i-1 in\\n13. O(n) time by iterating through all elements from j to i-1 and\\n14.  calculating the cost of painting each element.\\n15. We can calculate dp[i] in O(n^2) time by iterating through all\\n16. possible j < i and calculating dp[j] + k + trimmed[j][i-1].\\n\\n\\n# Complexity\\n- Time complexity: O(n^3).\\n\\n- Space complexity: O(n^2).\\n\\n# Code\\n```\\nclass Solution {\\n    func minCost(_ nums: [Int], _ k: Int) -> Int {\\n        var n = nums.count\\n        var trimmed = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        for i in 0..<n {\\n            var curr = 0\\n            var freq = Array(repeating: 0, count: n)\\n            for j in i..<n {\\n                freq[nums[j]] += 1\\n                if freq[nums[j]] == 2 {\\n                    curr += 2\\n                } else if freq[nums[j]] > 2 {\\n                    curr += 1\\n                }\\n                trimmed[i][j] = curr\\n            }\\n        }\\n        var dp = Array(repeating: 0, count: n+1)\\n        for i in 1...n {\\n            var min = Int.max\\n            for j in 0..<i {\\n                min = Swift.min(min, dp[j]+k+trimmed[j][i-1])\\n            }\\n            dp[i] = min\\n        }\\n        return dp[n]\\n    }\\n}\\n```\\n# Please UpVote if you like.",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func minCost(_ nums: [Int], _ k: Int) -> Int {\\n        var n = nums.count\\n        var trimmed = Array(repeating: Array(repeating: 0, count: n), count: n)\\n        for i in 0..<n {\\n            var curr = 0\\n            var freq = Array(repeating: 0, count: n)\\n            for j in i..<n {\\n                freq[nums[j]] += 1\\n                if freq[nums[j]] == 2 {\\n                    curr += 2\\n                } else if freq[nums[j]] > 2 {\\n                    curr += 1\\n                }\\n                trimmed[i][j] = curr\\n            }\\n        }\\n        var dp = Array(repeating: 0, count: n+1)\\n        for i in 1...n {\\n            var min = Int.max\\n            for j in 0..<i {\\n                min = Swift.min(min, dp[j]+k+trimmed[j][i-1])\\n            }\\n            dp[i] = min\\n        }\\n        return dp[n]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090755,
                "title": "c-super-short-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& A, int k) {\\n        int dp[1001]{};\\n        function<int(int)> dfs = [&](int p) {\\n            if(p == A.size()) return 0;\\n            if(dp[p]) return dp[p];\\n            int cnt[1001]{}, res = INT_MAX;\\n            for(int i = p, sum = 0; i < A.size(); i++) {\\n                cnt[A[i]]++;\\n                sum += cnt[A[i]] == 2 ? 2 : cnt[A[i]] > 2 ? 1 : 0;\\n                res = min(res, sum+k+dfs(i+1));\\n            }\\n            return dp[p] = res;\\n        };\\n        return dfs(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& A, int k) {\\n        int dp[1001]{};\\n        function<int(int)> dfs = [&](int p) {\\n            if(p == A.size()) return 0;\\n            if(dp[p]) return dp[p];\\n            int cnt[1001]{}, res = INT_MAX;\\n            for(int i = p, sum = 0; i < A.size(); i++) {\\n                cnt[A[i]]++;\\n                sum += cnt[A[i]] == 2 ? 2 : cnt[A[i]] > 2 ? 1 : 0;\\n                res = min(res, sum+k+dfs(i+1));\\n            }\\n            return dp[p] = res;\\n        };\\n        return dfs(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090746,
                "title": "java-bottom-up-1d-dp",
                "content": "# Intuition\\nI recorded the cost of all the subarrays first, so the dp part is easier to think through. \\n\\n# Approach\\n1. Calculate cost of each subarray\\n2. iterate through subarray of length 1 (nums.length - 1 to nums.length) to full length (0 to nums.length). Let\\'s call the subarray [i, nums.length)\\n3. for every j between i and nums.length, minimum cost of i to end of the array = min(cost(i to j) + cost(j to nums.length)) for every j. e.g.: len = 4, i = 1, mininum cost = min(1 to 2 + 2 to 4, 1 to 3 + 3 to 4, 1 to 4 + 4 to 4(nothing))\\n4. for the above example, since we calculate the cost bottom up (starting at array of length 1), the cost of each (j to nums.length) subarray stored in dp is already the lowest\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int[][] subarrays = new int[nums.length][nums.length + 1]; // [i, j)\\n        for (int i = 0; i < nums.length; i++) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            int count = 0;\\n            for (int j = i; j < nums.length; j++) {\\n                map.put(nums[j], map.getOrDefault(nums[j], 0) + 1);\\n                if (map.get(nums[j]) == 2) {\\n                    count++;\\n                }\\n                if (map.get(nums[j]) > 1) {\\n                    count++;\\n                }\\n                subarrays[i][j + 1] = count + k;\\n            }\\n        }\\n        int[] dp = new int[nums.length + 1];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            int min = subarrays[i][nums.length];\\n            for (int j = i + 1; j <= nums.length; j++) {\\n                // i to j + j to nums.length\\n                min = Math.min(subarrays[i][j] + dp[j], min);\\n            }\\n            dp[i] = min;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int[][] subarrays = new int[nums.length][nums.length + 1]; // [i, j)\\n        for (int i = 0; i < nums.length; i++) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            int count = 0;\\n            for (int j = i; j < nums.length; j++) {\\n                map.put(nums[j], map.getOrDefault(nums[j], 0) + 1);\\n                if (map.get(nums[j]) == 2) {\\n                    count++;\\n                }\\n                if (map.get(nums[j]) > 1) {\\n                    count++;\\n                }\\n                subarrays[i][j + 1] = count + k;\\n            }\\n        }\\n        int[] dp = new int[nums.length + 1];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            int min = subarrays[i][nums.length];\\n            for (int j = i + 1; j <= nums.length; j++) {\\n                // i to j + j to nums.length\\n                min = Math.min(subarrays[i][j] + dp[j], min);\\n            }\\n            dp[i] = min;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090713,
                "title": "python-dp-o-n-2",
                "content": "# **Minimum Cost to Split an Array**\\n\\n## Solution\\uD83D\\uDC4D\\n\\n```python\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [-1] * n\\n        def solve(start):\\n            if n <= start:\\n                return 0\\n            if dp[start] != -1:\\n                return dp[start]\\n            num_to_freq = [0] * n # element => its length\\n            count = 0\\n            res = float(\"inf\")\\n            for end in range(start, n):\\n                num_to_freq[nums[end]] += 1\\n                if num_to_freq[nums[end]] == 2:\\n                    count += 2\\n                elif 2 < num_to_freq[nums[end]]:\\n                    count += 1\\n                res = min(res, solve(end + 1) + count + k)\\n            dp[start] = res\\n            return dp[start]\\n        return solve(0)\\n```\\n\\n## Complexity\\u23F1\\uFE0F\\n\\n- Time: $O(N^2)$\\n- Space: $O(N^2)$\\n\\n## Description\\uD83D\\uDCDD\\n\\n- Try all possible combinations\\n    - `start` is a subarray\\u2019s starting index\\n    - `end` is a subarray\\u2019s ending index\\n- count them and store its min value in `dp`\\n\\n## References\\n\\n- [\\u2705Easy Dynamic Programming - Minimum Cost to Split an Array - LeetCode](https://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3083836/easy-dynamic-programming/?orderBy=most_votes)",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [-1] * n\\n        def solve(start):\\n            if n <= start:\\n                return 0\\n            if dp[start] != -1:\\n                return dp[start]\\n            num_to_freq = [0] * n # element => its length\\n            count = 0\\n            res = float(\"inf\")\\n            for end in range(start, n):\\n                num_to_freq[nums[end]] += 1\\n                if num_to_freq[nums[end]] == 2:\\n                    count += 2\\n                elif 2 < num_to_freq[nums[end]]:\\n                    count += 1\\n                res = min(res, solve(end + 1) + count + k)\\n            dp[start] = res\\n            return dp[start]\\n        return solve(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090712,
                "title": "python-dp-o-n-2",
                "content": "# **Minimum Cost to Split an Array**\\n\\n## Solution\\uD83D\\uDC4D\\n\\n```python\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [-1] * n\\n        def solve(start):\\n            if n <= start:\\n                return 0\\n            if dp[start] != -1:\\n                return dp[start]\\n            num_to_freq = [0] * n # element => its length\\n            count = 0\\n            res = float(\"inf\")\\n            for end in range(start, n):\\n                num_to_freq[nums[end]] += 1\\n                if num_to_freq[nums[end]] == 2:\\n                    count += 2\\n                elif 2 < num_to_freq[nums[end]]:\\n                    count += 1\\n                res = min(res, solve(end + 1) + count + k)\\n            dp[start] = res\\n            return dp[start]\\n        return solve(0)\\n```\\n\\n## Complexity\\u23F1\\uFE0F\\n\\n- Time: $O(N^2)$\\n- Space: $O(N^2)$\\n\\n## Description\\uD83D\\uDCDD\\n\\n- Try all possible combinations\\n    - `start` is a subarray\\u2019s starting index\\n    - `end` is a subarray\\u2019s ending index\\n- count them and store its min value in `dp`\\n\\n## References\\n\\n- [\\u2705Easy Dynamic Programming - Minimum Cost to Split an Array - LeetCode](https://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3083836/easy-dynamic-programming/?orderBy=most_votes)",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [-1] * n\\n        def solve(start):\\n            if n <= start:\\n                return 0\\n            if dp[start] != -1:\\n                return dp[start]\\n            num_to_freq = [0] * n # element => its length\\n            count = 0\\n            res = float(\"inf\")\\n            for end in range(start, n):\\n                num_to_freq[nums[end]] += 1\\n                if num_to_freq[nums[end]] == 2:\\n                    count += 2\\n                elif 2 < num_to_freq[nums[end]]:\\n                    count += 1\\n                res = min(res, solve(end + 1) + count + k)\\n            dp[start] = res\\n            return dp[start]\\n        return solve(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089139,
                "title": "recursion-dp-hashmap-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g.  -->\\n$$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g.  -->\\nmax $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    Long[]dp;\\n    public int minCost(int[] nums, int k) {\\n        dp=new Long[nums.length];\\n        return (int)helper(nums,k,0);\\n    }\\n    long helper(int[]nums,int k,int index){\\n        if(index>=nums.length)\\n        {\\n            return 0;\\n        }\\n        if(dp[index]!=null) return dp[index];\\n        Map<Integer,Integer>map=new HashMap<>();\\n        long ans=Integer.MAX_VALUE;\\n        int count=0;\\n        for(int i=index;i<nums.length;i++)\\n        {\\n           map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n          \\n           if(map.get(nums[i])>1)\\n           {\\n               if(map.get(nums[i])==2) count+=map.get(nums[i]);\\n               else count+=1;\\n           }\\n            ans=(long)Math.min(k+count+helper(nums,k,i+1),ans);\\n            \\n        }\\n        dp[index]=ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Long[]dp;\\n    public int minCost(int[] nums, int k) {\\n        dp=new Long[nums.length];\\n        return (int)helper(nums,k,0);\\n    }\\n    long helper(int[]nums,int k,int index){\\n        if(index>=nums.length)\\n        {\\n            return 0;\\n        }\\n        if(dp[index]!=null) return dp[index];\\n        Map<Integer,Integer>map=new HashMap<>();\\n        long ans=Integer.MAX_VALUE;\\n        int count=0;\\n        for(int i=index;i<nums.length;i++)\\n        {\\n           map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n          \\n           if(map.get(nums[i])>1)\\n           {\\n               if(map.get(nums[i])==2) count+=map.get(nums[i]);\\n               else count+=1;\\n           }\\n            ans=(long)Math.min(k+count+helper(nums,k,i+1),ans);\\n            \\n        }\\n        dp[index]=ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089052,
                "title": "c-dynamic-programming-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int cur, vector<int>& nums, int k,\\n            vector<int>& dp) {\\n        if (cur >= nums.size()) return 0;\\n        if (dp[cur] != -1) return dp[cur];\\n        vector<int> hmap(1001, 0);\\n        vector<int> hset(1001, 0);\\n        int res = INT_MAX;\\n        int sz = 0;\\n        for (int i = cur; i < nums.size(); i++) {\\n            hmap[nums[i]]++;\\n            if (hmap[nums[i]] >= 2) {\\n                sz -= hset[nums[i]] > 0 ? (hmap[nums[i]] - 1) : 0;\\n                sz += hmap[nums[i]];\\n                hset[nums[i]]++;\\n            }\\n            int cost = dfs(i + 1, nums, k, dp);\\n            if (cost != INT_MAX)\\n                res = min(res, cost + sz);\\n        }\\n        return dp[cur] = res + k;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size() + 1, -1);\\n        return dfs(0, nums, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int cur, vector<int>& nums, int k,\\n            vector<int>& dp) {\\n        if (cur >= nums.size()) return 0;\\n        if (dp[cur] != -1) return dp[cur];\\n        vector<int> hmap(1001, 0);\\n        vector<int> hset(1001, 0);\\n        int res = INT_MAX;\\n        int sz = 0;\\n        for (int i = cur; i < nums.size(); i++) {\\n            hmap[nums[i]]++;\\n            if (hmap[nums[i]] >= 2) {\\n                sz -= hset[nums[i]] > 0 ? (hmap[nums[i]] - 1) : 0;\\n                sz += hmap[nums[i]];\\n                hset[nums[i]]++;\\n            }\\n            int cost = dfs(i + 1, nums, k, dp);\\n            if (cost != INT_MAX)\\n                res = min(res, cost + sz);\\n        }\\n        return dp[cur] = res + k;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size() + 1, -1);\\n        return dfs(0, nums, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088896,
                "title": "dynamic-programming-bottom-up-93ms",
                "content": "# Intuition\\nDynamic Programming\\n\\n# Approach\\nAt any given time, a number has only 3 states:\\n1. Its frequency == 0\\n2. Its frequency == 1\\n3. Its frequency >= 2\\n\\nTo describe 3 states we only need 2 bits.\\nHence an int8_t should be enough to describe the state of a number.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int8_t count[1005];\\n    int dp[1005];\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        dp[n + 1] = 0;\\n        \\n        for(int i = n - 1; i >= 0; --i) {\\n            int64_t trimmed_length = 0;\\n            memset(count, 0, sizeof(count));\\n            int64_t min_cost = numeric_limits<int64_t>::max();\\n            for(int j = i; j < n; ++j) {\\n                int val = nums[j];\\n                \\n                if(count[val] == 0) {\\n                    count[val] += 1;\\n                } else if(count[val] == 1) {\\n                    count[val] += 1;\\n                    trimmed_length += 2;\\n                } else {\\n                    trimmed_length += 1;\\n                }\\n                \\n                int64_t cost = k + trimmed_length + dp[j + 1];\\n                min_cost = min(min_cost, cost);\\n            } \\n            \\n            dp[i] = min_cost;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int8_t count[1005];\\n    int dp[1005];\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        dp[n + 1] = 0;\\n        \\n        for(int i = n - 1; i >= 0; --i) {\\n            int64_t trimmed_length = 0;\\n            memset(count, 0, sizeof(count));\\n            int64_t min_cost = numeric_limits<int64_t>::max();\\n            for(int j = i; j < n; ++j) {\\n                int val = nums[j];\\n                \\n                if(count[val] == 0) {\\n                    count[val] += 1;\\n                } else if(count[val] == 1) {\\n                    count[val] += 1;\\n                    trimmed_length += 2;\\n                } else {\\n                    trimmed_length += 1;\\n                }\\n                \\n                int64_t cost = k + trimmed_length + dp[j + 1];\\n                min_cost = min(min_cost, cost);\\n            } \\n            \\n            dp[i] = min_cost;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088641,
                "title": "c-o-n-2-simple-dp-solution-257ms",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsidering the optimal substructure of the problem: \\n`min cost of array[0..n-1] = min(importance of non-split array[0..n-1], min_i(min cost of array[0, i] + importance of non-split array[i+1..n-1]))`, where i can be from 0 to n-2.\\n\\nSo we should design a way to efficiently compute importance of any non-split array[i, j], i.e. `ip[i][j]`(ip for importance). We can keep a frequency table and update the total importance. We can use the information of `ip[i][j-1]` and the frequency table to acquire `ip[i][j]` in O(1) time.\\n\\n1. if after adding `nums[j]`, the frequency of `nums[j]` becomes 2, then it means there is a single `nums[k] = nums[j]` at index k(`i<=k<j`) appears after i and before j. After adding `nums[j]`, `nums[k]` and `nums[j]` will both appear in the trimmed array. We should increase the importance by 2.\\n2. If the frequency is greater than 2, than this element will also appear in the trimmed array. Hence the improtance difference should be +1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. Filling the importance table `ip` takse two for loops and filling out each entry takes O(1) time. In addition, for the inner loop, I will reset the frequency table `hist`. So totally it takes `O(n*(n+n)) = O(n^2)`\\n2. Filling the dp table takes `O(n^2)` time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2) since we have the importance table\\n\\n# Code\\n```\\nint ip[1001][1001];\\nint dp[1001], hist[1001];\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            memset(hist, 0, sizeof(hist));\\n            int importance = 0;\\n            for (int j = i; j < n; ++j) {\\n                ++hist[nums[j]];\\n                if (hist[nums[j]] == 2)     { importance += 2; }\\n                else if (hist[nums[j]] > 2) { ++importance; }\\n                ip[i][j] = importance + k;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            dp[i] = ip[0][i];\\n            for (int j = 0; j < i ; ++j) {\\n                dp[i] = min(dp[i], dp[j] + ip[j+1][i]);\\n            }\\n        }\\n\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nint ip[1001][1001];\\nint dp[1001], hist[1001];\\n\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            memset(hist, 0, sizeof(hist));\\n            int importance = 0;\\n            for (int j = i; j < n; ++j) {\\n                ++hist[nums[j]];\\n                if (hist[nums[j]] == 2)     { importance += 2; }\\n                else if (hist[nums[j]] > 2) { ++importance; }\\n                ip[i][j] = importance + k;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            dp[i] = ip[0][i];\\n            for (int j = 0; j < i ; ++j) {\\n                dp[i] = min(dp[i], dp[j] + ip[j+1][i]);\\n            }\\n        }\\n\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088482,
                "title": "o-nlog-n-faster-than-100-used-less-memory-than-100-11m-memory-29-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe dp approach is easy. But we could optimize it even more, which could even deal with 1e6 data!\\n\\nLet\\'s consider our dp state, $$dp_i = \\\\min_{j=0\\\\ldots i-1}{dp[j] + f(j + 1, i) + k}$$. where $$f(j + 1, i)$$ is the trim array length. Iff we could get the minimum of $$dp_j + f(j + 1, i)$$ in $$O(N log N)$$, then we could solve this question in $$O(NlogN)$$. So how?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLet\\'s only focusing on one $$f(j + 1, i)$$. We actually only have 3 cases.\\n\\n1. in $$a_{j+1, ..., i - 1}$$, there isn\\'t any value same as $$a_{i}$$, then our $$a_i$$ doesn\\'t effect it at all, so $$f(j+1, i) = f(j+1, i -1)$$.\\n2. in $$a_{j+1, ..., i - 1}$$, there is **one** value $$a_j$$ same as $$a_{i}$$. Then by adding a new $$a_{i}$$ on it, we need to add **two**, $$f(j+1,i) = f(j+1, i-1)+ 2$$. Because we count our own $$a_i$$, **also** we count $$a_j$$ in since when we added $$a_j$$ into the list in the past, we didn\\'t count originally.\\n3. in $$a_{j+1, ..., i - 1}$$, there is **>1** values same as $$a_i$$. Then we only need to add one $$a_i$$ in, that is, $$f(j+1,i) = f(j+1, i - 1) + 1$$\\n\\nSo, let\\'s say we are on $$i$$, and we have our old $$f_{i-1}$$s for index $$i-1$$. For which indexes $$j$$, we want to update nothing, which indexes $$j$$, we want to update $$+1$$, and which indexes $$j$$, we want to update $$+2$$?\\n\\nWe create an array $$lst_i$$, meaning the last index $$j$$ in $$a$$ such that $$a_j = a_i$$.\\n\\nClearly, for all $$j = lst_i + 1 \\\\ldots i-1$$, we have $$f_i(j, i) := f_{i-1}(j, i -1)$$, because it is the first appearance of $$i$$\\n\\nFor all $$j = lst_{lst_i} + 1 \\\\ldots lst_i$$, we have $$f_i(j, i) := f_{i-1}(j, i - 1) + 2$$, because it is the second appearance.\\n\\nFor all $$j \\\\leq lst_{lst_i}$$, we have $$f_i(j, i) := f_{I-1}(j, i - 1) + 1$$, becasue we already have greater than 1 appearance before.\\n\\nBut another problem is, how could we find the $$dp_i$$ if we already have all $$f_i(j, i)$$?\\n\\nWe create another array, called $$s_t$$, where at index $$i$$, $$s_t = dp_{t-1} + f_i(t, i)$$. So $$dp_i = \\\\min{s_t} + k$$.\\n\\nHow do we update $$s_t$$ for getting $$s_t$$ from $$s_{t-1}$$? Just see how we update our $$f$$ function above. We could use a segment tree to deal with the range update + range min query!\\n\\nThen, we solve the question.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nEach update & query on seg is $$O(\\\\log(N))$$, so it is $$O(N\\\\log(N))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nSeg is $$O(N)$$, so it is $$O(N)$$ (I don\\'t know why I actually have 100% less memory than others).\\n\\n# Code\\n\\nNotice I shift all indexes by 1 to right in querying/updating segment tree because we need the $$0$$ index. The index rule might not be exactly the same as above but the idea is same.\\n\\n```\\ntypedef long long ll;\\n\\nconstexpr ll MAXN = 1e5 + 5;\\nconstexpr ll INF = 0x3f3f3f3f3f3f3f3f;\\n\\nll __M;\\nll seg[MAXN << 2];\\nll lazy[MAXN << 2];\\n\\ninline void maintain(ll x) {\\n    seg[x] = min(seg[x << 1], seg[x << 1 | 1]);\\n}\\n\\ninline void build(ll N) {\\n    for (__M = 1; __M < N + 2; __M <<= 1);\\n    for (ll i = __M; i <= __M * 2 + 1; i ++) {\\n        seg[i] = INF;\\n        lazy[i] = 0;\\n    }\\n    for (ll i = __M - 1; i >= 1; i --) {\\n        maintain(i);\\n        lazy[i] = 0;\\n    }\\n}\\n\\ninline void update(ll l, ll r, ll v) {\\n    if (l > r) return;\\n    for (l += __M - 1, r += __M + 1; l ^ r ^ 1;) {\\n        if (~l & 1) {\\n            seg[l ^ 1] += v;\\n            lazy[l ^ 1] += v;\\n        }\\n        if (r & 1) {\\n            seg[r ^ 1] += v;\\n            lazy[r ^ 1] += v;\\n        }\\n        l >>= 1, r >>= 1;\\n        maintain(l);\\n        seg[l] += lazy[l];\\n        maintain(r);\\n        seg[r] += lazy[r];\\n    }\\n    for (l >>= 1; l; l >>= 1) maintain(l);\\n}\\n\\ninline void initialize(ll x) {\\n    update(x, x, -INF);\\n}\\n\\ninline ll query(ll l, ll r) {\\n    if (l > r) return 0;\\n    bool visl = false, visr = false;\\n    ll mnl = INF, mnr = INF;\\n    for (l += __M - 1, r += __M + 1; l ^ r ^ 1;) {\\n        if (~l & 1) {\\n            visl = true;\\n            mnl = min(mnl, seg[l ^ 1]);\\n        }\\n        if (r & 1) {\\n            visr = true;\\n            mnr = min(mnr, seg[r ^ 1]);\\n        }\\n        l >>= 1, r >>= 1;\\n        if (visl)\\n            mnl += lazy[l];\\n        if (visr)\\n            mnr += lazy[r];\\n    }\\n    mnl = min(mnl, mnr);\\n    for (l >>= 1; l; l >>= 1) {\\n        mnl += lazy[l];\\n    }\\n    return mnl;\\n}\\n\\nclass Solution {\\npublic:\\n\\n    int minCost(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        nums.insert(nums.begin(), 0);\\n\\n        // coordinate compression\\n        unordered_map<int, int> to;\\n        int on = 0;\\n        for (int i = 0; i <= N; i ++) {\\n            if (!to.count(nums[i])) {\\n                to[nums[i]] = on ++;\\n            }\\n        }\\n        for (int i = 1; i <= N; i ++) {\\n            nums[i] = to[nums[i]];\\n        }\\n\\n        int M = to.size();\\n\\n        // generate lst\\n        vector<int> vis(M, - 1);\\n        vector<int> lst(N + 1);\\n        for (int i = 1; i <= N; i ++) {\\n            if (vis[nums[i]] < 0) {\\n                vis[nums[i]] = i;\\n                lst[i] = -1;\\n            } else {\\n                lst[i] = vis[nums[i]];\\n                vis[nums[i]] = i;\\n            }\\n        }\\n        \\n        build(N + 1);\\n\\n        // dp[0] = 0\\n        initialize(0 + 1);\\n\\n        for (ll i = 1; i <= N; i ++) {\\n            ll pre = lst[i];\\n            // if the lst isn\\'t -1\\n            if (pre != -1) {\\n                ll prepre = lst[pre];\\n                // update all between (prepre + 1) and (pre) by +2 (counting this one)\\n                // update all before prepre by +1\\n                if (prepre == -1) {\\n                    update(1, pre - 1 + 1, 2);\\n                } else {\\n                    update(prepre + 1, pre - 1 + 1, 2);\\n                    update(1, prepre - 1 + 1, 1);\\n                }\\n            }\\n            // this times\\' answer is all last times\\' answer largest + k\\n            ll ans = query(1, i) + k;\\n            initialize(i + 1);\\n            update(i + 1, i + 1, ans);\\n        }\\n        return query(N + 1, N + 1);\\n    }\\n};\\n```\\n\\n## Some Extension Reading\\n\\nHow could we find number of different values for range $$i\\\\ldots j$$ in $$Q$$ queries offline in:\\n1. $$O((N + Q)\\\\sqrt{Q})$$?\\n2. $$O(N\\\\log(N))$$?\\n\\n(In chinese)\\n\\n[Question](https://www.luogu.com.cn/problem/P1972)",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nconstexpr ll MAXN = 1e5 + 5;\\nconstexpr ll INF = 0x3f3f3f3f3f3f3f3f;\\n\\nll __M;\\nll seg[MAXN << 2];\\nll lazy[MAXN << 2];\\n\\ninline void maintain(ll x) {\\n    seg[x] = min(seg[x << 1], seg[x << 1 | 1]);\\n}\\n\\ninline void build(ll N) {\\n    for (__M = 1; __M < N + 2; __M <<= 1);\\n    for (ll i = __M; i <= __M * 2 + 1; i ++) {\\n        seg[i] = INF;\\n        lazy[i] = 0;\\n    }\\n    for (ll i = __M - 1; i >= 1; i --) {\\n        maintain(i);\\n        lazy[i] = 0;\\n    }\\n}\\n\\ninline void update(ll l, ll r, ll v) {\\n    if (l > r) return;\\n    for (l += __M - 1, r += __M + 1; l ^ r ^ 1;) {\\n        if (~l & 1) {\\n            seg[l ^ 1] += v;\\n            lazy[l ^ 1] += v;\\n        }\\n        if (r & 1) {\\n            seg[r ^ 1] += v;\\n            lazy[r ^ 1] += v;\\n        }\\n        l >>= 1, r >>= 1;\\n        maintain(l);\\n        seg[l] += lazy[l];\\n        maintain(r);\\n        seg[r] += lazy[r];\\n    }\\n    for (l >>= 1; l; l >>= 1) maintain(l);\\n}\\n\\ninline void initialize(ll x) {\\n    update(x, x, -INF);\\n}\\n\\ninline ll query(ll l, ll r) {\\n    if (l > r) return 0;\\n    bool visl = false, visr = false;\\n    ll mnl = INF, mnr = INF;\\n    for (l += __M - 1, r += __M + 1; l ^ r ^ 1;) {\\n        if (~l & 1) {\\n            visl = true;\\n            mnl = min(mnl, seg[l ^ 1]);\\n        }\\n        if (r & 1) {\\n            visr = true;\\n            mnr = min(mnr, seg[r ^ 1]);\\n        }\\n        l >>= 1, r >>= 1;\\n        if (visl)\\n            mnl += lazy[l];\\n        if (visr)\\n            mnr += lazy[r];\\n    }\\n    mnl = min(mnl, mnr);\\n    for (l >>= 1; l; l >>= 1) {\\n        mnl += lazy[l];\\n    }\\n    return mnl;\\n}\\n\\nclass Solution {\\npublic:\\n\\n    int minCost(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        nums.insert(nums.begin(), 0);\\n\\n        // coordinate compression\\n        unordered_map<int, int> to;\\n        int on = 0;\\n        for (int i = 0; i <= N; i ++) {\\n            if (!to.count(nums[i])) {\\n                to[nums[i]] = on ++;\\n            }\\n        }\\n        for (int i = 1; i <= N; i ++) {\\n            nums[i] = to[nums[i]];\\n        }\\n\\n        int M = to.size();\\n\\n        // generate lst\\n        vector<int> vis(M, - 1);\\n        vector<int> lst(N + 1);\\n        for (int i = 1; i <= N; i ++) {\\n            if (vis[nums[i]] < 0) {\\n                vis[nums[i]] = i;\\n                lst[i] = -1;\\n            } else {\\n                lst[i] = vis[nums[i]];\\n                vis[nums[i]] = i;\\n            }\\n        }\\n        \\n        build(N + 1);\\n\\n        // dp[0] = 0\\n        initialize(0 + 1);\\n\\n        for (ll i = 1; i <= N; i ++) {\\n            ll pre = lst[i];\\n            // if the lst isn\\'t -1\\n            if (pre != -1) {\\n                ll prepre = lst[pre];\\n                // update all between (prepre + 1) and (pre) by +2 (counting this one)\\n                // update all before prepre by +1\\n                if (prepre == -1) {\\n                    update(1, pre - 1 + 1, 2);\\n                } else {\\n                    update(prepre + 1, pre - 1 + 1, 2);\\n                    update(1, prepre - 1 + 1, 1);\\n                }\\n            }\\n            // this times\\' answer is all last times\\' answer largest + k\\n            ll ans = query(1, i) + k;\\n            initialize(i + 1);\\n            update(i + 1, i + 1, ans);\\n        }\\n        return query(N + 1, N + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088427,
                "title": "java-recursion-memoisation-dp",
                "content": "\\n\\n# Code\\n```\\n    // b <================= Minimum Cost to Split an Array ============>\\n    // https://leetcode.com/problems/minimum-cost-to-split-an-array/description/\\n\\n    // # Maine current subarray ki value nikali aur bache hue array ko kaha tu apni\\n    // # importance value leke aaja. Dono ko add karke maine min se compare kiya.\\n    // # Ab aisa agar mai har ek value ke liye karunga, to mujhe min value mil\\n    // # jayegi.\\n\\n    // ! Recursion :\\n\\n    public int minCost_rec(int[] nums, int k, int si, int n) {\\n\\n        if (si >= n)\\n            return 0;\\n\\n        int[] map = new int[n]; // To store the count of numbers,instead of using Hashmap, we used array which\\n                                // is faster.\\n        int count = 0;\\n        int min = (int) (1e9);\\n        for (int i = si; i < n; i++) {\\n            int val = nums[i];\\n            map[val]++;\\n            if (map[val] == 2)\\n                count += 2;\\n            else if (map[val] > 2)\\n                count++;\\n\\n            int currentArrImpValue = count + k;\\n            int remainingArrImpValue = minCost_rec(nums, k, i + 1, n);\\n\\n            min = Math.min(min, currentArrImpValue + remainingArrImpValue);\\n        }\\n        return min;\\n    }\\n\\n    public int minCost_rec(int[] nums, int k) {\\n        return minCost_rec(nums, k, 0, nums.length);\\n    }\\n\\n    // ! Memoisation :\\n\\n    public int minCost_memo(int[] nums, int k, int si, int n, int[] dp) {\\n        if (si >= n)\\n            return dp[si] = 0;\\n\\n        if (dp[si] != -1)\\n            return dp[si];\\n\\n        int[] map = new int[n];\\n        int count = 0;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = si; i < n; i++) {\\n            int val = nums[i];\\n            map[val]++;\\n            if (map[val] == 2)\\n                count += 2;\\n            else if (map[val] > 2)\\n                count++;\\n\\n            int currentArrImpValue = count + k;\\n            int remainingArrImpValue = minCost_memo(nums, k, i + 1, n, dp);\\n\\n            min = Math.min(min, currentArrImpValue + remainingArrImpValue);\\n\\n        }\\n\\n        return dp[si] = min;\\n    }\\n\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, -1);\\n        return minCost_memo(nums, k, 0, n, dp);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    // b <================= Minimum Cost to Split an Array ============>\\n    // https://leetcode.com/problems/minimum-cost-to-split-an-array/description/\\n\\n    // # Maine current subarray ki value nikali aur bache hue array ko kaha tu apni\\n    // # importance value leke aaja. Dono ko add karke maine min se compare kiya.\\n    // # Ab aisa agar mai har ek value ke liye karunga, to mujhe min value mil\\n    // # jayegi.\\n\\n    // ! Recursion :\\n\\n    public int minCost_rec(int[] nums, int k, int si, int n) {\\n\\n        if (si >= n)\\n            return 0;\\n\\n        int[] map = new int[n]; // To store the count of numbers,instead of using Hashmap, we used array which\\n                                // is faster.\\n        int count = 0;\\n        int min = (int) (1e9);\\n        for (int i = si; i < n; i++) {\\n            int val = nums[i];\\n            map[val]++;\\n            if (map[val] == 2)\\n                count += 2;\\n            else if (map[val] > 2)\\n                count++;\\n\\n            int currentArrImpValue = count + k;\\n            int remainingArrImpValue = minCost_rec(nums, k, i + 1, n);\\n\\n            min = Math.min(min, currentArrImpValue + remainingArrImpValue);\\n        }\\n        return min;\\n    }\\n\\n    public int minCost_rec(int[] nums, int k) {\\n        return minCost_rec(nums, k, 0, nums.length);\\n    }\\n\\n    // ! Memoisation :\\n\\n    public int minCost_memo(int[] nums, int k, int si, int n, int[] dp) {\\n        if (si >= n)\\n            return dp[si] = 0;\\n\\n        if (dp[si] != -1)\\n            return dp[si];\\n\\n        int[] map = new int[n];\\n        int count = 0;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = si; i < n; i++) {\\n            int val = nums[i];\\n            map[val]++;\\n            if (map[val] == 2)\\n                count += 2;\\n            else if (map[val] > 2)\\n                count++;\\n\\n            int currentArrImpValue = count + k;\\n            int remainingArrImpValue = minCost_memo(nums, k, i + 1, n, dp);\\n\\n            min = Math.min(min, currentArrImpValue + remainingArrImpValue);\\n\\n        }\\n\\n        return dp[si] = min;\\n    }\\n\\n    public int minCost(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, -1);\\n        return minCost_memo(nums, k, 0, n, dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3088123,
                "title": "golang-23-ms-3-3-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n# Code\\n```\\nfunc min(a, b int32) int32 {\\n\\tif a <= b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc minCost(nums []int, k int) int {\\n\\tn := len(nums)\\n\\tdp := make([]int32, n)\\n\\tdp[0] = int32(k)\\n\\tcounts := make([]int16, n)\\n\\tcountsTmp := make([]int16, n)\\n\\tcounts[nums[0]] = 1\\n\\tonceCount := 1\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tnum := nums[i]\\n\\t\\tswitch counts[num] {\\n\\t\\tcase 0:\\n\\t\\t\\tonceCount++\\n\\t\\tcase 1:\\n\\t\\t\\tonceCount--\\n\\t\\t}\\n\\t\\tcounts[num]++\\n\\t\\tdp[i] = int32(i + 1 - onceCount + k)\\n\\t\\tif onceCount <= i {\\n\\t\\t\\tcopy(countsTmp, counts)\\n\\t\\t\\tonceCountTmp := onceCount\\n\\t\\t\\tfor j := 0; j < i; j++ {\\n\\t\\t\\t\\tnum = nums[j]\\n\\t\\t\\t\\tswitch countsTmp[num] {\\n\\t\\t\\t\\tcase 1:\\n\\t\\t\\t\\t\\tonceCountTmp--\\n\\t\\t\\t\\tcase 2:\\n\\t\\t\\t\\t\\tonceCountTmp++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcountsTmp[num]--\\n\\t\\t\\t\\tdp[i] = min(dp[i], dp[j]+int32(i-j-onceCountTmp+k))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn int(dp[n-1])\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc min(a, b int32) int32 {\\n\\tif a <= b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc minCost(nums []int, k int) int {\\n\\tn := len(nums)\\n\\tdp := make([]int32, n)\\n\\tdp[0] = int32(k)\\n\\tcounts := make([]int16, n)\\n\\tcountsTmp := make([]int16, n)\\n\\tcounts[nums[0]] = 1\\n\\tonceCount := 1\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tnum := nums[i]\\n\\t\\tswitch counts[num] {\\n\\t\\tcase 0:\\n\\t\\t\\tonceCount++\\n\\t\\tcase 1:\\n\\t\\t\\tonceCount--\\n\\t\\t}\\n\\t\\tcounts[num]++\\n\\t\\tdp[i] = int32(i + 1 - onceCount + k)\\n\\t\\tif onceCount <= i {\\n\\t\\t\\tcopy(countsTmp, counts)\\n\\t\\t\\tonceCountTmp := onceCount\\n\\t\\t\\tfor j := 0; j < i; j++ {\\n\\t\\t\\t\\tnum = nums[j]\\n\\t\\t\\t\\tswitch countsTmp[num] {\\n\\t\\t\\t\\tcase 1:\\n\\t\\t\\t\\t\\tonceCountTmp--\\n\\t\\t\\t\\tcase 2:\\n\\t\\t\\t\\t\\tonceCountTmp++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcountsTmp[num]--\\n\\t\\t\\t\\tdp[i] = min(dp[i], dp[j]+int32(i-j-onceCountTmp+k))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn int(dp[n-1])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3088012,
                "title": "python-dynamic-programming",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        memo = {}\\n        def helper(i):\\n            if i in memo:\\n                return memo[i]\\n            if i >= len(nums):\\n                return 0\\n            cnt = defaultdict(int)\\n            temp = 0\\n            memo[i] = float(\"inf\")\\n            for j in range(i, len(nums)):\\n                cnt[nums[j]] += 1\\n                if cnt[nums[j]] == 2:\\n                    temp += 2\\n                elif cnt[nums[j]] > 2:\\n                    temp += 1\\n                memo[i] = min(memo[i], k + temp + helper(j + 1))\\n            return memo[i]\\n        return helper(0)\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        memo = {}\\n        def helper(i):\\n            if i in memo:\\n                return memo[i]\\n            if i >= len(nums):\\n                return 0\\n            cnt = defaultdict(int)\\n            temp = 0\\n            memo[i] = float(\"inf\")\\n            for j in range(i, len(nums)):\\n                cnt[nums[j]] += 1\\n                if cnt[nums[j]] == 2:\\n                    temp += 2\\n                elif cnt[nums[j]] > 2:\\n                    temp += 1\\n                memo[i] = min(memo[i], k + temp + helper(j + 1))\\n            return memo[i]\\n        return helper(0)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087990,
                "title": "c-dp-in-o-n-2",
                "content": "# Problem\\n\\n[Minimum Cost to Split an Array - LeetCode](https://leetcode.com/problems/minimum-cost-to-split-an-array/)\\n\\n# Analysis\\n\\nBasically, this problem is asking for partitioning the array into non-overlapping subarrays with costs. So it\\u2019s a pretty straightforward partition DP problem in a pattern like\\n\\n`dp[i] = min(dp[j] + cost(nums[j:i]))`\\n\\nWhere `dp[i]` is the **************************************************************minimum cost to split nums[:i]************************************************************** and `cost(nums[j:i])` is `k + trimmed(nums[j:i])`. The DP problem would take O(N^2) to compare all pairs of (i,j), but computing a `trimmed(nums)` would take extra `len(nums)` steps. So the overall time complexity would become O(N^3). So the overall time complexity would become O(N^3). \\n\\nTo optimize the `trimmed(nums)` , which is number of non-single value, the formula can be transformed to `size(nums) - singleValues(nums)` . The state transition formula then become\\n\\n`dp[i] = min(dp[j] + (k + size(nums[j:i]) - singleValues(nums[j:i])))`\\n\\nUsing a frequency table, the `singleValues(nums[j:i]) = singleValues(nums[j+1:i]) +`\\n- `1 if freq[nums[j]] == 0`\\n- `-1 if freq[nums[j]] == 1`\\n- `0 elsewhere`\\n\\nThis makes the computation of `trimmed(nums)` O(1) at each iteration.\\n\\n# Solution\\n\\n- Time: O(N^2)\\n- Space: O(N)\\n```c++\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n\\t\\t// partition the nums and minimized the sum of importance values\\n\\t\\t// the k is like a Sunk cost of each split\\n\\t\\t// dp[i] := minimized cost to split nums[:i]\\n\\t\\t// dp[i] = min(dp[j] + (k + trimmed(nums[j:i])))\\n\\t\\t// DP would take O(N^2) but trimmed(..) would take an extra N\\n\\t\\t//\\n\\t\\t// compute trimmed on the fly\\n\\t\\t// trimmed(nums[j:i]) := i - j - singleValues(nums[j:i])\\n\\t\\t// 1. we can cumulate singleValues of nums[j:i] by moving j from i to 0\\n\\t\\t// 2. singleValues(nums[j:i]) = singleValues(nums[j+1:i]) \\n\\t\\t// \\t\\t* -1 if freq[nums[j]] == 1\\n\\t\\t//\\t \\t* +1 if freq[nums[j]] == 0\\n\\t\\t// \\t\\t* +0 if freq[nums[j]] > 1\\n\\t\\tint n = nums.size();\\n\\t\\tvector<int> dp(n + 1, INT_MAX);\\n\\t\\tdp[0] = 0;\\n\\t\\tfor(int i = 0; i < n; ++i) {\\n\\t\\t\\tvector<int> freq(n, 0);\\n\\t\\t\\tint singles = 0;\\n\\t\\t\\tfor(int j = i; j >= 0; --j) {\\n\\t\\t\\t\\tif(freq[nums[j]] == 0)\\n\\t\\t\\t\\t\\tsingles++;\\n\\t\\t\\t\\telse if(freq[nums[j]] == 1) \\n\\t\\t\\t\\t\\tsingles--;\\n\\t\\t\\t\\tdp[i + 1] = min(dp[i+1], dp[j] + (k + i + 1 - j - singles));`\\n\\t\\t\\t\\tfreq[nums[j]]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[n];\\n\\t}\\t\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n\\t\\t// partition the nums and minimized the sum of importance values\\n\\t\\t// the k is like a Sunk cost of each split\\n\\t\\t// dp[i] := minimized cost to split nums[:i]\\n\\t\\t// dp[i] = min(dp[j] + (k + trimmed(nums[j:i])))\\n\\t\\t// DP would take O(N^2) but trimmed(..) would take an extra N\\n\\t\\t//\\n\\t\\t// compute trimmed on the fly\\n\\t\\t// trimmed(nums[j:i]) := i - j - singleValues(nums[j:i])\\n\\t\\t// 1. we can cumulate singleValues of nums[j:i] by moving j from i to 0\\n\\t\\t// 2. singleValues(nums[j:i]) = singleValues(nums[j+1:i]) \\n\\t\\t// \\t\\t* -1 if freq[nums[j]] == 1\\n\\t\\t//\\t \\t* +1 if freq[nums[j]] == 0\\n\\t\\t// \\t\\t* +0 if freq[nums[j]] > 1\\n\\t\\tint n = nums.size();\\n\\t\\tvector<int> dp(n + 1, INT_MAX);\\n\\t\\tdp[0] = 0;\\n\\t\\tfor(int i = 0; i < n; ++i) {\\n\\t\\t\\tvector<int> freq(n, 0);\\n\\t\\t\\tint singles = 0;\\n\\t\\t\\tfor(int j = i; j >= 0; --j) {\\n\\t\\t\\t\\tif(freq[nums[j]] == 0)\\n\\t\\t\\t\\t\\tsingles++;\\n\\t\\t\\t\\telse if(freq[nums[j]] == 1) \\n\\t\\t\\t\\t\\tsingles--;\\n\\t\\t\\t\\tdp[i + 1] = min(dp[i+1], dp[j] + (k + i + 1 - j - singles));`\\n\\t\\t\\t\\tfreq[nums[j]]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[n];\\n\\t}\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087950,
                "title": "java-dfs-memoization-explanation-with-comments-and-intuition",
                "content": "# Intuition\\nThink of it as a 2 step quesion. First step is generating a parition from an array and then finding the min importance value for each partition. \\n\\nFirst think how would we generate a partition for an array. Now, we can keep the variables during that process to keep counting importance value as we are generating partitions. Use that to compute the values and store the min using memoization. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    // Create a memoization array to store the min importance value at each index\\n    int[] memo;\\n    public int minCost(int[] nums, int k) {\\n        memo = new int[nums.length];\\n        for(int i = 0; i < memo.length; i++) {\\n            memo[i] = -1;\\n        }\\n        return dfs(nums, 0, k);\\n    }\\n\\n    // Returns the min importance value for an array index to nums.length-1\\n    private int dfs(int[] nums, int index, int k) {\\n        // 0 Importance value if we reach end of the array\\n        if (index == nums.length) return 0;\\n\\n        // If != -1, that means we have visited this index and we know what is ans for sub array [index,len-1]\\n        if (memo[index] != -1 ) return memo[index];\\n\\n        // Stores the running importance value at Index\\n        int importanceValueAtIndex = 0;\\n        // Min importance value at index\\n        int min = Integer.MAX_VALUE;\\n        // Frequency count map\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = index; i < nums.length; i++) {\\n            // Update the frequence count\\n            map.put(nums[i], map.getOrDefault(nums[i],0) + 1);\\n\\n            // If count is 2, that means we have not account for this digit, so now we will include at least 2 occurance of same digits, which is requirement to be included in trimmed array\\n            if (map.get(nums[i]) == 2) {\\n                importanceValueAtIndex += 2;\\n            } else if (map.get(nums[i]) > 2) {\\n                // If already same digit was seen before, then we only to increment by 1.\\n                importanceValueAtIndex += 1;\\n            }\\n            // Get the min importance value for array begging after i, which is i+1 and add it to importanceValueAtIndex\\n\\n            int fromChild = dfs(nums, i+1, k);\\n            min = Math.min(min, importanceValueAtIndex + k + fromChild);\\n        }\\n        // Store the min in dp\\n        memo[index] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    // Create a memoization array to store the min importance value at each index\\n    int[] memo;\\n    public int minCost(int[] nums, int k) {\\n        memo = new int[nums.length];\\n        for(int i = 0; i < memo.length; i++) {\\n            memo[i] = -1;\\n        }\\n        return dfs(nums, 0, k);\\n    }\\n\\n    // Returns the min importance value for an array index to nums.length-1\\n    private int dfs(int[] nums, int index, int k) {\\n        // 0 Importance value if we reach end of the array\\n        if (index == nums.length) return 0;\\n\\n        // If != -1, that means we have visited this index and we know what is ans for sub array [index,len-1]\\n        if (memo[index] != -1 ) return memo[index];\\n\\n        // Stores the running importance value at Index\\n        int importanceValueAtIndex = 0;\\n        // Min importance value at index\\n        int min = Integer.MAX_VALUE;\\n        // Frequency count map\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = index; i < nums.length; i++) {\\n            // Update the frequence count\\n            map.put(nums[i], map.getOrDefault(nums[i],0) + 1);\\n\\n            // If count is 2, that means we have not account for this digit, so now we will include at least 2 occurance of same digits, which is requirement to be included in trimmed array\\n            if (map.get(nums[i]) == 2) {\\n                importanceValueAtIndex += 2;\\n            } else if (map.get(nums[i]) > 2) {\\n                // If already same digit was seen before, then we only to increment by 1.\\n                importanceValueAtIndex += 1;\\n            }\\n            // Get the min importance value for array begging after i, which is i+1 and add it to importanceValueAtIndex\\n\\n            int fromChild = dfs(nums, i+1, k);\\n            min = Math.min(min, importanceValueAtIndex + k + fromChild);\\n        }\\n        // Store the min in dp\\n        memo[index] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087293,
                "title": "java-simple-dp",
                "content": "```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        Integer dp[]=new Integer [nums.length];\\n        return solve(nums,0,k,dp);\\n    }\\n    public int solve(int a[],int i,int k,Integer dp[]){\\n        if(i>=a.length)return 0;\\n        if(dp[i]!=null)return dp[i];\\n        int max=Integer.MAX_VALUE;\\n        \\n        // used to cnt element with one freq\\n        Set<Integer> one = new HashSet<>();\\n        Map<Integer,Integer> map= new HashMap<>();\\n        \\n        for(int j=i;j<a.length;j++){\\n            map.put(a[j],map.getOrDefault(a[j],0)+1);\\n            \\n            if(map.get(a[j])==1)one.add(a[j]);\\n            else if(one.contains(a[j]))one.remove(a[j]);\\n            \\n            int nex=solve(a,j+1,k,dp);\\n            \\n            max=Math.min(nex+(j-i+1-one.size())+k,max);\\n        }\\n        return dp[i]=max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        Integer dp[]=new Integer [nums.length];\\n        return solve(nums,0,k,dp);\\n    }\\n    public int solve(int a[],int i,int k,Integer dp[]){\\n        if(i>=a.length)return 0;\\n        if(dp[i]!=null)return dp[i];\\n        int max=Integer.MAX_VALUE;\\n        \\n        // used to cnt element with one freq\\n        Set<Integer> one = new HashSet<>();\\n        Map<Integer,Integer> map= new HashMap<>();\\n        \\n        for(int j=i;j<a.length;j++){\\n            map.put(a[j],map.getOrDefault(a[j],0)+1);\\n            \\n            if(map.get(a[j])==1)one.add(a[j]);\\n            else if(one.contains(a[j]))one.remove(a[j]);\\n            \\n            int nex=solve(a,j+1,k,dp);\\n            \\n            max=Math.min(nex+(j-i+1-one.size())+k,max);\\n        }\\n        return dp[i]=max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086953,
                "title": "java-memoized-solution-with-cached-importance-value",
                "content": "```\\nclass Solution {\\n    int[] nums;\\n    int ktarg;\\n    int[][] cost_cache;\\n    int[] dp;\\n    \\n    public int dycost(int n){\\n        if(n >= nums.length) return 0;\\n        if(dp[n] != -1) return dp[n];\\n        // System.out.println(\"finding for \"+n);\\n        int cost = cost_cache[n][nums.length-1];\\n        for(int i=n+1; i<nums.length; i++){\\n            int cst = dycost(i);\\n            // System.out.println(\"At \"+n+\" and part: \" + i + \" we return: \"+cst);\\n            cost = Math.min(cost,  cost_cache[n][i-1] + cst);\\n        }\\n        // System.out.println(\"At \"+n+\" we return: \"+cost);\\n        return dp[n] = cost;\\n    }\\n    \\n    public int minCost(int[] nums, int k) {\\n        this.nums = nums;\\n        this.ktarg = k;\\n        this.dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        \\n        cost_cache = new int[nums.length][nums.length];\\n\\n        for(int i=0; i<nums.length; i++){\\n            cost_cache[i][i] = k;\\n            HashMap<Integer, Integer> cache = new HashMap<>();\\n            cache.put(nums[i], 1);\\n            int cost = 0;\\n            \\n            for(int j=i+1; j<nums.length; j++){\\n                int val = nums[j];\\n                if(cache.containsKey(val)){\\n                    // Already contained, ie good, ie cost++\\n                    if(cache.get(val) == 1) cost += 2;\\n                    else cost+=1;\\n                    \\n                }\\n                cache.put(val, cache.getOrDefault(val,0)+1);\\n                \\n                cost_cache[i][j] = k + cost;\\n            }\\n        }\\n        \\n        // System.out.println(Arrays.deepToString(cost_cache).replace(\"], \", \"]\\\\n\").replace(\"[[\", \"[\").replace(\"]]\", \"]\"));\\n\\n        \\n        return dycost(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    int ktarg;\\n    int[][] cost_cache;\\n    int[] dp;\\n    \\n    public int dycost(int n){\\n        if(n >= nums.length) return 0;\\n        if(dp[n] != -1) return dp[n];\\n        // System.out.println(\"finding for \"+n);\\n        int cost = cost_cache[n][nums.length-1];\\n        for(int i=n+1; i<nums.length; i++){\\n            int cst = dycost(i);\\n            // System.out.println(\"At \"+n+\" and part: \" + i + \" we return: \"+cst);\\n            cost = Math.min(cost,  cost_cache[n][i-1] + cst);\\n        }\\n        // System.out.println(\"At \"+n+\" we return: \"+cost);\\n        return dp[n] = cost;\\n    }\\n    \\n    public int minCost(int[] nums, int k) {\\n        this.nums = nums;\\n        this.ktarg = k;\\n        this.dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        \\n        cost_cache = new int[nums.length][nums.length];\\n\\n        for(int i=0; i<nums.length; i++){\\n            cost_cache[i][i] = k;\\n            HashMap<Integer, Integer> cache = new HashMap<>();\\n            cache.put(nums[i], 1);\\n            int cost = 0;\\n            \\n            for(int j=i+1; j<nums.length; j++){\\n                int val = nums[j];\\n                if(cache.containsKey(val)){\\n                    // Already contained, ie good, ie cost++\\n                    if(cache.get(val) == 1) cost += 2;\\n                    else cost+=1;\\n                    \\n                }\\n                cache.put(val, cache.getOrDefault(val,0)+1);\\n                \\n                cost_cache[i][j] = k + cost;\\n            }\\n        }\\n        \\n        // System.out.println(Arrays.deepToString(cost_cache).replace(\"], \", \"]\\\\n\").replace(\"[[\", \"[\").replace(\"]]\", \"]\"));\\n\\n        \\n        return dycost(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086759,
                "title": "c-simple-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int impv[1001][1001];\\n    int dp[1001][1001];\\n    int minCost(vector<int>& nums, int k) {\\n         memset(dp,-1,sizeof(dp));\\n         memset(impv,-1,sizeof(impv));\\n         for(int i=0; i<nums.size(); i++) {\\n              int ch[1001] = {0};\\n              int cnt = 0;\\n              for(int j=i; j<nums.size(); j++) {\\n                    ch[nums[j]]++;\\n                    if(ch[nums[j]] == 1) cnt++;\\n                    else if(ch[nums[j]] == 2) cnt--;\\n                    impv[i][j] = (j - i + 1) - cnt;\\n              }\\n         }\\n        return solve(0,0,nums,k);\\n    }\\n    long solve(int l,int r,vector<int> &nums,int &k) {\\n          if(r>=nums.size()) {\\n               return impv[l][r-1] + k;\\n          }\\n          if(dp[l][r]!=-1) return dp[l][r];\\n          long cnt = 0;\\n          if(l == r) {\\n               cnt = min(solve(l,r+1,nums,k),k+impv[l][r]+solve(r+1,r+1,nums,k));\\n          }else {\\n               cnt = min(solve(l,r+1,nums,k),k+impv[l][r-1]+solve(r,r+1,nums,k));\\n          }\\n         return dp[l][r] = cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int impv[1001][1001];\\n    int dp[1001][1001];\\n    int minCost(vector<int>& nums, int k) {\\n         memset(dp,-1,sizeof(dp));\\n         memset(impv,-1,sizeof(impv));\\n         for(int i=0; i<nums.size(); i++) {\\n              int ch[1001] = {0};\\n              int cnt = 0;\\n              for(int j=i; j<nums.size(); j++) {\\n                    ch[nums[j]]++;\\n                    if(ch[nums[j]] == 1) cnt++;\\n                    else if(ch[nums[j]] == 2) cnt--;\\n                    impv[i][j] = (j - i + 1) - cnt;\\n              }\\n         }\\n        return solve(0,0,nums,k);\\n    }\\n    long solve(int l,int r,vector<int> &nums,int &k) {\\n          if(r>=nums.size()) {\\n               return impv[l][r-1] + k;\\n          }\\n          if(dp[l][r]!=-1) return dp[l][r];\\n          long cnt = 0;\\n          if(l == r) {\\n               cnt = min(solve(l,r+1,nums,k),k+impv[l][r]+solve(r+1,r+1,nums,k));\\n          }else {\\n               cnt = min(solve(l,r+1,nums,k),k+impv[l][r-1]+solve(r,r+1,nums,k));\\n          }\\n         return dp[l][r] = cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086601,
                "title": "lis-dp-c-intuition-explained-clean-code",
                "content": "# Intuition\\n\\nBy looking at constraints of the problem which are n <= 1000 i started thinking of an approach that runs in atleast O(N*N) time.\\n\\n# Approach\\nOn further looking as to how problem is basically asking us to consider subarrays i thought of LIS kind of dp where our dp state is\\n\\n```\\nlis_dp[j] = if i consider jth number to be last number in sequence what is max length of LIS i will get\\n```\\n\\nLike wise we can think of in this question\\n```\\ndp[j] = if i consider jth element in the last subarray that i am splitting whole array into what is minimum cost i can get \\n```\\n\\n   ```\\n----|----|---- (jth) \\n```\\n\\nYou must be now getting an intuiton as to how this is so similar to LIS\\n\\nto fasten things up we can use a frequency array rather than a seperate hashmap.\\n\\n# Complexity\\n- Time complexity:\\n O(N * N) \\n\\n- Space complexity:\\nO(N)\\n\\n\\nFeel free to ask anything and if this helps please upvote\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        // dp i represents what is min cost if I consider array from [0...i]\\n            \\n            \\n        vector<long long> dp(n + 1, 1e13);\\n        dp[0] = 0;\\n        dp[1] = k;    \\n        for(int i = 1; i < n; i ++) {\\n                vector<int> freq(1001, 0);\\n                long long cost = 0;\\n                for(int j = i; j >= 0; j --) {\\n                        dp[i + 1] = min(dp[i + 1], k + cost + dp[j + 1]);\\n                        \\n                        freq[nums[j]]++;\\n                        if(freq[nums[j]] == 2) {\\n                                cost += 2;\\n                        } else if(freq[nums[j]] > 2){\\n                                cost ++;\\n                        }\\n                }\\n                dp[i + 1] = min(dp[i + 1], k + cost);\\n             \\n        }\\n            \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nlis_dp[j] = if i consider jth number to be last number in sequence what is max length of LIS i will get\\n```\n```\\ndp[j] = if i consider jth element in the last subarray that i am splitting whole array into what is minimum cost i can get \\n```\n```\\n----|----|---- (jth) \\n```\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        // dp i represents what is min cost if I consider array from [0...i]\\n            \\n            \\n        vector<long long> dp(n + 1, 1e13);\\n        dp[0] = 0;\\n        dp[1] = k;    \\n        for(int i = 1; i < n; i ++) {\\n                vector<int> freq(1001, 0);\\n                long long cost = 0;\\n                for(int j = i; j >= 0; j --) {\\n                        dp[i + 1] = min(dp[i + 1], k + cost + dp[j + 1]);\\n                        \\n                        freq[nums[j]]++;\\n                        if(freq[nums[j]] == 2) {\\n                                cost += 2;\\n                        } else if(freq[nums[j]] > 2){\\n                                cost ++;\\n                        }\\n                }\\n                dp[i + 1] = min(dp[i + 1], k + cost);\\n             \\n        }\\n            \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086420,
                "title": "simpler-code-c-pre-requisite-palindrome-partitioning",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int ind , int k,vector<vector<int>>& trim,vector<int> &dp)\\n    {\\n        if(ind>=nums.size()) return 0;\\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        int score = INT_MAX;\\n        for(int i=ind; i<nums.size();i++)\\n        {\\n            int curr = k+trim[ind][i]+solve(nums,i+1,k,trim,dp);\\n            score=min(score,curr);\\n        }\\n        return dp[ind] = score;\\n    }\\n    int minCost(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        vector<vector<int>> trim(n,vector<int>(n,0));\\n        for(int i=0; i<n; i++)\\n        {\\n            unordered_map<int,int> mp;\\n            int count =0;\\n            for(int j=i; j<n; j++)\\n            {\\n                mp[nums[j]]++;\\n                if(mp[nums[j]]==2)\\n                {\\n                    count+=2;\\n                }\\n                else if(mp[nums[j]]>2)\\n                {\\n                    count++;\\n                }\\n                trim[i][j] = count;\\n            }   \\n        }\\n        vector<int> dp(n,-1);\\n        return solve(nums,0,k,trim,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int ind , int k,vector<vector<int>>& trim,vector<int> &dp)\\n    {\\n        if(ind>=nums.size()) return 0;\\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        int score = INT_MAX;\\n        for(int i=ind; i<nums.size();i++)\\n        {\\n            int curr = k+trim[ind][i]+solve(nums,i+1,k,trim,dp);\\n            score=min(score,curr);\\n        }\\n        return dp[ind] = score;\\n    }\\n    int minCost(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        vector<vector<int>> trim(n,vector<int>(n,0));\\n        for(int i=0; i<n; i++)\\n        {\\n            unordered_map<int,int> mp;\\n            int count =0;\\n            for(int j=i; j<n; j++)\\n            {\\n                mp[nums[j]]++;\\n                if(mp[nums[j]]==2)\\n                {\\n                    count+=2;\\n                }\\n                else if(mp[nums[j]]>2)\\n                {\\n                    count++;\\n                }\\n                trim[i][j] = count;\\n            }   \\n        }\\n        vector<int> dp(n,-1);\\n        return solve(nums,0,k,trim,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086405,
                "title": "c-dp-memoization-tabulation-easy-hashmaps-clean-code",
                "content": "\\n# Code\\n```\\n# MEMOIZATION\\nclass Solution {\\npublic:\\n    long dp[1001];\\n    int solve(int i,vector<int>&nums,long k )\\n    {\\n        if(i>=nums.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n          long ans=1e10;\\n          long length=0;\\n        unordered_map<long,long>mp;\\n        for(int j=i;j<nums.size();++j)\\n        {\\n            mp[nums[j]]++;\\n            \\n            if(mp[nums[j]]==2)\\n            {\\n                length+=2;\\n            }\\n            else if(mp[nums[j]]>2)\\n            {\\n                length++;\\n            }\\n            \\n            ans=min(ans,k+length+solve(j+1,nums,k ));\\n        }\\n        return dp[i]=ans;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(0,nums,k);\\n    }\\n};\\n\\n\\n#TABULATION\\n\\n\\nclass Solution {\\npublic:\\n    long dp[1001];\\n  \\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        int n=nums.size();\\n        \\n        dp[n]=0;\\n        \\n        for(int i=n-1;i>=0;--i)\\n        {\\n          long ans=1e10;\\n          long length=0;\\n            \\n        unordered_map<long,long>mp;\\n            \\n        for(int j=i;j<nums.size();++j)\\n        {\\n            mp[nums[j]]++;\\n            \\n            if(mp[nums[j]]==2)\\n            {\\n                length+=2;\\n            }\\n            else if(mp[nums[j]]>2)\\n            {\\n                length++;\\n            }\\n            \\n            ans=min(ans,k+length+dp[j+1]);\\n        }\\n            dp[i]=ans;\\n    \\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\\n**UPVOTE IF IT HELPED**",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n# MEMOIZATION\\nclass Solution {\\npublic:\\n    long dp[1001];\\n    int solve(int i,vector<int>&nums,long k )\\n    {\\n        if(i>=nums.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n          long ans=1e10;\\n          long length=0;\\n        unordered_map<long,long>mp;\\n        for(int j=i;j<nums.size();++j)\\n        {\\n            mp[nums[j]]++;\\n            \\n            if(mp[nums[j]]==2)\\n            {\\n                length+=2;\\n            }\\n            else if(mp[nums[j]]>2)\\n            {\\n                length++;\\n            }\\n            \\n            ans=min(ans,k+length+solve(j+1,nums,k ));\\n        }\\n        return dp[i]=ans;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(0,nums,k);\\n    }\\n};\\n\\n\\n#TABULATION\\n\\n\\nclass Solution {\\npublic:\\n    long dp[1001];\\n  \\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        int n=nums.size();\\n        \\n        dp[n]=0;\\n        \\n        for(int i=n-1;i>=0;--i)\\n        {\\n          long ans=1e10;\\n          long length=0;\\n            \\n        unordered_map<long,long>mp;\\n            \\n        for(int j=i;j<nums.size();++j)\\n        {\\n            mp[nums[j]]++;\\n            \\n            if(mp[nums[j]]==2)\\n            {\\n                length+=2;\\n            }\\n            else if(mp[nums[j]]>2)\\n            {\\n                length++;\\n            }\\n            \\n            ans=min(ans,k+length+dp[j+1]);\\n        }\\n            dp[i]=ans;\\n    \\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086389,
                "title": "javascript-simple-dynamicprogramming-7lines-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nvar minCost = function(nums, k) {\\n    const n = nums.length, dp = Array(n + 1).fill(Infinity);\\n\\n    dp[0] = 0;\\n    for (let i = 0; i < n; i++) {\\n        const freq = Array(n + 1).fill(0);\\n        for (let j = i, trimmedLength = 0; j >= 0; j--) {\\n            trimmedLength += (++freq[nums[j]] > 1) + (freq[nums[j]] == 2);\\n            dp[i + 1] = Math.min(dp[i + 1], dp[j] + k + trimmedLength);\\n        }\\n    }\\n\\n    return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minCost = function(nums, k) {\\n    const n = nums.length, dp = Array(n + 1).fill(Infinity);\\n\\n    dp[0] = 0;\\n    for (let i = 0; i < n; i++) {\\n        const freq = Array(n + 1).fill(0);\\n        for (let j = i, trimmedLength = 0; j >= 0; j--) {\\n            trimmedLength += (++freq[nums[j]] > 1) + (freq[nums[j]] == 2);\\n            dp[i + 1] = Math.min(dp[i + 1], dp[j] + k + trimmedLength);\\n        }\\n    }\\n\\n    return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3086177,
                "title": "c-dp-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1002];\\n    int solve(int idx,vector<int>& nums,int k)\\n    {\\n        if(idx==nums.size())\\n            return 0;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        vector<int> m(1002),flg(1002);\\n        int cnt=0;\\n        int ans=INT_MAX;\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            cnt++;\\n            if(m[nums[i]]==1)\\n            {\\n                if(flg[nums[i]]==0)\\n                {\\n                    cnt-=2;\\n                    flg[nums[i]]=1;\\n                }\\n                else\\n                cnt--;\\n            }\\n            m[nums[i]]=1;\\n            int importance = ((i-idx)+1)-cnt;\\n            int tmp = importance+k;\\n            if(dp[i+1]!=-1)\\n                tmp+=dp[i+1];\\n            else\\n            tmp+= solve(i+1,nums,k);\\n            ans = min(ans,tmp);\\n        }\\n        return dp[idx]=ans;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1002];\\n    int solve(int idx,vector<int>& nums,int k)\\n    {\\n        if(idx==nums.size())\\n            return 0;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        vector<int> m(1002),flg(1002);\\n        int cnt=0;\\n        int ans=INT_MAX;\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            cnt++;\\n            if(m[nums[i]]==1)\\n            {\\n                if(flg[nums[i]]==0)\\n                {\\n                    cnt-=2;\\n                    flg[nums[i]]=1;\\n                }\\n                else\\n                cnt--;\\n            }\\n            m[nums[i]]=1;\\n            int importance = ((i-idx)+1)-cnt;\\n            int tmp = importance+k;\\n            if(dp[i+1]!=-1)\\n                tmp+=dp[i+1];\\n            else\\n            tmp+= solve(i+1,nums,k);\\n            ans = min(ans,tmp);\\n        }\\n        return dp[idx]=ans;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085938,
                "title": "java-recursion-cache-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) at worst cases\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2) at worst cases\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return go(nums, 0, k, dp);\\n    }\\n\\n    private int go(int[] nums, int idx, int k, int[] dp) {\\n        if(idx >= nums.length) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        Set<Integer> single = new HashSet<>();\\n        Set<Integer> dbs = new HashSet<>();\\n        int ans = 0;\\n        int min = Integer.MAX_VALUE;\\n        for(int i = idx; i < nums.length; i++) {\\n          if(dbs.contains(nums[i])) {\\n              ans++;\\n          }\\n          else if(single.contains(nums[i])) {\\n              ans += 2;\\n              dbs.add(nums[i]);\\n          }\\n          else single.add(nums[i]);\\n          min = Math.min(min, k + ans + go(nums, i + 1, k, dp));\\n        }\\n        return dp[idx] = min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return go(nums, 0, k, dp);\\n    }\\n\\n    private int go(int[] nums, int idx, int k, int[] dp) {\\n        if(idx >= nums.length) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        Set<Integer> single = new HashSet<>();\\n        Set<Integer> dbs = new HashSet<>();\\n        int ans = 0;\\n        int min = Integer.MAX_VALUE;\\n        for(int i = idx; i < nums.length; i++) {\\n          if(dbs.contains(nums[i])) {\\n              ans++;\\n          }\\n          else if(single.contains(nums[i])) {\\n              ans += 2;\\n              dbs.add(nums[i]);\\n          }\\n          else single.add(nums[i]);\\n          min = Math.min(min, k + ans + go(nums, i + 1, k, dp));\\n        }\\n        return dp[idx] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085696,
                "title": "c-mcm-pattern-o-n-2",
                "content": "# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    vector<ll> dp;\\n    vector<vector<int>> cnt;\\n    int k,n;\\n    ll solve(int idx){\\n        if(idx==n) return 0;\\n        if(dp[idx]!=-1) return dp[idx];\\n        dp[idx]=INT_MAX;\\n        \\n        for(int i=idx+1;i<=n;i++){\\n            // piece of crap 2^n complexity\\n            // int x=0;\\n            // unordered_map<int,int> mp;\\n            // for(int j=idx;j<i;j++){\\n            //    mp[nums[j]]++;\\n            // }\\n            // for(auto &[a,b]: mp) if(b>1) x+=b;\\n            \\n            int x=cnt[idx][i-1];\\n            dp[idx]=min(dp[idx],k+x+solve(i));\\n        }\\n        return dp[idx];\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        n=nums.size();\\n        this->nums=nums;\\n        this->k=k;\\n        dp=vector<ll>(n+1,-1);\\n        \\n        //storing trimmed length for every subarray \\n        cnt=vector<vector<int>>(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            vector<int> mp(1001,0);\\n            int count=0;\\n            for(int j=i;j<n;j++){\\n                if(mp[nums[j]]==1) count+=2;\\n                else if(mp[nums[j]]) count++;\\n\\n                mp[nums[j]]++;\\n                cnt[i][j]=count;\\n            }\\n        }\\n        \\n        return solve(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    vector<ll> dp;\\n    vector<vector<int>> cnt;\\n    int k,n;\\n    ll solve(int idx){\\n        if(idx==n) return 0;\\n        if(dp[idx]!=-1) return dp[idx];\\n        dp[idx]=INT_MAX;\\n        \\n        for(int i=idx+1;i<=n;i++){\\n            // piece of crap 2^n complexity\\n            // int x=0;\\n            // unordered_map<int,int> mp;\\n            // for(int j=idx;j<i;j++){\\n            //    mp[nums[j]]++;\\n            // }\\n            // for(auto &[a,b]: mp) if(b>1) x+=b;\\n            \\n            int x=cnt[idx][i-1];\\n            dp[idx]=min(dp[idx],k+x+solve(i));\\n        }\\n        return dp[idx];\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        n=nums.size();\\n        this->nums=nums;\\n        this->k=k;\\n        dp=vector<ll>(n+1,-1);\\n        \\n        //storing trimmed length for every subarray \\n        cnt=vector<vector<int>>(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            vector<int> mp(1001,0);\\n            int count=0;\\n            for(int j=i;j<n;j++){\\n                if(mp[nums[j]]==1) count+=2;\\n                else if(mp[nums[j]]) count++;\\n\\n                mp[nums[j]]++;\\n                cnt[i][j]=count;\\n            }\\n        }\\n        \\n        return solve(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085624,
                "title": "simple-pick-not-pick-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int recur(vector<int>& nums,int n,int k,int i,int j,int pre[][1001]){\\n        if(j==n-1)\\n            return pre[i][j]+k;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int pick=recur(nums,n,k,j+1,j+1,pre)+pre[i][j]+k;\\n        int not_pick=recur(nums,n,k,i,j+1,pre);\\n        return dp[i][j]=min(pick,not_pick);\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=nums.size();\\n        int pre[1001][1001];\\n        memset(pre,0,sizeof(pre));\\n        for(int i=0;i<n;i++){\\n            unordered_map<int,int>mp;\\n            int cnt=0;\\n            for(int j=i;j<n;j++){\\n                mp[nums[j]]++;\\n                if(mp[nums[j]]==2)\\n                    cnt+=2;\\n                else if(mp[nums[j]]>2)\\n                    cnt++;\\n                pre[i][j]=cnt;\\n            }\\n        }\\n        return recur(nums,n,k,0,0,pre);\\n    }\\n};\\n```\\n\\nThis is similar to Knapsack Problem, here the 2 choices are:\\n1)Split Subarray from (i,j) and start splitting from (j+1,j+1)\\n2)Include j+1th element in Subarray (i,j) and call recursive function again to check for these 2 conditions for (i,j+1)\\n\\nThen as far as implementation goes, we can pre-process length of every trimmed subarray from (0,0) to (n-1,n-1) to reduce complexity from n^3 to n^2. Then,it is starightforward DP problem.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int recur(vector<int>& nums,int n,int k,int i,int j,int pre[][1001]){\\n        if(j==n-1)\\n            return pre[i][j]+k;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int pick=recur(nums,n,k,j+1,j+1,pre)+pre[i][j]+k;\\n        int not_pick=recur(nums,n,k,i,j+1,pre);\\n        return dp[i][j]=min(pick,not_pick);\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=nums.size();\\n        int pre[1001][1001];\\n        memset(pre,0,sizeof(pre));\\n        for(int i=0;i<n;i++){\\n            unordered_map<int,int>mp;\\n            int cnt=0;\\n            for(int j=i;j<n;j++){\\n                mp[nums[j]]++;\\n                if(mp[nums[j]]==2)\\n                    cnt+=2;\\n                else if(mp[nums[j]]>2)\\n                    cnt++;\\n                pre[i][j]=cnt;\\n            }\\n        }\\n        return recur(nums,n,k,0,0,pre);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085616,
                "title": "simplest-c-bottom-up-dp-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is based on bottom up dp\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCode is self explainatory with comments. \\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    int minCost(vector<int> nums, int k) {\\n       //bottom up solution\\n        int n=nums.size();\\n        int cnt[1001][1001];  // It stores the trimmed length from index i to j inclusive\\n\\n        //it fills the cnt\\n        for(int i=0;i<n;i++){\\n            unordered_map<int,int> mp;\\n            int len=0;\\n            for(int j=i;j<n;j++){\\n                len += (mp[nums[j]] == 1)*2 + (mp[nums[j]] >1)*1;\\n                mp[nums[j]]++;\\n                cnt[i][j] = len;\\n            }\\n        }\\n        \\n        int dp[1001];\\n        dp[0] = k;\\n\\n        //It is basically bottom up dp, dp[i] means minimum cost for subarray 0 to i. \\n        //For every i we are finding the position of the start of the last subarray for the subarray [0,i] while minimizing cost\\n        for(int i=0;i<n;i++){\\n            dp[i] = cnt[0][i]+k;\\n            for(int j=0;j<i;j++){\\n                dp[i] = min(dp[i], dp[j] + cnt[j+1][i]+k);\\n            }\\n        }\\n\\n\\n        return dp[n-1];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    int minCost(vector<int> nums, int k) {\\n       //bottom up solution\\n        int n=nums.size();\\n        int cnt[1001][1001];  // It stores the trimmed length from index i to j inclusive\\n\\n        //it fills the cnt\\n        for(int i=0;i<n;i++){\\n            unordered_map<int,int> mp;\\n            int len=0;\\n            for(int j=i;j<n;j++){\\n                len += (mp[nums[j]] == 1)*2 + (mp[nums[j]] >1)*1;\\n                mp[nums[j]]++;\\n                cnt[i][j] = len;\\n            }\\n        }\\n        \\n        int dp[1001];\\n        dp[0] = k;\\n\\n        //It is basically bottom up dp, dp[i] means minimum cost for subarray 0 to i. \\n        //For every i we are finding the position of the start of the last subarray for the subarray [0,i] while minimizing cost\\n        for(int i=0;i<n;i++){\\n            dp[i] = cnt[0][i]+k;\\n            for(int j=0;j<i;j++){\\n                dp[i] = min(dp[i], dp[j] + cnt[j+1][i]+k);\\n            }\\n        }\\n\\n\\n        return dp[n-1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085584,
                "title": "can-anyone-explain-why-this-solution-is-tle",
                "content": "This solution has a time complexity of O(N^2) according to me. But n<=1000 so this solution should be accepted but still it is giving tle.\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[1005][1005];\\n    int store[1005][1005];\\n    ll fix;\\n    ll rec(vector<int> &v,int prev,int i){\\n        if(i==v.size()-1){\\n            return store[prev][i]+fix;\\n        }\\n        if(dp[prev][i]!=-1) return dp[prev][i];\\n        return dp[prev][i] = min(rec(v, prev, i + 1), fix + store[prev][i] + rec(v, i + 1, i + 1));\\n    }\\n\\n\\n\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n==1) return 0;\\n        memset(dp,-1,sizeof(dp));\\n        memset(store,0,sizeof(store));\\n        for (int i = 0; i < nums.size();i++){\\n            map<int, int> m;\\n            int c = 1;\\n            m[nums[i]]=1;\\n            for (int j = i + 1; j < nums.size();j++){\\n                if(m.find(nums[j])!=m.end()){\\n                    if(m[nums[j]]==1) c--;\\n                    m[nums[j]]++;\\n                    store[i][j] = (j - i + 1 - c);;\\n                }\\n                else{\\n                    m[nums[j]] = 1;\\n                    c++;\\n                    store[i][j] = (j - i + 1 - c);;\\n                }\\n            }\\n        }\\n        fix=k;\\n        int ans=(int)rec(nums,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[1005][1005];\\n    int store[1005][1005];\\n    ll fix;\\n    ll rec(vector<int> &v,int prev,int i){\\n        if(i==v.size()-1){\\n            return store[prev][i]+fix;\\n        }\\n        if(dp[prev][i]!=-1) return dp[prev][i];\\n        return dp[prev][i] = min(rec(v, prev, i + 1), fix + store[prev][i] + rec(v, i + 1, i + 1));\\n    }\\n\\n\\n\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n==1) return 0;\\n        memset(dp,-1,sizeof(dp));\\n        memset(store,0,sizeof(store));\\n        for (int i = 0; i < nums.size();i++){\\n            map<int, int> m;\\n            int c = 1;\\n            m[nums[i]]=1;\\n            for (int j = i + 1; j < nums.size();j++){\\n                if(m.find(nums[j])!=m.end()){\\n                    if(m[nums[j]]==1) c--;\\n                    m[nums[j]]++;\\n                    store[i][j] = (j - i + 1 - c);;\\n                }\\n                else{\\n                    m[nums[j]] = 1;\\n                    c++;\\n                    store[i][j] = (j - i + 1 - c);;\\n                }\\n            }\\n        }\\n        fix=k;\\n        int ans=(int)rec(nums,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085564,
                "title": "simplest-recursion-memoization-version-among-all",
                "content": "class Solution {\\npublic int minCost(int[] nums, int k) {\\n\\n    int []dp=new int[nums.length+1];\\n    Arrays.fill(dp,-1);\\n    return f(0,nums,k,dp);\\n}\\n\\n\\n**public static int f(int ind,int nums[],int k,int dp[]){**\\n\\n    if(ind>=nums.length){\\n        return 0;\\n    }\\n    if(dp[ind] != -1){\\n        return dp[ind];\\n    }\\n    \\n    int min = Integer.MAX_VALUE;\\n    // hashmap for calculating the occurrences\\n    HashMap<Integer,Integer> map = new HashMap<>();\\n    int ones = 0;\\n    for (int i = ind; i < nums.length; i++) {\\n        \\n       // calculating the total length\\n        int len = i - ind + 1;\\n        \\n       // calculating the occurrences\\n        map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        \\n       // will increase the count of ones(number of elements having occurrence exactly ones) whenever we get the occurrence of an element as one.\\n        if(map.get(nums[i]) == 1){\\n            ones++;\\n        }\\n      //Reduce the count of ones whenever we encounter an element whose occurrence earlier was 1 but now it\\'s 2.\\n        else if(map.get(nums[i])==2){\\n            ones--;\\n        }\\n        // calculating the total cost\\n        int cost = len - ones + k;\\n        // taking minimum among all the possible answers\\n        min = Math.min(min , f(i+1,nums,k,dp) +  cost ) ;\\n        \\n    }\\n ***// storing result into DP for memoization***\\n   **return dp[ind] = min;**\\n}\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic int minCost(int[] nums, int k) {\\n\\n    int []dp=new int[nums.length+1];\\n    Arrays.fill(dp,-1);\\n    return f(0,nums,k,dp);\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3085545,
                "title": "python-top-down-dp-o-n-2",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nfrom functools import cache\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        @cache\\n        def dfs(i):\\n            if i == n: \\n                return 0\\n            res = float(\\'inf\\')\\n            counter = defaultdict(int)\\n            curval = 0\\n            for j in range(i, n):\\n                counter[nums[j]] += 1\\n                if counter[nums[j]] == 2:\\n                    curval += 2\\n                elif counter[nums[j]] > 2:\\n                    curval += 1\\n                res = min(res, k + curval + dfs(j + 1))\\n            return res\\n        return dfs(0)\\n                    \\n                \\n                \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom functools import cache\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        @cache\\n        def dfs(i):\\n            if i == n: \\n                return 0\\n            res = float(\\'inf\\')\\n            counter = defaultdict(int)\\n            curval = 0\\n            for j in range(i, n):\\n                counter[nums[j]] += 1\\n                if counter[nums[j]] == 2:\\n                    curval += 2\\n                elif counter[nums[j]] > 2:\\n                    curval += 1\\n                res = min(res, k + curval + dfs(j + 1))\\n            return res\\n        return dfs(0)\\n                    \\n                \\n                \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085460,
                "title": "java-solution-dfs-hashmap-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        // dfs + hashmap + dp\\n        int n = nums.length;\\n        int[][] dp = new int[n][n]; // dp[i][j] means cal[i..j] = k + trimmed([i..j]).length\\n        for (int i=0; i<n; i++) {\\n            int[] map = new int[1000];\\n            for (int j=i; j<n; j++) {\\n                if (i == j) dp[i][j] = k;\\n                else if (map[nums[j]] == 0) dp[i][j] = dp[i][j-1];\\n                else if (map[nums[j]] == 1) dp[i][j] = dp[i][j-1] + 2;\\n                else dp[i][j] = dp[i][j-1] + 1;\\n                map[nums[j]]++;\\n            }\\n        }\\n        // dp - find jump combination, to make [a..b] + [b..c] + [c..d] + [d..e] the minimum\\n        int[] res = new int[n]; // res[0..i] means min from 0 to i\\n        for (int i=0; i<n; i++) {\\n            res[i] = dp[0][i];\\n            for (int j=0; j<i; j++) res[i] = Math.min(res[i], res[j] + dp[j+1][i]);\\n        }\\n        return res[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        // dfs + hashmap + dp\\n        int n = nums.length;\\n        int[][] dp = new int[n][n]; // dp[i][j] means cal[i..j] = k + trimmed([i..j]).length\\n        for (int i=0; i<n; i++) {\\n            int[] map = new int[1000];\\n            for (int j=i; j<n; j++) {\\n                if (i == j) dp[i][j] = k;\\n                else if (map[nums[j]] == 0) dp[i][j] = dp[i][j-1];\\n                else if (map[nums[j]] == 1) dp[i][j] = dp[i][j-1] + 2;\\n                else dp[i][j] = dp[i][j-1] + 1;\\n                map[nums[j]]++;\\n            }\\n        }\\n        // dp - find jump combination, to make [a..b] + [b..c] + [c..d] + [d..e] the minimum\\n        int[] res = new int[n]; // res[0..i] means min from 0 to i\\n        for (int i=0; i<n; i++) {\\n            res[i] = dp[0][i];\\n            for (int j=0; j<i; j++) res[i] = Math.min(res[i], res[j] + dp[j+1][i]);\\n        }\\n        return res[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085223,
                "title": "java-100-faster-solution-bottom-up-dp",
                "content": "# Intuition\\n- Running the Two Loop Same as we Use to Generate Subarrays of an Array\\n- Keeping Track of Frequencies of Each Element When Generating New Combination of Splits\\n- Keep Track of Minimum Cost.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(maxElementSize) to keep Track of Frequencies on each Iteration\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] values, int k) {\\n        int n = values.length;\\n        int dp[] = new int[n+1];\\n        dp[n] = 0;\\n        int maxElement = Arrays.stream(values).max().getAsInt();\\n        for(int i = n-1; i>=0; i--) {\\n            int[] freq = new int[maxElement+1];\\n            int min = Integer.MAX_VALUE;\\n            int temp = 0;\\n            int cost = 0;\\n            for(int j = i; j<n; j++) {\\n                if(freq[values[j]]==1) {\\n                    temp+=1;\\n                }\\n                freq[values[j]]++;\\n                if(freq[values[j]]>1) {\\n                    cost+=1;\\n                }\\n                min = Math.min(min,temp+cost+((j + 1 < n) ? k : 0)+dp[j+1]);\\n            }\\n            dp[i]=min;\\n        }\\n        return dp[0]+k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] values, int k) {\\n        int n = values.length;\\n        int dp[] = new int[n+1];\\n        dp[n] = 0;\\n        int maxElement = Arrays.stream(values).max().getAsInt();\\n        for(int i = n-1; i>=0; i--) {\\n            int[] freq = new int[maxElement+1];\\n            int min = Integer.MAX_VALUE;\\n            int temp = 0;\\n            int cost = 0;\\n            for(int j = i; j<n; j++) {\\n                if(freq[values[j]]==1) {\\n                    temp+=1;\\n                }\\n                freq[values[j]]++;\\n                if(freq[values[j]]>1) {\\n                    cost+=1;\\n                }\\n                min = Math.min(min,temp+cost+((j + 1 < n) ? k : 0)+dp[j+1]);\\n            }\\n            dp[i]=min;\\n        }\\n        return dp[0]+k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085196,
                "title": "c-dp-solution-similar-to-palindrome-partitioning-o-n-2",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int start, int k, vector<int>&nums, vector<int>&dp){\\n        if(start == nums.size())return 0;\\n        if(dp[start]!=-1)return dp[start];\\n\\n        int ans = INT_MAX, mini = INT_MAX, freq[1001] = {0},val = k;\\n        for(int i=start;i<nums.size();i++){\\n            if(freq[nums[i]] == 1)val+=2;\\n            if(freq[nums[i]]>1)val++;\\n            freq[nums[i]]++;\\n            ans = min(ans,val + solve(i+1,k,nums,dp));\\n        }\\n\\n        return dp[start] = ans;\\n    }\\n\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int>dp(n,-1);\\n        return solve(0,k,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int start, int k, vector<int>&nums, vector<int>&dp){\\n        if(start == nums.size())return 0;\\n        if(dp[start]!=-1)return dp[start];\\n\\n        int ans = INT_MAX, mini = INT_MAX, freq[1001] = {0},val = k;\\n        for(int i=start;i<nums.size();i++){\\n            if(freq[nums[i]] == 1)val+=2;\\n            if(freq[nums[i]]>1)val++;\\n            freq[nums[i]]++;\\n            ans = min(ans,val + solve(i+1,k,nums,dp));\\n        }\\n\\n        return dp[start] = ans;\\n    }\\n\\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int>dp(n,-1);\\n        return solve(0,k,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085056,
                "title": "java-solution-using-memoization",
                "content": "int dp[]=new int[nums.length];\\n        Arrays.fill(dp,-1);\\n         return helper(0,nums,k,dp);\\n    }\\n    public int helper(int index,int nums[],int k,int dp[]){\\n        if(index>=nums.length){\\n            return 0;\\n        }\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        int minCost=Integer.MAX_VALUE;\\n        int freq[]=new int[nums.length];\\n        int size=0;\\n        for(int i=index;i<nums.length;i++){\\n            freq[nums[i]]++;\\n            if(freq[nums[i]]==2){\\n                size+=2;\\n            }\\n            else if(freq[nums[i]]>2){\\n                size++;\\n            }\\n            int cost=size+k+helper(i+1,nums,k,dp);\\n            minCost=Math.min(cost,minCost);\\n        }\\n        return dp[index]=minCost;",
                "solutionTags": [],
                "code": "int dp[]=new int[nums.length];\\n        Arrays.fill(dp,-1);\\n         return helper(0,nums,k,dp);\\n    }\\n    public int helper(int index,int nums[],int k,int dp[]){\\n        if(index>=nums.length){\\n            return 0;\\n        }\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        int minCost=Integer.MAX_VALUE;\\n        int freq[]=new int[nums.length];\\n        int size=0;\\n        for(int i=index;i<nums.length;i++){\\n            freq[nums[i]]++;\\n            if(freq[nums[i]]==2){\\n                size+=2;\\n            }\\n            else if(freq[nums[i]]>2){\\n                size++;\\n            }\\n            int cost=size+k+helper(i+1,nums,k,dp);\\n            minCost=Math.min(cost,minCost);\\n        }\\n        return dp[index]=minCost;",
                "codeTag": "Unknown"
            },
            {
                "id": 3084994,
                "title": "rust-dp-solution",
                "content": "# Approach\\n1. Calculate all `trimmed(subarray).length`.\\n2. Find minimum cost to split an array by using DP.\\n`dp[i] = dp[i].min(dp[j] + trimmed(array[j+1..=i]).length + k)` in `0 < j < i <= n`\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn min_cost(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = nums.len();\\n        let mut trimmed = vec![vec![0; n + 1]; n + 1];\\n        for i in 1..=n {\\n            let mut count = HashMap::new();\\n            for j in i..=n {\\n                trimmed[i][j] = trimmed[i][j - 1];\\n                let c = count.entry(nums[j - 1]).or_insert(0);\\n                *c += 1;\\n                if *c == 2 {\\n                    trimmed[i][j] += 2;\\n                } else if *c > 2 {\\n                    trimmed[i][j] += 1;\\n                }\\n            }\\n        }\\n        let mut dp = vec![i32::MAX; n + 1];\\n        dp[0] = 0;\\n        for i in 1..=n {\\n            for j in 0..i {\\n                dp[i] = dp[i].min(dp[j] + trimmed[j + 1][i] + k);\\n            }\\n        }\\n        dp[n]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn min_cost(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = nums.len();\\n        let mut trimmed = vec![vec![0; n + 1]; n + 1];\\n        for i in 1..=n {\\n            let mut count = HashMap::new();\\n            for j in i..=n {\\n                trimmed[i][j] = trimmed[i][j - 1];\\n                let c = count.entry(nums[j - 1]).or_insert(0);\\n                *c += 1;\\n                if *c == 2 {\\n                    trimmed[i][j] += 2;\\n                } else if *c > 2 {\\n                    trimmed[i][j] += 1;\\n                }\\n            }\\n        }\\n        let mut dp = vec![i32::MAX; n + 1];\\n        dp[0] = 0;\\n        for i in 1..=n {\\n            for j in 0..i {\\n                dp[i] = dp[i].min(dp[j] + trimmed[j + 1][i] + k);\\n            }\\n        }\\n        dp[n]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3084803,
                "title": "c-dynamic-programming-hashmap-easy-to-understand-recursion-memoization",
                "content": "**Approach:** First Calculate the Cost for every subarray and store it \\nThen Perform the Recursion Call with memoization and Store the Optimal Cost\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<ll>> cost(n , vector<ll>(n, 0));\\n        \\n        // PreCompute Cost for every Subarray\\n        \\n        for(int i=0; i < n; i++){\\n            unordered_map<int,int> mp;\\n            ll cnt = 0;\\n            \\n            for(int j= i; j < n; j++){\\n                \\n                mp[nums[j]]++;\\n                \\n                // If the number is Occuring only 1 time then it will be removed in the trimmed(subarray)\\n                \\n                if(mp[nums[j]] > 1){\\n                    if(mp[nums[j]] == 2) cnt += 2;\\n                    \\n                    else cnt++;\\n                    \\n                }\\n                \\n                // cnt is the total count of numbers that is that appears more than ones in this subarray \\n                cost[i][j] = cnt + k;\\n            }\\n        }\\n        \\n        vector<vector<ll>> dp(n , vector<ll> (n , -1));\\n        helper(0, n-1, cost, dp );\\n        return (int)dp[0][n-1];\\n    }\\n    \\n    ll helper(int i , int j ,  vector<vector<ll>> &cost , vector<vector<ll>> &dp   ){\\n        \\n        if(i > j ) return 0;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n            \\n        ll ans = 1e18;\\n        for(int idx = i; idx <= j; idx++){\\n            ans = min(ans , cost[i][idx] + helper(idx + 1 , j  , cost , dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/3d739321-7ada-4f68-bff5-ddcd2432a014_1674371029.1625516.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<ll>> cost(n , vector<ll>(n, 0));\\n        \\n        // PreCompute Cost for every Subarray\\n        \\n        for(int i=0; i < n; i++){\\n            unordered_map<int,int> mp;\\n            ll cnt = 0;\\n            \\n            for(int j= i; j < n; j++){\\n                \\n                mp[nums[j]]++;\\n                \\n                // If the number is Occuring only 1 time then it will be removed in the trimmed(subarray)\\n                \\n                if(mp[nums[j]] > 1){\\n                    if(mp[nums[j]] == 2) cnt += 2;\\n                    \\n                    else cnt++;\\n                    \\n                }\\n                \\n                // cnt is the total count of numbers that is that appears more than ones in this subarray \\n                cost[i][j] = cnt + k;\\n            }\\n        }\\n        \\n        vector<vector<ll>> dp(n , vector<ll> (n , -1));\\n        helper(0, n-1, cost, dp );\\n        return (int)dp[0][n-1];\\n    }\\n    \\n    ll helper(int i , int j ,  vector<vector<ll>> &cost , vector<vector<ll>> &dp   ){\\n        \\n        if(i > j ) return 0;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n            \\n        ll ans = 1e18;\\n        for(int idx = i; idx <= j; idx++){\\n            ans = min(ans , cost[i][idx] + helper(idx + 1 , j  , cost , dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084791,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        vector<int>dp(n,INT_MAX);\\n\\n        dp[0]=k;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n             vector<int>mp(1001,0);\\n             \\n             int len=0;\\n             for(int j=i;j>=0;j--)\\n             {\\n                 \\n                 mp[nums[j]]++;\\n                 if(mp[nums[j]]==2)\\n                 len+=2;\\n                 else if(mp[nums[j]]>2)\\n                 len+=1;\\n\\n                 if(j-1>=0)\\n                 {\\n                     dp[i]= min(dp[i],dp[j-1]+len+k);\\n                 }\\n                 else\\n                 {\\n                     dp[i]= min(dp[i],len+k);\\n                 } \\n             }\\n        }\\n\\n       return dp[n-1];     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        vector<int>dp(n,INT_MAX);\\n\\n        dp[0]=k;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n             vector<int>mp(1001,0);\\n             \\n             int len=0;\\n             for(int j=i;j>=0;j--)\\n             {\\n                 \\n                 mp[nums[j]]++;\\n                 if(mp[nums[j]]==2)\\n                 len+=2;\\n                 else if(mp[nums[j]]>2)\\n                 len+=1;\\n\\n                 if(j-1>=0)\\n                 {\\n                     dp[i]= min(dp[i],dp[j-1]+len+k);\\n                 }\\n                 else\\n                 {\\n                     dp[i]= min(dp[i],len+k);\\n                 } \\n             }\\n        }\\n\\n       return dp[n-1];     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084774,
                "title": "memoization",
                "content": "```\\nclass Solution{\\n    public:\\n    int dp[1001];\\nint solve(int k, vector<int> &arr, int i, int n)\\n{\\n    if (i == n)\\n    {\\n        return 0;\\n    }\\nif(dp[i]!=-1){\\n    return dp[i];\\n}\\n    unordered_map<int, int> mp;\\n    int ans = INT_MAX;\\n    int co = 0;\\n    for (int j = i; j < n; j++)\\n    {\\n        mp[arr[j]]++;\\n        if (mp[arr[j]] == 2)\\n        {\\n            co += 2;\\n        }\\n        if (mp[arr[j]] > 2)\\n        {\\n            co++;\\n        }\\n\\n        ans = min(ans, k + solve(k, arr, j + 1, n) + co);\\n    }\\n\\n    return dp[i]=ans;\\n}\\n\\nint minCost(vector<int> &arr, int k)\\n{\\n    int n = arr.size();\\nmemset(dp,-1,sizeof(dp));\\n    return solve(k, arr,0, n);\\n}};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public:\\n    int dp[1001];\\nint solve(int k, vector<int> &arr, int i, int n)\\n{\\n    if (i == n)\\n    {\\n        return 0;\\n    }\\nif(dp[i]!=-1){\\n    return dp[i];\\n}\\n    unordered_map<int, int> mp;\\n    int ans = INT_MAX;\\n    int co = 0;\\n    for (int j = i; j < n; j++)\\n    {\\n        mp[arr[j]]++;\\n        if (mp[arr[j]] == 2)\\n        {\\n            co += 2;\\n        }\\n        if (mp[arr[j]] > 2)\\n        {\\n            co++;\\n        }\\n\\n        ans = min(ans, k + solve(k, arr, j + 1, n) + co);\\n    }\\n\\n    return dp[i]=ans;\\n}\\n\\nint minCost(vector<int> &arr, int k)\\n{\\n    int n = arr.size();\\nmemset(dp,-1,sizeof(dp));\\n    return solve(k, arr,0, n);\\n}};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084700,
                "title": "c-easy-to-understand-pre-computation-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int store[1001][1001];\\n    int memo[1001];\\n    int fun(int i,int n,int k,vector<int> &nums)\\n    {\\n        if(i>=n)\\n        return 0;\\n        int mini=INT_MAX;\\n        if(memo[i]!=-1)\\n        return memo[i];\\n        for(int j=i;j<n;j++)\\n        {\\n            int imp=store[i][j]+k+fun(j+1,n,k,nums);\\n            mini=min(mini,imp);\\n        }\\n        return memo[i]=mini;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        memset(memo,-1,sizeof(memo));\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp.clear();\\n            int val=0;\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n                if(mp[nums[j]]==2)\\n                {\\n                    val+=2;\\n                }\\n                else if(mp[nums[j]]>2)\\n                {\\n                    val++;\\n                }\\n                store[i][j]=val;\\n            }   \\n        }\\n        return fun(0,n,k,nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int store[1001][1001];\\n    int memo[1001];\\n    int fun(int i,int n,int k,vector<int> &nums)\\n    {\\n        if(i>=n)\\n        return 0;\\n        int mini=INT_MAX;\\n        if(memo[i]!=-1)\\n        return memo[i];\\n        for(int j=i;j<n;j++)\\n        {\\n            int imp=store[i][j]+k+fun(j+1,n,k,nums);\\n            mini=min(mini,imp);\\n        }\\n        return memo[i]=mini;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        memset(memo,-1,sizeof(memo));\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp.clear();\\n            int val=0;\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n                if(mp[nums[j]]==2)\\n                {\\n                    val+=2;\\n                }\\n                else if(mp[nums[j]]>2)\\n                {\\n                    val++;\\n                }\\n                store[i][j]=val;\\n            }   \\n        }\\n        return fun(0,n,k,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084687,
                "title": "bottom-up-dp-easy-c-v",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLooking at the time constraints the first thing that strikes me is using dyanamic programming approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->The time complexity of this solution is O(N^2) as it iterates through the entire array twice: once for the outer loop (i) and once for the inner loop (j). \\n\\n\\n\\n\\n- Space complexity:\\n- The space complexity is $$O(n)$$ as it uses an additional array of size N to store the minimum cost of partitioning each subarray.\\n<!-- Add your space complexity here, e.g.  -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    const long long MAX=1e14;\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int N=nums.size();\\n        vector<long long> dp(N+1,MAX);\\n        dp[N]=0;\\n        dp[N-1]=k;\\n\\n        for(int i=N-1;i>=0;i--){\\n            unordered_map<int,int> hmp;\\n            int count=0;\\n            \\n            for(int j=i;j<N;j++){\\n                \\n                int x=nums[j];\\n                if(hmp[x]>0){\\n                    if(hmp[x]==1) count+=2;\\n                    else count++;\\n                }\\n                hmp[x]++;\\n                dp[i]=min(dp[i],count+k+dp[j+1]);\\n            }\\n            \\n        }\\n        \\n        for(auto x:dp) cout<<x<<\" \";\\n\\n        return dp[0];\\n    }\\n};\\n\\n// [1,2,1,2,1] k=5\\n// [5]\\n//    1,2,1,2,1,3,3]\\n// dp[i]--> mininmum val for partition for subarray[i----n-1]\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    const long long MAX=1e14;\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int N=nums.size();\\n        vector<long long> dp(N+1,MAX);\\n        dp[N]=0;\\n        dp[N-1]=k;\\n\\n        for(int i=N-1;i>=0;i--){\\n            unordered_map<int,int> hmp;\\n            int count=0;\\n            \\n            for(int j=i;j<N;j++){\\n                \\n                int x=nums[j];\\n                if(hmp[x]>0){\\n                    if(hmp[x]==1) count+=2;\\n                    else count++;\\n                }\\n                hmp[x]++;\\n                dp[i]=min(dp[i],count+k+dp[j+1]);\\n            }\\n            \\n        }\\n        \\n        for(auto x:dp) cout<<x<<\" \";\\n\\n        return dp[0];\\n    }\\n};\\n\\n// [1,2,1,2,1] k=5\\n// [5]\\n//    1,2,1,2,1,3,3]\\n// dp[i]--> mininmum val for partition for subarray[i----n-1]\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3084568,
                "title": "1-d-dynamic-programming-c-o-n-2",
                "content": "int val[1001][1001];\\nclass Solution {\\npublic:\\n    int dp[1010];\\n    int n;\\n    // Recursive dp code will not work shit! what is the problem with recursive\\n    // int rec(int level) {\\n    //     if (level == n)return 0;\\n    //     if (dp[level] != -1)return dp[level];\\n    //     int ans = INT_MAX;\\n    //     for (int i = level; i < n; i++) {\\n    //         ans = min(ans, rec(i + 1) + val[level][i]);\\n    //     }\\n    //     return dp[level] = ans;\\n    // }\\n\\n    int minCost(vector<int>& nums, int k) {\\n        n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            unordered_map<int, int>m;\\n            vector<int>t;\\n            int preq = 0;\\n            for (int j = i; j < n; j++) {\\n                m[nums[j]]++;\\n                if (m[nums[j]] > 1) {\\n                    if (m[nums[j]] == 2)preq++;\\n                    t.push_back(nums[j]);\\n                }\\n                val[i][j] = k + t.size() + preq;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            dp[i] = INT_MAX;\\n        }\\n        dp[n] = 0;\\n        for(int i=n-1;i>=0;i--){\\n            dp[i] = min(dp[i],val[i][n-1]);\\n            for(int j=i;j<n;j++){\\n                dp[i] = min(dp[i],val[i][j]+dp[j+1]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[1010];\\n    int n;\\n    // Recursive dp code will not work shit! what is the problem with recursive\\n    // int rec(int level) {\\n    //     if (level == n)return 0;\\n    //     if (dp[level] != -1)return dp[level];\\n    //     int ans = INT_MAX;\\n    //     for (int i = level; i < n; i++) {\\n    //         ans = min(ans, rec(i + 1) + val[level][i]);\\n    //     }",
                "codeTag": "Java"
            },
            {
                "id": 3084497,
                "title": "c-top-down-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nWe first store the lengths of all the split values for all possibilities.\\nOr we can say for every substring from i->j we are storing the lengths of the substring accdring to \\nthe given condition in the problem.\\nThen run a simple partitioning algorithm to update the result until we find the min.\\nThe partitioning algo gives us the access to all possible partitions and from the split vector\\nwe find the effective length of the subarray(partitions);\\n*/\\n\\nclass Solution {\\npublic:\\n    int split[1001][1001];\\n    int dp[1001];\\n\\n    int solve(vector<int> &nums, int idx, int k) {\\n        if(idx >= nums.size()) {\\n            return 0;\\n        }\\n\\n        if(dp[idx] != -1) {\\n            return dp[idx];\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i=idx; i<nums.size(); i++) {\\n            res = min(res, split[idx][i] + k + solve(nums,i+1,k));\\n        }\\n        return dp[idx] = res;\\n    }\\n\\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        int n = nums.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            unordered_map<int,int> m;\\n            int trim = 0;\\n\\n            for(int j=i; j<n; j++) {\\n                if(m[nums[j]] == 1) {\\n                    m[nums[j]]++;\\n                    trim += 2;\\n                }\\n                else if(m[nums[j]] > 1) {\\n                    m[nums[j]]++;\\n                    trim++;\\n                }\\n                else {\\n                    m[nums[j]]++;\\n                }\\n                split[i][j] = trim;\\n            }\\n            \\n        }\\n        return solve(nums,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nWe first store the lengths of all the split values for all possibilities.\\nOr we can say for every substring from i->j we are storing the lengths of the substring accdring to \\nthe given condition in the problem.\\nThen run a simple partitioning algorithm to update the result until we find the min.\\nThe partitioning algo gives us the access to all possible partitions and from the split vector\\nwe find the effective length of the subarray(partitions);\\n*/\\n\\nclass Solution {\\npublic:\\n    int split[1001][1001];\\n    int dp[1001];\\n\\n    int solve(vector<int> &nums, int idx, int k) {\\n        if(idx >= nums.size()) {\\n            return 0;\\n        }\\n\\n        if(dp[idx] != -1) {\\n            return dp[idx];\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i=idx; i<nums.size(); i++) {\\n            res = min(res, split[idx][i] + k + solve(nums,i+1,k));\\n        }\\n        return dp[idx] = res;\\n    }\\n\\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        int n = nums.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            unordered_map<int,int> m;\\n            int trim = 0;\\n\\n            for(int j=i; j<n; j++) {\\n                if(m[nums[j]] == 1) {\\n                    m[nums[j]]++;\\n                    trim += 2;\\n                }\\n                else if(m[nums[j]] > 1) {\\n                    m[nums[j]]++;\\n                    trim++;\\n                }\\n                else {\\n                    m[nums[j]]++;\\n                }\\n                split[i][j] = trim;\\n            }\\n            \\n        }\\n        return solve(nums,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084493,
                "title": "c-top-down-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nWe first store the lengths of all the split values for all possibilities.\\nOr we can say for every substring from i->j we are storing the lengths of the substring accdring to \\nthe given condition in the problem\\n*/\\n\\nclass Solution {\\npublic:\\n    int split[1001][1001];\\n    int dp[1001];\\n\\n    int solve(vector<int> &nums, int idx, int k) {\\n        if(idx >= nums.size()) {\\n            return 0;\\n        }\\n\\n        if(dp[idx] != -1) {\\n            return dp[idx];\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i=idx; i<nums.size(); i++) {\\n            res = min(res, split[idx][i] + k + solve(nums,i+1,k));\\n        }\\n        return dp[idx] = res;\\n    }\\n\\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        int n = nums.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            unordered_map<int,int> m;\\n            int trim = 0;\\n\\n            for(int j=i; j<n; j++) {\\n                if(m[nums[j]] == 1) {\\n                    m[nums[j]]++;\\n                    trim += 2;\\n                }\\n                else if(m[nums[j]] > 1) {\\n                    m[nums[j]]++;\\n                    trim++;\\n                }\\n                else {\\n                    m[nums[j]]++;\\n                }\\n                split[i][j] = trim;\\n            }\\n            \\n        }\\n        return solve(nums,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nWe first store the lengths of all the split values for all possibilities.\\nOr we can say for every substring from i->j we are storing the lengths of the substring accdring to \\nthe given condition in the problem\\n*/\\n\\nclass Solution {\\npublic:\\n    int split[1001][1001];\\n    int dp[1001];\\n\\n    int solve(vector<int> &nums, int idx, int k) {\\n        if(idx >= nums.size()) {\\n            return 0;\\n        }\\n\\n        if(dp[idx] != -1) {\\n            return dp[idx];\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i=idx; i<nums.size(); i++) {\\n            res = min(res, split[idx][i] + k + solve(nums,i+1,k));\\n        }\\n        return dp[idx] = res;\\n    }\\n\\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        int n = nums.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            unordered_map<int,int> m;\\n            int trim = 0;\\n\\n            for(int j=i; j<n; j++) {\\n                if(m[nums[j]] == 1) {\\n                    m[nums[j]]++;\\n                    trim += 2;\\n                }\\n                else if(m[nums[j]] > 1) {\\n                    m[nums[j]]++;\\n                    trim++;\\n                }\\n                else {\\n                    m[nums[j]]++;\\n                }\\n                split[i][j] = trim;\\n            }\\n            \\n        }\\n        return solve(nums,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084486,
                "title": "easy-100-tc-and-100-sc",
                "content": "Runtime: 267 ms, faster than 100.00% of C++ online submissions for Minimum Cost to Split an Array.\\nMemory Usage: 18.7 MB, less than 100.00% of C++ online submissions for Minimum Cost to Split an Array.\\n\\n```class Solution {\\npublic:\\n    \\n    int vis[1001][1001];\\n    int dp[1001][1001];\\n    \\n    int solve(vector<int>&nums,int l,int r,int k)\\n    {\\n        if(l>r)\\n            return 0;\\n        \\n        if(l==r)\\n            return k;\\n        \\n        if(dp[l][r]!=-1)\\n            return dp[l][r];\\n        \\n        int ans1=INT_MAX,x=0;\\n        for(int i=l;i<=r;i++)\\n        {   \\n            if(vis[l][nums[i]]==-1)\\n                vis[l][nums[i]]=1;\\n            else if(vis[l][nums[i]]==1)\\n            {\\n                x+=2;\\n                vis[l][nums[i]]=2;\\n            }\\n            else\\n            {\\n                x++;\\n            }\\n            \\n            ans1=min(ans1,x+k+solve(nums,i+1,r,k));\\n        }\\n        \\n        return dp[l][r]=ans1;\\n    }\\n    int minCost(vector<int>& nums, int k)\\n    {   \\n        memset(dp,-1,sizeof(dp));\\n        memset(vis,-1,sizeof(vis));\\n        return solve(nums,0,nums.size()-1,k);\\n    }\\n};```\\n",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    \\n    int vis[1001][1001];\\n    int dp[1001][1001];\\n    \\n    int solve(vector<int>&nums,int l,int r,int k)\\n    {\\n        if(l>r)\\n            return 0;\\n        \\n        if(l==r)\\n            return k;\\n        \\n        if(dp[l][r]!=-1)\\n            return dp[l][r];\\n        \\n        int ans1=INT_MAX,x=0;\\n        for(int i=l;i<=r;i++)\\n        {   \\n            if(vis[l][nums[i]]==-1)\\n                vis[l][nums[i]]=1;\\n            else if(vis[l][nums[i]]==1)\\n            {\\n                x+=2;\\n                vis[l][nums[i]]=2;\\n            }\\n            else\\n            {\\n                x++;\\n            }\\n            \\n            ans1=min(ans1,x+k+solve(nums,i+1,r,k));\\n        }\\n        \\n        return dp[l][r]=ans1;\\n    }\\n    int minCost(vector<int>& nums, int k)\\n    {   \\n        memset(dp,-1,sizeof(dp));\\n        memset(vis,-1,sizeof(vis));\\n        return solve(nums,0,nums.size()-1,k);\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3084460,
                "title": "dp-min-score-for-each-index",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[n] = 0\\n        for i in range(n - 1, -1, -1):\\n            curr = 0\\n            ctr = Counter()\\n            for j in range(i, n):\\n                ctr[nums[j]] += 1\\n                if ctr[nums[j]] == 1:\\n                    curr += 1\\n                elif ctr[nums[j]] == 2:\\n                    curr -= 1\\n                dp[i] = min(dp[i], k + j - i + 1 - curr + dp[j + 1])\\n        return dp[0]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[n] = 0\\n        for i in range(n - 1, -1, -1):\\n            curr = 0\\n            ctr = Counter()\\n            for j in range(i, n):\\n                ctr[nums[j]] += 1\\n                if ctr[nums[j]] == 1:\\n                    curr += 1\\n                elif ctr[nums[j]] == 2:\\n                    curr -= 1\\n                dp[i] = min(dp[i], k + j - i + 1 - curr + dp[j + 1])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084415,
                "title": "iterate-over-the-last-subarray-and-reduce-the-problem-to-a-smaller-version-of-itself",
                "content": "# Intuition - Iterate over the last subarray and use the solution for the remaining array\\n\\n\\n# Approach\\n[Github Explanation](https://github.com/MathProgrammer/LeetCode/blob/master/Contests/Weekly%20Contest%20329/Explanation/Minimum%20Cost%20to%20Split%20an%20Array%20Explanation.txt)\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        const int MAX_VALUE = 1001;\\n        vector <vector <int> > frequency(MAX_VALUE, vector <int> (nums.size() + 1));\\n        for(int n = 0; n < MAX_VALUE; n++)\\n        {\\n            for(int i = 0; i < nums.size(); i++)\\n            {\\n                frequency[n][i] = (nums[i] == n) + (i == 0 ? 0 : frequency[n][i - 1]);\\n            }\\n        }\\n        \\n        const int oo = 2e9;\\n        vector <int> minimum_cost_till(nums.size() + 1, oo);\\n        for(int right = 0; right < nums.size(); right++)\\n        {\\n            int unique_elements = 0;\\n            int cost_here = 0;\\n            for(int left = right; left >= 0; left--)\\n            {\\n                int n = nums[left];\\n                int frequency_here = frequency[n][right] - (left == 0 ? 0 : frequency[n][left - 1]);\\n                \\n                if(frequency_here == 1)\\n                {\\n                    unique_elements++;\\n                }\\n                else if(frequency_here == 2)\\n                {\\n                    unique_elements--;\\n                }\\n                   \\n                cost_here = k + (right - left + 1) - unique_elements;\\n                   \\n                int cost_of_partitioning_here = (left == 0 ? cost_here : cost_here + minimum_cost_till[left - 1]);\\n                   \\n                minimum_cost_till[right] = min(minimum_cost_till[right], cost_of_partitioning_here);\\n            }\\n        }\\n        \\n        return minimum_cost_till[nums.size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        const int MAX_VALUE = 1001;\\n        vector <vector <int> > frequency(MAX_VALUE, vector <int> (nums.size() + 1));\\n        for(int n = 0; n < MAX_VALUE; n++)\\n        {\\n            for(int i = 0; i < nums.size(); i++)\\n            {\\n                frequency[n][i] = (nums[i] == n) + (i == 0 ? 0 : frequency[n][i - 1]);\\n            }\\n        }\\n        \\n        const int oo = 2e9;\\n        vector <int> minimum_cost_till(nums.size() + 1, oo);\\n        for(int right = 0; right < nums.size(); right++)\\n        {\\n            int unique_elements = 0;\\n            int cost_here = 0;\\n            for(int left = right; left >= 0; left--)\\n            {\\n                int n = nums[left];\\n                int frequency_here = frequency[n][right] - (left == 0 ? 0 : frequency[n][left - 1]);\\n                \\n                if(frequency_here == 1)\\n                {\\n                    unique_elements++;\\n                }\\n                else if(frequency_here == 2)\\n                {\\n                    unique_elements--;\\n                }\\n                   \\n                cost_here = k + (right - left + 1) - unique_elements;\\n                   \\n                int cost_of_partitioning_here = (left == 0 ? cost_here : cost_here + minimum_cost_till[left - 1]);\\n                   \\n                minimum_cost_till[right] = min(minimum_cost_till[right], cost_of_partitioning_here);\\n            }\\n        }\\n        \\n        return minimum_cost_till[nums.size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084338,
                "title": "c-dp-bottom-up-with-explanation-o-n-2",
                "content": "# Intuition\\nThe idea is to iterate over all possible split points for a given sub-array `[0, i]` and select the one which gives the best answer, given that we already know best answers for all sub-arrays `[0, j]`, `j<i`.\\nRecursive formula for dynamic programming is:\\n```\\ndp[i] = min(dp[i], dp[j] + imp + k);\\n```\\n\\nIn this case `imp` is an importance value of sub-array `[j+1, i]`.\\n\\nHere we assume that the split point is between indexes `j` and `j+1`. We do not care how many split points we have in `[0, j]` sub-array as we already know an optimal answer for it.\\n\\n# Approach\\nIn the code we are computing `dp[i]` as described above and then `dp[n-1]` is our answer.\\n\\nWe are maintaining `count` array while iterating over `i`. It tells us a frequency of each value which is needed for \\'importance value\\' computation (`imp` in the code).\\n\\nWhen iterating over `j` we are maintaining `cur_count` (frequencies for `[j+1, i]` sub-array) and `cur_imp` (importance value for `[j+1, i]` sub-array).\\n\\n# Complexity\\n- Time complexity:\\n`O(n^2)`\\n\\n- Space complexity:\\n`O(n)`\\n\\n# Code\\n```\\nclass Solution {\\n   \\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> dp = vector<int>(nums.size(), numeric_limits<int>::max());\\n        vector<int> count(nums.size(), 0);\\n\\n        int imp = 0;\\n        for(int i = 0; i<nums.size(); ++i) {\\n            // Update frequency as new element is discovered.\\n            count[nums[i]]++;\\n            // Add 2 to importance value if frequency is exactly 2. Since the size of trimmed array is increasing by 2.\\n            if(count[nums[i]] == 2) imp+=2;\\n            // Otherwise add 1 as trimmed array is increased by 1.\\n            if(count[nums[i]] > 2) imp++;\\n            dp[i] = imp + k;\\n\\n            vector<int> cur_count = count;\\n            int cur_imp = imp;\\n            for(int j = 0; j<i; ++j) {\\n                // Subtract 2 from importance value if frequency is exactly 2. Since the size of trimmed array is reeducing by 2.\\n                if(cur_count[nums[j]] == 2) cur_imp-=2;\\n                // Otherwise subtract 1 since the size of trimmed array is reduced by 1.\\n                if(cur_count[nums[j]] > 2) cur_imp--;\\n\\n                // Update frequencies for [j+1, i] array.\\n                cur_count[nums[j]]--;\\n\\n                // Apply our recursive formula\\n                dp[i] = min(dp[i], dp[j] + k + cur_imp);\\n            }\\n        }\\n        return dp[nums.size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ndp[i] = min(dp[i], dp[j] + imp + k);\\n```\n```\\nclass Solution {\\n   \\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> dp = vector<int>(nums.size(), numeric_limits<int>::max());\\n        vector<int> count(nums.size(), 0);\\n\\n        int imp = 0;\\n        for(int i = 0; i<nums.size(); ++i) {\\n            // Update frequency as new element is discovered.\\n            count[nums[i]]++;\\n            // Add 2 to importance value if frequency is exactly 2. Since the size of trimmed array is increasing by 2.\\n            if(count[nums[i]] == 2) imp+=2;\\n            // Otherwise add 1 as trimmed array is increased by 1.\\n            if(count[nums[i]] > 2) imp++;\\n            dp[i] = imp + k;\\n\\n            vector<int> cur_count = count;\\n            int cur_imp = imp;\\n            for(int j = 0; j<i; ++j) {\\n                // Subtract 2 from importance value if frequency is exactly 2. Since the size of trimmed array is reeducing by 2.\\n                if(cur_count[nums[j]] == 2) cur_imp-=2;\\n                // Otherwise subtract 1 since the size of trimmed array is reduced by 1.\\n                if(cur_count[nums[j]] > 2) cur_imp--;\\n\\n                // Update frequencies for [j+1, i] array.\\n                cur_count[nums[j]]--;\\n\\n                // Apply our recursive formula\\n                dp[i] = min(dp[i], dp[j] + k + cur_imp);\\n            }\\n        }\\n        return dp[nums.size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084325,
                "title": "c-dp",
                "content": "# Intuition\\nDP\\n\\n# Code\\n```\\npublic class Solution {\\n    const int N = (int)1e3 + 1;\\n    int[,] p = new int[N, N];\\n    long[] f = new long[N];\\n    public int MinCost(int[] nums, int k) {\\n        int[] arr = new int[nums.Length + 1];\\n        for(int i = 1; i < arr.Length; i++){\\n            f[i] = int.MaxValue;\\n            arr[i] = nums[i - 1];\\n        }\\n        \\n        for(int i = 0; i < arr.Length; i++){\\n            int t = 0;\\n            p[i, arr[i]]++;\\n            int[] res = new int[arr.Length];\\n            for(int j = 0; j < arr.Length && i > 0; j++){\\n                p[i, j] += p[i - 1, j];\\n                res[j] = p[i, j];\\n                if(p[i, j] > 1) t += p[i, j];\\n            }\\n            \\n            for(int j = 0; j < i; j++){\\n                if(--res[arr[j]] > 1) t -= 1;\\n                else if(res[arr[j]] == 1) t -= 2;\\n                f[i] = Math.Min(f[i], t + f[j] + k);\\n            }\\n        }\\n        return (int)f[arr.Length - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    const int N = (int)1e3 + 1;\\n    int[,] p = new int[N, N];\\n    long[] f = new long[N];\\n    public int MinCost(int[] nums, int k) {\\n        int[] arr = new int[nums.Length + 1];\\n        for(int i = 1; i < arr.Length; i++){\\n            f[i] = int.MaxValue;\\n            arr[i] = nums[i - 1];\\n        }\\n        \\n        for(int i = 0; i < arr.Length; i++){\\n            int t = 0;\\n            p[i, arr[i]]++;\\n            int[] res = new int[arr.Length];\\n            for(int j = 0; j < arr.Length && i > 0; j++){\\n                p[i, j] += p[i - 1, j];\\n                res[j] = p[i, j];\\n                if(p[i, j] > 1) t += p[i, j];\\n            }\\n            \\n            for(int j = 0; j < i; j++){\\n                if(--res[arr[j]] > 1) t -= 1;\\n                else if(res[arr[j]] == 1) t -= 2;\\n                f[i] = Math.Min(f[i], t + f[j] + k);\\n            }\\n        }\\n        return (int)f[arr.Length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084232,
                "title": "c-simple-1d-dp-just-11-lines-easy-understanding-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int minCost(vector<int>& nums, int k) {\\n        ll n=nums.size();\\n        vector<ll> dp(n+1,INT_MAX);\\n        for(int i=0;i<n;i++){\\n            vector<ll> mp(n+1,0);\\n            ll cur=0;\\n            for(int j=i;j>=0;j--){\\n                if(mp[nums[j]]>1)cur++;\\n                if(mp[nums[j]]==1)cur+=2;\\n                mp[nums[j]]++;\\n                dp[i]=min(dp[i],k+cur+ (j>0?dp[j-1]:0));\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int minCost(vector<int>& nums, int k) {\\n        ll n=nums.size();\\n        vector<ll> dp(n+1,INT_MAX);\\n        for(int i=0;i<n;i++){\\n            vector<ll> mp(n+1,0);\\n            ll cur=0;\\n            for(int j=i;j>=0;j--){\\n                if(mp[nums[j]]>1)cur++;\\n                if(mp[nums[j]]==1)cur+=2;\\n                mp[nums[j]]++;\\n                dp[i]=min(dp[i],k+cur+ (j>0?dp[j-1]:0));\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084147,
                "title": "tle-in-c-but-accepted-in-python3",
                "content": "# C++ Solution (Getting TLE)\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        using ll = long long;\\n        int n = nums.size();\\n        vector<ll> memo(n, -1);\\n        \\n        function<ll(int)> solve = [&](int i) {\\n            if(i == n) return 0ll;\\n            if(memo[i] != -1) return memo[i];\\n            \\n            ll result = 1e12;\\n            \\n            unordered_map<int,bool> mp;\\n            int count = 0;\\n            \\n            for(int j=i; j<n; j++) {\\n                if(not mp.count(nums[j])) {\\n                    mp[nums[j]] = false;\\n                }\\n                else if(mp[nums[j]]) {\\n                    count++;\\n                }\\n                else {\\n                    mp[nums[j]] = true;\\n                    count += 2;\\n                }\\n                \\n                result = min(result, k+count+solve(j+1));\\n            }\\n            \\n            memo[i] = result;\\n            return memo[i];\\n        };\\n        \\n        return solve(0);\\n    }\\n};\\n```\\n\\n\\n# Python3 Solution (same as C++, getting ACCEPTED)\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        memo = {}\\n        \\n        def solve(i):\\n            if i == n: return 0\\n            if i in memo: return memo[i]\\n            \\n            mp = {}\\n            count = 0\\n            result = float(\\'inf\\')\\n            \\n            for j in range(i, n):\\n                if nums[j] not in mp:\\n                    mp[nums[j]] = False\\n                elif mp[nums[j]]:\\n                    count += 1\\n                else:\\n                    mp[nums[j]] = True\\n                    count += 2\\n                \\n                result = min(result, count+k+solve(j+1))\\n            \\n            memo[i] = result\\n            return memo[i]\\n        \\n        return solve(0)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        using ll = long long;\\n        int n = nums.size();\\n        vector<ll> memo(n, -1);\\n        \\n        function<ll(int)> solve = [&](int i) {\\n            if(i == n) return 0ll;\\n            if(memo[i] != -1) return memo[i];\\n            \\n            ll result = 1e12;\\n            \\n            unordered_map<int,bool> mp;\\n            int count = 0;\\n            \\n            for(int j=i; j<n; j++) {\\n                if(not mp.count(nums[j])) {\\n                    mp[nums[j]] = false;\\n                }\\n                else if(mp[nums[j]]) {\\n                    count++;\\n                }\\n                else {\\n                    mp[nums[j]] = true;\\n                    count += 2;\\n                }\\n                \\n                result = min(result, k+count+solve(j+1));\\n            }\\n            \\n            memo[i] = result;\\n            return memo[i];\\n        };\\n        \\n        return solve(0);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        memo = {}\\n        \\n        def solve(i):\\n            if i == n: return 0\\n            if i in memo: return memo[i]\\n            \\n            mp = {}\\n            count = 0\\n            result = float(\\'inf\\')\\n            \\n            for j in range(i, n):\\n                if nums[j] not in mp:\\n                    mp[nums[j]] = False\\n                elif mp[nums[j]]:\\n                    count += 1\\n                else:\\n                    mp[nums[j]] = True\\n                    count += 2\\n                \\n                result = min(result, count+k+solve(j+1))\\n            \\n            memo[i] = result\\n            return memo[i]\\n        \\n        return solve(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084125,
                "title": "java-pre-calculate-top-down-dp-with-memo-n-2",
                "content": "\\n\\n```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        // 1. use a preSum 2d array to store the pre-calculate trimmed len for each nums[i:j]\\n        //    ex: 1,2,1,2,1,3,3, i:0, j=N-1\\n        //        0,0,2,4,5,5,7\\n        //        cnt_map: 1:3, 2:2, 3:2\\n        // 2. top down dp, each item can be the new start or in the curList,\\n        //    note that for the ending criteria, need to add a \"K\" because even if there no split, still count a \"K\".\\n        int N = nums.length;\\n        int[][] preSum = new int[N][N];\\n        int[] cnt = new int[N];\\n        for(int i=0; i<N; i++){\\n            cnt = new int[N];\\n            for(int j=i; j<N; j++){\\n                int val = nums[j];\\n                cnt[val]++;\\n                if(cnt[val]==2){\\n                    preSum[i][j] = preSum[i][j-1] + cnt[val];\\n                }else if(cnt[val]>2){\\n                    preSum[i][j] = preSum[i][j-1]+1;\\n                }else if(j>0){\\n                    preSum[i][j] = preSum[i][j-1];\\n                }\\n            }\\n        }\\n        return dfs(nums, k, preSum, 0, 0, new Integer[N][N]);\\n    }\\n    \\n    private int dfs(int[] nums, int k, int[][] preSum, int lastIdx, int curIdx, Integer[][] memo){\\n        if(curIdx == nums.length){\\n            return k+ preSum[lastIdx][curIdx-1];\\n        }\\n        if(memo[lastIdx][curIdx]!=null){\\n            return memo[lastIdx][curIdx];\\n        }\\n        int rtn = Integer.MAX_VALUE;\\n        int asNew = Integer.MAX_VALUE;\\n        if(curIdx >lastIdx){\\n            asNew = k + preSum[lastIdx][curIdx-1] + dfs(nums, k, preSum, curIdx, curIdx+1, memo);\\n        }\\n        int asOld = dfs(nums, k, preSum, lastIdx, curIdx+1, memo);\\n        \\n        rtn = Math.min(asNew, asOld);\\n        memo[lastIdx][curIdx] = rtn;\\n        return rtn;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        // 1. use a preSum 2d array to store the pre-calculate trimmed len for each nums[i:j]\\n        //    ex: 1,2,1,2,1,3,3, i:0, j=N-1\\n        //        0,0,2,4,5,5,7\\n        //        cnt_map: 1:3, 2:2, 3:2\\n        // 2. top down dp, each item can be the new start or in the curList,\\n        //    note that for the ending criteria, need to add a \"K\" because even if there no split, still count a \"K\".\\n        int N = nums.length;\\n        int[][] preSum = new int[N][N];\\n        int[] cnt = new int[N];\\n        for(int i=0; i<N; i++){\\n            cnt = new int[N];\\n            for(int j=i; j<N; j++){\\n                int val = nums[j];\\n                cnt[val]++;\\n                if(cnt[val]==2){\\n                    preSum[i][j] = preSum[i][j-1] + cnt[val];\\n                }else if(cnt[val]>2){\\n                    preSum[i][j] = preSum[i][j-1]+1;\\n                }else if(j>0){\\n                    preSum[i][j] = preSum[i][j-1];\\n                }\\n            }\\n        }\\n        return dfs(nums, k, preSum, 0, 0, new Integer[N][N]);\\n    }\\n    \\n    private int dfs(int[] nums, int k, int[][] preSum, int lastIdx, int curIdx, Integer[][] memo){\\n        if(curIdx == nums.length){\\n            return k+ preSum[lastIdx][curIdx-1];\\n        }\\n        if(memo[lastIdx][curIdx]!=null){\\n            return memo[lastIdx][curIdx];\\n        }\\n        int rtn = Integer.MAX_VALUE;\\n        int asNew = Integer.MAX_VALUE;\\n        if(curIdx >lastIdx){\\n            asNew = k + preSum[lastIdx][curIdx-1] + dfs(nums, k, preSum, curIdx, curIdx+1, memo);\\n        }\\n        int asOld = dfs(nums, k, preSum, lastIdx, curIdx+1, memo);\\n        \\n        rtn = Math.min(asNew, asOld);\\n        memo[lastIdx][curIdx] = rtn;\\n        return rtn;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084116,
                "title": "recursion-memorization-c",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int memo[1001];\\n    int solve(int i,vector<int>&arr,int k){\\n        if(i == arr.size()) return 0;\\n        if(memo[i] != -1) return memo[i];\\n        \\n        unordered_map<int,int> mp; \\n        int maxi = INT_MAX, res = 0;\\n        \\n        for(int j=i;j<arr.size();j++){\\n            mp[arr[j]]++;\\n            if(mp[arr[j]] == 2) res += 2;\\n            else if(mp[arr[j]] > 2) res++;\\n            maxi = min(maxi,res+k+solve(j+1,arr,k));\\n        }\\n                      \\n        return memo[i] = maxi;\\n    }\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        memset(memo,-1,sizeof memo);\\n        return solve(0,nums,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int memo[1001];\\n    int solve(int i,vector<int>&arr,int k){\\n        if(i == arr.size()) return 0;\\n        if(memo[i] != -1) return memo[i];\\n        \\n        unordered_map<int,int> mp; \\n        int maxi = INT_MAX, res = 0;\\n        \\n        for(int j=i;j<arr.size();j++){\\n            mp[arr[j]]++;\\n            if(mp[arr[j]] == 2) res += 2;\\n            else if(mp[arr[j]] > 2) res++;\\n            maxi = min(maxi,res+k+solve(j+1,arr,k));\\n        }\\n                      \\n        return memo[i] = maxi;\\n    }\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        memset(memo,-1,sizeof memo);\\n        return solve(0,nums,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084097,
                "title": "java-dp",
                "content": "# Intuition\\ndp(low,high) = MIN(dp(low,i) + dp(i+1,high)) for every i\\ndp state has two variables :low and high\\n\\n# Approach\\ntop down dp\\nuse a map to get count of numbers repeating.\\nwhen the number is seen for the first, time, it doesnt contrinute to the repeating count;\\nony when it is seen from the second time and onwards, it contributes.\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nO(n2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int len = nums.length;\\n        Integer[][] dp = new Integer[len][len];\\n        return recur(0,len-1,k,nums, dp);\\n        \\n    }\\n    \\n    private int recur(int low, int high,int k,  int[] nums, Integer[][] dp){\\n        if(low>high)\\n            return 0;\\n        if(dp[low][high]!=null)\\n            return dp[low][high];\\n        \\n        int ans= Integer.MAX_VALUE;\\n        Map<Integer, Integer> map = new HashMap();\\n        int repeatedCount= 0;\\n        for(int i = low;i<=high;i++){\\n            int imp = k;\\n\\n            if(!map.containsKey(nums[i])){\\n                map.put(nums[i],1);\\n            }else{\\n                int count = map.get(nums[i]);\\n                if(count==1){\\n                    repeatedCount+=2;\\n                    map.put(nums[i],2);\\n                }else{\\n                    map.put(nums[i],count+1);\\n                    repeatedCount++;\\n                }\\n            }\\n            imp+=repeatedCount;\\n            int next = recur(i+1, high, k,nums, dp);\\n            int temp = Integer.MAX_VALUE;\\n            if(next!=Integer.MAX_VALUE)\\n                temp = imp + next;\\n            ans = Math.min(temp,ans);\\n            \\n        }\\n        \\n        dp[low][high] = ans;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int[] nums, int k) {\\n        int len = nums.length;\\n        Integer[][] dp = new Integer[len][len];\\n        return recur(0,len-1,k,nums, dp);\\n        \\n    }\\n    \\n    private int recur(int low, int high,int k,  int[] nums, Integer[][] dp){\\n        if(low>high)\\n            return 0;\\n        if(dp[low][high]!=null)\\n            return dp[low][high];\\n        \\n        int ans= Integer.MAX_VALUE;\\n        Map<Integer, Integer> map = new HashMap();\\n        int repeatedCount= 0;\\n        for(int i = low;i<=high;i++){\\n            int imp = k;\\n\\n            if(!map.containsKey(nums[i])){\\n                map.put(nums[i],1);\\n            }else{\\n                int count = map.get(nums[i]);\\n                if(count==1){\\n                    repeatedCount+=2;\\n                    map.put(nums[i],2);\\n                }else{\\n                    map.put(nums[i],count+1);\\n                    repeatedCount++;\\n                }\\n            }\\n            imp+=repeatedCount;\\n            int next = recur(i+1, high, k,nums, dp);\\n            int temp = Integer.MAX_VALUE;\\n            if(next!=Integer.MAX_VALUE)\\n                temp = imp + next;\\n            ans = Math.min(temp,ans);\\n            \\n        }\\n        \\n        dp[low][high] = ans;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084096,
                "title": "detailed-dp-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve thi-->\\nwhat we have to do here is split this array. So we can look at the first indices of the split and then we could figure out what is the minimum score from that index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndp[i]=minimum score from subarray i to n-1.\\nwe can split this subarray(i->n-1) into 2 subarrays at any index from (i+1->n-1) and we will take min of this. Now to implement this, we can take a freq array and keep track of trim length of (i->k)(here k is different from the k given in question). \\n\\ndp[i]=dp[k+1]+j(in question given as k)+trimLength of subarray (i->k).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1000];\\n    int recur(int i, vector<int>&nums, int j){\\n        int n=nums.size();\\n        if(i==n)return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        vector<int>freq(n, 0);\\n        int trim=0;\\n        int ans=INT_MAX;\\n        for(int k=i; k<n; k++){\\n            freq[nums[k]]++;\\n            if(freq[nums[k]]==2)trim+=2;\\n            else if(freq[nums[k]]>2)trim++;\\n            ans=min(ans, j+trim+recur(k+1, nums, j));\\n        }\\n        return dp[i]= ans;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        return recur(0, nums, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1000];\\n    int recur(int i, vector<int>&nums, int j){\\n        int n=nums.size();\\n        if(i==n)return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        vector<int>freq(n, 0);\\n        int trim=0;\\n        int ans=INT_MAX;\\n        for(int k=i; k<n; k++){\\n            freq[nums[k]]++;\\n            if(freq[nums[k]]==2)trim+=2;\\n            else if(freq[nums[k]]>2)trim++;\\n            ans=min(ans, j+trim+recur(k+1, nums, j));\\n        }\\n        return dp[i]= ans;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        return recur(0, nums, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084066,
                "title": "some-tle-question-c-top-down",
                "content": "why code1 using vector accept \\nwhile code2 using map get TLE\\nboth are O(N*N)\\n\\n# Code1\\n```\\nclass Solution {\\n    int dp[1000]={0};\\n    int DP(vector<int>& nums, int k,int left)\\n    {\\n        \\n        if(left==nums.size())\\n            return 0;\\n        if(dp[left])\\n            return dp[left];\\n        int count=0;\\n        vector<int> st(nums.size(),0); // the only different line\\n        int cur=INT_MAX;\\n        for(int i=left;i<nums.size();i++)\\n        {\\n            if(st[nums[i]]==1)\\n            {\\n                count+=2;\\n            }\\n            else if(st[nums[i]]>1)\\n                count++;\\n            st[nums[i]]++;\\n            int next=k+count+DP(nums,k,i+1);\\n            cur=min(cur,next);\\n        }\\n        dp[left]=cur;\\n        return cur;\\n    }\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        return DP(nums,k,0);\\n    }\\n};\\n```\\n# Code2\\n```\\nclass Solution {\\n    int dp[1000]={0};\\n    int DP(vector<int>& nums, int k,int left)\\n    {\\n        \\n        if(left==nums.size())\\n            return 0;\\n        if(dp[left])\\n            return dp[left];\\n        int count=0;\\n        unordered_map<int,int> st; // the only different line\\n        int cur=INT_MAX;\\n        for(int i=left;i<nums.size();i++)\\n        {\\n            if(st[nums[i]]==1)\\n            {\\n                count+=2;\\n            }\\n            else if(st[nums[i]]>1)\\n                count++;\\n            st[nums[i]]++;\\n            int next=k+count+DP(nums,k,i+1);\\n            cur=min(cur,next);\\n        }\\n        dp[left]=cur;\\n        return cur;\\n    }\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        return DP(nums,k,0);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int dp[1000]={0};\\n    int DP(vector<int>& nums, int k,int left)\\n    {\\n        \\n        if(left==nums.size())\\n            return 0;\\n        if(dp[left])\\n            return dp[left];\\n        int count=0;\\n        vector<int> st(nums.size(),0); // the only different line\\n        int cur=INT_MAX;\\n        for(int i=left;i<nums.size();i++)\\n        {\\n            if(st[nums[i]]==1)\\n            {\\n                count+=2;\\n            }\\n            else if(st[nums[i]]>1)\\n                count++;\\n            st[nums[i]]++;\\n            int next=k+count+DP(nums,k,i+1);\\n            cur=min(cur,next);\\n        }\\n        dp[left]=cur;\\n        return cur;\\n    }\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        return DP(nums,k,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int dp[1000]={0};\\n    int DP(vector<int>& nums, int k,int left)\\n    {\\n        \\n        if(left==nums.size())\\n            return 0;\\n        if(dp[left])\\n            return dp[left];\\n        int count=0;\\n        unordered_map<int,int> st; // the only different line\\n        int cur=INT_MAX;\\n        for(int i=left;i<nums.size();i++)\\n        {\\n            if(st[nums[i]]==1)\\n            {\\n                count+=2;\\n            }\\n            else if(st[nums[i]]>1)\\n                count++;\\n            st[nums[i]]++;\\n            int next=k+count+DP(nums,k,i+1);\\n            cur=min(cur,next);\\n        }\\n        dp[left]=cur;\\n        return cur;\\n    }\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        return DP(nums,k,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084034,
                "title": "javascrip-dp-158ms",
                "content": "TC: O(n ^ 2)\\n```\\nconst minCost = (a, k) => {\\n    let n = a.length, max = Math.max(...a), dp = Array(n + 1).fill(Number.MAX_SAFE_INTEGER);\\n    dp[0] = 0;\\n    for (let i = 0; i < n; i++) {\\n        let f = Array(max + 1).fill(0), cost = 0;\\n        for (let j = i; j < n; j++) {\\n            f[a[j]]++;\\n            if (f[a[j]] == 2) {\\n                cost += 2;\\n            } else if (f[a[j]] > 2) {\\n                cost++;\\n            }\\n            dp[j + 1] = Math.min(dp[i] + cost + k, dp[j + 1]);\\n        }\\n    }\\n    return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst minCost = (a, k) => {\\n    let n = a.length, max = Math.max(...a), dp = Array(n + 1).fill(Number.MAX_SAFE_INTEGER);\\n    dp[0] = 0;\\n    for (let i = 0; i < n; i++) {\\n        let f = Array(max + 1).fill(0), cost = 0;\\n        for (let j = i; j < n; j++) {\\n            f[a[j]]++;\\n            if (f[a[j]] == 2) {\\n                cost += 2;\\n            } else if (f[a[j]] > 2) {\\n                cost++;\\n            }\\n            dp[j + 1] = Math.min(dp[i] + cost + k, dp[j + 1]);\\n        }\\n    }\\n    return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3084000,
                "title": "my-java-solution-o-n-2",
                "content": "```\\nint n=nums.length;\\n        \\n        int[] dp = new int[n + 1];\\n        int[][] cost = new int[n][n];\\n        \\n        \\n        //prestore the cost for subarray\\n        for(int i = 0;i<n;i++){\\n            int[] freq = new int[1001];\\n            int c=0;\\n            for(int j=i;j<n;j++){\\n                freq[nums[j]]++;\\n                \\n                if ((freq[nums[j]]) == 2) c += 2;\\n                else if(freq[nums[j]]>2) c++;\\n                \\n                cost[i][j] = c;\\n            }\\n        }\\n       \\n        \\n      //trying all possible subarrays\\n      for (int i = 1; i <= n; i++)\\n          dp[i] = Integer.MAX_VALUE;\\n\\n      for (int i = 0; i < n; i++){\\n          for (int j = i; j < n; ++j){\\n              int price = 0;\\n              if(dp[j+1]==0)continue;\\n              price+=cost[i][j];\\n              dp[j + 1] = Math.min(dp[i] + price + k, dp[j + 1]);\\n          }\\n      }\\n      return dp[n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint n=nums.length;\\n        \\n        int[] dp = new int[n + 1];\\n        int[][] cost = new int[n][n];\\n        \\n        \\n        //prestore the cost for subarray\\n        for(int i = 0;i<n;i++){\\n            int[] freq = new int[1001];\\n            int c=0;\\n            for(int j=i;j<n;j++){\\n                freq[nums[j]]++;\\n                \\n                if ((freq[nums[j]]) == 2) c += 2;\\n                else if(freq[nums[j]]>2) c++;\\n                \\n                cost[i][j] = c;\\n            }\\n        }\\n       \\n        \\n      //trying all possible subarrays\\n      for (int i = 1; i <= n; i++)\\n          dp[i] = Integer.MAX_VALUE;\\n\\n      for (int i = 0; i < n; i++){\\n          for (int j = i; j < n; ++j){\\n              int price = 0;\\n              if(dp[j+1]==0)continue;\\n              price+=cost[i][j];\\n              dp[j + 1] = Math.min(dp[i] + price + k, dp[j + 1]);\\n          }\\n      }\\n      return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083993,
                "title": "python-javascript-top-down",
                "content": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        @cache\\n        def dp(i):\\n            if i == len(nums):\\n                return 0\\n            ans = sys.maxsize\\n            curr = k\\n            count = Counter()\\n            for j in range(i,len(nums)):\\n                n = nums[j]\\n                count[n] += 1\\n                curr += count[n] > 1 \\n                curr += count[n] == 2 \\n                ans = min(ans, dp(j+1) + curr)\\n            return ans \\n        return dp(0)\\n```\\n\\n```\\nvar minCost = function(nums, k) {\\n    const cache = {}\\n    const n = nums.length\\n    const dp = (i) => {\\n        if (i == n) return 0\\n        if (i in cache) return cache[i]\\n        let ans = Infinity\\n        const count = {}\\n        let curr = k\\n        for(let j = i; j < n; j++){\\n            const n = nums[j]\\n            count[n] = count[n] ? ++count[n] : 1\\n            curr += count[n] == 2\\n            curr += count[n] > 1\\n            ans = Math.min(ans, dp(j+1) + curr)\\n            \\n        }\\n        cache[i] = ans\\n        return ans\\n        }\\n    return dp(0)\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], k: int) -> int:\\n        @cache\\n        def dp(i):\\n            if i == len(nums):\\n                return 0\\n            ans = sys.maxsize\\n            curr = k\\n            count = Counter()\\n            for j in range(i,len(nums)):\\n                n = nums[j]\\n                count[n] += 1\\n                curr += count[n] > 1 \\n                curr += count[n] == 2 \\n                ans = min(ans, dp(j+1) + curr)\\n            return ans \\n        return dp(0)\\n```\n```\\nvar minCost = function(nums, k) {\\n    const cache = {}\\n    const n = nums.length\\n    const dp = (i) => {\\n        if (i == n) return 0\\n        if (i in cache) return cache[i]\\n        let ans = Infinity\\n        const count = {}\\n        let curr = k\\n        for(let j = i; j < n; j++){\\n            const n = nums[j]\\n            count[n] = count[n] ? ++count[n] : 1\\n            curr += count[n] == 2\\n            curr += count[n] > 1\\n            ans = Math.min(ans, dp(j+1) + curr)\\n            \\n        }\\n        cache[i] = ans\\n        return ans\\n        }\\n    return dp(0)\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083983,
                "title": "bottom-up-and-top-down-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> cache;\\n    int minCost(vector<int>& nums, int k) {\\n        // return solve(nums,k,0);\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n             int mini=-1,count=0;\\n            unordered_map<int,int> m;\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                    m[nums[j]]++;\\n                     if(m[nums[j]]>1)\\n                     {\\n                         count++;\\n                     }\\n                      if(m[nums[j]]==2)\\n                      {\\n                          count++;\\n                      }\\n                if(mini==-1)\\n                {\\n                    mini=k+count+cache[j+1];\\n                }else{\\n                     mini=min(mini,k+count+cache[j+1]);\\n                }\\n            }\\n            cache[i]=mini;\\n        }\\n        return cache[0];\\n    }\\n    int solve(vector<int>& nums, int k,int i)\\n              {\\n                  if(i==nums.size())\\n                  {\\n                      return 0;\\n                  }\\n                    if(cache.count(i)>0)\\n                    {\\n                        return cache[i];\\n                    }\\n                  int mini=INT_MAX,count=0;\\n                  unordered_map<int,int> m;\\n                  for(int j=i;j<nums.size();j++)\\n                  {\\n                     m[nums[j]]++;\\n                     if(m[nums[j]]>1)\\n                     {\\n                         count++;\\n                     }\\n                      if(m[nums[j]]==2)\\n                      {\\n                          count++;\\n                      }\\n                      \\n                     mini=min(mini,k+count+solve(nums,k,j+1));\\n                  }\\n                  return cache[i]=mini;\\n              }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> cache;\\n    int minCost(vector<int>& nums, int k) {\\n        // return solve(nums,k,0);\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n             int mini=-1,count=0;\\n            unordered_map<int,int> m;\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                    m[nums[j]]++;\\n                     if(m[nums[j]]>1)\\n                     {\\n                         count++;\\n                     }\\n                      if(m[nums[j]]==2)\\n                      {\\n                          count++;\\n                      }\\n                if(mini==-1)\\n                {\\n                    mini=k+count+cache[j+1];\\n                }else{\\n                     mini=min(mini,k+count+cache[j+1]);\\n                }\\n            }\\n            cache[i]=mini;\\n        }\\n        return cache[0];\\n    }\\n    int solve(vector<int>& nums, int k,int i)\\n              {\\n                  if(i==nums.size())\\n                  {\\n                      return 0;\\n                  }\\n                    if(cache.count(i)>0)\\n                    {\\n                        return cache[i];\\n                    }\\n                  int mini=INT_MAX,count=0;\\n                  unordered_map<int,int> m;\\n                  for(int j=i;j<nums.size();j++)\\n                  {\\n                     m[nums[j]]++;\\n                     if(m[nums[j]]>1)\\n                     {\\n                         count++;\\n                     }\\n                      if(m[nums[j]]==2)\\n                      {\\n                          count++;\\n                      }\\n                      \\n                     mini=min(mini,k+count+solve(nums,k,j+1));\\n                  }\\n                  return cache[i]=mini;\\n              }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083945,
                "title": "java-recursion-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n\\npublic int minCost(int[] nums, int k) {\\n        return getMin(0, nums, k, new Integer[nums.length]);\\n    }\\npublic int getMin(int index, int[] nums, int k, Integer[] dp)\\n{\\n\\tif(index>= nums.length)\\n\\t\\t\\treturn 0;\\n\\tif(dp[index] != null)\\n\\t\\t\\treturn dp[index];\\n\\tint max = Integer.MAX_VALUE;\\n\\tHashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\tint count = 0;\\n\\tfor(int i = index;i<nums.length;i++)\\n\\t{\\n\\t\\t\\tmap.put(nums[i], map.getOrDefault(nums[i], 0)+1);\\n\\t\\t\\tint num = map.get(nums[i]);\\n\\t\\t\\tif(num ==2)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount +=2;\\n\\t\\t\\t}\\n\\t\\t\\telse if(num>2)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tint curr = k+count+getMin(i+1, nums, k,dp);\\n\\t\\t\\t\\n\\t\\t\\tmax = Math.min(max, curr);\\n\\t}\\n\\treturn dp[index]= max;\\n\\t\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n\\npublic int minCost(int[] nums, int k) {\\n        return getMin(0, nums, k, new Integer[nums.length]);\\n    }\\npublic int getMin(int index, int[] nums, int k, Integer[] dp)\\n{\\n\\tif(index>= nums.length)\\n\\t\\t\\treturn 0;\\n\\tif(dp[index] != null)\\n\\t\\t\\treturn dp[index];\\n\\tint max = Integer.MAX_VALUE;\\n\\tHashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\tint count = 0;\\n\\tfor(int i = index;i<nums.length;i++)\\n\\t{\\n\\t\\t\\tmap.put(nums[i], map.getOrDefault(nums[i], 0)+1);\\n\\t\\t\\tint num = map.get(nums[i]);\\n\\t\\t\\tif(num ==2)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount +=2;\\n\\t\\t\\t}\\n\\t\\t\\telse if(num>2)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tint curr = k+count+getMin(i+1, nums, k,dp);\\n\\t\\t\\t\\n\\t\\t\\tmax = Math.min(max, curr);\\n\\t}\\n\\treturn dp[index]= max;\\n\\t\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083944,
                "title": "c-top-down-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the input is at most `1000` in length. You can use top down dp  to answer the question What the best score at the given index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse top down dp to chose the best score for the partition starting at index `i`. Initially the partition contains just the element `nums[i]`. Then branch comparing to what if you partitioned at the next `n-i` indexes vs what if you just kept growing this partition. Use memoization to reduce the time complexity.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$ we iterate n times at most for n dp calls.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ From storing the counts and memoizing the answer.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> memo(nums.size(), -1);\\n        int n = nums.size();\\n        function<int(int)> dp = [&](int i){\\n            if(memo[i] != -1) return memo[i];\\n            unordered_map<int, int> count;\\n            int ans = INT_MAX;\\n            count[nums[i]] = 1;\\n            int mtoc = 0;\\n            for(int j = i+1; j < n; j++){\\n                ans = min(ans, mtoc+ k + dp(j));\\n                if(count[nums[j]] == 0){\\n                    count[nums[j]] = 1;\\n                }else if(count[nums[j]] == 1){\\n                    count[nums[j]] = 2;\\n                    mtoc+=2;\\n                }else{\\n                    mtoc++;\\n                }\\n                \\n            }\\n            memo[i] = min( mtoc + k, ans);\\n            return  memo[i];\\n        };\\n        return dp(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> memo(nums.size(), -1);\\n        int n = nums.size();\\n        function<int(int)> dp = [&](int i){\\n            if(memo[i] != -1) return memo[i];\\n            unordered_map<int, int> count;\\n            int ans = INT_MAX;\\n            count[nums[i]] = 1;\\n            int mtoc = 0;\\n            for(int j = i+1; j < n; j++){\\n                ans = min(ans, mtoc+ k + dp(j));\\n                if(count[nums[j]] == 0){\\n                    count[nums[j]] = 1;\\n                }else if(count[nums[j]] == 1){\\n                    count[nums[j]] = 2;\\n                    mtoc+=2;\\n                }else{\\n                    mtoc++;\\n                }\\n                \\n            }\\n            memo[i] = min( mtoc + k, ans);\\n            return  memo[i];\\n        };\\n        return dp(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083939,
                "title": "simple-c-dp-solution",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int n;\\npublic:\\n    int f(int ind, vector<int>& nums, int k, vector<int>& dp) {\\n        if(ind == n) return 0;\\n        int &cost = dp[ind];\\n        if(cost != -1) return cost;\\n        vector<int> freq(n, 0);\\n        cost = INT_MAX;\\n        int len = 0;\\n        for(int i = ind; i < n; i++) {\\n            freq[nums[i]]++;\\n            if(freq[nums[i]] == 2) len += 2;\\n            else if(freq[nums[i]] > 2) len++;\\n            cost = min(cost, len + k + f(i + 1, nums, k, dp));\\n        }\\n        return cost;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        n = nums.size();\\n        vector<int> dp(n, -1);\\n        return f(0, nums, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n;\\npublic:\\n    int f(int ind, vector<int>& nums, int k, vector<int>& dp) {\\n        if(ind == n) return 0;\\n        int &cost = dp[ind];\\n        if(cost != -1) return cost;\\n        vector<int> freq(n, 0);\\n        cost = INT_MAX;\\n        int len = 0;\\n        for(int i = ind; i < n; i++) {\\n            freq[nums[i]]++;\\n            if(freq[nums[i]] == 2) len += 2;\\n            else if(freq[nums[i]] > 2) len++;\\n            cost = min(cost, len + k + f(i + 1, nums, k, dp));\\n        }\\n        return cost;\\n    }\\n    int minCost(vector<int>& nums, int k) {\\n        n = nums.size();\\n        vector<int> dp(n, -1);\\n        return f(0, nums, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1769070,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1770185,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 2045678,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 2024693,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1922064,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1772372,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1770192,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1769888,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1769317,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1769126,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1769070,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1770185,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 2045678,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 2024693,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1922064,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1772372,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1770192,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1769888,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1769317,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            },
            {
                "id": 1769126,
                "content": [
                    {
                        "username": "the_leetcode_guy",
                        "content": "Hints:\\n1. Precompute trimmedArray length for all subarrays from i..j\\n2. Use Recursion + DP and try for all possible splits of array\\n\\nDetailed explanation here: https://youtu.be/ozKoyKyWwSM"
                    },
                    {
                        "username": "no-username",
                        "content": "Can this not be done in O(n) ? What am I missing in below algo:\\n- Iterate left to right, calculate ` importance value` at each i and store at left[i]\\n- Iterate right to left, calculate ` importance value` at each i and store at right[i]\\n- Iterate 0 to nums.length , pick the min of (left[i]+k+right[i]+k) \\n\\nAbove passes 30/59, tests so am I missing anything? "
                    },
                    {
                        "username": "himan5hu_123",
                        "content": "can u share your code because i m doing the same thing but only 6 test cases are passing :("
                    },
                    {
                        "username": "AmorTsai",
                        "content": "I had the problems with you. After spending some time to consider this case, I found out that  I tried to apply greedy pattern to solve this problem, but the key point is that k could be very small such that we have to enumerate all posibilities."
                    },
                    {
                        "username": "AshutoshBits",
                        "content": "Hi, Can someone comment why the answer for this testcase is 3?\\nnums = [1,3,2,2,1,3,3] , k=1"
                    },
                    {
                        "username": "hero080",
                        "content": "It is actually possible to do this in $O(N \\\\log N)$\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "Zetsu_24",
                        "content": "\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        int sum = 0;\\n        int mnsum = INT_MAX;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            map<int,int> mp;\\n            sum = 0;\\n\\n            for(int j=0;j<i;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            int x = 0;\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    x++;\\n                }\\n            }\\n\\n            mp.clear();\\n\\n            sum += k + (i-x);\\n\\n            int y = 0;\\n\\n            for(int j=i;j<n;j++)\\n            {\\n                mp[nums[j]]++;\\n            }\\n\\n            for(auto&it : mp)\\n            {\\n                if(it.second==1)\\n                {\\n                    y++;\\n                }\\n            }\\n\\n            sum += k + (n-i-y);\\n\\n            mnsum = min(sum,mnsum);\\n        }\\n\\n        map<int,int>mp1;\\n\\n        int z = 0;\\n\\n        // for the whole subarray as partition\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[nums[i]]++;\\n        }\\n\\n        for(auto& it : mp1)\\n        {\\n            if(it.second==1)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        mnsum = min(mnsum,(n-z)+k);\\n\\n        return mnsum;\\n    }\\n};\\n\\n\\nTest cases passed :- 29/59\\n\\nnums =\\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\\nk = 3\\n\\nexpected :- 17\\n\\nmy code is giving 19 plz can anybody what is wrong in my code\\nThanks! In Advance\\n"
                    },
                    {
                        "username": "ReiKun",
                        "content": "can someone help why I\\'m getting TLE. This Should be N^2 \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int> &cache, const vector<int> const &nums, int k) {        \\n        if (cache[i] != -1) return cache[i];\\n        int res = INT_MAX;\\n        vector<int> cnt(nums.size() + 1);\\n        int curOnes = 0;\\n        int curLength = 0;\\n        for(; i < nums.size(); i++) {\\n            cnt[nums[i]]++;\\n            if (cnt[nums[i]] == 1) curOnes++;\\n            else if (cnt[nums[i]] == 2) curOnes--;\\n            curLength++;\\n            int trimmedLength = curLength - curOnes;\\n            int nextSplit = i == nums.size() - 1 ? 0 : solve(i + 1, cache, nums, k);\\n            res = min(res, k + trimmedLength + nextSplit);\\n        }\\n        cache[i] = res;\\n        return res;\\n    }\\n    \\n    int minCost(vector<int>& nums, int k) {\\n        vector<int> cache(nums.size() + 1, -1);        \\n        int res = solve(0, cache, nums, k);\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "XKTZ",
                        "content": "Is there a O(N log^k(N)) solution for this question? I am not sure if the process in looking for the value could be optimized, for example, using a merge sort tree"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do $O(N \\\\log N)$:\\nhttps://leetcode.com/problems/minimum-cost-to-split-an-array/solutions/3942831/beat-100-o-n-log-n-most-efficient-solution-step-by-step-explanation/"
                    },
                    {
                        "username": "gavinyck",
                        "content": "For testcase :\nnums =\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\nk =\n3\n\nI've just listed all the possible solutions, and got the minimal answer which is 19, However, the expected result is 17.\nCould somebody tell me which part I might misunderstand? Thanks.\n\n\"^\" means the split position\n[^5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n0 + 21 = 21\n[5^6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6^4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 20 = 23\n[5,6,4^3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 19 = 22\n[5,6,4,3^2,5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 18 = 21\n[5,6,4,3,2^5,4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n3 + 16 = 19\n[5,6,4,3,2,5^4,1,5,2,0,5,4,3,1,5,4,3,4,4]\n5 + 15 = 20\n[5,6,4,3,2,5,4^1,5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 14 = 21\n[5,6,4,3,2,5,4,1^5,2,0,5,4,3,1,5,4,3,4,4]\n7 + 12 = 19\n[5,6,4,3,2,5,4,1,5^2,0,5,4,3,1,5,4,3,4,4]\n8 + 11 = 19\n[5,6,4,3,2,5,4,1,5,2^0,5,4,3,1,5,4,3,4,4]\n10 + 11 = 21\n[5,6,4,3,2,5,4,1,5,2,0^5,4,3,1,5,4,3,4,4]\n10 + 11 =  21\n[5,6,4,3,2,5,4,1,5,2,0,5^4,3,1,5,4,3,4,4]\n11 + 9 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4^3,1,5,4,3,4,4]\n12 + 8 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3^1,5,4,3,4,4]\n14 + 6 = 20\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1^5,4,3,4,4]\n16 + 6 = 22\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5^4,3,4,4]\n17 + 6 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4^3,4,4]\n18 + 5 = 23\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3^4,4]\n19 + 5 = 24\n[5,6,4,3,2,5,4,1,5,2,0,5,4,3,1,5,4,3,4^4]\n20 + 3 = 23"
                    },
                    {
                        "username": "triangleofcoding",
                        "content": "hey bro , you can split the array multiple times (not mentioned in the question) ... that the problem .. you were trying to spit the array only online in O(N) time complexity ..... you have to use dp for solving that"
                    },
                    {
                        "username": "adjee2020",
                        "content": " `// this is working \n    int fun(vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        for(int idx = n-1; idx>=0; idx--){\n            ll mini = 1e17;\n            int multi = 0;\n            unordered_map<int , int> s;\n            for(int i=idx ; i<n; i++){\n                if(s[nums[i]] == 1) multi += 2;    \n                else if(s[nums[i]]>1) multi++;\n                ++s[nums[i]];\n\n                ll val = k + multi + dp[i+1];\n                mini = min(mini , val);\n            }\n            dp[idx] = mini;\n        }\n        return dp[0];\n    }\n\n    // this is not working\n    int memofun(int idx , vector<int> &nums , int k , vector<int> &dp){\n        int n = nums.size();\n        long long mini = 1e17;\n        \n        if(idx == n) return 0;\n        \n        if(dp[idx] != -1) return dp[idx];\n        \n        int multi = 0;\n        unordered_map<int , int> s;\n        for(int i=idx ; i<n; i++){\n            if(s[nums[i]] == 1) multi += 2;    \n            else if(s[nums[i]]>1) multi++;\n            ++s[nums[i]];\n            \n            long long val = k + multi  + memofun(i+1 , nums , k , dp);;\n            mini = min(mini , val);\n        }\n        return dp[idx] = mini;\n    } `\n\ncan somebody explain why the first method is working but second one is not , i have used same idea to solve in both the case just difference is first one is botton-up approch and second one is top-down approch ??"
                    },
                    {
                        "username": "sampleaccountpage",
                        "content": "greedy wouldn\\'t work because the local decision based on the past might be changed by the conditions in the future.\\nFor example, in [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3, 2, 4, 1, 2, 5, 1, 2, 0]\\nWe can have [4, 4, 2, 3, 3, 3, 1, 5, 5, 0, 5, 3] in the current group. \\nAdding 4 after 2 here would result in an increment of 2 because of 2 since 1 is not counted at all instead of counted as 1.\\nThe remaining part might have [4, 2, 2] so adding 4 to the first group saves 2 from the second group,\\nor it could have [5] so leaving 2 and 4 in the second group is better. \\n"
                    }
                ]
            }
        ]
    }
]