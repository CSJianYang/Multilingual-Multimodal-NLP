[
    {
        "title": "Defuse the Bomb",
        "question_content": "You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code&nbsp;of length of n&nbsp;and a key k.\nTo decrypt the code, you must replace every number. All the numbers are replaced simultaneously.\n\n\tIf k > 0, replace the ith number with the sum of the next k numbers.\n\tIf k < 0, replace the ith number with the sum of the previous k numbers.\n\tIf k == 0, replace the ith number with 0.\n\nAs code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].\nGiven the circular array code and an integer key k, return the decrypted code to defuse the bomb!\n&nbsp;\nExample 1:\n\nInput: code = [5,7,1,4], k = 3\nOutput: [12,10,16,13]\nExplanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.\n\nExample 2:\n\nInput: code = [1,2,3,4], k = 0\nOutput: [0,0,0,0]\nExplanation: When k is zero, the numbers are replaced by 0. \n\nExample 3:\n\nInput: code = [2,4,9,3], k = -2\nOutput: [12,5,6,13]\nExplanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.\n\n&nbsp;\nConstraints:\n\n\tn == code.length\n\t1 <= n&nbsp;<= 100\n\t1 <= code[i] <= 100\n\t-(n - 1) <= k <= n - 1",
        "solutions": [
            {
                "id": 935398,
                "title": "java-o-n-100-time-and-space-short-concise-sliding-window",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] res = new int[code.length];\\n        if (k == 0) return res;\\n        //Define the initial window and initial sum\\n        int start = 1, end = k, sum = 0;\\n        if (k < 0) {//If k < 0, the starting point will be end of the array.\\n            k = -k;\\n            start = code.length - k;\\n            end = code.length - 1;\\n        }\\n        for (int i = start; i <= end; i++) sum += code[i];\\n        //Scan through the code array as i moving to the right, update the window sum.\\n        for (int i = 0; i < code.length; i++) {\\n            res[i] = sum;\\n            sum -= code[(start++) % code.length];\\n            sum += code[(++end) % code.length];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] res = new int[code.length];\\n        if (k == 0) return res;\\n        //Define the initial window and initial sum\\n        int start = 1, end = k, sum = 0;\\n        if (k < 0) {//If k < 0, the starting point will be end of the array.\\n            k = -k;\\n            start = code.length - k;\\n            end = code.length - 1;\\n        }\\n        for (int i = start; i <= end; i++) sum += code[i];\\n        //Scan through the code array as i moving to the right, update the window sum.\\n        for (int i = 0; i < code.length; i++) {\\n            res[i] = sum;\\n            sum -= code[(start++) % code.length];\\n            sum += code[(++end) % code.length];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948726,
                "title": "c-sliding-window-linear-time-and-constant-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t// Taking a window of k elements\\n\\t\\t\\n\\t\\t// First window will be from index 1 to index k\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n\\t\\t   // if k is negative then the first window will be the last k elements\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        // maintaining first window\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            // sliding the window \\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t// Taking a window of k elements\\n\\t\\t\\n\\t\\t// First window will be from index 1 to index k\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n\\t\\t   // if k is negative then the first window will be the last k elements\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        // maintaining first window\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            // sliding the window \\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935444,
                "title": "clean-python-3-prefix-sum-o-n",
                "content": "Use the prefix sum trick to get range sum in O(1)\\nTime: `O(N)`\\nSpace: `O(N)`\\nThanks @WangQiuc\\'s suggestion.\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(1, 2 * n):\\n            prefix[i] += prefix[i - 1]\\n        for i in range(n):\\n            code[i] = prefix[i + k] - prefix[i]\\n        return code\\n```\\n\\nOne pass\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(2 * n):\\n            prefix[i] += i > 0 and prefix[i - 1]\\n            if k <= i < n + k:\\n                code[i - k] = prefix[i] - prefix[i - k]\\n        return code\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(1, 2 * n):\\n            prefix[i] += prefix[i - 1]\\n        for i in range(n):\\n            code[i] = prefix[i + k] - prefix[i]\\n        return code\\n```\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(2 * n):\\n            prefix[i] += i > 0 and prefix[i - 1]\\n            if k <= i < n + k:\\n                code[i - k] = prefix[i] - prefix[i - k]\\n        return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936749,
                "title": "pyhton3-beats-100-double-the-code-array",
                "content": "Double the ```code``` array so that it\\'s easy to iterate.\\n```class Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k==0: return [0 for i in code]\\n        temp = code\\n        code = code*2\\n        for i in range(len(temp)):\\n            if k>0:\\n                temp[i] = sum(code[i+1:i+k+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        return temp",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```code```",
                "codeTag": "Unknown"
            },
            {
                "id": 935478,
                "title": "python-3-clean-sliding-window",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```\\n\\n- for negative k: reverse params and result\\n- calculate sum of k element, then iteratively add new element and remove oldest one.\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935457,
                "title": "my-short-easy-to-understand-solution",
                "content": "To deal with this kind of problem, we need to play with the index wisely and carefully, just like defusing a bomb (lol). There are 3 points we need to notice:\\n\\n0. We need to return the result directly if k == 0 based on the problem statement. (I will handle this case specifically, to make it more readable and slightly faster :) )\\n1. We need to do ***%*** to make sure the index is always in-bound when k > 0;\\n2. We need to do ***+code.length*** to make sure it is alway > 0, and ***%*** to make sure the index is always in-bound when k < 0.\\n\\nHere is my code: \\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint[] result = new int[code.length];\\n\\tif (k == 0) {\\n\\t\\treturn result;\\n\\t}\\n\\tfor (int i = 0; i < result.length; i++) {\\n\\t\\tif (k > 0) {\\n\\t\\t\\tfor (int j = i + 1; j < i + k + 1; j++) {\\n\\t\\t\\t\\tresult[i] += code[j % code.length];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int j = i - 1; j > i + k - 1; j--) {\\n\\t\\t\\t\\tresult[i] += code[(j + code.length) % code.length];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;        \\n}\\n```\\n\\nPlease upvote if you find this is helpful! :)",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint[] result = new int[code.length];\\n\\tif (k == 0) {\\n\\t\\treturn result;\\n\\t}\\n\\tfor (int i = 0; i < result.length; i++) {\\n\\t\\tif (k > 0) {\\n\\t\\t\\tfor (int j = i + 1; j < i + k + 1; j++) {\\n\\t\\t\\t\\tresult[i] += code[j % code.length];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int j = i - 1; j > i + k - 1; j--) {\\n\\t\\t\\t\\tresult[i] += code[(j + code.length) % code.length];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942580,
                "title": "c-easy-solution-brute-force",
                "content": "if you don\\'t know how this code works,you could comment below.\\nI will try my best to answer your question! :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int>Ans(code.size(),0);\\n        \\n        for(int i = 0;i<code.size();i++){\\n            if (k > 0){\\n                int total = 0;\\n                for(int count = 1;count<=k;count++){\\n                    int num = i + count;\\n                    num = num % code.size(); \\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else if (k < 0){\\n                int total = 0;\\n                for(int count = -1;count>=k;count--){\\n                    int num = i + count;\\n                    if (num < 0){\\n                        num = code.size() + num;\\n                    }\\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else{\\n                Ans[i] = 0;\\n            }\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int>Ans(code.size(),0);\\n        \\n        for(int i = 0;i<code.size();i++){\\n            if (k > 0){\\n                int total = 0;\\n                for(int count = 1;count<=k;count++){\\n                    int num = i + count;\\n                    num = num % code.size(); \\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else if (k < 0){\\n                int total = 0;\\n                for(int count = -1;count>=k;count--){\\n                    int num = i + count;\\n                    if (num < 0){\\n                        num = code.size() + num;\\n                    }\\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else{\\n                Ans[i] = 0;\\n            }\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218554,
                "title": "very-easy-solution-explained-with-sample-implementation-break-the-cycle-prefix-suffix-sum",
                "content": "*------Please **upvote** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**EXPLANATION:**\\n\\n**Prerequisites -** *Prefix Sum* and *Suffix Sum* of an Array.\\n\\nFirst, we **simplify** the problem by **breaking the cycle.** \\n\\n*****How?*****  Just append the array to itself and the cycle will be broken into a linear array.\\n\\nTake the sample input array **code** as: **[5, 7, 1, 4]**\\nAppending it to itself, we get our new array **arr** as: **[5, 7, 1, 4, 5, 7, 1, 4]**.  We will now use this array for calculation.\\n\\n1. If **k = 0**: Just change all array elements of **code** to **0** and return **code**.\\n\\n2. If **k > 0**:  We calculate the **prefix** sum array **pre** of **arr** and our result for every index **i** would be **pre [i + k] - pre [i]**.  Sample implementation:\\n\\n**arr:** `[5, 7, 1, 4, 5, 7, 1, 4]`\\n**pre:** `[5, 12, 13, 17, 22, 29, 30, 34]`\\n\\n**k = 2**\\n\\nNow, for every index **i**: **code [i]** will become **pre [i + 2] - pre [i]**.\\n\\n**i = 0**: `code [0]` = `pre [0 + 2] - pre [0]` = `pre [2] - pre [0]` = **8**\\n**i = 1**: `code [1]` = `pre [1 + 2] - pre [1]` = `pre [3] - pre [1]` = **5**\\n**i = 2**: `code [2]` = `pre [2 + 2] - pre [2]` = `pre [4] - pre [2]` = **9**\\n**i = 3**: `code [3]` = `pre [3 + 2] - pre [3]` = `pre [5] - pre [3]` = **12**\\n\\nReturn **code** as **`[8, 5, 9, 12]`**\\n\\n3. If **k < 0**:  We calculate the **suffix** sum array **suf** of **arr** and our result for every index **i** would be **suf [i + n - k] - suf [i + n]** where **`n = length (code)`**.  Sample implementation:\\n\\n**arr:** `[5, 7, 1, 4, 5, 7, 1, 4]`\\n**suf:** `[34, 29, 22, 21, 17, 12, 5, 4]`\\n\\n**k = -2**\\n\\nHere, we will proceed in the reverse order (right - to - left) because the suffix sum is calculated from the right - to - left direction.\\n\\nNow, for every index **i**: **code [i]** will become **suf [i + 4 - 2] - suf [i + 4]**.\\n\\n**i = 3**: `code [3]` = `suf [3 + 4 - 2] - suf [3 + 4]` = `suf [5] - suf [7]` = **8**\\n**i = 2**: `code [2]` = `suf [2 + 4 - 2] - suf [2 + 4]` = `suf [4] - suf [6]` = **12**\\n**i = 1**: `code [1]` = `suf [1 + 4 - 2] - suf [1 + 4]` = `suf [3] - suf [5]` = **9**\\n**i = 0**: `code [0]` = `suf [0 + 4 - 2] - suf [0 + 4]` = `suf [2] - suf [4]` = **5**\\n\\nReturn **code** as **`[5, 9, 12, 8]`**\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = 0;\\n        }\\n        \\n        else if (k > 0) {\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int prefix [] = new int [arr.length];\\n            prefix [0] = arr [0];\\n            for (int i = 1; i < prefix.length; i++)\\n                prefix [i] = prefix [i-1] + arr [i];\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = prefix [i + k] - prefix [i];\\n        }\\n        \\n        else {\\n            k = Math.abs (k);\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int suffix [] = new int [arr.length];\\n            suffix [arr.length - 1] = arr [arr.length - 1];\\n            for (int i = suffix.length - 2; i >= 0; i--)\\n                suffix [i] = suffix [i+1] + arr [i];\\n            for (int i = code.length - 1; i >= 0; i--)\\n                code [i] = suffix [i + code.length - k] - suffix [i + code.length];\\n        }\\n        \\n        return code;\\n    }\\n}\\n```\\n\\nPlease **upvote!** if you like the solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = 0;\\n        }\\n        \\n        else if (k > 0) {\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int prefix [] = new int [arr.length];\\n            prefix [0] = arr [0];\\n            for (int i = 1; i < prefix.length; i++)\\n                prefix [i] = prefix [i-1] + arr [i];\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = prefix [i + k] - prefix [i];\\n        }\\n        \\n        else {\\n            k = Math.abs (k);\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int suffix [] = new int [arr.length];\\n            suffix [arr.length - 1] = arr [arr.length - 1];\\n            for (int i = suffix.length - 2; i >= 0; i--)\\n                suffix [i] = suffix [i+1] + arr [i];\\n            for (int i = code.length - 1; i >= 0; i--)\\n                code [i] = suffix [i + code.length - k] - suffix [i + code.length];\\n        }\\n        \\n        return code;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947553,
                "title": "java-o-n-using-prefix-sum-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] presum = new int[code.length];\\n        int[] postsum = new int[code.length];\\n\\t\\t\\n\\t\\t//Create prefix sum array\\n        int sum = 0;\\n        for(int i=0; i<code.length; ++i){\\n            sum += code[i];\\n            presum[i] = sum;\\n        }\\n        \\n\\t\\t//Create prefix sum array in reverse\\n        sum=0;\\n        for(int i=code.length-1; i>=0; --i){\\n            sum += code[i];\\n            postsum[i] = sum;\\n        }\\n        \\n        for(int i=0; i<code.length; ++i){\\n            if(k > 0){\\n                if((i+k) < code.length){\\n                    code[i] = presum[i+k]-presum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//presum[code.length-1] - presum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//presum[k-(code.length -i)]; --> Elements left of i\\n                    code[i] = presum[code.length-1] - presum[i] + presum[k-(code.length -i)];\\n                }   \\n            }else if(k == 0){\\n                code[i] = 0;\\n            }else{\\n                if(i+k >= 0){\\n                    code[i] = postsum[i+k] - postsum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//postsum[0] - postsum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//postsum[code.length+(i+k)] --> Elements left of i\\n                    code[i] = postsum[0] - postsum[i] + postsum[code.length+(i+k)];\\n                }\\n            }\\n        }\\n\\t\\t\\n        return code;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] presum = new int[code.length];\\n        int[] postsum = new int[code.length];\\n\\t\\t\\n\\t\\t//Create prefix sum array\\n        int sum = 0;\\n        for(int i=0; i<code.length; ++i){\\n            sum += code[i];\\n            presum[i] = sum;\\n        }\\n        \\n\\t\\t//Create prefix sum array in reverse\\n        sum=0;\\n        for(int i=code.length-1; i>=0; --i){\\n            sum += code[i];\\n            postsum[i] = sum;\\n        }\\n        \\n        for(int i=0; i<code.length; ++i){\\n            if(k > 0){\\n                if((i+k) < code.length){\\n                    code[i] = presum[i+k]-presum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//presum[code.length-1] - presum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//presum[k-(code.length -i)]; --> Elements left of i\\n                    code[i] = presum[code.length-1] - presum[i] + presum[k-(code.length -i)];\\n                }   \\n            }else if(k == 0){\\n                code[i] = 0;\\n            }else{\\n                if(i+k >= 0){\\n                    code[i] = postsum[i+k] - postsum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//postsum[0] - postsum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//postsum[code.length+(i+k)] --> Elements left of i\\n                    code[i] = postsum[0] - postsum[i] + postsum[code.length+(i+k)];\\n                }\\n            }\\n        }\\n\\t\\t\\n        return code;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285276,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n     public int[] decrypt(int[] code, int k) {\\n        int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int[] decrypt(int[] code, int k) {\\n        int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153936,
                "title": "simple-and-easy",
                "content": "```\\noutput = []\\nfor i in range(len(code)):\\n\\tif k > 0:\\n\\t\\tsum = 0\\n\\t\\tj = i+1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm-=1\\n\\t\\t\\tj+=1\\n\\t\\toutput.append(sum)\\n\\n\\telif k == 0:\\n\\t\\toutput.append(0)\\n\\n\\telse:\\n\\t\\tsum = 0\\n\\t\\tj = i-1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm+=1\\n\\t\\t\\tj-=1\\n\\t\\toutput.append(sum)\\n\\nreturn output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\noutput = []\\nfor i in range(len(code)):\\n\\tif k > 0:\\n\\t\\tsum = 0\\n\\t\\tj = i+1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm-=1\\n\\t\\t\\tj+=1\\n\\t\\toutput.append(sum)\\n\\n\\telif k == 0:\\n\\t\\toutput.append(0)\\n\\n\\telse:\\n\\t\\tsum = 0\\n\\t\\tj = i-1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm+=1\\n\\t\\t\\tj-=1\\n\\t\\toutput.append(sum)\\n\\nreturn output\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008102,
                "title": "go-o-n-0ms-2-3mb-sliding-window-with-wrapping-indexes",
                "content": "```\\nfunc decrypt(code []int, k int) []int {\\n    n := len(code)\\n    result := make([]int, n)\\n    if k == 0 {\\n        return result\\n    }\\n    start, end := 1, k + 1\\n    if k < 0 {\\n        start, end  =  n + k, n\\n    }\\n    s := 0\\n    for i := start; i < end; i++ {\\n        s += code[i]\\n    }\\n    for i := 0; i < n; i++ {\\n        result[i] = s\\n        s = s - code[(start + i) % n] + code[(end + i) % n]\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    n := len(code)\\n    result := make([]int, n)\\n    if k == 0 {\\n        return result\\n    }\\n    start, end := 1, k + 1\\n    if k < 0 {\\n        start, end  =  n + k, n\\n    }\\n    s := 0\\n    for i := start; i < end; i++ {\\n        s += code[i]\\n    }\\n    for i := 0; i < n; i++ {\\n        result[i] = s\\n        s = s - code[(start + i) % n] + code[(end + i) % n]\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942554,
                "title": "java-o-n-clear-explanation-beats-100",
                "content": "The idea is that for each index i, we will need to be able to query the sum of the next or prev k numbers - an easy way to achieve this is to cache the prefix sums.\\n\\nHowever, there is the added complexity of circular array so we can simply create a prefix sum array that is twice the normal length. Essentially caching the prefix sums of the array repeated.\\n\\ni.e. For something like A = [1,2,3,4], we can concatentate it with itself to create B = [1,2,3,4,1,2,3,4] so that it is easier to work with when applying circular things. \\n\\nWhen working with A, if k = 3 and i = 1, then normally we would have an add indexes 2, 3 and 4. However, index 4 would in fact be index 0 since we are working with a circular array. With our concatenated array B, we would be able to directly access index 4.\\n\\nTaking this concept 1 step further, we can then prefix sum cache this concatenated version which gives us a prefix sum cache that can find circular ranges. So if k < 0, we can find the range sum of [i-k, i-1] and if k > 0, we can find the range sum of [i+1, i+k].\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if(k == 0) return new int[code.length];\\n        \\n        int[] prefix = new int[code.length * 2 + 1];\\n        for(int i = 0; i < code.length * 2; i++) {\\n            prefix[i+1] = prefix[i] + code[i % code.length];\\n        }\\n        \\n        int[] ret = new int[code.length];\\n        for(int i = 0; i < code.length; i++) {\\n            int end = i + k;\\n            if(k < 0) {\\n                ret[i] = prefix[i + code.length] - prefix[end + code.length];\\n            }\\n            else {\\n                ret[i] = prefix[end + 1] - prefix[i+1];\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if(k == 0) return new int[code.length];\\n        \\n        int[] prefix = new int[code.length * 2 + 1];\\n        for(int i = 0; i < code.length * 2; i++) {\\n            prefix[i+1] = prefix[i] + code[i % code.length];\\n        }\\n        \\n        int[] ret = new int[code.length];\\n        for(int i = 0; i < code.length; i++) {\\n            int end = i + k;\\n            if(k < 0) {\\n                ret[i] = prefix[i + code.length] - prefix[end + code.length];\\n            }\\n            else {\\n                ret[i] = prefix[end + 1] - prefix[i+1];\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352139,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        l = code + code\\n        if k == 0:\\n            return [0]*n\\n        elif k > 0:\\n            ans = []\\n            for i in range(n):\\n                ans.append(sum(l[i+1:i+k+1]))\\n            return ans\\n        else:\\n            ans = []\\n            j = n\\n            for i in range(n):\\n                ans.append(sum(l[j+k:j]))\\n                j += 1\\n            return ans\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        l = code + code\\n        if k == 0:\\n            return [0]*n\\n        elif k > 0:\\n            ans = []\\n            for i in range(n):\\n                ans.append(sum(l[i+1:i+k+1]))\\n            return ans\\n        else:\\n            ans = []\\n            j = n\\n            for i in range(n):\\n                ans.append(sum(l[j+k:j]))\\n                j += 1\\n            return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 971143,
                "title": "javascript-simple",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    var res = new Array(code.length).fill(0)\\n    if (k > 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i + 1\\n            while(count < k){\\n                if (j === code.length) j = 0\\n                res[i] += code[j]\\n                count = count + 1\\n                j++\\n            }\\n        }\\n    }\\n    if (k < 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i - 1\\n            while(count > k){\\n                if (j === -1) j = code.length - 1\\n                res[i] += code[j]\\n                count = count - 1\\n                j--\\n            }\\n        }\\n    }\\n    return res \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    var res = new Array(code.length).fill(0)\\n    if (k > 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i + 1\\n            while(count < k){\\n                if (j === code.length) j = 0\\n                res[i] += code[j]\\n                count = count + 1\\n                j++\\n            }\\n        }\\n    }\\n    if (k < 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i - 1\\n            while(count > k){\\n                if (j === -1) j = code.length - 1\\n                res[i] += code[j]\\n                count = count - 1\\n                j--\\n            }\\n        }\\n    }\\n    return res \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367476,
                "title": "defuse-the-bomb-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int i, j, m, num;\\n        vector<int> ans;\\n        for(i=0 ; i<code.size() ; i++)\\n        {\\n            num=0;\\n            j = i;\\n            m = abs(k);\\n            while(m--)\\n            {\\n                if(k<0)\\n                {\\n                    j = j-1;\\n                    if(j<0)\\n                        j += code.size();\\n                    num += code[j];\\n                }\\n                else if(k>0)\\n                {\\n                    j = j+1;\\n                    if(j>=code.size())\\n                        j -= code.size();\\n                    num += code[j];\\n                }\\n            }\\n            ans.push_back(num);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int i, j, m, num;\\n        vector<int> ans;\\n        for(i=0 ; i<code.size() ; i++)\\n        {\\n            num=0;\\n            j = i;\\n            m = abs(k);\\n            while(m--)\\n            {\\n                if(k<0)\\n                {\\n                    j = j-1;\\n                    if(j<0)\\n                        j += code.size();\\n                    num += code[j];\\n                }\\n                else if(k>0)\\n                {\\n                    j = j+1;\\n                    if(j>=code.size())\\n                        j -= code.size();\\n                    num += code[j];\\n                }\\n            }\\n            ans.push_back(num);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482725,
                "title": "defuse-the-bomb",
                "content": "\\tclass Solution:\\n\\t\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n\\t\\t\\tlength = len(code) \\n\\t\\t\\tans=[0 for i in range(length)] \\n\\n\\t\\t\\tif k==0:  return ans \\n\\n\\t\\t\\tif k < 0:  code.reverse() \\n\\n\\t\\t\\tsumm = sum(code[:abs(k)])\\n\\n\\t\\t\\tfor i in range(length):\\n\\t\\t\\t\\t\\tsumm = summ-code[i]+code[(i+abs(k))%length]   \\n\\t\\t\\t\\t\\tans[i] = summ \\n\\n\\t\\t\\treturn reversed(ans) if k<0 else ans  \\n\\t\\t\\t\\n\\t\\t\\t",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n\\t\\t\\tlength = len(code) \\n\\t\\t\\tans=[0 for i in range(length)] \\n\\n\\t\\t\\tif k==0:  return ans \\n\\n\\t\\t\\tif k < 0:  code.reverse() \\n\\n\\t\\t\\tsumm = sum(code[:abs(k)])\\n\\n\\t\\t\\tfor i in range(length):\\n\\t\\t\\t\\t\\tsumm = summ-code[i]+code[(i+abs(k))%length]   \\n\\t\\t\\t\\t\\tans[i] = summ \\n\\n\\t\\t\\treturn reversed(ans) if k<0 else ans  \\n\\t\\t\\t\\n\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1903674,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0] * len(code)\\n        data = code + code\\n        result = [sum(data[i + 1: i + 1 + abs(k)]) for i in range(len(code))]\\n\\t\\t# result = []\\n        # for i in range(len(code)):\\n        #     result.append(sum(data[i + 1: i + 1 + abs(k)]))\\n        if 0 > k:\\n            return result[k - 1:] + result[:k - 1]\\n        return result\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0] * len(code)\\n        data = code + code\\n        result = [sum(data[i + 1: i + 1 + abs(k)]) for i in range(len(code))]\\n\\t\\t# result = []\\n        # for i in range(len(code)):\\n        #     result.append(sum(data[i + 1: i + 1 + abs(k)]))\\n        if 0 > k:\\n            return result[k - 1:] + result[:k - 1]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384496,
                "title": "c-solution-simple-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n    vector<int> ans;\\n    int n=code.size();\\n    if (k > 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + 1, temp = 0;\\n            while (temp++ != k)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else if (k < 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + k + n, temp = k;\\n            while (temp++ != 0)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else\\n        for (int i = 0; i < n; i++)\\n            ans.push_back(0);\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n    vector<int> ans;\\n    int n=code.size();\\n    if (k > 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + 1, temp = 0;\\n            while (temp++ != k)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else if (k < 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + k + n, temp = k;\\n            while (temp++ != 0)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else\\n        for (int i = 0; i < n; i++)\\n            ans.push_back(0);\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152661,
                "title": "python-3-o-n-sliding-window-with-array-rotation",
                "content": "# Intuition\\nOn close inspection we find that K<0 case solution is just a rotated form of K>0 solution\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nReturn 0 array for k==0 case and for other case find the next k sum array by sliding window technique and in case the k value is negative then rotate the ans list by k-1.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ans=[]\\n        s=0\\n        if k==0:\\n            ans = [0]*len(code)\\n        else:\\n            absK=abs(k)\\n            s=sum(code[0:absK])\\n            for i in range(len(code)):\\n                s=s-code[i]+code[(i+absK)%len(code)]\\n                ans.append(s)\\n            if k<0:\\n                ans=ans[k-1:]+ans[:k-1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ans=[]\\n        s=0\\n        if k==0:\\n            ans = [0]*len(code)\\n        else:\\n            absK=abs(k)\\n            s=sum(code[0:absK])\\n            for i in range(len(code)):\\n                s=s-code[i]+code[(i+absK)%len(code)]\\n                ans.append(s)\\n            if k<0:\\n                ans=ans[k-1:]+ans[:k-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933571,
                "title": "java-sliding-window-explained",
                "content": "**Idea:** Use a sliding window to maintain sum\\n>**T/S:** O(n)/O(1), where n = size(code), (ignoring space for output)\\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tvar n = code.length;\\n\\treturn k > 0 \\n\\t\\t ? decrypt(code, new int[n], k, 1, k + 1) \\n\\t\\t : decrypt(code, new int[n], k, n + k, n);\\n}\\n\\n// [left, right)\\nprivate int[] decrypt(int[] code, int[] decode, int k, int left, int right) {\\n\\tif (k == 0)\\n\\t\\treturn decode;\\n\\t\\t\\n\\tvar sum = decode[0] = Arrays.stream(code, left, right).sum();\\n\\t\\n\\tfor (int i = 1, n = decode.length; i < n; i++, left++, right++)\\n\\t\\tdecode[i] = sum += code[right % n] - code[left % n];\\n\\t\\n\\treturn decode;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tvar n = code.length;\\n\\treturn k > 0 \\n\\t\\t ? decrypt(code, new int[n], k, 1, k + 1) \\n\\t\\t : decrypt(code, new int[n], k, n + k, n);\\n}\\n\\n// [left, right)\\nprivate int[] decrypt(int[] code, int[] decode, int k, int left, int right) {\\n\\tif (k == 0)\\n\\t\\treturn decode;\\n\\t\\t\\n\\tvar sum = decode[0] = Arrays.stream(code, left, right).sum();\\n\\t\\n\\tfor (int i = 1, n = decode.length; i < n; i++, left++, right++)\\n\\t\\tdecode[i] = sum += code[right % n] - code[left % n];\\n\\t\\n\\treturn decode;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2819345,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n\\n   class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n   class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599513,
                "title": "java-beats-100-simple",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int res[]=new int[code.length];\\n        if(k==0) return res;\\n        int i= (k>0) ? 1 : code.length-1;\\n        int j=i;\\n        int sum=0;\\n        if(k>0){\\n            while(--k>=0)\\n            {\\n               sum+=code[j++]; \\n            }\\n            j--;\\n        }else{\\n            while(++k<=0){\\n                sum+=code[j--]; \\n            }\\n            j++;\\n            int temp=j;\\n            j=i;\\n            i=temp;\\n        }\\n        \\n        for(int p=0;p<code.length;p++){\\n            res[p]=sum;\\n          //  System.out.println(i+\" \"+j);\\n            j=(j+1)%code.length;\\n            sum=sum+(code[j]-code[i]);\\n            i=(i+1)%code.length;\\n        }\\n        return res;\\n    }\\n}\\nPlease upvote if you like the solution \\uD83D\\uDE4F",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int res[]=new int[code.length];\\n        if(k==0) return res;\\n        int i= (k>0) ? 1 : code.length-1;\\n        int j=i;\\n        int sum=0;\\n        if(k>0){\\n            while(--k>=0)\\n            {\\n               sum+=code[j++]; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2304860,
                "title": "defuse-the-bomb-solution-in-c",
                "content": "**Here You Go =>**\\n\\n```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    int* result=malloc(codeSize*sizeof(int));\\n    int n1,sum;\\n    if (k>0){\\n        for (int i=0;i<codeSize;i++){           // To cover all elements in code array\\n            for (int j=1;j<=k;j++){             // Cover elements till k\\n                n1=code[(i+j)%codeSize];        // As it is a circular array, modulo by size of code array will give the desired result.\\n                                                // I recommend to DRY-RUN this line for Example in description to understand the working.\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;                               // Initialize n1 and sum to zero for next iteration.\\n            sum=0;\\n        }\\n    }\\n    \\n    // For k=0\\n    else if(k==0){\\n        for (int i=0;i<codeSize;i++)\\n            result[i]=0;                        // For k=0, simply initalize all elements in code array with 0\\n    }\\n    \\n    // For k<0\\n    else{\\n        for (int i=0;i<codeSize;i++){\\n            for (int j=1;j<=abs(k);j++){\\n                n1=code[(i+codeSize-j)%codeSize];       // Logic for negative k\\'s is almost same as of above. DRY-RUN this line of code for better understanding\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;\\n            sum=0;\\n        }   \\n    }\\n    *returnSize=codeSize;\\n    return result;              // Return the resultant array\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    int* result=malloc(codeSize*sizeof(int));\\n    int n1,sum;\\n    if (k>0){\\n        for (int i=0;i<codeSize;i++){           // To cover all elements in code array\\n            for (int j=1;j<=k;j++){             // Cover elements till k\\n                n1=code[(i+j)%codeSize];        // As it is a circular array, modulo by size of code array will give the desired result.\\n                                                // I recommend to DRY-RUN this line for Example in description to understand the working.\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;                               // Initialize n1 and sum to zero for next iteration.\\n            sum=0;\\n        }\\n    }\\n    \\n    // For k=0\\n    else if(k==0){\\n        for (int i=0;i<codeSize;i++)\\n            result[i]=0;                        // For k=0, simply initalize all elements in code array with 0\\n    }\\n    \\n    // For k<0\\n    else{\\n        for (int i=0;i<codeSize;i++){\\n            for (int j=1;j<=abs(k);j++){\\n                n1=code[(i+codeSize-j)%codeSize];       // Logic for negative k\\'s is almost same as of above. DRY-RUN this line of code for better understanding\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;\\n            sum=0;\\n        }   \\n    }\\n    *returnSize=codeSize;\\n    return result;              // Return the resultant array\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256306,
                "title": "c-straightforward-modulo",
                "content": "![image](https://assets.leetcode.com/users/images/7d3784bc-ac6c-4d88-82be-bd82375afbbc_1657312778.1436577.png)\\n\\n**T->O(n * k) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> decrypt(vector<int>& code, int k) {\\n\\t\\t\\tint n=code.size();\\n\\t\\t\\tvector<int>ans(n,0);\\n\\t\\t\\tif(k==0)return ans;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tif(k>0){\\n\\t\\t\\t\\t\\tfor(int j=(i+1)%n;count<k;j=(j+1)%n){\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tfor(int j=i-1;count<abs(k);j--){\\n\\t\\t\\t\\t\\t\\tif(j==-1)j=n-1;\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> decrypt(vector<int>& code, int k) {\\n\\t\\t\\tint n=code.size();\\n\\t\\t\\tvector<int>ans(n,0);\\n\\t\\t\\tif(k==0)return ans;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tif(k>0){\\n\\t\\t\\t\\t\\tfor(int j=(i+1)%n;count<k;j=(j+1)%n){\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2179759,
                "title": "c-100-fast-0ms-easy-to-understand",
                "content": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n         \\n         if(k==0)\\n             return ans;\\n         \\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0;\\n            int sum=0;\\n            int count=k;\\n            if(k>0)\\n            {\\n                 j=i+1;\\n                while(count--)\\n                {\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)\\n                   j=n-1;\\n                else\\n                   j=i-1;\\n                \\n                while(count++)\\n                {\\n                    sum+=code[j];\\n                    if(j==0)\\n                        j=n-1;\\n                    else\\n                        j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n         \\n         if(k==0)\\n             return ans;\\n         \\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0;\\n            int sum=0;\\n            int count=k;\\n            if(k>0)\\n            {\\n                 j=i+1;\\n                while(count--)\\n                {\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)\\n                   j=n-1;\\n                else\\n                   j=i-1;\\n                \\n                while(count++)\\n                {\\n                    sum+=code[j];\\n                    if(j==0)\\n                        j=n-1;\\n                    else\\n                        j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1674760,
                "title": "java-1ms-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len=code.length;\\n        int arr[]=new int[len];\\n        if(k==0)\\n            return arr;\\n        if(k>0)\\n        for(int i=0;i<len;i++)\\n        {\\n            int sum=0;\\n            for(int j=1;j<=k;j++)\\n            {\\n                sum+=code[(j+i)%len];\\n            }\\n            arr[i]=sum;\\n        }\\n        if(k<0)\\n        {\\n            k=-1*k;\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=1;j<=k;j++)\\n                {\\n                    sum+=code[(len-j+i)%len];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len=code.length;\\n        int arr[]=new int[len];\\n        if(k==0)\\n            return arr;\\n        if(k>0)\\n        for(int i=0;i<len;i++)\\n        {\\n            int sum=0;\\n            for(int j=1;j<=k;j++)\\n            {\\n                sum+=code[(j+i)%len];\\n            }\\n            arr[i]=sum;\\n        }\\n        if(k<0)\\n        {\\n            k=-1*k;\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=1;j<=k;j++)\\n                {\\n                    sum+=code[(len-j+i)%len];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172514,
                "title": "python-beats-99-using-modulus",
                "content": "```\\n```\\nr=[]\\n        n=len(code)\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(n):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(n):\\n                e=i+k\\n                if e>0:\\n                    x=sum(code[e:i])\\n                else:\\n                    x=sum(code[:i])+sum(code[n+e:])\\n                r.append(x)\\n            return r\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114282,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        a = code.copy()\\n        res = []\\n        if k==0:\\n            return [0]*n\\n        elif k>0:\\n            a += code\\n            for i in range(n):\\n                res.append(sum(a[i+1:i+k+1]))\\n        else:\\n            a = code+a\\n            k =abs(k)\\n            for i in range(n,len(a)):\\n                res.append(sum(a[i-k:i]))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        a = code.copy()\\n        res = []\\n        if k==0:\\n            return [0]*n\\n        elif k>0:\\n            a += code\\n            for i in range(n):\\n                res.append(sum(a[i+1:i+k+1]))\\n        else:\\n            a = code+a\\n            k =abs(k)\\n            for i in range(n,len(a)):\\n                res.append(sum(a[i-k:i]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010869,
                "title": "java-sum",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] sum = new int[len+1];\\n        int[] res = new int[len];\\n        for(int i=0; i<len; i++)\\n            sum[i+1] = sum[i] + code[i];\\n        if(k>0){\\n            for(int i=0; i<len; i++){\\n                if(i+k<len)\\n                    res[i] = sum[i+k+1]-sum[i+1];\\n                else\\n                    res[i] += sum[len]-sum[i+1]+sum[k-len+i+1];\\n            }\\n        }else if(k<0){\\n            k=-k;\\n            for(int i=0; i<len; i++){\\n                if(i-k>=0)\\n                    res[i] = sum[i]-sum[i-k];\\n                else\\n                    res[i] += sum[i]+sum[len]-sum[len-k+i];\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] sum = new int[len+1];\\n        int[] res = new int[len];\\n        for(int i=0; i<len; i++)\\n            sum[i+1] = sum[i] + code[i];\\n        if(k>0){\\n            for(int i=0; i<len; i++){\\n                if(i+k<len)\\n                    res[i] = sum[i+k+1]-sum[i+1];\\n                else\\n                    res[i] += sum[len]-sum[i+1]+sum[k-len+i+1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 941890,
                "title": "simple-5-line-python-faster-than-100-with-comments",
                "content": "```\\n    def decrypt(self, num: List[int], k: int) -> List[int]:\\n        n, w = len(num), abs(k)\\n        sums = [sum(num[1:w+1])]*n                      # sums[i] is the sum of a window of size |k| after i\\n        for i in range(1,n):\\n            sums[i] = sums[i-1] + num[(i+w)%n] - num[i]\\n        return sums if k>=0 else sums[~w:]+sums[:~w]    # if k is negative all we need to do is shift the sums to the right by |k|\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def decrypt(self, num: List[int], k: int) -> List[int]:\\n        n, w = len(num), abs(k)\\n        sums = [sum(num[1:w+1])]*n                      # sums[i] is the sum of a window of size |k| after i\\n        for i in range(1,n):\\n            sums[i] = sums[i-1] + num[(i+w)%n] - num[i]\\n        return sums if k>=0 else sums[~w:]+sums[:~w]    # if k is negative all we need to do is shift the sums to the right by |k|\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 938895,
                "title": "javascript-sliding-window",
                "content": "```\\nconst decrypt = (code, k) => {\\n  \\n  const decode = (code, k) => {\\n    const result = [];\\n    let sum = 0;\\n    for(let i = 0; i < k; i++)\\n      sum += code[i];\\n    \\n    for(let i = 0 ; i < code.length; i++){\\n      sum -= code[i];\\n      sum += code[(i+k) % code.length];\\n      result.push(sum);\\n    }\\n    return result;\\n  }\\n  \\n  return k > 0 ? decode(code,k) : decode(code.reverse(), -k).reverse();\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst decrypt = (code, k) => {\\n  \\n  const decode = (code, k) => {\\n    const result = [];\\n    let sum = 0;\\n    for(let i = 0; i < k; i++)\\n      sum += code[i];\\n    \\n    for(let i = 0 ; i < code.length; i++){\\n      sum -= code[i];\\n      sum += code[(i+k) % code.length];\\n      result.push(sum);\\n    }\\n    return result;\\n  }\\n  \\n  return k > 0 ? decode(code,k) : decode(code.reverse(), -k).reverse();\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936310,
                "title": "c-presum-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int N = code.size();\\n        vector<int> Sum(code), ans(N);\\n        for(int i=1; i<N; ++i) Sum[i] = Sum[i-1] + code[i];\\n        for(int i=0; i<N; ++i) {\\n            int start = (i + N + (k < 0 ? k - 1 : 0)) % N;\\n            int end = (i + N + (k > 0 ? k : -1)) % N;\\n            if(!k) ans[i] = 0;\\n            else if(start < end) ans[i] = Sum[end] - Sum[start];\\n            else                 ans[i] = Sum[end] + (Sum[N-1] - Sum[start]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int N = code.size();\\n        vector<int> Sum(code), ans(N);\\n        for(int i=1; i<N; ++i) Sum[i] = Sum[i-1] + code[i];\\n        for(int i=0; i<N; ++i) {\\n            int start = (i + N + (k < 0 ? k - 1 : 0)) % N;\\n            int end = (i + N + (k > 0 ? k : -1)) % N;\\n            if(!k) ans[i] = 0;\\n            else if(start < end) ans[i] = Sum[end] - Sum[start];\\n            else                 ans[i] = Sum[end] + (Sum[N-1] - Sum[start]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935724,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        res = [0] * n\\n        if k > 0:\\n            res[0] = sum(code[1 : k + 1])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[(i + k) % n] - code[i]\\n        elif k < 0:\\n            res[0] = sum(code[n + k : n])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[i - 1] - code[(n + k + i - 1) % n]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        res = [0] * n\\n        if k > 0:\\n            res[0] = sum(code[1 : k + 1])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[(i + k) % n] - code[i]\\n        elif k < 0:\\n            res[0] = sum(code[n + k : n])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[i - 1] - code[(n + k + i - 1) % n]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935407,
                "title": "c-easy-solution-100-faster-100-less-space",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> decrypt(vector<int> &code, int k)\\n    {\\n        vector<int> res(code.size(), 0);\\n        int it; // count of k values while doing sum\\n        if (k == 0)\\n            return res;\\n        else\\n        {\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                it = 0;\\n                if (k > 0)\\n                {\\n                    for (int j = i + 1; it < k; j++)\\n                    {\\n                        if (j == code.size())\\n                            j = 0;\\n                        res[i] += code[j];\\n                        it++;\\n                    }\\n                }\\n                else if (k < 0)\\n                {\\n                    for (int j = i - 1; it > k; j--)\\n                    {\\n                        if (j < 0)\\n                            j = code.size() - 1;\\n                        res[i] += code[j];\\n                        it--;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> decrypt(vector<int> &code, int k)\\n    {\\n        vector<int> res(code.size(), 0);\\n        int it; // count of k values while doing sum\\n        if (k == 0)\\n            return res;\\n        else\\n        {\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                it = 0;\\n                if (k > 0)\\n                {\\n                    for (int j = i + 1; it < k; j++)\\n                    {\\n                        if (j == code.size())\\n                            j = 0;\\n                        res[i] += code[j];\\n                        it++;\\n                    }\\n                }\\n                else if (k < 0)\\n                {\\n                    for (int j = i - 1; it > k; j--)\\n                    {\\n                        if (j < 0)\\n                            j = code.size() - 1;\\n                        res[i] += code[j];\\n                        it--;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935382,
                "title": "py3-duplicate-the-array-to-simplify-things",
                "content": "```\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        if k == 0:\\n            return [0] * n\\n        arr = code + code\\n        res = [0] * n\\n        if k > 0:\\n            for i in range(n):\\n                res[i] = sum(arr[i+1:i+k+1])\\n        else:\\n            k = -k\\n            for i in range(n):\\n                res[i] = sum(arr[n+i-k:n+i])\\n        return res",
                "solutionTags": [],
                "code": "```\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        if k == 0:\\n            return [0] * n\\n        arr = code + code\\n        res = [0] * n\\n        if k > 0:\\n            for i in range(n):\\n                res[i] = sum(arr[i+1:i+k+1])\\n        else:\\n            k = -k\\n            for i in range(n):\\n                res[i] = sum(arr[n+i-k:n+i])\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3912887,
                "title": "simple-list-slicing-and-loop-process-that-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# **O**(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# **O**(n)\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k>0:\\n            final=code+code[:k]\\n            for i in range(len(code)):\\n                code[i]=sum(final[i+1:k+1+i])\\n            return code\\n        if k==0:\\n            new=[0]*len(code)\\n            return new\\n        else:\\n            final=code[k:]+code\\n            for i in range(len(code)):\\n                code[i]=sum(final[i:i-k])\\n            return code\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k>0:\\n            final=code+code[:k]\\n            for i in range(len(code)):\\n                code[i]=sum(final[i+1:k+1+i])\\n            return code\\n        if k==0:\\n            new=[0]*len(code)\\n            return new\\n        else:\\n            final=code[k:]+code\\n            for i in range(len(code)):\\n                code[i]=sum(final[i:i-k])\\n            return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674815,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n        if(k==0)\\n            return ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0, sum=0, count=k;\\n            if(k>0)\\n            {\\n                j=i+1;\\n                while(count--){\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)  j=n-1;\\n                else   j=i-1;\\n                while(count++){\\n                    sum+=code[j];\\n                    if(j==0)    j=n-1;\\n                    else     j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n        if(k==0)\\n            return ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0, sum=0, count=k;\\n            if(k>0)\\n            {\\n                j=i+1;\\n                while(count--){\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)  j=n-1;\\n                else   j=i-1;\\n                while(count++){\\n                    sum+=code[j];\\n                    if(j==0)    j=n-1;\\n                    else     j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636938,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res=[]\\n        if k>0:       \\n            first=sum(code[:k])\\n            for i in range(len(code)):\\n                first=first-code[i]+code[(k+i)%(len(code))]\\n                res.append(first)\\n        elif k<0:\\n            first=sum(code[k:])\\n            print(first)\\n            for i in range(len(code)):\\n                res.append(first)\\n                first=first+code[i]-code[(k+i)%(len(code))]\\n        else:\\n            res=[0]*len(code)\\n        return res\\n```\\n\\n***Please Upvote***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res=[]\\n        if k>0:       \\n            first=sum(code[:k])\\n            for i in range(len(code)):\\n                first=first-code[i]+code[(k+i)%(len(code))]\\n                res.append(first)\\n        elif k<0:\\n            first=sum(code[k:])\\n            print(first)\\n            for i in range(len(code)):\\n                res.append(first)\\n                first=first+code[i]-code[(k+i)%(len(code))]\\n        else:\\n            res=[0]*len(code)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436766,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ind = 0\\n        li = [0 for i in range(len(code))]\\n        if k>0:\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(k):\\n                    if ind+1 >= len(code):\\n                        sum += code[(ind+1)%len(code)]\\n                    else:\\n                        sum += code[ind+1]\\n                    ind += 1\\n                li[j] = sum\\n        elif k<0:\\n            r = -k\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(r):\\n                    if ind-1 <0:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                    else:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                li[j] = sum\\n        return li\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ind = 0\\n        li = [0 for i in range(len(code))]\\n        if k>0:\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(k):\\n                    if ind+1 >= len(code):\\n                        sum += code[(ind+1)%len(code)]\\n                    else:\\n                        sum += code[ind+1]\\n                    ind += 1\\n                li[j] = sum\\n        elif k<0:\\n            r = -k\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(r):\\n                    if ind-1 <0:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                    else:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                li[j] = sum\\n        return li\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106935,
                "title": "easy-js-solution-in-10-lines",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let decoded = Array(code.length).fill(0)\\n    if (k==0) return decoded\\n\\n    let direction = k < 0 ? 1 : -1\\n\\n    for (let i = 0; i < code.length; i++)\\n        for (j=k; j != 0; j += direction){\\n            let idx = (i + j) % code.length // if our index is too high, lower it\\n            idx < 0 ? idx += code.length : idx // too low? increase it\\n            decoded[i] += code[idx]\\n        }\\n    return decoded\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let decoded = Array(code.length).fill(0)\\n    if (k==0) return decoded\\n\\n    let direction = k < 0 ? 1 : -1\\n\\n    for (let i = 0; i < code.length; i++)\\n        for (j=k; j != 0; j += direction){\\n            let idx = (i + j) % code.length // if our index is too high, lower it\\n            idx < 0 ? idx += code.length : idx // too low? increase it\\n            decoded[i] += code[idx]\\n        }\\n    return decoded\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2957477,
                "title": "runtime-55-ms-beats-100-memory-41-9-mb-beats-97-92",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nvar decrypt = function (code, k) {\\n    if (k === 0) return new Array(code.length).fill(0);\\n    var arr = code.concat(code, code, code);\\n    // console.log(arr)\\n    let res = [];\\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        let x = i + 1;\\n        let y = (code.length - 1) + i;\\n        if (k > 0) {\\n            for (let j = 0; j < k; j++) {\\n                sum += arr[x];\\n                x++;\\n            }\\n            res.push(sum);\\n        } else if (k < 0) {\\n            for (let j = 0; j < -k; j++) {\\n                sum += arr[y];\\n                y--;\\n            }\\n            res.push(sum);\\n        }\\n    }\\n    return res;\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/1fc69f57-672f-4bff-92c0-aa12825dcdb4_1672132892.8528547.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decrypt = function (code, k) {\\n    if (k === 0) return new Array(code.length).fill(0);\\n    var arr = code.concat(code, code, code);\\n    // console.log(arr)\\n    let res = [];\\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        let x = i + 1;\\n        let y = (code.length - 1) + i;\\n        if (k > 0) {\\n            for (let j = 0; j < k; j++) {\\n                sum += arr[x];\\n                x++;\\n            }\\n            res.push(sum);\\n        } else if (k < 0) {\\n            for (let j = 0; j < -k; j++) {\\n                sum += arr[y];\\n                y--;\\n            }\\n            res.push(sum);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2551093,
                "title": "java-brute-force-easy-to-understand",
                "content": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] ans=new int[code.length];\\n       if(k==0){\\n           for(int i=0;i<code.length;i++){\\n               code[i]=0;\\n               \\n           }\\n           return code;\\n       }\\n        else if(k>0){\\n            \\n            for(int i=0;i<code.length;i++){\\n                int sum=0;\\n                int count=0;\\n                int u=i+1;\\n                if(i==code.length-1){\\n                    u=0;\\n                }\\n                for(int j=u;j<code.length;j++){\\n                    \\n                    sum+=code[j];\\n                    count++;\\n                    if(j==code.length-1){\\n                        j=-1;                       \\n                    }\\n                    if(count==k){\\n                        break;\\n                    }\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                int sum=0;\\n                int count=0;\\n                int u=i-1;\\n                if(i==0){\\n                    u=code.length-1;\\n                }\\n                for(int j=u;j>=0;j--){\\n                    sum+=code[j];\\n                    count++;\\n                    if(count==Math.abs(k)){\\n                        break;\\n                    }\\n                    if(j==0){\\n                        j=code.length;\\n                    }\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n        \\n       \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] ans=new int[code.length];\\n       if(k==0){\\n           for(int i=0;i<code.length;i++){\\n               code[i]=0;\\n               \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2431302,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int n = code.size();\\n        \\n        vector<int> res(n);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sum = 0;\\n            \\n            if (k > 0)\\n                for(int j=1; j<=k; j++)\\n                    sum += code[(i + j) % n]; \\n            else if (k < 0)\\n                for(int j=1; j<=-k; j++)\\n                    sum += code[(i - j + n)%n];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int n = code.size();\\n        \\n        vector<int> res(n);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sum = 0;\\n            \\n            if (k > 0)\\n                for(int j=1; j<=k; j++)\\n                    sum += code[(i + j) % n]; \\n            else if (k < 0)\\n                for(int j=1; j<=-k; j++)\\n                    sum += code[(i - j + n)%n];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323353,
                "title": "c-solution-with-12ms-runtime",
                "content": "Stats for this solution:\\nRuntime: 12 ms, faster than 5.85% of C++ online submissions for Defuse the Bomb.\\nMemory Usage: 8.2 MB, less than 73.28% of C++ online submissions for Defuse the Bomb.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);\\n        if(k == 0) return res;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(k > 0) {\\n                for(int j = (i + 1) % n; count < k; j = (j + 1) % n) {\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            } else {\\n                for(int j = i - 1; count < abs(k); j--) {\\n                    if(j == -1) j = n - 1;\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);\\n        if(k == 0) return res;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(k > 0) {\\n                for(int j = (i + 1) % n; count < k; j = (j + 1) % n) {\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            } else {\\n                for(int j = i - 1; count < abs(k); j--) {\\n                    if(j == -1) j = n - 1;\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306730,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        length = len(code) \\n        code = code + code \\n        ans = [] \\n        \\n        if k > 0 :\\n            for i in range(length) :\\n                tmp = code[i+1:i+k+1]\\n                ans.append(sum(tmp))\\n        elif k < 0 : \\n            for i in range(length,len(code)):\\n                tmp = code[k+i:i]\\n                ans.append(sum(tmp))     \\n        else:\\n            return [0] * length \\n            \\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        length = len(code) \\n        code = code + code \\n        ans = [] \\n        \\n        if k > 0 :\\n            for i in range(length) :\\n                tmp = code[i+1:i+k+1]\\n                ans.append(sum(tmp))\\n        elif k < 0 : \\n            for i in range(length,len(code)):\\n                tmp = code[k+i:i]\\n                ans.append(sum(tmp))     \\n        else:\\n            return [0] * length \\n            \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2051862,
                "title": "c-logic-two-loops-o-n2",
                "content": "Hi there , this is the simple logic that came into my mind at first, with O(n2) complexity\\nwould update a new thread if there comes another logic with better one.\\n\\nCODE- \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n= code.size();\\n         vector<int>res(n,0);\\n        if(k==0)\\n            return res;\\n        else if(k>0)\\n        {\\n            for(int ptr=0; ptr<n; ptr++)\\n            { \\n               int j=k;\\n                int i= ptr+1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i>n-1)\\n                       i%=n;\\n                   sum+=code[i];\\n                    i++;\\n               }\\n                res[ptr]=sum;\\n           }\\n        }\\n        else\\n        {\\n           for(int ptr=n-1; ptr>=0; ptr--)\\n           { \\n               int j=abs(k);\\n               int i=ptr-1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i<0)\\n                       i= n-abs(i);\\n                   sum+= code[i];\\n                   i--;\\n               }\\n               res[ptr]=sum;\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThanks for coming this far!  we can do thiss ! happy coding",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n= code.size();\\n         vector<int>res(n,0);\\n        if(k==0)\\n            return res;\\n        else if(k>0)\\n        {\\n            for(int ptr=0; ptr<n; ptr++)\\n            { \\n               int j=k;\\n                int i= ptr+1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i>n-1)\\n                       i%=n;\\n                   sum+=code[i];\\n                    i++;\\n               }\\n                res[ptr]=sum;\\n           }\\n        }\\n        else\\n        {\\n           for(int ptr=n-1; ptr>=0; ptr--)\\n           { \\n               int j=abs(k);\\n               int i=ptr-1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i<0)\\n                       i= n-abs(i);\\n                   sum+= code[i];\\n                   i--;\\n               }\\n               res[ptr]=sum;\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033540,
                "title": "straight-forward-prefix-sum-solution",
                "content": "using a map to keep track of all prefix sum from 0 -> 2 * n - 1, since its a circular array.\\ntime: o(n), space: o(n)\\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint n = code.length;\\n\\tint[] res = new int[n];\\n\\tif (k == 0) {\\n\\t\\treturn res;\\n\\t}\\n\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tint[] temp = new int[n * 2];\\n\\n\\tfor (int i = 0; i < n * 2 ; i++) {\\n\\t\\ttemp[i] = code[i % n];\\n\\t}\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < temp.length; i++) {\\n\\t\\tsum += temp[i];\\n\\t\\tmap.put(i, sum);\\n\\t}\\n\\n\\tint[] res = new int[code.length];\\n\\tif (k > 0) {\\n\\t\\tfor (int i = 0; i < code.length; i++) {\\n\\t\\t\\tres[i] = map.get(i + k) - map.get(i);\\n\\t\\t}\\n\\t} else if (k < 0) {\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = n; i < temp.length; i++) {\\n\\t\\t\\tres[index++] = map.get(i - 1) - map.get(i + k - 1);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint n = code.length;\\n\\tint[] res = new int[n];\\n\\tif (k == 0) {\\n\\t\\treturn res;\\n\\t}\\n\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tint[] temp = new int[n * 2];\\n\\n\\tfor (int i = 0; i < n * 2 ; i++) {\\n\\t\\ttemp[i] = code[i % n];\\n\\t}\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < temp.length; i++) {\\n\\t\\tsum += temp[i];\\n\\t\\tmap.put(i, sum);\\n\\t}\\n\\n\\tint[] res = new int[code.length];\\n\\tif (k > 0) {\\n\\t\\tfor (int i = 0; i < code.length; i++) {\\n\\t\\t\\tres[i] = map.get(i + k) - map.get(i);\\n\\t\\t}\\n\\t} else if (k < 0) {\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = n; i < temp.length; i++) {\\n\\t\\t\\tres[index++] = map.get(i - 1) - map.get(i + k - 1);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1992107,
                "title": "c-solution-t-o-nk-s-1",
                "content": "### C++ Solution:\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int mod_k = abs(k);\\n        \\n        vector<int> decrypted_code(code.size());\\n        \\n        if (k == 0)\\n            return decrypted_code;\\n        else if (k < 0)\\n        {\\n            // circular right\\n            // formula: right = (start - distance + n) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i - j + code.size()) % code.size()]; \\n            }\\n        }\\n        else\\n        {\\n            // circular left\\n            // formula: left = (start + distance) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i + j) % code.size()]; \\n            }\\n        }\\n        \\n        return decrypted_code;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int mod_k = abs(k);\\n        \\n        vector<int> decrypted_code(code.size());\\n        \\n        if (k == 0)\\n            return decrypted_code;\\n        else if (k < 0)\\n        {\\n            // circular right\\n            // formula: right = (start - distance + n) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i - j + code.size()) % code.size()]; \\n            }\\n        }\\n        else\\n        {\\n            // circular left\\n            // formula: left = (start + distance) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i + j) % code.size()]; \\n            }\\n        }\\n        \\n        return decrypted_code;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985487,
                "title": "short-and-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int l = code.size(), s;\\n        vector<int> v(l);\\n        for(int i=0; i<l; ++i){\\n            s = 0;\\n            if(k>0){\\n                for(int j=0; j<k; ++j){\\n                    if(i+1+j <l)\\n                        s += code[i+1+j];\\n                    else \\n                        s += code[(i+1+j) % l];\\n                }\\n            }\\n            else{\\n                for(int j=0; j<fabs(k); ++j){\\n                    if(i-1-j >=0)\\n                        s += code[i-1-j];\\n                    else \\n                        s += code[l-1+i-j];\\n                } \\n            }\\n            v[i] = s;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int l = code.size(), s;\\n        vector<int> v(l);\\n        for(int i=0; i<l; ++i){\\n            s = 0;\\n            if(k>0){\\n                for(int j=0; j<k; ++j){\\n                    if(i+1+j <l)\\n                        s += code[i+1+j];\\n                    else \\n                        s += code[(i+1+j) % l];\\n                }\\n            }\\n            else{\\n                for(int j=0; j<fabs(k); ++j){\\n                    if(i-1-j >=0)\\n                        s += code[i-1-j];\\n                    else \\n                        s += code[l-1+i-j];\\n                } \\n            }\\n            v[i] = s;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967947,
                "title": "simple-javascript-solution-faster-than-70",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\n\\nvar decrypt = (code, k) => {\\n    \\n    let result = [];\\n    \\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        \\n        if (k > 0) {\\n            for (let x = 1; x <= k; x++) {\\n                sum += code[(i+x) % code.length];\\n            }\\n        }\\n        \\n        if (k < 0) {\\n             for (let x = -1; x >= k; x--) {\\n                sum += code[(i + x + code.length) % code.length];\\n            }\\n        }\\n        \\n        result.push(sum);\\n    } \\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\n\\nvar decrypt = (code, k) => {\\n    \\n    let result = [];\\n    \\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        \\n        if (k > 0) {\\n            for (let x = 1; x <= k; x++) {\\n                sum += code[(i+x) % code.length];\\n            }\\n        }\\n        \\n        if (k < 0) {\\n             for (let x = -1; x >= k; x--) {\\n                sum += code[(i + x + code.length) % code.length];\\n            }\\n        }\\n        \\n        result.push(sum);\\n    } \\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862972,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        s=code*2\\n        for i in range(len(code)):\\n            if k==0:\\n                code[i]=0\\n            elif k>0:\\n                code[i]=sum(s[i+1:i+k+1])\\n            elif k<0:\\n                code[i] = sum(s[len(code) + i + k : len(code) + i])\\n        return code\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        s=code*2\\n        for i in range(len(code)):\\n            if k==0:\\n                code[i]=0\\n            elif k>0:\\n                code[i]=sum(s[i+1:i+k+1])\\n            elif k<0:\\n                code[i] = sum(s[len(code) + i + k : len(code) + i])\\n        return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830648,
                "title": "python-solution-using-extra-memory",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        # Handle the case where k is 0\\n        if k == 0:\\n            for i in range(len(code)):\\n                code[i] = 0\\n        \\n        # Handle the case where k > 0\\n        elif k > 0:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[i + 1:i+ k + 1])\\n        \\n        # Handle the case where k < 0\\n        else:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[len(code) + i + k : len(code) + i])\\n            \\n        return code        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        # Handle the case where k is 0\\n        if k == 0:\\n            for i in range(len(code)):\\n                code[i] = 0\\n        \\n        # Handle the case where k > 0\\n        elif k > 0:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[i + 1:i+ k + 1])\\n        \\n        # Handle the case where k < 0\\n        else:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[len(code) + i + k : len(code) + i])\\n            \\n        return code        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818728,
                "title": "python-single-pass-no-reverse-no-if-s",
                "content": "```\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        s = sum(code[i+1] for i in range(abs(k)))\\n        res = [0]*len(code)\\n        for i in range(len(code)):\\n            res[(i+(1-k)*(k<0))%len(code)] = s\\n            s -= code[(i+1)%len(code)]\\n            s += code[(i+1+abs(k))%len(code)]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        s = sum(code[i+1] for i in range(abs(k)))\\n        res = [0]*len(code)\\n        for i in range(len(code)):\\n            res[(i+(1-k)*(k<0))%len(code)] = s\\n            s -= code[(i+1)%len(code)]\\n            s += code[(i+1+abs(k))%len(code)]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1715964,
                "title": "easy-3-liner-python",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0 : return self.decrypt(code[::-1], -k)[::-1]\\n        code = code * 2\\n        return [sum(code[i+1:i+k+1]) for i in range(len(code)//2)]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0 : return self.decrypt(code[::-1], -k)[::-1]\\n        code = code * 2\\n        return [sum(code[i+1:i+k+1]) for i in range(len(code)//2)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640047,
                "title": "c-o-n-time-space-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        \\n        if(k==0)\\n        {\\n            return vector<int>(n);\\n        }\\n        \\n        int sum=0;\\n        int i=0;\\n        \\n        if(k>0)\\n        {\\n            vector<int> next_sum(n);\\n            \\n            for(i=0;i<k;i++)\\n            {\\n                sum+=code[i];\\n            }\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                sum=sum-code[j]+code[i];\\n                next_sum[j]= sum;\\n                i=(i+1) % n;\\n            }\\n            \\n            return next_sum;\\n            \\n        }\\n        \\n         // if k<0\\n        \\n        k=abs(k);\\n        \\n        vector<int> pre_sum(n);\\n        sum=0;\\n        i=n-1;\\n        \\n        for(i=n-1;i>n-1-k;i--)\\n        {\\n            sum+=code[i];\\n        }\\n        \\n        for(int j=n-1;j>=0;j--)\\n        {\\n            sum=sum-code[j]+code[i];\\n            pre_sum[j]=sum;\\n            i=i-1;\\n            if(i<0) { i=n-1; }\\n        }\\n        \\n        return pre_sum;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        \\n        if(k==0)\\n        {\\n            return vector<int>(n);\\n        }\\n        \\n        int sum=0;\\n        int i=0;\\n        \\n        if(k>0)\\n        {\\n            vector<int> next_sum(n);\\n            \\n            for(i=0;i<k;i++)\\n            {\\n                sum+=code[i];\\n            }\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                sum=sum-code[j]+code[i];\\n                next_sum[j]= sum;\\n                i=(i+1) % n;\\n            }\\n            \\n            return next_sum;\\n            \\n        }\\n        \\n         // if k<0\\n        \\n        k=abs(k);\\n        \\n        vector<int> pre_sum(n);\\n        sum=0;\\n        i=n-1;\\n        \\n        for(i=n-1;i>n-1-k;i--)\\n        {\\n            sum+=code[i];\\n        }\\n        \\n        for(int j=n-1;j>=0;j--)\\n        {\\n            sum=sum-code[j]+code[i];\\n            pre_sum[j]=sum;\\n            i=i-1;\\n            if(i<0) { i=n-1; }\\n        }\\n        \\n        return pre_sum;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623992,
                "title": "c-easy-to-understand-brute-force",
                "content": "**Brute force approach\\ntime complexity O(nxk)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int n=code.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=1,sum=0;\\n            int m=i;\\n            if(k<0)\\n            {\\n            m+=n;\\n            int j=-1;\\n            while(j>=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j--;\\n            }\\n            }\\n            else\\n            {\\n            while(j<=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j++;\\n            }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int n=code.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=1,sum=0;\\n            int m=i;\\n            if(k<0)\\n            {\\n            m+=n;\\n            int j=-1;\\n            while(j>=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j--;\\n            }\\n            }\\n            else\\n            {\\n            while(j<=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j++;\\n            }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603868,
                "title": "rust-fast-100",
                "content": "```\\n\\nstruct Solution{}\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if k == 0{\\n             return vec![0;code.len()];\\n        }else if k > 0{\\n            let mut v = vec![&code];\\n            for _ in 0..=(k/code.len() as i32){\\n                v.push(&code);\\n            }\\n            let chain = v.into_iter().flatten().collect::<Vec<&i32>>();\\n            let mut ans = vec![];\\n            for i in 0..code.len(){\\n                let mut x = 0;\\n                let mut count = 0;\\n                for j in (i+1)..chain.len(){\\n                    if count >= k{\\n                        break;\\n                    }\\n                    x += chain[j];\\n                    count +=1;\\n                }\\n                ans.push(x);                \\n            }\\n            ans\\n\\n        }else{\\n            let mut ans = vec![];          \\n            let vec = code.iter().cycle().take(((code.len() as i32 * code.len() as i32) - code.len() as i32) as usize).collect::<Vec<&i32>>();\\n            let v = vec.into_iter().rev().collect::<Vec<&i32>>();\\n            println!(\"{:?}\",v);\\n            let mut i= 0;\\n            while  i < v.len(){\\n                let mut m = 0;\\n                for j in 0..i32::abs(k){\\n                      m += v[i + j as usize];\\n                      print!(\"{} \",v[i+j as usize]);\\n                }\\n                println!();\\n                \\n                ans.push(m);\\n                i += code.len() - 1;       \\n            }\\n            ans\\n        }   \\n    }\\n}\\nfn main(){\\n    println!(\"{:?}\",Solution::decrypt(vec![2,4,9,3],-2));  \\n}\\n#[cfg(test)]\\nmod test{\\n    use crate::*;\\n\\n    #[test]\\n    fn basic(){\\n        assert_eq!(Solution::decrypt(vec![5,7,1,4],3),vec![12,10,16,13]);\\n        assert_eq!(Solution::decrypt(vec![1,2,3,4],0),vec![0,0,0,0]);\\n        assert_eq!(Solution::decrypt(vec![2,4,9,3],-2),vec![12,5,6,13]);\\n        assert_eq!(Solution::decrypt(vec![10,5,7,7,3,2,10,3,6,9,1,6],-4),vec![22,26,22,28,29,22,19,22,18,21,28,19]); \\n    }    \\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\\nstruct Solution{}\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if k == 0{\\n             return vec![0;code.len()];\\n        }else if k > 0{\\n            let mut v = vec![&code];\\n            for _ in 0..=(k/code.len() as i32){\\n                v.push(&code);\\n            }\\n            let chain = v.into_iter().flatten().collect::<Vec<&i32>>();\\n            let mut ans = vec![];\\n            for i in 0..code.len(){\\n                let mut x = 0;\\n                let mut count = 0;\\n                for j in (i+1)..chain.len(){\\n                    if count >= k{\\n                        break;\\n                    }\\n                    x += chain[j];\\n                    count +=1;\\n                }\\n                ans.push(x);                \\n            }\\n            ans\\n\\n        }else{\\n            let mut ans = vec![];          \\n            let vec = code.iter().cycle().take(((code.len() as i32 * code.len() as i32) - code.len() as i32) as usize).collect::<Vec<&i32>>();\\n            let v = vec.into_iter().rev().collect::<Vec<&i32>>();\\n            println!(\"{:?}\",v);\\n            let mut i= 0;\\n            while  i < v.len(){\\n                let mut m = 0;\\n                for j in 0..i32::abs(k){\\n                      m += v[i + j as usize];\\n                      print!(\"{} \",v[i+j as usize]);\\n                }\\n                println!();\\n                \\n                ans.push(m);\\n                i += code.len() - 1;       \\n            }\\n            ans\\n        }   \\n    }\\n}\\nfn main(){\\n    println!(\"{:?}\",Solution::decrypt(vec![2,4,9,3],-2));  \\n}\\n#[cfg(test)]\\nmod test{\\n    use crate::*;\\n\\n    #[test]\\n    fn basic(){\\n        assert_eq!(Solution::decrypt(vec![5,7,1,4],3),vec![12,10,16,13]);\\n        assert_eq!(Solution::decrypt(vec![1,2,3,4],0),vec![0,0,0,0]);\\n        assert_eq!(Solution::decrypt(vec![2,4,9,3],-2),vec![12,5,6,13]);\\n        assert_eq!(Solution::decrypt(vec![10,5,7,7,3,2,10,3,6,9,1,6],-4),vec![22,26,22,28,29,22,19,22,18,21,28,19]); \\n    }    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514918,
                "title": "c-0ms-o-n-k-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i+1); j <=(i+k); j++)\\n                    ans[i] += code[j%n];\\n            }\\n            \\n        }\\n        \\n        else if(k < 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i-1)%n; j >=(i-abs(k))%n; j--)\\n                {\\n                    if(j < 0)\\n                        ans[i] += code[n+j];\\n                    \\n                    else ans[i] += code[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i+1); j <=(i+k); j++)\\n                    ans[i] += code[j%n];\\n            }\\n            \\n        }\\n        \\n        else if(k < 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i-1)%n; j >=(i-abs(k))%n; j--)\\n                {\\n                    if(j < 0)\\n                        ans[i] += code[n+j];\\n                    \\n                    else ans[i] += code[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450462,
                "title": "easy-solution",
                "content": "just go with the flow \\ntwo things \\nto travel in counter clockwise direction:  **(n+j-1)%n**\\nto travel in clockwise direction:  **(n+i)%n**\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& nums, int k) \\n    {\\n    int n=nums.size();\\n    vector<int>ans(n,0);\\n    if(k==0)return ans;\\n    for(int i=0;i<n;i++)\\n    {\\n        int sum=0,j=k>0?(i+1)%n:(n+i-1)%n,count=0;\\n        if(k>0)while(count<k)sum+=nums[j],j=(j+1)%n,count++;\\n        if(k<0)while(count<abs(k))sum+=nums[j],j=(n+j-1)%n,count++;\\n        ans[i]=sum;\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& nums, int k) \\n    {\\n    int n=nums.size();\\n    vector<int>ans(n,0);\\n    if(k==0)return ans;\\n    for(int i=0;i<n;i++)\\n    {\\n        int sum=0,j=k>0?(i+1)%n:(n+i-1)%n,count=0;\\n        if(k>0)while(count<k)sum+=nums[j],j=(j+1)%n,count++;\\n        if(k<0)while(count<abs(k))sum+=nums[j],j=(n+j-1)%n,count++;\\n        ans[i]=sum;\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333655,
                "title": "python-solution",
                "content": "class Solution:\\n    \\n\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0]*len(code)    \\n        temp = code\\n        code = code*2\\n        for i in range(0,len(temp)):\\n            if k > 0:\\n                temp[i] = sum(code[i+1:k+i+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        \\n        return temp",
                "solutionTags": [],
                "code": "class Solution:\\n    \\n\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0]*len(code)    \\n        temp = code\\n        code = code*2\\n        for i in range(0,len(temp)):\\n            if k > 0:\\n                temp[i] = sum(code[i+1:k+i+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        \\n        return temp",
                "codeTag": "Java"
            },
            {
                "id": 1235556,
                "title": "python-two-lines-brute-force",
                "content": "Find the correct range based on the value of k, then sum the next/previous k values for each index using list comprehension.\\n\\n```python\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        n, range_ = len(code), range(1,k+1) if k > 0 else range(k, 0)\\n        return [sum([code[(i+j)%n] for j in range_]) for i in range(n)] if k else [0]*n\\n```",
                "solutionTags": [],
                "code": "```python\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        n, range_ = len(code), range(1,k+1) if k > 0 else range(k, 0)\\n        return [sum([code[(i+j)%n] for j in range_]) for i in range(n)] if k else [0]*n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1218451,
                "title": "100-python-array-concatenation-prefix-sum",
                "content": "```\\nimport math\\nclass Solution:\\n    def routine(self, code, k):\\n        append_times = int(math.ceil(abs(k) / len(code)))\\n        original_length = len(code)\\n        \\n        for i in range(1, append_times + 1):\\n            code += code\\n        \\n        prefixSum = [0]\\n        for num in code:\\n            prefixSum.append(prefixSum[-1] + num)\\n        \\n        if k > 0:\\n            for i in range(original_length):\\n                code[i] = prefixSum[i + k + 1] - prefixSum[i + 1]\\n        else:\\n            for i in range(original_length * append_times, len(code)):\\n                #    [0, 1, 0, 1]\\n                # [0, 0, 1, 1, 2]\\n                code[i] = prefixSum[i] - prefixSum[i + k]\\n        return code[: original_length] if k > 0 else code[-original_length:]\\n    \\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if not k:\\n            return [0] * len(code)\\n        return self.routine(code, k)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def routine(self, code, k):\\n        append_times = int(math.ceil(abs(k) / len(code)))\\n        original_length = len(code)\\n        \\n        for i in range(1, append_times + 1):\\n            code += code\\n        \\n        prefixSum = [0]\\n        for num in code:\\n            prefixSum.append(prefixSum[-1] + num)\\n        \\n        if k > 0:\\n            for i in range(original_length):\\n                code[i] = prefixSum[i + k + 1] - prefixSum[i + 1]\\n        else:\\n            for i in range(original_length * append_times, len(code)):\\n                #    [0, 1, 0, 1]\\n                # [0, 0, 1, 1, 2]\\n                code[i] = prefixSum[i] - prefixSum[i + k]\\n        return code[: original_length] if k > 0 else code[-original_length:]\\n    \\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if not k:\\n            return [0] * len(code)\\n        return self.routine(code, k)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218059,
                "title": "javascript-solution",
                "content": "```\\nvar decrypt = function(code, k) {\\n    const n = code.length;\\n    \\n    if (k === 0) return new Array(n).fill(0);\\n    \\n    const res = new Array(n).fill(0);\\n    \\n    if (k > 0) {\\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            sum += code[(i + k) % n];\\n            sum -= code[i];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    if (k < 0) {\\n        k = -k;\\n        \\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            res[(i + k) % n] = sum;\\n            \\n            sum -= code[i];\\n            sum += code[(i + k) % n];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decrypt = function(code, k) {\\n    const n = code.length;\\n    \\n    if (k === 0) return new Array(n).fill(0);\\n    \\n    const res = new Array(n).fill(0);\\n    \\n    if (k > 0) {\\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            sum += code[(i + k) % n];\\n            sum -= code[i];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    if (k < 0) {\\n        k = -k;\\n        \\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            res[(i + k) % n] = sum;\\n            \\n            sum -= code[i];\\n            sum += code[(i + k) % n];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1207790,
                "title": "python-94",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        lc = len(code)\\n        res = [0]*lc\\n        code += code\\n        if k == 0:\\n            return res\\n\\t\\t# if k < 0 just swap the code around and swap the result back at the end\\n        if k < 0:\\n            code = code[::-1]\\n        for i in range(lc):\\n            res[i] = sum(code[i+1:i+1+abs(k)])\\n        return res[::-1] if k < 0 else res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        lc = len(code)\\n        res = [0]*lc\\n        code += code\\n        if k == 0:\\n            return res\\n\\t\\t# if k < 0 just swap the code around and swap the result back at the end\\n        if k < 0:\\n            code = code[::-1]\\n        for i in range(lc):\\n            res[i] = sum(code[i+1:i+1+abs(k)])\\n        return res[::-1] if k < 0 else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175703,
                "title": "100-efficient-solution-c",
                "content": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int s=0,c=0,t;\\n        ans = code;\\n        code.insert(code.end(),ans.begin(),ans.end());\\n        ans.clear();\\n        if(k > 0){\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(k==code.size()){\\n                    break;\\n                }\\n                for(int j=c;j<=k;j++){\\n                    s=s+code[j];\\n                    c++;\\n                }\\n\\n                ans.push_back(s);\\n                k++;\\n            }\\n            ans.erase(ans.begin()+(code.size()/2),ans.end());\\n        }\\n        else if(k < 0){\\n            t=abs(k);\\n            reverse(code.begin(),code.end());\\n            cout<<code.size();\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(t==code.size()){\\n                    break;\\n                }\\n                for(int j=c;j<=t;j++){\\n                    s=s+code[j];\\n                    c++;\\n                }\\n                ans.push_back(s);\\n                t++;\\n            }\\n            ans.erase(ans.begin()+(code.size()/2),ans.end());\\n            reverse(ans.begin(),ans.end());\\n        }\\n        else if(k==0){\\n             for(int i=1;i<=code.size()/2;i++){\\n                 ans.push_back(0);\\n             }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int s=0,c=0,t;\\n        ans = code;\\n        code.insert(code.end(),ans.begin(),ans.end());\\n        ans.clear();\\n        if(k > 0){\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(k==code.size()){\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1173463,
                "title": "rust-simple-solution",
                "content": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        let l  = code.len();\\n\\n        if k == 0 {\\n            return vec![0; l];\\n        };\\n\\n        let mut res = Vec::with_capacity(l);\\n        let mut start = match k.signum() {\\n            -1 => l as i32 + k,\\n            s => s,\\n        } as usize;\\n        let steps = k.abs() as usize;\\n\\n        for _ in 0..l {\\n            let mut s = 0;\\n            (start..start + steps).for_each(|j| s += code[j % l]);\\n            res.push(s);\\n            start += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        let l  = code.len();\\n\\n        if k == 0 {\\n            return vec![0; l];\\n        };\\n\\n        let mut res = Vec::with_capacity(l);\\n        let mut start = match k.signum() {\\n            -1 => l as i32 + k,\\n            s => s,\\n        } as usize;\\n        let steps = k.abs() as usize;\\n\\n        for _ in 0..l {\\n            let mut s = 0;\\n            (start..start + steps).for_each(|j| s += code[j % l]);\\n            res.push(s);\\n            start += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1172511,
                "title": "using-modulus",
                "content": "```\\nr=[]\\n        n=len(code)\\n        x=0\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(len(code)):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(len(code)):\\n                e=(i%n)\\n                s=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            q=r[len(r)-1]\\n            r=r[:len(r)-1]\\n            r.insert(0,q)\\n            return r\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nr=[]\\n        n=len(code)\\n        x=0\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(len(code)):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(len(code)):\\n                e=(i%n)\\n                s=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            q=r[len(r)-1]\\n            r=r[:len(r)-1]\\n            r.insert(0,q)\\n            return r\\n            \\n            \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114740,
                "title": "c-stupidly-concise",
                "content": "Sliding window. \\n\\n`i` is left, `j` is right, `n` is the sum of the current window. Keep moving `j` to the right, adding in whatever value we hit to our sum. \\n\\nIf the total window size hits the limit, pull up the left hand side of the window and drop the value at that index from our sum. Then set this sum into the correct index - just before the start of the window if `k` is positive, and just after the end of the window if `k` is negative.\\n```\\nvector<int> decrypt(vector<int>& code, int k) {\\n\\tvector<int> v(code.size());\\n\\tfor (int i = 0, j = 0, n = 0; i < code.size() && k; ++j) {\\n\\t\\tn += code[j % code.size()];\\n\\t\\tif (j - i == abs(k)) v[k > 0 ? i - 1 : (j + 1) % code.size()] = n -= code[i++];\\n\\t}\\n\\treturn v;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n\\tvector<int> v(code.size());\\n\\tfor (int i = 0, j = 0, n = 0; i < code.size() && k; ++j) {\\n\\t\\tn += code[j % code.size()];\\n\\t\\tif (j - i == abs(k)) v[k > 0 ? i - 1 : (j + 1) % code.size()] = n -= code[i++];\\n\\t}\\n\\treturn v;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1094993,
                "title": "python-solution-array-prefix-sum",
                "content": "Array Prefix sum approach.\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n_l=[]\\n        res=[]\\n        nn=1\\n        ctr=0\\n        if k<0:\\n            nn=0\\n        n=len(code)\\n        if k==0:\\n            return [0]*len(code)\\n        if not nn:\\n            k=k*-1\\n            code=code[::-1]\\n        for i in code:\\n            ctr+=i\\n            n_l.append(ctr)\\n        for i in range(n):\\n            if (i+k)<n:\\n                res.append(n_l[i+k]-n_l[i])\\n            else:\\n                res.append(n_l[n-1]-n_l[i]+n_l[(i+k)%n])\\n        if nn:\\n            return res\\n        else:\\n            return res[::-1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n_l=[]\\n        res=[]\\n        nn=1\\n        ctr=0\\n        if k<0:\\n            nn=0\\n        n=len(code)\\n        if k==0:\\n            return [0]*len(code)\\n        if not nn:\\n            k=k*-1\\n            code=code[::-1]\\n        for i in code:\\n            ctr+=i\\n            n_l.append(ctr)\\n        for i in range(n):\\n            if (i+k)<n:\\n                res.append(n_l[i+k]-n_l[i])\\n            else:\\n                res.append(n_l[n-1]-n_l[i]+n_l[(i+k)%n])\\n        if nn:\\n            return res\\n        else:\\n            return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080903,
                "title": "c-concise-solution-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ret;\\n        for (int i = 0; i < code.size(); i++) {\\n            int sum = 0;\\n            int direction = k > 0 ? 1 : -1;\\n\\t\\t\\tint j = i + direction;\\n            while (j != i + k + direction) {\\n                sum += code.at((j + code.size()) % code.size());\\n                j = j + direction;\\n            }\\n            ret.push_back(sum);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ret;\\n        for (int i = 0; i < code.size(); i++) {\\n            int sum = 0;\\n            int direction = k > 0 ? 1 : -1;\\n\\t\\t\\tint j = i + direction;\\n            while (j != i + k + direction) {\\n                sum += code.at((j + code.size()) % code.size());\\n                j = j + direction;\\n            }\\n            ret.push_back(sum);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069062,
                "title": "java-100",
                "content": "1. Calculation and its sequence are same for both directions.\\n2. If k is negative, rotate the result and return\\n```\\n    public int[] decrypt(int[] code, int k) {\\n        int[] cycle = new int[code.length];  \\n        if(k == 0) return cycle;\\n        \\n        int sum = 0;\\n        int t = Math.abs(k);\\n        \\n        for(int i = 0; i < t; i ++)\\n            sum += code[i];\\n        \\n        for(int i = 0; i < code.length; i ++){\\n            sum = sum - code[i] + code[(i + t)%code.length];\\n            cycle[i] = sum;\\n        }\\n        \\n        if(k > 0) return cycle;\\n        \\n        int[] res = new int[code.length];\\n        \\n        for(int i = 0; i < code.length; i ++)\\n            res[i] = cycle[(i + code.length - t - 1)%code.length];\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] decrypt(int[] code, int k) {\\n        int[] cycle = new int[code.length];  \\n        if(k == 0) return cycle;\\n        \\n        int sum = 0;\\n        int t = Math.abs(k);\\n        \\n        for(int i = 0; i < t; i ++)\\n            sum += code[i];\\n        \\n        for(int i = 0; i < code.length; i ++){\\n            sum = sum - code[i] + code[(i + t)%code.length];\\n            cycle[i] = sum;\\n        }\\n        \\n        if(k > 0) return cycle;\\n        \\n        int[] res = new int[code.length];\\n        \\n        for(int i = 0; i < code.length; i ++)\\n            res[i] = cycle[(i + code.length - t - 1)%code.length];\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054478,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        x = []\\n        \\n        if k == 0 :\\n            return [0]*len(code)\\n        \\n        elif k > 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [i+1:i+1+k]))\\n                \\n        elif k < 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [len(code)+i+k:len(code)+i]))\\n        \\n        return x\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        x = []\\n        \\n        if k == 0 :\\n            return [0]*len(code)\\n        \\n        elif k > 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [i+1:i+1+k]))\\n                \\n        elif k < 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [len(code)+i+k:len(code)+i]))\\n        \\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051935,
                "title": "0ms-simple-c-solution",
                "content": "\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    \\n    int *ptr=(int*)malloc(sizeof(int)*codeSize);\\n    *returnSize=codeSize;\\n    \\n    int i,j;\\n    \\n    for(i=0;i<codeSize;i++)\\n    {\\n        int sum=0;\\n        if(k>0)\\n        {\\n            if(i+k<codeSize)\\n            {\\n                for(j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=i+1;j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=0;j<i+k+1-codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            ptr[i]=0;\\n        }\\n        else\\n        {\\n            if(i+k>=0)\\n            {\\n                for(j=i+k;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=0;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=codeSize-(abs(k)-i);j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n    }\\n    \\n    return ptr;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    \\n    int *ptr=(int*)malloc(sizeof(int)*codeSize);\\n    *returnSize=codeSize;\\n    \\n    int i,j;\\n    \\n    for(i=0;i<codeSize;i++)\\n    {\\n        int sum=0;\\n        if(k>0)\\n        {\\n            if(i+k<codeSize)\\n            {\\n                for(j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=i+1;j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=0;j<i+k+1-codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            ptr[i]=0;\\n        }\\n        else\\n        {\\n            if(i+k>=0)\\n            {\\n                for(j=i+k;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=0;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=codeSize-(abs(k)-i);j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n    }\\n    \\n    return ptr;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1036396,
                "title": "simple-c-with-circle-arr-comment-100-faster-85-better-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sum = 0;\\n        int n = code.size();\\n        int cnt = 0;\\n        vector<int> v(n);\\n        \\n        if (k > 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i+1; cnt < k; j++) {\\n                    if (j == n) j = 0; // circle logic - code[n+1] = code[0]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            }\\n        }\\n        \\n        else if (k < 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i-1; cnt < -k; j--) {\\n                    if (j < 0) j = n-1; // circle logic - code[-1] = code[n-1]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            } \\n        }\\n        \\n        else {\\n            for (int i = 0; i < n; ++i) {\\n                v[i] = 0;    \\n            }\\n        }\\n                    \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sum = 0;\\n        int n = code.size();\\n        int cnt = 0;\\n        vector<int> v(n);\\n        \\n        if (k > 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i+1; cnt < k; j++) {\\n                    if (j == n) j = 0; // circle logic - code[n+1] = code[0]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            }\\n        }\\n        \\n        else if (k < 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i-1; cnt < -k; j--) {\\n                    if (j < 0) j = n-1; // circle logic - code[-1] = code[n-1]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            } \\n        }\\n        \\n        else {\\n            for (int i = 0; i < n; ++i) {\\n                v[i] = 0;    \\n            }\\n        }\\n                    \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029160,
                "title": "simple-c-solution-100-faster",
                "content": "int n=code.size();\\n        if(k==0)\\n        {\\n            vector<int>v(n,0);\\n            return v;\\n        }\\n        \\n        vector<int>res;\\n        int q=0,sum=0,i=0,c=0;\\n         if(k>0)\\n        {\\n             i=1;\\n        while(q<n)\\n        {\\n            if(i<n)\\n            {  \\n                 sum=sum+code[i];\\n                c++;\\n                if(c==k)\\n                {\\n                    c=0;\\n                    res.push_back(sum);\\n                    sum=0;\\n                    q++;\\n                    i=q;\\n                }\\n                i++;\\n                     \\n            }\\n            else{\\n                i=0;\\n                \\n            }\\n            \\n        }\\n       \\n        return res;\\n        }\\n        else\\n        {\\n            i=n-1;\\n             while(q<n)\\n           {\\n                    if(i>=0)\\n                    {  \\n                          sum=sum+code[i];\\n                             c++;\\n                          if(c==abs(k))\\n                         {\\n                              c=0;\\n                             res.push_back(sum);\\n                             sum=0;\\n                             q++;\\n                              i=q;\\n                          }\\n                          i--;\\n                     \\n                     }\\n                     else\\n                          i=n-1;\\n        }\\n       \\n        return res;\\n        }\\n",
                "solutionTags": [],
                "code": "int n=code.size();\\n        if(k==0)\\n        {\\n            vector<int>v(n,0);\\n            return v;\\n        }\\n        \\n        vector<int>res;\\n        int q=0,sum=0,i=0,c=0;\\n         if(k>0)\\n        {\\n             i=1;\\n        while(q<n)\\n        {\\n            if(i<n)\\n            {  \\n                 sum=sum+code[i];\\n                c++;\\n                if(c==k)\\n                {\\n                    c=0;\\n                    res.push_back(sum);\\n                    sum=0;\\n                    q++;\\n                    i=q;\\n                }\\n                i++;\\n                     \\n            }\\n            else{\\n                i=0;\\n                \\n            }\\n            \\n        }\\n       \\n        return res;\\n        }\\n        else\\n        {\\n            i=n-1;\\n             while(q<n)\\n           {\\n                    if(i>=0)\\n                    {  \\n                          sum=sum+code[i];\\n                             c++;\\n                          if(c==abs(k))\\n                         {\\n                              c=0;\\n                             res.push_back(sum);\\n                             sum=0;\\n                             q++;\\n                              i=q;\\n                          }\\n                          i--;\\n                     \\n                     }\\n                     else\\n                          i=n-1;\\n        }\\n       \\n        return res;\\n        }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1029000,
                "title": "c-optimized-code-faster-than-90",
                "content": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        int i,j;\\n        vector< int>v(n,0);\\n        if(k==0)\\n        {\\n            return v;\\n        }\\n        int check;\\n        if(k>0)\\n        {\\n            for(i=0;i<n;i++)\\n            {\\n               int sum=0;\\n               check=k;\\n               j=i+1;\\n               while(check--)\\n               {\\n                    j=j%n;\\n                   sum+=code[j];\\n                   j++;\\n                   \\n                   \\n               }\\n                v[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(i=n-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                check=-k;\\n                j=i-1;\\n                if(j==-1)\\n                {\\n                    j=n-1;\\n                }\\n                while(check--)\\n                {\\n                    if(j==-1)\\n                    {\\n                        j=n-1;\\n                    }\\n                    sum+=code[j];\\n                    j--;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n       \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        int i,j;\\n        vector< int>v(n,0);\\n        if(k==0)\\n        {\\n            return v;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1003515,
                "title": "python3-easy-solution-with-list-index-manipulation",
                "content": "\\'\\'\\'\\n\\n\\n\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        retList = []\\n        \\n        if k == 0:\\n            for i in range(len(code)):\\n                retList.append(0)\\n                \\n            return retList\\n        \\n        if k > 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(k):\\n                    if i+1+j < len(code):\\n                        sumup += code[i+1+j]\\n                    else:\\n                        sumup += code[i+1+j-len(code)]\\n                \\n                retList.append(sumup)\\n                \\n            return retList\\n        \\n        if k < 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(abs(k)):\\n                    if i-j-1 < 0:\\n                        sumup += code[len(code)+i-j-1]\\n                    else:\\n                        sumup += code[i-j-1]\\n                        \\n                    \\n                retList.append(sumup)\\n                \\n            return retList",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\n\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        retList = []\\n        \\n        if k == 0:\\n            for i in range(len(code)):\\n                retList.append(0)\\n                \\n            return retList\\n        \\n        if k > 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(k):\\n                    if i+1+j < len(code):\\n                        sumup += code[i+1+j]\\n                    else:\\n                        sumup += code[i+1+j-len(code)]\\n                \\n                retList.append(sumup)\\n                \\n            return retList\\n        \\n        if k < 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(abs(k)):\\n                    if i-j-1 < 0:\\n                        sumup += code[len(code)+i-j-1]\\n                    else:\\n                        sumup += code[i-j-1]\\n                        \\n                    \\n                retList.append(sumup)\\n                \\n            return retList",
                "codeTag": "Python3"
            },
            {
                "id": 992601,
                "title": "java-brute-force-solution-beats-47-08",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int l = code.length;\\n        int output[] = new int[l];\\n        if (k > 0) {\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i + 1; count < k; j++) {\\n                    c += code[j % l];\\n                    count++;\\n                }\\n\\n                output[i] = c;\\n            }\\n        } else if (k < 0) {\\n\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i - 1; count < Math.abs(k); j--) {\\n                    c += code[(j + l) % l];\\n                    count++;\\n                }\\n                output[i] = c;\\n            }\\n\\n        } else {\\n            for (int i = 0; i < l; i++) {\\n                output[i] = 0;\\n            }\\n\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int l = code.length;\\n        int output[] = new int[l];\\n        if (k > 0) {\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i + 1; count < k; j++) {\\n                    c += code[j % l];\\n                    count++;\\n                }\\n\\n                output[i] = c;\\n            }\\n        } else if (k < 0) {\\n\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i - 1; count < Math.abs(k); j--) {\\n                    c += code[(j + l) % l];\\n                    count++;\\n                }\\n                output[i] = c;\\n            }\\n\\n        } else {\\n            for (int i = 0; i < l; i++) {\\n                output[i] = 0;\\n            }\\n\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984880,
                "title": "rust-o-n",
                "content": "Working through those type conversions, a prev sol helped. :) \\n\\n\\n```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if code.len() <= 0 {\\n            return code\\n        }\\n        let mut ret = vec![0; code.len()];\\n        let L  = ret.len();\\n        \\n        match k {\\n            0 => {}\\n            std::i32::MIN..=-1_i32 => {\\n                for i in 0..L {\\n                    for j in k..=-1 {\\n                        ret[i] += code[((i+L) as i32 + j ) as usize % L]\\n                    }\\n                }\\n            }\\n            1_i32..=std::i32::MAX => {\\n                for i in 0..L {\\n                    for j in 1..=k {\\n                        ret[i] += code[(i+j as usize)  % L]\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if code.len() <= 0 {\\n            return code\\n        }\\n        let mut ret = vec![0; code.len()];\\n        let L  = ret.len();\\n        \\n        match k {\\n            0 => {}\\n            std::i32::MIN..=-1_i32 => {\\n                for i in 0..L {\\n                    for j in k..=-1 {\\n                        ret[i] += code[((i+L) as i32 + j ) as usize % L]\\n                    }\\n                }\\n            }\\n            1_i32..=std::i32::MAX => {\\n                for i in 0..L {\\n                    for j in 1..=k {\\n                        ret[i] += code[(i+j as usize)  % L]\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 967756,
                "title": "simple-python-solution",
                "content": "```\\n    n = len(code) \\n    res = n * [0]\\n    code_extended = code * (abs(k)+1)  \\n    if k > 0:\\n        for i in range(n):\\n            res[i] = sum(code_extended[i+1:i+k+1])\\n    elif k < 0:\\n        k = abs(k)\\n        for i in range(k*n, (k+1)*n):\\n            res[i-k*n] = sum(code_extended[i-k:i])\\n    return res",
                "solutionTags": [],
                "code": "```\\n    n = len(code) \\n    res = n * [0]\\n    code_extended = code * (abs(k)+1)  \\n    if k > 0:\\n        for i in range(n):\\n            res[i] = sum(code_extended[i+1:i+k+1])\\n    elif k < 0:\\n        k = abs(k)\\n        for i in range(k*n, (k+1)*n):\\n            res[i-k*n] = sum(code_extended[i-k:i])\\n    return res",
                "codeTag": "Unknown"
            },
            {
                "id": 963902,
                "title": "go-solution-0ms-2-5mb",
                "content": "The idea is to form a temp slice that mimic the feature of circular array. It\\'ll be easy to locate the target elements, but with cost of higher memory usage.\\neg: \\nInput: code = [5,7,1,4] , k = -2\\ntemp would become  [5,7,1,4,**5,7,1,4**,5,7,1,4]\\n\\n```\\nfunc decrypt(code []int, k int) []int {\\n    var temp []int\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    n := len(code)\\n    for i:=n;i<2*n;i++ {\\n        var sum, j int = 0, k\\n        for j != 0  {\\n            sum += temp[i+j]\\n            if j < 0 { j++ }\\n            if j > 0 { j-- }\\n        }\\n        code[i-n] = sum\\n    }\\n    return code\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    var temp []int\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    n := len(code)\\n    for i:=n;i<2*n;i++ {\\n        var sum, j int = 0, k\\n        for j != 0  {\\n            sum += temp[i+j]\\n            if j < 0 { j++ }\\n            if j > 0 { j-- }\\n        }\\n        code[i-n] = sum\\n    }\\n    return code\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 959724,
                "title": "c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n = a.size(), s = 0;\\n        vector<int> prefix(n+1, 0);\\n        vector<int> ans(n, 0);\\n        // create prefix array \\n        for(int i=0; i<n; i++) {\\n            prefix[i+1] = prefix[i] + a[i];\\n        }\\n        \\n        if(k > 0) {\\n            for(int i=0; i<n; i++) {\\n\\t\\t\\t\\t// first part of the window \\n                int r = min(n-1, i+k);\\n                ans[i] += prefix[r+1] - prefix[i+1];\\n\\t\\t\\t\\t// second part of the window \\n                r = k - (r - i);\\n                ans[i] += prefix[r];\\n            }\\n        } else if(k < 0) {\\n            k = -k;\\n            for(int i=0; i<n; i++) {\\n                int l = max(0, i-k);\\n\\t\\t\\t\\t// first part of the window \\n                ans[i] += prefix[i] - prefix[l];\\n                l = k - (i - l);\\n\\t\\t\\t\\t// second part of the window \\n                ans[i] += prefix[n] - prefix[n-l]; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n = a.size(), s = 0;\\n        vector<int> prefix(n+1, 0);\\n        vector<int> ans(n, 0);\\n        // create prefix array \\n        for(int i=0; i<n; i++) {\\n            prefix[i+1] = prefix[i] + a[i];\\n        }\\n        \\n        if(k > 0) {\\n            for(int i=0; i<n; i++) {\\n\\t\\t\\t\\t// first part of the window \\n                int r = min(n-1, i+k);\\n                ans[i] += prefix[r+1] - prefix[i+1];\\n\\t\\t\\t\\t// second part of the window \\n                r = k - (r - i);\\n                ans[i] += prefix[r];\\n            }\\n        } else if(k < 0) {\\n            k = -k;\\n            for(int i=0; i<n; i++) {\\n                int l = max(0, i-k);\\n\\t\\t\\t\\t// first part of the window \\n                ans[i] += prefix[i] - prefix[l];\\n                l = k - (i - l);\\n\\t\\t\\t\\t// second part of the window \\n                ans[i] += prefix[n] - prefix[n-l]; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950114,
                "title": "java-solution-brute-force",
                "content": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] h = new int[code.length];\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    if (i + j == code.length) {\\n                        g = 0;\\n                    } else {\\n                        g++;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        else if (k == 0){\\n            for (int i = 0; i < code.length; i++) {\\n                h[i] = 0;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= (-1) * k; j++) {\\n                    if (i - j < 0 && g == 0){\\n                        g = code.length - 1;\\n                    }\\n                    else {\\n                        g --;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] h = new int[code.length];\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    if (i + j == code.length) {\\n                        g = 0;\\n                    } else {\\n                        g++;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        else if (k == 0){\\n            for (int i = 0; i < code.length; i++) {\\n                h[i] = 0;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= (-1) * k; j++) {\\n                    if (i - j < 0 && g == 0){\\n                        g = code.length - 1;\\n                    }\\n                    else {\\n                        g --;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943955,
                "title": "python-3-without-modulo-94-time",
                "content": "Quite a lengthy code but it does the job.\\n\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = []\\n        for x,i in enumerate(code):\\n            if k > 0:\\n                if (x+k+1) > len(code):  #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[x+1:x+k+1]) + sum(code[:(k-(len(code)-1-x))]))\\n                else:\\n                    res.append(sum(code[x+1:x+k+1]))        \\n            elif k == 0:\\n                return [0]*len(code)\\n            elif k < 0:\\n                if k+x < 0: #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[k+x:]) + sum(code[:x]))\\n                else:\\n                    res.append(sum(code[x+k:x]))\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = []\\n        for x,i in enumerate(code):\\n            if k > 0:\\n                if (x+k+1) > len(code):  #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[x+1:x+k+1]) + sum(code[:(k-(len(code)-1-x))]))\\n                else:\\n                    res.append(sum(code[x+1:x+k+1]))        \\n            elif k == 0:\\n                return [0]*len(code)\\n            elif k < 0:\\n                if k+x < 0: #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[k+x:]) + sum(code[:x]))\\n                else:\\n                    res.append(sum(code[x+k:x]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938270,
                "title": "more-understandable",
                "content": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        #defining range if k positive or negative\\n        #ranger[start, end]\\n        ranger= [1, abs(k+1)] if k>0 else [k, 0]\\n        mylist = []\\n        #run every number\\n        for c in range(len(code)):\\n            sum = 0\\n            #go through the range\\n            for index in range(ranger[0], ranger[1]):\\n                sum += code[(c+index)%len(code)]\\n            mylist.append(sum)\\n        return mylist\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        #defining range if k positive or negative\\n        #ranger[start, end]\\n        ranger= [1, abs(k+1)] if k>0 else [k, 0]\\n        mylist = []\\n        #run every number\\n        for c in range(len(code)):\\n            sum = 0\\n            #go through the range\\n            for index in range(ranger[0], ranger[1]):\\n                sum += code[(c+index)%len(code)]\\n            mylist.append(sum)\\n        return mylist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937967,
                "title": "c-o-n-time-o-1-additional-space",
                "content": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n);\\n        int runsum = 0;\\n        bool rev = 0;\\n        \\n        if (k < 0) {\\n            rev = 1;\\n            k = -k;\\n            reverse(code.begin(), code.end());\\n        }\\n        \\n        for (int i = 0; i <= k; i++)\\n            runsum += code[i];\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\trunsum -= code[i];\\n            ans[i] = runsum;\\n            runsum += code[(i + k + 1) % n];\\n        }\\n        if (rev)\\n\\t\\t\\treverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n);\\n        int runsum = 0;\\n        bool rev = 0;\\n        \\n        if (k < 0) {\\n            rev = 1;\\n            k = -k;\\n            reverse(code.begin(), code.end());\\n        }\\n        \\n        for (int i = 0; i <= k; i++)\\n            runsum += code[i];\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\trunsum -= code[i];\\n            ans[i] = runsum;\\n            runsum += code[(i + k + 1) % n];\\n        }\\n        if (rev)\\n\\t\\t\\treverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936993,
                "title": "java-10-liner-o-n",
                "content": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint currentSum = 0;\\n\\tfor(int i=0;i<Math.abs(k);i++) currentSum += code[k>0?i:code.length-1-i];\\n\\tint[] result = new int[code.length];\\n\\tif(k!=0)\\n\\t\\tfor(int i=0;i<code.length;i++) {\\n\\t\\t\\tint currentIndex = k > 0 ? i: code.length - 1 - i;\\n\\t\\t\\tcurrentSum = currentSum - code[currentIndex] + code[(code.length+currentIndex+k)%code.length];\\n\\t\\t\\tresult[currentIndex] = currentSum;\\n\\t\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint currentSum = 0;\\n\\tfor(int i=0;i<Math.abs(k);i++) currentSum += code[k>0?i:code.length-1-i];\\n\\tint[] result = new int[code.length];\\n\\tif(k!=0)\\n\\t\\tfor(int i=0;i<code.length;i++) {\\n\\t\\t\\tint currentIndex = k > 0 ? i: code.length - 1 - i;\\n\\t\\t\\tcurrentSum = currentSum - code[currentIndex] + code[(code.length+currentIndex+k)%code.length];\\n\\t\\t\\tresult[currentIndex] = currentSum;\\n\\t\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936660,
                "title": "java-0ms-sliding-window",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) return new int[code.length];\\n        \\n        int n = code.length;\\n        int ksum = 0;\\n        int[] res = new int[n];\\n        \\n        // build k size sum.\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) ksum += code[i];\\n            \\n        } else {\\n            for (int i = n - 1; i >= (n + k); i--) ksum += code[i];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n                int next = code[((n + i + k) % n)];\\n                int curr = code [i];\\n                \\n                if (k > 0) {\\n                    res[i] = ksum - curr + next;\\n                    ksum = res[i];\\n                }\\n                else {\\n                    res[i] = ksum;\\n                    ksum = ksum + curr - next; \\n                }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) return new int[code.length];\\n        \\n        int n = code.length;\\n        int ksum = 0;\\n        int[] res = new int[n];\\n        \\n        // build k size sum.\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) ksum += code[i];\\n            \\n        } else {\\n            for (int i = n - 1; i >= (n + k); i--) ksum += code[i];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n                int next = code[((n + i + k) % n)];\\n                int curr = code [i];\\n                \\n                if (k > 0) {\\n                    res[i] = ksum - curr + next;\\n                    ksum = res[i];\\n                }\\n                else {\\n                    res[i] = ksum;\\n                    ksum = ksum + curr - next; \\n                }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936226,
                "title": "defuse-the-bomb",
                "content": "c++  solution \\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n       \\n        \\n         int n=code.size();\\n         vector<int> ans;\\n         for(int i=0;i<n;i++){\\n             \\n             if(k==0){\\n                 ans.push_back(0);\\n             }\\n             else if(k>0){\\n                 int sum=0;\\n                 for(int j=i+1;j<=i+k;j++){\\n                     sum+=code[j%n];\\n                 }\\n                 ans.push_back(sum);\\n             }\\n             else{\\n                 int sum=0;\\n                 for(int j=i+k;j<=i-1;j++){\\n                     sum+=code[(j+n)%n];\\n                 }\\n                 ans.push_back(sum);     \\n             }\\n         }\\n         return ans;   \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n       \\n        \\n         int n=code.size();\\n         vector<int> ans;\\n         for(int i=0;i<n;i++){\\n             \\n             if(k==0){\\n                 ans.push_back(0);\\n             }\\n             else if(k>0){\\n                 int sum=0;\\n                 for(int j=i+1;j<=i+k;j++){\\n                     sum+=code[j%n];\\n                 }\\n                 ans.push_back(sum);\\n             }\\n             else{\\n                 int sum=0;\\n                 for(int j=i+k;j<=i-1;j++){\\n                     sum+=code[(j+n)%n];\\n                 }\\n                 ans.push_back(sum);     \\n             }\\n         }\\n         return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935446,
                "title": "javascript-o-n-k-time-complexity",
                "content": "```\\nvar decrypt = function(code, k) {\\n  const n = code.length;\\n\\n  let res = new Array(n).fill(0)\\n  if (k == 0) {\\n    return res;\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    if (k > 0) {\\n      for (let j = 0; j < k; j++) {\\n        let index = (i+1+j) % n;\\n        res[i] += code[index];\\n      }\\n    } else if (k < 0) {\\n      for (let j = 0; j < -k; j++) {\\n        let index = (i+n-j-1) % n;\\n        res[i] += code[index];\\n      }\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar decrypt = function(code, k) {\\n  const n = code.length;\\n\\n  let res = new Array(n).fill(0)\\n  if (k == 0) {\\n    return res;\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    if (k > 0) {\\n      for (let j = 0; j < k; j++) {\\n        let index = (i+1+j) % n;\\n        res[i] += code[index];\\n      }\\n    } else if (k < 0) {\\n      for (let j = 0; j < -k; j++) {\\n        let index = (i+n-j-1) % n;\\n        res[i] += code[index];\\n      }\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935431,
                "title": "easy-to-understand-o-nk-soln",
                "content": "```\\npublic int[] decrypt(int[] code, int k) {\\n        int n=code.length;\\n        int[] res=new int[n];\\n        if(k>0){\\n            for(int i=0;i<n;i++){\\n                for(int j=i+1;j<=i+k;j++)\\n                    res[i]+=code[j%n];\\n            }\\n        }\\n        else{\\n            for(int i=n-1;i>=0;i--){\\n                for(int j=i-1;j>=i+k;j--){\\n                    int idx=j>=0?j:j+n;\\n                    res[i]+=code[idx];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n        int n=code.length;\\n        int[] res=new int[n];\\n        if(k>0){\\n            for(int i=0;i<n;i++){\\n                for(int j=i+1;j<=i+k;j++)\\n                    res[i]+=code[j%n];\\n            }\\n        }\\n        else{\\n            for(int i=n-1;i>=0;i--){\\n                for(int j=i-1;j>=i+k;j--){\\n                    int idx=j>=0?j:j+n;\\n                    res[i]+=code[idx];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 935393,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res = code;\\n        res.insert(res.end(),code.begin(),code.end());\\n        vector<int> ans;\\n        if(k>0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int i=code.size();i<res.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res = code;\\n        res.insert(res.end(),code.begin(),code.end());\\n        vector<int> ans;\\n        if(k>0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int i=code.size();i<res.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935391,
                "title": "java-simple-o-nk-and-sliding-window-o-n-time-solutions",
                "content": "`O(NK)` time solutions:\\nJust do what is asked in the question\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int sum = 0;\\n            \\n            if (k > 0) {\\n                for (int j = 0; j < k; j++) {\\n                    sum += code[(i + j + 1) % n];\\n                }\\n            } else if (k < 0) {\\n                for (int j = 0; j < -k; j++) {\\n                    sum += code[(i + n - j - 1) % n];\\n                }\\n            }\\n            \\n            answer[i] = sum;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\n`O(N)` time solution\\nCompute sum for the first element. Continue computing sum for others maintaining sliding window\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        if (k == 0) {\\n            return answer;\\n        }\\n        \\n        int sum = 0;\\n        for (int idx = (n + k) % n, move = -k / Math.abs(k); idx != 0; idx = (idx + move) % n) {\\n            sum += code[idx];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            answer[i] = sum;\\n            \\n            if (k < 0) {\\n                sum -= code[(n + k + i) % n];\\n                sum += code[i];\\n            } else {\\n                sum -= code[(i + 1) % n];\\n                sum += code[(i + k + 1) % n];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int sum = 0;\\n            \\n            if (k > 0) {\\n                for (int j = 0; j < k; j++) {\\n                    sum += code[(i + j + 1) % n];\\n                }\\n            } else if (k < 0) {\\n                for (int j = 0; j < -k; j++) {\\n                    sum += code[(i + n - j - 1) % n];\\n                }\\n            }\\n            \\n            answer[i] = sum;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        if (k == 0) {\\n            return answer;\\n        }\\n        \\n        int sum = 0;\\n        for (int idx = (n + k) % n, move = -k / Math.abs(k); idx != 0; idx = (idx + move) % n) {\\n            sum += code[idx];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            answer[i] = sum;\\n            \\n            if (k < 0) {\\n                sum -= code[(n + k + i) % n];\\n                sum += code[i];\\n            } else {\\n                sum -= code[(i + 1) % n];\\n                sum += code[(i + k + 1) % n];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935388,
                "title": "java-0-ms-faster-than-100-00-39-4-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        int sum = 0;\\n        int n = code.length;\\n        int[] res = new int[n];\\n        if (k > 0) {\\n            for (int i = 0; i < n + k; ++i) {\\n                sum += code[i % n];\\n                if (i >= k) {\\n                    sum -= code[i - k];\\n                    res[i - k] = sum;\\n                }\\n            }\\n        } else {\\n            k = -k;\\n            for (int i = 0; i < n + k; ++i) {\\n                if (i >= k) {\\n                    res[i % n] = sum;\\n                    sum -= code[i - k];\\n                }\\n                sum += code[i % n];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        int sum = 0;\\n        int n = code.length;\\n        int[] res = new int[n];\\n        if (k > 0) {\\n            for (int i = 0; i < n + k; ++i) {\\n                sum += code[i % n];\\n                if (i >= k) {\\n                    sum -= code[i - k];\\n                    res[i - k] = sum;\\n                }\\n            }\\n        } else {\\n            k = -k;\\n            for (int i = 0; i < n + k; ++i) {\\n                if (i >= k) {\\n                    res[i % n] = sum;\\n                    sum -= code[i - k];\\n                }\\n                sum += code[i % n];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935385,
                "title": "brute-force-java",
                "content": "```\\n\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0)\\n        {\\n            return new int[code.length];\\n        }\\n        \\n        int[] res = new int[code.length];\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                for(int j = i + 1; j <= i + k; j++)\\n                {\\n                    res[i] += code[j % code.length];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                int l = Math.abs(k);\\n                for(int j = i - 1 + code.length; l > 0; j--)\\n                {\\n                    res[i] += code[j % code.length];\\n                    l--;\\n                }\\n            }\\n        }\\n        \\n        return res;        \\n    }\\n\\t\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0)\\n        {\\n            return new int[code.length];\\n        }\\n        \\n        int[] res = new int[code.length];\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                for(int j = i + 1; j <= i + k; j++)\\n                {\\n                    res[i] += code[j % code.length];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                int l = Math.abs(k);\\n                for(int j = i - 1 + code.length; l > 0; j--)\\n                {\\n                    res[i] += code[j % code.length];\\n                    l--;\\n                }\\n            }\\n        }\\n        \\n        return res;        \\n    }\\n\\t\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 935371,
                "title": "kt-js-py3-cpp-one-step-at-a-time",
                "content": "**Synopsis:**\\n\\nGenerate the answer `ans` one step at a time by accumulating the total sum of the `K` values adjacent to-the-right of each `i`<sup>th</sup> element of the input array `A`.  To simplify the code when `K` is negative, simply reverse `A` and return the reversed answer using positive `K`.\\n\\n---\\n\\n**Bi-Weekly Contest 39 Screenshare:**\\n\\n![image](https://assets.leetcode.com/users/images/2c2f0b1a-650d-43dc-bb60-fbd2340d74c1_1605370887.2933993.png)\\n\\nhttps://www.youtube.com/watch?v=tOBm0jYytpc\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun decrypt(A: IntArray, K: Int): IntArray {\\n        var N = A.size\\n        if (K == 0)\\n            return IntArray(N) { 0 }\\n        if (K < 0)\\n            return decrypt(A.reversed().toIntArray(), -K).reversed().toIntArray()\\n        var ans = mutableListOf<Int>()\\n        var step = { i: Int -> if (i + 1 < N) i + 1 else 0 }\\n        for (i in 0 until N) {\\n            var total = 0\\n            var j = step(i)\\n            for (steps in 0 until K) {\\n                total += A[j]\\n                j = step(j)\\n            }\\n            ans.add(total)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet decrypt = (A, K, ans = []) => {\\n    let N = A.length;\\n    if (!K)\\n        return Array(N).fill(0);\\n    if (K < 0)\\n        return decrypt(A.reverse(), -K).reverse();\\n    let step = i => i + 1 < N ? i + 1 : 0;\\n    for (let i = 0; i < N; ++i) {\\n        let steps = K,\\n            total = 0,\\n            j = step(i);\\n        while (steps--) total += A[j], j = step(j);\\n        ans.push(total);\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def decrypt(self, A: List[int], K: int) -> List[int]:\\n        N = len(A)\\n        if not K:\\n            return [0] * N\\n        if K < 0:\\n            return self.decrypt(A[::-1], -K)[::-1]\\n        step = lambda i: i + 1 if i + 1 < N else 0\\n        ans = []\\n        for i in range(N):\\n            steps = K\\n            total = 0\\n            j = step(i)\\n            for _ in range(steps): total += A[j]; j = step(j)\\n            ans.append(total)\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI decrypt(VI& A, int K, VI ans = {}) {\\n        auto N = A.size();\\n        if (!K)\\n            return VI(N);\\n        if (K < 0) {\\n            reverse(A.begin(), A.end());\\n            ans = decrypt(A, -K);\\n            return { ans.rbegin(), ans.rend() };\\n        }\\n        auto step = [=](auto i) { return i + 1 < N ? i + 1 : 0; };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto steps = K,\\n                 total = 0,\\n                 j = step(i);\\n            while (steps--) total += A[j], j = step(j);\\n            ans.push_back(total);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun decrypt(A: IntArray, K: Int): IntArray {\\n        var N = A.size\\n        if (K == 0)\\n            return IntArray(N) { 0 }\\n        if (K < 0)\\n            return decrypt(A.reversed().toIntArray(), -K).reversed().toIntArray()\\n        var ans = mutableListOf<Int>()\\n        var step = { i: Int -> if (i + 1 < N) i + 1 else 0 }\\n        for (i in 0 until N) {\\n            var total = 0\\n            var j = step(i)\\n            for (steps in 0 until K) {\\n                total += A[j]\\n                j = step(j)\\n            }\\n            ans.add(total)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\n```\\nlet decrypt = (A, K, ans = []) => {\\n    let N = A.length;\\n    if (!K)\\n        return Array(N).fill(0);\\n    if (K < 0)\\n        return decrypt(A.reverse(), -K).reverse();\\n    let step = i => i + 1 < N ? i + 1 : 0;\\n    for (let i = 0; i < N; ++i) {\\n        let steps = K,\\n            total = 0,\\n            j = step(i);\\n        while (steps--) total += A[j], j = step(j);\\n        ans.push(total);\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def decrypt(self, A: List[int], K: int) -> List[int]:\\n        N = len(A)\\n        if not K:\\n            return [0] * N\\n        if K < 0:\\n            return self.decrypt(A[::-1], -K)[::-1]\\n        step = lambda i: i + 1 if i + 1 < N else 0\\n        ans = []\\n        for i in range(N):\\n            steps = K\\n            total = 0\\n            j = step(i)\\n            for _ in range(steps): total += A[j]; j = step(j)\\n            ans.append(total)\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI decrypt(VI& A, int K, VI ans = {}) {\\n        auto N = A.size();\\n        if (!K)\\n            return VI(N);\\n        if (K < 0) {\\n            reverse(A.begin(), A.end());\\n            ans = decrypt(A, -K);\\n            return { ans.rbegin(), ans.rend() };\\n        }\\n        auto step = [=](auto i) { return i + 1 < N ? i + 1 : 0; };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto steps = K,\\n                 total = 0,\\n                 j = step(i);\\n            while (steps--) total += A[j], j = step(j);\\n            ans.push_back(total);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090277,
                "title": "loop-solution-time-complexity-o-n-k",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe inner loop iterates from 1 to the absolute value of k (inclusive). The purpose of this loop is to perform a certain number of shifts on the code list elements.\\n\\nInside this nested loop, there\\'s a conditional statement that checks whether k is greater than 0. If it is, it calculates the new value of newNum by adding the code element at the index (i+j)%n to newNum. If k is less than 0, it calculates newNum by adding the code element at the index (i-j)%n to newNum.\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(code)\\n        output = [0]*n\\n        if k == 0:\\n            return output\\n\\n        for i in range(n):\\n            newNum = 0\\n            for j in range(1,abs(k)+1):\\n                if k > 0:\\n                    newNum = newNum + code[(i+j)%n]\\n                else:\\n                    newNum = newNum + code[(i-j)%n]\\n            output[i] = newNum\\n        return output\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(code)\\n        output = [0]*n\\n        if k == 0:\\n            return output\\n\\n        for i in range(n):\\n            newNum = 0\\n            for j in range(1,abs(k)+1):\\n                if k > 0:\\n                    newNum = newNum + code[(i+j)%n]\\n                else:\\n                    newNum = newNum + code[(i-j)%n]\\n            output[i] = newNum\\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088740,
                "title": "easy-to-understand-java-solution-takes-only-1ms-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int sumg(int code[],int i,int k){//Function to find sum in case of k>0\\n        int s=0;i=i+1;\\n        while(k>0){\\n            if(i>code.length-1){\\n                 i=0;\\n                  s+=code[i];\\n            }\\n            else{\\n                s+=code[i];\\n            }\\n            i+=1;\\n            k--;\\n        }\\n        return s;\\n    }\\n    public int suml(int code[],int i,int k){//Function to find sum in case of k<0\\n       int s=0;i=i-1;\\n       while(k>0){\\n           if(i>=0&&i<code.length){\\n               s+=code[i];\\n           }\\n           else{\\n               i=code.length-1;\\n               s+=code[i];\\n           }\\n           i-=1;\\n           k-=1;\\n       }\\n       return s;\\n    }\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k==0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=0;\\n            }\\n            return ans;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=sumg(code,i,k);\\n            }\\n            return ans;\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=suml(code,i,k*(-1));\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumg(int code[],int i,int k){//Function to find sum in case of k>0\\n        int s=0;i=i+1;\\n        while(k>0){\\n            if(i>code.length-1){\\n                 i=0;\\n                  s+=code[i];\\n            }\\n            else{\\n                s+=code[i];\\n            }\\n            i+=1;\\n            k--;\\n        }\\n        return s;\\n    }\\n    public int suml(int code[],int i,int k){//Function to find sum in case of k<0\\n       int s=0;i=i-1;\\n       while(k>0){\\n           if(i>=0&&i<code.length){\\n               s+=code[i];\\n           }\\n           else{\\n               i=code.length-1;\\n               s+=code[i];\\n           }\\n           i-=1;\\n           k-=1;\\n       }\\n       return s;\\n    }\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k==0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=0;\\n            }\\n            return ans;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=sumg(code,i,k);\\n            }\\n            return ans;\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=suml(code,i,k*(-1));\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078307,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n=a.size(), j=0;\\n        vector<int> v(2*n, 0);\\n        vector<int> ret(n, 0);\\n        for(int i=0; i<n; ++i) v[i]=a[i];\\n        for(int i=n; i<2*n; ++i) v[i]=a[j++];\\n        if(k > 0) {\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=i+1; j<=i+k; ++j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n        } else if(k < 0) {\\n            k=abs(k);\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=n+i-1; j>(n+i-1)-k; --j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n=a.size(), j=0;\\n        vector<int> v(2*n, 0);\\n        vector<int> ret(n, 0);\\n        for(int i=0; i<n; ++i) v[i]=a[i];\\n        for(int i=n; i<2*n; ++i) v[i]=a[j++];\\n        if(k > 0) {\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=i+1; j<=i+k; ++j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n        } else if(k < 0) {\\n            k=abs(k);\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=n+i-1; j>(n+i-1)-k; --j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072718,
                "title": "c-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> v(code.size(), 0);\\n        if (k == 0){\\n            return v;\\n        }else if ( k > 0){\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    v[i] += code[(i+j)%code.size()];\\n                }\\n            }\\n            return v;\\n        }else{\\n            k = 0-k;\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    //cout << \"i \" << i << \" j \" << j << endl;\\n                    if ((i-j) >= 0){\\n                        v[i] += code[(i-j)%code.size()];\\n                    }else{\\n                        v[i] += code[code.size() - abs(i-j)%code.size()];\\n                    }\\n                }\\n            }\\n            return v;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> v(code.size(), 0);\\n        if (k == 0){\\n            return v;\\n        }else if ( k > 0){\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    v[i] += code[(i+j)%code.size()];\\n                }\\n            }\\n            return v;\\n        }else{\\n            k = 0-k;\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    //cout << \"i \" << i << \" j \" << j << endl;\\n                    if ((i-j) >= 0){\\n                        v[i] += code[(i-j)%code.size()];\\n                    }else{\\n                        v[i] += code[code.size() - abs(i-j)%code.size()];\\n                    }\\n                }\\n            }\\n            return v;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4064331,
                "title": "easy-cpp-solution-beats-100-in-runtime-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sz = code.size();\\n        vector<int> ans(sz, 0);\\n        if(k == 0) return ans;\\n        int start = k > 0 ? 1 : sz+k, end = k > 0 ? k : sz-1;\\n        for(int i=0; i<sz; i++){\\n            if(i == 0){\\n                for(int j=start; j<=end; j++)\\n                    ans[i] += code[j%sz];\\n            }\\n            else if(k > 0) ans[i] = ans[i-1] - code[i] + code[(i+k)%sz];\\n            else ans[i] = ans[i-1] - code[(i-1+sz+k)%sz] + code[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sz = code.size();\\n        vector<int> ans(sz, 0);\\n        if(k == 0) return ans;\\n        int start = k > 0 ? 1 : sz+k, end = k > 0 ? k : sz-1;\\n        for(int i=0; i<sz; i++){\\n            if(i == 0){\\n                for(int j=start; j<=end; j++)\\n                    ans[i] += code[j%sz];\\n            }\\n            else if(k > 0) ans[i] = ans[i-1] - code[i] + code[(i+k)%sz];\\n            else ans[i] = ans[i-1] - code[(i-1+sz+k)%sz] + code[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060974,
                "title": "2ms-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int result[]=new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                result[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i+1;j<code.length*2;j++)\\n                {\\n                    sum+=code[j%code.length];\\n                    k1++;\\n                    if(k1==k)\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n        }\\n        else if(k<0) {\\n\\n            for(int i=result.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i-1;j>=(-code.length);j--)\\n                {\\n                    if(j>=0)\\n                    {\\n                        sum+=code[j];\\n                    }\\n                    else if (j<0)\\n                    {\\n                        sum+=code[j+code.length];\\n                    }\\n                    k1++;\\n                    if(k1==Math.abs(k))\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int result[]=new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                result[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i+1;j<code.length*2;j++)\\n                {\\n                    sum+=code[j%code.length];\\n                    k1++;\\n                    if(k1==k)\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n        }\\n        else if(k<0) {\\n\\n            for(int i=result.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i-1;j>=(-code.length);j--)\\n                {\\n                    if(j>=0)\\n                    {\\n                        sum+=code[j];\\n                    }\\n                    else if (j<0)\\n                    {\\n                        sum+=code[j+code.length];\\n                    }\\n                    k1++;\\n                    if(k1==Math.abs(k))\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055984,
                "title": "simpler-as-much-for-beginner-beatz-100",
                "content": "## Complexity\\n####  Time complexity: O(n^2) \\n#### Space complexity: O(n) \\n\\n## Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = [0]*len(code)\\n\\n        if k > 0:\\n            for i in range(len(code)):\\n                temp = code[i+1:] + code\\n                res[i] = sum(temp[:k])\\n            return res\\n\\n        if k == 0:\\n            return res\\n\\n        else:\\n            for i in range(len(code)):\\n                temp = code+code[:i]\\n                res[i] = sum(temp[k:])\\n            return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = [0]*len(code)\\n\\n        if k > 0:\\n            for i in range(len(code)):\\n                temp = code[i+1:] + code\\n                res[i] = sum(temp[:k])\\n            return res\\n\\n        if k == 0:\\n            return res\\n\\n        else:\\n            for i in range(len(code)):\\n                temp = code+code[:i]\\n                res[i] = sum(temp[k:])\\n            return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038589,
                "title": "easy-and-understandable-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func decrypt(_ code: [Int], _ k: Int) -> [Int] {\\n        var answer:[Int] = []\\n        let codeExt = code + code + code\\n        let count = code.count\\n\\n        if k == 0 {\\n            answer = Array(repeating: 0, count: count)\\n        } else if k > 0{\\n            for i in 0..<count{\\n                let add = codeExt[count+1+i...count+i+k]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        } else {\\n            for i in 0..<count{\\n                let add = codeExt[count+k+i...count+i-1]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func decrypt(_ code: [Int], _ k: Int) -> [Int] {\\n        var answer:[Int] = []\\n        let codeExt = code + code + code\\n        let count = code.count\\n\\n        if k == 0 {\\n            answer = Array(repeating: 0, count: count)\\n        } else if k > 0{\\n            for i in 0..<count{\\n                let add = codeExt[count+1+i...count+i+k]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        } else {\\n            for i in 0..<count{\\n                let add = codeExt[count+k+i...count+i-1]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034311,
                "title": "beats-100-with-0ms-optimal-solution-with-explanation-tc-o-n-sc-o-n",
                "content": "# Intuition\\nk is basically a window of elements and we see this window moving across as we move ahead to populate our indices in the new array.\\n\\n# Approach\\nWe break down the problem into 3 parts. k==0 is straight forward. Our window slides for K>0 and K<0. the movement of the window is same, its just the starting and ending indices we have to identify for the different tow different cases of k. Once we do that we just create a for loop where we slide our window.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) and I believe it can\\'t be lower than that as we are supposed to return an array and we should always create a new one rather than modifying our input unless asked to.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        int sumArr = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n\\n        // when K=0 return the array as it is.\\n\\n        if(k==0){\\n            return arr;\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k>0){\\n            startIndex = 1;\\n            endIndex = k;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k<0){\\n            startIndex = code.length+k;\\n            endIndex = code.length-1;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // Now we just populate each index in the new array. while also incrementing our start and end index.\\n        for(int i = 0; i<code.length; i++){\\n            arr[i] = sumArr;\\n\\n            // if the pointer reaches the end, it comes back from the starting end and hence = 0.\\n            if(endIndex == code.length-1){\\n                endIndex = 0;\\n            }\\n            else{\\n                endIndex ++;\\n            }\\n            sumArr = sumArr - code[startIndex] + code[endIndex];\\n\\n            if(startIndex == code.length-1){\\n                startIndex = 0;\\n            }\\n            else{\\n                startIndex ++;\\n            }\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        int sumArr = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n\\n        // when K=0 return the array as it is.\\n\\n        if(k==0){\\n            return arr;\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k>0){\\n            startIndex = 1;\\n            endIndex = k;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k<0){\\n            startIndex = code.length+k;\\n            endIndex = code.length-1;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // Now we just populate each index in the new array. while also incrementing our start and end index.\\n        for(int i = 0; i<code.length; i++){\\n            arr[i] = sumArr;\\n\\n            // if the pointer reaches the end, it comes back from the starting end and hence = 0.\\n            if(endIndex == code.length-1){\\n                endIndex = 0;\\n            }\\n            else{\\n                endIndex ++;\\n            }\\n            sumArr = sumArr - code[startIndex] + code[endIndex];\\n\\n            if(startIndex == code.length-1){\\n                startIndex = 0;\\n            }\\n            else{\\n                startIndex ++;\\n            }\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033458,
                "title": "one-line-solution-using-a-cyclic-iterator",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)] if k > 0 else [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)] if k < 0 else [0]*len(code)\\n```\\n> More readable\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k > 0:\\n            return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)]\\n        if k < 0:\\n            return [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)]\\n        return [0]*len(code)\\n```",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)] if k > 0 else [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)] if k < 0 else [0]*len(code)\\n```\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k > 0:\\n            return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)]\\n        if k < 0:\\n            return [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)]\\n        return [0]*len(code)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020155,
                "title": "beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let result = []\\n    let sum \\n  \\n\\n    if( k > 0) {\\n        for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+k;j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n    }\\n    if(k === 0) {\\n        for(let k = 0; k <code.length;k++) {\\n            result.push(0)\\n        }\\n    }\\n\\n    if(k < 0) {\\n          let reverse = code.reverse()\\n         for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+(k*-1);j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n        result.reverse()\\n\\n    }\\n    return result \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let result = []\\n    let sum \\n  \\n\\n    if( k > 0) {\\n        for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+k;j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n    }\\n    if(k === 0) {\\n        for(let k = 0; k <code.length;k++) {\\n            result.push(0)\\n        }\\n    }\\n\\n    if(k < 0) {\\n          let reverse = code.reverse()\\n         for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+(k*-1);j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n        result.reverse()\\n\\n    }\\n    return result \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968965,
                "title": "c-0ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);  // Initialize the result vector\\n        if (k != 0) {\\n            for (int i = 0; i < n; i++) {\\n                int sum = 0;\\n                // Define the step direction\\n                // int step = k > 0 ? 1 : -1;\\n                int step;\\n                if(k>0){\\n                    step = 1;\\n                } else{\\n                    step = -1;\\n                }\\n                for (int j = 1; j <= abs(k); j++) {\\n                    // Calculate the new index with wrap-around\\n                    int index = (i + j * step + n) % n;\\n                    sum += code[index];\\n                }    \\n                res[i] = sum;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);  // Initialize the result vector\\n        if (k != 0) {\\n            for (int i = 0; i < n; i++) {\\n                int sum = 0;\\n                // Define the step direction\\n                // int step = k > 0 ? 1 : -1;\\n                int step;\\n                if(k>0){\\n                    step = 1;\\n                } else{\\n                    step = -1;\\n                }\\n                for (int j = 1; j <= abs(k); j++) {\\n                    // Calculate the new index with wrap-around\\n                    int index = (i + j * step + n) % n;\\n                    sum += code[index];\\n                }    \\n                res[i] = sum;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964778,
                "title": "sliding-window-reverse",
                "content": "# Intuition\\nWe can use sliding window for k > 0, for k < 0 we can reverse input and calculated outout.\\n\\n# Approach\\nFor k > 0, we can start by calculating first value with index 0, and sum from 1 to k.\\nNext we need to update n numbers, on each step we remove i + 1, element from the sum and add, k + i + 1 element to it. Use % of n to ensure data is read from ring buffer.\\nFor case when k < 0 we need to reverse input and output.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        const int n = code.size();\\n\\n        vector<int> result(n, 0);\\n        if (k == 0) {\\n            return result;\\n        }\\n\\n        bool rr = false;\\n        if (k < 0) {\\n            reverse(code.begin(), code.end());\\n            k = -k;\\n            rr = true;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 1;i <= k;i ++) {\\n            sum += code[i];\\n        }\\n\\n        int j = (k + 1) % n;\\n        for (int i = 0;i < code.size();i ++) {\\n            result[i] = sum;\\n            sum -= code[(i + 1) % n];\\n            sum += code[j % n];\\n            j ++;\\n        }\\n\\n        if (rr) {\\n            reverse(result.begin(), result.end());\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        const int n = code.size();\\n\\n        vector<int> result(n, 0);\\n        if (k == 0) {\\n            return result;\\n        }\\n\\n        bool rr = false;\\n        if (k < 0) {\\n            reverse(code.begin(), code.end());\\n            k = -k;\\n            rr = true;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 1;i <= k;i ++) {\\n            sum += code[i];\\n        }\\n\\n        int j = (k + 1) % n;\\n        for (int i = 0;i < code.size();i ++) {\\n            result[i] = sum;\\n            sum -= code[(i + 1) % n];\\n            sum += code[j % n];\\n            j ++;\\n        }\\n\\n        if (rr) {\\n            reverse(result.begin(), result.end());\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948273,
                "title": "cpp-solution",
                "content": "\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        vector<int> decrypt(vector<int> &code, int k)\\n        {\\n            int n = code.size(), sum = 0, t, idx = 0;\\n            vector<int> ans;\\n            if (k == 0)\\n            {\\n                vector<int> ans2(n);\\n                return ans2;\\n            }\\n            else if (k > 0)\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = k;\\n                    idx = i + 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == n)\\n                        {\\n                            idx = 0;\\n                        }\\n                        sum += code[idx++];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            else\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = abs(k);\\n                    idx = i - 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == -1)\\n                        {\\n                            idx = n - 1;\\n                        }\\n                        sum += code[idx--];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> decrypt(vector<int> &code, int k)\\n        {\\n            int n = code.size(), sum = 0, t, idx = 0;\\n            vector<int> ans;\\n            if (k == 0)\\n            {\\n                vector<int> ans2(n);\\n                return ans2;\\n            }\\n            else if (k > 0)\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = k;\\n                    idx = i + 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == n)\\n                        {\\n                            idx = 0;\\n                        }\\n                        sum += code[idx++];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            else\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = abs(k);\\n                    idx = i - 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == -1)\\n                        {\\n                            idx = n - 1;\\n                        }\\n                        sum += code[idx--];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942997,
                "title": "java-straightforward-t-s-o-m-runtime-78-80-1-ms-memory-93-29-41-1-mb",
                "content": "# Intuition & Approach\\nThis `decrypt` method that takes an integer array `code` and an integer `k` as input, and it returns an integer array `decrypt` as output. The purpose of this method is to \"decrypt\" the input array `code` using the given value of `k`. \\n\\n**Let\\'s break down the code step by step:**\\n\\n```\\npublic int[] decrypt(int[] code, int k) {\\n    int M = code.length;\\n    int[] decrypt = new int[M];\\n    \\n    if(k == 0)\\n        return decrypt;\\n````\\nHere, the method starts by defining a few variables:\\n\\n- `M` represents the length of the input array `code`.\\n\\n- An integer array `decrypt` is created with the same length as `code` to store the decrypted values.\\n\\n- The `if` condition checks if `k` is equal to `0`. If `k` is indeed `0`, then the decrypt array is returned as is (in accordance with the instructions), and the method terminates.\\n\\n```\\nfor(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n    int v = 0, adj = (k < 0) ? M + i : i;\\n    \\n    for(int j = 1; j <= e; j++) \\n        v += code[(adj + sgn * j) % M];\\n\\n    decrypt[i] = v;\\n}\\n```\\nIf `k` is not `0`, the method proceeds to this loop. This loop iterates through each index `i` of the `code` array. Here\\'s what happens in each iteration:\\n\\n- A variable `sgn` is set to either `-1` or `1` based on whether `k` is *negative* or *positive*. This is used to control the direction of decryption.\\n\\n- A variable `e` is set to the absolute value of `k`. This determines how many *steps of decryption will be performed*.\\n\\n- An integer variable `v` is initialized to `0`. This variable will accumulate the decrypted value for the current index `i`.\\n\\n- A variable `adj` is set to `M + i` if `k` is negative, or simply `i` if `k` is positive. This `adj` value is used to adjust the index when accessing elements from the `code` array.\\n\\n- An inner loop runs `e` times. In each iteration of the inner loop, it adds the value at the adjusted index `(adj + sgn * j) % M` to the variable `v`.\\n\\n- After the inner loop completes, the decrypted value for the current index `i` is stored in the `decrypt` array.\\n\\nFinally, the decrypted array `decrypt` is returned after the loop has processed all indices of the `code` array.\\n\\nIn summary, `decrypt` method decrypts the input code array by performing a series of circular shifts based on the value of `k`, and the result is stored in the `decrypt` array.\\n\\n\\n# Complexity\\n- Time complexity: $$T(M * e) = O(M)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int M = code.length;\\n        int[] decrypt = new int[M];\\n        \\n        if(k == 0)\\n            return decrypt;\\n        \\n        for(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n            int v = 0, adj = (k < 0) ? M + i : i;\\n            \\n            for(int j = 1; j <= e; j++) \\n                v += code[(adj + sgn * j) % M];\\n\\n            decrypt[i] = v;\\n        }\\n\\n        return decrypt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n    int M = code.length;\\n    int[] decrypt = new int[M];\\n    \\n    if(k == 0)\\n        return decrypt;\\n```\n```\\nfor(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n    int v = 0, adj = (k < 0) ? M + i : i;\\n    \\n    for(int j = 1; j <= e; j++) \\n        v += code[(adj + sgn * j) % M];\\n\\n    decrypt[i] = v;\\n}\\n```\n``` java []\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int M = code.length;\\n        int[] decrypt = new int[M];\\n        \\n        if(k == 0)\\n            return decrypt;\\n        \\n        for(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n            int v = 0, adj = (k < 0) ? M + i : i;\\n            \\n            for(int j = 1; j <= e; j++) \\n                v += code[(adj + sgn * j) % M];\\n\\n            decrypt[i] = v;\\n        }\\n\\n        return decrypt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914589,
                "title": "c-beginner-friendly-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n   O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans(n,0);\\n        if(k>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<=k;j++)\\n                {\\n                    ans[i]=ans[i]+code[(i+j)%n];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=-1;j>=k;j--)\\n                {\\n                    int ind=(i+j)%n;\\n                    if(ind<0)\\n                    {\\n                        ind=ind+n;\\n                    }\\n                    ans[i]=ans[i]+code[ind];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans(n,0);\\n        if(k>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<=k;j++)\\n                {\\n                    ans[i]=ans[i]+code[(i+j)%n];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=-1;j>=k;j--)\\n                {\\n                    int ind=(i+j)%n;\\n                    if(ind<0)\\n                    {\\n                        ind=ind+n;\\n                    }\\n                    ans[i]=ans[i]+code[ind];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885410,
                "title": "runtime-54ms-memory-43-10-mb-easy-for-loop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function (code, k) {\\n    let arr = []\\n    if (k == 0) {\\n        return code.fill(0)\\n    }\\n    for (let i = 0; i < code.length; i++) {\\n        let val = 0\\n        let n = 0\\n        if (k < 0) {\\n            for (let j = i-1; n> k; j--) {\\n                 if (!code[j]) {\\n                    j = code.length-1\\n                } \\n                    val = val + code[j]\\n                    n--\\n            }\\n        }\\n        else {\\n            for (let j = i+1; n<k; j++) {\\n                if (!code[j]) {\\n                    j = 0\\n                } \\n                    val = val + code[j]\\n                    n++\\n            }\\n        }\\n        arr.push(val)\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function (code, k) {\\n    let arr = []\\n    if (k == 0) {\\n        return code.fill(0)\\n    }\\n    for (let i = 0; i < code.length; i++) {\\n        let val = 0\\n        let n = 0\\n        if (k < 0) {\\n            for (let j = i-1; n> k; j--) {\\n                 if (!code[j]) {\\n                    j = code.length-1\\n                } \\n                    val = val + code[j]\\n                    n--\\n            }\\n        }\\n        else {\\n            for (let j = i+1; n<k; j++) {\\n                if (!code[j]) {\\n                    j = 0\\n                } \\n                    val = val + code[j]\\n                    n++\\n            }\\n        }\\n        arr.push(val)\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3874629,
                "title": "simple-c-solution",
                "content": "# Intuition\\nGenerate the array just the way it is described in the problem description.\\n\\n# Approach\\nCreate an array of the same size, as all operations are done simultaneously, which means we should not edit the original array.\\n\\nFor every index in the array, we sum all the values that we need. \\n\\nsteps: the amount of steps we make. We have to make a total of abs(k) steps.\\nindex: The index of the value we add to sum. We have code to wrap it around if it goes beyond the array bounds.\\nsum: Sum of the values.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n\\n        vector<int> ans(n, 0);\\n\\n        for(int i = 0; i < code.size(); ++i) {\\n            int steps = 0;\\n            int index = i;\\n            int sum = 0;\\n            while(steps < abs(k)) {\\n                index += (k > 0) ? 1 : -1;\\n                if(index >= n) {\\n                    index = 0;\\n                } else if(index < 0) {\\n                    index = n - 1;\\n                }\\n\\n                sum += code[index];\\n                ++steps;\\n            }\\n\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n\\n        vector<int> ans(n, 0);\\n\\n        for(int i = 0; i < code.size(); ++i) {\\n            int steps = 0;\\n            int index = i;\\n            int sum = 0;\\n            while(steps < abs(k)) {\\n                index += (k > 0) ? 1 : -1;\\n                if(index >= n) {\\n                    index = 0;\\n                } else if(index < 0) {\\n                    index = n - 1;\\n                }\\n\\n                sum += code[index];\\n                ++steps;\\n            }\\n\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868122,
                "title": "java",
                "content": "\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        //next ele = (i+1)%n;\\n        //prev ele =(i-1+n)%n;\\n        int n = code.length;\\n        if(k==0)\\n        {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        else if(k>0)\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i+1)%n;\\n                for(int j=1; j<=k; j++)\\n                {\\n                    sum += code[start];\\n                    start = (start+1)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        else\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i-1+n)%n;\\n                for(int j=1; j<=Math.abs(k); j++)\\n                {\\n                    sum += code[start];\\n                    start = (start-1+n)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        //next ele = (i+1)%n;\\n        //prev ele =(i-1+n)%n;\\n        int n = code.length;\\n        if(k==0)\\n        {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        else if(k>0)\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i+1)%n;\\n                for(int j=1; j<=k; j++)\\n                {\\n                    sum += code[start];\\n                    start = (start+1)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        else\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i-1+n)%n;\\n                for(int j=1; j<=Math.abs(k); j++)\\n                {\\n                    sum += code[start];\\n                    start = (start-1+n)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861654,
                "title": "by-07chorno-c-o-ms-beats-1oo-the-best-answer-click-now-to-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int L = code.size(), tmp, j;\\n        vector<int> decode(L);\\n\\n        if(k == 0)\\n            return decode;\\n        else if(k > 0)\\n        {\\n            for(int i = 0; i < L; i ++)\\n            {\\n                j = i+1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j == L)\\n                        j = 0;\\n                    decode[i] += code[j++];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            k *= -1;\\n            for(int i = 0; i < L; i++)\\n            {\\n                j = i - 1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j < 0)\\n                        j = L - 1;\\n                    decode[i] += code[j--];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        return decode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int L = code.size(), tmp, j;\\n        vector<int> decode(L);\\n\\n        if(k == 0)\\n            return decode;\\n        else if(k > 0)\\n        {\\n            for(int i = 0; i < L; i ++)\\n            {\\n                j = i+1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j == L)\\n                        j = 0;\\n                    decode[i] += code[j++];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            k *= -1;\\n            for(int i = 0; i < L; i++)\\n            {\\n                j = i - 1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j < 0)\\n                        j = L - 1;\\n                    decode[i] += code[j--];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        return decode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838391,
                "title": "1652-defuse-the-bomb",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int n=code.length;\\n        int res[]=new int[n];\\n\\n        if(k==0)\\n         return res;\\n\\n        else{\\n            int i=0,j=0,sum=0;\\n\\n            while(i<n){\\n                sum+=code[(j+n)%n];\\n\\n                if((j-i+1+n)%n<Math.abs(k))\\n                    j++; \\n\\n                else{\\n\\n                    if(k>0)\\n                     res[(i-1+n)%n]=sum;\\n\\n                    else\\n                     res[(j+1+n)%n]=sum;\\n                    sum-=code[(i+n)%n];\\n                    i++;\\n                    j++; \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int n=code.length;\\n        int res[]=new int[n];\\n\\n        if(k==0)\\n         return res;\\n\\n        else{\\n            int i=0,j=0,sum=0;\\n\\n            while(i<n){\\n                sum+=code[(j+n)%n];\\n\\n                if((j-i+1+n)%n<Math.abs(k))\\n                    j++; \\n\\n                else{\\n\\n                    if(k>0)\\n                     res[(i-1+n)%n]=sum;\\n\\n                    else\\n                     res[(j+1+n)%n]=sum;\\n                    sum-=code[(i+n)%n];\\n                    i++;\\n                    j++; \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817286,
                "title": "my-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> sum(code.size(), 0);\\n        if(k>0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=1; i<=k; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                    \\n                }\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=k; i<=-1; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n\\n\\n    int getnumber(vector<int>& code, int index)\\n    {\\n        int N = code.size();\\n        if(index>=0)\\n        {\\n            return code[index % N];\\n        }\\n        else\\n        {\\n            while(index < 0)\\n            {\\n                index += N;\\n            }\\n            return code[index % N];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> sum(code.size(), 0);\\n        if(k>0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=1; i<=k; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                    \\n                }\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=k; i<=-1; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n\\n\\n    int getnumber(vector<int>& code, int index)\\n    {\\n        int N = code.size();\\n        if(index>=0)\\n        {\\n            return code[index % N];\\n        }\\n        else\\n        {\\n            while(index < 0)\\n            {\\n                index += N;\\n            }\\n            return code[index % N];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814537,
                "title": "using-fixed-size-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n      int n = code.size();\\n      vector<int>ans(n,0);\\n      if( k == 0 )\\n      return ans;\\n      int s = 1, e = k;\\n\\n      if( k<0 )\\n      {\\n          k*= -1;\\n          s = n-k;\\n          e = n-1;\\n      }\\n\\n      int sum = 0;\\n      for( int  i = s; i<=e; i++)\\n      {\\n          sum+= code[i];\\n      } \\n\\n      for( int i = 0; i<n; i++)\\n      {\\n          ans[i] = sum;\\n          sum-= code[(s++)%n];\\n          sum+= code[(++e)%n];\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n      int n = code.size();\\n      vector<int>ans(n,0);\\n      if( k == 0 )\\n      return ans;\\n      int s = 1, e = k;\\n\\n      if( k<0 )\\n      {\\n          k*= -1;\\n          s = n-k;\\n          e = n-1;\\n      }\\n\\n      int sum = 0;\\n      for( int  i = s; i<=e; i++)\\n      {\\n          sum+= code[i];\\n      } \\n\\n      for( int i = 0; i<n; i++)\\n      {\\n          ans[i] = sum;\\n          sum-= code[(s++)%n];\\n          sum+= code[(++e)%n];\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810699,
                "title": "easy-sliding-window-solution-beats-100",
                "content": "\\n# Approach\\nI think this is minor variation of fixed sliding window. \\n1. Here window is fixed however windowstart and windowEnd isn\\'t starting with 0.\\n2. Main idea is how to initialise windowStart i.e. l and windoEnd i.e r. If  k> 0 then l=1 and r=1. Else for negative k -> l,r= code.length + k i.e. if k=-2 and n=4 then l,r = 2\\n3. Like most of sliding window solutions, we will iterate for Math.abs(k) to calculate sum of window. And doing that, we will increment r. We make sure that r is reinitiaze to 0 when it reaches end of array.\\n4. Once we have the window sum, then it is easy sliding window with maintaining boundry condition for both l and r;\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n     int[] arr = new int[code.length];\\n     if(k==0){\\n         return arr;\\n     }\\n    int l = k > 0  ? 1 : code.length + k;\\n    int r=l;\\n    int itr = Math.abs(k);\\n    int sum=0;\\n    for(int i=0; i< itr ; i++){\\n        sum+=code[r];\\n        r++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n    }\\n    int idx =0;\\n    while(idx< code.length){\\n        arr[idx] = sum;\\n        sum = sum + code[r] - code[l];    \\n        idx++;\\n        r++;\\n        l++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n        if(l== code.length){\\n            l=0;\\n        }\\n    }\\n     return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n     int[] arr = new int[code.length];\\n     if(k==0){\\n         return arr;\\n     }\\n    int l = k > 0  ? 1 : code.length + k;\\n    int r=l;\\n    int itr = Math.abs(k);\\n    int sum=0;\\n    for(int i=0; i< itr ; i++){\\n        sum+=code[r];\\n        r++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n    }\\n    int idx =0;\\n    while(idx< code.length){\\n        arr[idx] = sum;\\n        sum = sum + code[r] - code[l];    \\n        idx++;\\n        r++;\\n        l++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n        if(l== code.length){\\n            l=0;\\n        }\\n    }\\n     return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809538,
                "title": "defuse-the-bomb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                arr[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            // int p=0;\\n            for(int i=code.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    if(j<0)\\n                    {\\n                        int l=j+code.length;\\n                        sum=sum+code[l%code.length];\\n                    }\\n                    else\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                arr[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            // int p=0;\\n            for(int i=code.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    if(j<0)\\n                    {\\n                        int l=j+code.length;\\n                        sum=sum+code[l%code.length];\\n                    }\\n                    else\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797556,
                "title": "c-sliding-window-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nto work on the circular array .We just need to think of modulo everytime we want to acess the next\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans1(n,0);\\n        vector<int>ans;\\n        int sum=0;\\n        if(k==0){\\n            return ans1;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n\\n            }\\n            return ans;\\n        }\\n        else{\\n            k=-1*k;\\n            reverse(code.begin(),code.end());\\n            //same code as in above \\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n            }\\n            reverse(ans.begin(),ans.end());\\n            return ans;\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans1(n,0);\\n        vector<int>ans;\\n        int sum=0;\\n        if(k==0){\\n            return ans1;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n\\n            }\\n            return ans;\\n        }\\n        else{\\n            k=-1*k;\\n            reverse(code.begin(),code.end());\\n            //same code as in above \\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n            }\\n            reverse(ans.begin(),ans.end());\\n            return ans;\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781729,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def decrypt(code: Array[Int], k: Int): Array[Int] = {\\n      val n = code.length\\n      val res = Array.ofDim[Int](n)\\n      if (k == 0) res\\n      else if (k > 0) {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to k) sum += code((i + j) % n)\\n          res(i) = sum\\n        }\\n        res\\n      } else {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to -k) sum += code((i - j + n) % n)\\n          res(i) = sum\\n        }\\n        res\\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def decrypt(code: Array[Int], k: Int): Array[Int] = {\\n      val n = code.length\\n      val res = Array.ofDim[Int](n)\\n      if (k == 0) res\\n      else if (k > 0) {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to k) sum += code((i + j) % n)\\n          res(i) = sum\\n        }\\n        res\\n      } else {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to -k) sum += code((i - j + n) % n)\\n          res(i) = sum\\n        }\\n        res\\n      }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3763431,
                "title": "easiest-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>&c , int k){\\n        int n=c.size();\\n        vector<int>v(n,0);\\n        if(k==0){\\n            return v;\\n        }\\n        else if(k>0){\\n            for(int i=0; i<n; i++){\\n                int p = k;\\n                int d = i+1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = d%n;\\n                    sum+=c[idx];\\n                    d++;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                int p = -k;\\n                int d = i-1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = (d+n)%n;\\n                    sum+=c[idx];\\n                    d--; \\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>&c , int k){\\n        int n=c.size();\\n        vector<int>v(n,0);\\n        if(k==0){\\n            return v;\\n        }\\n        else if(k>0){\\n            for(int i=0; i<n; i++){\\n                int p = k;\\n                int d = i+1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = d%n;\\n                    sum+=c[idx];\\n                    d++;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                int p = -k;\\n                int d = i-1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = (d+n)%n;\\n                    sum+=c[idx];\\n                    d--; \\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732757,
                "title": "solution-1652-defuse-the-bomb",
                "content": "# Intuition\\nThe code aims to decrypt an array of integers using a given key. It iterates through each element in the input array and calls the helperSum function to calculate the decrypted value. The helperSum function calculates the sum of elements based on the given key and the starting index.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] ans = new int[len];\\n\\n        for (int i = 0; i < len; i++) {\\n            ans[i] = helperSum(code, i, k, len);\\n        }\\n\\n        return ans;\\n    }\\n\\n    static int helperSum (int[] arr, int start, int k, int len) {\\n        int ans = 0;\\n        int s = start;\\n\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) {\\n                ans += arr[(s + i + 1) % len];\\n            }\\n        }\\n\\n        if(k < 0) {\\n            k = Math.abs(k);\\n            int index = s - 1;\\n\\n            for (int i = 1; i <= k; i++) {\\n                if (index== -1) {\\n                    index = len - 1;\\n                }\\n                ans += arr[(index)];\\n                index--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] ans = new int[len];\\n\\n        for (int i = 0; i < len; i++) {\\n            ans[i] = helperSum(code, i, k, len);\\n        }\\n\\n        return ans;\\n    }\\n\\n    static int helperSum (int[] arr, int start, int k, int len) {\\n        int ans = 0;\\n        int s = start;\\n\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) {\\n                ans += arr[(s + i + 1) % len];\\n            }\\n        }\\n\\n        if(k < 0) {\\n            k = Math.abs(k);\\n            int index = s - 1;\\n\\n            for (int i = 1; i <= k; i++) {\\n                if (index== -1) {\\n                    index = len - 1;\\n                }\\n                ans += arr[(index)];\\n                index--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732315,
                "title": "easy-ts-solution",
                "content": "# Code\\n```\\nfunction decrypt(code: number[], k: number): number[] {\\n    const codeLen = code.length;\\n    let defuseCode = []\\n\\n    if(k === 0) return Array(codeLen).fill(k)\\n    \\n    let sum = 0;\\n\\n    for(let i = 0; i < codeLen; i++) {\\n        for(let j = 1; j <= Math.abs(k); j++){\\n            const _j = k < 0 ? -j : j;\\n            const index = Math.abs((codeLen+i+_j)%codeLen);\\n            sum += code[index];    \\n        }\\n        defuseCode.push(sum);\\n        sum = 0\\n    }\\n\\n    return defuseCode\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction decrypt(code: number[], k: number): number[] {\\n    const codeLen = code.length;\\n    let defuseCode = []\\n\\n    if(k === 0) return Array(codeLen).fill(k)\\n    \\n    let sum = 0;\\n\\n    for(let i = 0; i < codeLen; i++) {\\n        for(let j = 1; j <= Math.abs(k); j++){\\n            const _j = k < 0 ? -j : j;\\n            const index = Math.abs((codeLen+i+_j)%codeLen);\\n            sum += code[index];    \\n        }\\n        defuseCode.push(sum);\\n        sum = 0\\n    }\\n\\n    return defuseCode\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3726835,
                "title": "basic-and-explained-c-solution-easy-to-understand-array-basics-beginner-friendly",
                "content": "# Intuition\\nSure! Let me explain the code in first person and discuss its complexity.\\n\\nIn this code, I see a class named `Solution` with a member function `decrypt`. This function takes a reference to a vector of integers `code` and an integer `k` as input. It aims to decrypt the given code using a specific algorithm.\\n\\n\\n# Approach\\nNow, let\\'s go through the code step by step:\\n\\n1. The code starts with an `if` condition that checks if `k` is equal to 0. If this condition is true, it means there is no encryption to decrypt, so the function creates a new vector `ans` with the same size as `code` and fills it with 0s. This is done to return a vector of zeros as the decryption result.\\n\\n2. If `k` is not equal to 0, the code proceeds to the main decryption logic. It initializes an empty vector `ans` to store the decryption results.\\n\\n3. The code then enters a `for` loop that iterates over the elements of the `code` vector. Inside this loop:\\n   - It initializes `sum` and `count` variables to 0, which will be used to calculate the sum of elements and keep track of the number of elements considered.\\n   - It checks if `k` is greater than 0. If `k` is positive, it means we need to decrypt the code in the forward direction.\\n     - If the current index `i` is the last index of `code`, a nested `for` loop is used to iterate from the first element to the `k`th element of `code`. It calculates the sum of these elements and increments the `count` variable.\\n     - If the current index `i` is not the last index, another nested `for` loop is used to iterate from the next index to `k` elements ahead, wrapping around to the beginning if necessary. Again, it calculates the sum of these elements and increments the `count` variable.\\n   - If `k` is less than or equal to 0, it means we need to decrypt the code in the backward direction. The logic is similar to the forward direction, but it iterates in reverse order and wraps around from the last index to the beginning if necessary.\\n   - Finally, the calculated `sum` is added to the `ans` vector.\\n\\n4. After the loop finishes, the function returns the `ans` vector containing the decrypted code.\\n\\n- # Complexity\\n- Time complexity : The code uses two nested loops, each iterating over the elements of the `code` vector. Therefore, the time complexity is O(n^2), where n is the size of the vector.\\n- - Space complexity : The space complexity is O(n) as it uses additional space to store the decrypted code in the `ans` vector, which has the same size as `code`.\\n\\n![star-wars-bb8.gif](https://assets.leetcode.com/users/images/34d33a9f-faca-4c62-9e31-54d0b6ef0d2b_1688640507.0608313.gif)\\n\\n![upvote-raccoon.gif](https://assets.leetcode.com/users/images/e6ce0476-7e4e-47de-b6ba-05c64c207f7e_1688640515.7785654.gif)\\n\\n#Please do Upvote if you find the solution good\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        if(k == 0)\\n        {\\n            vector<int> ans(code.size(),0);\\n            return ans;\\n        }\\n        vector<int> ans;\\n        int sum,count;\\n        for(int i = 0 ; i<code.size() ; i++)\\n        {\\n            sum = 0;\\n            count = 0 ;\\n            if(k > 0)\\n            {\\n                if(i == code.size()-1)\\n                {\\n                    for(int j = 0 ; j<code.size() , count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i+1 ; j<code.size() ,count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == code.size()-1)\\n                        {\\n                            j = -1;\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n            else\\n            {\\n                if(i == 0)\\n                {\\n                    for(int j = code.size()-1 ; j>0 , count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i-1 ; j>=0 ,count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == 0)\\n                        {\\n                            j = code.size();\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n}; //Please Upvote\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        if(k == 0)\\n        {\\n            vector<int> ans(code.size(),0);\\n            return ans;\\n        }\\n        vector<int> ans;\\n        int sum,count;\\n        for(int i = 0 ; i<code.size() ; i++)\\n        {\\n            sum = 0;\\n            count = 0 ;\\n            if(k > 0)\\n            {\\n                if(i == code.size()-1)\\n                {\\n                    for(int j = 0 ; j<code.size() , count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i+1 ; j<code.size() ,count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == code.size()-1)\\n                        {\\n                            j = -1;\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n            else\\n            {\\n                if(i == 0)\\n                {\\n                    for(int j = code.size()-1 ; j>0 , count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i-1 ; j>=0 ,count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == 0)\\n                        {\\n                            j = code.size();\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n}; //Please Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701654,
                "title": "basic-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i+k-j)>=code.length)\\n                        sum+=code[(i+k-j)-code.length];\\n                    else\\n                        sum+=code[i+k-j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        if(k<0){\\n            k=-k;\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i-k+j)<0)\\n                        sum+=code[code.length+i-k+j];\\n                    else\\n                        sum+=code[i-k+j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i+k-j)>=code.length)\\n                        sum+=code[(i+k-j)-code.length];\\n                    else\\n                        sum+=code[i+k-j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        if(k<0){\\n            k=-k;\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i-k+j)<0)\\n                        sum+=code[code.length+i-k+j];\\n                    else\\n                        sum+=code[i-k+j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692467,
                "title": "day-30",
                "content": "# Complexity\\n- Time complexity:\\n-       O(n * abs(k)), \\n        where n is the length of the code list. This is because for\\n        each element in code, we perform a loop of length abs(k)\\n        to calculate the sum.\\n- Space complexity:\\n-       O(n) \\n        because we create a new list result of size n\\n        to store the decrypted code.\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        result = [0] * n\\n        \\n        if k != 0:\\n            for i in range(n):\\n                if k > 0:\\n                    for j in range(i + 1, i + k + 1):\\n                        result[i] += code[j % n]\\n                else:\\n                    for j in range(i + k, i):\\n                        result[i] += code[(j + n) % n]\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        result = [0] * n\\n        \\n        if k != 0:\\n            for i in range(n):\\n                if k > 0:\\n                    for j in range(i + 1, i + k + 1):\\n                        result[i] += code[j % n]\\n                else:\\n                    for j in range(i + k, i):\\n                        result[i] += code[(j + n) % n]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689987,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int arr[] = new int[code.length];\\n        if(k == 0) {\\n            return arr;\\n        }\\n\\n        if(k > 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        if(k < 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k * -1; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int arr[] = new int[code.length];\\n        if(k == 0) {\\n            return arr;\\n        }\\n\\n        if(k > 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        if(k < 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k * -1; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681291,
                "title": "sliding-window-solution-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> v(n);\\n        if(k>0){\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(n+i-1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else if(k<0){\\n            k=-k;\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(j+1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n;++i){\\n                v[i]=0;\\n            }\\n        }\\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> v(n);\\n        if(k>0){\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(n+i-1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else if(k<0){\\n            k=-k;\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(j+1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n;++i){\\n                v[i]=0;\\n            }\\n        }\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3680405,
                "title": "harshi-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& c, int k) {\\n        vector<int> l;\\n       int v=c.size();\\n        for(int i=0;i<c.size();i++){\\n             int s=0;\\n             int o=k;\\n             if(o<0){\\n             int p=abs(o);\\n             for(int j=o;j<0;j++){\\n                 int q;\\n                 if (i+j<0)\\n                    q=v+(i+j);\\n                 else  \\n                    q=i+j;\\n\\n                 s=s+c[q]; \\n                 o++;\\n             }\\n             }\\n             else{\\n                 for(int j=1;j<=o;j++)\\n             {  int r=(i+j)%(v);\\n                 s=s+c[r];\\n             }\\n             }\\n              l.push_back(s);\\n            }\\n        return l;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& c, int k) {\\n        vector<int> l;\\n       int v=c.size();\\n        for(int i=0;i<c.size();i++){\\n             int s=0;\\n             int o=k;\\n             if(o<0){\\n             int p=abs(o);\\n             for(int j=o;j<0;j++){\\n                 int q;\\n                 if (i+j<0)\\n                    q=v+(i+j);\\n                 else  \\n                    q=i+j;\\n\\n                 s=s+c[q]; \\n                 o++;\\n             }\\n             }\\n             else{\\n                 for(int j=1;j<=o;j++)\\n             {  int r=(i+j)%(v);\\n                 s=s+c[r];\\n             }\\n             }\\n              l.push_back(s);\\n            }\\n        return l;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673326,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                arr[i] = 0;\\n                return arr;\\n            }\\n        }\\n        int sum = 0;\\n        int ops;\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i + 1 <= code.length - 1 ? i + 1 : 0;\\n                int negative = 0;\\n                while (ops > 0) {\\n                    if (index <= code.length - 1) {\\n                        sum += code[index++];\\n                    } else {\\n                        sum += code[negative++];\\n                    }\\n                    ops--;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        } else {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i > 0 ? i - 1 : code.length - 1;\\n                int negative = code.length - 1;\\n                while (ops < 0) {\\n                    if (index >= 0) {\\n                        sum += code[index--];\\n                    } else {\\n                        sum += code[negative--];\\n                    }\\n                    ops++;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        }\\n        return arr;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                arr[i] = 0;\\n                return arr;\\n            }\\n        }\\n        int sum = 0;\\n        int ops;\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i + 1 <= code.length - 1 ? i + 1 : 0;\\n                int negative = 0;\\n                while (ops > 0) {\\n                    if (index <= code.length - 1) {\\n                        sum += code[index++];\\n                    } else {\\n                        sum += code[negative++];\\n                    }\\n                    ops--;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        } else {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i > 0 ? i - 1 : code.length - 1;\\n                int negative = code.length - 1;\\n                while (ops < 0) {\\n                    if (index >= 0) {\\n                        sum += code[index--];\\n                    } else {\\n                        sum += code[negative--];\\n                    }\\n                    ops++;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        }\\n        return arr;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665514,
                "title": "naive-method-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res;\\n        int sum = 0, n = code.size(); \\n        for(int i = 0; i<code.size();i++)\\n        {  \\n            sum =0; \\n             \\n            if(k>0)\\n            { \\n                for(int j = i+1;j<=i+k;j++)\\n                sum += code[j%n];\\n            }\\n            else if(k<0)\\n            {   \\n                for(int j =i-1; j>=i+k;j--)\\n                {\\n                     \\n                   sum += code[(j+n)%n];\\n                }\\n            }\\n            \\n            res.push_back(sum);\\n\\n        }\\n        \\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res;\\n        int sum = 0, n = code.size(); \\n        for(int i = 0; i<code.size();i++)\\n        {  \\n            sum =0; \\n             \\n            if(k>0)\\n            { \\n                for(int j = i+1;j<=i+k;j++)\\n                sum += code[j%n];\\n            }\\n            else if(k<0)\\n            {   \\n                for(int j =i-1; j>=i+k;j--)\\n                {\\n                     \\n                   sum += code[(j+n)%n];\\n                }\\n            }\\n            \\n            res.push_back(sum);\\n\\n        }\\n        \\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653280,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n\\n        if (k==0)\\n            return ans;\\n\\n        for (int i=0 ; i<n ; i++){\\n            int index;\\n            int sum = 0;\\n            if (k>0){\\n                int count = 0;\\n                index = i+1;\\n                while (index < n && count < k){\\n                    sum += code[index++];\\n                    count++;\\n                }\\n                if (count < k){\\n                    index = 0;\\n                    while (count < k){\\n                        sum += code[index++];\\n                        count++;\\n                    }\\n                }\\n            }\\n            else{\\n                int count = 0;\\n                index = i-1;\\n                while (index >= 0 && count < abs(k)){\\n                    sum += code[index--];\\n                    count++;\\n                }\\n                if (count < abs(k)){\\n                    index = n-1;\\n                    while (count < abs(k)){\\n                        sum += code[index--];\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n\\n        if (k==0)\\n            return ans;\\n\\n        for (int i=0 ; i<n ; i++){\\n            int index;\\n            int sum = 0;\\n            if (k>0){\\n                int count = 0;\\n                index = i+1;\\n                while (index < n && count < k){\\n                    sum += code[index++];\\n                    count++;\\n                }\\n                if (count < k){\\n                    index = 0;\\n                    while (count < k){\\n                        sum += code[index++];\\n                        count++;\\n                    }\\n                }\\n            }\\n            else{\\n                int count = 0;\\n                index = i-1;\\n                while (index >= 0 && count < abs(k)){\\n                    sum += code[index--];\\n                    count++;\\n                }\\n                if (count < abs(k)){\\n                    index = n-1;\\n                    while (count < abs(k)){\\n                        sum += code[index--];\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645630,
                "title": "go-solution-bomb-decode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc decrypt(code []int, k int) []int {\\n    var flag bool\\n\\n    var result []int\\n\\n    if k < 0{\\n        for i := 0; i < len(code) / 2; i ++{\\n            code[i], code[len(code) - 1 - i] = code[len(code) - 1 - i], code[i]\\n        }\\n        flag = true\\n        k *= -1\\n    }\\n\\n    for i := 0; i < len(code); i++{\\n        var num int\\n        for j := 0; j < k; j++{\\n            var val int\\n            val = i + j + 1\\n            if val > len(code) - 1{\\n                val = val - len(code)\\n            }\\n            num += code[val]\\n        }\\n        result = append(result, num)\\n    }\\n\\n    if flag == true{\\n        for i := 0; i < len(result) / 2; i ++{\\n            result[i], result[len(result) - 1 - i] = result[len(result) - 1 - i], result[i]\\n        }\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    var flag bool\\n\\n    var result []int\\n\\n    if k < 0{\\n        for i := 0; i < len(code) / 2; i ++{\\n            code[i], code[len(code) - 1 - i] = code[len(code) - 1 - i], code[i]\\n        }\\n        flag = true\\n        k *= -1\\n    }\\n\\n    for i := 0; i < len(code); i++{\\n        var num int\\n        for j := 0; j < k; j++{\\n            var val int\\n            val = i + j + 1\\n            if val > len(code) - 1{\\n                val = val - len(code)\\n            }\\n            num += code[val]\\n        }\\n        result = append(result, num)\\n    }\\n\\n    if flag == true{\\n        for i := 0; i < len(result) / 2; i ++{\\n            result[i], result[len(result) - 1 - i] = result[len(result) - 1 - i], result[i]\\n        }\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3641800,
                "title": "java-easy-beginner-friendly-solution-80-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n    int n = code.length;\\n    int arr[] = new int[n];\\n    int sum=0;\\n   // for(int i=0;i<n;i++){\\n        if(k>0){\\n             for(int i=0;i<n;i++){\\n            for(int j=i+1;j<k+i+1;j++){\\n                if(j<n){\\n            sum+=code[j];\\n                }\\n                else{\\n                    sum+=code[j-n];\\n                }\\n            }\\n            arr[i] = sum;\\n        sum = 0;    \\n        }\\n        }\\n        if(k==0){\\n             for(int i=0;i<n;i++){\\n            arr[i] = 0;\\n        }\\n        }\\n        if(k<0) {\\n             for(int i=0;i<n;i++){\\n            for(int l=i-1;l>i-1+k;l--){\\n                if(l<0){\\n                    sum+=code[l+n];\\n                }\\n                else{\\n                    sum+=code[l];\\n                }\\n            }\\n            arr[i] = sum;\\n            sum=0;\\n        }\\n    }\\n    return arr;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n    int n = code.length;\\n    int arr[] = new int[n];\\n    int sum=0;\\n   // for(int i=0;i<n;i++){\\n        if(k>0){\\n             for(int i=0;i<n;i++){\\n            for(int j=i+1;j<k+i+1;j++){\\n                if(j<n){\\n            sum+=code[j];\\n                }\\n                else{\\n                    sum+=code[j-n];\\n                }\\n            }\\n            arr[i] = sum;\\n        sum = 0;    \\n        }\\n        }\\n        if(k==0){\\n             for(int i=0;i<n;i++){\\n            arr[i] = 0;\\n        }\\n        }\\n        if(k<0) {\\n             for(int i=0;i<n;i++){\\n            for(int l=i-1;l>i-1+k;l--){\\n                if(l<0){\\n                    sum+=code[l+n];\\n                }\\n                else{\\n                    sum+=code[l];\\n                }\\n            }\\n            arr[i] = sum;\\n            sum=0;\\n        }\\n    }\\n    return arr;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629016,
                "title": "defuse-the-bomb-js-intuitive-solution",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    len = code.length\\n    arr = []\\n\\n    for (let i = 0; i < len; i++) {        \\n        arr.push(scan(i))\\n    }\\n\\n    return arr\\n\\n    function scan(i) {        \\n        sum = 0\\n        s = k\\n\\n        if (s == 0) return 0\\n\\n        while (s > 0) {\\n            n = i + s\\n            if (n >= len) n = n - len             \\n            sum += code[n]\\n            s --\\n        }\\n\\n        while (s < 0) {\\n            n = i + s    \\n            sum += code.at(n)\\n            s ++\\n        }\\n\\n        return sum\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    len = code.length\\n    arr = []\\n\\n    for (let i = 0; i < len; i++) {        \\n        arr.push(scan(i))\\n    }\\n\\n    return arr\\n\\n    function scan(i) {        \\n        sum = 0\\n        s = k\\n\\n        if (s == 0) return 0\\n\\n        while (s > 0) {\\n            n = i + s\\n            if (n >= len) n = n - len             \\n            sum += code[n]\\n            s --\\n        }\\n\\n        while (s < 0) {\\n            n = i + s    \\n            sum += code.at(n)\\n            s ++\\n        }\\n\\n        return sum\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616240,
                "title": "c-100-faster-circular-sliding-window-with-explanation",
                "content": "# Intuition\\nThe problem clearly deals with an array and sub-array with a window size of k.\\n# Approach\\n3 cases:\\n 1. k==0 return res(output array) as it is with all 0s\\n 2. k>0 - we form a window of size k with pointers i and j, and move till i!=n-1 to ensure we calc the sum for each element. \\nElement to be updated given by i-1\\n 3. k>0 - we form a window of size k with pointers i and j, and move till i!=n-1 to ensure we calc the sum for each element. Element to be updated given by (j+1)%array.size()\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1) - excluding the output array\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& v, int k) {\\n        \\n        int n(v.size()),i(0),j(0),sum(0);\\n        vector<int> res(n,0);\\n\\n        if(k==0) return res;\\n        else if(k>0)\\n        {\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[n-1]=sum;\\n\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[i-1]=sum;\\n            }\\n        }\\n        else\\n        {\\n            sum=0;\\n            j=0;\\n            i=0;\\n            k=abs(k);\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[j+1]=sum;\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[(j+1)%n]=sum;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& v, int k) {\\n        \\n        int n(v.size()),i(0),j(0),sum(0);\\n        vector<int> res(n,0);\\n\\n        if(k==0) return res;\\n        else if(k>0)\\n        {\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[n-1]=sum;\\n\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[i-1]=sum;\\n            }\\n        }\\n        else\\n        {\\n            sum=0;\\n            j=0;\\n            i=0;\\n            k=abs(k);\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[j+1]=sum;\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[(j+1)%n]=sum;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578348,
                "title": "100-time-beat-memory-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:  O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int sum=0,n=code.size();\\n        bool flag=true;\\n        if(k<0)\\n        {\\n            k=-k;\\n            flag=false;\\n        }\\n        for(int i=1;i<=k;i++)\\n            sum+=code[i];\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(sum);\\n            sum+=code[(i+1+k)%n];\\n            sum-=code[(i+1)%n];\\n        }\\n        int l=v[0];\\n        if(flag==false)\\n        {\\n            for(int i=0;i<n;i++)\\n               code[i]=v[(n-k-1+i)%n];\\n            return code;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int sum=0,n=code.size();\\n        bool flag=true;\\n        if(k<0)\\n        {\\n            k=-k;\\n            flag=false;\\n        }\\n        for(int i=1;i<=k;i++)\\n            sum+=code[i];\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(sum);\\n            sum+=code[(i+1+k)%n];\\n            sum-=code[(i+1)%n];\\n        }\\n        int l=v[0];\\n        if(flag==false)\\n        {\\n            for(int i=0;i<n;i++)\\n               code[i]=v[(n-k-1+i)%n];\\n            return code;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576292,
                "title": "lets-defuse-it-yeahhhhhhhhhhhhhh",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to replace each element in the given code array with the sum of the k elements that come after it (if k > 0) or before it (if k < 0), considering the array wraps around. The intuition is to iterate through the code array and calculate the replacement value based on the specified rules.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution iterates through the code array, calling the ReplaceNum function for each element. In ReplaceNum, the replacement value is calculated by iterating k times in the specified direction (forward or backward), summing up the values encountered. The index is adjusted using the modulo operator for wrapping around the array.\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nint Replacenum(vector<int> &code, int i, int k):\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index];\\n            if(index >= code.size()){\\n                index = 0;\\n            }else{\\n                index++;\\n            }\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        while(k--){\\n            value += code[index];\\n            if(index < 0){\\n                index = code.size()-1;\\n            }else{\\n                index--;\\n            }\\n        }\\n        return value;\\n    }\\n\\nfor(int i=0; i<code.size(); i++){\\n    code[i] = ReplaceNum(code, i, k);\\n}\\n*/\\nclass Solution {\\npublic:\\n\\nint ReplaceNum(vector<int> &code, int i, int k){\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index % code.size()];\\n            index++;\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        if(index < 0 ){\\n            index = code.size()-1;\\n        }\\n        value += code[index];\\n        cout << index << \" \";\\n        int reps = abs(k)-1;\\n        while(reps--){\\n            cout << index << \" \";\\n            index--;\\n            if(index < 0){\\n                index = code.size()-1;\\n            }\\n            value += code[index];\\n        }\\n\\n        return value;\\n    };\\n};\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> Output_arr(code.size(),0);\\n        if(k == 0){\\n            return Output_arr;\\n        }\\n        for(int i=0; i<code.size(); i++){\\n            Output_arr[i] = ReplaceNum(code, i, k);\\n        }   \\n\\n        return Output_arr;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nint Replacenum(vector<int> &code, int i, int k):\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index];\\n            if(index >= code.size()){\\n                index = 0;\\n            }else{\\n                index++;\\n            }\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        while(k--){\\n            value += code[index];\\n            if(index < 0){\\n                index = code.size()-1;\\n            }else{\\n                index--;\\n            }\\n        }\\n        return value;\\n    }\\n\\nfor(int i=0; i<code.size(); i++){\\n    code[i] = ReplaceNum(code, i, k);\\n}\\n*/\\nclass Solution {\\npublic:\\n\\nint ReplaceNum(vector<int> &code, int i, int k){\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index % code.size()];\\n            index++;\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        if(index < 0 ){\\n            index = code.size()-1;\\n        }\\n        value += code[index];\\n        cout << index << \" \";\\n        int reps = abs(k)-1;\\n        while(reps--){\\n            cout << index << \" \";\\n            index--;\\n            if(index < 0){\\n                index = code.size()-1;\\n            }\\n            value += code[index];\\n        }\\n\\n        return value;\\n    };\\n};\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> Output_arr(code.size(),0);\\n        if(k == 0){\\n            return Output_arr;\\n        }\\n        for(int i=0; i<code.size(); i++){\\n            Output_arr[i] = ReplaceNum(code, i, k);\\n        }   \\n\\n        return Output_arr;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3574874,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        l=len(code)\\n        if k >0:\\n            ls = []\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,k):\\n                    dcode += code[(i+j+1)%l]\\n                ls.append(dcode)\\n        elif k==0:\\n            ls=[0]*l\\n        else:\\n            ls=[]\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,abs(k)):\\n                    dcode += code[(i-j-1)%l]\\n                ls.append(dcode)\\n        return ls\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        l=len(code)\\n        if k >0:\\n            ls = []\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,k):\\n                    dcode += code[(i+j+1)%l]\\n                ls.append(dcode)\\n        elif k==0:\\n            ls=[0]*l\\n        else:\\n            ls=[]\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,abs(k)):\\n                    dcode += code[(i-j-1)%l]\\n                ls.append(dcode)\\n        return ls\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570432,
                "title": "java-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    private int FindSum(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k-- > 0)\\n        {\\n            sum += code[idx % n];\\n            idx++;\\n        }\\n        return sum;\\n    }\\n    private int FindSum2(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k++ < 0)\\n        {\\n            sum += code[(idx + n) % n];\\n            idx--;\\n        }\\n        return sum;\\n    }\\n    public int[] decrypt(int[] code, int k) \\n    {\\n        int n = code.length;\\n        int ans[] = new int[n];\\n        if(k == 0) return ans;\\n\\n        if(k > 0)\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum(i + 1, code, k);\\n        }\\n        else\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum2(i - 1, code, k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    private int FindSum(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k-- > 0)\\n        {\\n            sum += code[idx % n];\\n            idx++;\\n        }\\n        return sum;\\n    }\\n    private int FindSum2(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k++ < 0)\\n        {\\n            sum += code[(idx + n) % n];\\n            idx--;\\n        }\\n        return sum;\\n    }\\n    public int[] decrypt(int[] code, int k) \\n    {\\n        int n = code.length;\\n        int ans[] = new int[n];\\n        if(k == 0) return ans;\\n\\n        if(k > 0)\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum(i + 1, code, k);\\n        }\\n        else\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum2(i - 1, code, k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562620,
                "title": "beginner-friendly-solution-to-the-problem-2ms-runtime",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int [] ans = new int[code.length];\\n        int code_length = code.length;\\n        int sum;\\n        int index;\\n        int count;\\n        if(k > 0){\\n            index = 0;\\n            while(index < code_length){\\n                sum = 0;\\n                count = 0;\\n                int i = (index+1)%code_length;\\n                while(count < k){\\n                    sum = sum + code[i];\\n                    i = (i+1)%code_length;\\n                    count++;\\n                }\\n                ans[index] = sum;\\n                index++;\\n            }\\n        }\\n        else if(k < 0){\\n            int [] new_array = reverse_array(code);\\n            ans = decrypt(new_array, k*-1);\\n            ans = reverse_array(ans);\\n        }\\n        else {\\n            return ans;\\n        }\\n        return ans;\\n    }\\n    public int[] reverse_array(int[] array){\\n        int first = 0;\\n        int last = array.length - 1;\\n        while(first <  last){\\n            array[first]  = array[first] + array[last];\\n            array[last] = array[first] - array[last];\\n            array[first] = array[first] - array[last];\\n            first++;\\n            last--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int [] ans = new int[code.length];\\n        int code_length = code.length;\\n        int sum;\\n        int index;\\n        int count;\\n        if(k > 0){\\n            index = 0;\\n            while(index < code_length){\\n                sum = 0;\\n                count = 0;\\n                int i = (index+1)%code_length;\\n                while(count < k){\\n                    sum = sum + code[i];\\n                    i = (i+1)%code_length;\\n                    count++;\\n                }\\n                ans[index] = sum;\\n                index++;\\n            }\\n        }\\n        else if(k < 0){\\n            int [] new_array = reverse_array(code);\\n            ans = decrypt(new_array, k*-1);\\n            ans = reverse_array(ans);\\n        }\\n        else {\\n            return ans;\\n        }\\n        return ans;\\n    }\\n    public int[] reverse_array(int[] array){\\n        int first = 0;\\n        int last = array.length - 1;\\n        while(first <  last){\\n            array[first]  = array[first] + array[last];\\n            array[last] = array[first] - array[last];\\n            array[first] = array[first] - array[last];\\n            first++;\\n            last--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559879,
                "title": "python-beat-93",
                "content": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 0:\\n            return [0]*len(code)\\n        \\n        # idea is that a circular array\\n        # can be represent as array + array\\n        # ie [5,7,1,4]\\n        # repeated [5,7,1,4,5,7,1,4]\\n        # now apply sliding window from the front\\n        # if k > 0 otherwise start from the back\\n        \\n        repeated = code + code\\n        res = []\\n \\n        if k > 0:\\n            start_index = 0;\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index+1:start_index+1+k]))\\n                start_index+=1\\n        \\n        if k < 0:\\n            start_index = len(repeated)-1\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index-abs(k):start_index]))\\n                start_index-=1\\n            res.reverse()\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 0:\\n            return [0]*len(code)\\n        \\n        # idea is that a circular array\\n        # can be represent as array + array\\n        # ie [5,7,1,4]\\n        # repeated [5,7,1,4,5,7,1,4]\\n        # now apply sliding window from the front\\n        # if k > 0 otherwise start from the back\\n        \\n        repeated = code + code\\n        res = []\\n \\n        if k > 0:\\n            start_index = 0;\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index+1:start_index+1+k]))\\n                start_index+=1\\n        \\n        if k < 0:\\n            start_index = len(repeated)-1\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index-abs(k):start_index]))\\n                start_index-=1\\n            res.reverse()\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559649,
                "title": "solution-using-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n         int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n         int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556345,
                "title": "defuse-the-bomb-java-easy",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr=new int[code.length];\\n        if(k==0){return arr;}\\n        if(k>0)\\n        {\\n           for(int i=0;i<code.length;i++)\\n           {\\n                arr[i]=kPositive(code,i+1,k);\\n           }\\n            return arr; \\n        }\\n    \\n        for(int i=0;i<code.length;i++)\\n        {\\n            arr[i]=kNegative(code,i-1,k);\\n        }\\n        return arr;\\n        \\n        \\n    }\\n    public int kPositive(int[] code,int index,int k)\\n    {\\n        int postSum=0;\\n        while(k!=0)\\n        {\\n            postSum+=code[(index)%code.length];\\n            index++;\\n            k--;\\n        }\\n        return postSum;\\n    }\\n    public int kNegative(int[] code,int index,int k)\\n    {\\n        int preSum=0;\\n        while(k!=0)\\n        {  \\n            if(index<0)\\n            {\\n                preSum+=code[code.length+index];\\n            }\\n            else\\n            {\\n               preSum+=code[index]; \\n            }\\n            \\n            index--;\\n            k++;\\n        }\\n        return preSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr=new int[code.length];\\n        if(k==0){return arr;}\\n        if(k>0)\\n        {\\n           for(int i=0;i<code.length;i++)\\n           {\\n                arr[i]=kPositive(code,i+1,k);\\n           }\\n            return arr; \\n        }\\n    \\n        for(int i=0;i<code.length;i++)\\n        {\\n            arr[i]=kNegative(code,i-1,k);\\n        }\\n        return arr;\\n        \\n        \\n    }\\n    public int kPositive(int[] code,int index,int k)\\n    {\\n        int postSum=0;\\n        while(k!=0)\\n        {\\n            postSum+=code[(index)%code.length];\\n            index++;\\n            k--;\\n        }\\n        return postSum;\\n    }\\n    public int kNegative(int[] code,int index,int k)\\n    {\\n        int preSum=0;\\n        while(k!=0)\\n        {  \\n            if(index<0)\\n            {\\n                preSum+=code[code.length+index];\\n            }\\n            else\\n            {\\n               preSum+=code[index]; \\n            }\\n            \\n            index--;\\n            k++;\\n        }\\n        return preSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556131,
                "title": "simple-and-easy-approch",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] arr, int k) {\\n        int op[] = new int[arr.length];\\n        int sum=0;\\n        for(int i=0; i<k; i++){\\n            sum+=arr[i];\\n        }\\n        if(k==0){\\n            return op;\\n        }else if(k>0){\\n            for(int i=0; i<arr.length; i++){\\n                op[i]=sum-arr[i]+arr[(i+k)%arr.length];\\n                sum=op[i];\\n            }\\n        }else{\\n            k=k*-1;\\n            for(int i=0; i<arr.length; i++){\\n                sum=0;\\n                for(int j=1; j<=k; j++){\\n                    sum+=arr[(arr.length-j+i)%arr.length];\\n                }\\n                op[i]=sum;\\n            }\\n        }\\n        \\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] arr, int k) {\\n        int op[] = new int[arr.length];\\n        int sum=0;\\n        for(int i=0; i<k; i++){\\n            sum+=arr[i];\\n        }\\n        if(k==0){\\n            return op;\\n        }else if(k>0){\\n            for(int i=0; i<arr.length; i++){\\n                op[i]=sum-arr[i]+arr[(i+k)%arr.length];\\n                sum=op[i];\\n            }\\n        }else{\\n            k=k*-1;\\n            for(int i=0; i<arr.length; i++){\\n                sum=0;\\n                for(int j=1; j<=k; j++){\\n                    sum+=arr[(arr.length-j+i)%arr.length];\\n                }\\n                op[i]=sum;\\n            }\\n        }\\n        \\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552363,
                "title": "java-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[] = new int[code.length];\\n        int sum = 0;\\n        if(k<0){            \\n            for(int i=code.length-2;i>=code.length-1+k;i--){\\n                sum += code[i];\\n            }\\n            ans[code.length-1] = sum;\\n            for(int i = code.length-2;i>=0;i--){\\n                int index = i+k < 0 ? code.length+(i+k) : i+k;                \\n                ans[i] = ans[i+1]-code[i]+code[index];\\n            }\\n        }else if(k>0){            \\n            for(int i=1;i<=k;i++){\\n                sum += code[i];\\n            }\\n            ans[0] = sum;\\n            for(int i=1;i<code.length;i++){\\n                int index = i+k>=code.length?i+k-code.length : i+k;\\n                ans[i] = ans[i-1]-code[i]+code[index];\\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[] = new int[code.length];\\n        int sum = 0;\\n        if(k<0){            \\n            for(int i=code.length-2;i>=code.length-1+k;i--){\\n                sum += code[i];\\n            }\\n            ans[code.length-1] = sum;\\n            for(int i = code.length-2;i>=0;i--){\\n                int index = i+k < 0 ? code.length+(i+k) : i+k;                \\n                ans[i] = ans[i+1]-code[i]+code[index];\\n            }\\n        }else if(k>0){            \\n            for(int i=1;i<=k;i++){\\n                sum += code[i];\\n            }\\n            ans[0] = sum;\\n            for(int i=1;i<code.length;i++){\\n                int index = i+k>=code.length?i+k-code.length : i+k;\\n                ans[i] = ans[i-1]-code[i]+code[index];\\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1743482,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 2043876,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 1913659,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 1734530,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Deletions to Make String Balanced",
        "question_content": "<p>You are given a string <code>s</code> consisting only of characters <code>&#39;a&#39;</code> and <code>&#39;b&#39;</code>​​​​.</p>\n\n<p>You can delete any number of characters in <code>s</code> to make <code>s</code> <strong>balanced</strong>. <code>s</code> is <strong>balanced</strong> if there is no pair of indices <code>(i,j)</code> such that <code>i &lt; j</code> and <code>s[i] = &#39;b&#39;</code> and <code>s[j]= &#39;a&#39;</code>.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of deletions needed to make </em><code>s</code><em> <strong>balanced</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aababbab&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You can either:\nDelete the characters at 0-indexed positions 2 and 6 (&quot;aa<u>b</u>abb<u>a</u>b&quot; -&gt; &quot;aaabbb&quot;), or\nDelete the characters at 0-indexed positions 3 and 6 (&quot;aab<u>a</u>bb<u>a</u>b&quot; -&gt; &quot;aabbbb&quot;).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bbaaaaabb&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The only solution is to delete the first two characters.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is&nbsp;<code>&#39;a&#39;</code> or <code>&#39;b&#39;</code>​​.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 935701,
                "title": "dp-solution-beats-100-with-explanation",
                "content": "\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n\\t\\t//dp stores number of chars to remove to make s.substring(0, i) valid\\n        int[] dp = new int[l + 1];\\n        int bcount = 0;\\n        for (int i = 0; i < l; i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                //case 1: keep current a. ==> prev chars must be a...a\\n                //so need to remove all \\'b\\' chars before i, which is bcount\\n                \\n                //case 2: remove current a ==> prev chars must be a...ab...b\\n                //so need to remove current a and whatever makes substring before current i valid which is dp[i];\\n                dp[i + 1] = Math.min(dp[i] + 1, bcount);\\n            } else {\\n                //since it is always valid to append \\'b\\' if substring before current i is valid, so just copy whatever makes substring before i valid which is dp[i];\\n                dp[i + 1] = dp[i];\\n                bcount++;\\n            }\\n        }\\n        \\n        return dp[l];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n\\t\\t//dp stores number of chars to remove to make s.substring(0, i) valid\\n        int[] dp = new int[l + 1];\\n        int bcount = 0;\\n        for (int i = 0; i < l; i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                //case 1: keep current a. ==> prev chars must be a...a\\n                //so need to remove all \\'b\\' chars before i, which is bcount\\n                \\n                //case 2: remove current a ==> prev chars must be a...ab...b\\n                //so need to remove current a and whatever makes substring before current i valid which is dp[i];\\n                dp[i + 1] = Math.min(dp[i] + 1, bcount);\\n            } else {\\n                //since it is always valid to append \\'b\\' if substring before current i is valid, so just copy whatever makes substring before i valid which is dp[i];\\n                dp[i + 1] = dp[i];\\n                bcount++;\\n            }\\n        }\\n        \\n        return dp[l];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997750,
                "title": "6-different-approaches-from-basic-to-the-most-optimal-c",
                "content": "Approach 1: Three passes with space O(n)\\nIn the first pass, we compute vector \"b\" which stores the count of character \\'b\\'. \\nIn the second pass, we compute vector \"a\" which stores the count of character \\'a\\'.\\nIn the third pass, we iterate through the string s. \\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        vector<int> b(n,0);\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            b[i]=c;\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        for(int i=0;i<n;i++) ans=min(ans,a[i]+b[i]);\\n        return ans;\\n        \\n    }\\n\\nApproach2: Two passes with space O(n)\\nWe compute vector a, and instead of computing vector b, we do the processing while iterating through the string itself.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        int c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(a[i]+c,ans);\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        return ans;\\n    }\\n\\nApproach 3: Two passes with space O(1).\\nInstead of using vector a and b, we use two variables count_a and count_b.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        //get the count of a\\'s in the first pass\\n        int count_a=0;\\n        for(int i=0;i<n;i++) if (s[i]==\\'a\\') count_a++;\\n        int count_b=0;\\n        int ans=n;\\n        //second pass\\n        //as you iterate through the string count b\\n        for(int i=0;i<n;i++)\\n        {\\n            if (s[i]==\\'a\\') count_a--;\\n            ans=min(ans,count_a+count_b);\\n            if (s[i]==\\'b\\') count_b++;\\n        }\\n        return ans;\\n        \\n    }\\n\\nApproach 4: Using stack(one pass and space O(n))\\n\\nIf we delete all occurrences of \"ba\", then we can get the desired string. We use stack for that.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        stack<char> stk;\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if (!stk.empty() && stk.top()==\\'b\\' && s[i]==\\'a\\')\\n                stk.pop(),c++;\\n            else stk.push(s[i]);\\n        }\\n        return c;\\n    }\\n\\nApproach 5: Using DP approach: one pass with space O(n)\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> dp(n+1,0);\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') dp[i+1]=dp[i],count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                dp[i+1]=min(dp[i]+1,count_b);\\n            }\\n        }\\n        return dp[n];\\n        \\n    }\\n\\nApproach 6: \\n\\nOne pass space O(1)\\nimprovisation on the approach 5\\n\\nNote that in the dp approach, to obtain the value of dp[i+1], we only need dp[i], and not dp[0]...dp[i-1]\\nHence, instead of dp array, we can also use a variable called ans to store dp[i].\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        //corresponingly ans variable represents dp[i]\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                ans=min(ans+1,count_b);\\n            }\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "Approach 1: Three passes with space O(n)\\nIn the first pass, we compute vector \"b\" which stores the count of character \\'b\\'. \\nIn the second pass, we compute vector \"a\" which stores the count of character \\'a\\'.\\nIn the third pass, we iterate through the string s. \\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        vector<int> b(n,0);\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            b[i]=c;\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        for(int i=0;i<n;i++) ans=min(ans,a[i]+b[i]);\\n        return ans;\\n        \\n    }\\n\\nApproach2: Two passes with space O(n)\\nWe compute vector a, and instead of computing vector b, we do the processing while iterating through the string itself.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        int c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(a[i]+c,ans);\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        return ans;\\n    }\\n\\nApproach 3: Two passes with space O(1).\\nInstead of using vector a and b, we use two variables count_a and count_b.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        //get the count of a\\'s in the first pass\\n        int count_a=0;\\n        for(int i=0;i<n;i++) if (s[i]==\\'a\\') count_a++;\\n        int count_b=0;\\n        int ans=n;\\n        //second pass\\n        //as you iterate through the string count b\\n        for(int i=0;i<n;i++)\\n        {\\n            if (s[i]==\\'a\\') count_a--;\\n            ans=min(ans,count_a+count_b);\\n            if (s[i]==\\'b\\') count_b++;\\n        }\\n        return ans;\\n        \\n    }\\n\\nApproach 4: Using stack(one pass and space O(n))\\n\\nIf we delete all occurrences of \"ba\", then we can get the desired string. We use stack for that.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        stack<char> stk;\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if (!stk.empty() && stk.top()==\\'b\\' && s[i]==\\'a\\')\\n                stk.pop(),c++;\\n            else stk.push(s[i]);\\n        }\\n        return c;\\n    }\\n\\nApproach 5: Using DP approach: one pass with space O(n)\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> dp(n+1,0);\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') dp[i+1]=dp[i],count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                dp[i+1]=min(dp[i]+1,count_b);\\n            }\\n        }\\n        return dp[n];\\n        \\n    }\\n\\nApproach 6: \\n\\nOne pass space O(1)\\nimprovisation on the approach 5\\n\\nNote that in the dp approach, to obtain the value of dp[i+1], we only need dp[i], and not dp[0]...dp[i-1]\\nHence, instead of dp array, we can also use a variable called ans to store dp[i].\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        //corresponingly ans variable represents dp[i]\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                ans=min(ans+1,count_b);\\n            }\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 935373,
                "title": "c-stack-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //Idea is to traverse from right to left & use stack to keep track if \\'b\\' comes before \\'a\\' in string\\n    //then we need to pop & need to delete that character\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int n =s.size();\\n        int res = 0;\\n        \\n        for(int i = n-1; i >=0; i--){\\n            char c = s[i];\\n            if(!st.empty() && st.top() < c){\\n                res++;\\n                st.pop();\\n            }else{\\n                st.push(c);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Idea is to traverse from right to left & use stack to keep track if \\'b\\' comes before \\'a\\' in string\\n    //then we need to pop & need to delete that character\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int n =s.size();\\n        int res = 0;\\n        \\n        for(int i = n-1; i >=0; i--){\\n            char c = s[i];\\n            if(!st.empty() && st.top() < c){\\n                res++;\\n                st.pop();\\n            }else{\\n                st.push(c);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936436,
                "title": "java-python-3-two-codes-1-pass-and-2-passes-w-brief-explanation-and-analysis",
                "content": "**Method 1: Use stack to cancel bad pairs**\\n\\nWhenever encounter a pair of `\"ba\"`, cancel both of them and count the number of cancellations; \\nWhy this works? \\nWhether delete `a` or `b` depending on the the character right after the last cancellation is `a` or `b`; If `a`, we have to delete `b`\\'s in all cancellations, otherwise delete either `a`\\'s or `b`\\'s. Therefore, we are sure there is no `ba` in the string.\\n\\n\\n**Q & A:**\\n\\nQ1: For this approach, it seems to be that it is more of `finding the number of deletions` rather than the `minimum` number of deletions. is there a proof that using a stack and cancelling bad pairs would lead us to the minimum deletions rather than just finding the number of deletions?\\nA1: All indices of character(s) inside stack are less than that  of those outside. Therefore, whenever we find a `\\'b\\'` inside and a `\\'a\\'` outside of the stack, we have to delete 1 (either `\\'a\\'` or `\\'b\\'`) to make the string balanced. In short, if there are total n bad pairs, then there must be n `\\'b\\'`\\'s in front of n `\\'a\\'`\\'s, and the n is the minimum deletions.\\n\\n**End of Q & A**.\\n\\n```java\\n    public int minimumDeletions(String s) {\\n        int cnt = 0;\\n        Deque<Character> stk = new ArrayDeque<>();\\n        for (char c : s.toCharArray()) {\\n            if (!stk.isEmpty() && stk.peek() == \\'b\\' && c == \\'a\\') {\\n                stk.pop();\\n                ++cnt;\\n            }else {\\n                stk.push(c);\\n            }\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        cnt, stack = 0, []\\n        for c in s:\\n            if stack and stack[-1] == \\'b\\' and c == \\'a\\':\\n                stack.pop()\\n                cnt += 1\\n            else:\\n                stack.append(c)\\n        return cnt\\n```\\n**Analysis:**\\n\\nTime & space: O(n), n = s.length().\\n\\n----\\n\\n**Method 2: Two passes with space O(1).**\\n\\nCount the total occurrences of `\\'a\\'` on the right and `\\'b\\'` on the left for each index, find the mininum;\\n\\n```java\\n    public int minimumDeletions(String s) {\\n        int a = s.chars().map(i -> i == \\'a\\' ? 1 : 0).sum();\\n        int cnt = a, b = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'b\\') {\\n                cnt = Math.min(cnt, a + b++);\\n            }else {\\n                --a;\\n            }\\n        }\\n        return Math.min(cnt, b);\\n    }\\n```\\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        a, b, cnt = s.count(\\'a\\'), 0, len(s)\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt = min(cnt, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(cnt, b)\\n```\\n**Analysis:**\\n\\nTime: O(n), space: O(1), n = s.length().\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minimumDeletions(String s) {\\n        int cnt = 0;\\n        Deque<Character> stk = new ArrayDeque<>();\\n        for (char c : s.toCharArray()) {\\n            if (!stk.isEmpty() && stk.peek() == \\'b\\' && c == \\'a\\') {\\n                stk.pop();\\n                ++cnt;\\n            }else {\\n                stk.push(c);\\n            }\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        cnt, stack = 0, []\\n        for c in s:\\n            if stack and stack[-1] == \\'b\\' and c == \\'a\\':\\n                stack.pop()\\n                cnt += 1\\n            else:\\n                stack.append(c)\\n        return cnt\\n```\n```java\\n    public int minimumDeletions(String s) {\\n        int a = s.chars().map(i -> i == \\'a\\' ? 1 : 0).sum();\\n        int cnt = a, b = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'b\\') {\\n                cnt = Math.min(cnt, a + b++);\\n            }else {\\n                --a;\\n            }\\n        }\\n        return Math.min(cnt, b);\\n    }\\n```\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        a, b, cnt = s.count(\\'a\\'), 0, len(s)\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt = min(cnt, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(cnt, b)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935464,
                "title": "python-dp-o-n-short-with-explanation",
                "content": "```\\ndef minimumDeletions(self, s: str) -> int:\\n        cnt_b = 0\\n        dp = [0]\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt_b+=1\\n                dp.append( dp[-1] )\\n            else:\\n                dp.append( min(cnt_b,dp[-1]+1) )\\n        return dp[-1]\\n```\\nThe problem can be formulated as DP.\\n\\nAt every point when you see  \\'a\\' , you have 2 options, \\n1. remove all the b\\'s you found earlier.  --> total cost = count_of_b\\nOR\\n2. delete the current \\'a\\'. --> total cost = cur_total_cost + 1\\n\\nIf u see a \\'b\\' , then no more cost.\\n\\nThus maintain the count of \\'b\\'s you found. \\n\\nPlease Upvote!",
                "solutionTags": [],
                "code": "```\\ndef minimumDeletions(self, s: str) -> int:\\n        cnt_b = 0\\n        dp = [0]\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt_b+=1\\n                dp.append( dp[-1] )\\n            else:\\n                dp.append( min(cnt_b,dp[-1]+1) )\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935372,
                "title": "c-find-split-location-simple-o-n-time-o-1-mem",
                "content": "My intuition for this problem is to keep track of the extra As and Bs to the right and left of each position and find the position with the minimun extra letters. \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int as = 0, bs = 0;\\n        for( const char& c : s )\\n            if( c == \\'a\\' )\\n                ++as;\\n        \\n        int del = as;\\n        for( const char& c : s )\\n        {\\n            if( c == \\'b\\' )\\n                ++bs;\\n            else\\n                --as;\\n            \\n            del = min( del, (as+bs) );\\n        }\\n        return del;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int as = 0, bs = 0;\\n        for( const char& c : s )\\n            if( c == \\'a\\' )\\n                ++as;\\n        \\n        int del = as;\\n        for( const char& c : s )\\n        {\\n            if( c == \\'b\\' )\\n                ++bs;\\n            else\\n                --as;\\n            \\n            del = min( del, (as+bs) );\\n        }\\n        return del;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935422,
                "title": "python-greedy-iterate-from-the-back",
                "content": "Refer to @wareag1e in the comment, the explanation is way better there.\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        a = 0\\n        res = 0\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == \\'a\\':\\n                a += 1\\n            elif s[i] == \\'b\\':\\n                if a > 0:\\n                    a -= 1\\n                    res += 1\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        a = 0\\n        res = 0\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == \\'a\\':\\n                a += 1\\n            elif s[i] == \\'b\\':\\n                if a > 0:\\n                    a -= 1\\n                    res += 1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 935399,
                "title": "c-minimalism-o-n",
                "content": "#### Approach 1: Find the split point\\n```cpp\\nint minimumDeletions(string s) {\\n    int a = count(begin(s), end(s), \\'a\\'), b = 0, res = a;\\n    for (auto ch : s) {\\n        b += ch == \\'b\\';\\n        a -= ch == \\'a\\';\\n        res = min(res, b + a);\\n    }\\n    return res;\\n}\\n```\\n\\n#### Approach 2: Simulation\\nWe count the total number of \\'a\\' and \\'b\\'. Then, we \"eat\" all \\'a\\' from the left, and all \\'b\\' from the right.\\n\\nNow, we are at the decision point - do we remove from left of right?\\n\\nIt seems that greedy got accepted - we remove the charracter with the smaller count - but I am still thinking of the proof.\\n\\n```cpp\\nint minimumDeletions(string s) {\\n    int a = 0, b = 0, l = 0, r = s.size() - 1, res = 0;\\n    for (auto ch : s) {\\n        a += ch == \\'a\\'; \\n        b += ch == \\'b\\';\\n    }\\n    while (l < r) {\\n        if (a && s[l] == \\'a\\') {\\n            ++l;\\n            --a;\\n        }\\n        else if (b && s[r] == \\'b\\') {\\n            --r;\\n            --b;\\n        }\\n        else {\\n            ++res;\\n            if (a < b) {\\n                --a;\\n                --r;\\n            }\\n            else {\\n                --b;\\n                ++l;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minimumDeletions(string s) {\\n    int a = count(begin(s), end(s), \\'a\\'), b = 0, res = a;\\n    for (auto ch : s) {\\n        b += ch == \\'b\\';\\n        a -= ch == \\'a\\';\\n        res = min(res, b + a);\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint minimumDeletions(string s) {\\n    int a = 0, b = 0, l = 0, r = s.size() - 1, res = 0;\\n    for (auto ch : s) {\\n        a += ch == \\'a\\'; \\n        b += ch == \\'b\\';\\n    }\\n    while (l < r) {\\n        if (a && s[l] == \\'a\\') {\\n            ++l;\\n            --a;\\n        }\\n        else if (b && s[r] == \\'b\\') {\\n            --r;\\n            --b;\\n        }\\n        else {\\n            ++res;\\n            if (a < b) {\\n                --a;\\n                --r;\\n            }\\n            else {\\n                --b;\\n                ++l;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038781,
                "title": "simple-python-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        result = 0\\n        b_count = 0\\n        \\n        for c in s:\\n            if c == \"a\":\\n                result = min(b_count, result + 1)\\n            else:\\n                b_count += 1\\n        \\n        return result\\n```\\n\\nAt every point in our traversal, if we encounter an \"a\", we can either delete every \"b\" up to that point, or we can delete that one \"a\".\\n\\n```result``` keeps a running total of the number of deletions we have made so far to keep the string up until the current point balanced.\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        result = 0\\n        b_count = 0\\n        \\n        for c in s:\\n            if c == \"a\":\\n                result = min(b_count, result + 1)\\n            else:\\n                b_count += 1\\n        \\n        return result\\n```\n```result```",
                "codeTag": "Java"
            },
            {
                "id": 1020107,
                "title": "python-dp-solution-easy-to-understand",
                "content": "* O(n) for loop each character of the string s\\n* Track the minimum number of deletions to make a balanced string till current character, either ending with \\'a\\' or \\'b\\'.\\n* In the end, find the min of these two numbers\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        # track the minimum number of deletions to make the current string balanced ending with \\'a\\', \\'b\\'\\n        end_a, end_b = 0,0 \\n        for val in s:\\n            if val == \\'a\\':\\n                # to end with \\'a\\', nothing to do with previous ending with \\'a\\'\\n                # to end with \\'b\\', need to delete the current \\'a\\' from previous ending with \\'b\\'\\n                end_b += 1\\n            else:\\n                # to end with \\'a\\', need to delete the current \\'b\\' from previous ending with \\'a\\'\\n                # to end with \\'b\\', nothing to do, so just pick smaller of end_a, end_b\\n                end_a, end_b = end_a+1, min(end_a, end_b)\\n        return min(end_a, end_b)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        # track the minimum number of deletions to make the current string balanced ending with \\'a\\', \\'b\\'\\n        end_a, end_b = 0,0 \\n        for val in s:\\n            if val == \\'a\\':\\n                # to end with \\'a\\', nothing to do with previous ending with \\'a\\'\\n                # to end with \\'b\\', need to delete the current \\'a\\' from previous ending with \\'b\\'\\n                end_b += 1\\n            else:\\n                # to end with \\'a\\', need to delete the current \\'b\\' from previous ending with \\'a\\'\\n                # to end with \\'b\\', nothing to do, so just pick smaller of end_a, end_b\\n                end_a, end_b = end_a+1, min(end_a, end_b)\\n        return min(end_a, end_b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935481,
                "title": "java-dp-17-ms-faster-than-100-00-39-7-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int dp = 0, cntb = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'a\\') dp = Math.min(dp + 1, cntb);\\n            else ++cntb;\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int dp = 0, cntb = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'a\\') dp = Math.min(dp + 1, cntb);\\n            else ++cntb;\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878367,
                "title": "java-simple-and-easy-to-understand-with-comments-o-n-time",
                "content": "The whole problem boils down to the positions of A and B (using A and B instead of \\'a\\' and \\'b\\' so its easier to read and understand). All is good until all the As are before the Bs. It is balanced. It becomes a problem when As appears after Bs.\\n\\nTo solve it, start going through the string, char by char, and keep a count of the Bs (increment it). Once you have your Bs, then if an A appears, then you have to cut down a A for every B (decrement it) only if the count of B is greater than 0. You also need to track the number of decrements of Bs counts (total number of removals).\\n\\nConsider this string - aabbabb\\n\\nAll is well and good until its index = 4 (\\'a\\'). Now the countB = 2, decrement it (becomes 1), and increment the removal (becomes 1).\\n\\n```\\npublic static int minimumDeletions(String s) {\\n\\n        if (s == null || s.isEmpty()) return 0;\\n\\n        int countB = 0; //keep a count of Bs\\n        int removals = 0; //keep a count of removed As\\n\\n        for (int i = 0; i < s.length(); i++) {\\n\\n            if (s.charAt(i) == \\'a\\') {\\n                if (countB > 0) { // only if there are Bs before this A\\n                    ++removals; // remove this A\\n                    --countB; // and decrement the Bs count\\n                }\\n            } else {\\n                ++countB; // keep incrementing the Bs count\\n            }\\n        }\\n       return removals;\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int minimumDeletions(String s) {\\n\\n        if (s == null || s.isEmpty()) return 0;\\n\\n        int countB = 0; //keep a count of Bs\\n        int removals = 0; //keep a count of removed As\\n\\n        for (int i = 0; i < s.length(); i++) {\\n\\n            if (s.charAt(i) == \\'a\\') {\\n                if (countB > 0) { // only if there are Bs before this A\\n                    ++removals; // remove this A\\n                    --countB; // and decrement the Bs count\\n                }\\n            } else {\\n                ++countB; // keep incrementing the Bs count\\n            }\\n        }\\n       return removals;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 943968,
                "title": "java-dp-accepted-explanation",
                "content": "**We use Dynamic programming approach because for each substring we need to consider all cases !**\\n\\nFor the sake of explanation:\\n1. we iterate from left->right\\n2. we consider ideal case for us as \"bbbbbbbbbbbbbbb.......bbb\"\\n\\nWe move from left->right and so we consider the ideal case as all b\\'s because any number of b\\'s is valid as move from left->right(with no a\\'s in between).\\n\\nSo we consider \\'b\\' as our friendly character and \\'a\\' as our enemy .\\n\\n**So whenever we see a \\'b\\' we just increase the bCount by one and our answer for that particular substring(0..i) is dp[idx-1].**\\n\\n**But if we see an \\'a\\' then we need to take into consideration 2 cases :**\\n\\n**case 1:** keep current a. ==> prev chars must be a...a , so need to remove all \\'b\\' chars before i, which is bcount\\n                \\n **case 2:** remove current a ==> prev chars must be a...ab...b, so need to remove current a and whatever makes substring before current i valid which is dp[idx-1]+1;\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        //ideal case :  bbbbbbbbb\\n        int[] dp =  new int[s.length()+1];\\n        int idx =1;\\n        int bCount=0;\\n        \\n        for(int i =0 ;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'a\\')\\n            {\\n             dp[idx] = Math.min(dp[idx-1]+1,bCount);   \\n            }\\n            else\\n            {\\n                dp[idx]=dp[idx-1];\\n                bCount++;\\n            }\\n            \\n            idx++;\\n        }\\n        return dp[s.length()];\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        //ideal case :  bbbbbbbbb\\n        int[] dp =  new int[s.length()+1];\\n        int idx =1;\\n        int bCount=0;\\n        \\n        for(int i =0 ;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'a\\')\\n            {\\n             dp[idx] = Math.min(dp[idx-1]+1,bCount);   \\n            }\\n            else\\n            {\\n                dp[idx]=dp[idx-1];\\n                bCount++;\\n            }\\n            \\n            idx++;\\n        }\\n        return dp[s.length()];\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912995,
                "title": "python-easy-to-read-and-understand-stack",
                "content": "**Count the total number of ba pairs**\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack, res = [], 0\\n        for i in range(len(s)):\\n            if stack and s[i] == \"a\" and stack[-1] == \"b\":\\n                stack.pop()\\n                res += 1\\n            else:\\n                stack.append(s[i])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "**Count the total number of ba pairs**\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack, res = [], 0\\n        for i in range(len(s)):\\n            if stack and s[i] == \"a\" and stack[-1] == \"b\":\\n                stack.pop()\\n                res += 1\\n            else:\\n                stack.append(s[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1025601,
                "title": "c-o-n-time-complexity-and-o-1-space",
                "content": "Greedy. Use bCnt to record count for preserved b (have no way to be replaced by a) up till now, use res to record deletion count.  \\n\\nTraverse string s, for each char ch:\\n(1) If it\\'s b, we don\\'t know whether to delete it or not, only increase bCnt by 1. \\n(2) If it\\'s a, we will make deletion only when bCnt is > 0, which means there\\'re b preserved before and has no way to be replaced by traversed a. We might delete current a, or delete previous b, but we don\\'t know yet since this is decided by furture remainig chars. But no matter what we delete, the deletion cnt res will always increase by 1. Use the greedy idea, even if we delete current a, still decrease bCnt by 1 to indicate this b can be replaced by a if later we need it to be replaced\\n\\neg1. aabba\\naabb -> res = 0, bCnt = 2; \\naabba -> res = 1, bCnt = 1; \\nans: aabb\\n\\neg2. aabbaaa\\naabb -> res = 0, bCnt = 2; \\naabba -> res = 1, bCnt = 1 (aabb, or aaba)\\naabbaa -> res = 2, bCnt = 0 (aabb, or aaaa)\\naabbaaa -> res = 2, bCnt = 0 (aaaaa)\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCnt = 0;\\n        int res = 0;\\n        for (char& ch : s) {\\n            if (ch == \\'a\\' && bCnt > 0) {\\n                bCnt--;\\n                res++;\\n            }\\n            if (ch == \\'b\\') {\\n                bCnt++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCnt = 0;\\n        int res = 0;\\n        for (char& ch : s) {\\n            if (ch == \\'a\\' && bCnt > 0) {\\n                bCnt--;\\n                res++;\\n            }\\n            if (ch == \\'b\\') {\\n                bCnt++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948123,
                "title": "simple-c-solution-beats-90",
                "content": "The idea is really simple; you basically count the number of \\'a\\' characters in the string, and then iterate over the string to count the number of \\'b\\' characters. The sum of these 2 values at a given index is the number of deletions you need to make in order to balance the string. \\n\\nFrom there you simply return the minimum sum (deleteCount);\\n\\n```cpp\\nclass Solution {\\n    public:\\n        int minimumDeletions(string s) {\\n            int rightA = 0;\\n            int leftB = 0;\\n\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\'){\\n                    rightA += 1;\\n                }\\n            }\\n\\n            int deleteCount = leftB + rightA;\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\') {\\n                    rightA -= 1;\\n                } else {\\n                    leftB += 1;\\n                }\\n                \\n                if (leftB + rightA < deleteCount){\\n                    deleteCount = leftB + rightA;\\n                }\\n            }\\n            return deleteCount;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\n    public:\\n        int minimumDeletions(string s) {\\n            int rightA = 0;\\n            int leftB = 0;\\n\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\'){\\n                    rightA += 1;\\n                }\\n            }\\n\\n            int deleteCount = leftB + rightA;\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\') {\\n                    rightA -= 1;\\n                } else {\\n                    leftB += 1;\\n                }\\n                \\n                if (leftB + rightA < deleteCount){\\n                    deleteCount = leftB + rightA;\\n                }\\n            }\\n            return deleteCount;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510493,
                "title": "c-explained-intuitive-approach",
                "content": "My approach without using DP.\\n\\nThe resultant string must have all `a\\'s` to left and all `b\\'s` to the right.\\n\\n*  Count for every index, `number of b\\'s to there left` call it as array `bvec`\\n*  Count for every index, `number of a\\'s to there right`call it as array `avec`\\n*  Now, to remove all `b` from left and all `a` from right we need one index from which it will be minimum.\\n*  Therefore, we will traverse both the array and find the minimum `bvec[i] + avec[i]` for some `i` where `0 <= i < n`\\n\\nCode : \\n```cpp\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n = s.length();\\n        vector<int> bvec(n);\\n        vector<int> avec(n);\\n        \\n        int cnt = 0;\\n        // generate array for every index number of b\\'s to there left\\n        for(int i = 0; i < n; i++){\\n            bvec[i] = cnt;\\n            if(s[i] == \\'b\\'){\\n                cnt++;\\n            }\\n        }\\n        cnt = 0;\\n        // generate array for every index number of a\\'s to there right\\n        for(int i = n - 1; i >= 0; i--){\\n            avec[i] = cnt;\\n            if(s[i] == \\'a\\'){\\n                cnt++;\\n            }\\n        }\\n        \\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            mini = min(mini, bvec[i] + avec[i]);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n = s.length();\\n        vector<int> bvec(n);\\n        vector<int> avec(n);\\n        \\n        int cnt = 0;\\n        // generate array for every index number of b\\'s to there left\\n        for(int i = 0; i < n; i++){\\n            bvec[i] = cnt;\\n            if(s[i] == \\'b\\'){\\n                cnt++;\\n            }\\n        }\\n        cnt = 0;\\n        // generate array for every index number of a\\'s to there right\\n        for(int i = n - 1; i >= 0; i--){\\n            avec[i] = cnt;\\n            if(s[i] == \\'a\\'){\\n                cnt++;\\n            }\\n        }\\n        \\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            mini = min(mini, bvec[i] + avec[i]);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935616,
                "title": "easy-to-understand-solutions-with-optimization",
                "content": "To begin with, we can think about that **if we want to obtain the min deletion, what we can do?** For each index, if we find a pair that is not banlanced, we must do 2 things to make it banlanced:\\n\\n**1. Delete all \\'b\\'s before this index**\\n\\t**2. Delete all \\'a\\'s on and after this index**\\n\\nThen we can compare those **sums of deleting times** to find the min.\\n\\nSo, we can use 2 array, *aSum* represents **how many \\'a\\'s on its right**, *bSum* represents **how many \\'b\\'s on its left**.\\n```\\npublic int minimumDeletions(String s) {\\n\\tint length = s.length(), aSum[] = new int[length], bSum[] = new int[length], curMin = Integer.MAX_VALUE;\\n\\tfor (int i = length - 1; i >= 0; i--) {\\n\\t\\taSum[i] = (i < length - 1 ? aSum[i + 1] : 0) + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length; i++) {\\n\\t\\tbSum[i] = (i > 0 ? bSum[i - 1] : 0) + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length + 1; i++) {\\n\\t\\tcurMin = Math.min(curMin, (i > 0 ? bSum[i - 1] : 0) + (i == length ? 0 : aSum[i]));\\n\\t}\\n\\treturn curMin;\\n}\\n```\\n\\nWe also notice that each element in *aSum* and *bSum* is only use once, so **we can change that 2 arrays to 2 variables**:\\n```\\npublic int minimumDeletions(String s) {\\n\\tint aSum = 0, bSum = 0; \\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tif (c == \\'a\\')\\n\\t\\t\\taSum += 1;\\n\\t\\telse {\\n\\t\\t\\taSum = Math.min(aSum, bSum);\\n\\t\\t\\tbSum += 1;\\n\\t\\t}\\n\\t}\\n\\treturn Math.min(aSum, bSum);\\n}\\n```\\n\\n**Now we can see the space complexity reduce from O(n) to O(1).**\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic int minimumDeletions(String s) {\\n\\tint length = s.length(), aSum[] = new int[length], bSum[] = new int[length], curMin = Integer.MAX_VALUE;\\n\\tfor (int i = length - 1; i >= 0; i--) {\\n\\t\\taSum[i] = (i < length - 1 ? aSum[i + 1] : 0) + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length; i++) {\\n\\t\\tbSum[i] = (i > 0 ? bSum[i - 1] : 0) + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length + 1; i++) {\\n\\t\\tcurMin = Math.min(curMin, (i > 0 ? bSum[i - 1] : 0) + (i == length ? 0 : aSum[i]));\\n\\t}\\n\\treturn curMin;\\n}\\n```\n```\\npublic int minimumDeletions(String s) {\\n\\tint aSum = 0, bSum = 0; \\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tif (c == \\'a\\')\\n\\t\\t\\taSum += 1;\\n\\t\\telse {\\n\\t\\t\\taSum = Math.min(aSum, bSum);\\n\\t\\t\\tbSum += 1;\\n\\t\\t}\\n\\t}\\n\\treturn Math.min(aSum, bSum);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1189982,
                "title": "top-down-dp-and-greedy-solution-c",
                "content": "### Top Down Dynamic Programming\\n\\n182 ms\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[100001][2];\\n    \\n    int getMinDeletions(string& s, bool bPrev = false, int current = 0) {\\n        if(current >= s.size()) return 0;\\n        if(dp[current][(int)bPrev]) return dp[current][(int)bPrev];\\n        char ch = s[current];\\n        if(ch == \\'a\\' && bPrev) { // Delete the current a\\n            dp[current][(int)bPrev] = 1 + getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(bPrev) { // Continue since current is b\\n            dp[current][(int)bPrev] =  getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(ch == \\'a\\') { // If no b before and current a\\n            dp[current][(int)bPrev] = getMinDeletions(s,false,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        // Current is b\\n        dp[current][(int)bPrev] = min(getMinDeletions(s,true,current+1), 1 + getMinDeletions(s,false,current+1));\\n        return dp[current][(int)bPrev];\\n    }\\n    \\n    int minimumDeletions(string s) {\\n        memset(dp,0,sizeof(dp));\\n        return getMinDeletions(s);\\n    }\\n};\\n```\\n\\n### Greedy Approach\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    int minimumDeletions(string s) {\\n        int prefA[s.size()+1];\\n        int prefB[s.size()+1];\\n        memset(prefA, 0, sizeof(prefA));\\n        memset(prefB, 0, sizeof(prefB));\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            prefA[i+1] = prefA[i] + (s[i] == \\'a\\' ? 1 : 0);\\n            prefB[i+1] = prefB[i] + (s[i] == \\'b\\' ? 1 : 0);\\n        }\\n        \\n        int minMoves = INT_MAX;\\n        \\n        for(int i=0; i<=s.size(); i++) {\\n            minMoves = min(minMoves, prefB[i] + (prefA[s.size()] - prefA[i]));\\n        }\\n        \\n        return minMoves;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[100001][2];\\n    \\n    int getMinDeletions(string& s, bool bPrev = false, int current = 0) {\\n        if(current >= s.size()) return 0;\\n        if(dp[current][(int)bPrev]) return dp[current][(int)bPrev];\\n        char ch = s[current];\\n        if(ch == \\'a\\' && bPrev) { // Delete the current a\\n            dp[current][(int)bPrev] = 1 + getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(bPrev) { // Continue since current is b\\n            dp[current][(int)bPrev] =  getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(ch == \\'a\\') { // If no b before and current a\\n            dp[current][(int)bPrev] = getMinDeletions(s,false,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        // Current is b\\n        dp[current][(int)bPrev] = min(getMinDeletions(s,true,current+1), 1 + getMinDeletions(s,false,current+1));\\n        return dp[current][(int)bPrev];\\n    }\\n    \\n    int minimumDeletions(string s) {\\n        memset(dp,0,sizeof(dp));\\n        return getMinDeletions(s);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    int minimumDeletions(string s) {\\n        int prefA[s.size()+1];\\n        int prefB[s.size()+1];\\n        memset(prefA, 0, sizeof(prefA));\\n        memset(prefB, 0, sizeof(prefB));\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            prefA[i+1] = prefA[i] + (s[i] == \\'a\\' ? 1 : 0);\\n            prefB[i+1] = prefB[i] + (s[i] == \\'b\\' ? 1 : 0);\\n        }\\n        \\n        int minMoves = INT_MAX;\\n        \\n        for(int i=0; i<=s.size(); i++) {\\n            minMoves = min(minMoves, prefB[i] + (prefA[s.size()] - prefA[i]));\\n        }\\n        \\n        return minMoves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935410,
                "title": "java-get-number-of-a-from-left-and-b-from-right-o-n-time-and-o-n-space",
                "content": "Maintain number of `a` from left and number of `b` from right. Can be solved in `O(1)` space. Here is `O(N)` space solution\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int[] counts = new int[n + 1];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            counts[i] = counts[i + 1];\\n            if (s.charAt(i) == \\'a\\') {\\n                counts[i]++;\\n            }\\n        }\\n        \\n        int counter = 0;\\n        int answer = counts[0];\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == \\'b\\') counter++;\\n            answer = Math.min(answer, counter + counts[i + 1]);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int[] counts = new int[n + 1];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            counts[i] = counts[i + 1];\\n            if (s.charAt(i) == \\'a\\') {\\n                counts[i]++;\\n            }\\n        }\\n        \\n        int counter = 0;\\n        int answer = counts[0];\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == \\'b\\') counter++;\\n            answer = Math.min(answer, counter + counts[i + 1]);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819350,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n            int countb=0;\\n    int ans=0;\\n    for(auto i:s)\\n    {\\n        if(i==\\'b\\'){countb++;}\\n        if(i==\\'a\\' && countb>0){ans++;countb--;}\\n    }\\n    \\n    return ans;\\n}\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n            int countb=0;\\n    int ans=0;\\n    for(auto i:s)\\n    {\\n        if(i==\\'b\\'){countb++;}\\n        if(i==\\'a\\' && countb>0){ans++;countb--;}\\n    }\\n    \\n    return ans;\\n}\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848583,
                "title": "easy-c-solution-fully-explained",
                "content": "**THE PROBLEM CAN BE EASILY SOLVED JUST WITH THE HELP OF OBSERVATION**\\n\\nLET US TAKE A VERY SIMPLE EXAMPLE\\n\\n**STRING  S = \"A A A B A A\"**\\n\\nWE CAN EASILY SAY THAT THE ANSWER IS 1, BUT HOW DO WE ACHIEVE THAT\\n\\nSIMPLEE, **WE CONSIDER EVERY POINT AS BALANCING POINT**\\n\\n1) *ON THE LEFT OF BALANCING POINT EVEYTHING SHOULD BE \"A\" ( THERE SHOULD BE NO B ) *\\n2) ON THE RIGHT OF BALANCING POINT EVERYTHING SHOULB BE \"B\"(THERE SHOULD BE NO A)\\n\\nNOW, IT SIMPLY MEANS THAT FOR A BALANCING POINT IF THERE ARE ANY \"B\" ON THE RIGHT HAND SIDE WE HAVE TO DELETE THEM AND IF THERE ARE ANY \"A\" ON THE RIGHT HAND SIDE OF THE BALANCING POINT WE HAVE TO DELETE THEM\\n\\nTOTAL DELETION = NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   \\n\\nLET US CALCULATE FOR EVERY INDEX FOR THE ABOVE EXAMPLE\\n\" A A A B A A\"\\nNO OF B ON THE LEFT OF EVERY INDEX = [0 ,0 ,0 ,0 ,1 , 1];\\nNO OF A ON THE RIGHT OF EVERY INDEX = [4, 3, 2, 2, 1, 0];\\n\\nNOW FOR INDEX WE HAVE TO CALCULATE **THE  NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   **\\n\\nAND AFTER CALCULATING FOR EVERY INDEX WE HAVE TO JUST TAKE THE MINIMUM\\n\\nHERE WE CAN SEE THAT (1+0) IS THE BEST BALANCING POINT WHERE WE HAVE TO DELETE 1 \"B\" AND 0 \"A\"\\n\\nTHE CODE FOR THE ABOVE SOLUTION IS\\n```\\n  int back[100001]={-1};\\n        int front[100001]={-1};\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                back[i] = count;\\n                count++;\\n            }\\n            else\\n            {\\n                back[i]=count;\\n            }\\n            \\n        }\\n        \\n     count =0;\\n        for(int i=s.size()-1; i>=0; i--)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                front[i]=count;\\n            }\\n            else\\n            {\\n                front[i]=count;\\n                count++;\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            \\n            \\n                int x = back[i]+front[i];\\n                //cout<<back[i]<<\" \";\\n                if(x<ans)\\n                {\\n                    ans = x;\\n                }\\n            \\n        }\\n        \\n        if(ans==INT_MAX)\\n        {\\n            return 0;\\n        }\\n        return ans;\\n        \\n        \\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "**THE PROBLEM CAN BE EASILY SOLVED JUST WITH THE HELP OF OBSERVATION**\\n\\nLET US TAKE A VERY SIMPLE EXAMPLE\\n\\n**STRING  S = \"A A A B A A\"**\\n\\nWE CAN EASILY SAY THAT THE ANSWER IS 1, BUT HOW DO WE ACHIEVE THAT\\n\\nSIMPLEE, **WE CONSIDER EVERY POINT AS BALANCING POINT**\\n\\n1) *ON THE LEFT OF BALANCING POINT EVEYTHING SHOULD BE \"A\" ( THERE SHOULD BE NO B ) *\\n2) ON THE RIGHT OF BALANCING POINT EVERYTHING SHOULB BE \"B\"(THERE SHOULD BE NO A)\\n\\nNOW, IT SIMPLY MEANS THAT FOR A BALANCING POINT IF THERE ARE ANY \"B\" ON THE RIGHT HAND SIDE WE HAVE TO DELETE THEM AND IF THERE ARE ANY \"A\" ON THE RIGHT HAND SIDE OF THE BALANCING POINT WE HAVE TO DELETE THEM\\n\\nTOTAL DELETION = NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   \\n\\nLET US CALCULATE FOR EVERY INDEX FOR THE ABOVE EXAMPLE\\n\" A A A B A A\"\\nNO OF B ON THE LEFT OF EVERY INDEX = [0 ,0 ,0 ,0 ,1 , 1];\\nNO OF A ON THE RIGHT OF EVERY INDEX = [4, 3, 2, 2, 1, 0];\\n\\nNOW FOR INDEX WE HAVE TO CALCULATE **THE  NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   **\\n\\nAND AFTER CALCULATING FOR EVERY INDEX WE HAVE TO JUST TAKE THE MINIMUM\\n\\nHERE WE CAN SEE THAT (1+0) IS THE BEST BALANCING POINT WHERE WE HAVE TO DELETE 1 \"B\" AND 0 \"A\"\\n\\nTHE CODE FOR THE ABOVE SOLUTION IS\\n```\\n  int back[100001]={-1};\\n        int front[100001]={-1};\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                back[i] = count;\\n                count++;\\n            }\\n            else\\n            {\\n                back[i]=count;\\n            }\\n            \\n        }\\n        \\n     count =0;\\n        for(int i=s.size()-1; i>=0; i--)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                front[i]=count;\\n            }\\n            else\\n            {\\n                front[i]=count;\\n                count++;\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            \\n            \\n                int x = back[i]+front[i];\\n                //cout<<back[i]<<\" \";\\n                if(x<ans)\\n                {\\n                    ans = x;\\n                }\\n            \\n        }\\n        \\n        if(ans==INT_MAX)\\n        {\\n            return 0;\\n        }\\n        return ans;\\n        \\n        \\n",
                "codeTag": "C++"
            },
            {
                "id": 1674644,
                "title": "c-solution-o-n-time-complexity-beginner-friendly",
                "content": "``` Easy implementation of stack. Time complexity is O(n) where n is length of string. ```\\n``` Just counted the pair of \"ba\" in the string. ```\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string str) {\\n        stack<char>s;         // Initialised the stack\\n        int c=0;\\n        s.push(str[0]);         // Pushed the first char of the string\\n        for(int i=1;i<str.length();i++)\\n        {\\n            if(s.empty())\\n                s.push(str[i]);\\n            else if(s.top()==\\'b\\' && str[i]==\\'a\\')     \\n            {\\n                c++;               // Increased the count of deletions\\n                s.pop();        // Pop the top of stack\\n            }\\n            else\\n                s.push(str[i]);\\n                \\n        }\\n        return c;\\n    }\\n};\\n```\\n``` If you like my approach then hit the like button to  keep me motivated to post more solutions like this.```",
                "solutionTags": [],
                "code": "``` Easy implementation of stack. Time complexity is O(n) where n is length of string. ```\n``` Just counted the pair of \"ba\" in the string. ```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string str) {\\n        stack<char>s;         // Initialised the stack\\n        int c=0;\\n        s.push(str[0]);         // Pushed the first char of the string\\n        for(int i=1;i<str.length();i++)\\n        {\\n            if(s.empty())\\n                s.push(str[i]);\\n            else if(s.top()==\\'b\\' && str[i]==\\'a\\')     \\n            {\\n                c++;               // Increased the count of deletions\\n                s.pop();        // Pop the top of stack\\n            }\\n            else\\n                s.push(str[i]);\\n                \\n        }\\n        return c;\\n    }\\n};\\n```\n``` If you like my approach then hit the like button to  keep me motivated to post more solutions like this.```",
                "codeTag": "Java"
            },
            {
                "id": 1643636,
                "title": "java-stack-simple-2-solutions-explained",
                "content": "The idea here is to simply push \\'b\\' onto a Stack whenever we encounter it.\\nBut what if we encounter \\'a\\', in this case we check if there is a \\'b\\' present already only then we pop \\'b\\' from the Stack (which signifies a Delete operation).\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        Stack<Character> balance = new Stack();\\n        char c = \\' \\';\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            c = s.charAt(i);\\n            if(!balance.empty() && (balance.peek() == \\'b\\' && c == \\'a\\'))\\n            {\\n                balance.pop();\\n                count++;\\n            }\\n            else if(c == \\'b\\')\\n                balance.push(c);\\n        }\\n        return count;\\n    }\\n}\\n```\\nA similar solution just without Stack \\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n        int prefix = 0;\\n        int total = 0;\\n        for (int i = 0; i < l; i++) \\n        {\\n            if (s.charAt(i) == \\'b\\') \\n                prefix++;\\n            else if(s.charAt(i) == \\'a\\' && prefix > 0)\\n            {\\n                prefix--;\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        Stack<Character> balance = new Stack();\\n        char c = \\' \\';\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            c = s.charAt(i);\\n            if(!balance.empty() && (balance.peek() == \\'b\\' && c == \\'a\\'))\\n            {\\n                balance.pop();\\n                count++;\\n            }\\n            else if(c == \\'b\\')\\n                balance.push(c);\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n        int prefix = 0;\\n        int total = 0;\\n        for (int i = 0; i < l; i++) \\n        {\\n            if (s.charAt(i) == \\'b\\') \\n                prefix++;\\n            else if(s.charAt(i) == \\'a\\' && prefix > 0)\\n            {\\n                prefix--;\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045562,
                "title": "best-and-easiest-solution-o-n-82-faster-solution",
                "content": "same as longest increasing subsequence concept\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n                a++;\\n            else\\n                b++;\\n            a=min(a,b);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n                a++;\\n            else\\n                b++;\\n            a=min(a,b);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939185,
                "title": "python-3-one-pass",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        \"\"\"\\n        Given a string s, this program determines the minimum\\n        number of deletions in s needed to make s balanced.\\n        \\n        At any point in s, it can be balanced by deleting all\\n        b\\'s to the left and all a\\'s to the right. This program\\n        scans s, determines the number of deletions at each\\n        point, and returns the minimum.\\n\\n        :param s: string containing only a\\'s and b\\'s\\n        :type s: str\\n        :return: minimum number of deletions in s needed to\\n                 make s balanced\\n        :rtype: int\\n        \"\"\"\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        delete_counts = [a_count + b_count]\\n        for char in s:\\n            if char == \\'a\\':\\n                a_count -= 1\\n            else:\\n                b_count += 1\\n            delete_counts.append(a_count + b_count)\\n        return min(delete_counts)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        \"\"\"\\n        Given a string s, this program determines the minimum\\n        number of deletions in s needed to make s balanced.\\n        \\n        At any point in s, it can be balanced by deleting all\\n        b\\'s to the left and all a\\'s to the right. This program\\n        scans s, determines the number of deletions at each\\n        point, and returns the minimum.\\n\\n        :param s: string containing only a\\'s and b\\'s\\n        :type s: str\\n        :return: minimum number of deletions in s needed to\\n                 make s balanced\\n        :rtype: int\\n        \"\"\"\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        delete_counts = [a_count + b_count]\\n        for char in s:\\n            if char == \\'a\\':\\n                a_count -= 1\\n            else:\\n                b_count += 1\\n            delete_counts.append(a_count + b_count)\\n        return min(delete_counts)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935460,
                "title": "simplest-solution-greedy-o-n",
                "content": "* Given a desired format (`aaa....aaabbbb....bbbb`), lets call the boundary where the transition happens from `a` to `b` as pivot.\\n* To get the desired format, we want to remove all `b` to the left of the pivot. Similarly, we want to remove all `a` to the right of the pivot.\\n* Instead of actually removing, we will keep the counts of `b` to the left of current index and `a` to the right of current index.\\n\\n```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = s.count(\\'a\\')\\n        b = 0\\n        res = len(s)\\n        for ch in s:\\n            if ch == \\'b\\':\\n                res = min(res, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(res, a+b)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = s.count(\\'a\\')\\n        b = 0\\n        res = len(s)\\n        for ch in s:\\n            if ch == \\'b\\':\\n                res = min(res, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(res, a+b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452670,
                "title": "python-stack-beats-95",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count = 0\\n        stack = []        \\n        for c in s:\\n            if c == \\'b\\':\\n                stack.append(c)\\n            elif stack:\\n                stack.pop()\\n                count += 1\\n        return count\\n               \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count = 0\\n        stack = []        \\n        for c in s:\\n            if c == \\'b\\':\\n                stack.append(c)\\n            elif stack:\\n                stack.pop()\\n                count += 1\\n        return count\\n               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000518,
                "title": "java-dp",
                "content": "Store min operation to make length `i` string balanced. To make `i+1` balanced, if `i+1`th character is `b`, keep the same, otherwise either delete all `b`s or delete one more `a` which is one more extra from `i`th result.\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        var len=s.length();\\n        int dp=0,bc=0;\\n        for(int i=0;i<len;i++) {\\n            if(s.charAt(i)==\\'b\\') bc++;\\n            else dp=Math.min(dp+1,bc);\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        var len=s.length();\\n        int dp=0,bc=0;\\n        for(int i=0;i<len;i++) {\\n            if(s.charAt(i)==\\'b\\') bc++;\\n            else dp=Math.min(dp+1,bc);\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935403,
                "title": "python-o-n",
                "content": "`a_right_count[i]`: the number of a at the right of index i\\n`b_left_count[i]`: the number of b at the left of index i\\n`a_right_count[i] + b_left_count[i]`: the number of deleted characters at index i\\n\\n```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_right_count = [0] * len(s)\\n        b_left_count = [0] * len(s)\\n        \\n        count = 0\\n        for i in range(len(s)):\\n            b_left_count[i] = count\\n            if s[i] == \\'b\\':\\n                count += 1\\n        \\n        count = 0\\n        for i in range(len(s) - 1 ,-1, -1):\\n            a_right_count[i] = count\\n            if s[i] == \\'a\\':\\n                count += 1\\n        \\n        min_delete = len(s)\\n        for i in range(len(s)):\\n            min_delete = min(min_delete, a_right_count[i] + b_left_count[i])\\n        return min_delete\\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_right_count = [0] * len(s)\\n        b_left_count = [0] * len(s)\\n        \\n        count = 0\\n        for i in range(len(s)):\\n            b_left_count[i] = count\\n            if s[i] == \\'b\\':\\n                count += 1\\n        \\n        count = 0\\n        for i in range(len(s) - 1 ,-1, -1):\\n            a_right_count[i] = count\\n            if s[i] == \\'a\\':\\n                count += 1\\n        \\n        min_delete = len(s)\\n        for i in range(len(s)):\\n            min_delete = min(min_delete, a_right_count[i] + b_left_count[i])\\n        return min_delete\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041057,
                "title": "prefix-suffix-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), cnt = 0, ans = 1e9;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), cnt = 0, ans = 1e9;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309277,
                "title": "dp-with-o-1-space",
                "content": "```\\n   int minimumDeletions(string s) \\n   {\\n        int i;\\n        int best = 0;\\n        int count = 0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'a\\')\\n                best = min(best+1, count); // if we have seen \\'a\\' then best will be minimun of converting all \\'b\\' till now or whatever was the best till now + 1 for this new \\'a\\' conversion.\\n            if(s[i] == \\'b\\')\\n                count++;  // count the number of \\'b\\'\\n        }\\n        return best;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n   int minimumDeletions(string s) \\n   {\\n        int i;\\n        int best = 0;\\n        int count = 0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'a\\')\\n                best = min(best+1, count); // if we have seen \\'a\\' then best will be minimun of converting all \\'b\\' till now or whatever was the best till now + 1 for this new \\'a\\' conversion.\\n            if(s[i] == \\'b\\')\\n                count++;  // count the number of \\'b\\'\\n        }\\n        return best;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2186582,
                "title": "c-prefix-suffix",
                "content": "* We want to make a sequence of characters such that all `a\\'s` are on left and all `b\\'s` are on right.\\n\\n * At each index of `s` , Keep all `a\\'s` from left till `i` and keep all `b\\'s`  from right till `i`. **Delete all remaining**. **Find minimum out of those**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>pref , suff ;\\n        int a = 0 ;\\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            a += s[i] == \\'a\\' ;\\n            pref.push_back(a) ;\\n        }\\n        int b = 0 ;\\n        for(int i = s.size() - 1 ; i >= 0 ; --i ){\\n            b += s[i] == \\'b\\' ;\\n            suff.push_back(b) ;\\n        }\\n        reverse(begin(suff),end(suff)) ; \\n        \\n        int dels = s.size() ;\\n        for(int i = 0 ; i < s.size() ; ++i ) dels = min(dels,(int)s.size() - pref[i] - suff[i]) ;\\n        return dels ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>pref , suff ;\\n        int a = 0 ;\\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            a += s[i] == \\'a\\' ;\\n            pref.push_back(a) ;\\n        }\\n        int b = 0 ;\\n        for(int i = s.size() - 1 ; i >= 0 ; --i ){\\n            b += s[i] == \\'b\\' ;\\n            suff.push_back(b) ;\\n        }\\n        reverse(begin(suff),end(suff)) ; \\n        \\n        int dels = s.size() ;\\n        for(int i = 0 ; i < s.size() ; ++i ) dels = min(dels,(int)s.size() - pref[i] - suff[i]) ;\\n        return dels ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075592,
                "title": "java-o-n-solution",
                "content": "```\\npublic int minimumDeletions(String s) {\\n\\n        int bCnt = 0;\\n        int ans =0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if(ch ==\\'b\\')bCnt++;\\n            if(bCnt>0 && ch==\\'a\\'){\\n                bCnt--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minimumDeletions(String s) {\\n\\n        int bCnt = 0;\\n        int ans =0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if(ch ==\\'b\\')bCnt++;\\n            if(bCnt>0 && ch==\\'a\\'){\\n                bCnt--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1941430,
                "title": "easy-javascript-bidirectional-dp",
                "content": "This uses the same solution from https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solution/\\nwhere you count the number of \\'b\\' you need to delete going from the left, and count the number of \\'a\\' you need to delete going from the right.\\nOnce you have a count, you find the min_deletion = left_dpA[i] + right_dpB[i]. Note, the bidirectional left shift and right shift is removed, by incrementing the counter after, which yields an non-inclusive character count. The character at i, can be either \\'a\\' or \\'b\\' and it wouldn\\'t effect the minimum delete because that intersection point will belong to left or right.\\n```\\nvar minimumDeletions = function(s) {\\n    const dpA = [];\\n    let counter = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        dpA[i] = counter;\\n        if (s[i] === \\'b\\') {\\n            counter++;\\n        }\\n    }\\n    \\n    counter = 0;\\n    const dpB = [];\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        dpB[i] = counter;\\n        if (s[i] === \\'a\\') {\\n            counter++;\\n        }\\n    }\\n\\n    let minDelete = s.length;\\n    for (let i = 0; i < s.length; i++) {\\n        minDelete = Math.min(minDelete, dpA[i] + dpB[i]);\\n    }\\n    \\n    return minDelete;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minimumDeletions = function(s) {\\n    const dpA = [];\\n    let counter = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        dpA[i] = counter;\\n        if (s[i] === \\'b\\') {\\n            counter++;\\n        }\\n    }\\n    \\n    counter = 0;\\n    const dpB = [];\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        dpB[i] = counter;\\n        if (s[i] === \\'a\\') {\\n            counter++;\\n        }\\n    }\\n\\n    let minDelete = s.length;\\n    for (let i = 0; i < s.length; i++) {\\n        minDelete = Math.min(minDelete, dpA[i] + dpB[i]);\\n    }\\n    \\n    return minDelete;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1700646,
                "title": "java-o-1-space-o-n-complexity",
                "content": "assume we have got answer for string s, then lets suppose a new character comes and get added\\nwe then have below situations for that new character:\\n1. if it is a \\'b\\' then nothing needed, because \\'b\\' at the end will still be balanced\\n2. if it is a \\'a\\' then number of deletion have to be increased from previous no_of_deletions\\nso new no_of_deletions = no_of_deletions + 1.\\nNow we have 2 counters, no_of_b & no_of_deletions. We will take whichever is lesser of the two.\\n```\\n        int b = 0, no_of_deletions = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'b\\') b++;\\n            else no_of_deletions++;\\n            no_of_deletions = Math.min(no_of_deletions, b);\\n        }\\n        return no_of_deletions;\\n```",
                "solutionTags": [],
                "code": "```\\n        int b = 0, no_of_deletions = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'b\\') b++;\\n            else no_of_deletions++;\\n            no_of_deletions = Math.min(no_of_deletions, b);\\n        }\\n        return no_of_deletions;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093898,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        ans = suffix = 0\\n        for c in reversed(s):\\n            if c == \"a\": suffix += 1\\n            else: ans = min(1 + ans, suffix)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        ans = suffix = 0\\n        for c in reversed(s):\\n            if c == \"a\": suffix += 1\\n            else: ans = min(1 + ans, suffix)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965905,
                "title": "c-100-o-n-time-o-1-space-dp-solution-with-explanation",
                "content": "This is classic DP problem. \\n```\\nLet nda[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'a\\'\\nLet ndb[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'b\\'\\n```\\n\\nNow loop over each char of str\\n```\\n\\tcase \\'a\\'\\n\\t\\tnda[i] = nda[i-1]   //No deletions required \\n\\t\\tndb[i] = ndb[i-1] + 1  // 1 deletion required\\n\\t\\tbreak;\\n\\tcase \\'b\\'\\n\\t\\tndb[i] = min(nda[i-1], ndb[i-1]) // previous sub-string doesnt matter, it can be \\'aa\\' or \\'bb\\' or \\'ab\\'\\n\\t\\tnda[i] = nda[i-1] + 1 // 1 deletion required\\n```\\nNow simply return Min of nda[last], ndb[last]\\nDry Run:\\n____aababbab\\nnda 00112334\\nndb 11011122\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>nda(s.size()+1,0);\\n        vector<int>ndb(s.size()+1,0);\\n        int i=1;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                ndb[i] = ndb[i-1] + 1;\\n                nda[i] = nda[i-1] + 0;\\n            }\\n            else{\\n                ndb[i] = min(ndb[i-1],nda[i-1]);\\n                nda[i] = nda[i-1] + 1;\\n            }\\n            i++;\\n        }\\n        return min(ndb[s.size()],nda[s.size()]);\\n    }\\n};\\n/*\\n____aababbab\\nnda 00112334\\nndb 11011122\\n*/\\n```\\nWe can Optimise into O(1) Space since we need only 2 variables\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int a = 0;\\n        int b = 0;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return min(a,b);\\n    }\\n};\\n/*\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nLet nda[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'a\\'\\nLet ndb[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'b\\'\\n```\n```\\n\\tcase \\'a\\'\\n\\t\\tnda[i] = nda[i-1]   //No deletions required \\n\\t\\tndb[i] = ndb[i-1] + 1  // 1 deletion required\\n\\t\\tbreak;\\n\\tcase \\'b\\'\\n\\t\\tndb[i] = min(nda[i-1], ndb[i-1]) // previous sub-string doesnt matter, it can be \\'aa\\' or \\'bb\\' or \\'ab\\'\\n\\t\\tnda[i] = nda[i-1] + 1 // 1 deletion required\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>nda(s.size()+1,0);\\n        vector<int>ndb(s.size()+1,0);\\n        int i=1;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                ndb[i] = ndb[i-1] + 1;\\n                nda[i] = nda[i-1] + 0;\\n            }\\n            else{\\n                ndb[i] = min(ndb[i-1],nda[i-1]);\\n                nda[i] = nda[i-1] + 1;\\n            }\\n            i++;\\n        }\\n        return min(ndb[s.size()],nda[s.size()]);\\n    }\\n};\\n/*\\n____aababbab\\nnda 00112334\\nndb 11011122\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int a = 0;\\n        int b = 0;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return min(a,b);\\n    }\\n};\\n/*\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938408,
                "title": "a-few-solutions",
                "content": "Consider each `i`<sup>th</sup> index as a \"pivot\" position where we can balance `s` via the following 2 operations:\\n\\n1. delete all characters `\\'b\\'`  \\uD83D\\uDC48 to-the-left of `i`\\n2. delete all characters `\\'a\\'`  \\uD83D\\uDC49 to-the-right of `i`\\n\\nLet us denote the results of operation 1 and and operation 2 above as `prefix` and `suffix` correspondingly.  Then we can find the minimum amount of deletions via `prefix[i] + suffix[i] - 1`, ie. add each `i`<sup>th</sup> `prefix` + `i`<sup>th</sup> `suffix` and subtract by `1` (since we only need to delete `\\'a\\'` xor `\\'b\\'`, but *not* both, at each candidate `i`<sup>th</sup> \"pivot\" index).\\n\\n*Example 1:*\\n```\\nInput: s = \"aababbab\"\\nOutput: 2\\n\\n     s = a a b a b b a b\\nprefix = 0 0 1 1 2 3 3 4\\nsuffix = 4 3 2 2 1 1 1 0\\n cands = 3 2 2 2 2 3 3 3  <-- minimum candidate is 2\\n```\\n\\n*Example 2:*\\n```\\nInput: s = \"bbaaaaabb\"\\nOutput: 2\\n\\n     s = b b a a a a a b b\\nprefix = 1 2 2 2 2 2 2 3 4\\nsuffix = 5 5 5 4 3 2 1 0 0\\n cands = 5 6 6 5 4 3 2 2 3  <-- minimum candidate is 2\\n ```\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minimumDeletions(s: String): Int {\\n        var N = s.length\\n        var prefix = IntArray(N) { 0 }\\n        var suffix = IntArray(N) { 0 }\\n        var beg = 0\\n        var end = N - 1\\n        for (i in beg..end)     prefix[i] = (if (s[i] == \\'b\\') 1 else 0) + (if (beg < i) prefix[i - 1] else 0)\\n        for (i in end downTo 0) suffix[i] = (if (s[i] == \\'a\\') 1 else 0) + (if (i < end) suffix[i + 1] else 0)\\n        return prefix.zip(suffix){ a, b -> a + b }.min()!!.minus(1)  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minimumDeletions = s => {\\n    let N = s.length;\\n    let A = s.split(\\'\\');\\n    let prefix = Array(N).fill(0),\\n        suffix = Array(N).fill(0);\\n    let beg = 0,\\n        end = N - 1;\\n    for (let i = beg; i <= end; ++i) prefix[i] = Number(A[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n    for (let i = end; beg <= i; --i) suffix[i] = Number(A[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n    return Math.min(..._.zip(prefix, suffix).map(([a, b]) => a + b)) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        N = len(s)\\n        prefix = [0] * N\\n        suffix = [0] * N\\n        for i in range(N):             prefix[i] = int(s[i] == \\'b\\') + (prefix[i - 1] if 0 < i     else 0)\\n        for i in range(N - 1, -1, -1): suffix[i] = int(s[i] == \\'a\\') + (suffix[i + 1] if i < N - 1 else 0)\\n        return min(a + b for a, b in zip(prefix, suffix)) - 1  # \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_deletions(s: String) -> i32 {\\n        let s: Vec<char> = s.chars().collect();\\n        let N = s.len();\\n        let mut prefix = vec![0; N];\\n        let mut suffix = vec![0; N];\\n        let (beg, end) = (0, N - 1);\\n        for i in 0..N {\\n            prefix[i] = if s[i] == \\'b\\' { 1 } else { 0 } + if beg < i { prefix[i - 1] } else { 0 };\\n        }\\n        for j in (0..N).rev() {\\n            suffix[j] = if s[j] == \\'a\\' { 1 } else { 0 } + if j < end { suffix[j + 1] } else { 0 };\\n        }\\n        prefix.iter().zip(suffix).map(|(a, b)| a + b).min().unwrap() - 1 // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minimumDeletions(string s) {\\n        int N = s.size();\\n        VI prefix(N),\\n           suffix(N),\\n           cands(N);\\n        int beg = 0,\\n            end = N - 1;\\n        for (auto i{ beg }; i <= end; ++i) prefix[i] = int(s[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n        for (auto i{ end }; beg <= i; --i) suffix[i] = int(s[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n        for (auto i{ 0 }; i < N; ++i)\\n            cands[i] = prefix[i] + suffix[i];\\n        return *min_element(cands.begin(), cands.end()) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nInput: s = \"aababbab\"\\nOutput: 2\\n\\n     s = a a b a b b a b\\nprefix = 0 0 1 1 2 3 3 4\\nsuffix = 4 3 2 2 1 1 1 0\\n cands = 3 2 2 2 2 3 3 3  <-- minimum candidate is 2\\n```\n```\\nInput: s = \"bbaaaaabb\"\\nOutput: 2\\n\\n     s = b b a a a a a b b\\nprefix = 1 2 2 2 2 2 2 3 4\\nsuffix = 5 5 5 4 3 2 1 0 0\\n cands = 5 6 6 5 4 3 2 2 3  <-- minimum candidate is 2\\n ```\n```\\nclass Solution {\\n    fun minimumDeletions(s: String): Int {\\n        var N = s.length\\n        var prefix = IntArray(N) { 0 }\\n        var suffix = IntArray(N) { 0 }\\n        var beg = 0\\n        var end = N - 1\\n        for (i in beg..end)     prefix[i] = (if (s[i] == \\'b\\') 1 else 0) + (if (beg < i) prefix[i - 1] else 0)\\n        for (i in end downTo 0) suffix[i] = (if (s[i] == \\'a\\') 1 else 0) + (if (i < end) suffix[i + 1] else 0)\\n        return prefix.zip(suffix){ a, b -> a + b }.min()!!.minus(1)  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\n```\\nlet minimumDeletions = s => {\\n    let N = s.length;\\n    let A = s.split(\\'\\');\\n    let prefix = Array(N).fill(0),\\n        suffix = Array(N).fill(0);\\n    let beg = 0,\\n        end = N - 1;\\n    for (let i = beg; i <= end; ++i) prefix[i] = Number(A[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n    for (let i = end; beg <= i; --i) suffix[i] = Number(A[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n    return Math.min(..._.zip(prefix, suffix).map(([a, b]) => a + b)) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n};\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        N = len(s)\\n        prefix = [0] * N\\n        suffix = [0] * N\\n        for i in range(N):             prefix[i] = int(s[i] == \\'b\\') + (prefix[i - 1] if 0 < i     else 0)\\n        for i in range(N - 1, -1, -1): suffix[i] = int(s[i] == \\'a\\') + (suffix[i + 1] if i < N - 1 else 0)\\n        return min(a + b for a, b in zip(prefix, suffix)) - 1  # \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n```\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_deletions(s: String) -> i32 {\\n        let s: Vec<char> = s.chars().collect();\\n        let N = s.len();\\n        let mut prefix = vec![0; N];\\n        let mut suffix = vec![0; N];\\n        let (beg, end) = (0, N - 1);\\n        for i in 0..N {\\n            prefix[i] = if s[i] == \\'b\\' { 1 } else { 0 } + if beg < i { prefix[i - 1] } else { 0 };\\n        }\\n        for j in (0..N).rev() {\\n            suffix[j] = if s[j] == \\'a\\' { 1 } else { 0 } + if j < end { suffix[j + 1] } else { 0 };\\n        }\\n        prefix.iter().zip(suffix).map(|(a, b)| a + b).min().unwrap() - 1 // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minimumDeletions(string s) {\\n        int N = s.size();\\n        VI prefix(N),\\n           suffix(N),\\n           cands(N);\\n        int beg = 0,\\n            end = N - 1;\\n        for (auto i{ beg }; i <= end; ++i) prefix[i] = int(s[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n        for (auto i{ end }; beg <= i; --i) suffix[i] = int(s[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n        for (auto i{ 0 }; i < N; ++i)\\n            cands[i] = prefix[i] + suffix[i];\\n        return *min_element(cands.begin(), cands.end()) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936514,
                "title": "javascript-time-o-n-space-o-1-100-both",
                "content": "I contrast to counting number of characters to delete, I count characters that I can keep in a balanced string that is subsequence of the whole string and calculate number of chars to delete by extracting it from the total string length. `lena` and `lenb` are lengths of the longest subsequences ending with `a` or `b` respectively. \\n- `a` can be appended only to subsequence ending with `a`, so the length of new subsequence ending with newly added `a` is `lena + 1`.\\n- `b` can be appended both to subsequence ending with `a` or `b` so the length of new subsequence will be `max(lena, lenb) + 1`.\\n```javascript\\nvar minimumDeletions = function (s) {\\n  let lena = 0;\\n  let lenb = 0;\\n  for (let ch of s) {\\n    if (\\'a\\' == ch) {\\n      ++lena;\\n    } else {\\n      lenb = Math.max(lena, lenb) + 1;\\n    }\\n  }\\n\\n  return s.length - Math.max(lena, lenb);\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar minimumDeletions = function (s) {\\n  let lena = 0;\\n  let lenb = 0;\\n  for (let ch of s) {\\n    if (\\'a\\' == ch) {\\n      ++lena;\\n    } else {\\n      lenb = Math.max(lena, lenb) + 1;\\n    }\\n  }\\n\\n  return s.length - Math.max(lena, lenb);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935437,
                "title": "time-o-n-space-o-1-without-stack",
                "content": "We count number of \\'a\\' and \\'b\\'.\\nAnd during traversing we make a decision:\\n1. either we remove \\'b\\'.\\n2. or we remove all upcoming \\'a\\'.\\n\\n```\\npublic int minimumDeletions(String s) {\\n    int a = 0, b = 0;\\n    for(char c : s.toCharArray()) {\\n        if (c == \\'a\\') a++;\\n        else b++;\\n    }\\n    int cA = 0, cB = 0, min = 0, delAll = a;\\n    for(int i = 0; i < s.length(); i++) {\\n        char c = s.charAt(i);\\n        if (a - cA == 0) break;\\n        if (c == \\'a\\') {\\n            cA++;\\n        } else {\\n            cB++;\\n            delAll = Math.min(a - cA + min, delAll);\\n            min++;\\n        }\\n    }\\n    return Math.min(delAll, min);;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minimumDeletions(String s) {\\n    int a = 0, b = 0;\\n    for(char c : s.toCharArray()) {\\n        if (c == \\'a\\') a++;\\n        else b++;\\n    }\\n    int cA = 0, cB = 0, min = 0, delAll = a;\\n    for(int i = 0; i < s.length(); i++) {\\n        char c = s.charAt(i);\\n        if (a - cA == 0) break;\\n        if (c == \\'a\\') {\\n            cA++;\\n        } else {\\n            cB++;\\n            delAll = Math.min(a - cA + min, delAll);\\n            min++;\\n        }\\n    }\\n    return Math.min(delAll, min);;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935387,
                "title": "python-short-and-simple-5-lines-o-n",
                "content": "If we are standing at some position, to make the string balanced by converting the left side to all *a*\\'s and the right side to all *b*\\'s, we need the number of deletions to equal the number of *b*\\'s on the left plus the number of *a*\\'s on the right.\\n\\nLet\\'s start with imaginary position right before the first (index 0) character. The number of needed deletions is the number of *a*\\'s on the right. To move to the next position in the string (between position 0 and 1, then between position 1 and 2, etc.), we need to subtract 1 from the calculated deletions if the current character is *a* (becase if moves from the right part to the left; thus, the number of needed deletions on the right decreases) and add 1 if the current character is b (becase if moves to the left part from the current position; i.e., the number of needed deletions on the left increases). \\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        min_del=del_chars=s.count(\"a\")\\n        for char in s+\"b\":\\n            min_del=min(min_del, del_chars)\\n            del_chars=del_chars+1 if char==\"b\" else del_chars-1\\n        return min_del\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        min_del=del_chars=s.count(\"a\")\\n        for char in s+\"b\":\\n            min_del=min(min_del, del_chars)\\n            del_chars=del_chars+1 if char==\"b\" else del_chars-1\\n        return min_del\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824481,
                "title": "c-very-easy-stack-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count=0;\\n\\n        for(int i=0;i<s.size();i++){\\n            char c = s[i];\\n            if(c == \\'a\\'){\\n                if(!st.empty()){\\n                    st.pop();\\n                    count++;\\n                }\\n            }\\n            else{\\n               st.push(c);\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count=0;\\n\\n        for(int i=0;i<s.size();i++){\\n            char c = s[i];\\n            if(c == \\'a\\'){\\n                if(!st.empty()){\\n                    st.pop();\\n                    count++;\\n                }\\n            }\\n            else{\\n               st.push(c);\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267946,
                "title": "lis-dp-o-n",
                "content": "# Approach\\nThe longest nonstrictly increasing subsequence is computed and then this is subtracted from the length of the input string.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(n)$\\n\\n$n$ is the length of the input string.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int lis(vector<int> & nums, int i, int p, vector<vector<int>> & dp) {\\n\\n        int n = nums.size();\\n\\n        if(i >= n)\\n            return 0;\\n\\n        if(dp[i][p] != -1)\\n            return dp[i][p];\\n\\n        int res = 0;\\n\\n        if(nums[i] >= p)\\n            res = max(res, 1 + lis(nums, i + 1, nums[i], dp));\\n            \\n        res = max(res, lis(nums, i + 1, p, dp));\\n\\n        dp[i][p] = res;\\n\\n        return res;\\n    }\\n\\n    int lengthOfLIS(vector<int> & nums) {\\n        \\n        int n = nums.size();\\n\\n        int uniqueNums = 2;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(uniqueNums, -1));\\n\\n        return lis(nums, 0, 0, dp);\\n    }\\n\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(auto c : s) {\\n            if(c == \\'a\\')\\n                nums.push_back(0);\\n            else \\n                nums.push_back(1);\\n        }\\n\\n        return s.length() - lengthOfLIS(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    int lis(vector<int> & nums, int i, int p, vector<vector<int>> & dp) {\\n\\n        int n = nums.size();\\n\\n        if(i >= n)\\n            return 0;\\n\\n        if(dp[i][p] != -1)\\n            return dp[i][p];\\n\\n        int res = 0;\\n\\n        if(nums[i] >= p)\\n            res = max(res, 1 + lis(nums, i + 1, nums[i], dp));\\n            \\n        res = max(res, lis(nums, i + 1, p, dp));\\n\\n        dp[i][p] = res;\\n\\n        return res;\\n    }\\n\\n    int lengthOfLIS(vector<int> & nums) {\\n        \\n        int n = nums.size();\\n\\n        int uniqueNums = 2;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(uniqueNums, -1));\\n\\n        return lis(nums, 0, 0, dp);\\n    }\\n\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(auto c : s) {\\n            if(c == \\'a\\')\\n                nums.push_back(0);\\n            else \\n                nums.push_back(1);\\n        }\\n\\n        return s.length() - lengthOfLIS(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198090,
                "title": "very-easy-approach-can-be-used-for-many-problems",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach PREFIX AND SUFFIX SUM\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.length(), cnt = 0;\\n        int ans = INT_MAX;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.length(), cnt = 0;\\n        int ans = INT_MAX;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971585,
                "title": "time-o-n-space-o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[ Flip String to Monotone Increasing](https://leetcode.com/problems/flip-string-to-monotone-increasing/solutions/2912351/flip-string-to-monotone-increasing//)\\n\\nExactly Same\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        rightDel = s.count(\\'a\\')\\n        leftDel = 0\\n        ans = rightDel\\n        for i in range(len(s)):\\n            if s[i] == \\'b\\':\\n                leftDel += 1\\n            else:\\n                rightDel -= 1\\n                ans = min(ans,leftDel+rightDel)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        rightDel = s.count(\\'a\\')\\n        leftDel = 0\\n        ans = rightDel\\n        for i in range(len(s)):\\n            if s[i] == \\'b\\':\\n                leftDel += 1\\n            else:\\n                rightDel -= 1\\n                ans = min(ans,leftDel+rightDel)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918899,
                "title": "python3-solution-clean-concise-o-1-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```Python\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        ans, count = 0, 0\\n        for i in s:\\n            if i == \\'b\\':\\n                count += 1\\n            elif count:\\n                ans += 1\\n                count -= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        ans, count = 0, 0\\n        for i in s:\\n            if i == \\'b\\':\\n                count += 1\\n            elif count:\\n                ans += 1\\n                count -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362604,
                "title": "python3-one-pass-o-1-mem-simple-and-intuitive",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n\\n        a_len = 0\\n        ab_len = 0\\n\\n        for c in s:\\n            if c == \"a\":\\n                a_len += 1\\n            else:\\n                ab_len = max(ab_len+1, a_len+1)\\n\\n        return n - max(a_len, ab_len)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n\\n        a_len = 0\\n        ab_len = 0\\n\\n        for c in s:\\n            if c == \"a\":\\n                a_len += 1\\n            else:\\n                ab_len = max(ab_len+1, a_len+1)\\n\\n        return n - max(a_len, ab_len)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340836,
                "title": "my-java-code-o-n-time-o-1-space",
                "content": "This question is similar to->  [https://leetcode.com/problems/flip-string-to-monotone-increasing/]\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int i = 0;\\n        for(i = 0; i < s.length(); i++){\\n            if(s.charAt(i)==\\'b\\')\\n                break;\\n        }\\n        int countflips = 0;\\n        int countb = 0;\\n        for(i=i; i < s.length(); i++){\\n            if(s.charAt(i)==\\'a\\') countflips++;\\n            \\n            else countb++;\\n            \\n            countflips = Math.min(countflips, countb);\\n        }    \\n        return countflips;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimumDeletions(String s) {\\n        int i = 0;\\n        for(i = 0; i < s.length(); i++){\\n            if(s.charAt(i)==\\'b\\')\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2288528,
                "title": "this-should-be-classified-as-easy-problem-simple-java-solution",
                "content": "This is a very simple question.\\n\\tThe idea is straightforward, we need to keep a count of all the `\\'b\\'` that we have encountered. If we encounter an `\\'a\\'`, we need to decrement the count of `b`, since we have found more `b`s before `a`s. And doing that, we need to increment `deleteCt` since we have more `b` and we need to remove that.\\n\\n\\n```\\n    public int minimumDeletions(String s) {\\n        int bCt = 0, deleteCt = 0;\\n        for(char ch: s.toCharArray()){\\n            if(ch == \\'b\\')\\n                bCt = bCt <= 0 ? 1 : bCt + 1;\\n            else {\\n                if(bCt > 0){\\n                    deleteCt++;\\n                    bCt--;\\n                }\\n            }\\n        }\\n        return deleteCt;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n    public int minimumDeletions(String s) {\\n        int bCt = 0, deleteCt = 0;\\n        for(char ch: s.toCharArray()){\\n            if(ch == \\'b\\')\\n                bCt = bCt <= 0 ? 1 : bCt + 1;\\n            else {\\n                if(bCt > 0){\\n                    deleteCt++;\\n                    bCt--;\\n                }\\n            }\\n        }\\n        return deleteCt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228525,
                "title": "faster-than-83-clean-dp-solution-with-explanation",
                "content": "The idea is pretty simple here, we will iterate from index 0 to n-1 and calculate the current max length of balanced string from starting (0) to the current index i ( with the element i being present in it ).\\nNow for example  a a b a b a .\\nIn the above string dp[0]  = 1 ( the max length of balanced string is 1 including the index 0)\\nsimilary for dp[1] = 2 ( a a ).\\nSo we will keep a count of \\'a\\' , and anytime we will encounter a new \\'a\\' the current max length of balanced string would be  count_a + 1. ( The reasoning behind this is that if you want to end your balanced string with an \\'a\\' then you cant include the \\'b\\' in it ).\\nfor example in    a a b a b a \\nthe maximum length of balanced string that you can from ending at index 5 is 4 ( a a a a ) excluding the 2 \\'b\\'s .\\nNow what if we encounter a \\'b\\' , what would be the maximum length of balanced string ending at that index.\\nWell that would be max( previous_b_length , count_a) +1 , because there can be a \\'b\\' or an \\'a\\' before the next b and we would like to take the maximum of the the case.\\n\\nCode:\\n```\\n  int minimumDeletions(string s) {\\n        \\n        int n= s.size(),prevb=0;\\n        int dp[n],maxi=-1;\\n        int i,j,la=0,lb=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                la++;\\n                dp[i] = la;\\n                maxi = max(maxi,dp[i]);\\n            }\\n            if(s[i]==\\'b\\')\\n            {\\n                dp[i] =  max(la,prevb) + 1;\\n                maxi = max(maxi,dp[i]);\\n                prevb = dp[i];\\n            }\\n        }\\n        return n-maxi;\\n\\t\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "The idea is pretty simple here, we will iterate from index 0 to n-1 and calculate the current max length of balanced string from starting (0) to the current index i ( with the element i being present in it ).\\nNow for example  a a b a b a .\\nIn the above string dp[0]  = 1 ( the max length of balanced string is 1 including the index 0)\\nsimilary for dp[1] = 2 ( a a ).\\nSo we will keep a count of \\'a\\' , and anytime we will encounter a new \\'a\\' the current max length of balanced string would be  count_a + 1. ( The reasoning behind this is that if you want to end your balanced string with an \\'a\\' then you cant include the \\'b\\' in it ).\\nfor example in    a a b a b a \\nthe maximum length of balanced string that you can from ending at index 5 is 4 ( a a a a ) excluding the 2 \\'b\\'s .\\nNow what if we encounter a \\'b\\' , what would be the maximum length of balanced string ending at that index.\\nWell that would be max( previous_b_length , count_a) +1 , because there can be a \\'b\\' or an \\'a\\' before the next b and we would like to take the maximum of the the case.\\n\\nCode:\\n```\\n  int minimumDeletions(string s) {\\n        \\n        int n= s.size(),prevb=0;\\n        int dp[n],maxi=-1;\\n        int i,j,la=0,lb=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                la++;\\n                dp[i] = la;\\n                maxi = max(maxi,dp[i]);\\n            }\\n            if(s[i]==\\'b\\')\\n            {\\n                dp[i] =  max(la,prevb) + 1;\\n                maxi = max(maxi,dp[i]);\\n                prevb = dp[i];\\n            }\\n        }\\n        return n-maxi;\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1977265,
                "title": "easy-o-n-time-o-1-space",
                "content": "Basic idea is pretty simple you have to convert string to aaaaa..(n times)bbbb...(m times) so for this, you can select after what index there should be no a\\'s present in the string and before that index there should be no b\\'s. You have to find the index which will give minimum sum of count of: b\\'s from start to index and a\\'s from index to end. Your answer is the sum. \\nSteps:\\n1) Calculate the countA.\\n2) Start iterating by keeping count of a and b, and ans = min(ans,countA-a+b).\\n3) Initially your ans will be countA (no a is considered initially).\\n![image](https://assets.leetcode.com/users/images/6b49cfb3-dbb9-4d2b-83d5-f90030230b8d_1650776896.3743162.png)\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int countA = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                countA++;\\n            }\\n        }\\n        int ans = countA;\\n        int tempA = 0;\\n        int tempB = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                tempA++;\\n            }\\n            else{\\n                tempB++;\\n            }\\n            ans = min(ans,(countA-tempA+tempB));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int countA = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                countA++;\\n            }\\n        }\\n        int ans = countA;\\n        int tempA = 0;\\n        int tempB = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                tempA++;\\n            }\\n            else{\\n                tempB++;\\n            }\\n            ans = min(ans,(countA-tempA+tempB));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775152,
                "title": "java-flip-string-to-monotone-increasing-o-n-time-o-1-space-one-pass",
                "content": "This question is exactly similar to the question Flip String to Monotone Increasing :\\nhttps://leetcode.com/problems/flip-string-to-monotone-increasing/\\n\\nThere we were trying to get minimum number of flips where in this question flip is same as delete.\\n\\n* Flip String to monotone Increasing :\\n\\n \\n        int flips=0;\\n\\t\\tint countOnes=0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\t\\n\\t\\t\\tif (s.charAt(i) == \\'0\\'  &&  countOnes > 0) {\\n\\t\\t\\t\\tflips += 1;\\n\\t\\t\\t\\tcountOnes --;\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(s.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tcountOnes += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn flips;    \\n    \\n\\t\\n* \\tMinimum deletions to make a string balanced :\\n\\n        int deletes=0;\\n\\t\\tint countBs=0;  //count number of consecutive b s\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\tif(s.charAt(i) == \\'a\\'  &&  countBs > 0) {\\n\\t\\t\\t\\tdeletes += 1;\\n\\t\\t\\t\\tcountBs --;\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\tif(s.charAt(i) == \\'b\\') {\\n\\t\\t\\t\\tcountBs += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn deletes;\\n    \\n\\n\\t",
                "solutionTags": [],
                "code": "This question is exactly similar to the question Flip String to Monotone Increasing :\\nhttps://leetcode.com/problems/flip-string-to-monotone-increasing/\\n\\nThere we were trying to get minimum number of flips where in this question flip is same as delete.\\n\\n* Flip String to monotone Increasing :\\n\\n \\n        int flips=0;\\n\\t\\tint countOnes=0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\t\\n\\t\\t\\tif (s.charAt(i) == \\'0\\'  &&  countOnes > 0) {\\n\\t\\t\\t\\tflips += 1;\\n\\t\\t\\t\\tcountOnes --;\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(s.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tcountOnes += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn flips;    \\n    \\n\\t\\n* \\tMinimum deletions to make a string balanced :\\n\\n        int deletes=0;\\n\\t\\tint countBs=0;  //count number of consecutive b s\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\tif(s.charAt(i) == \\'a\\'  &&  countBs > 0) {\\n\\t\\t\\t\\tdeletes += 1;\\n\\t\\t\\t\\tcountBs --;\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\tif(s.charAt(i) == \\'b\\') {\\n\\t\\t\\t\\tcountBs += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn deletes;\\n    \\n\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1662781,
                "title": "easy-c-solution-using-stack-start-counting-from-the-end-of-the-string",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n=s.size();\\n        int c=0;\\n        stack<char>t;\\n        \\n        int i=n-1;\\n        while(i>=0){\\n            \\n            if(t.empty()){\\n                t.push(s[i]);     \\n            }\\n            \\n            else if(t.top()==\\'a\\' && s[i]==\\'b\\'){\\n                c++;\\n                t.pop();         \\n            }\\n            \\n            else t.push(s[i]); \\n            i--;\\n        }    \\n\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n=s.size();\\n        int c=0;\\n        stack<char>t;\\n        \\n        int i=n-1;\\n        while(i>=0){\\n            \\n            if(t.empty()){\\n                t.push(s[i]);     \\n            }\\n            \\n            else if(t.top()==\\'a\\' && s[i]==\\'b\\'){\\n                c++;\\n                t.pop();         \\n            }\\n            \\n            else t.push(s[i]); \\n            i--;\\n        }    \\n\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511951,
                "title": "java-find-divide-point-solution-o-n-time-o-1-memory",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int aCount = 0;\\n        \\n\\t\\t// Count total number of a\\'s\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount++;\\n            }\\n        }\\n\\n        int bCount = 0;\\n        int min = aCount + bCount; // Base case when all numbers needs to be deleted\\n\\t\\t\\n\\t\\t// aCount = number of a\\'s on right, bCount = number of b\\'s at left\\n\\t\\t// at divide index `i`, there will be no a\\'s at index >= `i` and no b\\'s at index < `i`\\n\\t\\t// minimum number to be deleted = number of b\\'s deleted before divide index `i` + number of a\\'s deleted after divide index `i`\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount--; \\n            } else {\\n                bCount++;\\n            }\\n            \\n            min = Integer.min(aCount + bCount, min);\\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int aCount = 0;\\n        \\n\\t\\t// Count total number of a\\'s\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount++;\\n            }\\n        }\\n\\n        int bCount = 0;\\n        int min = aCount + bCount; // Base case when all numbers needs to be deleted\\n\\t\\t\\n\\t\\t// aCount = number of a\\'s on right, bCount = number of b\\'s at left\\n\\t\\t// at divide index `i`, there will be no a\\'s at index >= `i` and no b\\'s at index < `i`\\n\\t\\t// minimum number to be deleted = number of b\\'s deleted before divide index `i` + number of a\\'s deleted after divide index `i`\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount--; \\n            } else {\\n                bCount++;\\n            }\\n            \\n            min = Integer.min(aCount + bCount, min);\\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406992,
                "title": "3-different-python-easy-solution",
                "content": "# Using stack\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack = []\\n        count = 0\\n        \\n        for i in s:\\n            if stack and stack[-1] == \\'b\\' and i == \\'a\\':\\n                stack.pop()\\n                count += 1\\n            \\n            else:\\n                stack.append(i)\\n                \\n        return count\\n```\\n\\n        \\n\\n\\n# Using O(1) space, most optimal\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        ans = len(s) + 1\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                ans = min(ans, a_count + b_count)\\n                \\n            else:\\n                ans = min(ans, a_count + b_count)\\n                b_count += 1\\n                \\n        return ans\\n```\\n        \\n        \\n        \\n        \\n        \\n\\n# Using O(n) space\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = []\\n        b = []\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                a.append(a_count)\\n                b.append(b_count)\\n            \\n            else:\\n                a.append(a_count)\\n                b.append(b_count)\\n                b_count += 1\\n                \\n        ans = len(s) + 1\\n        \\n        for i in range(0,len(s)):\\n            ans = min(ans, a[i] + b[i])            \\n\\t\\t\\t\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack = []\\n        count = 0\\n        \\n        for i in s:\\n            if stack and stack[-1] == \\'b\\' and i == \\'a\\':\\n                stack.pop()\\n                count += 1\\n            \\n            else:\\n                stack.append(i)\\n                \\n        return count\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        ans = len(s) + 1\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                ans = min(ans, a_count + b_count)\\n                \\n            else:\\n                ans = min(ans, a_count + b_count)\\n                b_count += 1\\n                \\n        return ans\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = []\\n        b = []\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                a.append(a_count)\\n                b.append(b_count)\\n            \\n            else:\\n                a.append(a_count)\\n                b.append(b_count)\\n                b_count += 1\\n                \\n        ans = len(s) + 1\\n        \\n        for i in range(0,len(s)):\\n            ans = min(ans, a[i] + b[i])            \\n\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369807,
                "title": "easy-c-solution-o-n-time-with-explanation",
                "content": "Any time if we see an \\'a\\' we need to make a decision whether we: \\n- delete that \\'a\\'\\n- or delete all the previous \\'b\\'s\\n\\nwe calculate the deletion count for that \\'a\\' depending on which is least expensive - if the number of \\'b\\'s before this \\'a\\' is greater than the deletion count after deleting this \\'a\\' (i.e. +1 to the previous deletion count), then it makes sense NOT to delete all the previous \\'b\\'s because it would prove to be costlier than deleting this \\'a\\'.\\n\\nSimliarly, if the number of \\'b\\'s is lesser than the count of deletion after deleting this \\'a\\', we are better off deleting all the previous \\'b\\'s\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCountSoFar = 0, deleteCount = 0;\\n        for (char ch: s) {\\n//             at any point if we see \\'a\\', we either delete it or delete all previous \\'b\\'s depending on which is less expensive\\n            if (ch == \\'a\\') {\\n//                 if number of \\'b\\'s so far is greater, then delete this \\'a\\'\\n                if(bCountSoFar > deleteCount + 1)\\n                    deleteCount++;\\n//                 or else we delete the previous \\'b\\'s\\n                else deleteCount = bCountSoFar;\\n            }\\n            // keep counting the number of \\'b\\'s\\n            else if (ch == \\'b\\') ++bCountSoFar;\\n        }\\n        return deleteCount;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCountSoFar = 0, deleteCount = 0;\\n        for (char ch: s) {\\n//             at any point if we see \\'a\\', we either delete it or delete all previous \\'b\\'s depending on which is less expensive\\n            if (ch == \\'a\\') {\\n//                 if number of \\'b\\'s so far is greater, then delete this \\'a\\'\\n                if(bCountSoFar > deleteCount + 1)\\n                    deleteCount++;\\n//                 or else we delete the previous \\'b\\'s\\n                else deleteCount = bCountSoFar;\\n            }\\n            // keep counting the number of \\'b\\'s\\n            else if (ch == \\'b\\') ++bCountSoFar;\\n        }\\n        return deleteCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341776,
                "title": "c-pre-computed-arrays-basic-dp-explanation",
                "content": "Here I have pre-computed the two arrays \\'a\\' and \\'b\\' which hold the elements to be deleted.\\narray \\'a\\' : number of alphabets \\'a\\' to be deleted at index \\'i\\'.\\narray \\'b\\' : number of alphabets \\'b\\' to be deleted at index \\'i\\'.\\n\\n```\\nint minimumDeletions(string s) {\\n        vector<int>a(s.size(), 0), b(s.size(), 0);\\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            if(s[i] == \\'b\\')\\n                b[i] += i > 0 ? 1 + b[i - 1] : 1;\\n            else\\n                b[i] = (i > 0) ? b[i - 1] : 0;\\n            if(s[s.size() - 1 - i] == \\'a\\')\\n                a[s.size() - 1 - i] += (s.size() - 1 - i < s.size() - 1) ? 1 + a[s.size() - i] : 1;\\n            else\\n                a[s.size() - 1 - i] = (s.size() - 1 - i < s.size() - 1) ? a[s.size() - i] : 0;\\n        }\\n        int ans = min(a[0], b[s.size() - 1]);\\n        for(int i=0; i<s.size() - 1; ++i)\\n            ans = min(ans, b[i] + a[i + 1]);\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "Here I have pre-computed the two arrays \\'a\\' and \\'b\\' which hold the elements to be deleted.\\narray \\'a\\' : number of alphabets \\'a\\' to be deleted at index \\'i\\'.\\narray \\'b\\' : number of alphabets \\'b\\' to be deleted at index \\'i\\'.\\n\\n```\\nint minimumDeletions(string s) {\\n        vector<int>a(s.size(), 0), b(s.size(), 0);\\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            if(s[i] == \\'b\\')\\n                b[i] += i > 0 ? 1 + b[i - 1] : 1;\\n            else\\n                b[i] = (i > 0) ? b[i - 1] : 0;\\n            if(s[s.size() - 1 - i] == \\'a\\')\\n                a[s.size() - 1 - i] += (s.size() - 1 - i < s.size() - 1) ? 1 + a[s.size() - i] : 1;\\n            else\\n                a[s.size() - 1 - i] = (s.size() - 1 - i < s.size() - 1) ? a[s.size() - i] : 0;\\n        }\\n        int ans = min(a[0], b[s.size() - 1]);\\n        for(int i=0; i<s.size() - 1; ++i)\\n            ans = min(ans, b[i] + a[i + 1]);\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1272492,
                "title": "c-simple-and-clear-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int x=0, y=0;\\n        vector<int> dp(n+1,0);\\n        if(s[0]==\\'a\\')\\n            x++;\\n        else\\n            y++;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && y!=0)\\n            {\\n                dp[i] = min(dp[i-1]+1, min(y,x+1));\\n            }\\n            else\\n                dp[i] = dp[i-1];\\n            if(s[i]==\\'a\\')\\n                x++;\\n            else\\n                y++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int x=0, y=0;\\n        vector<int> dp(n+1,0);\\n        if(s[0]==\\'a\\')\\n            x++;\\n        else\\n            y++;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && y!=0)\\n            {\\n                dp[i] = min(dp[i-1]+1, min(y,x+1));\\n            }\\n            else\\n                dp[i] = dp[i-1];\\n            if(s[i]==\\'a\\')\\n                x++;\\n            else\\n                y++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168221,
                "title": "cpp-dp-change-the-view-of-the-problem",
                "content": "You can change the view of the problem.\\nThe intent of the original problem is to find the minimum.\\nYou can find the maximum subsequence of the original string.\\nThe subsequence is like ->   a\\\\*b\\\\* , and then subtract the length of the subsequence from the original length.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int last_a = -1;\\n        int last_b = -1;\\n    \\n        int len = s.size();\\n        int max_len[len];\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (s[i] == \\'a\\') {\\n                if (last_a == -1) {\\n                    last_a = i;\\n                    max_len[i] = 1;\\n                } else {\\n                    max_len[i] = max_len[last_a] + 1;\\n                    last_a = i;\\n                }\\n            }\\n            \\n            if (s[i] == \\'b\\') {\\n                if (last_b == -1) {\\n                    last_b = i;\\n                    if (last_a == -1)\\n                        max_len[i] = 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a] + 1,1);\\n                } else {\\n                    if (last_a == -1)\\n                        max_len[i] = max_len[last_b] + 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a], max_len[last_b]) + 1;\\n                    last_b = i;\\n                }\\n            }\\n        }\\n        \\n        int maxmm = -1;\\n        for (int i = 0; i < len; i++)\\n            maxmm = max(maxmm, max_len[i]);\\n        \\n        return len - maxmm;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int last_a = -1;\\n        int last_b = -1;\\n    \\n        int len = s.size();\\n        int max_len[len];\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (s[i] == \\'a\\') {\\n                if (last_a == -1) {\\n                    last_a = i;\\n                    max_len[i] = 1;\\n                } else {\\n                    max_len[i] = max_len[last_a] + 1;\\n                    last_a = i;\\n                }\\n            }\\n            \\n            if (s[i] == \\'b\\') {\\n                if (last_b == -1) {\\n                    last_b = i;\\n                    if (last_a == -1)\\n                        max_len[i] = 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a] + 1,1);\\n                } else {\\n                    if (last_a == -1)\\n                        max_len[i] = max_len[last_b] + 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a], max_len[last_b]) + 1;\\n                    last_b = i;\\n                }\\n            }\\n        }\\n        \\n        int maxmm = -1;\\n        for (int i = 0; i < len; i++)\\n            maxmm = max(maxmm, max_len[i]);\\n        \\n        return len - maxmm;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163332,
                "title": "javascript-3-unique-solutions-stack-dp",
                "content": "Time: `O(N)`\\nSpace: `O(N)`\\n## Solution 1: Stack\\n```javascript\\nvar minimumDeletions = function(s) {\\n    const stack = [];\\n    let count = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        if(stack.length && stack[stack.length-1] > s[i]) {\\n            count++;\\n            stack.pop();\\n        } else {\\n            stack.push(s[i]);\\n        }\\n    }\\n    return count;\\n};\\n```\\n## Solution 2: DP\\n```javascript\\nvar minimumDeletions = function(s) {\\n    const dp = [0];\\n    let bCount = 0;\\n    \\n    if(s[0] == \\'b\\') bCount++;\\n    \\n    for(let i = 1; i < s.length; i++) {\\n        if(s[i] === \\'a\\') {\\n            dp[i] = Math.min(dp[i-1] + 1, bCount);\\n        } else {\\n            dp[i] = dp[i-1];\\n            bCount++\\n        }\\n    }\\n    return dp[s.length-1];\\n};\\n```\\n## Solution 3\\n```\\nvar minimumDeletions = function(s) {\\n    const aList = [], bList = [];\\n    let countA = 0, countB = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let j = s.length - 1 - i; // going backwards\\n        if(s[i] === \\'b\\') countB++;\\n        if(s[j] === \\'a\\') countA++;\\n        bList[i] = countB;\\n        aList[j] = countA;\\n    }\\n    \\n    function deleteCount(idx, til) {\\n        if(idx >= s.length-1) return 0;\\n        \\n        if(s[idx] === \\'b\\' && s[idx+1] === \\'a\\') {\\n            const deleteA = aList[idx];\\n            const deleteB = deleteCount(idx+2, idx) + bList[idx] - (bList[til] || 0);\\n            return Math.min(deleteA, deleteB);\\n        }\\n        return deleteCount(idx+1, til);\\n    }\\n    return deleteCount(0, -1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```javascript\\nvar minimumDeletions = function(s) {\\n    const stack = [];\\n    let count = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        if(stack.length && stack[stack.length-1] > s[i]) {\\n            count++;\\n            stack.pop();\\n        } else {\\n            stack.push(s[i]);\\n        }\\n    }\\n    return count;\\n};\\n```\n```javascript\\nvar minimumDeletions = function(s) {\\n    const dp = [0];\\n    let bCount = 0;\\n    \\n    if(s[0] == \\'b\\') bCount++;\\n    \\n    for(let i = 1; i < s.length; i++) {\\n        if(s[i] === \\'a\\') {\\n            dp[i] = Math.min(dp[i-1] + 1, bCount);\\n        } else {\\n            dp[i] = dp[i-1];\\n            bCount++\\n        }\\n    }\\n    return dp[s.length-1];\\n};\\n```\n```\\nvar minimumDeletions = function(s) {\\n    const aList = [], bList = [];\\n    let countA = 0, countB = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let j = s.length - 1 - i; // going backwards\\n        if(s[i] === \\'b\\') countB++;\\n        if(s[j] === \\'a\\') countA++;\\n        bList[i] = countB;\\n        aList[j] = countA;\\n    }\\n    \\n    function deleteCount(idx, til) {\\n        if(idx >= s.length-1) return 0;\\n        \\n        if(s[idx] === \\'b\\' && s[idx+1] === \\'a\\') {\\n            const deleteA = aList[idx];\\n            const deleteB = deleteCount(idx+2, idx) + bList[idx] - (bList[til] || 0);\\n            return Math.min(deleteA, deleteB);\\n        }\\n        return deleteCount(idx+1, til);\\n    }\\n    return deleteCount(0, -1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1133563,
                "title": "c-3-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int lasta = 0, lastb = 0;\\n        for(char i:s){\\n            if(i == \\'a\\') lastb++;\\n            else lastb=min(lasta++,lastb);\\n        }\\n        return min(lasta,lastb);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int lasta = 0, lastb = 0;\\n        for(char i:s){\\n            if(i == \\'a\\') lastb++;\\n            else lastb=min(lasta++,lastb);\\n        }\\n        return min(lasta,lastb);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937912,
                "title": "c-prefix-sum-with-explanation-and-example",
                "content": "A balance string is simply a lexical sorted string (all the `a` appear at left, `b` at right).\\nThe idea is to find the rightmost `a` in the longest balanced string.\\n\\ne.g. `s = \"aababbab\"`\\n\\nif choosing the `a` in index 6 as the last `a`, I will have to delete all the `b` at its left, and all the `a` at its right.\\n```\\n\"aababbab\"\\n       ^\\n\"aaxaxxxb\"\\n```\\nHowever, if I choose the `a` in index 3, I only have to delete `b` in index 2, `a` in index 6.\\n```\\n\"aababbab\"\\n    ^\\n\"aaxabbxb\"\\n```\\nBy observation, I have to use some way to efficiently get the number of `b`s on a given `a`\\'s left, and the number of `a`s on it\\'s right.\\n\\nThe way to achieve that is to use prefix sum:\\n```\\ns        = \"aababbab\"\\nas       = 432211100\\nbs       = 000112334\\n-----------------------\\ndeletion =  32323434\\n```\\nYou can see that the minimum deletion occurs when you choose `a` at index 1 and 3, which yields the answer `2`.\\n\\nNote: for handling cases that does not contain `a`, I add a dummy `a` infront of the original string. (that does not affect the answer since it is already at it\\'s right place)\\n```\\nint minimumDeletions(string s) {\\n    s = \\'a\\' + s;\\n    vector<int> as(s.size()+1);\\n    vector<int> bs(s.size()+1);\\n    int n = s.size();\\n\\n    for (int i = 0; i < s.size(); i++) {\\n      as[n-i-1] = as[n-i] + (s[n-i-1] == \\'a\\');\\n      bs[i+1] = bs[i] + (s[i] == \\'b\\');\\n    }\\n    \\n    int ans = n;\\n    for (int i = 0; i < s.size(); i++) {\\n      if (s[i] == \\'a\\') {\\n        ans = min(ans, as[i+1] + bs[i]);\\n      }\\n    }\\n    \\n    return ans;\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\n\"aababbab\"\\n       ^\\n\"aaxaxxxb\"\\n```\n```\\n\"aababbab\"\\n    ^\\n\"aaxabbxb\"\\n```\n```\\ns        = \"aababbab\"\\nas       = 432211100\\nbs       = 000112334\\n-----------------------\\ndeletion =  32323434\\n```\n```\\nint minimumDeletions(string s) {\\n    s = \\'a\\' + s;\\n    vector<int> as(s.size()+1);\\n    vector<int> bs(s.size()+1);\\n    int n = s.size();\\n\\n    for (int i = 0; i < s.size(); i++) {\\n      as[n-i-1] = as[n-i] + (s[n-i-1] == \\'a\\');\\n      bs[i+1] = bs[i] + (s[i] == \\'b\\');\\n    }\\n    \\n    int ans = n;\\n    for (int i = 0; i < s.size(); i++) {\\n      if (s[i] == \\'a\\') {\\n        ans = min(ans, as[i+1] + bs[i]);\\n      }\\n    }\\n    \\n    return ans;\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 935739,
                "title": "python-solution",
                "content": "Initialize `res = [0] * len(s)`, and let `res[i]` be the solution of the problem for `s[:i + 1]`, i.e., `res[i]` is the number of minimum deletions to make `s[:i+1]` balanced. It\\'s easy to see that `res[0] = 0`, because a single character is always balanced. Then we loop `i` over `range(1, len(s))`, we know that if `s[i] == \\'b\\'`, then `res[i] = res[i - 1]`, because a trailing `\\'b\\'` appending to a balanced string will always be balanced. Hence the minimum deletion that makes `s[:i]` balanced will also make `s[:i+1]` balanced; Otherwise if `s[i] == \\'a\\'`, then `res[i] = min(res[i - 1] + 1, count_b)`, where `count_b` is the number of `\\'b\\'`s in `s[:i]`, this is because to make `s[:i+1]` balanced, we have two options -- either delete the last `a`, in which case the minimum deletion to make `s[:i+1]` balanced is `res[i - 1] + 1`, or delete all the `b`s in `s[:i]`, in  which case the minimum deletion to make `s[:i+1]` balanced is `count_b`. The overall minimum is then `res[i] = min(res[i - 1] + 1, count_b)`. Finally, we return `res[-1]` to be the solution of the problem.\\n\\nTime complexity: O(n), space complexity: O(n).\\n\\nSpace complexity can be further reduced to O(1), because we don\\'t really need the array `res`, we only need to save the minimum deletions for the previous iteration.\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        res = [0] * n\\n        count_b = 0\\n        if s[0] == \\'b\\':\\n            count_b = 1\\n        for i in range(1, n):\\n            if s[i] == \\'a\\':\\n                res[i] = min(1 + res[i - 1], count_b)\\n            else:\\n                count_b += 1\\n                res[i] = res[i - 1]\\n        return res[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        res = [0] * n\\n        count_b = 0\\n        if s[0] == \\'b\\':\\n            count_b = 1\\n        for i in range(1, n):\\n            if s[i] == \\'a\\':\\n                res[i] = min(1 + res[i - 1], count_b)\\n            else:\\n                count_b += 1\\n                res[i] = res[i - 1]\\n        return res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935455,
                "title": "java-easy-stack-solution",
                "content": "We iterate through the string and greedily adjust to make sure there are no (a)\\'s after any (b)\\'s. If we do, we remove the (b) and add to our min counter.\\n```\\n    public int minimumDeletions(String s) {\\n        Stack<Character> st = new Stack<>();\\n        int min = 0;\\n        \\n        for (char c : s.toCharArray()) {\\n            if (!st.isEmpty() && st.peek() > c) {\\n                st.pop();\\n                min++;\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        \\n        return min;\\n    }",
                "solutionTags": [],
                "code": "We iterate through the string and greedily adjust to make sure there are no (a)\\'s after any (b)\\'s. If we do, we remove the (b) and add to our min counter.\\n```\\n    public int minimumDeletions(String s) {\\n        Stack<Character> st = new Stack<>();\\n        int min = 0;\\n        \\n        for (char c : s.toCharArray()) {\\n            if (!st.isEmpty() && st.peek() > c) {\\n                st.pop();\\n                min++;\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        \\n        return min;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 935406,
                "title": "c-dp-o-n-easy-to-understand",
                "content": "Algorithm:\\n\\t1. Use DP to record the number of a and b.\\n\\t2. Find the suitable index(How to is in Implementation).\\n\\t3. Erase all \"b\"\\'s left to the index.\\n\\t4. Erase all \"a\"\\'s right to the index.\\n\\nImplementation:\\n\\t1.dp_a records frequency of \"a\" from right to left\\n\\t2.dp_b records frequency of \"b\" from left to right\\n\\t3.sum up dp_a and dp_b and find the smallest value substracted by 1\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp_a(s.size(),0);\\n        vector<int>dp_b(s.size(),0);\\n\\t\\t//record b\\n        for(int i = 0 ; i < s.size();++i){\\n            if(i==0&&s[i]==\\'b\\')\\n                dp_b[i]=1;\\n            else if(i==0&&s[i]==\\'a\\')\\n                dp_b[i]=0;\\n            else if(s[i]==\\'b\\')\\n                dp_b[i] = dp_b[i-1]+1;\\n            else\\n                dp_b[i]=dp_b[i-1];\\n        }\\n\\t\\t//record a\\n        for(int i = s.size()-1 ;i>=0;--i){\\n            if(i==s.size()-1&&s[i]==\\'a\\')\\n                dp_a[i]=1;\\n            else if(i==s.size()-1&&s[i]==\\'b\\')\\n                dp_a[i]=0;\\n            else if(s[i]==\\'a\\')\\n                dp_a[i] = dp_a[i+1]+1;\\n            else\\n                dp_a[i] = dp_a[i+1];\\n        }\\n\\t\\t//sum up dp_a and dp_b and find the smallest one\\n        int res=INT_MAX;\\n        for(int i = 0 ; i < s.size() ;++i){\\n            res=min(dp_b[i]+dp_a[i],res);\\n        }\\n        return res-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp_a(s.size(),0);\\n        vector<int>dp_b(s.size(),0);\\n\\t\\t//record b\\n        for(int i = 0 ; i < s.size();++i){\\n            if(i==0&&s[i]==\\'b\\')\\n                dp_b[i]=1;\\n            else if(i==0&&s[i]==\\'a\\')\\n                dp_b[i]=0;\\n            else if(s[i]==\\'b\\')\\n                dp_b[i] = dp_b[i-1]+1;\\n            else\\n                dp_b[i]=dp_b[i-1];\\n        }\\n\\t\\t//record a\\n        for(int i = s.size()-1 ;i>=0;--i){\\n            if(i==s.size()-1&&s[i]==\\'a\\')\\n                dp_a[i]=1;\\n            else if(i==s.size()-1&&s[i]==\\'b\\')\\n                dp_a[i]=0;\\n            else if(s[i]==\\'a\\')\\n                dp_a[i] = dp_a[i+1]+1;\\n            else\\n                dp_a[i] = dp_a[i+1];\\n        }\\n\\t\\t//sum up dp_a and dp_b and find the smallest one\\n        int res=INT_MAX;\\n        for(int i = 0 ; i < s.size() ;++i){\\n            res=min(dp_b[i]+dp_a[i],res);\\n        }\\n        return res-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935377,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        l, r = 0, n - 1\\n        c = Counter(s)\\n        res = 0\\n        while l < r:\\n            if s[r] == \\'b\\':\\n                r -= 1\\n                c[\\'b\\'] -= 1\\n                continue\\n            elif s[l] == \\'a\\':\\n                l += 1\\n                c[\\'a\\'] -= 1\\n                continue\\n            else: # b - a\\n                if c[\\'a\\'] <= c[\\'b\\']:\\n                    c[\\'a\\'] -= 1\\n                    res += 1\\n                    r -= 1\\n                else:\\n                    c[\\'b\\'] -= 1\\n                    res += 1\\n                    l += 1\\n        return res\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        l, r = 0, n - 1\\n        c = Counter(s)\\n        res = 0\\n        while l < r:\\n            if s[r] == \\'b\\':\\n                r -= 1\\n                c[\\'b\\'] -= 1\\n                continue\\n            elif s[l] == \\'a\\':\\n                l += 1\\n                c[\\'a\\'] -= 1\\n                continue\\n            else: # b - a\\n                if c[\\'a\\'] <= c[\\'b\\']:\\n                    c[\\'a\\'] -= 1\\n                    res += 1\\n                    r -= 1\\n                else:\\n                    c[\\'b\\'] -= 1\\n                    res += 1\\n                    l += 1\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 4030220,
                "title": "c-without-dp-lis-prefix-suffix-o-n-tc-o-1-sc",
                "content": "# Intuition\\nAs also mentioned in Hint , we need to find for every index the number of Bs before it and the number of A\\'s after it and the minimum one will be our answer .\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int cnta = 0, cntb = 0, ans = 1e5;\\n        for(auto i : s) cnta += i == \\'a\\';\\n        \\n        // Delete all the a\\'s that could be possible ans \\n        ans = cnta;\\n\\n        for(int i = 0 ; i<s.length() ; i++){\\n            cntb += s[i] == \\'b\\';\\n            cnta -= s[i] == \\'a\\';\\n\\n            ans = min(ans, cntb+cnta);\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int cnta = 0, cntb = 0, ans = 1e5;\\n        for(auto i : s) cnta += i == \\'a\\';\\n        \\n        // Delete all the a\\'s that could be possible ans \\n        ans = cnta;\\n\\n        for(int i = 0 ; i<s.length() ; i++){\\n            cntb += s[i] == \\'b\\';\\n            cnta -= s[i] == \\'a\\';\\n\\n            ans = min(ans, cntb+cnta);\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877461,
                "title": "lis-binary-search-tc-o-nlogn-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlength of LIS using binary search.\\n`Result = size of string - lengthOfLIS`\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(const char& ch : s) {\\n            if(ch == \\'a\\') nums.push_back(0);\\n            else nums.push_back(1);\\n        }\\n\\n        return s.size() - lengthOfLIS(nums);\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> lis;\\n        lis.push_back(nums[0]);\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i] >= lis.back())\\n                lis.push_back(nums[i]);\\n            else{\\n                int idx = findCeil(lis, 0, lis.size(), nums[i]);\\n                lis[idx] = nums[i];\\n            }\\n        }\\n        \\n        return lis.size();\\n    }\\n    \\n    int findCeil(vector<int> &lis, int l, int r, int x){\\n        while(l<r){\\n            int m = l + (r-l)/2;\\n            if(lis[m] > x)\\n                r = m;\\n            else\\n                l = m+1;\\n        }\\n        \\n        return r;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(const char& ch : s) {\\n            if(ch == \\'a\\') nums.push_back(0);\\n            else nums.push_back(1);\\n        }\\n\\n        return s.size() - lengthOfLIS(nums);\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> lis;\\n        lis.push_back(nums[0]);\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i] >= lis.back())\\n                lis.push_back(nums[i]);\\n            else{\\n                int idx = findCeil(lis, 0, lis.size(), nums[i]);\\n                lis[idx] = nums[i];\\n            }\\n        }\\n        \\n        return lis.size();\\n    }\\n    \\n    int findCeil(vector<int> &lis, int l, int r, int x){\\n        while(l<r){\\n            int m = l + (r-l)/2;\\n            if(lis[m] > x)\\n                r = m;\\n            else\\n                l = m+1;\\n        }\\n        \\n        return r;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824477,
                "title": "very-easy-stack-solution-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ans = 0;\\n\\n        stack<char> st;\\n\\n        for(int i=0;i<s.size();i++){\\n\\n            if(s[i]==\\'a\\'){\\n            if(!st.empty()){\\n                char top = st.top();\\n                if(top==\\'b\\') ans++;\\n                st.pop();\\n                }\\n            }\\n            else{\\n                st.push(\\'b\\');\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ans = 0;\\n\\n        stack<char> st;\\n\\n        for(int i=0;i<s.size();i++){\\n\\n            if(s[i]==\\'a\\'){\\n            if(!st.empty()){\\n                char top = st.top();\\n                if(top==\\'b\\') ans++;\\n                st.pop();\\n                }\\n            }\\n            else{\\n                st.push(\\'b\\');\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760035,
                "title": "simple-python-solution-using-dynamic-programming",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` python3 []\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_cnt = s.count(\\'a\\')\\n        result = a_cnt\\n        left_b = 0\\n        right_a = a_cnt\\n\\n        for char in s:\\n            if char == \\'a\\':\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n            result = min(result, right_a + left_b)\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "``` python3 []\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_cnt = s.count(\\'a\\')\\n        result = a_cnt\\n        left_b = 0\\n        right_a = a_cnt\\n\\n        for char in s:\\n            if char == \\'a\\':\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n            result = min(result, right_a + left_b)\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203527,
                "title": "python-idea-of-moving-partition-with-detailed-explanation-easy-understanding",
                "content": "# Intuition\\nWe need to find a partition such that if we remove the number of \"b\" to the left of that partition and remove the number of \"a\" on the right of that partition we get a balanced string. Details and example is shown below.\\n\\nWe would then check if the number of deletions with that particular partition and checck if this is a candidate for the minimum number of deletions. \\n\\n# Approach\\nWe can visualize the partition as following:-\\n\\nGiven s = \"aababbab\"\\n\\n`Partition at index 0: \" | aababbab \"` -> To make this balanced remove all b\\'s on left of the partition and remove all a\\'s on the right. So with this partition we would convert the string into \"bbbb\" since we would have to remove all a\\'s to the right(no b\\'s on the left of the partition)\\n\\n`Partition at index 1: \" a | ababbab \"` -> Following the above logic we try to convert it to a balanced string \"abbbb\" and check if the resultant string is a candidate for the answer by comparing to the current answer.\\n\\n`Partition at index 2: \" aa | babbab \"` -> possible balanced string is \"aabbbb\". So total 2 deletions of a\\'s on the right\\n\\n`Partition at index 3: \"aab | abbab\"` -> \"aabbb\"\\n`Partition at index 4: \" aaba | bbab \"` -> \"aaabbb\"\\n`Partition at index 5: \" aabab | bab \"` -> \"aaabb\"\\n`Partition at index 6: \" aababb | ab \"` -> \"aaab\"\\n`Partition at index 7: \" aababba | b \"` -> \"aaaab\"\\n`Partition at index 8: \" aababbab | \"` -> \"aaaa\"\\n\\n**Implementation :-**\\nMaintain variables to keep the count of a\\'s on left and right of partition and the number of b\\'s on the left and right. \\n\\nI have named them as `left_a, left_b, right_a, right_b`. Just add or subtract them as we move the partition. \\n\\nRather than explicitly moving a \"partition\" from LEFT to RIGHT, I am adding the characters into the LEFT-HALF of the partition as the implementation becomes easy that way. \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        C = Counter(s)\\n        left_a, left_b = 0, 0\\n        right_a, right_b = C[\"a\"], C[\"b\"]\\n\\n        deletions = right_a\\n        for char in s:\\n            if char == \"a\":\\n                right_a -= 1\\n                left_a += 1\\n            else:\\n                left_b += 1\\n                right_b -= 1\\n            deletions = min(deletions, left_b + right_a)\\n        \\n        return deletions\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        C = Counter(s)\\n        left_a, left_b = 0, 0\\n        right_a, right_b = C[\"a\"], C[\"b\"]\\n\\n        deletions = right_a\\n        for char in s:\\n            if char == \"a\":\\n                right_a -= 1\\n                left_a += 1\\n            else:\\n                left_b += 1\\n                right_b -= 1\\n            deletions = min(deletions, left_b + right_a)\\n        \\n        return deletions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086296,
                "title": "python-stack-approach",
                "content": "It is given that the string can be balanced, only if there are no pairs like -> \"ba\" in the string. \\n\\nAnd that\\'s the only thing which will make the string invalid. Hence, what we can do is, whenever we come across a situation where the previous character was a \"b\" but the current character is an \"a\", we know we have to make one deletion here. \\n\\nSo, we can simply use a stack to keep track of all the previous \"b\" and whenever we come across an \"a\", we can then check whether we have a \"b\" in the stack. If yes, it means, one deletion has to be made.\\n\\n```\\ndef minimumDeletions(self, s: str) -> int:\\n        # Since we want to ensure that the string is balanced in such as way that\\n        # There is no \"a\" after \"b\" in the final string\\n        # It means, whenever we come across something like \"ba\", we know we have to make one deletion\\n        deletions = 0\\n        \\n        # We will use this stack to put the \"b\" in it whenever we come across one\\n        # In short, this stack is only to keep track of previous \"b\"\\n        stack = []\\n        \\n        # Go through each character of the string\\n        for c in s:\\n            # If this is an \"a\"\\n            if c == \"a\":\\n                # Then, if the stack is not empty\\n                # It means, there was a \"b\" before it\\n                # So we need to make a deletion here\\n                if stack:\\n                    stack.pop()\\n                    deletions += 1\\n            # If it is a \"b\", just push it to the stack\\n            else: stack.append(c)\\n                \\n        return deletion\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef minimumDeletions(self, s: str) -> int:\\n        # Since we want to ensure that the string is balanced in such as way that\\n        # There is no \"a\" after \"b\" in the final string\\n        # It means, whenever we come across something like \"ba\", we know we have to make one deletion\\n        deletions = 0\\n        \\n        # We will use this stack to put the \"b\" in it whenever we come across one\\n        # In short, this stack is only to keep track of previous \"b\"\\n        stack = []\\n        \\n        # Go through each character of the string\\n        for c in s:\\n            # If this is an \"a\"\\n            if c == \"a\":\\n                # Then, if the stack is not empty\\n                # It means, there was a \"b\" before it\\n                # So we need to make a deletion here\\n                if stack:\\n                    stack.pop()\\n                    deletions += 1\\n            # If it is a \"b\", just push it to the stack\\n            else: stack.append(c)\\n                \\n        return deletion\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2793615,
                "title": "python-98-beats-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\n        l=len(s)\\n        i=0\\n        while i<l and s[i]!=\\'b\\':\\n            i+=1\\n        j=l-1\\n        while j>=0 and s[j]!=\\'a\\':\\n            j-=1\\n        if i==l or j==-1:\\n            return 0\\n        \\n        ca=0\\n        cb=0\\n        ans=0\\n        for k in range(i,j+1):\\n            if s[k]==\\'a\\':\\n                if cb>0: \\n                    if ca>=cb:\\n                        ans+=cb\\n                        ca=0\\n                        cb=0\\n                    else:\\n                        ca+=1\\n            else:\\n                cb+=1\\n        ans+=min(ca,cb)\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\n        l=len(s)\\n        i=0\\n        while i<l and s[i]!=\\'b\\':\\n            i+=1\\n        j=l-1\\n        while j>=0 and s[j]!=\\'a\\':\\n            j-=1\\n        if i==l or j==-1:\\n            return 0\\n        \\n        ca=0\\n        cb=0\\n        ans=0\\n        for k in range(i,j+1):\\n            if s[k]==\\'a\\':\\n                if cb>0: \\n                    if ca>=cb:\\n                        ans+=cb\\n                        ca=0\\n                        cb=0\\n                    else:\\n                        ca+=1\\n            else:\\n                cb+=1\\n        ans+=min(ca,cb)\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633113,
                "title": "c-using-prefix-and-suffix-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int l[n];//number of b\\'s from left\\n        int r[n];//number of a\\'s from right\\n        l[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            l[i]=l[i-1];\\n            l[i]+=(s[i-1]==\\'b\\')? 1:0;\\n        }\\n        r[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            r[i]=r[i+1];\\n            r[i]+=(s[i+1]==\\'a\\')? 1:0;\\n        }\\n        int ans=INT_MAX;\\n        //for(int i=0;i<n;i++){cout<<r[i]<<\" \";}\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,l[i]+r[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int l[n];//number of b\\'s from left\\n        int r[n];//number of a\\'s from right\\n        l[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            l[i]=l[i-1];\\n            l[i]+=(s[i-1]==\\'b\\')? 1:0;\\n        }\\n        r[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            r[i]=r[i+1];\\n            r[i]+=(s[i+1]==\\'a\\')? 1:0;\\n        }\\n        int ans=INT_MAX;\\n        //for(int i=0;i<n;i++){cout<<r[i]<<\" \";}\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,l[i]+r[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2568565,
                "title": "python-solution",
                "content": "use b to count current number of \"b\", use res to keep tracking current solution, res[0] is min deletions needed if keeping current \"a\", res[1] is min deletions needed if not keeping current \"a\".\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, res = 0, [0, 0]\\n        for c in s:\\n            if c == \"a\":\\n                res = [b, min(res) + 1]\\n            else:\\n                b += 1\\n        return min(res)\\n```\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, a = 0, s.count(\"a\")\\n        res = a\\n        for c in s:\\n            if c == \"a\":\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, res = 0, [0, 0]\\n        for c in s:\\n            if c == \"a\":\\n                res = [b, min(res) + 1]\\n            else:\\n                b += 1\\n        return min(res)\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, a = 0, s.count(\"a\")\\n        res = a\\n        for c in s:\\n            if c == \"a\":\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524041,
                "title": "monotonic-string-solution",
                "content": "MInimum number of deletions =Minimum flip required to convert into montonic string\\n\\t\\t   \\n\\t\\t   int count_b=0;\\n        int flip=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                count_b++;\\n            else\\n                flip++;\\n            \\n            flip=min(count_b,flip);\\n        }\\n        \\n        return flip;\\n    }",
                "solutionTags": [],
                "code": "MInimum number of deletions =Minimum flip required to convert into montonic string\\n\\t\\t   \\n\\t\\t   int count_b=0;\\n        int flip=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                count_b++;\\n            else\\n                flip++;\\n            \\n            flip=min(count_b,flip);\\n        }\\n        \\n        return flip;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2520410,
                "title": "c-o-n-tc-space-complexity-o-1",
                "content": "* Iterate from last index to \\'0\\'.\\n* Keep the count of \\'a\\'\\n* If \\'b\\' encounters decrease count_of_a and increase your ans by 1\\n\\n\\n\\nclass Solution {\\npublic:\\n    int find_collision(string &s){\\n         int n = s.size();\\n        \\n        \\n        int ct_a=0;    // counter for \\'a\\'\\n        int ans=0;     // our answer\\n        \\n        for(int i = n-1 ; i>=0; --i){\\n            if(s[i]==\\'a\\')ct_a++;\\n            else if(s[i]==\\'b\\' && ct_a>0){\\n                ++ans; \\n                --ct_a;\\n            }\\n        }\\n        \\n        return ans;\\n      \\n    }\\n    \\n    \\n    \\n   int minimumDeletions(string s) {\\n      return find_collision(s);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int find_collision(string &s){\\n         int n = s.size();\\n        \\n        \\n        int ct_a=0;    // counter for \\'a\\'\\n        int ans=0;     // our answer\\n        \\n        for(int i = n-1 ; i>=0; --i){\\n            if(s[i]==\\'a\\')ct_a++;\\n            else if(s[i]==\\'b\\' && ct_a>0){\\n                ++ans; \\n                --ct_a;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2405583,
                "title": "partition-at-every-index-very-simple-c-solution",
                "content": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n\\n// get the number of characters that can be included in balanced string \\n\\n// keeping count for the number of a\\'s on left side\\n// traverse the string , making partition around every index \\n\\n\\nint minimumDeletions(string s) {    \\n    int n = s.size();\\n    int maxi = 0;\\n    int a_left = 0, b_right = 0;\\n\\n    for(char ch : s) {\\n        if(ch == \\'b\\') b_right++;\\n    }\\n\\n    for(int i = 0; i < n; i++) {\\n        if(s[i] == \\'a\\') {\\n            a_left++;\\n            maxi = max(maxi, a_left + b_right);\\n        }\\n        else  {\\n            // maxi = max(maxi, a_left + b_right);\\n            b_right--;\\n        }\\n    }\\n\\n    return n - maxi;\\n}\\n\\n\\nint main() {   \\n    string s = \"babaabbba\";\\n    cout<<minimumDeletions(s)<<endl;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n\\n// get the number of characters that can be included in balanced string \\n\\n// keeping count for the number of a\\'s on left side\\n// traverse the string , making partition around every index \\n\\n\\nint minimumDeletions(string s) {    \\n    int n = s.size();\\n    int maxi = 0;\\n    int a_left = 0, b_right = 0;\\n\\n    for(char ch : s) {\\n        if(ch == \\'b\\') b_right++;\\n    }\\n\\n    for(int i = 0; i < n; i++) {\\n        if(s[i] == \\'a\\') {\\n            a_left++;\\n            maxi = max(maxi, a_left + b_right);\\n        }\\n        else  {\\n            // maxi = max(maxi, a_left + b_right);\\n            b_right--;\\n        }\\n    }\\n\\n    return n - maxi;\\n}\\n\\n\\nint main() {   \\n    string s = \"babaabbba\";\\n    cout<<minimumDeletions(s)<<endl;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2383148,
                "title": "no-dp-simple-programming-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int n=s.size();\\n        \\n        int sol = INT_MAX;  int a=0, b=0, c1=0, c2=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'a\\') c1++;  else c2++;\\n        }\\n        if(c1==0 || c2==0) return 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            sol = min(sol, (b + (c1-a)));\\n            if(s[i]==\\'a\\') a++;  else b++;\\n        }\\n        sol = min(sol, (b + (c1-a)));\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int n=s.size();\\n        \\n        int sol = INT_MAX;  int a=0, b=0, c1=0, c2=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'a\\') c1++;  else c2++;\\n        }\\n        if(c1==0 || c2==0) return 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            sol = min(sol, (b + (c1-a)));\\n            if(s[i]==\\'a\\') a++;  else b++;\\n        }\\n        sol = min(sol, (b + (c1-a)));\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271337,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n        int cntl = 0, cntr = 0;\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'b\\'){\\n                cntl++;\\n            }\\n            left[i] = cntl;\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i]==\\'a\\'){\\n                cntr++;\\n            }\\n            right[i] = cntr;\\n        }\\n        int res = min(right[0],left[n-1]);\\n        for(int i=0; i<n-1; i++){\\n            res = min(res,left[i]+right[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n        int cntl = 0, cntr = 0;\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'b\\'){\\n                cntl++;\\n            }\\n            left[i] = cntl;\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i]==\\'a\\'){\\n                cntr++;\\n            }\\n            right[i] = cntr;\\n        }\\n        int res = min(right[0],left[n-1]);\\n        for(int i=0; i<n-1; i++){\\n            res = min(res,left[i]+right[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271324,
                "title": "70-tc-and-78-sc-easy-python-solution",
                "content": "```\\ndef minimumDeletions(self, s: str) -> int:\\n\\tstart = [0]\\n\\tlast = [0]\\n\\tfor i in s:\\n\\t\\tstart.append(start[-1] + int(i==\"b\"))\\n\\tfor i in s[::-1]:\\n\\t\\tlast.append(last[-1] + int(i==\"a\"))\\n\\tans = 10000000000\\n\\tfor i in range(len(start)):\\n\\t\\tans = min(ans, start[i] + last[-i-1])\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef minimumDeletions(self, s: str) -> int:\\n\\tstart = [0]\\n\\tlast = [0]\\n\\tfor i in s:\\n\\t\\tstart.append(start[-1] + int(i==\"b\"))\\n\\tfor i in s[::-1]:\\n\\t\\tlast.append(last[-1] + int(i==\"a\"))\\n\\tans = 10000000000\\n\\tfor i in range(len(start)):\\n\\t\\tans = min(ans, start[i] + last[-i-1])\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2254688,
                "title": "c-o-n-clean-code-two-approach",
                "content": "### **Approach 1: Without Stack**\\n\\nclass Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n\\t// we are initializing ans with a, to consider the case where we want to delete all occurances of a.\\n        int a = count(s.begin(), s.end(), \\'a\\'), b = 0, ans = a;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            a -= s[i] == \\'a\\';\\n            b += s[i] == \\'b\\';\\n            \\n            ans = min(ans, b + a);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n**Time: O(N), Space: O(1).**\\n\\n### **Approach 2: Using Stack**\\n\\nclass Solution {\\npublic:\\n\\n\\tint minimumDeletions(string s) {\\n    int n=s.length();\\n    stack<char> stk;\\n    int c=0;\\n    for(int i=0;i<n;i++) {\\n        if (!stk.empty() && stk.top()==\\'b\\' && s[i]==\\'a\\')\\n\\t\\t\\t\\tstk.pop(),c++;\\n\\t\\t\\telse stk.push(s[i]);\\n\\t\\t}\\n\\t\\treturn c;\\n\\t}\\n};\\n\\n**Time: O(N), Space: O(N);**\\n\\nNote: Dry run for better understanding.\\nComment below for doubt or query.\\n**PLEASE UPVOTE IF HELPFUL!!!**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n\\t// we are initializing ans with a, to consider the case where we want to delete all occurances of a.\\n        int a = count(s.begin(), s.end(), \\'a\\'), b = 0, ans = a;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            a -= s[i] == \\'a\\';\\n            b += s[i] == \\'b\\';\\n            \\n            ans = min(ans, b + a);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2209310,
                "title": "simple-java-solution-with-o-n-time-and-o-1-space",
                "content": "\\n    \\n\\tpublic int minimumDeletions(String s) {\\n        \\n\\t\\tint n=s.length();\\n\\t\\tint min=Integer.MAX_VALUE;;\\n\\t\\tint countA=0, countB=0;\\n        \\n        for(int i=0; i<n; i++)\\n            countA = s.charAt(i) == \\'a\\' ? countA+1 : countA;\\n\\n        for(int i=0; i<n; i++){\\n            countA = s.charAt(i) == \\'a\\' ? countA-1 : countA;\\n            min=Math.min(min, countA + countB);\\n            countB = s.charAt(i) == \\'b\\' ? countB+1 : countB;\\n        }\\n        \\n        return min;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    \\n\\tpublic int minimumDeletions(String s) {\\n        \\n\\t\\tint n=s.length();\\n\\t\\tint min=Integer.MAX_VALUE;;\\n\\t\\tint countA=0, countB=0;\\n        \\n        for(int i=0; i<n; i++)\\n            countA = s.charAt(i) == \\'a\\' ? countA+1 : countA;\\n\\n        for(int i=0; i<n; i++){\\n            countA = s.charAt(i) == \\'a\\' ? countA-1 : countA;\\n            min=Math.min(min, countA + countB);\\n            countB = s.charAt(i) == \\'b\\' ? countB+1 : countB;\\n        }\\n        \\n        return min;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2181270,
                "title": "o-n-and-o-nlogn-solutions-in-c",
                "content": "**Method 1:** O(NlogN) - Map \\'a\\' -> 0 and \\'b\\' -> 1. Find longest non-decreasing sub-sequence\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int len = s.length();\\n        vector <int> arr;\\n        \\n        for(int i = 0; i < len; i++) {\\n            int d = s[i] - \\'a\\';\\n                \\n            if(arr.empty()) {\\n                arr.push_back(d);\\n            }\\n            else {\\n                if(d >= arr.back()) {\\n                    arr.push_back(d);\\n                }\\n                else {\\n                    int idx = upper_bound(arr.begin(), arr.end(), d) - arr.begin();\\n                    arr[idx] = d;\\n                }\\n            }\\n        }\\n        \\n        return len - arr.size();\\n    }\\n};\\n```\\n\\n**Method 2:** O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ta = 0, tb = 0, len = s.length();\\n        for(const char &ch : s) {\\n            tb += (ch == \\'b\\');\\n            ta += (ch == \\'a\\');\\n        }\\n        \\n        int x = 0, a = 0, b = 0, res = min(tb, ta); // make all \\'a\\' or all \\'b\\'\\n        for(const char &ch : s) {\\n            a += (ch == \\'a\\');\\n            b += (ch == \\'b\\');\\n            x++;\\n            \\n            // make left part (a) and right part (b)\\n            int op = b + (ta - a);\\n            \\n            res = min(res, op);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int len = s.length();\\n        vector <int> arr;\\n        \\n        for(int i = 0; i < len; i++) {\\n            int d = s[i] - \\'a\\';\\n                \\n            if(arr.empty()) {\\n                arr.push_back(d);\\n            }\\n            else {\\n                if(d >= arr.back()) {\\n                    arr.push_back(d);\\n                }\\n                else {\\n                    int idx = upper_bound(arr.begin(), arr.end(), d) - arr.begin();\\n                    arr[idx] = d;\\n                }\\n            }\\n        }\\n        \\n        return len - arr.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ta = 0, tb = 0, len = s.length();\\n        for(const char &ch : s) {\\n            tb += (ch == \\'b\\');\\n            ta += (ch == \\'a\\');\\n        }\\n        \\n        int x = 0, a = 0, b = 0, res = min(tb, ta); // make all \\'a\\' or all \\'b\\'\\n        for(const char &ch : s) {\\n            a += (ch == \\'a\\');\\n            b += (ch == \\'b\\');\\n            x++;\\n            \\n            // make left part (a) and right part (b)\\n            int op = b + (ta - a);\\n            \\n            res = min(res, op);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127919,
                "title": "simple-o-n-java-solution-without-dp",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int[] aS = new int[s.length()];\\n        int[] bS = new int[s.length()];\\n        \\n        int cnt = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            aS[i] = cnt;\\n            if(s.charAt(i) == \\'a\\') cnt++;\\n        }\\n        \\n        cnt = 0;\\n        for(int i = 0; i< s.length(); i++) {\\n            bS[i] = cnt;\\n            if(s.charAt(i) == \\'b\\') cnt++;\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i< s.length(); i++) {\\n            ans = Math.min(ans , aS[i] + bS[i]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int[] aS = new int[s.length()];\\n        int[] bS = new int[s.length()];\\n        \\n        int cnt = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            aS[i] = cnt;\\n            if(s.charAt(i) == \\'a\\') cnt++;\\n        }\\n        \\n        cnt = 0;\\n        for(int i = 0; i< s.length(); i++) {\\n            bS[i] = cnt;\\n            if(s.charAt(i) == \\'b\\') cnt++;\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i< s.length(); i++) {\\n            ans = Math.min(ans , aS[i] + bS[i]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108657,
                "title": "simplest-shortest-solution",
                "content": "a = max len string of the form aaa....aaa with possibly 0 a\\nab = max len string of the form aaa...aabb....bb with possibly 0 a and/or 0 b\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), a = 0, ab = 0;\\n        for(char &c : s) {\\n            if (c == \\'a\\') {\\n                a++;\\n                ab = max(ab, a);\\n            } else ab++;\\n        }\\n        return n - ab;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), a = 0, ab = 0;\\n        for(char &c : s) {\\n            if (c == \\'a\\') {\\n                a++;\\n                ab = max(ab, a);\\n            } else ab++;\\n        }\\n        return n - ab;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032143,
                "title": "python-simple-o-n-find-split-point",
                "content": "Basically, we want the string to end up to be \"aaaaaaaa\", or \"bbbbbbb\" or \"aaaabbbbb\". We just need to find an optimum split point in the string, whereby number of \"b\" to the left of split point + number of \"a\" to the right of split point is the minimum. \\n\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:        \\n\\n        left_b = 0  ###Keep track of number of \"b\" to the left of split point\\n        right_a = s.count(\"a\") ###Keep track of number of \"a\" to the right of split point\\n        \\n        min_deletion = right_a ###Delete all a\\n        \\n        ###Iterate through all potential position split point\\n        for i, char in enumerate(s):\\n            if char == \"a\":\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n                \\n            min_deletion = min(min_deletion, left_b + right_a)\\n            \\n            \\n        return min_deletion\\n            \\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:        \\n\\n        left_b = 0  ###Keep track of number of \"b\" to the left of split point\\n        right_a = s.count(\"a\") ###Keep track of number of \"a\" to the right of split point\\n        \\n        min_deletion = right_a ###Delete all a\\n        \\n        ###Iterate through all potential position split point\\n        for i, char in enumerate(s):\\n            if char == \"a\":\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n                \\n            min_deletion = min(min_deletion, left_b + right_a)\\n            \\n            \\n        return min_deletion\\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013333,
                "title": "python-prefix-sum",
                "content": "The question is similar to **926. Flip String to Monotone Increasing.**\\n\\nWe can apply the same logic as in the solution for question 926, create a prefix sum and find the sum of *\\'b\\'* to the left of a position in the string and *\\'a\\'* to the right of the position in the string, this sum would be the number of deletions required to make the string balanced.\\n\\nThen find the minimum of this sum by considering every possible position in the string.\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        prefix = [0]\\n        for i in range(0,len(s)):\\n            prefix.append(prefix[-1]+1 if s[i]==\\'b\\' else prefix[-1])\\n        print(prefix)\\n        mini = float(\\'inf\\')\\n        for i in range(len(prefix)):\\n            val=prefix[i]+(len(s)-i)-(prefix[-1]-prefix[i])\\n            mini=min(mini,val)\\n        return mini if mini!=float(\\'inf\\') else 0\\n```",
                "solutionTags": [
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        prefix = [0]\\n        for i in range(0,len(s)):\\n            prefix.append(prefix[-1]+1 if s[i]==\\'b\\' else prefix[-1])\\n        print(prefix)\\n        mini = float(\\'inf\\')\\n        for i in range(len(prefix)):\\n            val=prefix[i]+(len(s)-i)-(prefix[-1]-prefix[i])\\n            mini=min(mini,val)\\n        return mini if mini!=float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011120,
                "title": "c-dp-tabulation-and-space-optimized-solution-with-explanation-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n        \\n        //============================Tabulation DP Approach O(N) Time O(N) Space==============================//\\n//         vector<int> dp(s.size()+1);\\n//         int b = 0;\\n//         dp[0] = 0;\\n//         for(int i = 1; i<=s.size(); i++)\\n//         {\\n//             if(s[i-1]==\\'a\\')\\n//             {\\n//                 dp[i] = min(1+dp[i-1],b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n//             }\\n//             else\\n//             {\\n//                 dp[i] = dp[i-1], ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n//             }\\n//         }\\n//         return dp[s.size()];\\n        \\n        \\n        //========================Space Optimized DP O(N) Time O(1) Space =================================//\\n        //Since we are only using current and previous state of the dp array...!\\n        int prev = 0, curr = 0;\\n        int b = 0;\\n        for(int i = 1; i<=s.size(); i++)\\n        {\\n            if(s[i-1]==\\'a\\')\\n            {\\n                curr = min(1+prev,b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n            }\\n            else\\n            {\\n                curr = prev, ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n            }\\n            prev = curr;\\n        }\\n        \\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n        \\n        //============================Tabulation DP Approach O(N) Time O(N) Space==============================//\\n//         vector<int> dp(s.size()+1);\\n//         int b = 0;\\n//         dp[0] = 0;\\n//         for(int i = 1; i<=s.size(); i++)\\n//         {\\n//             if(s[i-1]==\\'a\\')\\n//             {\\n//                 dp[i] = min(1+dp[i-1],b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n//             }\\n//             else\\n//             {\\n//                 dp[i] = dp[i-1], ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n//             }\\n//         }\\n//         return dp[s.size()];\\n        \\n        \\n        //========================Space Optimized DP O(N) Time O(1) Space =================================//\\n        //Since we are only using current and previous state of the dp array...!\\n        int prev = 0, curr = 0;\\n        int b = 0;\\n        for(int i = 1; i<=s.size(); i++)\\n        {\\n            if(s[i-1]==\\'a\\')\\n            {\\n                curr = min(1+prev,b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n            }\\n            else\\n            {\\n                curr = prev, ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n            }\\n            prev = curr;\\n        }\\n        \\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006722,
                "title": "easy-to-understand-dp-solution-using-python-o-n",
                "content": "First we will create two arrays of n+1 size for storing a\\'s and b\\'s count. Now, the size of array needs to be n+1 because, we want to know that what will be the answer if we want to consider the first and last index.\\nStep1. Traverse the string and store count of a\\'s from left to right in dp_fron, including a on that position, we will start filling array from index 1 not 0\\nStep2. Repeat step1 from Right to Left for b\\'s cound and for this we will start filling from index n-1\\nStep3. We will count the a\\'s count and b\\'s count of each position and store the maximum count.\\nStep4. Subtract the max count with the length of array to get number of elements to remove.\\n```\\nn=len(s)\\ndp_front=[0]*(n+1)\\ndp_last=[0]*(n+1)\\n\\n\\nfor i in range(n):\\n    if s[i]==\"a\":\\n        dp_front[i+1]=dp_front[i]+1\\n    else:\\n        dp_front[i+1]=dp_front[i]\\n\\nfor i in range(n-1,-1,-1):\\n    if s[i]==\"b\":\\n        dp_last[i]=dp_last[i+1]+1\\n    else:\\n        dp_last[i]=dp_last[i+1]\\n\\nmax_val=0\\nfor i in range(n+1):\\n    max_val=max(max_val,dp_front[i]+dp_last[i])\\nans=n-max_val\\nprint(ans)\\n\\n```\\nThanks for reading it out, hope you finds this solution useful.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nn=len(s)\\ndp_front=[0]*(n+1)\\ndp_last=[0]*(n+1)\\n\\n\\nfor i in range(n):\\n    if s[i]==\"a\":\\n        dp_front[i+1]=dp_front[i]+1\\n    else:\\n        dp_front[i+1]=dp_front[i]\\n\\nfor i in range(n-1,-1,-1):\\n    if s[i]==\"b\":\\n        dp_last[i]=dp_last[i+1]+1\\n    else:\\n        dp_last[i]=dp_last[i+1]\\n\\nmax_val=0\\nfor i in range(n+1):\\n    max_val=max(max_val,dp_front[i]+dp_last[i])\\nans=n-max_val\\nprint(ans)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1965368,
                "title": "java",
                "content": "\"\"\"\\nclass Solution \\n{\\n    public int minimumDeletions(String s) \\n    {\\n        int aLeft = 0, bLeft = 0;\\n        int aRight = findCount(s, \\'a\\'), bRight = findCount(s, \\'b\\');\\n        \\n        /*Any one of the 2 can be utilized :\\n                 -------------------\\n              | int minDel = bRight; |\\n              | int minDel = aRight; |\\n                ---------------------\\n            i.e To get the right sequence, we can either delete all the a\\'s\\n            or all the b\\'s towards the right hand side*/\\n        \\n        \\n        int minDel = aRight;\\n        \\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            //To get the valid result, we need to delete all the b\\'s appearing towards the left and all the a\\'s appearing towards the right\\n            minDel = Math.min(minDel, bLeft + aRight);\\n            \\n            //Update the 4 counter variables appropriately (aRight, aLeft, bRight, bLeft)\\n            if(s.charAt(i) == \\'a\\')\\n            {\\n                aRight -= 1;\\n                aLeft += 1;\\n            }\\n            else\\n            {\\n                bRight -= 1;\\n                bLeft += 1;\\n            }\\n        }\\n        \\n        minDel = Math.min(minDel, bLeft + aRight);\\n        return minDel;\\n    }\\n    \\n    //Returns the count of character c in the String \\n    private int findCount(String s, char c)\\n    {\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == c)\\n            {\\n                count += 1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\"\"\"",
                "solutionTags": [],
                "code": "class Solution \\n{\\n    public int minimumDeletions(String s) \\n    {\\n        int aLeft = 0, bLeft = 0;\\n        int aRight = findCount(s, \\'a\\'), bRight = findCount(s, \\'b\\');\\n        \\n        /*Any one of the 2 can be utilized :\\n                 -------------------\\n              | int minDel = bRight; |\\n              | int minDel = aRight; |\\n                ---------------------\\n            i.e To get the right sequence, we can either delete all the a\\'s\\n            or all the b\\'s towards the right hand side*/\\n        \\n        \\n        int minDel = aRight;\\n        \\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            //To get the valid result, we need to delete all the b\\'s appearing towards the left and all the a\\'s appearing towards the right\\n            minDel = Math.min(minDel, bLeft + aRight);\\n            \\n            //Update the 4 counter variables appropriately (aRight, aLeft, bRight, bLeft)\\n            if(s.charAt(i) == \\'a\\')\\n            {\\n                aRight -= 1;\\n                aLeft += 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1948314,
                "title": "weeb-does-python-c-prefix-suffix-sum",
                "content": "**Python**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef minimumDeletions(self, s: str) -> int:\\n\\t\\t\\tpreSum = [0] * (len(s) + 1)\\n\\t\\t\\tsufSum = [0] * (len(s) + 1)\\n\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif s[i] == \"a\":\\n\\t\\t\\t\\t\\tpreSum[i] += 1 + preSum[i-1]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpreSum[i] = preSum[i-1]\\n\\n\\t\\t\\t\\tif s[len(s)-i-1] == \"b\":\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += 1 + sufSum[len(s)-i]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += sufSum[len(s)-i]\\n\\n\\t\\t\\tmaxStringLength = 0\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif preSum[i] + sufSum[i] > maxStringLength:\\n\\t\\t\\t\\t\\tmaxStringLength = preSum[i] + sufSum[i]\\n\\n\\t\\t\\treturn len(s) - maxStringLength\\n\\n**C++**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumDeletions(string s) {\\n\\t\\t\\tvector<int> preSum(s.size(), 0);\\n\\t\\t\\tvector<int> sufSum(s.size(), 0);\\n\\n\\t\\t\\tif (s[0] == \\'a\\') preSum[0] = 1;\\n\\t\\t\\tif (s[s.size()-1] == \\'b\\') sufSum[s.size()-1] = 1;\\n\\n\\t\\t\\tfor (int i=1; i<s.size(); i++){\\n\\t\\t\\t\\tif (s[i] == \\'a\\') preSum[i] += 1 + preSum[i-1];\\n\\n\\t\\t\\t\\telse{preSum[i] = preSum[i-1];}\\n\\n\\t\\t\\t\\tif (s[s.size()-i-1] == \\'b\\') sufSum[s.size()-i-1] += 1 + sufSum[s.size()-i];\\n\\n\\t\\t\\t\\telse{sufSum[s.size()-i-1] += sufSum[s.size()-i];}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint maxStringLen = 0;\\n\\n\\t\\t\\tfor (int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tif (preSum[i] + sufSum[i] > maxStringLen) maxStringLen = preSum[i] + sufSum[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn s.size() - maxStringLen;\\n\\t\\t}\\n\\t};\\n\\nTake a break, watch some anime\\nCheck out **\\u6BBA\\u3057\\u611B (Love of Kill)**\\n\\n\\n# Episodes: 12\\n# Genres: Action, Romance\\n# Themes: Adult Cast, Organized Crime\\n\\nIts a nice anime, watch it",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n\\t\\tdef minimumDeletions(self, s: str) -> int:\\n\\t\\t\\tpreSum = [0] * (len(s) + 1)\\n\\t\\t\\tsufSum = [0] * (len(s) + 1)\\n\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif s[i] == \"a\":\\n\\t\\t\\t\\t\\tpreSum[i] += 1 + preSum[i-1]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpreSum[i] = preSum[i-1]\\n\\n\\t\\t\\t\\tif s[len(s)-i-1] == \"b\":\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += 1 + sufSum[len(s)-i]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += sufSum[len(s)-i]\\n\\n\\t\\t\\tmaxStringLength = 0\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif preSum[i] + sufSum[i] > maxStringLength:\\n\\t\\t\\t\\t\\tmaxStringLength = preSum[i] + sufSum[i]\\n\\n\\t\\t\\treturn len(s) - maxStringLength\\n\\n**C++**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumDeletions(string s) {\\n\\t\\t\\tvector<int> preSum(s.size(), 0);\\n\\t\\t\\tvector<int> sufSum(s.size(), 0);\\n\\n\\t\\t\\tif (s[0] == \\'a\\') preSum[0] = 1;\\n\\t\\t\\tif (s[s.size()-1] == \\'b\\') sufSum[s.size()-1] = 1;\\n\\n\\t\\t\\tfor (int i=1; i<s.size(); i++){\\n\\t\\t\\t\\tif (s[i] == \\'a\\') preSum[i] += 1 + preSum[i-1];\\n\\n\\t\\t\\t\\telse{preSum[i] = preSum[i-1];}",
                "codeTag": "Java"
            },
            {
                "id": 1946583,
                "title": "c-o-1-space-same-as-lc926-simple-solution-with-explanation",
                "content": "We just have two options when current character `s[i]` is `a`, and we already have best solution `res` for `0~i-1` : \\n(1) delete all `b` we have counted before\\n(2) only delete current character, sum with `res`\\nso `res = min(res+1, bcnt)`\\n\\n* time: `O(n)`\\n* space: `O(1)`\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bcnt = 0, res = 0;\\n        for (auto &ch: s) {\\n            if (ch == \\'a\\') {\\n                res = min(res+1, bcnt);\\n            } else {\\n                ++bcnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bcnt = 0, res = 0;\\n        for (auto &ch: s) {\\n            if (ch == \\'a\\') {\\n                res = min(res+1, bcnt);\\n            } else {\\n                ++bcnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918029,
                "title": "elegant-c-solution",
                "content": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int cnt1=0, cnt2=0;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                cnt1++; // the number of b appearing before a\\n            }\\n            else if(cnt1>0)\\n            {\\n                cnt1--; \\n                cnt2++;  \\n            }\\n            i++;\\n        }\\n        return cnt2;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int cnt1=0, cnt2=0;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                cnt1++; // the number of b appearing before a\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1901549,
                "title": "python-o-n-stack-with-explanation",
                "content": "Idea is to count the number of pairs of \"b\" and \"a\" such that \"a\" has appeared after a \"b\"\\n        \\n\\tuse stack\\n            see b? push to stack\\n            see a?\\n                if stack not empty: \\n                     pop from the stack and count it as a deletion \\nTime and space: O(n)\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\t\\tstack = [] \\n        counter = 0 \\n        \\n        for char in s:\\n            if char == \"b\":\\n                stack.append(char)\\n            \\n            elif stack:\\n                counter += 1\\n                stack.pop()\\n        \\n        return counter \\n            \\n        \\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\t\\tstack = [] \\n        counter = 0 \\n        \\n        for char in s:\\n            if char == \"b\":\\n                stack.append(char)\\n            \\n            elif stack:\\n                counter += 1\\n                stack.pop()\\n        \\n        return counter \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897453,
                "title": "cpp-prefix-sum-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        if(n==1)\\n        {\\n            if(s[0]==\\'a\\')\\n                return 0;\\n        }\\n        vector<int> a(n,0),b(n,0);\\n        if(s[0]==\\'b\\')\\n        {\\n            b[0]=1;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                b[i]=b[i-1]+1;\\n            }\\n            else\\n            {\\n                b[i]=b[i-1];\\n            }\\n        }\\n        if(s[n-1]==\\'a\\')\\n        {\\n            a[n-1]=1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                a[i]=a[i+1]+1;\\n            }\\n            else\\n            {\\n                a[i]=a[i+1];\\n            }\\n        }\\n        int mi=n;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            mi=min(mi,a[i+1]+b[i-1]);\\n        }\\n        if(b[n-1]==n||a[0]==n)\\n            return 0;\\n        mi=min(mi,a[0]);\\n        mi=min(mi,b[n-1]);\\n        return mi;\\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        if(n==1)\\n        {\\n            if(s[0]==\\'a\\')\\n                return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1893179,
                "title": "java-find-the-longest-valid-sequence",
                "content": "This question translates to find the longest valid sequence and the answer would be length of string minus that. \\n\\nLet `a` be the length of a valid sequence that ends with an `a`.\\nLet `b` be the length of a valid sequence that ends with an `b`.\\n\\nCase 1 - When current char equals to a: We increment `a` by 1 as there is no way to transition from a valid sequence that ends with a `b` to `a`.\\nCase 2 - When current char equals to b: We can append this `b` to either `a` or `b` to form a valid sequence, that is, we take from `max(a, b)` and plus 1.\\n\\n\\n```Java\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (char ch : s.toCharArray()){\\n            if (ch == \\'a\\'){\\n                a++;\\n            }else{\\n                b = Math.max(a, b) + 1;\\n            }\\n        }\\n\\n        return s.length() - Math.max(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (char ch : s.toCharArray()){\\n            if (ch == \\'a\\'){\\n                a++;\\n            }else{\\n                b = Math.max(a, b) + 1;\\n            }\\n        }\\n\\n        return s.length() - Math.max(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880018,
                "title": "without-stack-o-1-space",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int count=0;\\n        //stack<char> st;\\n        int countb=0;\\n        int counta=0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'b\\'){\\n                countb++;\\n            }\\n            \\n            else{\\n                counta++;\\n            }\\n            \\n            if(countb!=0 && s[i]==\\'a\\'){\\n                countb--;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int count=0;\\n        //stack<char> st;\\n        int countb=0;\\n        int counta=0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'b\\'){\\n                countb++;\\n            }\\n            \\n            else{\\n                counta++;\\n            }\\n            \\n            if(countb!=0 && s[i]==\\'a\\'){\\n                countb--;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873217,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        \\n        int ans=INT_MIN;\\n        int cntb=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                cntb++;\\n        }       \\n        int a=0,b=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                a++;\\n                ans=max(ans,a+cntb-b);\\n            }\\n            else\\n            {\\n                b++;\\n                ans=max(ans,a+cntb-b+1);\\n            }\\n            \\n        }\\n        \\n        return n-ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        \\n        int ans=INT_MIN;\\n        int cntb=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                cntb++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1813674,
                "title": "c-prefix-sum-o-n",
                "content": "**Idea**\\nThere will exist atleast one index `i` before which we have to remove all `b` and after which will have to remove all `a`. Bulid a prefix(`left`) and suffix(`right`) array which contains no. of `b` till index `i` and no. of `a` after index `i` including `i`.\\nThen calculate min no. of operations by `min(left[i-1]+right[i])`. Take care of boundary cases.\\n**Time: O(n)**\\n**Space: O(n)**\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> left(s.size(),0),right(s.size(),0);\\n        \\n        if(s[0]==\\'b\\') left[0]++;\\n        for(int i = 1; i<s.size();++i){\\n            left[i] = left[i-1];\\n            if(s[i]==\\'b\\') left[i]++;\\n        }\\n        \\n        if(s[s.size()-1]==\\'a\\') right[s.size()-1]++;\\n        for(int i = s.size()-2;i>=0;--i){\\n            right[i] = right[i+1];\\n            if(s[i]==\\'a\\') right[i]++;\\n        }\\n        \\n        int re = min(right[0],left[s.size()-1]);\\n        for(int i = 1;i<s.size()-1;++i) re = min(re,left[i-1]+right[i]);\\n        \\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> left(s.size(),0),right(s.size(),0);\\n        \\n        if(s[0]==\\'b\\') left[0]++;\\n        for(int i = 1; i<s.size();++i){\\n            left[i] = left[i-1];\\n            if(s[i]==\\'b\\') left[i]++;\\n        }\\n        \\n        if(s[s.size()-1]==\\'a\\') right[s.size()-1]++;\\n        for(int i = s.size()-2;i>=0;--i){\\n            right[i] = right[i+1];\\n            if(s[i]==\\'a\\') right[i]++;\\n        }\\n        \\n        int re = min(right[0],left[s.size()-1]);\\n        for(int i = 1;i<s.size()-1;++i) re = min(re,left[i-1]+right[i]);\\n        \\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760353,
                "title": "c-o-n-t-c-o-1-s-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n         int n = s.size();\\n        \\n           // edge case\\n           if(n == 1) return 0;\\n        \\n           int count_a = 0;\\n           for(char ch : s){\\n               if(ch == \\'a\\') count_a++;\\n           }\\n           \\n           if(count_a == 0)  return 0;\\n           int curCount_b = 0, curCount_a;\\n        \\n           int ans = INT_MAX;\\n        \\n           for(char ch : s){\\n               if(ch == \\'a\\'){\\n                   curCount_a++;\\n                   ans = min(ans, curCount_b + count_a - curCount_a);\\n               }\\n               else {\\n                      ans = min(ans, curCount_b + count_a - curCount_a); \\n                      curCount_b++;\\n               }\\n           }\\n         \\n           return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n         int n = s.size();\\n        \\n           // edge case\\n           if(n == 1) return 0;\\n        \\n           int count_a = 0;\\n           for(char ch : s){\\n               if(ch == \\'a\\') count_a++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1754652,
                "title": "javascript-iterative-dynamic-programming-explanation",
                "content": "```\\n/** https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s) {\\n  if (s.length === 1) {\\n    return 0;\\n  }\\n  \\n  let bCount = Array(s.length+1).fill(0);\\n  \\n  // Count how many \\'b\\' from `0...i-1`\\n  for (let i = 0; i < s.length; i++) {\\n    bCount[i+1] = bCount[i];\\n    \\n    if (s[i] === \\'b\\') {\\n      bCount[i+1] += 1;\\n    }\\n  }\\n  \\n  let out = Infinity;\\n  \\n  // Find the least deletion operation needed to make string balance\\n  // To achieve that, we delete all \\'a\\' on the right + all \\'b\\' on the left of `i`\\n  for (let i = 0; i < s.length; i++) {\\n    // How many \\'b\\' on the left\\n    let bOnLeft = bCount[i];\\n    \\n    // How many \\'a\\' on the right\\n    // The formula is the length of `s` (0 indexed) - current position `i` minus how many \\'b\\' on the right\\n    // How many \\'b\\' on the right is easy to calculate by taking last \\'b\\' count and minus how many \\'b\\' at `i+1` then we get \\'b\\' count from `i...s.length-1`\\n    let length = s.length - 1;\\n    let bOnRight = bCount[bCount.length - 1] - bCount[i + 1];\\n    let aOnRight = length - i - bOnRight;\\n    \\n    out = Math.min(out, bOnLeft + aOnRight);\\n  }\\n  \\n  return out;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\n/** https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s) {\\n  if (s.length === 1) {\\n    return 0;\\n  }\\n  \\n  let bCount = Array(s.length+1).fill(0);\\n  \\n  // Count how many \\'b\\' from `0...i-1`\\n  for (let i = 0; i < s.length; i++) {\\n    bCount[i+1] = bCount[i];\\n    \\n    if (s[i] === \\'b\\') {\\n      bCount[i+1] += 1;\\n    }\\n  }\\n  \\n  let out = Infinity;\\n  \\n  // Find the least deletion operation needed to make string balance\\n  // To achieve that, we delete all \\'a\\' on the right + all \\'b\\' on the left of `i`\\n  for (let i = 0; i < s.length; i++) {\\n    // How many \\'b\\' on the left\\n    let bOnLeft = bCount[i];\\n    \\n    // How many \\'a\\' on the right\\n    // The formula is the length of `s` (0 indexed) - current position `i` minus how many \\'b\\' on the right\\n    // How many \\'b\\' on the right is easy to calculate by taking last \\'b\\' count and minus how many \\'b\\' at `i+1` then we get \\'b\\' count from `i...s.length-1`\\n    let length = s.length - 1;\\n    let bOnRight = bCount[bCount.length - 1] - bCount[i + 1];\\n    let aOnRight = length - i - bOnRight;\\n    \\n    out = Math.min(out, bOnLeft + aOnRight);\\n  }\\n  \\n  return out;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1699321,
                "title": "python3-simple-and-fast-o-n-time-o-1-space",
                "content": "We should loop through the string and keep track of the number of ***a***\\'s in the right side and the number of ***b***\\'s in the left side, the minimum sum of these two counts is the answer.\\n```\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        a, b = s.count(\\'a\\'), 0\\n        res = a + b\\n        for char in s:\\n            if char == \\'a\\':\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        a, b = s.count(\\'a\\'), 0\\n        res = a + b\\n        for char in s:\\n            if char == \\'a\\':\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641169,
                "title": "c-o-n-time-space-amateur-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumDeletions(string s) {\\n        int n = s.length();\\n        \\n        \\n        \\n        //1. Calculate the number of \\'b\\'s appearing before index i\\n        vector<int> leftB(n,0); \\n        for(int i=1;i<n;i++){\\n            leftB[i] = (s[i-1] == \\'b\\') + leftB[i-1];\\n        }\\n        \\n        //2. Calculate the number of \\'a\\'s appearing after index i\\n        vector<int> rightA(n,0);\\n        for(int i=n-2;i>=0;i--){\\n            rightA[i] = (s[i+1] == \\'a\\') + rightA[i+1];\\n        }\\n        \\n        //3. deletion for each index i = leftB[i] + rightA[i]\\n        //   find the index with minimum deletions\\n        int minDeletions = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            minDeletions = min(minDeletions, leftB[i] + rightA[i]);\\n        }\\n        \\n        return minDeletions;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumDeletions(string s) {\\n        int n = s.length();\\n        \\n        \\n        \\n        //1. Calculate the number of \\'b\\'s appearing before index i\\n        vector<int> leftB(n,0); \\n        for(int i=1;i<n;i++){\\n            leftB[i] = (s[i-1] == \\'b\\') + leftB[i-1];\\n        }\\n        \\n        //2. Calculate the number of \\'a\\'s appearing after index i\\n        vector<int> rightA(n,0);\\n        for(int i=n-2;i>=0;i--){\\n            rightA[i] = (s[i+1] == \\'a\\') + rightA[i+1];\\n        }\\n        \\n        //3. deletion for each index i = leftB[i] + rightA[i]\\n        //   find the index with minimum deletions\\n        int minDeletions = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            minDeletions = min(minDeletions, leftB[i] + rightA[i]);\\n        }\\n        \\n        return minDeletions;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624492,
                "title": "java-easy-10-line-o-n-o-1-dp-solution",
                "content": "@a: maximum length of valid string end with a\\n@b: maximum length of valid string end with b\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') a = a+1;\\n            else  b = Math.max(b+1, a+1);\\n        }\\n        return s.length()-Math.max(a,b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') a = a+1;\\n            else  b = Math.max(b+1, a+1);\\n        }\\n        return s.length()-Math.max(a,b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591448,
                "title": "dp-c-easy-to-understand",
                "content": "You can remove only all the \\'a\\' after a certain point and the \\'b\\' before that point.\\nSo you are supposed to find the minimum among all those possible value.\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ca=0,cb=0;\\n        for(auto c:s){\\n            if(c==\\'a\\')ca++;\\n            else cb++;\\n        }\\n        int n=s.length();\\n        int ans=ca;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'a\\')a++;\\n            else b++;\\n            ans=min(ans,ca-a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ca=0,cb=0;\\n        for(auto c:s){\\n            if(c==\\'a\\')ca++;\\n            else cb++;\\n        }\\n        int n=s.length();\\n        int ans=ca;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'a\\')a++;\\n            else b++;\\n            ans=min(ans,ca-a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583404,
                "title": "c-time-o-n-space-o-1-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // let endA[i] be the length of the longest balanced string up to position i and ending with \\'a\\'\\n    // let endB[i] be the length of the longest balanced string up to position i and ending with \\'b\\'\\n    //\\n    // now, consider position i+1\\n    //\\n    // if s[i+1] == \\'a\\', we can form a longer balanced string by appending \\'a\\'\\n\\t// to the the longest balanced string ending with \\'a\\' up to position i,\\n    // thus\\n    //    endA[i+1] = endA[i] + 1\\n    // we cannot append \\'a\\' to a string ending with \\'b\\' to form a balance string so endB stays the same\\n    //    endB[i+1] = endB[i]\\n\\t//\\n    // if s[i+1] == \\'b\\', we can form a longer balanced string by appending \\'b\\'\\n\\t// to either the longest blanced string ending with \\'b\\' or \\'a\\' up to position i,\\n    // thus\\n    //    endB[i+1] = max(endB[i], endA[i]) + 1\\n    // endA stays the same\\n    //    endA[i+1] = endA[i]\\n    //\\n    // answer will be s.size() - max(endA[n], endB[n]);\\n\\t\\n    int minimumDeletions(string s) {\\n        std::ios_base::sync_with_stdio(0);\\n        std::cin.tie(0);\\n        \\n        int endA = 0, endB = 0;\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'a\\') {\\n                endA = endA + 1;\\n            } else {\\n                endB = std::max(endB + 1, endA + 1);\\n            }\\n        }\\n        \\n        return s.size() - std::max(endA, endB);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // let endA[i] be the length of the longest balanced string up to position i and ending with \\'a\\'\\n    // let endB[i] be the length of the longest balanced string up to position i and ending with \\'b\\'\\n    //\\n    // now, consider position i+1\\n    //\\n    // if s[i+1] == \\'a\\', we can form a longer balanced string by appending \\'a\\'\\n\\t// to the the longest balanced string ending with \\'a\\' up to position i,\\n    // thus\\n    //    endA[i+1] = endA[i] + 1\\n    // we cannot append \\'a\\' to a string ending with \\'b\\' to form a balance string so endB stays the same\\n    //    endB[i+1] = endB[i]\\n\\t//\\n    // if s[i+1] == \\'b\\', we can form a longer balanced string by appending \\'b\\'\\n\\t// to either the longest blanced string ending with \\'b\\' or \\'a\\' up to position i,\\n    // thus\\n    //    endB[i+1] = max(endB[i], endA[i]) + 1\\n    // endA stays the same\\n    //    endA[i+1] = endA[i]\\n    //\\n    // answer will be s.size() - max(endA[n], endB[n]);\\n\\t\\n    int minimumDeletions(string s) {\\n        std::ios_base::sync_with_stdio(0);\\n        std::cin.tie(0);\\n        \\n        int endA = 0, endB = 0;\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'a\\') {\\n                endA = endA + 1;\\n            } else {\\n                endB = std::max(endB + 1, endA + 1);\\n            }\\n        }\\n        \\n        return s.size() - std::max(endA, endB);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566086,
                "title": "java-dp-two-states-switch",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int end_a = 0;\\n        int end_b = 0;\\n        for(char c : s.toCharArray()){\\n            int cur_end_a;\\n            int cur_end_b;\\n            if(c == \\'a\\'){\\n                cur_end_a = end_a;\\n                cur_end_b = Math.min(end_a + 1, end_b + 1);\\n            }else{\\n                cur_end_a = end_a + 1;\\n                cur_end_b = Math.min(end_a, end_b);\\n            }\\n            end_a = cur_end_a;\\n            end_b = cur_end_b;\\n        }\\n        return Math.min(end_a, end_b);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int end_a = 0;\\n        int end_b = 0;\\n        for(char c : s.toCharArray()){\\n            int cur_end_a;\\n            int cur_end_b;\\n            if(c == \\'a\\'){\\n                cur_end_a = end_a;\\n                cur_end_b = Math.min(end_a + 1, end_b + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1551143,
                "title": "o-1-space-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b = 0 , ans = 0;\\n        for(int i = 0 ;i< s.length();i++){\\n            if(s[i] == \\'a\\'){\\n                ans = min(ans+1 , b);                \\n            }\\n            else b++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b = 0 , ans = 0;\\n        for(int i = 0 ;i< s.length();i++){\\n            if(s[i] == \\'a\\'){\\n                ans = min(ans+1 , b);                \\n            }\\n            else b++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540821,
                "title": "simple-python-solution",
                "content": "```\\ndef minimumDeletions(self, st: str) -> int:\\n        bCount = 0\\n        bCarr = []\\n        ln = 0\\n        for item in st:\\n            if item == \\'b\\':\\n                bCount +=1\\n            bCarr.append(bCount)\\n            ln +=1\\n\\n        dl = 0\\n        for i in range(ln):\\n            if st[i] == \\'a\\':\\n                if bCarr[i] - dl > 0:\\n                    dl +=1\\n\\n        return dl\\n```\\n\\n981MS, 17.8MB",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minimumDeletions(self, st: str) -> int:\\n        bCount = 0\\n        bCarr = []\\n        ln = 0\\n        for item in st:\\n            if item == \\'b\\':\\n                bCount +=1\\n            bCarr.append(bCount)\\n            ln +=1\\n\\n        dl = 0\\n        for i in range(ln):\\n            if st[i] == \\'a\\':\\n                if bCarr[i] - dl > 0:\\n                    dl +=1\\n\\n        return dl\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1530385,
                "title": "c-o-n-time-complexity-and-o-1-space-complexity-simple-and-concise-solution",
                "content": "```\\nint minimumDeletions(string s) {\\n        int res=0;\\n        int count_a=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'b\\' and count_a>0)\\n            {\\n                res++;\\n                count_a--;\\n            }\\n            else\\n                {\\n                if(s[i]==\\'a\\') count_a++;\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumDeletions(string s) {\\n        int res=0;\\n        int count_a=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'b\\' and count_a>0)\\n            {\\n                res++;\\n                count_a--;\\n            }\\n            else\\n                {\\n                if(s[i]==\\'a\\') count_a++;\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527058,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int countB = 0;\\n        int countA = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'b\\')\\n            {\\n                countB++;\\n            }\\n            else\\n            {\\n                countA++;\\n            }\\n            countA = Math.min(countA,countB);\\n        }\\n        return countA;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumDeletions(String s) {\\n        int countB = 0;\\n        int countA = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'b\\')\\n            {\\n                countB++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1459817,
                "title": "simple-c-solutions-same-as-926-flip-string-to-monotone-increasing",
                "content": "This is same as **problem 926(Flip String to Monotone Increasing)** where we need to **flip** 1\\'s or 0\\'s to make string monotone increasing. Here, we need to **delete** a\\'s or b\\'s to make it increasing.\\n**Explanation**: For every index we can store number of b\\'s before that index (**bs in the code**) and keep a variable **del(required deletions)** and increment it when we see a\\'s and for every index find min of del and number of bs.\\n\\n```\\n\\t\\tint bs=0;\\n\\t\\tint del= 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                bs++;\\n            }\\n            else\\n            {\\n                del++;\\n            }\\n            del= min(del, bs);\\n        }\\n        return del;\\n\\t\\t\\n\\t```\\n\\n**Dry run:**\\nex: s= \"aababbab\"\\n(Here we need to delete a\\'s at index 3 and 6 to make s as \"aabbbb\")\\ni=0:\\nbs=0, del=1\\ndel= min(del, bs) =>del=  min(0, 1)=0\\ni=1:\\nbs=0, del=1\\ndel= min(del, bs) =>del=  min(0, 1)=0\\ni=2:\\nbs=1, del=0\\ndel= min(del, bs) =>del=  min(1, 0)=0\\ni=3:\\nbs=1, del=1\\ndel= min(del, bs) =>del=  min(1, 1)=1\\ni=4:\\nbs=2, del=1\\ndel= min(del, bs) =>del=  min(1, 2)=1\\ni=5:\\nbs= 3, del= 1\\ndel= min(del, bs) =>del=  min(1, 3)=1\\ni=6:\\nbs= 3, del=2\\ndel= min(del, bs) =>del=  min(2, 3)=2\\ni=7:\\nbs= 4, del=2\\ndel= min(del, bs) =>del=  min(2, 4)=2\\n\\n(Hope this is clear, pls let me know if anything\\'s not clear)\\n",
                "solutionTags": [],
                "code": "```\\n\\t\\tint bs=0;\\n\\t\\tint del= 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                bs++;\\n            }\\n            else\\n            {\\n                del++;\\n            }\\n            del= min(del, bs);\\n        }\\n        return del;\\n\\t\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1453672,
                "title": "dp-solution-o-n",
                "content": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp(s.size()+1);\\n        int bcount=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                dp[i+1]=min(1+dp[i],bcount);\\n            }\\n            else\\n            {\\n                dp[i+1]=dp[i];\\n                bcount++;\\n            }\\n        }\\n       return dp[s.size()];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp(s.size()+1);\\n        int bcount=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                dp[i+1]=min(1+dp[i],bcount);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1402109,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'a\\') {\\n                b++;\\n            } else {\\n                b = min(a, b);\\n                a++;\\n            }\\n        }\\n        return min(a, b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'a\\') {\\n                b++;\\n            } else {\\n                b = min(a, b);\\n                a++;\\n            }\\n        }\\n        return min(a, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395482,
                "title": "c-minimization-maximization-solution-o-n",
                "content": "**Minimization Approach:**\\n\\nThe problem is exactly similar to [926. Flip String to Monotone Increasing](https://leetcode.com/problems/flip-string-to-monotone-increasing/). Its solution is described [here](https://leetcode.com/problems/flip-string-to-monotone-increasing/discuss/1395348/C++-Solution-O(N)).\\n\\n\\n```\\nHere we have to delete char from string such that there is no i<j and s[j]=a and s[i]=b means we have to\\ndelete chars to make it monotonic increasing from a to b which is same as monotonic increasing of binary\\nstring where a=0 and b=1. Also flipping 0 to 1 and 1 to 0 can be equally considered as a delete operation\\nfor this problem. So, we use the same solution approach of 926. Flip String to Monotone Increasing. \\n```\\n\\nRuntime: 84 ms, faster than 90.98% of C++ online submissions for Minimum Deletions to Make String Balanced.\\nMemory Usage: 22 MB, less than 93.87% of C++ online submissions for Minimum Deletions to Make String Balanced.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n        \\n        //track number of delete \\n        int del = 0;\\n        \\n        // counts prefix bs \\n        int b_c = 0;\\n        \\n        for(int i=0;i<sl;i++)\\n        {\\n            // need to delete when prefix b exists, otherwise ignore\\n            if(s[i]==\\'a\\')\\n            {\\n                if(b_c>0)del++;\\n                else continue;\\n            }\\n            else b_c++; // track prefix 1 count\\n            \\n            // get the minimum between delete and b count\\n            // if delete > b count then it means there is more suffix a then prefix b\\n            del = min(del,b_c);\\n        }\\n        \\n        return del;\\n    }\\n};\\n```\\n\\n**Maximization Approach:**\\n\\n```\\nAnother way to think about this problem is finding the Length of Longest Monotonic Increasing\\nSubsequence. Then the minimum delete will be String Length - Max LMIS. \\n\\nNow as there are only 2 char type in the string we can easily calculate the Max LMIS for ending char\\na and b. Let they are a_c and b_c. Now the LMIS ending with a must contain all previous \\'a\\' char and\\nso we just increment its count. Other hand, Max LMIS ending with b can have previous a chars a_c or \\nprevious Max LMIS of ending with b, b_c and we update b_c as max(a_c,b_c) + 1. The max LMIS will be\\nthe max value between a_c and b_c at last and thus minimum delete will be String Length - Max LMIS.\\n\\nExample : \\n\\nMax LMIS ending with a => \"aaaaaaaa\"\\n\\nMax LMIS ending with b => \"aaaaaaab\"  or \"aaaabbb\" or \"bbbbbbb\"\\n```\\n\\nRuntime: 88 ms, faster than 81.27% of C++ online submissions for Minimum Deletions to Make String Balanced.\\nMemory Usage: 22 MB, less than 75.72% of C++ online submissions for Minimum Deletions to Make String Balanced.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n                \\n        // Length of LMIS ending with a\\n        int a_c = 0;\\n        // Length of LMIS ending with a\\n        int b_c = 0;\\n\\n        // loop through string and find max LMIS ending with a and b\\n        for(int i=0;i<sl;i++)\\n        {\\n            // Max LMIS ending with a can only have previous a element and so we increment its count\\n            if(s[i]==\\'a\\')a_c++;\\n            \\n            // Max LMIS ending with b can have all previous a element or previous Max LMIS ending with b elements\\n            // thus we take the max between those and add the current b\\n            else b_c = max(a_c,b_c) + 1;\\n        }\\n        \\n        // minimum delete => Total length - Max LMIS => String Length - max(a_c,b_c)\\n        return sl-max(a_c,b_c);\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nHere we have to delete char from string such that there is no i<j and s[j]=a and s[i]=b means we have to\\ndelete chars to make it monotonic increasing from a to b which is same as monotonic increasing of binary\\nstring where a=0 and b=1. Also flipping 0 to 1 and 1 to 0 can be equally considered as a delete operation\\nfor this problem. So, we use the same solution approach of 926. Flip String to Monotone Increasing. \\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n        \\n        //track number of delete \\n        int del = 0;\\n        \\n        // counts prefix bs \\n        int b_c = 0;\\n        \\n        for(int i=0;i<sl;i++)\\n        {\\n            // need to delete when prefix b exists, otherwise ignore\\n            if(s[i]==\\'a\\')\\n            {\\n                if(b_c>0)del++;\\n                else continue;\\n            }\\n            else b_c++; // track prefix 1 count\\n            \\n            // get the minimum between delete and b count\\n            // if delete > b count then it means there is more suffix a then prefix b\\n            del = min(del,b_c);\\n        }\\n        \\n        return del;\\n    }\\n};\\n```\n```\\nAnother way to think about this problem is finding the Length of Longest Monotonic Increasing\\nSubsequence. Then the minimum delete will be String Length - Max LMIS. \\n\\nNow as there are only 2 char type in the string we can easily calculate the Max LMIS for ending char\\na and b. Let they are a_c and b_c. Now the LMIS ending with a must contain all previous \\'a\\' char and\\nso we just increment its count. Other hand, Max LMIS ending with b can have previous a chars a_c or \\nprevious Max LMIS of ending with b, b_c and we update b_c as max(a_c,b_c) + 1. The max LMIS will be\\nthe max value between a_c and b_c at last and thus minimum delete will be String Length - Max LMIS.\\n\\nExample : \\n\\nMax LMIS ending with a => \"aaaaaaaa\"\\n\\nMax LMIS ending with b => \"aaaaaaab\"  or \"aaaabbb\" or \"bbbbbbb\"\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n                \\n        // Length of LMIS ending with a\\n        int a_c = 0;\\n        // Length of LMIS ending with a\\n        int b_c = 0;\\n\\n        // loop through string and find max LMIS ending with a and b\\n        for(int i=0;i<sl;i++)\\n        {\\n            // Max LMIS ending with a can only have previous a element and so we increment its count\\n            if(s[i]==\\'a\\')a_c++;\\n            \\n            // Max LMIS ending with b can have all previous a element or previous Max LMIS ending with b elements\\n            // thus we take the max between those and add the current b\\n            else b_c = max(a_c,b_c) + 1;\\n        }\\n        \\n        // minimum delete => Total length - Max LMIS => String Length - max(a_c,b_c)\\n        return sl-max(a_c,b_c);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385337,
                "title": "c-simple-intuitive-solution-with-o-1-space",
                "content": "The idea here is to maintain a counter for the number of \\'b\\'.\\nTraversing the string from left to right, when the current character is \\'b\\', simply increment the counter by 1.\\nWhen the current character is \\'a\\', check if the counter is positive. If yes, simply decrement it by 1, and increase the answer by 1.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n     \\n        int ans=0,cb=0,i=0,n=s.size();\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && cb>0)\\n            {\\n                cb--;\\n                ans++;\\n            }\\n            else if(s[i]==\\'b\\')\\n            {\\n                cb++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n     \\n        int ans=0,cb=0,i=0,n=s.size();\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && cb>0)\\n            {\\n                cb--;\\n                ans++;\\n            }\\n            else if(s[i]==\\'b\\')\\n            {\\n                cb++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345829,
                "title": "short-c-solution-o-n-time-o-1-space-w-explanation",
                "content": "The resulting string will always be some number of a\\'s then some number of b\\'s\\nSo we know that we need find a split of the string such that the number of b\\'s in the left side + the number of a\\'s on the right side is minimised\\nThis can be done in constant time by first counting how many a\\'s there are in the string then iterate through the string and count the number of a\\'s and b\\'s seen so far. We know the number of a\\'s to the right of the current position is just total number of a\\'s minus current count of a\\'s.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int at = 0, bc = 0, ac = 0;\\n        for(char c : s) if(c == \\'a\\') ++at;\\n        int ans = at;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\') ++ac;\\n            else ++bc;\\n            int dels = bc + (at - ac);\\n            ans = min(ans, dels);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int at = 0, bc = 0, ac = 0;\\n        for(char c : s) if(c == \\'a\\') ++at;\\n        int ans = at;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\') ++ac;\\n            else ++bc;\\n            int dels = bc + (at - ac);\\n            ans = min(ans, dels);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318797,
                "title": "very-intuitive-two-pointer-python-o-n-time-and-o-1-space-solution",
                "content": "The idea is to use two pointers i and j where i traverses from left to right and j traverses from right to left.\\nWhile traversing right, get to the first position where s[i] == \\'b\\' and similarly while traversing left, get to the first position where s[j] == \\'a\\'. We also keep on adjusting the count of \\'a\\' and \\'b\\' accordingly. Now we reach to a point where s[0:i] is all \\'a\\' and s[j+1:] is all \\'b\\'. At this point we need to decide whether we want to delete \\'a\\' or \\'b\\'. So we go greedy and delete that char whose count is less. So if count_a < count_b, we delete char \\'a\\' else we delete char \\'b\\'.\\n\\n```\\ndef get_a_count(word):\\n    count = 0\\n    for ch in word:\\n        if ch == \\'a\\':\\n            count += 1\\n    return count        \\n    \\n\\ndef get_minimum_deletions(word):\\n    result = 0\\n    i = 0\\n    j = len(word)-1\\n    count_a = get_a_count(word)\\n    count_b = len(word)-count_a\\n    while i < j:\\n\\t    # get to the point where word[i] = \\'b\\'\\n        while i < j and word[i] == \\'a\\':\\n            i += 1\\n            count_a -= 1\\n\\t\\t# get to the point where word[j] = \\'a\\'\\t\\n        while i < j and word[j] == \\'b\\':\\n            j -= 1\\n            count_b -= 1\\n            \\n\\t\\t# we go greedy here and delete that char whose count is less\\n        if count_a != 0 and count_b != 0:\\n            if count_a < count_b:\\n                j -= 1  # simulates deletion of \\'a\\'\\n                result += 1\\n                count_a -= 1\\n            else:\\n                i += 1  # simulates deletion of \\'b\\'\\n                result += 1\\n                count_b -= 1\\n    return result\\n```\\t\\n\\t\\n",
                "solutionTags": [],
                "code": "```\\ndef get_a_count(word):\\n    count = 0\\n    for ch in word:\\n        if ch == \\'a\\':\\n            count += 1\\n    return count        \\n    \\n\\ndef get_minimum_deletions(word):\\n    result = 0\\n    i = 0\\n    j = len(word)-1\\n    count_a = get_a_count(word)\\n    count_b = len(word)-count_a\\n    while i < j:\\n\\t    # get to the point where word[i] = \\'b\\'\\n        while i < j and word[i] == \\'a\\':\\n            i += 1\\n            count_a -= 1\\n\\t\\t# get to the point where word[j] = \\'a\\'\\t\\n        while i < j and word[j] == \\'b\\':\\n            j -= 1\\n            count_b -= 1\\n            \\n\\t\\t# we go greedy here and delete that char whose count is less\\n        if count_a != 0 and count_b != 0:\\n            if count_a < count_b:\\n                j -= 1  # simulates deletion of \\'a\\'\\n                result += 1\\n                count_a -= 1\\n            else:\\n                i += 1  # simulates deletion of \\'b\\'\\n                result += 1\\n                count_b -= 1\\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1087213,
                "title": "dp-python-simplest-constant-space-o-n-solution",
                "content": "Idea: The problem can be converted to longest aaa\\\\*bbbb\\\\* subsequence. \\n- t0 means the longest subsequence ending with a. \\n- t1 means the longest subsequence ending with b.\\nTime complexity is O(N)\\nSpace: O(1)\\n```python\\ndef minimumDeletions(self, s: str) -> int:\\n\\tt0 = t1 = 0\\n\\tfor c in s:\\n\\t\\t# carry the previous status\\n\\t\\tn0, n1 = t0, t1 \\n\\t\\tif c == \\'a\\':\\n\\t\\t\\tn0 = t0 + 1\\n\\t\\telse:\\n\\t\\t\\tn1 = max(t0, t1) + 1\\n\\t\\tt0, t1 = n0, n1\\n\\treturn len(s) - max(t0, t1)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minimumDeletions(self, s: str) -> int:\\n\\tt0 = t1 = 0\\n\\tfor c in s:\\n\\t\\t# carry the previous status\\n\\t\\tn0, n1 = t0, t1 \\n\\t\\tif c == \\'a\\':\\n\\t\\t\\tn0 = t0 + 1\\n\\t\\telse:\\n\\t\\t\\tn1 = max(t0, t1) + 1\\n\\t\\tt0, t1 = n0, n1\\n\\treturn len(s) - max(t0, t1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1009031,
                "title": "java-greedy-tc-o-n-space-o-1-17ms-faster-thn-99-with-explained-easily",
                "content": "```\\n/* idea is we think of removing a\\'s occruing after b\\'s to make the string balanced ,so we conut the number of a\\'s \\nafter b\\'s , BUT if we see that the count of b is less than count of a uptill now , we remove the b\\'s instead of the \\na\\'s beacuse it costs less .\\nThen just reset both a , b count and continue iterating the string \\nlastly it might happen that count (a) > count (b) never occurs for the entire string or for some part of the \\nstring after some removals , so we add count of a after coming out of the for loop .\\n\\n*/\\n\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0 , b = 0 ,cnt = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'a\\'){\\n                if(b == 0)\\n                    continue ;\\n                a++;\\n                if(a > b){\\n                    cnt += b ;\\n                    b = 0;\\n                    a = 0;\\n                }\\n            }\\n            else\\n                b++;\\n        }\\n        // consider -> baababbaabbaaabaabbabbbabaaaaaabaabababaaababbb\"\\n        // add the cnt of the single a in the index == 43 in the last part becasue a > b never triggers \\n        // if it triggers a will be 0 !\\n        cnt += a; \\n        return cnt ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* idea is we think of removing a\\'s occruing after b\\'s to make the string balanced ,so we conut the number of a\\'s \\nafter b\\'s , BUT if we see that the count of b is less than count of a uptill now , we remove the b\\'s instead of the \\na\\'s beacuse it costs less .\\nThen just reset both a , b count and continue iterating the string \\nlastly it might happen that count (a) > count (b) never occurs for the entire string or for some part of the \\nstring after some removals , so we add count of a after coming out of the for loop .\\n\\n*/\\n\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0 , b = 0 ,cnt = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'a\\'){\\n                if(b == 0)\\n                    continue ;\\n                a++;\\n                if(a > b){\\n                    cnt += b ;\\n                    b = 0;\\n                    a = 0;\\n                }\\n            }\\n            else\\n                b++;\\n        }\\n        // consider -> baababbaabbaaabaabbabbbabaaaaaabaabababaaababbb\"\\n        // add the cnt of the single a in the index == 43 in the last part becasue a > b never triggers \\n        // if it triggers a will be 0 !\\n        cnt += a; \\n        return cnt ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004397,
                "title": "simplest-c-o-n-without-dp-same-as-monotone-increasing",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b=0,a=0,ans=0;\\n        for(char c:s){\\n            if(c==\\'a\\') a++;\\n        }\\n        ans=a;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'b\\'){\\n                b++;\\n            }\\n            else{\\n                a--;\\n            }\\n            ans=min(ans,a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b=0,a=0,ans=0;\\n        for(char c:s){\\n            if(c==\\'a\\') a++;\\n        }\\n        ans=a;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'b\\'){\\n                b++;\\n            }\\n            else{\\n                a--;\\n            }\\n            ans=min(ans,a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000047,
                "title": "java-very-easy-to-understand-solution",
                "content": "Question says that there shouldn\\'t be any **b** between **a\\'s sequences** and there shouldn\\'t be any **a** in **b\\'s sequences** and **b\\'s sequences** should be after **a\\'s sequences**.To make the string balance we can try to balance every substring and atlast our string will be balanced.\\n\\n*Intution*\\n1. Loop over the character of s\\n2. If the character is \\'b\\' then we don\\'t need to delete anything.\\n3. Otherwise we have two option.We can delete that character and our delete count increases by 1 or we want to delete every b to get this substring valid.\\n4. Our answer is the minimum of this value.\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int bcnt = 0;\\n        int deleted = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'b\\') bcnt++;\\n            else{\\n                deleted = Math.min(deleted+1,bcnt);\\n            }\\n        }\\n        return deleted;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int bcnt = 0;\\n        int deleted = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'b\\') bcnt++;\\n            else{\\n                deleted = Math.min(deleted+1,bcnt);\\n            }\\n        }\\n        return deleted;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975389,
                "title": "java-solution-using-stack-with-explanation",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n       Stack<Character> st = new Stack<>();\\n       int min_del = 0;\\n       for(char c : s.toCharArray()){\\n         //whenever find \\'b\\' on top of stack and \\'a\\' on string we\\n         //delete both from the stack but we delete only \\'a\\' or \\'b\\' depending\\n         //on the no of b\\'s on the left and the no of a\\'s on the right\\n         //to eliminate b a.\\n         if(!st.isEmpty() && st.peek() == \\'b\\' && c == \\'a\\'){\\n           st.pop();\\n           min_del++;\\n         }else st.push(c);\\n        }\\n       return min_del;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n       Stack<Character> st = new Stack<>();\\n       int min_del = 0;\\n       for(char c : s.toCharArray()){\\n         //whenever find \\'b\\' on top of stack and \\'a\\' on string we\\n         //delete both from the stack but we delete only \\'a\\' or \\'b\\' depending\\n         //on the no of b\\'s on the left and the no of a\\'s on the right\\n         //to eliminate b a.\\n         if(!st.isEmpty() && st.peek() == \\'b\\' && c == \\'a\\'){\\n           st.pop();\\n           min_del++;\\n         }else st.push(c);\\n        }\\n       return min_del;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965912,
                "title": "100-javascript-dp-o-1-space",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s)  {\\n        let a = 0;\\n        let b = 0;\\n        for(let ch of s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = Math.min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return Math.min(a,b);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s)  {\\n        let a = 0;\\n        let b = 0;\\n        for(let ch of s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = Math.min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return Math.min(a,b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955662,
                "title": "java-dp-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int len = s.length();\\n\\t\\t//endA and endB store the number of deletions if the resulting valid string ends with A and B\\n        int endA = 0, endB = 0;\\n        for (int i=0; i<len; i++) {\\n\\t\\t\\t//if current char is a, we need to delete it to make string ending with b valid\\n            if (s.charAt(i) == \\'a\\') {\\n                endB++;\\n            }\\n\\t\\t\\t//if b, we can append it to the string with minimum deletion to make a valid string ending with b\\n            else {\\n                endB = Math.min(endA, endB);\\n                endA++;\\n            }\\n        }\\n        return Math.min(endA, endB);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int len = s.length();\\n\\t\\t//endA and endB store the number of deletions if the resulting valid string ends with A and B\\n        int endA = 0, endB = 0;\\n        for (int i=0; i<len; i++) {\\n\\t\\t\\t//if current char is a, we need to delete it to make string ending with b valid\\n            if (s.charAt(i) == \\'a\\') {\\n                endB++;\\n            }\\n\\t\\t\\t//if b, we can append it to the string with minimum deletion to make a valid string ending with b\\n            else {\\n                endB = Math.min(endA, endB);\\n                endA++;\\n            }\\n        }\\n        return Math.min(endA, endB);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941114,
                "title": "6-line-c-dp-o-n-time-o-1-space-change-the-problem-definition-makes-it-easier",
                "content": "Explain in comments.\\n```\\nint minimumDeletions(string s) {\\n\\t// Change the problem to be: longest accending string you can get\\n\\t// DP: two states\\n\\t//      a: longest string ending with \\'a\\'\\n\\t//      b: longest string ending with \\'b\\'\\n\\t// Iterate through string, if we meet \\'a\\', a++. Otherwise, the string can either be:\\n\\t//      1. previous longest string ending with \\'a\\' plus the current \\'b\\'\\n\\t//      2. previous longest string ending with \\'b\\' plus the current \\'b\\'\\n\\t// The minimun deletion would be length of string minus the longer one ending in either \\'a\\' or \\'b\\'.\\n\\tint a = 0, b = 0;\\n\\tfor (auto c: s) {\\n\\t\\tif (c == \\'a\\') a++;\\n\\t\\telse b = max(a, b) + 1;\\n\\t}\\n\\treturn s.length() - max(a, b);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumDeletions(string s) {\\n\\t// Change the problem to be: longest accending string you can get\\n\\t// DP: two states\\n\\t//      a: longest string ending with \\'a\\'\\n\\t//      b: longest string ending with \\'b\\'\\n\\t// Iterate through string, if we meet \\'a\\', a++. Otherwise, the string can either be:\\n\\t//      1. previous longest string ending with \\'a\\' plus the current \\'b\\'\\n\\t//      2. previous longest string ending with \\'b\\' plus the current \\'b\\'\\n\\t// The minimun deletion would be length of string minus the longer one ending in either \\'a\\' or \\'b\\'.\\n\\tint a = 0, b = 0;\\n\\tfor (auto c: s) {\\n\\t\\tif (c == \\'a\\') a++;\\n\\t\\telse b = max(a, b) + 1;\\n\\t}\\n\\treturn s.length() - max(a, b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 939879,
                "title": "java-solution-easy-to-understand-concise-o-3n",
                "content": "```java\\n public int minimumDeletions(String s) {\\n        int[] a = new int[s.length() + 1];\\n        int[] b = new int[s.length() + 1];\\n        for (int i = 0; i < s.length(); i++) {\\n            a[i + 1] = a[i] + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n        }\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            b[i] = b[i + 1] + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n        }\\n        int r = s.length();\\n        for (int i = 0; i < s.length() + 1; i++) {\\n            r = Math.min(r, s.length() - a[i] - b[i]);\\n        }\\n        return r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n public int minimumDeletions(String s) {\\n        int[] a = new int[s.length() + 1];\\n        int[] b = new int[s.length() + 1];\\n        for (int i = 0; i < s.length(); i++) {\\n            a[i + 1] = a[i] + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n        }\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            b[i] = b[i + 1] + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n        }\\n        int r = s.length();\\n        for (int i = 0; i < s.length() + 1; i++) {\\n            r = Math.min(r, s.length() - a[i] - b[i]);\\n        }\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 939861,
                "title": "o-n-very-simple-idea",
                "content": "Say the final answer begins at position p in the original string. To make position p a valid position, you have to delete all b\\'s before that position and all a\\'s after that position. Now we just iterate over the string and consider each possible position and try to find a p where number of deletions is minimum :)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> countA(s.length(), 0);\\n        int cnt = 0;\\n        for(int i = s.length()-1; i >=0 ; i--)\\n        {\\n            countA[i] = cnt;\\n            if(s[i] == \\'a\\')\\n                cnt++;\\n        }\\n        \\n        vector<int> countB(s.length(), 0);    \\n        cnt = 0;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            countB[i] = cnt;\\n            if(s[i] == \\'b\\')\\n                cnt++;\\n        }\\n        \\n        int minDel = s.length();\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            minDel = min(minDel, countB[i]+countA[i]);\\n        }\\n        \\n        return minDel;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> countA(s.length(), 0);\\n        int cnt = 0;\\n        for(int i = s.length()-1; i >=0 ; i--)\\n        {\\n            countA[i] = cnt;\\n            if(s[i] == \\'a\\')\\n                cnt++;\\n        }\\n        \\n        vector<int> countB(s.length(), 0);    \\n        cnt = 0;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            countB[i] = cnt;\\n            if(s[i] == \\'b\\')\\n                cnt++;\\n        }\\n        \\n        int minDel = s.length();\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            minDel = min(minDel, countB[i]+countA[i]);\\n        }\\n        \\n        return minDel;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939204,
                "title": "runtime-beats-98-93-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n =s.size()-1,a = 0,res = 0;\\n        \\n        for(int i=n;i>=0;i--)\\n            if(s[i] == \\'a\\') a++;\\n            else if( s[i] == \\'b\\'&& a > 0) a--,res ++;\\n        \\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n =s.size()-1,a = 0,res = 0;\\n        \\n        for(int i=n;i>=0;i--)\\n            if(s[i] == \\'a\\') a++;\\n            else if( s[i] == \\'b\\'&& a > 0) a--,res ++;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936487,
                "title": "min-deletions-of-left-b-and-right-a",
                "content": "```\\n    fun minimumDeletions(s: String): Int {\\n        val N = s.length\\n        var (la, lb) = 0 to 0\\n        var ra = s.count { it == \\'a\\' }\\n        var rb = N - ra\\n        var ans = ra  \\n        for (ch in s) {\\n            if (ch == \\'a\\') {\\n                la += 1\\n                ra -= 1\\n            } else {\\n                lb += 1\\n                rb -= 1\\n            }\\n            ans = minOf(ans, lb + ra)\\n        }\\n        return ans\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun minimumDeletions(s: String): Int {\\n        val N = s.length\\n        var (la, lb) = 0 to 0\\n        var ra = s.count { it == \\'a\\' }\\n        var rb = N - ra\\n        var ans = ra  \\n        for (ch in s) {\\n            if (ch == \\'a\\') {\\n                la += 1\\n                ra -= 1\\n            } else {\\n                lb += 1\\n                rb -= 1\\n            }\\n            ans = minOf(ans, lb + ra)\\n        }\\n        return ans\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936468,
                "title": "swift-clean-code-o-n-time-o-1-space",
                "content": "result = length(s) - length of the valid longest subsequence\\n```\\nclass Solution {\\n    func minimumDeletions(_ s: String) -> Int {\\n        let n = s.count\\n        // maxA is the length of the longest subsequence end with \"a\" \\n        var maxA = 0\\n        // maxB is the length of the longest subsequence end with \"b\" \\n        var maxB = 0\\n        for c in s {\\n            if c == \"a\" {\\n                maxA += 1\\n            } else {\\n                maxB = max(maxA, maxB) + 1\\n            }\\n        }\\n        return n - max(maxA, maxB)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumDeletions(_ s: String) -> Int {\\n        let n = s.count\\n        // maxA is the length of the longest subsequence end with \"a\" \\n        var maxA = 0\\n        // maxB is the length of the longest subsequence end with \"b\" \\n        var maxB = 0\\n        for c in s {\\n            if c == \"a\" {\\n                maxA += 1\\n            } else {\\n                maxB = max(maxA, maxB) + 1\\n            }\\n        }\\n        return n - max(maxA, maxB)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936240,
                "title": "minimum-deletions-to-make-string-balanced",
                "content": "Minimum Deletions to Make String Balanced\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n       int n=s.size();\\n       int  pre[100005]={0},suff[100005]={0};\\n        \\n       pre[0]=0; \\n       for(int i=0;i<n;i++){\\n           pre[i+1]=pre[i];\\n           if(s[i]==\\'b\\'){\\n               pre[i+1]++;\\n           }\\n       }\\n        \\n       suff[n]=0;\\n       for(int i=n-1;i>=0;i--){\\n           suff[i]=suff[i+1];\\n           if(s[i]==\\'a\\'){\\n               suff[i]++;\\n           }\\n       }\\n        \\n    \\n        int ans=1e9;\\n        for(int i=0;i<=s.size();i++)\\n             ans=min(ans,pre[i]+suff[i]);\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n       int n=s.size();\\n       int  pre[100005]={0},suff[100005]={0};\\n        \\n       pre[0]=0; \\n       for(int i=0;i<n;i++){\\n           pre[i+1]=pre[i];\\n           if(s[i]==\\'b\\'){\\n               pre[i+1]++;\\n           }\\n       }\\n        \\n       suff[n]=0;\\n       for(int i=n-1;i>=0;i--){\\n           suff[i]=suff[i+1];\\n           if(s[i]==\\'a\\'){\\n               suff[i]++;\\n           }\\n       }\\n        \\n    \\n        int ans=1e9;\\n        for(int i=0;i<=s.size();i++)\\n             ans=min(ans,pre[i]+suff[i]);\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935797,
                "title": "java-count-the-number-of-a-s-and-b-s-left-and-right",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int cntA = 0;\\n        int cntB = 0;\\n        int[] leftA = new int[n];\\n        int[] leftB = new int[n];\\n        int[] rightA = new int[n];\\n        int[] rightB = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            leftA[i] = cntA;\\n            leftB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        cntA = cntB = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            rightA[i] = cntA;\\n            rightB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        int min = n;\\n        for (int i = 0; i < n; i++) {\\n            min = Math.min(min, leftB[i] + rightA[i]);\\n            if (s.charAt(i) == \\'a\\') {\\n                min = Math.min(min, leftB[i] + rightB[i]);\\n                min = Math.min(min, leftA[i] + rightA[i] + 1);\\n            }\\n            if (s.charAt(i) == \\'b\\') {\\n                min = Math.min(min, leftA[i] + rightA[i]);\\n                min = Math.min(min, leftB[i] + rightB[i] + 1);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int cntA = 0;\\n        int cntB = 0;\\n        int[] leftA = new int[n];\\n        int[] leftB = new int[n];\\n        int[] rightA = new int[n];\\n        int[] rightB = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            leftA[i] = cntA;\\n            leftB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        cntA = cntB = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            rightA[i] = cntA;\\n            rightB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        int min = n;\\n        for (int i = 0; i < n; i++) {\\n            min = Math.min(min, leftB[i] + rightA[i]);\\n            if (s.charAt(i) == \\'a\\') {\\n                min = Math.min(min, leftB[i] + rightB[i]);\\n                min = Math.min(min, leftA[i] + rightA[i] + 1);\\n            }\\n            if (s.charAt(i) == \\'b\\') {\\n                min = Math.min(min, leftA[i] + rightA[i]);\\n                min = Math.min(min, leftB[i] + rightB[i] + 1);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935691,
                "title": "java-simple-o-n-dp-solution-beats-100-time-and-space",
                "content": "dp[i] == Number of deletions to balance `str[0, i]`. Also `dp[0] == 0` since it\\'s balanced.\\nNow if we see an `a` then we have two choices\\n\\t- Delete the `a` in which case total steps will be `dp[i-1]+1`\\n\\t- Keep the `a` and delete all preceding `b`, in which case dp[i] = `total b count so far`\\n\\t- We pick the min of the above two\\nIf we see a `b` then nothing needs to be done as `b` at end is legit. We just update counter for number of seen `b`.\\nWe can make it work with no additional space by just tracking the total deletions so far.\\n\\nTime `O(N)`\\nSpace `O(1)`\\n\\n\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int totDel = 0, totB = s.charAt(0) == \\'b\\' ? 1 : 0;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                totDel = Math.min(totDel+1, totB);\\n            } else {\\n                totB++;\\n            }\\n        }\\n        return totDel;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int totDel = 0, totB = s.charAt(0) == \\'b\\' ? 1 : 0;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                totDel = Math.min(totDel+1, totB);\\n            } else {\\n                totB++;\\n            }\\n        }\\n        return totDel;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935555,
                "title": "easy-c-100-better-in-time-and-100-better-in-space",
                "content": "\\'\\'\\'\\n\\npublic int MinimumDeletions(string s) {\\n        \\n        if(s.Length == 0) {\\n            return 0;\\n        }\\n        var minDeletes = s.Length;\\n        var deletes = new int[s.Length];\\n        var bCounts = 0;\\n        for(var i = 0; i < s.Length; i++)\\n        {\\n            deletes[i] = bCounts;\\n            if(s[i] == \\'b\\') {\\n                 bCounts++;\\n            }\\n        }\\n        \\n        var aCounts = 0;\\n        for(var i = s.Length-1; i >= 0; i--)\\n        {\\n             \\n            deletes[i] += aCounts;\\n            minDeletes = Math.Min(minDeletes,deletes[i]);\\n            if(s[i] == \\'a\\') {\\n                aCounts++;\\n             }\\n             \\n        }\\n        return minDeletes;\\n    }",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\npublic int MinimumDeletions(string s) {\\n        \\n        if(s.Length == 0) {\\n            return 0;\\n        }\\n        var minDeletes = s.Length;\\n        var deletes = new int[s.Length];\\n        var bCounts = 0;\\n        for(var i = 0; i < s.Length; i++)\\n        {\\n            deletes[i] = bCounts;\\n            if(s[i] == \\'b\\') {\\n                 bCounts++;\\n            }\\n        }\\n        \\n        var aCounts = 0;\\n        for(var i = s.Length-1; i >= 0; i--)\\n        {\\n             \\n            deletes[i] += aCounts;\\n            minDeletes = Math.Min(minDeletes,deletes[i]);\\n            if(s[i] == \\'a\\') {\\n                aCounts++;\\n             }\\n             \\n        }\\n        return minDeletes;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 935488,
                "title": "simple-python3-time-o-n-space-o-n",
                "content": "1. Counting all \"b\" from left to right, storing in array A.\\n2. Counting all \"a\" from right to left, storing is not needed\\n3. stored value in array A plus actual value of \"b\\' is number of deletions, if the point of \"...ab...\" is here\\n\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        m=len(s)\\n        if m<2: return 0\\n        \\n        A=[0]*m\\n        L=0\\n        b=0 # counting \"b\" from left\\n        while L<m:\\n            b+=s[L]==\\'b\\'\\n            A[L]=b\\n            L+=1\\n        \\n        minDel=b\\n        R=m-1\\n        a=0 # counting \"a\" from right\\n        while 0<=R:\\n            a+=s[R]==\\'a\\'\\n            minDel=min(minDel,A[R-1]+a)\\n            R-=1 \\n            \\n        return min(minDel,a) \\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        m=len(s)\\n        if m<2: return 0\\n        \\n        A=[0]*m\\n        L=0\\n        b=0 # counting \"b\" from left\\n        while L<m:\\n            b+=s[L]==\\'b\\'\\n            A[L]=b\\n            L+=1\\n        \\n        minDel=b\\n        R=m-1\\n        a=0 # counting \"a\" from right\\n        while 0<=R:\\n            a+=s[R]==\\'a\\'\\n            minDel=min(minDel,A[R-1]+a)\\n            R-=1 \\n            \\n        return min(minDel,a) \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 935418,
                "title": "easy-dp-c-explained-o-n-t-c",
                "content": "***Note : Random people downvote without even reading, do read and if helps dont atleast downvote, Thank You.***\\n***Note: Always welcome for optimisations, changes and advices.***\\n\\n***Intiution***\\n 1) Keep counting the number of encountered \\'b\\', uptill current index.\\n 2) If the current element is \\'b\\' , increse the count, and solution uptill current index will be same as of previous.\\n 3) If the element is an \\'a\\'. two case arise either previous encountered number of \\'b\\' is zero then solution upto current index is same as upto previous, else it will be the minimum of previous solution + 1 and deleting the previously encountered \\'b\\' uptill now.\\n \\n\\n```\\n\\nclass Solution \\n{\\npublic:\\n    int minimumDeletions(string s)\\n    {\\n        int no_of_b = 0;\\n        vector<int> dp( s.length(), 0 );\\n        \\n        no_of_b += ( s[0] == \\'b\\' ) ? 1 : 0;\\n        \\n        for( int i = 1; i<s.length(); i++ )\\n        {\\n            if( s[i] == \\'b\\' )\\n            {\\n                no_of_b++;\\n                dp[i] = dp[i-1];\\n            }\\n            else\\n            {\\n                if( no_of_b == 0 ) dp[i] = dp[i-1];\\n                else dp[i] = min( dp[i-1] + 1, no_of_b );\\n            }\\n        }\\n        \\n        return dp[s.length()-1];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution \\n{\\npublic:\\n    int minimumDeletions(string s)\\n    {\\n        int no_of_b = 0;\\n        vector<int> dp( s.length(), 0 );\\n        \\n        no_of_b += ( s[0] == \\'b\\' ) ? 1 : 0;\\n        \\n        for( int i = 1; i<s.length(); i++ )\\n        {\\n            if( s[i] == \\'b\\' )\\n            {\\n                no_of_b++;\\n                dp[i] = dp[i-1];\\n            }\\n            else\\n            {\\n                if( no_of_b == 0 ) dp[i] = dp[i-1];\\n                else dp[i] = min( dp[i-1] + 1, no_of_b );\\n            }\\n        }\\n        \\n        return dp[s.length()-1];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935416,
                "title": "python-variant-of-the-longest-increasing-subsequence",
                "content": "```\\nclass Solution(object):\\n    def minimumDeletions(self, s):\\n        dp = []\\n        for c in s:\\n            if c == \\'b\\':\\n                dp += c,\\n            else:\\n                if not dp:\\n                    dp += c,\\n                else:\\n                    if dp[-1] == \\'a\\':\\n                        dp += c,\\n                    else:\\n                        idx = bisect_right(dp, c)\\n                        dp[idx] = c\\n        return len(s) - len(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minimumDeletions(self, s):\\n        dp = []\\n        for c in s:\\n            if c == \\'b\\':\\n                dp += c,\\n            else:\\n                if not dp:\\n                    dp += c,\\n                else:\\n                    if dp[-1] == \\'a\\':\\n                        dp += c,\\n                    else:\\n                        idx = bisect_right(dp, c)\\n                        dp[idx] = c\\n        return len(s) - len(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935411,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> a;\\n        int n = s.size();\\n        if(s.size() == 1){\\n            return 0;\\n        }\\n        a.push_back(0);\\n        if(s[0] == \\'a\\')\\n            a[0] = 1;\\n        for(int i = 1; i < n; i++){\\n            a.push_back(a[i - 1]);\\n            if(s[i] == \\'a\\'){\\n                a[i] ++;\\n            }\\n        }\\n        if(s.size() - a.back() == 0){\\n            return 0;\\n        }\\n        \\n        int ans = INT_MAX;\\n        int local;\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                local = i - a[i] + a.back() - a[i];\\n                ans = min(ans, local);\\n            }\\n            \\n            \\n        }\\n        local = s.size() - a.back();\\n        ans = min(ans, local);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> a;\\n        int n = s.size();\\n        if(s.size() == 1){\\n            return 0;\\n        }\\n        a.push_back(0);\\n        if(s[0] == \\'a\\')\\n            a[0] = 1;\\n        for(int i = 1; i < n; i++){\\n            a.push_back(a[i - 1]);\\n            if(s[i] == \\'a\\'){\\n                a[i] ++;\\n            }\\n        }\\n        if(s.size() - a.back() == 0){\\n            return 0;\\n        }\\n        \\n        int ans = INT_MAX;\\n        int local;\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                local = i - a[i] + a.back() - a[i];\\n                ans = min(ans, local);\\n            }\\n            \\n            \\n        }\\n        local = s.size() - a.back();\\n        ans = min(ans, local);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083281,
                "title": "easy-to-understand-javascript-solution-dp",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar minimumDeletions = function(s) {\\n    let a = b = 0;\\n\\n    for (const char of s) {\\n        char === \\'a\\'\\n            ? b = Math.min(a, b + 1)\\n            : a += 1;\\n    }\\n    return Math.min(a, b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumDeletions = function(s) {\\n    let a = b = 0;\\n\\n    for (const char of s) {\\n        char === \\'a\\'\\n            ? b = Math.min(a, b + 1)\\n            : a += 1;\\n    }\\n    return Math.min(a, b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039498,
                "title": "most-easiest-solution-using-stack-must-see-too-easy-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                st.push(\\'b\\');\\n            }\\n\\n            else if(s[i] == \\'a\\'){\\n                if(st.size() != 0){\\n                    if(st.top() == \\'b\\'){\\n                        st.pop();\\n                        count++;\\n                    }\\n                }\\n\\n                else{\\n                    st.push(\\'a\\');\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                st.push(\\'b\\');\\n            }\\n\\n            else if(s[i] == \\'a\\'){\\n                if(st.size() != 0){\\n                    if(st.top() == \\'b\\'){\\n                        st.pop();\\n                        count++;\\n                    }\\n                }\\n\\n                else{\\n                    st.push(\\'a\\');\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005377,
                "title": "c-simple-solution-tc-o-n-sc-o-1-explanation",
                "content": "# EXPLANATION \\nAt first we count the number of **\\'a\\'** present in string and store in **a**.\\nThen again traverse in string **s**.\\nIf that char is \\'a\\' then we decrease count of **a** and do **ans=min(ans,a+b)**.\\nElse, then we do **ans=min(ans,a+b)** and increase the count of \\'b\\' in **b**.\\nOur idea is that if current is \\'a\\' then we count the number of \\'b\\' in left of it and the number of \\'a\\' on right of it.\\nElse if that current is \\'b\\' then we count the number of \\'a\\' on right and \\'b\\' on left.\\nFinally return the minimum of it and return as **ans**.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ans=INT_MAX;\\n        for(auto x:s)\\n            if(x==\\'a\\')\\n                a++;\\n        for(auto x:s){\\n            if(x==\\'a\\'){\\n                a--;\\n                ans=min(ans,a+b);\\n            }\\n            else{\\n                ans=min(ans,b+a);\\n                b++;\\n            }\\n        }\\n        ans=(ans==INT_MAX)?0:ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ans=INT_MAX;\\n        for(auto x:s)\\n            if(x==\\'a\\')\\n                a++;\\n        for(auto x:s){\\n            if(x==\\'a\\'){\\n                a--;\\n                ans=min(ans,a+b);\\n            }\\n            else{\\n                ans=min(ans,b+a);\\n                b++;\\n            }\\n        }\\n        ans=(ans==INT_MAX)?0:ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002666,
                "title": "without-using-any-extra-space-and-without-using-dp-and-stack-here-is-my-o-n-time-and-o-1-space",
                "content": "# Intuition\\n  **Have a look at the below image :** \\n\\n![leetcode.jpg](https://assets.leetcode.com/users/images/18eea307-3a95-4dde-b808-9fded7848a88_1693852109.88309.jpeg)\\n\\nJust a simple approach man as we know that we don\\'t want that our string consist of \\'a\\' character after the \\'b\\' character and we can keep track of this thing from the back of the string because in the beginning we don\\'t know after \\'b\\' how many \\'a\\' were there and before \\'a\\' how many \\'b\\' were there and we don\\'t know whether we will get the minimum deletions at the left end or right hand but at the same time we can keep track of \"ba\" from the end in an easy manner.\\n\\nJust we need to keep the count of \\'a\\' character and as soon as we got the \\'b\\' character then simply we will check if the count of \\'a\\' is greater than 0 and if it that means we need to delete either \\'a\\' or \\'b\\' which will take 1 deletion operation only so in such cases we will increment our answer by 1 and will decrement the count of \\'a\\' by 1 because we have already deleted it.\\n\\nAt the end we will simply return our answer variable which will contains the required answer.\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int ans=0,a=0;\\n        for(int i=n-1;i>=0;i--){\\n            char ch = s.charAt(i);\\n            if(ch==\\'a\\') a++;\\n            else if(ch==\\'b\\' && a!=0){\\n                ans+=1;\\n                a--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# **If you find this helpful then please upvote me :)**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int ans=0,a=0;\\n        for(int i=n-1;i>=0;i--){\\n            char ch = s.charAt(i);\\n            if(ch==\\'a\\') a++;\\n            else if(ch==\\'b\\' && a!=0){\\n                ans+=1;\\n                a--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998778,
                "title": "o-n-o-1-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        // stack<char> st;\\n        // int cnt=0;\\n        // for(auto ch:s)\\n        // {\\n        //     if(ch==\\'b\\')\\n        //     st.push(\\'b\\');\\n        //     if(ch==\\'a\\' && !st.empty())\\n        //     {\\n        //         st.pop();\\n        //         cnt++;\\n        //     }\\n        // }\\n        // return cnt;\\n        int cnt=0;\\n        int cntB=0;\\n        for(auto ch:s)\\n        {\\n            if(ch==\\'b\\')\\n            cntB++;\\n            else if(ch==\\'a\\' && cntB)\\n            {\\n                cntB--;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        // stack<char> st;\\n        // int cnt=0;\\n        // for(auto ch:s)\\n        // {\\n        //     if(ch==\\'b\\')\\n        //     st.push(\\'b\\');\\n        //     if(ch==\\'a\\' && !st.empty())\\n        //     {\\n        //         st.pop();\\n        //         cnt++;\\n        //     }\\n        // }\\n        // return cnt;\\n        int cnt=0;\\n        int cntB=0;\\n        for(auto ch:s)\\n        {\\n            if(ch==\\'b\\')\\n            cntB++;\\n            else if(ch==\\'a\\' && cntB)\\n            {\\n                cntB--;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981945,
                "title": "c-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int totalA = 0, totalB = 0;\\n        for(char c:s) {\\n            if(c ==\\'a\\'){\\n                totalA++;\\n            } else {\\n                totalB++;\\n            }\\n        }\\n        int min = std::min(totalA, totalB), pastA=0, pastB=0;\\n        for(int pos =1; pos<s.size(); pos++) {\\n            if(s[pos-1]==\\'a\\'){\\n                pastA++;\\n            } else {\\n                pastB++;\\n            }\\n            if(s[pos-1]==\\'a\\'&&s[pos]==\\'b\\') {\\n                int del = totalA-pastA + pastB;\\n                if(del<min){min = del;}\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int totalA = 0, totalB = 0;\\n        for(char c:s) {\\n            if(c ==\\'a\\'){\\n                totalA++;\\n            } else {\\n                totalB++;\\n            }\\n        }\\n        int min = std::min(totalA, totalB), pastA=0, pastB=0;\\n        for(int pos =1; pos<s.size(); pos++) {\\n            if(s[pos-1]==\\'a\\'){\\n                pastA++;\\n            } else {\\n                pastB++;\\n            }\\n            if(s[pos-1]==\\'a\\'&&s[pos]==\\'b\\') {\\n                int del = totalA-pastA + pastB;\\n                if(del<min){min = del;}\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971463,
                "title": "minimum-deletions-to-make-string-valid-using-stack",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        int len = s.length();\\n         \\n        Stack<Character> st = new Stack<Character>(); \\n         if (s == null || s.isEmpty()) return 0;\\n\\n        for( int i = 0 ; i < len ; i++){\\n          char c  = s.charAt(i);\\n\\n         if(!st.isEmpty() && c == \\'a\\'){\\n             st.pop();\\n             count++;\\n         }\\n         if(c == \\'b\\'){\\n             st.push(c);\\n          }\\n        }  \\n         return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        int len = s.length();\\n         \\n        Stack<Character> st = new Stack<Character>(); \\n         if (s == null || s.isEmpty()) return 0;\\n\\n        for( int i = 0 ; i < len ; i++){\\n          char c  = s.charAt(i);\\n\\n         if(!st.isEmpty() && c == \\'a\\'){\\n             st.pop();\\n             count++;\\n         }\\n         if(c == \\'b\\'){\\n             st.push(c);\\n          }\\n        }  \\n         return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958486,
                "title": "simple-python3-solution-92-47-simple-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to count the occurrences of \\'a\\' and \\'b\\' characters and use these counts to determine the minimum number of deletions needed to balance the string. We can match \\'a\\' characters with \\'b\\' characters to create pairs and eliminate the need for deletions. The goal is to minimize the total number of deletions required.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two variables a_count and b_count to keep track of the counts of \\'a\\' and \\'b\\' characters encountered in the string, and another variable total_deletions to track the total number of deletions needed.\\n\\n2. Iterate through each character c in the input string s:\\n\\n- If c is \\'a\\':\\n\\n    - If there are \\'b\\' characters encountered before (b_count > 0), it means we can form a balanced pair by matching this \\'a\\' with a \\'b\\', so decrement b_count and increment total_deletions by 1.\\n    - Otherwise, increment a_count by 1, indicating that we\\'ve encountered an \\'a\\' character.\\n\\n- If c is \\'b\\':\\n\\n    - Increment b_count by 1, indicating that we\\'ve encountered a \\'b\\' character.\\n\\n3. After processing all characters, the total_deletions will represent the minimum number of deletions needed to make the string balanced\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\nBeats 85.96%of users with Python3\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\nBeats 92.47%of users with Python3\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count_a = 0\\n        count_b = 0\\n        min_deleted = 0\\n\\n        for i in range(len(s)):\\n            if s[i] == \"a\":\\n                if count_b >0:\\n                    count_b-=1\\n                    min_deleted+=1\\n                else:\\n                    count_a += 1\\n            elif s[i] == \"b\":\\n                count_b +=1\\n\\n        return min_deleted\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count_a = 0\\n        count_b = 0\\n        min_deleted = 0\\n\\n        for i in range(len(s)):\\n            if s[i] == \"a\":\\n                if count_b >0:\\n                    count_b-=1\\n                    min_deleted+=1\\n                else:\\n                    count_a += 1\\n            elif s[i] == \"b\":\\n                count_b +=1\\n\\n        return min_deleted\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958325,
                "title": "c-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n            int countb=0;\\n            int ans=0;\\n            for(auto i:s)\\n            {\\n                if(i==\\'b\\')\\n                countb++;\\n                if(i==\\'a\\' && countb>0)\\n                {\\n                    ans++;\\n                    countb--;\\n                }\\n            }\\n        return ans;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n            int countb=0;\\n            int ans=0;\\n            for(auto i:s)\\n            {\\n                if(i==\\'b\\')\\n                countb++;\\n                if(i==\\'a\\' && countb>0)\\n                {\\n                    ans++;\\n                    countb--;\\n                }\\n            }\\n        return ans;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1895764,
                "content": [
                    {
                        "username": "Aayush65",
                        "content": "Can anybody tell me why is this giving TLE, when that same (61st test case) is running in 300ms when run in the console.\\nCode:\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        \\n        memo = {}\\n        def dp(l: int, r: int) -> int:\\n            if (l, r) in memo:\\n                return memo[(l, r)]\\n            key = (l, r)\\n            while l < r and s[l] == \\'a\\':\\n                l += 1\\n            while r > l and s[r] == \\'b\\':\\n                r -= 1\\n            if l == r:\\n                return 0\\n            res = 1 + min(dp(l + 1, r), dp(l, r - 1))\\n            memo[key] = res\\n            return res\\n            \\n        return dp(0, len(s) - 1)\\n```"
                    },
                    {
                        "username": "vishalgunawad",
                        "content": "what is the (61st test case) ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Jumps to Reach Home",
        "question_content": "<p>A certain bug&#39;s home is on the x-axis at position <code>x</code>. Help them get there from position <code>0</code>.</p>\n\n<p>The bug jumps according to the following rules:</p>\n\n<ul>\n\t<li>It can jump exactly <code>a</code> positions <strong>forward</strong> (to the right).</li>\n\t<li>It can jump exactly <code>b</code> positions <strong>backward</strong> (to the left).</li>\n\t<li>It cannot jump backward twice in a row.</li>\n\t<li>It cannot jump to any <code>forbidden</code> positions.</li>\n</ul>\n\n<p>The bug may jump forward <strong>beyond</strong> its home, but it <strong>cannot jump</strong> to positions numbered with <strong>negative</strong> integers.</p>\n\n<p>Given an array of integers <code>forbidden</code>, where <code>forbidden[i]</code> means that the bug cannot jump to the position <code>forbidden[i]</code>, and integers <code>a</code>, <code>b</code>, and <code>x</code>, return <em>the minimum number of jumps needed for the bug to reach its home</em>. If there is no possible sequence of jumps that lands the bug on position <code>x</code>, return <code>-1.</code></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 3 jumps forward (0 -&gt; 3 -&gt; 6 -&gt; 9) will get the bug home.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\n<strong>Output:</strong> -1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> One jump forward (0 -&gt; 16) then one jump backward (16 -&gt; 7) will get the bug home.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= forbidden.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= a, b, forbidden[i] &lt;= 2000</code></li>\n\t<li><code>0 &lt;= x &lt;= 2000</code></li>\n\t<li>All the elements in <code>forbidden</code> are distinct.</li>\n\t<li>Position <code>x</code> is not forbidden.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 978357,
                "title": "c-bidirectional-bfs-solution-with-proof-for-search-upper-bound",
                "content": "The main difficulty with this problem is figuring out at what `x` should the search be terminated, since otherwise in the BFS one can keep adding `a` to infinity. Just for this part I think the problem should be labeled \"hard\"`. This problem is also unsolvabe without knowing Bezout\\'s Identity. \\n\\n**Proof that maximum search is capped at `stop = a+b+max(x, max(forbidden))`**:\\n\\nFirst thing to note is that all reachable positions must be a factor of `gcd(a,b)`. This is the result Bezout\\'s Identity (https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity). **Bezout\\'s Identity just states that for some integers `x`, `y`, `z`,`a`, `b`, `x*a+y*b = z*gcd(a,b)`.** \\n\\nWhat this means in the context of this problem, is that by applying `a` size steps forward `x` times and `b` size steps backward `y` times, we must reach some position that is a multiple of `gcd(a,b)`. This part is required to find an upper bound to the BFS search without guessing.\\n\\nFor this proof, there are two cases: `a  >= b` and `a < b`.\\n\\nThe first case is trivial. If `a  = b`, then there is no point going backwards. You will end up at the position you just came from. So if you cannot reach `x` before going beyond `x`, you cannot ever reach `x`. For `a > b`, if you go beyond `x` you can never go back to `x`. So the maximum search boundary for `a >= b` is at `x`, which is less than `stop`. \\n\\nSecond case is the real problem. If `a < b` then technically we can continuously add `a`, and still find some way  to retrace back, since we can keep adding `a` then minus `b` to go back `b-a` steps. However, this is only guaranteed if the path(s) back are not blocked by forbidden positions. Thus to verify if a path is possible, we must at least search past `max(x, max(forbidden))`. \\n\\nPast `max(x, max(forbidden)`, at some point you will start hitting repeat positions. For example, you can reach some position `pos` by going forward once, or by going a few steps forward and some back to reach the same position (this is guaranteed by Bezout\\'s Identity). But the latter should not be considered since you can already reach `pos` in 1 step. This is where the repeats come in. There are an infinitely number of ways to reach `pos`, but only the shortest needs to be considered. \\n\\nSo at what point does the paths start repeating? First we need to find the starting point. Assume `max_ = max(x, max(forbidden))`. The first reachable position is the first pos `p0 = n*gcd(a,b)` such that `p > max_`. Using this definition we can say that all positions `p = p0 + m*gcd(a,b), m >= 0` are reachable. \\n\\nThe next step is to figure when do we stop (for what `m` do we not continue). The intuition is that regardless of how far you  venture out, eventually you need to come back. Otherwise you won\\'t reach `x`. Initially, you must start before `max_`. Since you can only go forward `a`, you will end up at some position `(max_, max_+a]`. Since `gcd(a,b)` is a multiple of `a`, we can say that the positions we can first reach are `[p0, p0+gcd(a,b), p0+2*gcd(a,b), ... p0+a-gcd(a,b)]`. For these positions, we can reach them from \"beyond\" by going back `b`. Thus the positions we can come back from are `gcd(a,b)` multiples in range `[p0+b, p0+a-gcd(a,b)+b]`. This also means that `p0+a-gcd(a,b)+b` is the bound we should stop searching at. This is because of the repeats. We can reach `[p0, p0+a-gcd(a,b)]` from `[p0+b, p0+a-gcd(a,b)+b]` by going back one step. Anything beyond `p0+a-gcd(a,b)+b` will take **at least** 4 or more steps. First you have to go forward `a` to go beyond `p0+a-gcd(a,b)+b`, so you at least end up at `p0+a-gcd(a,b)+b+gcd(a,b) = p0+a+b`, then you go back `b`, and end up at `p0+a > p0+a-gcd(a,b)`. So now you have to at least do another cycle (go forward `a`, go back `b`) to arrive at `p0+a-b`, and in the best scenario `b > gcd(a,b)` you end up in `[p0, p0+a-gcd(a,b)]`. This shows that venturing beyond `p0+a-gcd(a,b)+b` will always lead to higher step count, and thus this is the stopping bound. \\n\\nSo now we know that the maximum boundary is `p0+a-gcd(a,b)+b`. Using description of `p0`, we can say `p0 = max_ + delta = c*gcd(a,b)`, where `delta <= gcd(a,b)`. Thus, we can create an upperbound for `p0` using `p0 = max_ + delta = max_ + gcd(a,b)`. This leads to the upper bound `p0+a-gcd(a,b)+b = max_+gcd(a,b)+a-gcd(a,b)+b = max_+a+b = a+b+max(x, max(forbidden)`. \\n\\n\\nRun-time is `O(max(x,max(forbidden))+a+b)+len(forbiddend)`, space is `O(max(x,max(forbidden))+a+b+len(forbidden))`. \\n\\n```\\n#define B_MASK 14\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        int g{std::gcd(a, b)};\\n        \\n        if(x % g) return -1; // No non-negative integers c1,c2 such that c1*a - c2*b == x\\n        int max_{x};\\n        std::bitset<1<<15> invalid;\\n        for(const auto &n: forbidden) max_ = std::max(max_, n), invalid.set(n);\\n        b\\n        int16_t stop{(int16_t)(max_+b+a)};\\n        \\n        /* Bidirectional BFS, good for when both start and end states are known, and the edge definition is \"bidirectional\"\\n\\t\\t   aka for edge \"a <--> b\", at \"a\" you know you can go to \"b\", and at \"b\" you know you can come from \"a\".\\n\\t\\t  The definition need not be symmetric, such as in this problem. */\\n        std::queue<std::pair<int16_t,int16_t>> qS, qE;\\n        int stepS{0}, stepE{0};\\n        qS.emplace(0,0), qS.emplace(-1,-1);\\n        qE.emplace(x,0), qE.emplace(x, 1), qE.emplace(-1,-1);\\n        \\n        std::vector<int16_t> visitedS(1<<15, -1), visitedE(1<<15, -1);\\n        \\n        bool useS{true};\\n        while(!qS.empty() || !qE.empty()) {\\n            if(useS) {\\n                auto [loc, bc]{qS.front()}; qS.pop();\\n                if(loc == -1) {\\n                    if(!qS.empty()) ++stepS, qS.emplace(-1,-1);\\n                    if(qS.empty() || qS.size() >= qE.size() && !qE.empty()) useS = false;\\n                    continue;\\n                }\\n\\n                int16_t key = {(int16_t)(loc|(bc<<B_MASK))};\\n                if(visitedS[key] != -1) continue;\\n                visitedS[key] = stepS;\\n                if(visitedE[key] != -1) return stepS + visitedE[key];\\n                \\n                if(loc+a <= stop && !invalid[loc+a] && visitedS[(key+a)%(1<<B_MASK)] == -1) qS.emplace(loc+a, 0);\\n                if(!bc && loc-b > 0 && !invalid[loc-b] && visitedS[(key-b)|(1<<B_MASK)] == -1) qS.emplace(loc-b, 1);\\n                    \\n            } else {\\n                auto [loc, bc]{qE.front()}; qE.pop();\\n                if(loc == -1) {\\n                    if(!qE.empty()) ++stepE, qE.emplace(-1,-1);\\n                    if(qE.empty() || qE.size() >= qS.size() && !qS.empty()) useS = true;\\n                    continue;\\n                }\\n                \\n                int16_t key = {(int16_t)(loc|(bc<<B_MASK))};\\n                if(visitedE[key] != -1) continue;\\n                visitedE[key] = stepE;\\n                if(visitedS[key] != -1) return stepE + visitedS[key];\\n\\n                if(loc-a >= 0 && !invalid[loc-a] && visitedE[key-a] == -1) qE.emplace(loc-a, bc);\\n                if(bc && loc+b <= stop && !invalid[loc+b] && visitedE[(key+b)%(1<<B_MASK)] == -1) qE.emplace(loc+b, 0);\\n            }\\n            \\n        }\\n        \\n        return -1; \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define B_MASK 14\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        int g{std::gcd(a, b)};\\n        \\n        if(x % g) return -1; // No non-negative integers c1,c2 such that c1*a - c2*b == x\\n        int max_{x};\\n        std::bitset<1<<15> invalid;\\n        for(const auto &n: forbidden) max_ = std::max(max_, n), invalid.set(n);\\n        b\\n        int16_t stop{(int16_t)(max_+b+a)};\\n        \\n        /* Bidirectional BFS, good for when both start and end states are known, and the edge definition is \"bidirectional\"\\n\\t\\t   aka for edge \"a <--> b\", at \"a\" you know you can go to \"b\", and at \"b\" you know you can come from \"a\".\\n\\t\\t  The definition need not be symmetric, such as in this problem. */\\n        std::queue<std::pair<int16_t,int16_t>> qS, qE;\\n        int stepS{0}, stepE{0};\\n        qS.emplace(0,0), qS.emplace(-1,-1);\\n        qE.emplace(x,0), qE.emplace(x, 1), qE.emplace(-1,-1);\\n        \\n        std::vector<int16_t> visitedS(1<<15, -1), visitedE(1<<15, -1);\\n        \\n        bool useS{true};\\n        while(!qS.empty() || !qE.empty()) {\\n            if(useS) {\\n                auto [loc, bc]{qS.front()}; qS.pop();\\n                if(loc == -1) {\\n                    if(!qS.empty()) ++stepS, qS.emplace(-1,-1);\\n                    if(qS.empty() || qS.size() >= qE.size() && !qE.empty()) useS = false;\\n                    continue;\\n                }\\n\\n                int16_t key = {(int16_t)(loc|(bc<<B_MASK))};\\n                if(visitedS[key] != -1) continue;\\n                visitedS[key] = stepS;\\n                if(visitedE[key] != -1) return stepS + visitedE[key];\\n                \\n                if(loc+a <= stop && !invalid[loc+a] && visitedS[(key+a)%(1<<B_MASK)] == -1) qS.emplace(loc+a, 0);\\n                if(!bc && loc-b > 0 && !invalid[loc-b] && visitedS[(key-b)|(1<<B_MASK)] == -1) qS.emplace(loc-b, 1);\\n                    \\n            } else {\\n                auto [loc, bc]{qE.front()}; qE.pop();\\n                if(loc == -1) {\\n                    if(!qE.empty()) ++stepE, qE.emplace(-1,-1);\\n                    if(qE.empty() || qE.size() >= qS.size() && !qS.empty()) useS = true;\\n                    continue;\\n                }\\n                \\n                int16_t key = {(int16_t)(loc|(bc<<B_MASK))};\\n                if(visitedE[key] != -1) continue;\\n                visitedE[key] = stepE;\\n                if(visitedS[key] != -1) return stepE + visitedS[key];\\n\\n                if(loc-a >= 0 && !invalid[loc-a] && visitedE[key-a] == -1) qE.emplace(loc-a, bc);\\n                if(bc && loc+b <= stop && !invalid[loc+b] && visitedE[(key+b)%(1<<B_MASK)] == -1) qE.emplace(loc+b, 0);\\n            }\\n            \\n        }\\n        \\n        return -1; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935384,
                "title": "c-bfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\t\\tunordered_set<int> forbi(forbidden.begin(), forbidden.end());\\n\\t\\t\\tvector<vector<int>> visited(2,vector<int>(5000));\\n\\t\\t\\t// visited array has two states:\\n\\t\\t\\t// visited[0][i] means the ith cell was reached from its left hand side jumping forward, \\n\\t\\t\\t// visited[1][i] means the ith cell was reached from its right hand side jumping backward. \\n\\t\\t\\tqueue<pair<int,bool>> qu; \\n\\t\\t\\t// true means your last jump was backward jumping, you cannot jump backward in current step.\\n\\t\\t\\t// false, otherwise.\\n\\t\\t\\tqu.push({0,false});\\n\\t\\t\\tvisited[0][0] = 1;\\n\\t\\t\\tvisited[1][0] = 1;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\twhile(!qu.empty()) {\\n\\t\\t\\t\\tint len = qu.size();\\n\\t\\t\\t\\twhile(len > 0) {\\n\\t\\t\\t\\t\\tlen--;\\n\\t\\t\\t\\t\\tint cur = qu.front().first;\\n\\t\\t\\t\\t\\tbool flag = qu.front().second;\\n\\t\\t\\t\\t\\tif(cur == x) {\\n\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\t\\tif(forward < 5000 && visited[0][forward] == 0 && !forbi.count(forward)) {\\n\\t\\t\\t\\t\\t\\tqu.push({forward,false});\\n\\t\\t\\t\\t\\t\\tvisited[0][forward] = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(backward >=0 && visited[1][backward] == 0 && !forbi.count(backward) && !flag) {\\n\\t\\t\\t\\t\\t\\tqu.push({backward,true});\\n\\t\\t\\t\\t\\t\\tvisited[1][backward] = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\t\\tunordered_set<int> forbi(forbidden.begin(), forbidden.end());\\n\\t\\t\\tvector<vector<int>> visited(2,vector<int>(5000));\\n\\t\\t\\t// visited array has two states:\\n\\t\\t\\t// visited[0][i] means the ith cell was reached from its left hand side jumping forward, \\n\\t\\t\\t// visited[1][i] means the ith cell was reached from its right hand side jumping backward. \\n\\t\\t\\tqueue<pair<int,bool>> qu; \\n\\t\\t\\t// true means your last jump was backward jumping, you cannot jump backward in current step.\\n\\t\\t\\t// false, otherwise.\\n\\t\\t\\tqu.push({0,false}",
                "codeTag": "Java"
            },
            {
                "id": 936440,
                "title": "java-python-3-bfs-clean-codes-w-brief-explanation-and-analysis",
                "content": "**The key observation of the problem is that the variable to track the bug is a `vector`: direction and position.**\\n1. Use `0/True` and `1/False` to indicate forward and backward directions, respectively;\\n2. The bug at most need to reach `furthest = max(x, forbideen) + a + b` in order to arrive at `x`, hence the range of the position of the bug is `[0, furthest]`;\\n3. Use a Queue to maintain the vectors of the bug, use a Set to avoid forbidden positions and duplicates;\\n```java\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int steps = 0, furthest = x + a + b;\\n        Queue<Pair<Integer, Integer>> q = new LinkedList();\\n        q.offer(new Pair(0, 0)); // direction & position;\\n        Set<Pair<Integer, Integer>> seen = new HashSet<>(q);\\n        for (int pos : forbidden) {\\n            seen.add(new Pair(0, pos));\\n            seen.add(new Pair(1, pos));\\n            furthest = Math.max(furthest, pos + a + b);\\n        }\\n        while (!q.isEmpty()) {\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                Pair<Integer, Integer> p = q.poll();\\n                int dir = p.getKey(), pos = p.getValue();\\n                if (pos == x) {\\n                    return steps;\\n                }\\n                Pair<Integer, Integer> forward = new Pair<>(0, pos + a), backward = new Pair<>(1, pos - b);\\n                if (pos + a <= furthest && seen.add(forward)) {\\n                    q.offer(forward);\\n                }\\n                if (dir == 0 && pos - b >= 0 && seen.add(backward)) {\\n                    q.offer(backward);\\n                }\\n            }\\n            ++steps;\\n        }\\n        return -1;                \\n    }\\n```\\n```python\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        dq, seen, steps, furthest = deque([(True, 0)]), {(True, 0)}, 0, max(x, max(forbidden)) + a + b\\n        for pos in forbidden:\\n            seen.add((True, pos)) \\n            seen.add((False, pos)) \\n        while dq:\\n            for _ in range(len(dq)):\\n                dir, pos = dq.popleft()\\n                if pos == x:\\n                    return steps\\n                forward, backward = (True, pos + a), (False, pos - b)\\n                if pos + a <= furthest and forward not in seen:\\n                    seen.add(forward)\\n                    dq.append(forward)\\n                if dir and pos - b > 0 and backward not in seen:\\n                    seen.add(backward)\\n                    dq.append(backward)    \\n            steps += 1         \\n        return -1\\n```\\n\\n**Analysis:**\\n\\nTime & space: O(max(x, max(forbidden)) + a + b).",
                "solutionTags": [],
                "code": "```java\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int steps = 0, furthest = x + a + b;\\n        Queue<Pair<Integer, Integer>> q = new LinkedList();\\n        q.offer(new Pair(0, 0)); // direction & position;\\n        Set<Pair<Integer, Integer>> seen = new HashSet<>(q);\\n        for (int pos : forbidden) {\\n            seen.add(new Pair(0, pos));\\n            seen.add(new Pair(1, pos));\\n            furthest = Math.max(furthest, pos + a + b);\\n        }\\n        while (!q.isEmpty()) {\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                Pair<Integer, Integer> p = q.poll();\\n                int dir = p.getKey(), pos = p.getValue();\\n                if (pos == x) {\\n                    return steps;\\n                }\\n                Pair<Integer, Integer> forward = new Pair<>(0, pos + a), backward = new Pair<>(1, pos - b);\\n                if (pos + a <= furthest && seen.add(forward)) {\\n                    q.offer(forward);\\n                }\\n                if (dir == 0 && pos - b >= 0 && seen.add(backward)) {\\n                    q.offer(backward);\\n                }\\n            }\\n            ++steps;\\n        }\\n        return -1;                \\n    }\\n```\n```python\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        dq, seen, steps, furthest = deque([(True, 0)]), {(True, 0)}, 0, max(x, max(forbidden)) + a + b\\n        for pos in forbidden:\\n            seen.add((True, pos)) \\n            seen.add((False, pos)) \\n        while dq:\\n            for _ in range(len(dq)):\\n                dir, pos = dq.popleft()\\n                if pos == x:\\n                    return steps\\n                forward, backward = (True, pos + a), (False, pos - b)\\n                if pos + a <= furthest and forward not in seen:\\n                    seen.add(forward)\\n                    dq.append(forward)\\n                if dir and pos - b > 0 and backward not in seen:\\n                    seen.add(backward)\\n                    dq.append(backward)    \\n            steps += 1         \\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935419,
                "title": "python-deque-bfs-o-max-x-max-forbidden-a-b",
                "content": "The problem is actually quite straightforward. \\n\\nWe keep a deque *queue* of the positions to explore, and have an array *jumps* that records the number of jumps needed to reach the position. Forbidden positions in *jumps* are marked with -1.\\n\\nAt every step, we extract a position from *queue*. If we can make a jump forward - we update *jumps*, and add the new position to  *queue*.\\n\\nIf we can make the jump backward - we update *jumps*. As we cannot make two jumps backward, the *queue* is not updated. Instead, we check if we can make next jump forward (after the backward); if yes - we update *jumps* once again, and add the new position to  *queue*.\\n\\nFor performance, I use FIFO to extract positions from *queue*, because their required number of *jumps* is lower.\\n\\n**The role of *max_val***\\n\\nThis variable identifies the max. place for us to explore for solving the problem. It gives enough space after the last forbidden place or after *x* for the frog to try possible places. The basis for the formula is simple: the frog can freely jump backward from the last *a* spaces and not hit the forbidden, and if can jump forward from any of the b places after the last forbidden place.\\n\\nAssume that a=4, b=5. Let max. forbidden = 10. If we put the frog at any of the places in interval [11,19], it can jump to any of the places in the interval: e.g., 11->15->19->14->18->13->17->12->16->11.\\n\\nWe do need this feature, because if say forbidden = [1,2,3,5,6,7,10] and x=11, then the frog can jump to 11 only from 16, with the best path 0->4->8->12->16->11; thus, it needs that extra space beyond x and max(forbidden) to jump around.\\n\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \\n        max_val=max([x]+forbidden) +a+b\\n        \\n        jumps=[0]+[math.inf] * max_val\\n        for pos in forbidden: jumps[pos]=-1\\n        queue=deque([0])\\n        \\n        while queue:\\n            pos=queue.popleft()\\n            if pos+a<= max_val and jumps[pos+a]>jumps[pos]+1:\\n                queue.append(pos+a)\\n                jumps[pos+a]=jumps[pos]+1\\n            if pos-b>0 and  jumps[pos-b]>jumps[pos]+1:\\n                jumps[pos-b]=jumps[pos]+1\\n                if pos-b+a<= max_val and jumps[pos-b+a]>jumps[pos]+2:\\n                    queue.append(pos-b+a)\\n                    jumps[pos-b+a]=jumps[pos]+2\\n      \\n        return jumps[x] if jumps[x]<math.inf else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \\n        max_val=max([x]+forbidden) +a+b\\n        \\n        jumps=[0]+[math.inf] * max_val\\n        for pos in forbidden: jumps[pos]=-1\\n        queue=deque([0])\\n        \\n        while queue:\\n            pos=queue.popleft()\\n            if pos+a<= max_val and jumps[pos+a]>jumps[pos]+1:\\n                queue.append(pos+a)\\n                jumps[pos+a]=jumps[pos]+1\\n            if pos-b>0 and  jumps[pos-b]>jumps[pos]+1:\\n                jumps[pos-b]=jumps[pos]+1\\n                if pos-b+a<= max_val and jumps[pos-b+a]>jumps[pos]+2:\\n                    queue.append(pos-b+a)\\n                    jumps[pos-b+a]=jumps[pos]+2\\n      \\n        return jumps[x] if jumps[x]<math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159317,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    // to track the forbidden positions\\n    unordered_map<int,int>m;\\n    int dp[7001][2];\\n    int solve(int i,bool back,int a,int b,int x)\\n    {\\n        // base case\\n        if(i == x)return 0;\\n        // you cannot land on -ve n0.and blocked positions\\n        if( i < 0 || m.find(i)!= m.end() || i>6000 )\\n            return 1e9;\\n        \\n        \\n        if(dp[i][back]!=-1)return dp[i][back];\\n        int forward = 0;\\n        // either go forward \\n        dp[i][back] = 1 + solve(i+a,0,a,b,x);\\n        //go backward but cannot go consecutively 2 times\\n        if(!back)\\n        {\\n            dp[i][back] = min(dp[i][back],1 + solve(i-b,1,a,b,x));\\n        }\\n      \\n        return dp[i][back];\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        for(int i = 0 ; i<forbidden.size();i++)\\n            m[forbidden[i]] = 1;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(0,0,a,b,x);\\n        if(ans > 1e9)return -1;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    // to track the forbidden positions\\n    unordered_map<int,int>m;\\n    int dp[7001][2];\\n    int solve(int i,bool back,int a,int b,int x)\\n    {\\n        // base case\\n        if(i == x)return 0;\\n        // you cannot land on -ve n0.and blocked positions\\n        if( i < 0 || m.find(i)!= m.end() || i>6000 )\\n            return 1e9;\\n        \\n        \\n        if(dp[i][back]!=-1)return dp[i][back];\\n        int forward = 0;\\n        // either go forward \\n        dp[i][back] = 1 + solve(i+a,0,a,b,x);\\n        //go backward but cannot go consecutively 2 times\\n        if(!back)\\n        {\\n            dp[i][back] = min(dp[i][back],1 + solve(i-b,1,a,b,x));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 935504,
                "title": "java-bfs-and-dfs-solution",
                "content": "Trick:\\n1.Need monitor both index and direction\\n2.Can\\'t go back twice, so max is Math.max(max value in forbidden, 2000) + 2 * b;\\n\\nDFS\\n```\\nclass Solution {\\n    private Map<String/*idx + direction*/, Integer> cache;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        cache = new HashMap<>();\\n        Set<Integer> visited = new HashSet<>(); \\n        Set<Integer> forbit = new HashSet<>();\\n        int maxLimit = 2000 + 2 * b;\\n        for(int num : forbidden){\\n            forbit.add(num);\\n            maxLimit = Math.max(maxLimit, num + 2 * b);\\n        }\\n        int val = helper(0, x, a, b, forbit, visited, 0, maxLimit);\\n        return val == Integer.MAX_VALUE ? -1 : val;\\n    }\\n    private int helper(int idx, int x, int a, int b, Set<Integer> forbit, Set<Integer> visited, int dir, int maxLimit){\\n        if(cache.containsKey(idx+\",\"+dir)){\\n            return cache.get(idx+\",\"+dir);\\n        }\\n        if(idx == x) return 0;\\n        if(idx < 0 || idx > maxLimit) return Integer.MAX_VALUE;\\n        visited.add(idx);\\n        int min = Integer.MAX_VALUE;\\n\\t\\t//try jump forward\\n        if(idx+a < maxLimit && !forbit.contains(idx+a) && !visited.contains(idx+a)){\\n            int step = helper(idx+a, x, a, b, forbit, visited, 0, maxLimit);\\n            if(step != Integer.MAX_VALUE){\\n                min = Math.min(min, step + 1);\\n            }\\n        }\\n\\t\\t//try jump back\\n       if(idx-b >= 0 && !forbit.contains(idx-b) && !visited.contains(idx-b) && dir != 1){\\n            int step = helper(idx-b, x, a, b, forbit, visited, 1, maxLimit);\\n            if(step != Integer.MAX_VALUE){\\n                min = Math.min(min, step + 1);\\n            }\\n        }\\n        visited.remove(idx);\\n        cache.put(idx+\",\"+dir, min);\\n        return min;\\n    }\\n}\\n```\\nBFS\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a1,a2)-> a1[0] - a2[0]);\\n        pq.offer(new int[]{0,0,0});//step, current index, direction(0 is back, 1 is forward)\\n        Set<Integer> forbit = new HashSet<>();\\n        Set<String> visited = new HashSet<>();\\n        int maxLimit = 2000 + 2 * b;\\n        for(int num : forbidden){\\n            forbit.add(num);\\n            maxLimit = Math.max(maxLimit, num + 2 * b);\\n        }\\n        while(!pq.isEmpty()){\\n            int[] node = pq.poll();\\n            int step = node[0];\\n            int idx = node[1];\\n            int dir = node[2];\\n            if(idx == x) return step;\\n\\t\\t\\t//try jump forward\\n            if(idx+a < maxLimit && !forbit.contains(idx+a) && !visited.contains(idx+a+\",\"+0)){\\n                visited.add(idx+a+\",\"+0);\\n                pq.offer(new int[]{step+1, idx+a, 0});\\n            }\\n\\t\\t\\t//try jump back\\n            if(idx-b >= 0 && !forbit.contains(idx-b) && !visited.contains(idx-b+\",\"+1) && dir != 1){\\n                visited.add(idx-b+\",\"+1);\\n                pq.offer(new int[]{step+1, idx-b, 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private Map<String/*idx + direction*/, Integer> cache;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        cache = new HashMap<>();\\n        Set<Integer> visited = new HashSet<>(); \\n        Set<Integer> forbit = new HashSet<>();\\n        int maxLimit = 2000 + 2 * b;\\n        for(int num : forbidden){\\n            forbit.add(num);\\n            maxLimit = Math.max(maxLimit, num + 2 * b);\\n        }\\n        int val = helper(0, x, a, b, forbit, visited, 0, maxLimit);\\n        return val == Integer.MAX_VALUE ? -1 : val;\\n    }\\n    private int helper(int idx, int x, int a, int b, Set<Integer> forbit, Set<Integer> visited, int dir, int maxLimit){\\n        if(cache.containsKey(idx+\",\"+dir)){\\n            return cache.get(idx+\",\"+dir);\\n        }\\n        if(idx == x) return 0;\\n        if(idx < 0 || idx > maxLimit) return Integer.MAX_VALUE;\\n        visited.add(idx);\\n        int min = Integer.MAX_VALUE;\\n\\t\\t//try jump forward\\n        if(idx+a < maxLimit && !forbit.contains(idx+a) && !visited.contains(idx+a)){\\n            int step = helper(idx+a, x, a, b, forbit, visited, 0, maxLimit);\\n            if(step != Integer.MAX_VALUE){\\n                min = Math.min(min, step + 1);\\n            }\\n        }\\n\\t\\t//try jump back\\n       if(idx-b >= 0 && !forbit.contains(idx-b) && !visited.contains(idx-b) && dir != 1){\\n            int step = helper(idx-b, x, a, b, forbit, visited, 1, maxLimit);\\n            if(step != Integer.MAX_VALUE){\\n                min = Math.min(min, step + 1);\\n            }\\n        }\\n        visited.remove(idx);\\n        cache.put(idx+\",\"+dir, min);\\n        return min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a1,a2)-> a1[0] - a2[0]);\\n        pq.offer(new int[]{0,0,0});//step, current index, direction(0 is back, 1 is forward)\\n        Set<Integer> forbit = new HashSet<>();\\n        Set<String> visited = new HashSet<>();\\n        int maxLimit = 2000 + 2 * b;\\n        for(int num : forbidden){\\n            forbit.add(num);\\n            maxLimit = Math.max(maxLimit, num + 2 * b);\\n        }\\n        while(!pq.isEmpty()){\\n            int[] node = pq.poll();\\n            int step = node[0];\\n            int idx = node[1];\\n            int dir = node[2];\\n            if(idx == x) return step;\\n\\t\\t\\t//try jump forward\\n            if(idx+a < maxLimit && !forbit.contains(idx+a) && !visited.contains(idx+a+\",\"+0)){\\n                visited.add(idx+a+\",\"+0);\\n                pq.offer(new int[]{step+1, idx+a, 0});\\n            }\\n\\t\\t\\t//try jump back\\n            if(idx-b >= 0 && !forbit.contains(idx-b) && !visited.contains(idx-b+\",\"+1) && dir != 1){\\n                visited.add(idx-b+\",\"+1);\\n                pq.offer(new int[]{step+1, idx-b, 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950952,
                "title": "fast-python-and-c-solution-with-explanation-bfs",
                "content": "The objective is to find the minimum number of hops. BFS is the ideal candidate for this question since it will provide the shortest path.\\n**Solution:**\\n1. We start exploring from `0` position. \\n2. At each position, we can either go forward by `a` and go backward by `b`. Thing to note here is we cannot go backward twice in a row so we will maintain a flag `isForward` to signal if the previous jump was a `forward` jump.\\n3. If the previous jump was `isForward` then we have 2 positions we can go to from current position `pos` -> `pos+a` and `pos-b`\\n4. If the previous jump was not `isForward` then we  can go to 1 position only from current position `pos` -> `pos+a`\\n5. To avoid going to the same `pos` multiple times we will maintain a `visited` data-structure which will keep track of already visited positions. We will also add forbidden positions to this data structure.\\n6. The tricky bit is to figure out when the forward limit. Since the question mentions that the max x is 2000. The absolute limit is `2000 + a + b`. As anything beyond this limit will always be greater than x because there is only one backward move allowed. So any position above this limit will not be added to the search queue.\\n7. Keep exploring the positions in the `queue` until you reach destination `x` in which case `return hops` or until the `queue` is empty in which case `return -1`\\n\\nPython\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        limit = 2000 + a + b\\n        visited = set(forbidden)\\n        myque = collections.deque([(0, True)]) # (pos, isForward) \\n        hops = 0\\n        while(myque):\\n            l = len(myque)\\n            while(l > 0):\\n                l -= 1\\n                pos, isForward = myque.popleft()\\n                if pos == x:\\n                    return hops\\n                if pos in visited: continue\\n                visited.add(pos)\\n                if isForward:\\n                    nxt_jump = pos - b\\n                    if nxt_jump >= 0:\\n                        myque.append((nxt_jump, False))\\n                nxt_jump = pos + a\\n                if nxt_jump <= limit:\\n                    myque.append((nxt_jump, True))\\n            hops += 1\\n        return -1\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        int limit = 2000 + a + b;\\n        std::queue<std::pair<int, int>> cur;\\n        cur.push({0, 1});\\n        std::unordered_set<int> visited;\\n        for (auto& x : forbidden){\\n            visited.insert(x);\\n        }\\n        \\n        int hops = 0;\\n        while(!cur.empty()){\\n            int size = cur.size();\\n            while(size--){\\n                auto it = cur.front(); cur.pop();\\n                int num = it.first;\\n                int forward = it.second;\\n                if (num == x) return hops;\\n                if (visited.count(num) != 0)\\n                    continue;\\n                visited.insert(num);\\n                if (forward){\\n                    int nxt = num - b;\\n                    if (nxt >= 0){\\n                        cur.push({nxt, 0});\\n                    }\\n                }\\n                int nxt = num + a;\\n                if (nxt <= limit){\\n                    cur.push({nxt, 1});\\n                }\\n            }\\n            ++hops;\\n        }\\n        return -1;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        limit = 2000 + a + b\\n        visited = set(forbidden)\\n        myque = collections.deque([(0, True)]) # (pos, isForward) \\n        hops = 0\\n        while(myque):\\n            l = len(myque)\\n            while(l > 0):\\n                l -= 1\\n                pos, isForward = myque.popleft()\\n                if pos == x:\\n                    return hops\\n                if pos in visited: continue\\n                visited.add(pos)\\n                if isForward:\\n                    nxt_jump = pos - b\\n                    if nxt_jump >= 0:\\n                        myque.append((nxt_jump, False))\\n                nxt_jump = pos + a\\n                if nxt_jump <= limit:\\n                    myque.append((nxt_jump, True))\\n            hops += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935401,
                "title": "python-dfs-issue-with-121-test-case-solved",
                "content": "**UPD:**\\n\\nI believe I have found the issue: I should be able to go back more if my back step is larger than my forward step. Thanks to @ShidaLei\\n for pointing it out.\\n\\n----------------------------------------------------------------------------------------------------------------\\nUpdated, working DFS solution, still not 100% about the \"toofar\" condition, one possibly could come up with test cases where this still breaks:\\n```\\ndef minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n\\tforbidden = set(forbidden)\\n\\ttoofar = max(forbidden) + b if a < b else x\\n\\tminsofar = -1\\n\\n\\tposition_cost = {}  # only record the cost when jumping forward\\n\\tdef minjumps(cur_pos = 0, jumped_back = False, jumpsmade = 0):\\n\\t\\tnonlocal minsofar, toofar\\n\\t\\tif cur_pos < 0 or \\\\\\n\\t\\t   cur_pos in forbidden or \\\\\\n\\t\\t   cur_pos - b > toofar or \\\\\\n\\t\\t   minsofar > -1 and jumpsmade > minsofar: return \\n\\n\\t\\tif cur_pos == x:\\n\\t\\t\\tminsofar = jumpsmade if minsofar == -1 else min(minsofar, jumpsmade)\\n\\t\\t\\treturn\\n\\n\\t\\tif jumped_back: # can only jump forward at this point\\n\\t\\t\\tminjumps(cur_pos + a, False, jumpsmade + 1)\\n\\t\\t\\treturn\\n\\t\\telif cur_pos not in position_cost: position_cost[cur_pos] = jumpsmade\\n\\t\\telif jumpsmade >= position_cost[cur_pos]: return\\n\\t\\telse: position_cost[cur_pos] = jumpsmade\\n\\n\\t\\tminjumps(cur_pos + a, False, jumpsmade + 1)\\n\\t\\tminjumps(cur_pos - b, True, jumpsmade + 1)\\n\\n\\tminjumps()\\n\\treturn minsofar\\n```\\n\\nTest case, for which I used to end up with  `-1` instead of `121`:\\n```\\n[162,118,178,152,167,100,40,74,199,186,26,73,200,127,30,124,193,84,184,36,103,149,153,9,54,154,133,95,45,198,79,157,64,122,59,71,48,177,82,35,14,176,16,108,111,6,168,31,134,164,136,72,98]\\n29\\n98\\n80\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n\\tforbidden = set(forbidden)\\n\\ttoofar = max(forbidden) + b if a < b else x\\n\\tminsofar = -1\\n\\n\\tposition_cost = {}  # only record the cost when jumping forward\\n\\tdef minjumps(cur_pos = 0, jumped_back = False, jumpsmade = 0):\\n\\t\\tnonlocal minsofar, toofar\\n\\t\\tif cur_pos < 0 or \\\\\\n\\t\\t   cur_pos in forbidden or \\\\\\n\\t\\t   cur_pos - b > toofar or \\\\\\n\\t\\t   minsofar > -1 and jumpsmade > minsofar: return \\n\\n\\t\\tif cur_pos == x:\\n\\t\\t\\tminsofar = jumpsmade if minsofar == -1 else min(minsofar, jumpsmade)\\n\\t\\t\\treturn\\n\\n\\t\\tif jumped_back: # can only jump forward at this point\\n\\t\\t\\tminjumps(cur_pos + a, False, jumpsmade + 1)\\n\\t\\t\\treturn\\n\\t\\telif cur_pos not in position_cost: position_cost[cur_pos] = jumpsmade\\n\\t\\telif jumpsmade >= position_cost[cur_pos]: return\\n\\t\\telse: position_cost[cur_pos] = jumpsmade\\n\\n\\t\\tminjumps(cur_pos + a, False, jumpsmade + 1)\\n\\t\\tminjumps(cur_pos - b, True, jumpsmade + 1)\\n\\n\\tminjumps()\\n\\treturn minsofar\\n```\n```\\n[162,118,178,152,167,100,40,74,199,186,26,73,200,127,30,124,193,84,184,36,103,149,153,9,54,154,133,95,45,198,79,157,64,122,59,71,48,177,82,35,14,176,16,108,111,6,168,31,134,164,136,72,98]\\n29\\n98\\n80\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1137466,
                "title": "c-recursive-dp-40ms",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    int dp[6001][2];\\n    \\n    \\n    int helper(int i, bool back , int a ,int b, int x) {\\n        if(i == x)\\n            return 0;\\n        if(i<0 || i>6000 || back>=2 || mp.find(i)!=mp.end())\\n            return 1e9;\\n        if(dp[i][back] != -1) \\n            return dp[i][back];\\n        \\n        dp[i][back] = 1+helper(i+a,0,a,b,x); //go forward\\n        \\n        if(!back) //cannot go consecutively backwards more than 1\\n        {\\n        dp[i][back] = min(dp[i][back] , helper(i-b,1,a,b,x)+1);  \\n        \\n        }\\n        return dp[i][back];\\n    }\\n    \\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++){\\n            mp[forbidden[i]] = 1;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = helper(0,0,a,b,x);\\n        if(ans>1e9) \\n               return -1;\\n        return ans;               \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    int dp[6001][2];\\n    \\n    \\n    int helper(int i, bool back , int a ,int b, int x) {\\n        if(i == x)\\n            return 0;\\n        if(i<0 || i>6000 || back>=2 || mp.find(i)!=mp.end())\\n            return 1e9;\\n        if(dp[i][back] != -1) \\n            return dp[i][back];\\n        \\n        dp[i][back] = 1+helper(i+a,0,a,b,x); //go forward\\n        \\n        if(!back) //cannot go consecutively backwards more than 1\\n        {\\n        dp[i][back] = min(dp[i][back] , helper(i-b,1,a,b,x)+1);  \\n        \\n        }\\n        return dp[i][back];\\n    }\\n    \\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++){\\n            mp[forbidden[i]] = 1;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = helper(0,0,a,b,x);\\n        if(ans>1e9) \\n               return -1;\\n        return ans;               \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375366,
                "title": "c-simple-c-code-2-approach",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n**BFS**\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6002, vector<int> (2,0));\\n        if(x == 0) return 0;\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            dp[num][0]++;\\n            dp[num][1]++;\\n        }\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({0,1});\\n        if(dp[x][1]) return -1;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                pair<int, int> tp = q.front();\\n                q.pop();\\n                int val = tp.first;\\n                int ab = tp.second;\\n                if(val == x) return ans;\\n                if(ab)\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                    tmp = val - b;\\n                    if(tmp >= 0 && !dp[tmp][0])\\n                    {\\n                        q.push({tmp, 0});\\n                        dp[tmp][0]=1;\\n                    }\\n                }\\n                else\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**DFS**\\n```\\nclass Solution {\\n    unordered_map<int, int> um;\\n    int dfs(int a, int b, int x, int val, int pn, vector<vector<int>> &dp)\\n    {\\n        if(val == x) return 0;\\n        if(um.count(val)) return 6000;\\n        if(val < 0 || val > 6000) return 6000;\\n        if(dp[val][pn] != -1)\\n            return dp[val][pn];\\n        dp[val][pn] = 1 + dfs(a,b,x,val+a, 0, dp);\\n        if(pn == 0)\\n            dp[val][pn] = min(dp[val][pn], 1+dfs(a, b, x, val-b, 1,dp));\\n        return dp[val][pn];\\n    }\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6001, vector<int> (2, -1));\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            um[num]++;\\n        }\\n        int val = dfs(a, b, x, 0, 0, dp);\\n        if(val >= 6000) return -1;\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6002, vector<int> (2,0));\\n        if(x == 0) return 0;\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            dp[num][0]++;\\n            dp[num][1]++;\\n        }\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({0,1});\\n        if(dp[x][1]) return -1;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                pair<int, int> tp = q.front();\\n                q.pop();\\n                int val = tp.first;\\n                int ab = tp.second;\\n                if(val == x) return ans;\\n                if(ab)\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                    tmp = val - b;\\n                    if(tmp >= 0 && !dp[tmp][0])\\n                    {\\n                        q.push({tmp, 0});\\n                        dp[tmp][0]=1;\\n                    }\\n                }\\n                else\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    unordered_map<int, int> um;\\n    int dfs(int a, int b, int x, int val, int pn, vector<vector<int>> &dp)\\n    {\\n        if(val == x) return 0;\\n        if(um.count(val)) return 6000;\\n        if(val < 0 || val > 6000) return 6000;\\n        if(dp[val][pn] != -1)\\n            return dp[val][pn];\\n        dp[val][pn] = 1 + dfs(a,b,x,val+a, 0, dp);\\n        if(pn == 0)\\n            dp[val][pn] = min(dp[val][pn], 1+dfs(a, b, x, val-b, 1,dp));\\n        return dp[val][pn];\\n    }\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6001, vector<int> (2, -1));\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            um[num]++;\\n        }\\n        int val = dfs(a, b, x, 0, 0, dp);\\n        if(val >= 6000) return -1;\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357034,
                "title": "c-bfs",
                "content": "simple bfs with only constraint to check previous step. 1 and 0 indicate backward and forward .\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int> v;\\n        queue<pair<int,int>> q; \\n        for(auto i:forbidden){\\n            v[i]=true;\\n        }\\n        q.push({0,0}) ; \\n        int ans = 0;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            while(size--){\\n                auto curr = q.front() ;\\n                q.pop() ;\\n                int num = curr.first;\\n                if(num == x){\\n                    return ans;\\n                }\\n               \\n                if(v[num] == true){\\n                    continue;\\n                } \\n                v[num]=true;\\n                if(curr.second == 0 && num-b>=0) {\\n                    q.push({(num-b),1});\\n                }\\n                if(num <= 2000+b){\\n                    q.push({(num+a),0});                 \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int> v;\\n        queue<pair<int,int>> q; \\n        for(auto i:forbidden){\\n            v[i]=true;\\n        }\\n        q.push({0,0}) ; \\n        int ans = 0;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            while(size--){\\n                auto curr = q.front() ;\\n                q.pop() ;\\n                int num = curr.first;\\n                if(num == x){\\n                    return ans;\\n                }\\n               \\n                if(v[num] == true){\\n                    continue;\\n                } \\n                v[num]=true;\\n                if(curr.second == 0 && num-b>=0) {\\n                    q.push({(num-b),1});\\n                }\\n                if(num <= 2000+b){\\n                    q.push({(num+a),0});                 \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966234,
                "title": "c-easy-to-understand-recursive-memoized-code-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    const int inf = 1e9;\\n  \\n    unordered_set<int> set;\\n  \\n    int dp[6005][2];\\n  \\n    int go(int pos, int target, int fwd, int bwd, int cnt)\\n    {\\n      if(pos == target)\\n        return 0;\\n      \\n      if(set.find(pos) != set.end() or pos < 0 or pos > 6000)\\n        return inf;\\n      \\n      if(dp[pos][cnt] != -1)\\n          return dp[pos][cnt];\\n      \\n      dp[pos][cnt] = 1 + go(pos + fwd, target, fwd, bwd, 0);\\n      dp[pos][cnt] = min(dp[pos][cnt],  (cnt) ? 1 + go(pos + fwd, target, fwd, bwd, 0) : 1 + go(pos - bwd, target, fwd, bwd, 1));\\n      \\n      return dp[pos][cnt];\\n    }\\n  \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n      for(int ele : forbidden)\\n        set.insert(ele);\\n      \\n      memset(dp, -1, sizeof dp);\\n      int ans = go(0, x, a, b, 0);\\n      return (ans >= 1e9) ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int inf = 1e9;\\n  \\n    unordered_set<int> set;\\n  \\n    int dp[6005][2];\\n  \\n    int go(int pos, int target, int fwd, int bwd, int cnt)\\n    {\\n      if(pos == target)\\n        return 0;\\n      \\n      if(set.find(pos) != set.end() or pos < 0 or pos > 6000)\\n        return inf;\\n      \\n      if(dp[pos][cnt] != -1)\\n          return dp[pos][cnt];\\n      \\n      dp[pos][cnt] = 1 + go(pos + fwd, target, fwd, bwd, 0);\\n      dp[pos][cnt] = min(dp[pos][cnt],  (cnt) ? 1 + go(pos + fwd, target, fwd, bwd, 0) : 1 + go(pos - bwd, target, fwd, bwd, 1));\\n      \\n      return dp[pos][cnt];\\n    }\\n  \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n      for(int ele : forbidden)\\n        set.insert(ele);\\n      \\n      memset(dp, -1, sizeof dp);\\n      int ans = go(0, x, a, b, 0);\\n      return (ans >= 1e9) ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935424,
                "title": "java-bfs-there-should-be-2-states-for-the-bfs-expansion",
                "content": "Mose people failing some test case is beacuse they use one state. \\nThere should be two state for the expansion :[currentPos,direction]\\n\\n`Additional Question` : why we can beak the position if we pass certain limit?\\nWe must considerate **Two Case**: a>b and  b>a\\n\\n1. if a>b, since we can go backward only 1 time,if x pass certain limit, after we do pos-b, the next step is always pos+a, which will increase the position further, the pos will only keep increasing and we can never go back\\n2. if b>a, in this case, since the backward is larger, we can go back by  at most  (b-a).  Let\\'s say out current pos is Y(Y>x,if not, just go forward).We want to reach x and (Y-x)%(b-a)=0.We may do (Y-x)/(b-a) steps. Y=(b-a)*x. We can see at some point, we can bound the Y \\n\\n\\n\\n```\\nclass Solution {\\n    Set<Integer>bad=new HashSet<>();\\n    Set<String>set=new HashSet<>();\\n    public int minimumJumps(int[] A, int a, int b, int x) {\\n        for(int i:A){\\n            bad.add(i);\\n        }\\n        \\n        Queue<int[]>q=new LinkedList<>();\\n        q.add(new int[]{0,0,0});\\n        set.add(\"0,0\");\\n        while(q.size()!=0){\\n            int pair[]=q.poll();\\n            \\n            int pos=pair[0],level=pair[1],state=pair[2];\\n            if(pos==x)return level;\\n            \\n            if(state>=0){\\n                if(pos<=10000&&!set.contains((pos+a)+\",0\")&&!bad.contains(pos+a)){\\n                    set.add((pos+a)+\",0\");\\n                    q.add(new int[]{pos+a,level+1,0});\\n                }\\n                \\n                if(!set.contains((pos-b)+\",-1\")&&!bad.contains(pos-b)&&pos-b>=0){\\n                    set.add((pos-b)+\",-1\");\\n                    q.add(new int[]{pos-b,level+1,-1});\\n                }\\n            }\\n            else if(state<0){\\n                if(pos<=10000&&!set.contains((pos+a)+\",0\")&&!bad.contains(pos+a)){\\n                    set.add((pos+a)+\",0\");\\n                    q.add(new int[]{pos+a,level+1,0});\\n                }\\n               \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Set<Integer>bad=new HashSet<>();\\n    Set<String>set=new HashSet<>();\\n    public int minimumJumps(int[] A, int a, int b, int x) {\\n        for(int i:A){\\n            bad.add(i);\\n        }\\n        \\n        Queue<int[]>q=new LinkedList<>();\\n        q.add(new int[]{0,0,0});\\n        set.add(\"0,0\");\\n        while(q.size()!=0){\\n            int pair[]=q.poll();\\n            \\n            int pos=pair[0],level=pair[1],state=pair[2];\\n            if(pos==x)return level;\\n            \\n            if(state>=0){\\n                if(pos<=10000&&!set.contains((pos+a)+\",0\")&&!bad.contains(pos+a)){\\n                    set.add((pos+a)+\",0\");\\n                    q.add(new int[]{pos+a,level+1,0});\\n                }\\n                \\n                if(!set.contains((pos-b)+\",-1\")&&!bad.contains(pos-b)&&pos-b>=0){\\n                    set.add((pos-b)+\",-1\");\\n                    q.add(new int[]{pos-b,level+1,-1});\\n                }\\n            }\\n            else if(state<0){\\n                if(pos<=10000&&!set.contains((pos+a)+\",0\")&&!bad.contains(pos+a)){\\n                    set.add((pos+a)+\",0\");\\n                    q.add(new int[]{pos+a,level+1,0});\\n                }\\n               \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943895,
                "title": "c-bfs-solution",
                "content": "```\\n// visited table is desgined for two conditions:\\n// visited when can go backward/can\\'t go backward\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> forbidIndex;\\n        for(auto f:forbidden){\\n            forbidIndex.insert(f);\\n        }\\n        vector<pair<bool,bool>> visited(6000, {false, false}); // visited when can go back, when can\\'t\\n        visited[0].first = true;\\n        queue<pair<int, bool>> q; // {current index, if prev step is jump backward}\\n        q.push({0, false});\\n        int stepCount = 0;\\n        while(q.size()){\\n            int size = q.size();\\n            while(size--){\\n                int curIndex = q.front().first;\\n                bool prevBackWard = q.front().second;\\n                q.pop();\\n                if(curIndex == x){\\n                    return stepCount;\\n                }else{\\n                    int nextIndex = curIndex+a;\\n                    if(nextIndex < 6000 && forbidIndex.count(nextIndex)==0 && !visited[nextIndex].first){\\n                        q.push({nextIndex, false});\\n                        visited[nextIndex].first = true;\\n                    }\\n                    if(!prevBackWard){ // we can jump backward now!\\n                        nextIndex = curIndex-b;\\n                        if(nextIndex > 0 && forbidIndex.count(nextIndex)==0 && !visited[nextIndex].second){\\n                            q.push({nextIndex, true});\\n                            visited[nextIndex].second = true;\\n                        }\\n                    }\\n                }\\n            }\\n            stepCount++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n// visited table is desgined for two conditions:\\n// visited when can go backward/can\\'t go backward\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> forbidIndex;\\n        for(auto f:forbidden){\\n            forbidIndex.insert(f);\\n        }\\n        vector<pair<bool,bool>> visited(6000, {false, false}); // visited when can go back, when can\\'t\\n        visited[0].first = true;\\n        queue<pair<int, bool>> q; // {current index, if prev step is jump backward}\\n        q.push({0, false});\\n        int stepCount = 0;\\n        while(q.size()){\\n            int size = q.size();\\n            while(size--){\\n                int curIndex = q.front().first;\\n                bool prevBackWard = q.front().second;\\n                q.pop();\\n                if(curIndex == x){\\n                    return stepCount;\\n                }else{\\n                    int nextIndex = curIndex+a;\\n                    if(nextIndex < 6000 && forbidIndex.count(nextIndex)==0 && !visited[nextIndex].first){\\n                        q.push({nextIndex, false});\\n                        visited[nextIndex].first = true;\\n                    }\\n                    if(!prevBackWard){ // we can jump backward now!\\n                        nextIndex = curIndex-b;\\n                        if(nextIndex > 0 && forbidIndex.count(nextIndex)==0 && !visited[nextIndex].second){\\n                            q.push({nextIndex, true});\\n                            visited[nextIndex].second = true;\\n                        }\\n                    }\\n                }\\n            }\\n            stepCount++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935517,
                "title": "simple-concise-cpp-bfs",
                "content": "```\\nusing tup = tuple<int, int, bool>; // location, count, previous_jump(forward or backward)\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<tup> que; // forward true\\n        set<pair<int, bool>> seen; //previous jump direction with its location\\n        que.push({0, 0, true});\\n        for (int i : forbidden) \\n            seen.insert({i, true}), seen.insert({i, false});\\n        while (!que.empty()) {\\n            auto [loc, count, forward] = que.front();\\n            que.pop();\\n            if (loc == x) \\n                return count;\\n            else if (seen.count({loc, forward}) || loc > 6000)\\n                continue;\\n            seen.insert({loc, forward});\\n            que.push({loc + a, count + 1, true});\\n            if (forward && loc >= b)\\n                que.push({loc - b, count + 1, false});\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nusing tup = tuple<int, int, bool>; // location, count, previous_jump(forward or backward)\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<tup> que; // forward true\\n        set<pair<int, bool>> seen; //previous jump direction with its location\\n        que.push({0, 0, true});\\n        for (int i : forbidden) \\n            seen.insert({i, true}), seen.insert({i, false});\\n        while (!que.empty()) {\\n            auto [loc, count, forward] = que.front();\\n            que.pop();\\n            if (loc == x) \\n                return count;\\n            else if (seen.count({loc, forward}) || loc > 6000)\\n                continue;\\n            seen.insert({loc, forward});\\n            que.push({loc + a, count + 1, true});\\n            if (forward && loc >= b)\\n                que.push({loc - b, count + 1, false});\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144639,
                "title": "java-bfs-with-details-explanation",
                "content": "Basically, this is a BFS issue, but the details make me crazy.\\n\\nBasically, the idea here is that :\\n- Start from index : 0 with direction forward ( you can set to backward too, if you want)\\n- Go to the next idx  with step `a` and `b`,  but we need to make sure \\n\\t- index  > 0\\n\\t-  if we move backward,  should no backward in a row\\n\\n\\nWith below thought in mind, you will be easily come with below solution:\\n## BFS initial version\\n\\n```\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<Integer> visitedIdx = new HashSet<>();\\n        int steps = 0;\\n        \\n        for (int f : forbidden) {\\n            visitedIdx.add(f);\\n        }\\n        \\n        q.offer(new int[]{0, 1});\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                \\n                int[] cur = q.poll();\\n                int value = cur[0];\\n                int direction = cur[1];\\n             \\n                if (!visitedIdx.contains(value) ) {\\n                    visitedIdx.add(value);\\n                    \\n                    if (value == x) {\\n                        return steps;\\n                    }\\n                    \\n                    if (value + a > 0 && !visitedIdx.contains(value + a)) {\\n                        q.offer(new int[]{value + a, 1});\\n                    }\\n                    \\n                    if (value - b > 0  && !visitedIdx.contains(value - b) && direction != 0) {\\n                        q.offer(new int[]{value - b, 0});\\n                    }\\n                    \\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n```\\n\\n#### issues \\n- you will get timeout for most of the case\\n\\n\\n##### solution\\n- we missed quit conditions in the for loop, so put `value <= 6000` , explantion can be found in the below part.\\n- the change can fixed some failed case, but the funny things is \\n\\n```\\n-  If i change the value 6000 to 6500, some cases passed when value <= 6000 failed after change the value to 6500.\\n \\n```\\n\\nAfter adding logs in the code, there is one impartant thing for the `visitedIdx` is that : \\n```\\nvisitedIdx  * *MUST* * contains the directions, because the same index can be visited both forward and backward, if we simply check the index without direction, we will lose the half possiblity. which can cause the result to -1.\\n\\n```\\n\\n## Final Version\\n\\n```\\n        //using BFS to find the target index, \\n        // first value indicate the idx, second value indicate the direction(0: back, 1: forward)\\n        \\n        // MOST important: for the visited set , we need to save the direction and idx, or we will lose the answer\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<List<Integer>> visitedIdx = new HashSet<>();\\n        int steps = 0;\\n        \\n        for (int f : forbidden) {\\n            visitedIdx.add(Arrays.asList(f, 1));\\n            visitedIdx.add(Arrays.asList(f, 0));\\n        }\\n        \\n        q.offer(new int[]{0, 1});\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                \\n                int[] cur = q.poll();\\n                int value = cur[0];\\n                int direction = cur[1];\\n                \\n                List<Integer> node = Arrays.asList(value, direction);\\n                \\n                \\n                // the reason why 6000 is becase: target x is max 2000, and a max 2000, \\n                // that means, x + a with max value to x + a + a \\n                if (!visitedIdx.contains(node) && value <= 6000) {\\n                    visitedIdx.add(node);\\n                    \\n                    if (value == x) {\\n                        return steps;\\n                    }\\n                    \\n                    if (value + a > 0 && !visitedIdx.contains(Arrays.asList(value + a, 1))) {\\n                        q.offer(new int[]{value + a, 1});\\n                    }\\n                    \\n                    if (value - b > 0  && !visitedIdx.contains(Arrays.asList(value - b, 0)) && direction != 0) {\\n                        q.offer(new int[]{value - b, 0});\\n                    }\\n                    \\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n```",
                "solutionTags": [],
                "code": "```\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<Integer> visitedIdx = new HashSet<>();\\n        int steps = 0;\\n        \\n        for (int f : forbidden) {\\n            visitedIdx.add(f);\\n        }\\n        \\n        q.offer(new int[]{0, 1});\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                \\n                int[] cur = q.poll();\\n                int value = cur[0];\\n                int direction = cur[1];\\n             \\n                if (!visitedIdx.contains(value) ) {\\n                    visitedIdx.add(value);\\n                    \\n                    if (value == x) {\\n                        return steps;\\n                    }\\n                    \\n                    if (value + a > 0 && !visitedIdx.contains(value + a)) {\\n                        q.offer(new int[]{value + a, 1});\\n                    }\\n                    \\n                    if (value - b > 0  && !visitedIdx.contains(value - b) && direction != 0) {\\n                        q.offer(new int[]{value - b, 0});\\n                    }\\n                    \\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n```\n```\\n-  If i change the value 6000 to 6500, some cases passed when value <= 6000 failed after change the value to 6500.\\n \\n```\n```\\nvisitedIdx  * *MUST* * contains the directions, because the same index can be visited both forward and backward, if we simply check the index without direction, we will lose the half possiblity. which can cause the result to -1.\\n\\n```\n```\\n        //using BFS to find the target index, \\n        // first value indicate the idx, second value indicate the direction(0: back, 1: forward)\\n        \\n        // MOST important: for the visited set , we need to save the direction and idx, or we will lose the answer\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<List<Integer>> visitedIdx = new HashSet<>();\\n        int steps = 0;\\n        \\n        for (int f : forbidden) {\\n            visitedIdx.add(Arrays.asList(f, 1));\\n            visitedIdx.add(Arrays.asList(f, 0));\\n        }\\n        \\n        q.offer(new int[]{0, 1});\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                \\n                int[] cur = q.poll();\\n                int value = cur[0];\\n                int direction = cur[1];\\n                \\n                List<Integer> node = Arrays.asList(value, direction);\\n                \\n                \\n                // the reason why 6000 is becase: target x is max 2000, and a max 2000, \\n                // that means, x + a with max value to x + a + a \\n                if (!visitedIdx.contains(node) && value <= 6000) {\\n                    visitedIdx.add(node);\\n                    \\n                    if (value == x) {\\n                        return steps;\\n                    }\\n                    \\n                    if (value + a > 0 && !visitedIdx.contains(Arrays.asList(value + a, 1))) {\\n                        q.offer(new int[]{value + a, 1});\\n                    }\\n                    \\n                    if (value - b > 0  && !visitedIdx.contains(Arrays.asList(value - b, 0)) && direction != 0) {\\n                        q.offer(new int[]{value - b, 0});\\n                    }\\n                    \\n                }\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935575,
                "title": "python-bfs-with-detailed-explanation",
                "content": "The basic setup is to do a BFS starting from position 0, and according to the rules, try to move forward or backward till we reach x. However, there are a few catches:\\n1. We cannot move backward twice in a row. To handle this, we store the state in the queue as `(0,1)` where the first element is the position and the second element is the direction of the last move. If the previous move was in the forward direction, then we can try the backwards direction.\\n2. We may land on the same position (`z`) either by moving forward (`p1 + a = z`) or backward (`p2 - b = z`). To handle this, we will iterate through the queue twice, and process all forward jumps first, then the backward jumps. The reason is because the forward jumps have no restrictions and we land on the same position, so we lose nothing by keeping only the forward jumps.\\n3. We need to bound the positions we search, otherwise the code will run forever. For the lower bound, it is given by the question that we cannot visit negative integers. For the upper bound, it is given by `max(x, max(forbidden)) + a + b`. This value is the largest position that we should explore such that it may be possible to backtrack to the bug\\'s home. For example, `a = 2, b = 3, forbidden = [7], x = 9`. We will take the path: `2 -> 4 -> 6 -> 8 -> 10 -> 12 -> 9`. Thus, at the very end we may need to go past our destination and then backtrack. We need to take into account both `x` and `max(forbidden)` because `max(forbidden)` can be insignificant or e.g. the following input: `forbidden = [10], a = 20, b = 19, x = 101`.\\n\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = deque([(0,1)])\\n        jumps = 0\\n        forbidden = set(forbidden)\\n        forbidden.add(0)\\n        MAX_DIST = max(x, max(forbidden)) + a + b\\n        while queue:\\n            tmp = deque()\\n            for elem in queue:\\n                (pos, direction) = elem\\n                if pos == x: return jumps\\n                forward = pos + a\\n                if forward not in forbidden and forward <= MAX_DIST:\\n                    tmp.append((forward, 1))\\n                    forbidden.add(forward)\\n            for elem in queue:\\n                (pos, direction) = elem\\n                if pos == x: return jumps\\n                backward = pos - b\\n                if direction != -1 and backward >= 0 and backward not in forbidden:\\n                    tmp.append((backward, -1))\\n                    forbidden.add(backward)\\n            queue = tmp\\n            jumps += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = deque([(0,1)])\\n        jumps = 0\\n        forbidden = set(forbidden)\\n        forbidden.add(0)\\n        MAX_DIST = max(x, max(forbidden)) + a + b\\n        while queue:\\n            tmp = deque()\\n            for elem in queue:\\n                (pos, direction) = elem\\n                if pos == x: return jumps\\n                forward = pos + a\\n                if forward not in forbidden and forward <= MAX_DIST:\\n                    tmp.append((forward, 1))\\n                    forbidden.add(forward)\\n            for elem in queue:\\n                (pos, direction) = elem\\n                if pos == x: return jumps\\n                backward = pos - b\\n                if direction != -1 and backward >= 0 and backward not in forbidden:\\n                    tmp.append((backward, -1))\\n                    forbidden.add(backward)\\n            queue = tmp\\n            jumps += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748557,
                "title": "c-bfs-clear-and-concise-solution-with-comments-65-time-78-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n      unordered_map<int, int> um;\\n      for(auto &pos: forbidden){  // Adding all the forbidden positions\\n        um[pos]++;\\n      }\\n      queue<pair<int, pair<int, bool>>> q;  \\n\\t  // Queue will store the Position, Number of hops and \\n\\t  // a bool variable that will denote if the last hop was in\\n\\t  // forward direction or backward (True: forward, False: backward)\\n      q.push({0, {0, true}});\\n      while(!q.empty()){\\n        auto node = q.front();\\n        int currPos = node.first, ans = node.second.first;\\n        bool canGoBackwards = node.second.second;  \\n        q.pop();\\n        if(currPos == x) return ans;\\n\\t\\t// If the position is already visited we do not add forward and backward from that position\\n        if(um.find(currPos) != um.end()) continue;  \\n        um[currPos]++;\\n        int forward = currPos + a, backward = currPos - b;\\n        if(canGoBackwards and backward >= 0){\\n          q.push({backward, {ans + 1, false}});\\n        }\\n        if(forward <= 2000 + a + b){    // 1 <= a, b, forbidden[i] <= 2000\\n          // We can at max come backwards from (2000 + a + b) position to x position\\n          q.push({forward, {ans + 1, true}});\\n        }\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n      unordered_map<int, int> um;\\n      for(auto &pos: forbidden){  // Adding all the forbidden positions\\n        um[pos]++;\\n      }\\n      queue<pair<int, pair<int, bool>>> q;  \\n\\t  // Queue will store the Position, Number of hops and \\n\\t  // a bool variable that will denote if the last hop was in\\n\\t  // forward direction or backward (True: forward, False: backward)\\n      q.push({0, {0, true}});\\n      while(!q.empty()){\\n        auto node = q.front();\\n        int currPos = node.first, ans = node.second.first;\\n        bool canGoBackwards = node.second.second;  \\n        q.pop();\\n        if(currPos == x) return ans;\\n\\t\\t// If the position is already visited we do not add forward and backward from that position\\n        if(um.find(currPos) != um.end()) continue;  \\n        um[currPos]++;\\n        int forward = currPos + a, backward = currPos - b;\\n        if(canGoBackwards and backward >= 0){\\n          q.push({backward, {ans + 1, false}});\\n        }\\n        if(forward <= 2000 + a + b){    // 1 <= a, b, forbidden[i] <= 2000\\n          // We can at max come backwards from (2000 + a + b) position to x position\\n          q.push({forward, {ans + 1, true}});\\n        }\\n      }\\n      return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885961,
                "title": "c-bfs-easy-to-understand-solution",
                "content": "## **APPROACH**\\n* So consider this vector as graph and for any index i you have two options either to go right for exactly a steps  or left for exactly b steps  but you need to take care that no consectuve back steps(left) are taken.\\n* So to handle this we can keep track of last move in queue itself where before taking left step , we first check whether last move taken was in right or left.\\n* If lastMove was left , then only consider right step right now , but if lastMove was right , consider both left and right move.\\n* But now comes one more problem.\\n* Do we need to mark indexes as visited for both the steps?\\n* Actually not...\\n* See if you reach to some location **Q** through a backward step , now you cannot take one more backward , but it is possible that one backward is the place to reach **X** i.e the final destination.\\n* And also it is possible to reach **Q** from front taking a step and then one backward will reach to **X**.\\n* So to tackle this ,make sure to mark a point as visited only when you visit that from front direction and not from back direction.\\n\\n\\n## **CODE**\\u2714\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\n        unordered_set<int> visited(forbidden.begin(),forbidden.end());\\n        \\n        queue<pair<int,int>> q;  // here second value is what last move was taken\\n        q.push({0,1});          // 1 for to the right and -1 for left\\n        visited.insert(0);\\n        \\n        int level=0;\\n        while(!q.empty())\\n        {\\n            level++;\\n            int size=q.size();\\n            \\n            while(size--)\\n            {\\n                int u,lastMove;\\n                tie(u,lastMove)=q.front();\\n                q.pop();\\n                \\n                if(u==x)\\n                    return level-1;\\n                \\n                int forward=u+a;\\n                int backward=u-b;\\n                \\n                if(forward<=6000 && visited.find(forward)==visited.end())\\n                {\\n                    q.push({forward,1});\\n                    visited.insert(forward);  \\n                }\\n                \\n                if(lastMove==1 && backward>=0 && visited.find(backward)==visited.end() )\\n                {\\n                     q.push({backward,-1});\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n\\n### **TIME-COMPLEXITY :**\\nO(n) , n=6000\\nFor upper limit in right direction , took 6000 which is 3 times of maximum jump in right , not sure for this , how it works!!\\n### **SPACE-COMPLEXITY:**\\nO(n)",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\n        unordered_set<int> visited(forbidden.begin(),forbidden.end());\\n        \\n        queue<pair<int,int>> q;  // here second value is what last move was taken\\n        q.push({0,1});          // 1 for to the right and -1 for left\\n        visited.insert(0);\\n        \\n        int level=0;\\n        while(!q.empty())\\n        {\\n            level++;\\n            int size=q.size();\\n            \\n            while(size--)\\n            {\\n                int u,lastMove;\\n                tie(u,lastMove)=q.front();\\n                q.pop();\\n                \\n                if(u==x)\\n                    return level-1;\\n                \\n                int forward=u+a;\\n                int backward=u-b;\\n                \\n                if(forward<=6000 && visited.find(forward)==visited.end())\\n                {\\n                    q.push({forward,1});\\n                    visited.insert(forward);  \\n                }\\n                \\n                if(lastMove==1 && backward>=0 && visited.find(backward)==visited.end() )\\n                {\\n                     q.push({backward,-1});\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850544,
                "title": "c-solution-bfs-simple-commented",
                "content": "```\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t//to hold forbidden positions\\n\\tunordered_set<int> st{forbidden.begin(),forbidden.end()};\\n\\tqueue<pair<int,int>> Q;\\n\\t//pait {a,b} a---> position b----> last jump(forward===0 or backward==1)\\n\\tQ.push({0,0});\\n\\t//insert 0 in forbidden list\\n\\tst.insert(0);\\n\\tint steps=0;\\n\\twhile(!Q.empty()){\\n\\t\\tint s=Q.size();\\n\\t\\twhile(s--){\\n\\t\\t\\tint u=Q.front().first;\\n\\t\\t\\tint f=Q.front().second;\\n\\t\\t\\tQ.pop();\\n\\t\\t\\tif(u==x) return steps;\\n\\t\\t\\t//r---->forward jump,l----->backward jump\\n\\t\\t\\tint r=u+a,l=u-b;\\n\\t\\t\\t//backward jump only if previous jump is forward and position is not in forbidden list\\n\\t\\t\\tif(!f and l>=0 and !st.count(l)){\\n\\t\\t\\t\\tst.insert(l);\\n\\t\\t\\t\\tQ.push({l,1});\\n\\t\\t\\t}\\n\\t\\t\\t// As x,a,b take max values of 2000 each, max forward jump can be 6000\\n\\t\\t\\tif(r<=6000 and !st.count(r)){\\n\\t\\t\\t\\tst.insert(r);\\n\\t\\t\\t\\tQ.push({r,0});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsteps++;\\n\\t}\\n\\treturn -1;\\n}\\n```\\n\\n**Please upvote: )**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t//to hold forbidden positions\\n\\tunordered_set<int> st{forbidden.begin(),forbidden.end()};\\n\\tqueue<pair<int,int>> Q;\\n\\t//pait {a,b} a---> position b----> last jump(forward===0 or backward==1)\\n\\tQ.push({0,0});\\n\\t//insert 0 in forbidden list\\n\\tst.insert(0);\\n\\tint steps=0;\\n\\twhile(!Q.empty()){\\n\\t\\tint s=Q.size();\\n\\t\\twhile(s--){\\n\\t\\t\\tint u=Q.front().first;\\n\\t\\t\\tint f=Q.front().second;\\n\\t\\t\\tQ.pop();\\n\\t\\t\\tif(u==x) return steps;\\n\\t\\t\\t//r---->forward jump,l----->backward jump\\n\\t\\t\\tint r=u+a,l=u-b;\\n\\t\\t\\t//backward jump only if previous jump is forward and position is not in forbidden list\\n\\t\\t\\tif(!f and l>=0 and !st.count(l)){\\n\\t\\t\\t\\tst.insert(l);\\n\\t\\t\\t\\tQ.push({l,1});\\n\\t\\t\\t}\\n\\t\\t\\t// As x,a,b take max values of 2000 each, max forward jump can be 6000\\n\\t\\t\\tif(r<=6000 and !st.count(r)){\\n\\t\\t\\t\\tst.insert(r);\\n\\t\\t\\t\\tQ.push({r,0});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsteps++;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935774,
                "title": "python3-simple-bfs-100-faster-solution",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, t: int) -> int:\\n        if not t: return 0\\n        \\n        threshold = max(forbidden + [t]) + a + b\\n        forbidden = set(forbidden)\\n        seen = set([0])\\n        q = [[0,0]]\\n        \\n        while q:\\n            pos, steps = q.pop(0)\\n            \\n            if pos+a not in forbidden and pos+a not in seen and pos+a <= threshold: \\n                # Termination Condition\\n                if pos+a == t: return steps+1\\n                \\n                q.append([pos+a, steps+1])\\n                seen.add(pos+a)\\n                \\n            if pos-b > 0 and pos-b not in forbidden and pos-b not in seen: \\n                # Termination Condition\\n                if pos-b == t: return steps+1\\n                seen.add(pos-b)\\n                \\n                if pos-b+a not in forbidden and pos-b+a not in seen and pos-b+a <= threshold:\\n                    # Termination Condition\\n                    if pos-b+a == t: return steps+2\\n                    \\n                    q.append([pos-b+a, steps+2])\\n                    seen.add(pos-b+a)\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, t: int) -> int:\\n        if not t: return 0\\n        \\n        threshold = max(forbidden + [t]) + a + b\\n        forbidden = set(forbidden)\\n        seen = set([0])\\n        q = [[0,0]]\\n        \\n        while q:\\n            pos, steps = q.pop(0)\\n            \\n            if pos+a not in forbidden and pos+a not in seen and pos+a <= threshold: \\n                # Termination Condition\\n                if pos+a == t: return steps+1\\n                \\n                q.append([pos+a, steps+1])\\n                seen.add(pos+a)\\n                \\n            if pos-b > 0 and pos-b not in forbidden and pos-b not in seen: \\n                # Termination Condition\\n                if pos-b == t: return steps+1\\n                seen.add(pos-b)\\n                \\n                if pos-b+a not in forbidden and pos-b+a not in seen and pos-b+a <= threshold:\\n                    # Termination Condition\\n                    if pos-b+a == t: return steps+2\\n                    \\n                    q.append([pos-b+a, steps+2])\\n                    seen.add(pos-b+a)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935515,
                "title": "c-bfs",
                "content": "```\\npublic class Solution\\n{\\n    public int MinimumJumps(int[] forbidden, int a, int b, int x)\\n    {\\n        var invalid = new HashSet<int>(forbidden);\\n        var visited = new HashSet<(int,bool)>();\\n        var que = new Queue<(int Pos, bool IsBackward)>();\\n        que.Enqueue((0, false));\\n        int steps = 0;\\n        while (que.Count > 0)\\n        {\\n            int count = que.Count;\\n            while (count-- > 0)\\n            {\\n                var cur = que.Dequeue();\\n                if (cur.Pos == x) return steps;\\n                if(invalid.Contains(cur.Pos) || visited.Contains(cur)) continue;\\n                visited.Add(cur);\\n                if (cur.Pos + a <= 4000)\\n                    que.Enqueue((cur.Pos + a, false));\\n                if (cur.Pos - b >= 0 && !cur.IsBackward)\\n                    que.Enqueue((cur.Pos - b, true));                    \\n            }\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int MinimumJumps(int[] forbidden, int a, int b, int x)\\n    {\\n        var invalid = new HashSet<int>(forbidden);\\n        var visited = new HashSet<(int,bool)>();\\n        var que = new Queue<(int Pos, bool IsBackward)>();\\n        que.Enqueue((0, false));\\n        int steps = 0;\\n        while (que.Count > 0)\\n        {\\n            int count = que.Count;\\n            while (count-- > 0)\\n            {\\n                var cur = que.Dequeue();\\n                if (cur.Pos == x) return steps;\\n                if(invalid.Contains(cur.Pos) || visited.Contains(cur)) continue;\\n                visited.Add(cur);\\n                if (cur.Pos + a <= 4000)\\n                    que.Enqueue((cur.Pos + a, false));\\n                if (cur.Pos - b >= 0 && !cur.IsBackward)\\n                    que.Enqueue((cur.Pos - b, true));                    \\n            }\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605355,
                "title": "java-simple-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int n = forbidden.length;\\n        //2D boolean to keep track of forward and backward visits\\n        boolean[][] visited = new boolean[6000][2];\\n        if(x == 0) return 0;\\n        for(int i = 0; i < n; i++){\\n            //for forbidden numbers we can not go to them\\n            //either forward or backward moment\\n            visited[forbidden[i]][0] = true;\\n            visited[forbidden[i]][1] = true; \\n        }\\n        int ans = 0;\\n        //queue to perform bfs\\n        Queue<int[]> q = new LinkedList();\\n        //array as input to keep track of both backward andd forward moment\\n        q.add(new int[]{0, 0});\\n        while(q.size() > 0){\\n            int size = q.size();\\n            while(size-- > 0){\\n                int[] pos = q.poll();\\n                //not processing already visited numbers\\n                if(visited[pos[0]][pos[1]]) continue;\\n                visited[pos[0]][pos[1]] = true;\\n                //if home found we return ans\\n                if(pos[0] == x) return ans;\\n                //6000 is the maximum possible value for forward moment\\n                if(pos[0] + a < 6000){\\n                    //forward moment shown marked by 0\\n                    q.add(new int[]{pos[0] + a, 0});\\n                }\\n                //to restrict double backward moment we mark backward\\n                //moment by adding 1\\n                if(pos[0] - b >= 0 && pos[1] != 1){\\n                    q.add(new int[]{pos[0] - b, 1});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nPlease upvote if find helful",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int n = forbidden.length;\\n        //2D boolean to keep track of forward and backward visits\\n        boolean[][] visited = new boolean[6000][2];\\n        if(x == 0) return 0;\\n        for(int i = 0; i < n; i++){\\n            //for forbidden numbers we can not go to them\\n            //either forward or backward moment\\n            visited[forbidden[i]][0] = true;\\n            visited[forbidden[i]][1] = true; \\n        }\\n        int ans = 0;\\n        //queue to perform bfs\\n        Queue<int[]> q = new LinkedList();\\n        //array as input to keep track of both backward andd forward moment\\n        q.add(new int[]{0, 0});\\n        while(q.size() > 0){\\n            int size = q.size();\\n            while(size-- > 0){\\n                int[] pos = q.poll();\\n                //not processing already visited numbers\\n                if(visited[pos[0]][pos[1]]) continue;\\n                visited[pos[0]][pos[1]] = true;\\n                //if home found we return ans\\n                if(pos[0] == x) return ans;\\n                //6000 is the maximum possible value for forward moment\\n                if(pos[0] + a < 6000){\\n                    //forward moment shown marked by 0\\n                    q.add(new int[]{pos[0] + a, 0});\\n                }\\n                //to restrict double backward moment we mark backward\\n                //moment by adding 1\\n                if(pos[0] - b >= 0 && pos[1] != 1){\\n                    q.add(new int[]{pos[0] - b, 1});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978766,
                "title": "python3-bfs-easy-understanding",
                "content": "```\\ndef minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        visited = set()\\n        q = deque([(0, 0)])\\n        forbidden = set(forbidden)\\n        furthest = max(x, max(forbidden)) + a + b\\n        \\n        res = 0\\n        while q:\\n            n = len(q)\\n            for _ in range(n):\\n                p, is_back = q.popleft()\\n                if p in forbidden or (p, is_back) in visited or p < 0 or p > furthest:\\n                    continue\\n                if p == x:\\n                    return res \\n                visited.add((p, is_back))\\n                q.append((p + a, 0))\\n                if not is_back:\\n                    q.append((p - b, 1))\\n                \\n            res += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        visited = set()\\n        q = deque([(0, 0)])\\n        forbidden = set(forbidden)\\n        furthest = max(x, max(forbidden)) + a + b\\n        \\n        res = 0\\n        while q:\\n            n = len(q)\\n            for _ in range(n):\\n                p, is_back = q.popleft()\\n                if p in forbidden or (p, is_back) in visited or p < 0 or p > furthest:\\n                    continue\\n                if p == x:\\n                    return res \\n                visited.add((p, is_back))\\n                q.append((p + a, 0))\\n                if not is_back:\\n                    q.append((p - b, 1))\\n                \\n            res += 1\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1540090,
                "title": "simple-bfs-clean-concise-well-coded",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \\n        forbidden = set(forbidden)\\n        limit = max(x,max(forbidden))+a+b\\n        seen = set()\\n        q = [(0,0,False)]\\n        while q:\\n            p,s,isb = q.pop(0)\\n            if p>limit or p<0 or p in forbidden or (p,isb) in seen:\\n                continue\\n            \\n            if p==x:\\n                return s\\n            \\n            q.append((p+a,s+1,False))\\n            if not isb:\\n                q.append((p-b,s+1,True))\\n            seen.add((p,isb))\\n        \\n        return -1\\n\\n**Thanks & Upvote if you got any help !!**\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \\n        forbidden = set(forbidden)\\n        limit = max(x,max(forbidden))+a+b\\n        seen = set()\\n        q = [(0,0,False)]\\n        while q:\\n            p,s,isb = q.pop(0)\\n            if p>limit or p<0 or p in forbidden or (p,isb) in seen:\\n                continue\\n            \\n            if p==x:\\n                return s\\n            \\n            q.append((p+a,s+1,False))\\n            if not isb:\\n                q.append((p-b,s+1,True))\\n            seen.add((p,isb))\\n        \\n        return -1\\n\\n**Thanks & Upvote if you got any help !!**\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1010334,
                "title": "bfs-javascript",
                "content": "```\\n\\nconst minimumJumps = (forbidden, a, b, x)  => {\\n    \\n  const visited = new Set(forbidden);\\n  const limit = 2000 + a + b;\\n  const q = [[0,  0, true]];\\n\\n  while(q.length){\\n    const [current, jumps, backJump] = q.shift();\\n    if(current == x )\\n      return jumps;\\n    \\n    if(visited.has(current))\\n      continue;\\n    \\n    visited.add(current);\\n    let nextJump\\n    if(backJump){\\n      nextJump = current - b;\\n      if(nextJump >= 0)\\n        q.push([nextJump, jumps+1, false]) \\n      }\\n      \\n    nextJump = current + a;\\n    if(nextJump <= limit)\\n      q.push([nextJump, jumps+1, true])\\n  }\\n  return -1;\\n  \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst minimumJumps = (forbidden, a, b, x)  => {\\n    \\n  const visited = new Set(forbidden);\\n  const limit = 2000 + a + b;\\n  const q = [[0,  0, true]];\\n\\n  while(q.length){\\n    const [current, jumps, backJump] = q.shift();\\n    if(current == x )\\n      return jumps;\\n    \\n    if(visited.has(current))\\n      continue;\\n    \\n    visited.add(current);\\n    let nextJump\\n    if(backJump){\\n      nextJump = current - b;\\n      if(nextJump >= 0)\\n        q.push([nextJump, jumps+1, false]) \\n      }\\n      \\n    nextJump = current + a;\\n    if(nextJump <= limit)\\n      q.push([nextJump, jumps+1, true])\\n  }\\n  return -1;\\n  \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2911334,
                "title": "c-solution",
                "content": "# Code\\n```\\n#define maxn 10005\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int, int> mp;\\n        for(auto x: forbidden) mp[x] = 1;\\n\\t\\tint vis[maxn][2] = {};\\n\\t\\tvis[0][0] = 1;\\n\\t\\tvis[0][1] = 1;\\n        queue<pair<int, int>> q; \\n\\t\\tq.push({0, 0});\\n\\t\\tint ans = 0;\\n\\t\\twhile(!q.empty()) {\\n            int len = q.size();\\n            while(len--) {\\n                int u = q.front().first;\\n                int fl = q.front().second;\\n                q.pop();\\n                if(u == x) return ans;\\n                int vf = u + a;\\n                int vb = u - b;\\n                if(vf < maxn and !vis[vf][0] and !mp[vf]) {\\n                    vis[vf][0] = 1;\\n                    q.push({vf, 0});\\n                }\\n                if(vb >= 0 and !vis[vb][1] and !mp[vb] and !fl) {\\n                    vis[vb][1] = 1;\\n                    q.push({vb, 1});\\n                }\\n            }\\n            ans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define maxn 10005\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int, int> mp;\\n        for(auto x: forbidden) mp[x] = 1;\\n\\t\\tint vis[maxn][2] = {};\\n\\t\\tvis[0][0] = 1;\\n\\t\\tvis[0][1] = 1;\\n        queue<pair<int, int>> q; \\n\\t\\tq.push({0, 0});\\n\\t\\tint ans = 0;\\n\\t\\twhile(!q.empty()) {\\n            int len = q.size();\\n            while(len--) {\\n                int u = q.front().first;\\n                int fl = q.front().second;\\n                q.pop();\\n                if(u == x) return ans;\\n                int vf = u + a;\\n                int vb = u - b;\\n                if(vf < maxn and !vis[vf][0] and !mp[vf]) {\\n                    vis[vf][0] = 1;\\n                    q.push({vf, 0});\\n                }\\n                if(vb >= 0 and !vis[vb][1] and !mp[vb] and !fl) {\\n                    vis[vb][1] = 1;\\n                    q.push({vb, 1});\\n                }\\n            }\\n            ans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087392,
                "title": "bfs",
                "content": "```cpp\\nmap<int, bool> visited;\\nint m = 0;\\n\\n// mark the forbidden position as visited.\\nfor (int f : forbidden)\\n{\\n\\tvisited[f] = true;\\n\\tm = max(m, f);\\n}\\n\\n// the trick\\nm = a + b + max(m, x);\\n\\n// bfs\\nqueue<pair<int, bool>> que;\\nint s = 0;\\nint c = 0;\\n\\nque.push({0, true});\\nvisited[0] = true;\\n\\nwhile (s = que.size())\\n{\\n\\twhile (s --)\\n\\t{\\n\\t\\tint i = que.front().first;\\n\\t\\tbool forward = que.front().second;\\n\\t\\tque.pop();\\n\\t\\t\\n\\t\\t// ending case\\n\\t\\tif (i == x)\\n\\t\\t\\treturn c;\\n\\t\\t\\n\\t\\t// check jump backward first\\n\\t\\tint ii = i - b;\\n\\n\\t\\tif (forward && ii >= 0 && ! visited[ii])\\n\\t\\t{\\n\\t\\t\\tque.push({ii, false});\\n\\t\\t\\tvisited[ii] = true;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// jump forward\\n\\t\\tint jj = i + a;\\n\\t\\t\\n\\t\\tif (jj <= m && ! visited[jj])\\n\\t\\t{\\n\\t\\t\\tque.push({jj, true});\\n\\t\\t\\tvisited[jj] = true;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t++ c;\\n}\\n\\nreturn -1;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nmap<int, bool> visited;\\nint m = 0;\\n\\n// mark the forbidden position as visited.\\nfor (int f : forbidden)\\n{\\n\\tvisited[f] = true;\\n\\tm = max(m, f);\\n}\\n\\n// the trick\\nm = a + b + max(m, x);\\n\\n// bfs\\nqueue<pair<int, bool>> que;\\nint s = 0;\\nint c = 0;\\n\\nque.push({0, true});\\nvisited[0] = true;\\n\\nwhile (s = que.size())\\n{\\n\\twhile (s --)\\n\\t{\\n\\t\\tint i = que.front().first;\\n\\t\\tbool forward = que.front().second;\\n\\t\\tque.pop();\\n\\t\\t\\n\\t\\t// ending case\\n\\t\\tif (i == x)\\n\\t\\t\\treturn c;\\n\\t\\t\\n\\t\\t// check jump backward first\\n\\t\\tint ii = i - b;\\n\\n\\t\\tif (forward && ii >= 0 && ! visited[ii])\\n\\t\\t{\\n\\t\\t\\tque.push({ii, false});\\n\\t\\t\\tvisited[ii] = true;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// jump forward\\n\\t\\tint jj = i + a;\\n\\t\\t\\n\\t\\tif (jj <= m && ! visited[jj])\\n\\t\\t{\\n\\t\\t\\tque.push({jj, true});\\n\\t\\t\\tvisited[jj] = true;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t++ c;\\n}\\n\\nreturn -1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1689407,
                "title": "c-easy-bfs-solution-visited-track-dp-exploring-2-possibilities",
                "content": "```\\nclass Solution {\\nprivate:\\n    int bfs(unordered_set<int>& vis,int a,int b,int x){\\n        queue<pair<int,bool>> q;\\n        q.push({0,true});\\n        int ans = 0;\\n        \\n        while(!q.empty()){\\n            int count = q.size();\\n            for(int i=0; i<count; i++){\\n                int currPoint = q.front().first;\\n                bool currStatus = q.front().second;\\n                q.pop();\\n                \\n                if(currPoint == x) return ans;\\n                if(vis.count(currPoint)) continue;\\n                \\n                vis.insert(currPoint);\\n                \\n                if(currStatus && currPoint - b >= 0){\\n                    q.push({currPoint - b,false});\\n                }\\n                if(currPoint - b <= 2000){\\n                    q.push({currPoint + a,true});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> vis;\\n        for(int &v : forbidden) vis.insert(v);\\n        \\n        return bfs(vis,a,b,x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Memoization",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int bfs(unordered_set<int>& vis,int a,int b,int x){\\n        queue<pair<int,bool>> q;\\n        q.push({0,true});\\n        int ans = 0;\\n        \\n        while(!q.empty()){\\n            int count = q.size();\\n            for(int i=0; i<count; i++){\\n                int currPoint = q.front().first;\\n                bool currStatus = q.front().second;\\n                q.pop();\\n                \\n                if(currPoint == x) return ans;\\n                if(vis.count(currPoint)) continue;\\n                \\n                vis.insert(currPoint);\\n                \\n                if(currStatus && currPoint - b >= 0){\\n                    q.push({currPoint - b,false});\\n                }\\n                if(currPoint - b <= 2000){\\n                    q.push({currPoint + a,true});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> vis;\\n        for(int &v : forbidden) vis.insert(v);\\n        \\n        return bfs(vis,a,b,x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182751,
                "title": "python-3-memoization",
                "content": "The tricky part is to figure out the upper bound to stop the DFS. In the worst case, you could jump beyond home to avoid a forbidden point.\\n\\n```python\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        bound = max(max(forbidden) + a + b, x + b)\\n        memo = {}\\n\\n        def dp(pos, backward):\\n            if pos > bound or pos < 0 or pos in forbidden:\\n                return float(\\'inf\\')\\n            if pos == x:\\n                return 0\\n            if (pos, backward) not in memo:\\n                memo[pos, backward] = 1 + dp(pos + a, False)\\n                if not backward:\\n                    memo[pos, backward] = min(memo[pos, backward],\\n                                              1 + dp(pos - b, True))\\n            return memo[pos, backward]\\n\\n        ans = dp(0, True)\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        bound = max(max(forbidden) + a + b, x + b)\\n        memo = {}\\n\\n        def dp(pos, backward):\\n            if pos > bound or pos < 0 or pos in forbidden:\\n                return float(\\'inf\\')\\n            if pos == x:\\n                return 0\\n            if (pos, backward) not in memo:\\n                memo[pos, backward] = 1 + dp(pos + a, False)\\n                if not backward:\\n                    memo[pos, backward] = min(memo[pos, backward],\\n                                              1 + dp(pos - b, True))\\n            return memo[pos, backward]\\n\\n        ans = dp(0, True)\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935812,
                "title": "python-faster-than-100-of-python-submissions",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        # Shortest distance to x : min jumps\\n        forbidden = set(forbidden)\\n        queue = deque([(0,False)])\\n        ans = 0\\n        seen = set()\\n        seen.add((0,False))\\n        while queue:\\n            for _ in range(len(queue)):\\n                curr, is_last_backward = queue.popleft()\\n                if curr == x:\\n                    return ans\\n                \\n                # Jump forward\\n                next_pos = curr + a\\n                if next_pos not in forbidden and next_pos < 4000 and (next_pos,False) not in seen:\\n                    queue.append((next_pos, False))\\n                    seen.add((next_pos, False))\\n                # Jump backward\\n                if not is_last_backward:\\n                    next_pos = curr - b\\n                    if next_pos >= 0 and next_pos not in forbidden and (next_pos, True) not in seen :\\n                        queue.append((next_pos,True))\\n                        seen.add((next_pos, True))\\n         \\n                \\n            ans += 1\\n        \\n        return -1\\n            \\n            \\n            \\n            \\n    \\n\"\"\"\\n[14,4,18,1,15]\\n\\n\\na = 3\\nb = 15\\nx = 9\\n\\n0 -- > 3 -- > 6 -- > 9\\n\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        # Shortest distance to x : min jumps\\n        forbidden = set(forbidden)\\n        queue = deque([(0,False)])\\n        ans = 0\\n        seen = set()\\n        seen.add((0,False))\\n        while queue:\\n            for _ in range(len(queue)):\\n                curr, is_last_backward = queue.popleft()\\n                if curr == x:\\n                    return ans\\n                \\n                # Jump forward\\n                next_pos = curr + a\\n                if next_pos not in forbidden and next_pos < 4000 and (next_pos,False) not in seen:\\n                    queue.append((next_pos, False))\\n                    seen.add((next_pos, False))\\n                # Jump backward\\n                if not is_last_backward:\\n                    next_pos = curr - b\\n                    if next_pos >= 0 and next_pos not in forbidden and (next_pos, True) not in seen :\\n                        queue.append((next_pos,True))\\n                        seen.add((next_pos, True))\\n         \\n                \\n            ans += 1\\n        \\n        return -1\\n            \\n            \\n            \\n            \\n    \\n\"\"\"\\n[14,4,18,1,15]\\n\\n\\na = 3\\nb = 15\\nx = 9\\n\\n0 -- > 3 -- > 6 -- > 9\\n\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935436,
                "title": "java-bfs-with-simple-comments",
                "content": "```\\n\\tpublic int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        boolean[][] visited = new boolean[8888][2]; // [position][direction] indicates if already visited\\n        for (int i : forbidden) visited[i][0] = visited[i][1] = true;\\n        int ret = 0;\\n        LinkedList<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0}); // init with position 0 and right direction\\n        visited[0][0] = true;\\n        while (!q.isEmpty()) {\\n            for (int i = q.size(); i > 0; i--) {\\n                int[] p = q.poll();\\n                if (p[0] == x) return ret;\\n                int idx = p[0] - b;\\n                if (idx >= 0 && !visited[idx][1] && p[1] == 0) {\\n                    q.add(new int[]{idx, 1});\\n                    visited[idx][1] = true; // have to make it visited when you put it into the queue\\n                }\\n                idx = p[0] + a;\\n                if (!visited[idx][0] && idx <= 4000) { // position beyond 4000 will never reach x because of rule 3\\n                    q.add(new int[]{idx, 0});\\n                    visited[idx][0] = true;\\n                }\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        boolean[][] visited = new boolean[8888][2]; // [position][direction] indicates if already visited\\n        for (int i : forbidden) visited[i][0] = visited[i][1] = true;\\n        int ret = 0;\\n        LinkedList<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0}); // init with position 0 and right direction\\n        visited[0][0] = true;\\n        while (!q.isEmpty()) {\\n            for (int i = q.size(); i > 0; i--) {\\n                int[] p = q.poll();\\n                if (p[0] == x) return ret;\\n                int idx = p[0] - b;\\n                if (idx >= 0 && !visited[idx][1] && p[1] == 0) {\\n                    q.add(new int[]{idx, 1});\\n                    visited[idx][1] = true; // have to make it visited when you put it into the queue\\n                }\\n                idx = p[0] + a;\\n                if (!visited[idx][0] && idx <= 4000) { // position beyond 4000 will never reach x because of rule 3\\n                    q.add(new int[]{idx, 0});\\n                    visited[idx][0] = true;\\n                }\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935381,
                "title": "c-simulate-steps-using-dfs",
                "content": "> why you dont mark visit move2?\\n\\tans: If we move back we still want to allow forward jump from that index. If we mark them visited then we are blocking forward jump from that index.. which is not correct.\\n\\t\\n> why 4000\\nLooking at the constraint.. we can find that we can do back jump of maximum of 2000. If we have some answer (not -1) we must terminate our forward jump before `4000`. In all other cases it answer will be -1\\n\\n```\\nclass Solution {\\npublic:\\n    int MAX = 99999;\\n    unordered_set<int> visited;\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> f (forbidden.begin(), forbidden.end());\\n        visited = {};\\n        int res =  solve(f, 0,a, b, x, 1);\\n        \\n        return res >= MAX ? -1 : res-1;\\n    }\\n    \\n    int solve(unordered_set<int> &forbidden, int index, int a, int b, int x, int isBackJumpAllowed){\\n        if(index == x) {\\n            return 1;\\n        }\\n        int res1  = MAX;\\n        int move1 = index + a;\\n        if(forbidden.find(move1) == forbidden.end() && move1 >= 0 && visited.count(move1)==0 && move1 <= 4000){\\n            visited.insert(move1);\\n            res1  = solve(forbidden, move1, a, b, x, 1);\\n        }\\n        int res2  = MAX;\\n        int move2 = index - b;\\n        if(forbidden.find(move2) == forbidden.end() && move2 >= 0 && isBackJumpAllowed && visited.count(move2)==0){\\n            res2  = solve(forbidden, move2, a, b, x , 0);\\n        }\\n        return 1 + min(res1, res2);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MAX = 99999;\\n    unordered_set<int> visited;\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int> f (forbidden.begin(), forbidden.end());\\n        visited = {};\\n        int res =  solve(f, 0,a, b, x, 1);\\n        \\n        return res >= MAX ? -1 : res-1;\\n    }\\n    \\n    int solve(unordered_set<int> &forbidden, int index, int a, int b, int x, int isBackJumpAllowed){\\n        if(index == x) {\\n            return 1;\\n        }\\n        int res1  = MAX;\\n        int move1 = index + a;\\n        if(forbidden.find(move1) == forbidden.end() && move1 >= 0 && visited.count(move1)==0 && move1 <= 4000){\\n            visited.insert(move1);\\n            res1  = solve(forbidden, move1, a, b, x, 1);\\n        }\\n        int res2  = MAX;\\n        int move2 = index - b;\\n        if(forbidden.find(move2) == forbidden.end() && move2 >= 0 && isBackJumpAllowed && visited.count(move2)==0){\\n            res2  = solve(forbidden, move2, a, b, x , 0);\\n        }\\n        return 1 + min(res1, res2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241529,
                "title": "python3-bfs-beats-100-with-explanation",
                "content": "# Intuition\\r\\n- We use BFS to find the minimum number of jumps required to reach the target position from the starting position.\\r\\n\\r\\n- We consider two types of moves: a forward jump of size \\'a\\', and a backward jump of size \\'b\\'.\\r\\n\\r\\n- We avoid forbidden positions, jumping backwards twice in a row and jumping into negative positions. \\r\\n\\r\\n- We keep track of positions that we have already visited to avoid revisiting them. Those can be added into set of forbidden positions.\\r\\n\\r\\n- If we cannot reach the target position from the starting position, we return -1.\\r\\n\\r\\n# Approach\\r\\n- We use BFS to explore all possible positions that we can reach from the starting position within a maximum of two forward jumps.\\r\\n- We start by setting upper and lower limits for the search, based on the target position and the highest forbidden position, and the minimum allowed position (0).\\r\\n- We create a queue to keep track of the positions to explore, their corresponding number of steps, and a boolean flag to indicate if we can or cannot make a backward jump from the current position.\\r\\n- For each position in the queue, we explore all possible forward jumps and backward jumps, as long as they are within the upper and lower limits and not forbidden, and we also use the boolean flag to prevent going backwards twice in a row.\\r\\n- If we reach the target position, we return the corresponding number of steps.\\r\\n- If we exhaust all possible positions to explore without reaching the target position, we return -1 to indicate that the target is unreachable\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: **O(U)**\\r\\n- Where U is the upper limit of the search space. In worse case scenario, the algorithm will have to explore all positions between in range(0, U)\\r\\n\\r\\n- Space complexity: **O(U)**\\r\\n- We need to keep track of all positions between 0 and U, and each position can be added to the queue at most once.\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\r\\n        # Create a set of forbidden positions, set the lower limit to 0, and set the upper limit to the maximum of the goal position, \\r\\n        # the maximum of the forbidden positions, and the sum of the jump lengths.\\r\\n        forbidden, lower, upper = set(forbidden), 0, max(x, max(forbidden)) + a + b\\r\\n        if 0 in forbidden:\\r\\n            return -1\\r\\n        \\r\\n        # Initialize a queue to hold the positions to be explored, set the number of steps to -1, and add the starting position to the queue.\\r\\n        queue, steps = deque(), -1\\r\\n        queue.append((0, True))\\r\\n        forbidden.add(0)\\r\\n        \\r\\n        # Loop through the positions in the queue until the queue is empty.\\r\\n        while queue:\\r\\n            # Increment the number of steps.\\r\\n            steps += 1\\r\\n            \\r\\n            # Loop through the positions in the queue that were added in the previous iteration.\\r\\n            for i in range(len(queue)):\\r\\n                # Remove the first position from the queue.\\r\\n                pos, canBackwards = queue.popleft()\\r\\n                \\r\\n                # Check if the current position is the goal position, if so, return the number of steps.\\r\\n                if pos == x:\\r\\n                    return steps\\r\\n                \\r\\n                # Check if it is possible to jump backwards from the current position and if the new position is not forbidden.\\r\\n                if (canBackwards and pos - b > 0 and pos-b not in forbidden):\\r\\n                    # Add the new position to the queue with canBackwards set to False, and add it to the forbidden set.\\r\\n                    queue.append((pos-b, False))\\r\\n                    forbidden.add(pos-b)\\r\\n                \\r\\n                # Check if it is possible to jump forwards from the current position and if the new position is not forbidden.\\r\\n                if (pos+a <= upper and pos+a not in forbidden):\\r\\n                    # Add the new position to the queue with canBackwards set to True, and add it to the forbidden set.\\r\\n                    queue.append((pos+a, True))\\r\\n                    forbidden.add(pos+a)\\r\\n        \\r\\n        # If the goal position is not reached, return -1.\\r\\n        return -1\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\r\\n        # Create a set of forbidden positions, set the lower limit to 0, and set the upper limit to the maximum of the goal position, \\r\\n        # the maximum of the forbidden positions, and the sum of the jump lengths.\\r\\n        forbidden, lower, upper = set(forbidden), 0, max(x, max(forbidden)) + a + b\\r\\n        if 0 in forbidden:\\r\\n            return -1\\r\\n        \\r\\n        # Initialize a queue to hold the positions to be explored, set the number of steps to -1, and add the starting position to the queue.\\r\\n        queue, steps = deque(), -1\\r\\n        queue.append((0, True))\\r\\n        forbidden.add(0)\\r\\n        \\r\\n        # Loop through the positions in the queue until the queue is empty.\\r\\n        while queue:\\r\\n            # Increment the number of steps.\\r\\n            steps += 1\\r\\n            \\r\\n            # Loop through the positions in the queue that were added in the previous iteration.\\r\\n            for i in range(len(queue)):\\r\\n                # Remove the first position from the queue.\\r\\n                pos, canBackwards = queue.popleft()\\r\\n                \\r\\n                # Check if the current position is the goal position, if so, return the number of steps.\\r\\n                if pos == x:\\r\\n                    return steps\\r\\n                \\r\\n                # Check if it is possible to jump backwards from the current position and if the new position is not forbidden.\\r\\n                if (canBackwards and pos - b > 0 and pos-b not in forbidden):\\r\\n                    # Add the new position to the queue with canBackwards set to False, and add it to the forbidden set.\\r\\n                    queue.append((pos-b, False))\\r\\n                    forbidden.add(pos-b)\\r\\n                \\r\\n                # Check if it is possible to jump forwards from the current position and if the new position is not forbidden.\\r\\n                if (pos+a <= upper and pos+a not in forbidden):\\r\\n                    # Add the new position to the queue with canBackwards set to True, and add it to the forbidden set.\\r\\n                    queue.append((pos+a, True))\\r\\n                    forbidden.add(pos+a)\\r\\n        \\r\\n        # If the goal position is not reached, return -1.\\r\\n        return -1\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085343,
                "title": "java-solution-6-ms-beats-99",
                "content": "# Code\\n```\\nclass Solution {\\n    class Pair {\\n        int pos;\\n        boolean dir;\\n        public Pair(int pos, boolean dir) {\\n            this.pos = pos;\\n            this.dir = dir;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] visited = new boolean[limit];\\n        for (int num: forbidden) {\\n            visited[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        visited[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                boolean dir = p.dir;\\n              \\n                if (pos == x) return step;\\n                \\n                if (dir==false) {\\n                    int backward = pos - b;\\n                  \\n                    if (backward > 0 && !visited[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        visited[backward] = true;\\n                    }\\n                }\\n                \\n                int forward = pos + a;\\n           \\n                if (forward < limit && !visited[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    visited[forward] = true;\\n                }\\n              \\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int pos;\\n        boolean dir;\\n        public Pair(int pos, boolean dir) {\\n            this.pos = pos;\\n            this.dir = dir;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] visited = new boolean[limit];\\n        for (int num: forbidden) {\\n            visited[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        visited[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                boolean dir = p.dir;\\n              \\n                if (pos == x) return step;\\n                \\n                if (dir==false) {\\n                    int backward = pos - b;\\n                  \\n                    if (backward > 0 && !visited[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        visited[backward] = true;\\n                    }\\n                }\\n                \\n                int forward = pos + a;\\n           \\n                if (forward < limit && !visited[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    visited[forward] = true;\\n                }\\n              \\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788411,
                "title": "c-2-approaches-dynamic-programming-recursive-memoization-simple-bfs",
                "content": "# Code\\n**IF YOU LIKE PLEASE UPVOTE, HAPPY CODING :)**\\n\\nDP Approach-------\\n\\n```\\nint fun(int pos,int a,int b,int x,unordered_map<int,int>&mp,int move,vector<vector<int>>&dp)\\n{\\n    if(pos==x)\\n    {\\n        return 0;\\n    }\\n    if(pos<0 || pos>6001 || mp.find(pos)!=mp.end()) return 1e9;\\n    if(dp[pos][move]!=-1) return dp[pos][move];\\n    int forward=0;\\n    dp[pos][move]=1+fun(pos+a,a,b,x,mp,0,dp);\\n    if(move==0)\\n    {\\n        dp[pos][move]=min(dp[pos][move],1+fun(pos-b,a,b,x,mp,1,dp));\\n    }\\n    return dp[pos][move];\\n}\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<forbidden.size();i++)\\n        {\\n            mp[forbidden[i]]=1;\\n        }\\n        vector<vector<int>>dp(7001,vector<int>(2,-1));\\n        int d=fun(0,a,b,x,mp,0,dp);\\n        if(d>=1e7) return -1;\\n        return d;\\n    }\\n```\\nUsing Simple BFS\\n\\n```\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x)\\n        {\\n            queue<pair<pair<int,int>,int>>q;\\n            unordered_map<int,int>mp;\\n            for(int i=0;i<forbidden.size();i++)\\n            {\\n                mp[forbidden[i]]=1;\\n            }\\n            q.push({{0,0},0});\\n            vector<vector<int>>vis(6001,vector<int>(2,0));\\n            vis[0][0]=1;\\n            while(!q.empty())\\n            {\\n                int pos=q.front().first.first;\\n                int move=q.front().first.second;\\n                int steps=q.front().second;\\n                q.pop();\\n                if(pos==x)\\n                {\\n                    return steps;\\n                }\\n                if(pos+a<6001 && mp.find(pos+a)==mp.end() && vis[pos+a][0]==0)\\n                {\\n                    q.push({{pos+a,0},steps+1});\\n                    vis[pos+a][0]=1;\\n                }\\n                if(pos-b>=0 && move==0 && mp.find(pos-b)==mp.end() && vis[pos-b][1]==0)\\n                {\\n                    q.push({{pos-b,1},steps+1});\\n                    vis[pos-b][1]=1;\\n                }\\n            }\\n            return -1;\\n        }\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nint fun(int pos,int a,int b,int x,unordered_map<int,int>&mp,int move,vector<vector<int>>&dp)\\n{\\n    if(pos==x)\\n    {\\n        return 0;\\n    }\\n    if(pos<0 || pos>6001 || mp.find(pos)!=mp.end()) return 1e9;\\n    if(dp[pos][move]!=-1) return dp[pos][move];\\n    int forward=0;\\n    dp[pos][move]=1+fun(pos+a,a,b,x,mp,0,dp);\\n    if(move==0)\\n    {\\n        dp[pos][move]=min(dp[pos][move],1+fun(pos-b,a,b,x,mp,1,dp));\\n    }\\n    return dp[pos][move];\\n}\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<forbidden.size();i++)\\n        {\\n            mp[forbidden[i]]=1;\\n        }\\n        vector<vector<int>>dp(7001,vector<int>(2,-1));\\n        int d=fun(0,a,b,x,mp,0,dp);\\n        if(d>=1e7) return -1;\\n        return d;\\n    }\\n```\n```\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x)\\n        {\\n            queue<pair<pair<int,int>,int>>q;\\n            unordered_map<int,int>mp;\\n            for(int i=0;i<forbidden.size();i++)\\n            {\\n                mp[forbidden[i]]=1;\\n            }\\n            q.push({{0,0},0});\\n            vector<vector<int>>vis(6001,vector<int>(2,0));\\n            vis[0][0]=1;\\n            while(!q.empty())\\n            {\\n                int pos=q.front().first.first;\\n                int move=q.front().first.second;\\n                int steps=q.front().second;\\n                q.pop();\\n                if(pos==x)\\n                {\\n                    return steps;\\n                }\\n                if(pos+a<6001 && mp.find(pos+a)==mp.end() && vis[pos+a][0]==0)\\n                {\\n                    q.push({{pos+a,0},steps+1});\\n                    vis[pos+a][0]=1;\\n                }\\n                if(pos-b>=0 && move==0 && mp.find(pos-b)==mp.end() && vis[pos-b][1]==0)\\n                {\\n                    q.push({{pos-b,1},steps+1});\\n                    vis[pos-b][1]=1;\\n                }\\n            }\\n            return -1;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2668948,
                "title": "c-clean-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        std::queue<std::pair<int, bool>> Q; Q.push({0, true});\\n        std::set<int> visited; \\n        for(int place : forbidden) visited.insert(place);\\n        \\n        int count = -1;\\n        while(!Q.empty()){\\n            count++;\\n            int length = Q.size();\\n            for(int i = 0; i < length; i++){\\n                auto [curr, forward] = Q.front(); Q.pop();\\n            \\n                if(visited.count(curr) > 0) continue;\\n\\n                if(curr == x) return count;\\n\\n                if(forward && curr - b >= 0) Q.push({curr - b, false});\\n                if(curr - b <= 2000) Q.push({curr + a, true});\\n\\n\\n                visited.insert(curr);\\n            }\\n        }\\n         return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        std::queue<std::pair<int, bool>> Q; Q.push({0, true});\\n        std::set<int> visited; \\n        for(int place : forbidden) visited.insert(place);\\n        \\n        int count = -1;\\n        while(!Q.empty()){\\n            count++;\\n            int length = Q.size();\\n            for(int i = 0; i < length; i++){\\n                auto [curr, forward] = Q.front(); Q.pop();\\n            \\n                if(visited.count(curr) > 0) continue;\\n\\n                if(curr == x) return count;\\n\\n                if(forward && curr - b >= 0) Q.push({curr - b, false});\\n                if(curr - b <= 2000) Q.push({curr + a, true});\\n\\n\\n                visited.insert(curr);\\n            }\\n        }\\n         return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263310,
                "title": "java-easy-bfs",
                "content": "Wonder why visited has FORWARD, BACKWARD presence?\\nto reach a num, say 10, we do not know if we reach 10 by adding a or subtracting b.\\n```\\nx + a = 10 (different combination)\\nx - b = 10 (different combination)\\n```\\n\\n**If you like the solution, please upvote! Happy Learning!**\\n```\\nclass Solution {\\n    private static final int FORWARD = 1;\\n    private static final int BACKWARD = 2;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<int[]> q = new LinkedList();\\n        q.add(new int[] {0, FORWARD});\\n        Set<String> visited = new HashSet();\\n        Set<Integer> forbiddenSet = new HashSet();\\n        int farthest = 2000 + 2 * b;\\n        for (int f: forbidden) {\\n            farthest = Math.max(farthest, f + 2 * b);\\n            forbiddenSet.add(f);\\n        }\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] current = q.poll();\\n                if (current[0] == x) {\\n                    return step;\\n                }\\n                \\n                int forward = current[0] + a;\\n                int backward = current[0] - b;\\n                \\n                if (forward <= farthest && !visited.contains(forward + \"|\" + FORWARD) && !forbiddenSet.contains(forward)) {\\n                    visited.add(forward + \"|\" + FORWARD);\\n                    q.add(new int[] {forward, FORWARD});\\n                }\\n                \\n                if (current[1] != BACKWARD && backward >= 0 && !visited.contains(backward + \"|\" + BACKWARD) && !forbiddenSet.contains(backward)) {\\n                    visited.add(backward + \"|\" + BACKWARD);\\n                    q.add(new int[] {backward, BACKWARD});\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nx + a = 10 (different combination)\\nx - b = 10 (different combination)\\n```\n```\\nclass Solution {\\n    private static final int FORWARD = 1;\\n    private static final int BACKWARD = 2;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<int[]> q = new LinkedList();\\n        q.add(new int[] {0, FORWARD});\\n        Set<String> visited = new HashSet();\\n        Set<Integer> forbiddenSet = new HashSet();\\n        int farthest = 2000 + 2 * b;\\n        for (int f: forbidden) {\\n            farthest = Math.max(farthest, f + 2 * b);\\n            forbiddenSet.add(f);\\n        }\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] current = q.poll();\\n                if (current[0] == x) {\\n                    return step;\\n                }\\n                \\n                int forward = current[0] + a;\\n                int backward = current[0] - b;\\n                \\n                if (forward <= farthest && !visited.contains(forward + \"|\" + FORWARD) && !forbiddenSet.contains(forward)) {\\n                    visited.add(forward + \"|\" + FORWARD);\\n                    q.add(new int[] {forward, FORWARD});\\n                }\\n                \\n                if (current[1] != BACKWARD && backward >= 0 && !visited.contains(backward + \"|\" + BACKWARD) && !forbiddenSet.contains(backward)) {\\n                    visited.add(backward + \"|\" + BACKWARD);\\n                    q.add(new int[] {backward, BACKWARD});\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250752,
                "title": "c-bfs",
                "content": "**Note:**\\nvis[x][0] denotes that we have visited the position x following forward direction (some other point--->x)\\nvis[x][1] denotes that we have visited the position x following backward direction (X<--some other point)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<pair<int,int>>q;\\n        q.push({0,0}); // pos, dir(0->forward 1->backward); // adding starting postion with direction as forward (0)\\n        int end=10000; // from constraints\\n        vector<vector<bool>>vis(end+1,vector<bool>(2,false));\\n        \\n        for(auto zone:forbidden){ // visit the all forbidden zone\\n            if(zone<=end)vis[zone][0]=true;\\n            if(zone<=end)vis[zone][1]=true;\\n        }\\n        if(vis[x][0])return -1; // if home is at forbidden zone\\n        vis[0][0]=true; // we assume we have visited at source by travelling forward as well as backwards.\\n        vis[0][1]=true;\\n        int jumps=0;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto rem=q.front(); q.pop();\\n                int pos=rem.first;\\n                int dir=rem.second;\\n                if(pos==x)return jumps;\\n                if(dir==0){ // if this position is travelled with forward direction then we can move forward as well as backward directiona.\\n                    if(((pos+a)<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                    if(((pos-b)>=0)&&(!vis[pos-b][1])){vis[pos-b][1]=true;q.push({pos-b,1});}\\n                        \\n                }else{ // if this position is travelled with backward direction then we can move only in forward direction\\n                    if((pos+a<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                }\\n            }\\n           jumps++; \\n            \\n        }\\n        return -1;\\n    }\\n};\\n\\n```\\nplz upvote if u like it",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<pair<int,int>>q;\\n        q.push({0,0}); // pos, dir(0->forward 1->backward); // adding starting postion with direction as forward (0)\\n        int end=10000; // from constraints\\n        vector<vector<bool>>vis(end+1,vector<bool>(2,false));\\n        \\n        for(auto zone:forbidden){ // visit the all forbidden zone\\n            if(zone<=end)vis[zone][0]=true;\\n            if(zone<=end)vis[zone][1]=true;\\n        }\\n        if(vis[x][0])return -1; // if home is at forbidden zone\\n        vis[0][0]=true; // we assume we have visited at source by travelling forward as well as backwards.\\n        vis[0][1]=true;\\n        int jumps=0;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto rem=q.front(); q.pop();\\n                int pos=rem.first;\\n                int dir=rem.second;\\n                if(pos==x)return jumps;\\n                if(dir==0){ // if this position is travelled with forward direction then we can move forward as well as backward directiona.\\n                    if(((pos+a)<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                    if(((pos-b)>=0)&&(!vis[pos-b][1])){vis[pos-b][1]=true;q.push({pos-b,1});}\\n                        \\n                }else{ // if this position is travelled with backward direction then we can move only in forward direction\\n                    if((pos+a<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                }\\n            }\\n           jumps++; \\n            \\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980115,
                "title": "java-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        \\n        // Visited Set\\n        Set<Integer> visited = new HashSet<Integer>();\\n        \\n        // Add forbidden coordinates to visited\\n        for (int i = 0; i < forbidden.length; i++) {\\n            visited.add(forbidden[i]);\\n        }\\n        \\n        // Distance/ Jumps map\\n        Map<Integer, Integer> jumps = new HashMap<>();\\n        jumps.put(0, 0);\\n        \\n        // BFS Queue\\n        Queue<Integer[]> q = new LinkedList<>();\\n        q.add(new Integer[] {0, 1});\\n        \\n        // BFS \\n        while (q.size() != 0) {\\n            \\n            Integer[] ud = q.poll();\\n            \\n            int u = ud[0], d = ud[1];\\n            \\n            // x found\\n            if (u == x) {\\n                return jumps.get(u);\\n            }\\n            \\n            // jump right\\n            if (u + a < 6001 && !visited.contains(u+a)) {\\n                q.add(new Integer[] {u+a, 1});\\n                visited.add(u+a);\\n                jumps.put(u+a, jumps.get(u) + 1);\\n            }\\n            \\n            // jump left\\n            if (d != -1 && u - b > -1 && !visited.contains(u-b)) {\\n                q.add(new Integer[] {u-b, -1});\\n                jumps.put(u-b, jumps.get(u) + 1);\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        \\n        // Visited Set\\n        Set<Integer> visited = new HashSet<Integer>();\\n        \\n        // Add forbidden coordinates to visited\\n        for (int i = 0; i < forbidden.length; i++) {\\n            visited.add(forbidden[i]);\\n        }\\n        \\n        // Distance/ Jumps map\\n        Map<Integer, Integer> jumps = new HashMap<>();\\n        jumps.put(0, 0);\\n        \\n        // BFS Queue\\n        Queue<Integer[]> q = new LinkedList<>();\\n        q.add(new Integer[] {0, 1});\\n        \\n        // BFS \\n        while (q.size() != 0) {\\n            \\n            Integer[] ud = q.poll();\\n            \\n            int u = ud[0], d = ud[1];\\n            \\n            // x found\\n            if (u == x) {\\n                return jumps.get(u);\\n            }\\n            \\n            // jump right\\n            if (u + a < 6001 && !visited.contains(u+a)) {\\n                q.add(new Integer[] {u+a, 1});\\n                visited.add(u+a);\\n                jumps.put(u+a, jumps.get(u) + 1);\\n            }\\n            \\n            // jump left\\n            if (d != -1 && u - b > -1 && !visited.contains(u-b)) {\\n                q.add(new Integer[] {u-b, -1});\\n                jumps.put(u-b, jumps.get(u) + 1);\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920366,
                "title": "java-bfs-faster-than-99-85",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        int i;\\n        boolean backward;\\n        public Pair(int i, boolean b) {\\n            this.i = i;\\n            this.backward = b;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] v = new boolean[limit];\\n        for (int num: forbidden) {\\n            v[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        v[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair c = q.poll();\\n                if (c.i == x) return step;\\n                if (!c.backward) {\\n                    int backward = c.i - b;\\n                    if (backward == x) return step + 1;\\n                    if (backward > 0 && !v[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        v[backward] = true;\\n                    }\\n                }\\n                int forward = c.i + a;\\n                if (forward == x) return step + 1;\\n                if (forward < limit && !v[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    v[forward] = true;\\n                }               \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int i;\\n        boolean backward;\\n        public Pair(int i, boolean b) {\\n            this.i = i;\\n            this.backward = b;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] v = new boolean[limit];\\n        for (int num: forbidden) {\\n            v[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        v[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair c = q.poll();\\n                if (c.i == x) return step;\\n                if (!c.backward) {\\n                    int backward = c.i - b;\\n                    if (backward == x) return step + 1;\\n                    if (backward > 0 && !v[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        v[backward] = true;\\n                    }\\n                }\\n                int forward = c.i + a;\\n                if (forward == x) return step + 1;\\n                if (forward < limit && !v[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    v[forward] = true;\\n                }               \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868193,
                "title": "javascript-clean-bfs-99",
                "content": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n  forbidden = new Set(forbidden);\\n  const upper = a + b + Math.max(x, Math.max(...forbidden))\\n  \\n  const queue = new Queue([[0, true, 0]]);\\n  while (!queue.isEmpty()) {\\n    const [cur, backward, jumps] = queue.dequeue();\\n    \\n    if (forbidden.has(cur)) continue;\\n    forbidden.add(cur);\\n    \\n    if (cur === x) return jumps\\n    \\n    const newPosB = cur - b\\n    if (!forbidden.has(newPosB) && newPosB > 0 && backward) queue.enqueue([newPosB, false, jumps + 1])\\n    \\n    const newPosA = cur + a\\n    if (!forbidden.has(newPosA) && newPosA <= upper) queue.enqueue([newPosA, true, jumps + 1])\\n  }\\n  \\n  return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n  forbidden = new Set(forbidden);\\n  const upper = a + b + Math.max(x, Math.max(...forbidden))\\n  \\n  const queue = new Queue([[0, true, 0]]);\\n  while (!queue.isEmpty()) {\\n    const [cur, backward, jumps] = queue.dequeue();\\n    \\n    if (forbidden.has(cur)) continue;\\n    forbidden.add(cur);\\n    \\n    if (cur === x) return jumps\\n    \\n    const newPosB = cur - b\\n    if (!forbidden.has(newPosB) && newPosB > 0 && backward) queue.enqueue([newPosB, false, jumps + 1])\\n    \\n    const newPosA = cur + a\\n    if (!forbidden.has(newPosA) && newPosA <= upper) queue.enqueue([newPosA, true, jumps + 1])\\n  }\\n  \\n  return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605214,
                "title": "c-bfs",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forb, int a, int b, int x) {\\n        unordered_set<int> forbidden(begin(forb), end(forb));\\n        \\n        using State = pair<int, bool>;\\n        \\n        queue<State> q;\\n        q.push({0, false});\\n        \\n        set<State> seen{{0, false}};\\n        \\n        int jumps = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            \\n            for (int i = 0; i < size; ++i) {\\n                auto [pos, isBackward] = q.front();\\n                q.pop();\\n\\n                if (pos == x) {\\n                    return jumps;\\n                }\\n                \\n                // Go forward\\n                if (!seen.count({pos + a, false}) && pos < 4000 && !forbidden.count(pos + a)) {\\n                    seen.insert({pos + a, false});\\n                    q.push({pos + a, false});\\n                }\\n                \\n                // Go backward\\n                if (!isBackward && pos - b > 0 && !seen.count({pos - b, true}) && !forbidden.count(pos - b)) {\\n                    seen.insert({pos - b, true});\\n                    q.push({pos - b, true});\\n                }\\n            }\\n            ++jumps;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forb, int a, int b, int x) {\\n        unordered_set<int> forbidden(begin(forb), end(forb));\\n        \\n        using State = pair<int, bool>;\\n        \\n        queue<State> q;\\n        q.push({0, false});\\n        \\n        set<State> seen{{0, false}};\\n        \\n        int jumps = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            \\n            for (int i = 0; i < size; ++i) {\\n                auto [pos, isBackward] = q.front();\\n                q.pop();\\n\\n                if (pos == x) {\\n                    return jumps;\\n                }\\n                \\n                // Go forward\\n                if (!seen.count({pos + a, false}) && pos < 4000 && !forbidden.count(pos + a)) {\\n                    seen.insert({pos + a, false});\\n                    q.push({pos + a, false});\\n                }\\n                \\n                // Go backward\\n                if (!isBackward && pos - b > 0 && !seen.count({pos - b, true}) && !forbidden.count(pos - b)) {\\n                    seen.insert({pos - b, true});\\n                    q.push({pos - b, true});\\n                }\\n            }\\n            ++jumps;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525906,
                "title": "java-easy-to-understand-dfs-code-with-explanation-15-ms-faster-than-94-04",
                "content": "**Key points to understand the solution.**\\n1. I have taken all variables which will be commonly used by all recursion calls commonly.\\n2. I have thought of two exit calls that are possible.\\n    a. First is when my currentNode is equal to my valueToReach value;\\n\\tb. If my currNode reaches >6000 ( max of a + max of b + max of c, got the each value from constraint as 2000),         I will simply return.\\n3. Now for understanding that when to mark a node as visited, consider the following diagram.\\n![image](https://assets.leetcode.com/users/images/056e01e4-b28b-4254-91d5-150509aff64c_1634463686.869404.jpeg)\\n4. There are two possibilities to reach from currNode - a ->currNode OR currNode + b -> currNode.\\n5. If we consider reaching to currNode from possibility 1, then there are two children possible currNode + a and currNode -b.\\n6. If we consider reaching to currNode from possibility 2, then there is one child possible i.e currNode -b.\\n7. If we mark currNode as visited because of possibility 2, then we will miss the one child of which will be currNode + a.\\n8. So we will always mark currNode as visited if we are taking a forward step from currNode - a or when previousSetp.equals(\"forward\").\\n\\n\\n\\n\\n```\\nclass Solution {\\n    int minJumps = Integer.MAX_VALUE;\\n    int max_val;\\n    int p;\\n    int q;\\n    int valueToReach;\\n    HashSet<Integer> visited;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        visited = new HashSet();\\n        for(int i =0;i<forbidden.length;i++){\\n            visited.add(forbidden[i]);\\n        }\\n        max_val = 6000;\\n        p = a;\\n        q = b;\\n        valueToReach = x;\\n        visited.add(0);\\n        dfs(0, 0, \"forward\");\\n        if(minJumps == Integer.MAX_VALUE)\\n            return -1;\\n        return minJumps;\\n    }\\n    \\n    public void dfs(int currNode, int jumps, String previousStep){\\n        if(currNode == valueToReach){\\n            minJumps = minJumps < jumps ? minJumps : jumps;\\n            return;\\n        }\\n        if(previousStep.equals(\"forward\"))\\n            visited.add(currNode);\\n        if(((currNode + p) < max_val) && !visited.contains(currNode + p)){\\n            \\n                dfs(currNode + p, jumps +1, \"forward\");\\n        }\\n        if(((currNode - q) < max_val)&& previousStep.equals(\"forward\")&& (currNode - q) >=0 && !visited.contains(currNode - q)){\\n                \\n                dfs(currNode - q, jumps + 1, \"back\");\\n        }\\n        return;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int minJumps = Integer.MAX_VALUE;\\n    int max_val;\\n    int p;\\n    int q;\\n    int valueToReach;\\n    HashSet<Integer> visited;\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        visited = new HashSet();\\n        for(int i =0;i<forbidden.length;i++){\\n            visited.add(forbidden[i]);\\n        }\\n        max_val = 6000;\\n        p = a;\\n        q = b;\\n        valueToReach = x;\\n        visited.add(0);\\n        dfs(0, 0, \"forward\");\\n        if(minJumps == Integer.MAX_VALUE)\\n            return -1;\\n        return minJumps;\\n    }\\n    \\n    public void dfs(int currNode, int jumps, String previousStep){\\n        if(currNode == valueToReach){\\n            minJumps = minJumps < jumps ? minJumps : jumps;\\n            return;\\n        }\\n        if(previousStep.equals(\"forward\"))\\n            visited.add(currNode);\\n        if(((currNode + p) < max_val) && !visited.contains(currNode + p)){\\n            \\n                dfs(currNode + p, jumps +1, \"forward\");\\n        }\\n        if(((currNode - q) < max_val)&& previousStep.equals(\"forward\")&& (currNode - q) >=0 && !visited.contains(currNode - q)){\\n                \\n                dfs(currNode - q, jumps + 1, \"back\");\\n        }\\n        return;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450316,
                "title": "can-t-understand-how-changing-places-of-the-conditions-work",
                "content": "So I have this code for the problem\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int,bool> m;\\n        queue<pair<int,int>> queue;\\n        int ans = 0;\\n        for(int& n: forbidden) m[n]=true;\\n        queue.push(make_pair(0,0));\\n        while(!queue.empty()) {\\n            int size = queue.size();\\n            while(size--) {\\n                auto p = queue.front(); queue.pop();\\n                if(p.first == x) return ans;\\n                if(m[p.first]) continue;\\n                m[p.first]=true;\\n                \\n             \\n\\t\\t\\t\\t  // I\\'m calling this FORWARD CONDITION\\n                 if(p.first <= (2000+b)) {\\n                    queue.push(make_pair(p.first+a, 0));\\n                }\\n               \\n\\t\\t\\t      \\n                if(p.second == 0  && (p.first-b) >=0) {\\n                    queue.push(make_pair(p.first-b, 1));             \\n                }\\n\\t\\t\\t   \\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\\n\\nThis code is giving me wrong answer for some test cases. But after moving the FORWARD CONDITION below the other if condition, the code seems to work.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int,bool> m;\\n        queue<pair<int,int>> queue;\\n        int ans = 0;\\n        for(int& n: forbidden) m[n]=true;\\n        queue.push(make_pair(0,0));\\n        while(!queue.empty()) {\\n            int size = queue.size();\\n            while(size--) {\\n                auto p = queue.front(); queue.pop();\\n                if(p.first == x) return ans;\\n                if(m[p.first]) continue;\\n                m[p.first]=true;\\n                \\n                              \\n                if(p.second == 0  && (p.first-b) >=0) {\\n                    queue.push(make_pair(p.first-b, 1));             \\n                }\\n\\t\\t\\t\\t//FORWARD CONDITION moved below  \\n                 if(p.first <= (2000+b)) {\\n                    queue.push(make_pair(p.first+a, 0));\\n                }\\n               \\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThis code is working fine and I don\\'t undestand why. Can someone help?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int,bool> m;\\n        queue<pair<int,int>> queue;\\n        int ans = 0;\\n        for(int& n: forbidden) m[n]=true;\\n        queue.push(make_pair(0,0));\\n        while(!queue.empty()) {\\n            int size = queue.size();\\n            while(size--) {\\n                auto p = queue.front(); queue.pop();\\n                if(p.first == x) return ans;\\n                if(m[p.first]) continue;\\n                m[p.first]=true;\\n                \\n             \\n\\t\\t\\t\\t  // I\\'m calling this FORWARD CONDITION\\n                 if(p.first <= (2000+b)) {\\n                    queue.push(make_pair(p.first+a, 0));\\n                }\\n               \\n\\t\\t\\t      \\n                if(p.second == 0  && (p.first-b) >=0) {\\n                    queue.push(make_pair(p.first-b, 1));             \\n                }\\n\\t\\t\\t   \\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        map<int,bool> m;\\n        queue<pair<int,int>> queue;\\n        int ans = 0;\\n        for(int& n: forbidden) m[n]=true;\\n        queue.push(make_pair(0,0));\\n        while(!queue.empty()) {\\n            int size = queue.size();\\n            while(size--) {\\n                auto p = queue.front(); queue.pop();\\n                if(p.first == x) return ans;\\n                if(m[p.first]) continue;\\n                m[p.first]=true;\\n                \\n                              \\n                if(p.second == 0  && (p.first-b) >=0) {\\n                    queue.push(make_pair(p.first-b, 1));             \\n                }\\n\\t\\t\\t\\t//FORWARD CONDITION moved below  \\n                 if(p.first <= (2000+b)) {\\n                    queue.push(make_pair(p.first+a, 0));\\n                }\\n               \\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027325,
                "title": "c-memoization",
                "content": "\\n```\\n    int memo(bool back, int start, int f, int b, int home, vector<vector<int>>& dp){\\n        if(start == home) return dp[start][back] = 0; \\n        if(start>6001|| start <0 || dp[start][back]== -2 ) return 1e5;\\n        if(dp[start][back] != -1) return dp[start][back]; \\n        dp[start][back] = 1+ memo(false,start+f, f,b,home, dp); \\n        if(!back) dp[start][back] = min(dp[start][back],1+memo(true,start-b, f,b,home, dp)); \\n        \\n        return dp[start][back] ; \\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6005, vector<int>(2, -1)); \\n        for(auto x:forbidden) dp[x][0] = -2, dp[x][1] = -2; \\n        int res = memo(false,0 , a,b,x , dp); \\n        return  res > 1e5 ? -1:res; \\n    }\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\n    int memo(bool back, int start, int f, int b, int home, vector<vector<int>>& dp){\\n        if(start == home) return dp[start][back] = 0; \\n        if(start>6001|| start <0 || dp[start][back]== -2 ) return 1e5;\\n        if(dp[start][back] != -1) return dp[start][back]; \\n        dp[start][back] = 1+ memo(false,start+f, f,b,home, dp); \\n        if(!back) dp[start][back] = min(dp[start][back],1+memo(true,start-b, f,b,home, dp)); \\n        \\n        return dp[start][back] ; \\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6005, vector<int>(2, -1)); \\n        for(auto x:forbidden) dp[x][0] = -2, dp[x][1] = -2; \\n        int res = memo(false,0 , a,b,x , dp); \\n        return  res > 1e5 ? -1:res; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935583,
                "title": "java-min-jumps-bug-100-fast",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        LinkedList<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0});\\n      \\n        boolean[][] visited = new boolean[4000][2];\\n        for(int i:forbidden){\\n          visited[i][0] = true;\\n          visited[i][1] = true;\\n        }\\n      \\n        while(!queue.isEmpty()){\\n          int curr[] = queue.remove();\\n          int pos = curr[0];\\n          int dir = curr[1];\\n          int level = curr[2];\\n          if(pos==x)\\n            return level;\\n          if(visited[pos][dir])\\n            continue;\\n          visited[pos][dir] = true;\\n          \\n          if(pos+a<4000)\\n            queue.add(new int[]{pos+a,0,level+1});\\n          \\n          if(pos-b>-1 && dir==0)\\n            queue.add(new int[]{pos-b,1,level+1});\\n        }\\n\\n        return -1;      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        LinkedList<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0});\\n      \\n        boolean[][] visited = new boolean[4000][2];\\n        for(int i:forbidden){\\n          visited[i][0] = true;\\n          visited[i][1] = true;\\n        }\\n      \\n        while(!queue.isEmpty()){\\n          int curr[] = queue.remove();\\n          int pos = curr[0];\\n          int dir = curr[1];\\n          int level = curr[2];\\n          if(pos==x)\\n            return level;\\n          if(visited[pos][dir])\\n            continue;\\n          visited[pos][dir] = true;\\n          \\n          if(pos+a<4000)\\n            queue.add(new int[]{pos+a,0,level+1});\\n          \\n          if(pos-b>-1 && dir==0)\\n            queue.add(new int[]{pos-b,1,level+1});\\n        }\\n\\n        return -1;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456541,
                "title": "simple-bfs-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int pos;\\n    boolean isBackward;\\n    Pair(int pos,boolean isBackward){\\n        this.pos=pos;\\n        this.isBackward=isBackward;\\n    }\\n}\\n\\n\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer>visited=new HashSet<>();\\n        for(int e:forbidden){\\n            visited.add(e);\\n        }\\n\\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(0,false));\\n        visited.add(0);\\n\\n        int limit=6000;// given in constarints (2000+2000+2000)\\n        int level=0;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                int pos=q.peek().pos;\\n                boolean isBackward=q.peek().isBackward;\\n                q.poll();\\n\\n                if(pos==x) return level;\\n\\n                if(!isBackward){\\n\\n                    int nextBackPos=pos-b;\\n                    if(nextBackPos>0 && !visited.contains(nextBackPos)){\\n                        visited.add(nextBackPos);\\n                        q.add(new Pair(nextBackPos,true));\\n                    }\\n                    \\n                }\\n                int nextForPos=pos+a;\\n                if(nextForPos<limit && !visited.contains(nextForPos)){\\n                    visited.add(nextForPos);\\n                    q.add(new Pair(nextForPos,false));\\n                }   \\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int pos;\\n    boolean isBackward;\\n    Pair(int pos,boolean isBackward){\\n        this.pos=pos;\\n        this.isBackward=isBackward;\\n    }\\n}\\n\\n\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer>visited=new HashSet<>();\\n        for(int e:forbidden){\\n            visited.add(e);\\n        }\\n\\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(0,false));\\n        visited.add(0);\\n\\n        int limit=6000;// given in constarints (2000+2000+2000)\\n        int level=0;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                int pos=q.peek().pos;\\n                boolean isBackward=q.peek().isBackward;\\n                q.poll();\\n\\n                if(pos==x) return level;\\n\\n                if(!isBackward){\\n\\n                    int nextBackPos=pos-b;\\n                    if(nextBackPos>0 && !visited.contains(nextBackPos)){\\n                        visited.add(nextBackPos);\\n                        q.add(new Pair(nextBackPos,true));\\n                    }\\n                    \\n                }\\n                int nextForPos=pos+a;\\n                if(nextForPos<limit && !visited.contains(nextForPos)){\\n                    visited.add(nextForPos);\\n                    q.add(new Pair(nextForPos,false));\\n                }   \\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788811,
                "title": "python-concise-bfs-easy-understanding",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden, visited, Q = set(forbidden), set(), deque()\\n        Q.append([0,0,True]) # [current_position, steps_taken_until_now, flag_for_saving_state_if_we_can_move_backward_from_this_position]\\n        threshold = max(forbidden) + x + a + b\\n        \\n        while Q:\\n            curr, steps, used = Q.popleft()\\n            \\n            if curr == x:\\n                return steps\\n            \\n            if (curr + a, False) not in visited and (curr + a) not in forbidden and (curr + a) <= threshold:\\n                Q.append([curr+a, steps+1, False])\\n                visited.add((curr+a, False))\\n            \\n            if (curr - b, True) not in visited and (curr - b) not in forbidden and not used and (curr - b) > 0 :\\n                Q.append([curr-b,steps + 1,True])\\n                visited.add((curr-b, True))\\n                         \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden, visited, Q = set(forbidden), set(), deque()\\n        Q.append([0,0,True]) # [current_position, steps_taken_until_now, flag_for_saving_state_if_we_can_move_backward_from_this_position]\\n        threshold = max(forbidden) + x + a + b\\n        \\n        while Q:\\n            curr, steps, used = Q.popleft()\\n            \\n            if curr == x:\\n                return steps\\n            \\n            if (curr + a, False) not in visited and (curr + a) not in forbidden and (curr + a) <= threshold:\\n                Q.append([curr+a, steps+1, False])\\n                visited.add((curr+a, False))\\n            \\n            if (curr - b, True) not in visited and (curr - b) not in forbidden and not used and (curr - b) > 0 :\\n                Q.append([curr-b,steps + 1,True])\\n                visited.add((curr-b, True))\\n                         \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694374,
                "title": "dfs-works-too",
                "content": "##### Java\\n```java\\nprivate int minimum = Integer.MAX_VALUE;\\n\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> forbiddenSet = Arrays.stream(forbidden).boxed().collect(Collectors.toSet());\\n        dfs(forbiddenSet, new HashSet<>(), x, 0, 0, a, b, false);\\n        return minimum == Integer.MAX_VALUE ? -1 : minimum;\\n    }\\n\\n    private void dfs(Set<Integer> forbidden, Set<Integer> visited, int target, int current, int jumps, int forward, int backward, boolean lastIsBack) {\\n        if (visited.contains(current) || forbidden.contains(current) || current < 0 || current > 6000 || jumps >= minimum)\\n            return;\\n\\n        if (!lastIsBack)\\n            visited.add(current);\\n        \\n        if (current == target)\\n            minimum = jumps;\\n        else {\\n            dfs(forbidden, visited, target, current + forward, jumps + 1, forward, backward, false);\\n            if (!lastIsBack)\\n                dfs(forbidden, visited, target, current - backward, jumps + 1, forward, backward, true);\\n        }\\n    }\\n```\\n\\n##### C++\\n```\\nprivate:\\n    int minimum = INT_MAX;\\n\\npublic:\\n    int minimumJumps(vector<int> &forbidden, int a, int b, int x) {\\n        unordered_set<int> forbiddenSet(forbidden.begin(), forbidden.end());\\n        unordered_set<int> visited;\\n        dfs(forbiddenSet, visited, x, 0, 0, a, b, false);\\n        return minimum == INT_MAX ? -1 : minimum;\\n    }\\n\\nprivate:\\n    void dfs(unordered_set<int> &forbidden, unordered_set<int> &visited, int target, int current, int jumps, int forward,int backward, bool lastIsBack) {\\n        if (visited.find(current) != visited.end() || forbidden.find(current) != visited.end() || current < 0 ||\\n            current > 6000 || jumps >= minimum)\\n            return;\\n\\n        if (!lastIsBack)\\n            visited.insert(current);\\n\\n        if (current == target)\\n            minimum = jumps;\\n        else {\\n            dfs(forbidden, visited, target, current + forward, jumps + 1, forward, backward, false);\\n            if (!lastIsBack)\\n                dfs(forbidden, visited, target, current - backward, jumps + 1, forward, backward, true);\\n        }\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\nprivate int minimum = Integer.MAX_VALUE;\\n\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> forbiddenSet = Arrays.stream(forbidden).boxed().collect(Collectors.toSet());\\n        dfs(forbiddenSet, new HashSet<>(), x, 0, 0, a, b, false);\\n        return minimum == Integer.MAX_VALUE ? -1 : minimum;\\n    }\\n\\n    private void dfs(Set<Integer> forbidden, Set<Integer> visited, int target, int current, int jumps, int forward, int backward, boolean lastIsBack) {\\n        if (visited.contains(current) || forbidden.contains(current) || current < 0 || current > 6000 || jumps >= minimum)\\n            return;\\n\\n        if (!lastIsBack)\\n            visited.add(current);\\n        \\n        if (current == target)\\n            minimum = jumps;\\n        else {\\n            dfs(forbidden, visited, target, current + forward, jumps + 1, forward, backward, false);\\n            if (!lastIsBack)\\n                dfs(forbidden, visited, target, current - backward, jumps + 1, forward, backward, true);\\n        }\\n    }\\n```\n```\\nprivate:\\n    int minimum = INT_MAX;\\n\\npublic:\\n    int minimumJumps(vector<int> &forbidden, int a, int b, int x) {\\n        unordered_set<int> forbiddenSet(forbidden.begin(), forbidden.end());\\n        unordered_set<int> visited;\\n        dfs(forbiddenSet, visited, x, 0, 0, a, b, false);\\n        return minimum == INT_MAX ? -1 : minimum;\\n    }\\n\\nprivate:\\n    void dfs(unordered_set<int> &forbidden, unordered_set<int> &visited, int target, int current, int jumps, int forward,int backward, bool lastIsBack) {\\n        if (visited.find(current) != visited.end() || forbidden.find(current) != visited.end() || current < 0 ||\\n            current > 6000 || jumps >= minimum)\\n            return;\\n\\n        if (!lastIsBack)\\n            visited.insert(current);\\n\\n        if (current == target)\\n            minimum = jumps;\\n        else {\\n            dfs(forbidden, visited, target, current + forward, jumps + 1, forward, backward, false);\\n            if (!lastIsBack)\\n                dfs(forbidden, visited, target, current - backward, jumps + 1, forward, backward, true);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2522402,
                "title": "python3-bfs-and-my-interpretation-of-how-to-find-the-upper-bound",
                "content": "```python\\nclass Solution1:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \"\"\"Very difficult one. I had the intuition correct, that by using BFS,\\n        we can always find the solution when x is reachable. The difficulty is\\n        when x is not reachable. Since we can always add a, there is no end\\n        to BFS. Thus, the key to the problem is to find the upper bound for\\n        BFS. If no solution is found within the upper bound, we can say x is\\n        not reachable.\\n\\n        To determine the upper bound, we have to use the Bezout\\'s Identity,\\n        which stipulates that given any integers u and v, a * v + b * v = n *\\n        gcd(a, b). In addition, we need some ingenuity, which is detailed in\\n        this post: https://leetcode.com/problems/minimum-jumps-to-reach-home/discuss/978357/C%2B%2B-bidirectional-BFS-solution-with-proof-for-search-upper-bound\\n\\n        I am going to describe here my understanding of finding the upper bound.\\n\\n        We know that if a >= b, we basically cannot go left. Thus, the upper\\n        bound is x itself. This means if we go beyond x, there is no way we\\n        can go back. So whenever we go beyond x, we know x is not reachable.\\n\\n        If a < b, we can go right and left. Now we can definitely go beyond x.\\n        Furthermore, to verify all possibilities, we have to go beyond\\n        max(forbidden), because the forbidden values add another layer of\\n        complexity. We must go beyond that to hit all possibilities associated\\n        with the forbidden value. Thus, the upper bound must be beyond max(x,\\n        max(forbidden)).\\n\\n        Given Bezout\\'s Identity, let p = n * gcd(a, b) that is the smallest\\n        value bigger than max(x, max(forbidden)). p is the left most point that\\n        we can reach beyond max(x, max(forbidden)). Notice that there is no\\n        more forbidden value to the right of p. Therefore, we don\\'t have to\\n        worry about the added complexity of forbidden values now.\\n\\n        Let\\'s say we are at p right now. The first move we can make that will\\n        land us in the new territory is p + a. Since a is a multiple of\\n        gcd(a, b), there are other points we can reach between p and p + a,\\n        such as:\\n\\n        p + gcd(a, b), p + 2 * gcd(a, b), ..., p - gcd(a, b) + a\\n\\n        Note that all these positions can only be reached by a left jump.\\n        Therefore, the upper bound must be p - gcd(a, b) + a + b.\\n\\n        One might ask, why can\\'t we go beyond p - gcd(a, b) + a + b? We\\n        certainly can, but going beyond p - gcd(a, b) + a + b won\\'t help us to\\n        reach x if we don\\'t go left. And if we go left, eventually we will end\\n        up at one of the positions in [p, p + a] again, and when that happens,\\n        we have already taken more steps than visiting the positions in\\n        [p, p + a] for the first time.\\n\\n        Therefore, the upper bound must be p - gcd(a, b) + a + b.\\n\\n        Since p = n * gcd(a, b) is the smallest multiple of gcd(a, b) that is\\n        larger than max(x, max(forbidden)), we have\\n        p - gcd(a, b) <= max(x, max(forbidden)). Thus, p - gcd(a, b) + a + b <=\\n        max(x, max(forbidden)) + a + b.\\n\\n        Therefore, it is perfectly okay for us to set the upper bound to be\\n        max(x, max(forbidden)) + a + b\\n\\n        Once we have the upper bound, we can use BFS to find the solution.\\n\\n        O(max(x, max(forbidden)) + a + b), 264 ms, faster than 31.58%\\n        \"\"\"\\n        upper_bound = max(x, max(forbidden)) + a + b\\n        forbidden = set(forbidden)\\n        queue = set([(0, False)])\\n        steps = 0\\n        visited = set()\\n        while queue:\\n            temp = set()\\n            for pos, is_pre_left in queue:\\n                visited.add(pos)\\n                if pos == x:\\n                    return steps\\n                if pos + a <= upper_bound and pos + a not in forbidden and pos + a not in visited:\\n                    temp.add((pos + a, False))\\n                if pos - b >= 0 and pos - b not in forbidden and pos - b not in visited and not is_pre_left:\\n                    temp.add((pos - b, True))\\n            if temp:\\n                steps += 1\\n            queue = temp\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution1:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \"\"\"Very difficult one. I had the intuition correct, that by using BFS,\\n        we can always find the solution when x is reachable. The difficulty is\\n        when x is not reachable. Since we can always add a, there is no end\\n        to BFS. Thus, the key to the problem is to find the upper bound for\\n        BFS. If no solution is found within the upper bound, we can say x is\\n        not reachable.\\n\\n        To determine the upper bound, we have to use the Bezout\\'s Identity,\\n        which stipulates that given any integers u and v, a * v + b * v = n *\\n        gcd(a, b). In addition, we need some ingenuity, which is detailed in\\n        this post: https://leetcode.com/problems/minimum-jumps-to-reach-home/discuss/978357/C%2B%2B-bidirectional-BFS-solution-with-proof-for-search-upper-bound\\n\\n        I am going to describe here my understanding of finding the upper bound.\\n\\n        We know that if a >= b, we basically cannot go left. Thus, the upper\\n        bound is x itself. This means if we go beyond x, there is no way we\\n        can go back. So whenever we go beyond x, we know x is not reachable.\\n\\n        If a < b, we can go right and left. Now we can definitely go beyond x.\\n        Furthermore, to verify all possibilities, we have to go beyond\\n        max(forbidden), because the forbidden values add another layer of\\n        complexity. We must go beyond that to hit all possibilities associated\\n        with the forbidden value. Thus, the upper bound must be beyond max(x,\\n        max(forbidden)).\\n\\n        Given Bezout\\'s Identity, let p = n * gcd(a, b) that is the smallest\\n        value bigger than max(x, max(forbidden)). p is the left most point that\\n        we can reach beyond max(x, max(forbidden)). Notice that there is no\\n        more forbidden value to the right of p. Therefore, we don\\'t have to\\n        worry about the added complexity of forbidden values now.\\n\\n        Let\\'s say we are at p right now. The first move we can make that will\\n        land us in the new territory is p + a. Since a is a multiple of\\n        gcd(a, b), there are other points we can reach between p and p + a,\\n        such as:\\n\\n        p + gcd(a, b), p + 2 * gcd(a, b), ..., p - gcd(a, b) + a\\n\\n        Note that all these positions can only be reached by a left jump.\\n        Therefore, the upper bound must be p - gcd(a, b) + a + b.\\n\\n        One might ask, why can\\'t we go beyond p - gcd(a, b) + a + b? We\\n        certainly can, but going beyond p - gcd(a, b) + a + b won\\'t help us to\\n        reach x if we don\\'t go left. And if we go left, eventually we will end\\n        up at one of the positions in [p, p + a] again, and when that happens,\\n        we have already taken more steps than visiting the positions in\\n        [p, p + a] for the first time.\\n\\n        Therefore, the upper bound must be p - gcd(a, b) + a + b.\\n\\n        Since p = n * gcd(a, b) is the smallest multiple of gcd(a, b) that is\\n        larger than max(x, max(forbidden)), we have\\n        p - gcd(a, b) <= max(x, max(forbidden)). Thus, p - gcd(a, b) + a + b <=\\n        max(x, max(forbidden)) + a + b.\\n\\n        Therefore, it is perfectly okay for us to set the upper bound to be\\n        max(x, max(forbidden)) + a + b\\n\\n        Once we have the upper bound, we can use BFS to find the solution.\\n\\n        O(max(x, max(forbidden)) + a + b), 264 ms, faster than 31.58%\\n        \"\"\"\\n        upper_bound = max(x, max(forbidden)) + a + b\\n        forbidden = set(forbidden)\\n        queue = set([(0, False)])\\n        steps = 0\\n        visited = set()\\n        while queue:\\n            temp = set()\\n            for pos, is_pre_left in queue:\\n                visited.add(pos)\\n                if pos == x:\\n                    return steps\\n                if pos + a <= upper_bound and pos + a not in forbidden and pos + a not in visited:\\n                    temp.add((pos + a, False))\\n                if pos - b >= 0 and pos - b not in forbidden and pos - b not in visited and not is_pre_left:\\n                    temp.add((pos - b, True))\\n            if temp:\\n                steps += 1\\n            queue = temp\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517465,
                "title": "c-bfs-easy-code-with-comments",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    // 3 -> Forbidden pos\\n    // 2 -> visited by forward move\\n    // 1 -> visited by backward move \\n    // 0 -> not visited\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int> m;\\n        for(auto x:forbidden)\\n            m[x]=3;\\n        \\n        int maxnum=10000;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        int res=0;\\n        m[0]=1;\\n        while(!q.empty())\\n        {\\n            int j=q.size();\\n            for(int i=0;i<j;i++)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                if(p.first==x)\\n                    return res;\\n                \\n                // <2 means either not visited or visited by backward move, so we can do a forward move\\n                if(p.first+a<=maxnum && m[p.first+a]<2)\\n                {\\n                    m[p.first+a]=2;\\n                    q.push({p.first+a,0});\\n                }\\n                if(p.first-b>0 && m[p.first-b]==0 && p.second==0)\\n                {\\n                    m[p.first-b]=1;\\n                    q.push({p.first-b,1});\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // 3 -> Forbidden pos\\n    // 2 -> visited by forward move\\n    // 1 -> visited by backward move \\n    // 0 -> not visited\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,int> m;\\n        for(auto x:forbidden)\\n            m[x]=3;\\n        \\n        int maxnum=10000;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        int res=0;\\n        m[0]=1;\\n        while(!q.empty())\\n        {\\n            int j=q.size();\\n            for(int i=0;i<j;i++)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                if(p.first==x)\\n                    return res;\\n                \\n                // <2 means either not visited or visited by backward move, so we can do a forward move\\n                if(p.first+a<=maxnum && m[p.first+a]<2)\\n                {\\n                    m[p.first+a]=2;\\n                    q.push({p.first+a,0});\\n                }\\n                if(p.first-b>0 && m[p.first-b]==0 && p.second==0)\\n                {\\n                    m[p.first-b]=1;\\n                    q.push({p.first-b,1});\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436117,
                "title": "dp-memo-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    int dp[7001][2];\\n    int solve(int i,int a,int b,int x,bool back)\\n    {\\n      if(i==x)return 0;\\n      if((i<0) || (i>6000) || (mp.find(i)!=mp.end()))\\n      {\\n        return 1e9;\\n      }\\n      if(dp[i][back]!=-1)return dp[i][back];\\n      //go forword\\n      dp[i][back]=1+solve(i+a,a,b,x,false);\\n      \\n      if(back==false) dp[i][back]=min(dp[i][back],1+solve(i-b,a,b,x,true));\\n      \\n      return dp[i][back];\\n      \\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int f:forbidden)mp[f]++;\\n        memset(dp,-1,sizeof(dp));\\n        int res=solve(0,a,b,x,false);\\n        if(res>=1e9)return -1;\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    int dp[7001][2];\\n    int solve(int i,int a,int b,int x,bool back)\\n    {\\n      if(i==x)return 0;\\n      if((i<0) || (i>6000) || (mp.find(i)!=mp.end()))\\n      {\\n        return 1e9;\\n      }\\n      if(dp[i][back]!=-1)return dp[i][back];\\n      //go forword\\n      dp[i][back]=1+solve(i+a,a,b,x,false);\\n      \\n      if(back==false) dp[i][back]=min(dp[i][back],1+solve(i-b,a,b,x,true));\\n      \\n      return dp[i][back];\\n      \\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int f:forbidden)mp[f]++;\\n        memset(dp,-1,sizeof(dp));\\n        int res=solve(0,a,b,x,false);\\n        if(res>=1e9)return -1;\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364299,
                "title": "very-easy-bfs-stepwise-explanation",
                "content": "```\\n// Here We are Using BFS Since every time there can be neighbours \\n// at every step (consider neighbours here as moving forward and backward position (if possible)).\\n// So here we apply simple bfs traversal. \\n\\n// We are keeping track of backward movement by queue second value i.e. -1 \\n// here since here no consecutive backward movement is allowed.\\n\\n// Map is used so that if we some point again then simply return because that point is already under process in queue (it just like visited array in out normal dfs/bfs). \\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& nums, int a, int b, int x) {\\n        queue<pair<int,int>> q;\\n        map<int,bool>seen;\\n        \\n        // mark forbidden values as seen \\n        for( int i = 0 ; i < nums.size() ;  i++ ){\\n            seen[nums[i]] = true;\\n        }\\n        \\n        // first  => current index\\n        // second => track of backward movement : 0=>we can move backward, -1 means we cannot move backward(we already moved back in previous turn)\\n        // we dont allow it to go backward?? => NO as it mentions in the comment we cannot go to negative integer indexes\\n        q.push({0,-1});\\n        \\n        int lvl = -1;\\n        \\n        while(!q.empty()){\\n            \\n            // increment the level\\n            lvl++;\\n            int sz = q.size();\\n            \\n            // process all the elements that were in the queue (not the elements that are being added now)\\n            while(sz--){\\n                int node = q.front().first;\\n                int val = q.front().second;\\n                q.pop();\\n                   \\n                // we reached the target position\\n                if(node == x){\\n                        return lvl;\\n                    }\\n                   \\n                //if this is a forbidden node/ or a visited node\\n                if(seen[node]){\\n                        continue;\\n                    }\\n            \\n                // mark current node as visited \\n                seen[node]=true;\\n                \\n                //we already made a backward step in the previous iteration\\n                if(val==-1){\\n                    \\n                    // move forward by a units\\n                    int k = a+node;\\n                    \\n                    // 2000+b => is taken as it will be the max amount we can go as , if we go to this location and then take b steps back we reach x\\n                    if(node<=2000+b){\\n                        q.push({k,0});\\n                    }\\n                    \\n                }\\n               //we made a forward step in the previous iteration\\n\\n                else if(val==0){\\n                    int k1= a + node;\\n                    int k2= node - b;\\n                    \\n                    // condition given in the question to not move to negative indexes\\n                    if(k2>=0){\\n                        q.push({k2,-1});\\n                    }\\n                    // if we are able to reach an index less than 2000+b we can explore it once, as we might go to xmax+b , if say b=2000 & x=2000 & a =2000 then to reach x we need to come back from x+b backward by moving a once(as we cant move backward twice)\\n                    if(node<=2000+b){\\n                        q.push({k1,0});\\n                    }\\n                }\\n            }\\n        }\\n        // if we did not reach the target position\\n        return -1;\\n    }\\n};\\n```\\ncredits: @77jj",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Here We are Using BFS Since every time there can be neighbours \\n// at every step (consider neighbours here as moving forward and backward position (if possible)).\\n// So here we apply simple bfs traversal. \\n\\n// We are keeping track of backward movement by queue second value i.e. -1 \\n// here since here no consecutive backward movement is allowed.\\n\\n// Map is used so that if we some point again then simply return because that point is already under process in queue (it just like visited array in out normal dfs/bfs). \\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& nums, int a, int b, int x) {\\n        queue<pair<int,int>> q;\\n        map<int,bool>seen;\\n        \\n        // mark forbidden values as seen \\n        for( int i = 0 ; i < nums.size() ;  i++ ){\\n            seen[nums[i]] = true;\\n        }\\n        \\n        // first  => current index\\n        // second => track of backward movement : 0=>we can move backward, -1 means we cannot move backward(we already moved back in previous turn)\\n        // we dont allow it to go backward?? => NO as it mentions in the comment we cannot go to negative integer indexes\\n        q.push({0,-1});\\n        \\n        int lvl = -1;\\n        \\n        while(!q.empty()){\\n            \\n            // increment the level\\n            lvl++;\\n            int sz = q.size();\\n            \\n            // process all the elements that were in the queue (not the elements that are being added now)\\n            while(sz--){\\n                int node = q.front().first;\\n                int val = q.front().second;\\n                q.pop();\\n                   \\n                // we reached the target position\\n                if(node == x){\\n                        return lvl;\\n                    }\\n                   \\n                //if this is a forbidden node/ or a visited node\\n                if(seen[node]){\\n                        continue;\\n                    }\\n            \\n                // mark current node as visited \\n                seen[node]=true;\\n                \\n                //we already made a backward step in the previous iteration\\n                if(val==-1){\\n                    \\n                    // move forward by a units\\n                    int k = a+node;\\n                    \\n                    // 2000+b => is taken as it will be the max amount we can go as , if we go to this location and then take b steps back we reach x\\n                    if(node<=2000+b){\\n                        q.push({k,0});\\n                    }\\n                    \\n                }\\n               //we made a forward step in the previous iteration\\n\\n                else if(val==0){\\n                    int k1= a + node;\\n                    int k2= node - b;\\n                    \\n                    // condition given in the question to not move to negative indexes\\n                    if(k2>=0){\\n                        q.push({k2,-1});\\n                    }\\n                    // if we are able to reach an index less than 2000+b we can explore it once, as we might go to xmax+b , if say b=2000 & x=2000 & a =2000 then to reach x we need to come back from x+b backward by moving a once(as we cant move backward twice)\\n                    if(node<=2000+b){\\n                        q.push({k1,0});\\n                    }\\n                }\\n            }\\n        }\\n        // if we did not reach the target position\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101575,
                "title": "c-bfs-no-dp",
                "content": "```\\n// Here We are Using BFS Since every time there can be neighbours \\n// at evry step (consider neighbours here as moving forward and backward position (if possible)).\\n// So here we apply simple bfs traversal. \\n// We are keeping track of backward movement by queue second value i.e. -1 \\n// here since here no consecutive backward movement is allowed.\\n// Map is used so that if we some point again then simply return because that point is already under process in queue (it just like visited array in out normal dfs/bfs). \\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>&nums, int a, int b, int x) {\\n        queue<pair<int,int>>q;\\n        map<int,bool>seen;\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            seen[nums[i]] = true;\\n        }\\n        q.push({0,-1});\\n        int lvl = -1;\\n        while(!q.empty())\\n        {\\n            lvl++;\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int node = q.front().first;\\n                int val = q.front().second;\\n                q.pop();\\n                if(node==x)\\n                {\\n                    return lvl;\\n                }\\n                if(seen[node])\\n                {\\n                    continue;\\n                }\\n                seen[node] = true;\\n                if(val==-1)\\n                {\\n                    int k = a+node;\\n                    if(node<=2000+b)\\n                    {\\n                      q.push({k,0});\\n                    }\\n                }\\n                else if(val==0)\\n                {\\n                    int k1 = a + node;\\n                    int k2 = node - b;\\n                    if(k2>=0)\\n                    {\\n                       q.push({k2,-1});\\n                    }\\n                    if(node<=2000+b)\\n                    {\\n                       q.push({k1,0});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Please Upvote if You like the code and Explanation..!! :):)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n// Here We are Using BFS Since every time there can be neighbours \\n// at evry step (consider neighbours here as moving forward and backward position (if possible)).\\n// So here we apply simple bfs traversal. \\n// We are keeping track of backward movement by queue second value i.e. -1 \\n// here since here no consecutive backward movement is allowed.\\n// Map is used so that if we some point again then simply return because that point is already under process in queue (it just like visited array in out normal dfs/bfs). \\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>&nums, int a, int b, int x) {\\n        queue<pair<int,int>>q;\\n        map<int,bool>seen;\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            seen[nums[i]] = true;\\n        }\\n        q.push({0,-1});\\n        int lvl = -1;\\n        while(!q.empty())\\n        {\\n            lvl++;\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int node = q.front().first;\\n                int val = q.front().second;\\n                q.pop();\\n                if(node==x)\\n                {\\n                    return lvl;\\n                }\\n                if(seen[node])\\n                {\\n                    continue;\\n                }\\n                seen[node] = true;\\n                if(val==-1)\\n                {\\n                    int k = a+node;\\n                    if(node<=2000+b)\\n                    {\\n                      q.push({k,0});\\n                    }\\n                }\\n                else if(val==0)\\n                {\\n                    int k1 = a + node;\\n                    int k2 = node - b;\\n                    if(k2>=0)\\n                    {\\n                       q.push({k2,-1});\\n                    }\\n                    if(node<=2000+b)\\n                    {\\n                       q.push({k1,0});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092842,
                "title": "javascript-bfs",
                "content": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(Number.MAX_SAFE_INTEGER); d.push(t); } return d; };\\n\\nconst minimumJumps = (forbidden, a, b, x) => {\\n    // save min dis in 0 index for +a, 1 for -b\\n    let dis = initialize2DArray(100005, 2), q = [[0, \\'s\\']], se = new Set(forbidden);\\n    dis[0][0] = 0;\\n    while (q.length) {\\n        let [cur, mark] = q.shift(), next = [cur + a, cur - b];\\n        let curPos = mark == \\'b\\' ? 1 : 0;\\n        for (const ne of next) {\\n            if (se.has(ne)) continue;\\n            if (ne < 0 || ne >= dis.length) continue;\\n            if (ne < cur && mark == \\'b\\') continue; // doesn\\'t allow two consective backwards\\n            let pos = ne < cur ? 1 : 0;\\n            if (dis[ne][pos] > dis[cur][curPos] + 1) { // update min distance\\n                dis[ne][pos] = dis[cur][curPos] + 1;\\n                q.push([ne, ne < cur ? \\'b\\' : \\'f\\']);\\n            }\\n        }\\n    }\\n    let res = Math.min(dis[x][0], dis[x][1])\\n    return res == Number.MAX_SAFE_INTEGER ? -1 : res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(Number.MAX_SAFE_INTEGER); d.push(t); } return d; };\\n\\nconst minimumJumps = (forbidden, a, b, x) => {\\n    // save min dis in 0 index for +a, 1 for -b\\n    let dis = initialize2DArray(100005, 2), q = [[0, \\'s\\']], se = new Set(forbidden);\\n    dis[0][0] = 0;\\n    while (q.length) {\\n        let [cur, mark] = q.shift(), next = [cur + a, cur - b];\\n        let curPos = mark == \\'b\\' ? 1 : 0;\\n        for (const ne of next) {\\n            if (se.has(ne)) continue;\\n            if (ne < 0 || ne >= dis.length) continue;\\n            if (ne < cur && mark == \\'b\\') continue; // doesn\\'t allow two consective backwards\\n            let pos = ne < cur ? 1 : 0;\\n            if (dis[ne][pos] > dis[cur][curPos] + 1) { // update min distance\\n                dis[ne][pos] = dis[cur][curPos] + 1;\\n                q.push([ne, ne < cur ? \\'b\\' : \\'f\\']);\\n            }\\n        }\\n    }\\n    let res = Math.min(dis[x][0], dis[x][1])\\n    return res == Number.MAX_SAFE_INTEGER ? -1 : res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2053201,
                "title": "javascript-dfs-memo",
                "content": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    let f = new Set(forbidden);\\n    let m = 2000 + 2 * b;\\n    let memo = {};\\n    let visited = new Set();\\n    let res = dfs(0, true);\\n    return res === Infinity ? -1 : res;\\n    \\n    function dfs(i,canJumpBack) {\\n        if (i === x) return 0;\\n        let key = `${i},${canJumpBack}`;\\n        visited.add(i);\\n        if (memo[key] !== undefined) return memo[key];\\n        if (i > m || i < 0) return Infinity;\\n        let min = Infinity;\\n        if (canJumpBack && !f.has(i - b) && !visited.has(i-b)) {\\n            min = Math.min(min, 1 + dfs(i - b, false));\\n        }\\n        \\n        if (!f.has(i + a) && !visited.has(i+a)) {\\n            min = Math.min(min, 1 + dfs(i + a, true));\\n        }\\n        \\n        visited.delete(i);\\n        return memo[key] = min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    let f = new Set(forbidden);\\n    let m = 2000 + 2 * b;\\n    let memo = {};\\n    let visited = new Set();\\n    let res = dfs(0, true);\\n    return res === Infinity ? -1 : res;\\n    \\n    function dfs(i,canJumpBack) {\\n        if (i === x) return 0;\\n        let key = `${i},${canJumpBack}`;\\n        visited.add(i);\\n        if (memo[key] !== undefined) return memo[key];\\n        if (i > m || i < 0) return Infinity;\\n        let min = Infinity;\\n        if (canJumpBack && !f.has(i - b) && !visited.has(i-b)) {\\n            min = Math.min(min, 1 + dfs(i - b, false));\\n        }\\n        \\n        if (!f.has(i + a) && !visited.has(i+a)) {\\n            min = Math.min(min, 1 + dfs(i + a, true));\\n        }\\n        \\n        visited.delete(i);\\n        return memo[key] = min;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2029519,
                "title": "java-bfs-beats-100",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        int pos;\\n        boolean dir;\\n        public Pair(int pos, boolean dir) {\\n            this.pos = pos;\\n            this.dir = dir;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] visited = new boolean[limit];\\n        for (int num: forbidden) {\\n            visited[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        visited[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                boolean dir = p.dir;\\n              \\n                if (pos == x) return step;\\n                \\n                if (dir==false) {\\n                    int backward = pos - b;\\n                  \\n                    if (backward > 0 && !visited[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        visited[backward] = true;\\n                    }\\n                }\\n                \\n                int forward = pos + a;\\n           \\n                if (forward < limit && !visited[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    visited[forward] = true;\\n                }\\n              \\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int pos;\\n        boolean dir;\\n        public Pair(int pos, boolean dir) {\\n            this.pos = pos;\\n            this.dir = dir;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        int limit = 2000 + 2 * b + 1;\\n        boolean[] visited = new boolean[limit];\\n        for (int num: forbidden) {\\n            visited[num] = true;\\n        }\\n        int step = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, false));\\n        visited[0] = true;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair p = q.poll();\\n                int pos = p.pos;\\n                boolean dir = p.dir;\\n              \\n                if (pos == x) return step;\\n                \\n                if (dir==false) {\\n                    int backward = pos - b;\\n                  \\n                    if (backward > 0 && !visited[backward]) {\\n                        q.offer(new Pair(backward, true));\\n                        visited[backward] = true;\\n                    }\\n                }\\n                \\n                int forward = pos + a;\\n           \\n                if (forward < limit && !visited[forward]) {\\n                    q.offer(new Pair(forward, false));\\n                    visited[forward] = true;\\n                }\\n              \\n                \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919466,
                "title": "c-bfs-solution-with-explanation",
                "content": "class Solution {\\npublic:\\n    \\n    /*\\n        Since here we need to find the minimum jumps to reach bugs home, so BFS algorithm can help.\\n        Now let\\'s understand the question.\\n        \\n        Suppose we are standing at any position on the x-axis then three options can be there -\\n        1. Our current position is forbidden or we have reached this position earlier. so we don\\'t need to take any action from this                point\\n        2. We can jump a steps forward. Note that a and b can have maximum value of 2000 so we cannot go to a position where \\n            curPosition>2000+b because we wont reach home in this case.\\n        3. We can jump b steps backward. But this step can be taken only when our last jump was forward otherwise we dont need to\\n            jump backward.\\n        \\n        To handle case 1 we can use a hashmap which will store whether our current position is forbidden or we have reached this                position before.\\n        \\n        To handle case 2 and case 3 we need a queue of pairs whose first  value will store our jump and whether the jump was \\n        forward or backward.\\n        1 - denote jump was backward\\n        0 - denote jump was forward.\\n        \\n        now we will run BFS taking these cases into consideration and if we reach our target we return jumps else when\\n        queue gets exhausted we return from it.\\n    */\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,bool> mp;\\n        for(auto i:forbidden)\\n            mp[i]=true;\\n        queue<pair<int,int> > q;\\n        q.push({0,0});\\n        int jumps=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                auto cur=q.front();\\n                q.pop();\\n                if(cur.first==x)\\n                    return jumps;\\n                if(mp[cur.first]==true)\\n                    continue;\\n                mp[cur.first]=true;\\n                if(cur.first-b>=0 && cur.second==0)\\n                    q.push({cur.first-b,1});\\n                if(cur.first<=2000+b)\\n                    q.push({cur.first+a,0});\\n            }\\n            jumps++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    /*\\n        Since here we need to find the minimum jumps to reach bugs home, so BFS algorithm can help.\\n        Now let\\'s understand the question.\\n        \\n        Suppose we are standing at any position on the x-axis then three options can be there -\\n        1. Our current position is forbidden or we have reached this position earlier. so we don\\'t need to take any action from this                point\\n        2. We can jump a steps forward. Note that a and b can have maximum value of 2000 so we cannot go to a position where \\n            curPosition>2000+b because we wont reach home in this case.\\n        3. We can jump b steps backward. But this step can be taken only when our last jump was forward otherwise we dont need to\\n            jump backward.\\n        \\n        To handle case 1 we can use a hashmap which will store whether our current position is forbidden or we have reached this                position before.\\n        \\n        To handle case 2 and case 3 we need a queue of pairs whose first  value will store our jump and whether the jump was \\n        forward or backward.\\n        1 - denote jump was backward\\n        0 - denote jump was forward.\\n        \\n        now we will run BFS taking these cases into consideration and if we reach our target we return jumps else when\\n        queue gets exhausted we return from it.\\n    */\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int,bool> mp;\\n        for(auto i:forbidden)\\n            mp[i]=true;\\n        queue<pair<int,int> > q;\\n        q.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1870865,
                "title": "dp-clean-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[6001][2]; //6000 or 6001 is maximum accessible distance and 2 is state forward/backward\\n    unordered_map<int,int> mp;//map to retrieve which value is forbidden otherwise we have to tarverse                                   //again and again in forbidden array\\n    int helper(int i,bool back,int a,int b,int x){\\n        if(i==x) return 0; \\n        if(i<0 || i>6000 || mp.find(i)!=mp.end() || back>=2) return 1e9; //Conddition we will not get ans\\n        if(dp[i][back]!=-1){\\n            return dp[i][back]; //if value is already stored return\\n        }\\n        dp[i][back]=1+helper(i+a,0,a,b,x); //1 is too denote we have taken 1 steps forward\\n        if(!back){\\n            dp[i][back]=min(dp[i][back],helper(i-b,1,a,b,x)+1); //We can not mve consecutively two times                                                                   //back\\n        }\\n        return dp[i][back];\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++){\\n            mp[forbidden[i]]=1;\\n        }\\n        memset(dp,-1,sizeof(dp));//Setting alll value of dp to -1\\n        int ans=helper(0,0,a,b,x);//First 0 will be starting index and second zero means forward step\\n        return ans>1e9?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[6001][2]; //6000 or 6001 is maximum accessible distance and 2 is state forward/backward\\n    unordered_map<int,int> mp;//map to retrieve which value is forbidden otherwise we have to tarverse                                   //again and again in forbidden array\\n    int helper(int i,bool back,int a,int b,int x){\\n        if(i==x) return 0; \\n        if(i<0 || i>6000 || mp.find(i)!=mp.end() || back>=2) return 1e9; //Conddition we will not get ans\\n        if(dp[i][back]!=-1){\\n            return dp[i][back]; //if value is already stored return\\n        }\\n        dp[i][back]=1+helper(i+a,0,a,b,x); //1 is too denote we have taken 1 steps forward\\n        if(!back){\\n            dp[i][back]=min(dp[i][back],helper(i-b,1,a,b,x)+1); //We can not mve consecutively two times                                                                   //back\\n        }\\n        return dp[i][back];\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++){\\n            mp[forbidden[i]]=1;\\n        }\\n        memset(dp,-1,sizeof(dp));//Setting alll value of dp to -1\\n        int ans=helper(0,0,a,b,x);//First 0 will be starting index and second zero means forward step\\n        return ans>1e9?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839974,
                "title": "simple-solution-in-java-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if(x == 0) return 0;\\n        \\n        // The bug cannot go in the backward direction two times\\n        \\n        HashSet<String> visited = new HashSet<>();\\n        for(int f : forbidden){\\n            visited.add(f+\",\"+1);\\n            visited.add(f+\",\"+0);\\n        }\\n        // Check if target is forbidden\\n        if(visited.contains(x+\",\"+0) || visited.contains(x+\",\"+1)) return -1;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        // Zero is the starting point\\n        // 1 -> Forward\\n        // 0 -> Backward\\n        queue.offer(new Pair(0, 1));\\n        visited.add(0+\",\"+1);\\n        \\n        int step = 0;\\n        while(!queue.isEmpty()){\\n            step++;\\n            \\n            int size = queue.size();\\n            for(int i=0; i<size; i++){\\n                Pair pa = queue.poll();\\n                \\n                /*\\n                   6000 because we don\\'t want to lose any state, as the max value of a and b is 2000, suppose if we take\\n\\t\\t\\t\\t   4000 value instead of 6000 and a and b are 2000, then 4000 and backward direction position will not \\n\\t\\t\\t\\t   be possible, to avoid that, take max value to be 6000 to be able to reach all the states \\n                */\\n                if(pa.x > 6000) continue; \\n                if(pa.x < 0) continue;\\n                \\n                // Check whether reached the target or not\\n                if((pa.x + a == x) || (pa.dir == 1 && pa.x - b == x)){\\n                   return step; \\n                }\\n                \\n                // Go forward\\n                if(!visited.contains( (pa.x + a) +\",\"+1)){\\n                    visited.add((pa.x + a)+\",\"+1);\\n                    queue.offer(new Pair(pa.x+a, 1));\\n                }\\n                \\n                // Go backward\\n                // Can only go backward if the current direction is not backward\\n                if(pa.dir != 0 && !visited.contains((pa.x - b) + \",\" + 0)){\\n                    visited.add((pa.x - b) + \",\" + 0);\\n                    queue.offer(new Pair(pa.x - b, 0));\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private class Pair{\\n        public int x;\\n        public int dir;\\n        \\n        public Pair(int x, int dir){\\n            this.x = x;\\n            this.dir = dir;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if(x == 0) return 0;\\n        \\n        // The bug cannot go in the backward direction two times\\n        \\n        HashSet<String> visited = new HashSet<>();\\n        for(int f : forbidden){\\n            visited.add(f+\",\"+1);\\n            visited.add(f+\",\"+0);\\n        }\\n        // Check if target is forbidden\\n        if(visited.contains(x+\",\"+0) || visited.contains(x+\",\"+1)) return -1;\\n        \\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        // Zero is the starting point\\n        // 1 -> Forward\\n        // 0 -> Backward\\n        queue.offer(new Pair(0, 1));\\n        visited.add(0+\",\"+1);\\n        \\n        int step = 0;\\n        while(!queue.isEmpty()){\\n            step++;\\n            \\n            int size = queue.size();\\n            for(int i=0; i<size; i++){\\n                Pair pa = queue.poll();\\n                \\n                /*\\n                   6000 because we don\\'t want to lose any state, as the max value of a and b is 2000, suppose if we take\\n\\t\\t\\t\\t   4000 value instead of 6000 and a and b are 2000, then 4000 and backward direction position will not \\n\\t\\t\\t\\t   be possible, to avoid that, take max value to be 6000 to be able to reach all the states \\n                */\\n                if(pa.x > 6000) continue; \\n                if(pa.x < 0) continue;\\n                \\n                // Check whether reached the target or not\\n                if((pa.x + a == x) || (pa.dir == 1 && pa.x - b == x)){\\n                   return step; \\n                }\\n                \\n                // Go forward\\n                if(!visited.contains( (pa.x + a) +\",\"+1)){\\n                    visited.add((pa.x + a)+\",\"+1);\\n                    queue.offer(new Pair(pa.x+a, 1));\\n                }\\n                \\n                // Go backward\\n                // Can only go backward if the current direction is not backward\\n                if(pa.dir != 0 && !visited.contains((pa.x - b) + \",\" + 0)){\\n                    visited.add((pa.x - b) + \",\" + 0);\\n                    queue.offer(new Pair(pa.x - b, 0));\\n                }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private class Pair{\\n        public int x;\\n        public int dir;\\n        \\n        public Pair(int x, int dir){\\n            this.x = x;\\n            this.dir = dir;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316296,
                "title": "easy-bfs-solution-ii",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>jumps;\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int, bool>mp;\\n        for(int i=0; i<forbidden.size(); i++)\\n            mp[forbidden[i]] = true;\\n        int n = 10001;\\n        jumps.resize(n, INT_MAX);\\n        jumps[0] = 0;\\n        \\n        queue<vector<int>>q;                     //currentPos, lastMove(0->forward, 1->backward), minJumps\\n        q.push({0, 0, 0});\\n        while(!q.empty()){\\n            auto top = q.front();\\n            q.pop();\\n            \\n            if(top[0] == x)\\n                return top[2];\\n            \\n            if(top[1] != 1 and mp.find(top[0] - b) == mp.end() and top[0]-b >= 0 and top[2]+1 < jumps[top[0] - b]){\\n                vector<int>v = {top[0] - b, 1, top[2]+1};\\n                q.push(v);\\n                jumps[top[0] - b] = top[2] + 1;\\n            }\\n            \\n            if(mp.find(top[0] + a) == mp.end() and top[0]+a < n and top[2]+1 < jumps[top[0]+a]){\\n                vector<int>v = {top[0] + a, 0, top[2]+1};\\n                q.push(v);\\n                jumps[top[0] + a] = top[2] + 1;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>jumps;\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int, bool>mp;\\n        for(int i=0; i<forbidden.size(); i++)\\n            mp[forbidden[i]] = true;\\n        int n = 10001;\\n        jumps.resize(n, INT_MAX);\\n        jumps[0] = 0;\\n        \\n        queue<vector<int>>q;                     //currentPos, lastMove(0->forward, 1->backward), minJumps\\n        q.push({0, 0, 0});\\n        while(!q.empty()){\\n            auto top = q.front();\\n            q.pop();\\n            \\n            if(top[0] == x)\\n                return top[2];\\n            \\n            if(top[1] != 1 and mp.find(top[0] - b) == mp.end() and top[0]-b >= 0 and top[2]+1 < jumps[top[0] - b]){\\n                vector<int>v = {top[0] - b, 1, top[2]+1};\\n                q.push(v);\\n                jumps[top[0] - b] = top[2] + 1;\\n            }\\n            \\n            if(mp.find(top[0] + a) == mp.end() and top[0]+a < n and top[2]+1 < jumps[top[0]+a]){\\n                vector<int>v = {top[0] + a, 0, top[2]+1};\\n                q.push(v);\\n                jumps[top[0] + a] = top[2] + 1;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248387,
                "title": "bfs-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\n        unordered_set<int> v;\\n        queue<pair<int,int>> q; // The second part of the pair is a flag which indicates whether the first is in reverse direction or not. \\n        for(int i = 0 ; i< forbidden.size() ; i++){\\n            v.insert(forbidden[i]) ;\\n        }\\n        q.push(make_pair(0,0)) ; // Since the first way to move is forward, second is 0.\\n        int ans = 0;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            while(size--){\\n                auto curr = q.front() ;\\n                q.pop() ;\\n                int num = curr.first;\\n                if(num == x){\\n                    return ans;\\n                }\\n               \\n                if(v.count(num) == 1){\\n                    continue;\\n                } \\n                v.insert(num);\\n                if(curr.second == 0){\\n                    // If curr.second is 1, it means that it cannot move backward second time. Hence, it is only executed when second is 0.\\n                    int step = num - b;\\n                    if(step >= 0){\\n                        q.push(make_pair(step,1));\\n                    }\\n                }\\n                int step = num+a;\\n                if(step <= 2000+a+b){\\n                    q.push(make_pair(step,0));\\n                    \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\n        unordered_set<int> v;\\n        queue<pair<int,int>> q; // The second part of the pair is a flag which indicates whether the first is in reverse direction or not. \\n        for(int i = 0 ; i< forbidden.size() ; i++){\\n            v.insert(forbidden[i]) ;\\n        }\\n        q.push(make_pair(0,0)) ; // Since the first way to move is forward, second is 0.\\n        int ans = 0;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            while(size--){\\n                auto curr = q.front() ;\\n                q.pop() ;\\n                int num = curr.first;\\n                if(num == x){\\n                    return ans;\\n                }\\n               \\n                if(v.count(num) == 1){\\n                    continue;\\n                } \\n                v.insert(num);\\n                if(curr.second == 0){\\n                    // If curr.second is 1, it means that it cannot move backward second time. Hence, it is only executed when second is 0.\\n                    int step = num - b;\\n                    if(step >= 0){\\n                        q.push(make_pair(step,1));\\n                    }\\n                }\\n                int step = num+a;\\n                if(step <= 2000+a+b){\\n                    q.push(make_pair(step,0));\\n                    \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242963,
                "title": "simple-bfs-solution-cpp",
                "content": "```\\nstruct info\\n    {\\n        int curr;bool flag;int count;\\n    };\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x)\\n    {\\n        unordered_map<int,int>vis;\\n        for(int i=0;i<forbidden.size();i++)\\n            vis[forbidden[i]]=1;\\n        queue<info>q1;\\n        q1.push({0,1,0});\\n        \\n        \\n        while(!q1.empty())\\n        {\\n            \\n            int curr=q1.front().curr;\\n            bool flag=q1.front().flag;\\n            int count=q1.front().count;\\n            //cout<<curr<<\" \";\\n            q1.pop();\\n            \\n            if(curr==x)\\n                return count;\\n            \\n            if(curr-b>=0 && vis[curr-b]==0 && flag==1)\\n            {\\n                q1.push({curr-b,0,count+1});\\n                vis[curr-b]=1;\\n            }\\n            if(vis[curr+a]==0 && curr+a<6000 )\\n            {\\n                q1.push({curr+a,1,count+1});\\n                vis[curr+a]=1;\\n            }\\n            \\n            count++;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nstruct info\\n    {\\n        int curr;bool flag;int count;\\n    };\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x)\\n    {\\n        unordered_map<int,int>vis;\\n        for(int i=0;i<forbidden.size();i++)\\n            vis[forbidden[i]]=1;\\n        queue<info>q1;\\n        q1.push({0,1,0});\\n        \\n        \\n        while(!q1.empty())\\n        {\\n            \\n            int curr=q1.front().curr;\\n            bool flag=q1.front().flag;\\n            int count=q1.front().count;\\n            //cout<<curr<<\" \";\\n            q1.pop();\\n            \\n            if(curr==x)\\n                return count;\\n            \\n            if(curr-b>=0 && vis[curr-b]==0 && flag==1)\\n            {\\n                q1.push({curr-b,0,count+1});\\n                vis[curr-b]=1;\\n            }\\n            if(vis[curr+a]==0 && curr+a<6000 )\\n            {\\n                q1.push({curr+a,1,count+1});\\n                vis[curr+a]=1;\\n            }\\n            \\n            count++;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n```",
                "codeTag": "C++"
            },
            {
                "id": 1145505,
                "title": "python-bfs-solution-using-deque",
                "content": "* it\\'s very hard to set the threshold, it can be changed if more test cases are involved.\\n\\nfrom collections import deque\\nclass Solution:\\n\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        stack = deque([(0,False,0)]) # first index records current position, second index records previous movement is backward or not, third index records the number of steps\\n        forbidden = set(forbidden)\\n        toofar = 6000 # very tricky threshold \\n        visited = set()\\n        while(stack):\\n            position, backward, step = stack.popleft()\\n            if position == x:\\n                return step\\n            if position> toofar or position in visited:\\n                continue\\n            if not backward: # we only add current position into visited when it is from forward movement\\n                visited.add(position)\\n            if position+a not in forbidden: # check if forward movement is possible \\n                stack.append((position+a, False, step+1))\\n            if position-b>0 and position-b not in forbidden and backward == False: # check if backward movement is possible\\n                stack.append((position-b, True, step+1))\\n        return -1",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "* it\\'s very hard to set the threshold, it can be changed if more test cases are involved.\\n\\nfrom collections import deque\\nclass Solution:\\n\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        stack = deque([(0,False,0)]) # first index records current position, second index records previous movement is backward or not, third index records the number of steps\\n        forbidden = set(forbidden)\\n        toofar = 6000 # very tricky threshold \\n        visited = set()\\n        while(stack):\\n            position, backward, step = stack.popleft()\\n            if position == x:\\n                return step\\n            if position> toofar or position in visited:\\n                continue\\n            if not backward: # we only add current position into visited when it is from forward movement\\n                visited.add(position)\\n            if position+a not in forbidden: # check if forward movement is possible \\n                stack.append((position+a, False, step+1))\\n            if position-b>0 and position-b not in forbidden and backward == False: # check if backward movement is possible\\n                stack.append((position-b, True, step+1))\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 1098702,
                "title": "easiest-bfs-java-solution",
                "content": "```\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass Solution {\\n\\n    public int minimumJumps(int[] f, int a, int b, int x) {\\n        Set<Integer> forbidden = Arrays.stream(f).boxed().collect(Collectors.toSet());\\n\\n        Queue<int[]> queue = new ArrayDeque<>();\\n\\n        queue.offer(new int[]{0, 0, 1});    // currentPosition, cost, canJumpBack\\n\\n        while (!queue.isEmpty()){\\n            int[] t = queue.poll();\\n            int pos = t[0];\\n            int cost = t[1];\\n            int canJumpBack = t[2];\\n\\n            if(pos == x) return cost;\\n            if(forbidden.contains(pos)) continue;\\n            forbidden.add(pos);\\n\\n            int next = pos + a;\\n            int prev = pos - b;\\n            \\n            if(!forbidden.contains(prev) && prev >= 0 && canJumpBack == 1) {\\n                queue.offer(new int[]{prev, cost + 1, 0});\\n            }\\n\\n            if(!forbidden.contains(next) && next < 6000) {\\n                queue.offer(new int[]{next, cost + 1, 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass Solution {\\n\\n    public int minimumJumps(int[] f, int a, int b, int x) {\\n        Set<Integer> forbidden = Arrays.stream(f).boxed().collect(Collectors.toSet());\\n\\n        Queue<int[]> queue = new ArrayDeque<>();\\n\\n        queue.offer(new int[]{0, 0, 1});    // currentPosition, cost, canJumpBack\\n\\n        while (!queue.isEmpty()){\\n            int[] t = queue.poll();\\n            int pos = t[0];\\n            int cost = t[1];\\n            int canJumpBack = t[2];\\n\\n            if(pos == x) return cost;\\n            if(forbidden.contains(pos)) continue;\\n            forbidden.add(pos);\\n\\n            int next = pos + a;\\n            int prev = pos - b;\\n            \\n            if(!forbidden.contains(prev) && prev >= 0 && canJumpBack == 1) {\\n                queue.offer(new int[]{prev, cost + 1, 0});\\n            }\\n\\n            if(!forbidden.contains(next) && next < 6000) {\\n                queue.offer(new int[]{next, cost + 1, 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1093297,
                "title": "python-java-solution-bfs-faster-than-100-solutions",
                "content": "**Java Solution (15ms)**\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<int[]> queue=new LinkedList<>();\\n        queue.offer(new int[]{x,0,1});\\n        Set<Integer> vis=new HashSet<>();\\n        Integer lim=x;\\n        for (int i: forbidden) {vis.add(i); lim=Math.max(lim,i);};\\n        lim+=a+b;\\n        while (!queue.isEmpty()){\\n            int[] temp=queue.poll();\\n            int curr=temp[0], jumps=temp[1], is_b=temp[2];\\n            if(curr<0 || curr>lim || vis.contains(curr)) continue;\\n            vis.add(curr);\\n            if (curr==0) return jumps;\\n            if(is_b==1) queue.offer(new int[]{curr+b, jumps+1, 0});\\n            queue.offer(new int[]{curr-a, jumps+1, 1});\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Python Solution (76ms)**\\n```\\nclass Solution:\\n    def minimumJumps(self, vis: List[int], a: int, b: int, x: int) -> int:\\n        queue,vis=[(x,0,True)],set(vis)\\n        lim=max(max(vis),x)+a+b\\n        while queue:\\n            curr,jumps,is_b=queue.pop(0)\\n            if curr in vis or not 0<=curr<=lim: continue\\n            vis.add(curr)\\n            if curr==0: return jumps\\n            if is_b: queue.append((curr+b,jumps+1,False))\\n            queue.append((curr-a,jumps+1,True))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<int[]> queue=new LinkedList<>();\\n        queue.offer(new int[]{x,0,1});\\n        Set<Integer> vis=new HashSet<>();\\n        Integer lim=x;\\n        for (int i: forbidden) {vis.add(i); lim=Math.max(lim,i);};\\n        lim+=a+b;\\n        while (!queue.isEmpty()){\\n            int[] temp=queue.poll();\\n            int curr=temp[0], jumps=temp[1], is_b=temp[2];\\n            if(curr<0 || curr>lim || vis.contains(curr)) continue;\\n            vis.add(curr);\\n            if (curr==0) return jumps;\\n            if(is_b==1) queue.offer(new int[]{curr+b, jumps+1, 0});\\n            queue.offer(new int[]{curr-a, jumps+1, 1});\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minimumJumps(self, vis: List[int], a: int, b: int, x: int) -> int:\\n        queue,vis=[(x,0,True)],set(vis)\\n        lim=max(max(vis),x)+a+b\\n        while queue:\\n            curr,jumps,is_b=queue.pop(0)\\n            if curr in vis or not 0<=curr<=lim: continue\\n            vis.add(curr)\\n            if curr==0: return jumps\\n            if is_b: queue.append((curr+b,jumps+1,False))\\n            queue.append((curr-a,jumps+1,True))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083263,
                "title": "c-bfs-with-brief-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        int big = 6005;\\n        vector<vector<int>> dp(big, vector<int>(2, -1)); // Keep track of visited positions.\\n        \\n        for(auto f : forbidden) {\\n            dp[f][0] = -2;\\n            dp[f][1] = -2;\\n        }\\n        \\n        // vector {position, jumpBack, step}.\\n        queue<vector<int>> q;\\n        q.push({0, 0, 0});\\n        \\n        while(!q.empty()) {\\n            auto v = q.front();\\n            q.pop();\\n            \\n            if(v[0] == x) return v[2];\\n            \\n            // visited, including forbidden.\\n            if(dp[v[0]][v[1]] != -1) {\\n                continue;\\n            } \\n            \\n            dp[v[0]][v[1]] = 1; // Mark as visited.\\n            \\n            if(v[0] + a < big) q.push({v[0]+ a, 0, v[2] + 1});\\n            if(v[1] == 0 && v[0] - b >= 0) q.push({v[0] - b, 1, v[2] + 1});\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        int big = 6005;\\n        vector<vector<int>> dp(big, vector<int>(2, -1)); // Keep track of visited positions.\\n        \\n        for(auto f : forbidden) {\\n            dp[f][0] = -2;\\n            dp[f][1] = -2;\\n        }\\n        \\n        // vector {position, jumpBack, step}.\\n        queue<vector<int>> q;\\n        q.push({0, 0, 0});\\n        \\n        while(!q.empty()) {\\n            auto v = q.front();\\n            q.pop();\\n            \\n            if(v[0] == x) return v[2];\\n            \\n            // visited, including forbidden.\\n            if(dp[v[0]][v[1]] != -1) {\\n                continue;\\n            } \\n            \\n            dp[v[0]][v[1]] = 1; // Mark as visited.\\n            \\n            if(v[0] + a < big) q.push({v[0]+ a, 0, v[2] + 1});\\n            if(v[1] == 0 && v[0] - b >= 0) q.push({v[0] - b, 1, v[2] + 1});\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052778,
                "title": "python-easy-understanding-bfs-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        visited = set()\\n        limit = max(x, max(forbidden)) + a + b\\n        queue = [(0, 0, False)]\\n        while queue:\\n            pos, step, back = queue.pop(0)\\n            if pos > limit or pos < 0 or pos in forbidden or (pos, back) in visited:\\n                continue\\n            if pos == x:\\n                return step\\n            queue.append((pos+a, step+1, False))\\n            if not back: queue.append((pos-b, step+1, True))\\n            visited.add((pos, back))\\n        return -1\\n```\\nA traditional BFS solution by using queue. Each **element** in the queue contains:\\n* `pos`: The current position of the bug;\\n* `step`: The total step;\\n* `back`: Check if the previous step is jumping backward.\\n\\nThe **terminal conditions** is declared in the question:\\n1. `pos < 0`: The bug cannot jump to the negative position;\\n2. `pos in forbidden`: The bug cannot jump to the forbidden position;\\n3. `(pos, back) in visited`: To prevent the bug repeatly jumps between the previous and current position, it is noticeable that jump forward or backward to the position is totally different;\\n4. `pos > limit`: As `0 <= x <= 2000`, the maximum index of position will not beyond `limit`, which `limit = max(x, max(forbidden)) + a + b`.\\n\\nThe **recurrence**:\\n1. Jump forward: `queue.append((pos+a, step+1, False))`;\\n2. Jump backward: `queue.append((pos-b, step+1, True))` if the previoius step jumped forward (`if not back`).",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        visited = set()\\n        limit = max(x, max(forbidden)) + a + b\\n        queue = [(0, 0, False)]\\n        while queue:\\n            pos, step, back = queue.pop(0)\\n            if pos > limit or pos < 0 or pos in forbidden or (pos, back) in visited:\\n                continue\\n            if pos == x:\\n                return step\\n            queue.append((pos+a, step+1, False))\\n            if not back: queue.append((pos-b, step+1, True))\\n            visited.add((pos, back))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972220,
                "title": "python-recursive-approach-with-comments",
                "content": "```\\nimport functools \\n\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        denied = {}\\n        for i in forbidden:\\n            denied[i]=True\\n        visited = {}\\n        \\n        @lru_cache(None)\\n        def solve(position, is_back_jump_again):\\n            if (position, is_back_jump_again) in visited:   # If the condition is already visited.\\n                return float(\\'inf\\')\\n            else:\\n                visited[ (position, is_back_jump_again)] = True   # Else add it to visited list\\n            \\n            if position == x:   # Reached the required posiiton\\n                return 0\\n            \\n            if position in denied or position > 5998:  \\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tIf landed in the denied area or went too far from destination\\n\\t\\t\\t\\t\"\"\"\\n                return float(\\'inf\\')\\n            \\n            if is_back_jump_again or position-b<0: # If went in negative zone then move ahead only\\n                return 1 + solve(position+a, False)\\n            \\n            return 1 + min(solve(position+a, False), solve(position-b, True))\\n        \\n        ans = solve(0, False)\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools \\n\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        denied = {}\\n        for i in forbidden:\\n            denied[i]=True\\n        visited = {}\\n        \\n        @lru_cache(None)\\n        def solve(position, is_back_jump_again):\\n            if (position, is_back_jump_again) in visited:   # If the condition is already visited.\\n                return float(\\'inf\\')\\n            else:\\n                visited[ (position, is_back_jump_again)] = True   # Else add it to visited list\\n            \\n            if position == x:   # Reached the required posiiton\\n                return 0\\n            \\n            if position in denied or position > 5998:  \\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tIf landed in the denied area or went too far from destination\\n\\t\\t\\t\\t\"\"\"\\n                return float(\\'inf\\')\\n            \\n            if is_back_jump_again or position-b<0: # If went in negative zone then move ahead only\\n                return 1 + solve(position+a, False)\\n            \\n            return 1 + min(solve(position+a, False), solve(position-b, True))\\n        \\n        ans = solve(0, False)\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967434,
                "title": "the-simplest-bfs-ever-don-t-mark-backward-nodes-as-visited",
                "content": "Only important point is to not mark nodes where we have jumped backward as visited! Because then we could not go from that point backward once more. And we maybe could come to that point from forward direction and then go back. \\n```\\nclass Position {\\n\\tint x;\\n\\tint step;\\n\\tboolean backward;\\n\\t\\n\\tpublic Position(int x, int step, boolean backward) {\\n\\t\\tthis.x = x;\\n\\t\\tthis.step = step;\\n\\t\\tthis.backward = backward;\\n\\t}\\n}\\n\\npublic class Solution {\\n\\n\\tpublic int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        \\n\\t\\tif (x == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\tSet<Integer> forbiddenSet = new HashSet<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < forbidden.length; i++) {\\n\\t\\t\\tforbiddenSet.add(forbidden[i]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tSet<Integer> visited = new HashSet<>();\\n\\t\\t\\n\\t\\tvisited.add(0);\\n\\t\\t\\n\\t\\tQueue<Position> q = new LinkedList<>();\\n\\t\\t\\n\\t\\tif (!forbiddenSet.contains(a)) {\\n\\t\\t\\tq.add(new Position(a, 1, false));\\n\\t\\t}\\n\\t\\t\\n\\t\\twhile (!q.isEmpty()) {\\n\\t\\t\\t\\n\\t\\t\\tPosition position = q.remove();\\n\\t\\t\\t\\n\\t\\t\\tif (position.x == x) {\\n\\t\\t\\t\\treturn position.step;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (position.x + a <= 6000 && !forbiddenSet.contains(position.x + a)\\n\\t\\t\\t\\t\\t&& !visited.contains(position.x + a)) {\\n\\t\\t\\t\\tq.add(new Position(position.x + a, position.step + 1, false));\\n\\t\\t\\t\\tvisited.add(position.x + a);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (position.x - b > 0 && !position.backward && !forbiddenSet.contains(position.x - b)\\n\\t\\t\\t\\t\\t&& !visited.contains(position.x - b)) {\\n\\t\\t\\t\\tq.add(new Position(position.x - b, position.step + 1, true));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\tpublic int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        \\n\\t\\tif (x == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 940613,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        F = set(forbidden)\\n        visited = set()\\n        @lru_cache(None)\\n        def dfs(i,isPrevBack):\\n            if (i,isPrevBack) in visited: return math.inf\\n            else: visited.add((i,isPrevBack))\\n            if i == x: return 0\\n            if i in F or i > 6000: return math.inf\\n            if isPrevBack or i - b <= 0: return 1 + dfs(i + a, False)\\n            return 1 + min(dfs(i + a, False), dfs(i - b, True))\\n        ans = dfs(0,False)\\n        return ans if ans < math.inf else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        F = set(forbidden)\\n        visited = set()\\n        @lru_cache(None)\\n        def dfs(i,isPrevBack):\\n            if (i,isPrevBack) in visited: return math.inf\\n            else: visited.add((i,isPrevBack))\\n            if i == x: return 0\\n            if i in F or i > 6000: return math.inf\\n            if isPrevBack or i - b <= 0: return 1 + dfs(i + a, False)\\n            return 1 + min(dfs(i + a, False), dfs(i - b, True))\\n        ans = dfs(0,False)\\n        return ans if ans < math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936219,
                "title": "c-keeping-both-current-and-isback-in-state",
                "content": "```csharp\\npublic int MinimumJumps(int[] forbidden, int a, int b, int x)\\n{\\n\\tHashSet<int> blocked = new HashSet<int>(forbidden);\\n\\tHashSet<(int, bool)> visited = new HashSet<(int, bool)>();\\n\\tQueue<(int, bool)> q = new Queue<(int, bool)>();\\n\\n\\tq.Enqueue((0, false));\\n\\tvisited.Add((0, false));\\n\\tint result = 0;\\n\\tint maxForbidden = forbidden.Max();\\n\\tint max = Math.Max(x, maxForbidden) + 2 * a + b + 1;\\n\\n\\twhile(q.Count > 0)\\n\\t{\\n\\t\\tint count = q.Count;\\n\\t\\tfor(int i = 0; i < count; i++)\\n\\t\\t{\\n\\t\\t\\t(int current, bool isBack) = q.Dequeue();                \\n\\t\\t\\tif(current == x)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint forward = current + a;\\n\\t\\t\\tint backward = current - b;\\n\\n\\t\\t\\tif(forward > 0 && forward < max && !blocked.Contains(forward) && !visited.Contains((forward, false)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tvisited.Add((forward, false));\\n\\t\\t\\t\\tq.Enqueue((forward, false));\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(!isBack && backward > 0 && backward < max && !blocked.Contains(backward) && !visited.Contains((backward, true)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tvisited.Add((backward, true));\\n\\t\\t\\t\\tq.Enqueue((backward, true));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tresult++;\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinimumJumps(int[] forbidden, int a, int b, int x)\\n{\\n\\tHashSet<int> blocked = new HashSet<int>(forbidden);\\n\\tHashSet<(int, bool)> visited = new HashSet<(int, bool)>();\\n\\tQueue<(int, bool)> q = new Queue<(int, bool)>();\\n\\n\\tq.Enqueue((0, false));\\n\\tvisited.Add((0, false));\\n\\tint result = 0;\\n\\tint maxForbidden = forbidden.Max();\\n\\tint max = Math.Max(x, maxForbidden) + 2 * a + b + 1;\\n\\n\\twhile(q.Count > 0)\\n\\t{\\n\\t\\tint count = q.Count;\\n\\t\\tfor(int i = 0; i < count; i++)\\n\\t\\t{\\n\\t\\t\\t(int current, bool isBack) = q.Dequeue();                \\n\\t\\t\\tif(current == x)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint forward = current + a;\\n\\t\\t\\tint backward = current - b;\\n\\n\\t\\t\\tif(forward > 0 && forward < max && !blocked.Contains(forward) && !visited.Contains((forward, false)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tvisited.Add((forward, false));\\n\\t\\t\\t\\tq.Enqueue((forward, false));\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(!isBack && backward > 0 && backward < max && !blocked.Contains(backward) && !visited.Contains((backward, true)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tvisited.Add((backward, true));\\n\\t\\t\\t\\tq.Enqueue((backward, true));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tresult++;\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935605,
                "title": "python-bfs-faster-than-100",
                "content": "In the first I had the same issue with many people: can\\'t past the test case:\\n[162,118,178,152,167,100,40,74,199,186,26,73,200,127,30,124,193,84,184,36,103,149,153,9,54,154,133,95,45,198,79,157,64,122,59,71,48,177,82,35,14,176,16,108,111,6,168,31,134,164,136,72,98]\\n29\\n98\\n80\\n\\nThen I updated the code, key is about the visited set, if a position is in visited, we can\\'t ban it, because maybe we can still visit it in another direction. What we need to do is to make sure that we do not visit it in the same way as last time (forward or backward)\\n```\\nfrom queue import Queue\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x==0: return 0\\n        forbidden=set(forbidden)\\n        visited=set([(0,0)])\\n        Q=Queue()\\n        \\n        #record prevous jump, 1 means forward, -1 means backward\\n        Q.put((0,0))\\n        step=0\\n        \\n        while Q.qsize():\\n            n=Q.qsize()\\n            for _ in range(n):\\n                pos,prev=Q.get()\\n                if pos==x: return step\\n                visited.add((pos,prev))\\n\\n                forward,backward=pos+a,pos-b\\n                if (forward,1) not in visited and forward not in forbidden and forward<=max(forbidden) + 2*b:\\n                    Q.put((forward,1))\\n                    visited.add((forward,1))\\n                \\n                if (backward,-1) not in visited and backward not in forbidden and prev!=-1 and backward>=0:\\n                    Q.put((backward,-1))\\n                    visited.add((backward,-1))\\n            step+=1\\n        return -1\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom queue import Queue\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x==0: return 0\\n        forbidden=set(forbidden)\\n        visited=set([(0,0)])\\n        Q=Queue()\\n        \\n        #record prevous jump, 1 means forward, -1 means backward\\n        Q.put((0,0))\\n        step=0\\n        \\n        while Q.qsize():\\n            n=Q.qsize()\\n            for _ in range(n):\\n                pos,prev=Q.get()\\n                if pos==x: return step\\n                visited.add((pos,prev))\\n\\n                forward,backward=pos+a,pos-b\\n                if (forward,1) not in visited and forward not in forbidden and forward<=max(forbidden) + 2*b:\\n                    Q.put((forward,1))\\n                    visited.add((forward,1))\\n                \\n                if (backward,-1) not in visited and backward not in forbidden and prev!=-1 and backward>=0:\\n                    Q.put((backward,-1))\\n                    visited.add((backward,-1))\\n            step+=1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935461,
                "title": "c-dp-solution",
                "content": "```\\nconst int inf = 1e6;\\nint cache[6005][2];\\nint a,b,x;\\nint check_forbidden[6005];\\nint dp(int cur,int f)\\n{\\n    // f - > previously how many consecutive backward operation perform.\\n    //cur -> cur position of bug.   \\n   // stop condition of Memoization\\n    if(cur < 0 or cur > 6000 or check_forbidden[cur] or f >= 2) \\n        return inf;\\n    if(cur == x)\\n        return 0;\\n    int &ans = cache[cur][f];\\n    if(ans != -1)\\n        return ans;\\n    // forward operation\\n    ans = dp(cur+a,0) + 1;\\n    // backward operation \\n    ans = min(ans , dp(cur-b , f+1)+1);\\n \\xA0 \\xA0return ans;\\n\\t\\n}\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a1, int b1, int x1) {\\n        a = a1,b = b1,x = x1;\\n        // initialize  check_forbidden array by zero      \\n        memset(check_forbidden,0,sizeof(check_forbidden));\\n        // make the position in check_forbidden array 1 where bug cannot jump.     \\n        for(auto it : forbidden)\\n            check_forbidden[it] = 1;\\n        // initialize  cache array by -1 \\n        memset(cache,-1,sizeof(cache));\\n        int ans = dp(0,0);\\n        // means no possible sequence found         \\n        if(ans >= inf)\\n            ans = -1;\\n        return ans;\\n    }\\n};\\n```\\n***feel free to ask if having any doubt***",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nconst int inf = 1e6;\\nint cache[6005][2];\\nint a,b,x;\\nint check_forbidden[6005];\\nint dp(int cur,int f)\\n{\\n    // f - > previously how many consecutive backward operation perform.\\n    //cur -> cur position of bug.   \\n   // stop condition of Memoization\\n    if(cur < 0 or cur > 6000 or check_forbidden[cur] or f >= 2) \\n        return inf;\\n    if(cur == x)\\n        return 0;\\n    int &ans = cache[cur][f];\\n    if(ans != -1)\\n        return ans;\\n    // forward operation\\n    ans = dp(cur+a,0) + 1;\\n    // backward operation \\n    ans = min(ans , dp(cur-b , f+1)+1);\\n \\xA0 \\xA0return ans;\\n\\t\\n}\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a1, int b1, int x1) {\\n        a = a1,b = b1,x = x1;\\n        // initialize  check_forbidden array by zero      \\n        memset(check_forbidden,0,sizeof(check_forbidden));\\n        // make the position in check_forbidden array 1 where bug cannot jump.     \\n        for(auto it : forbidden)\\n            check_forbidden[it] = 1;\\n        // initialize  cache array by -1 \\n        memset(cache,-1,sizeof(cache));\\n        int ans = dp(0,0);\\n        // means no possible sequence found         \\n        if(ans >= inf)\\n            ans = -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824089,
                "title": "recursive-solution-memoisation-7-lines-of-code-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> blocked =  Arrays.stream(forbidden).boxed().collect(Collectors.toSet());\\n        final int MAX_POSITION = 6001, BACKWARD = 2;\\n        long[][] memo = new long[MAX_POSITION][BACKWARD];\\n        for(long[] row: memo) Arrays.fill(row, -1);\\n        long minJumps = getMinJumps(0, 0, a, b, x, blocked, memo);\\n        return minJumps >= Integer.MAX_VALUE ? - 1 : (int) minJumps;\\n    }\\n\\n    private long getMinJumps(int pos, int back, int f, int b, int home, Set<Integer> blocked, long[][] memo) {\\n        if(pos == home) return 0;\\n        if(pos < 0 || pos > 6000 || blocked.contains(pos) || back >= 2) return Integer.MAX_VALUE;\\n        if(memo[pos][back] != -1) return memo[pos][back];\\n        memo[pos][back] = 1L + getMinJumps(pos + f, 0, f, b, home, blocked, memo);\\n        if(back == 0) memo[pos][back] = Math.min(memo[pos][back], 1L + getMinJumps(pos - b, 1, f, b, home, blocked, memo));\\n        return memo[pos][back];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> blocked =  Arrays.stream(forbidden).boxed().collect(Collectors.toSet());\\n        final int MAX_POSITION = 6001, BACKWARD = 2;\\n        long[][] memo = new long[MAX_POSITION][BACKWARD];\\n        for(long[] row: memo) Arrays.fill(row, -1);\\n        long minJumps = getMinJumps(0, 0, a, b, x, blocked, memo);\\n        return minJumps >= Integer.MAX_VALUE ? - 1 : (int) minJumps;\\n    }\\n\\n    private long getMinJumps(int pos, int back, int f, int b, int home, Set<Integer> blocked, long[][] memo) {\\n        if(pos == home) return 0;\\n        if(pos < 0 || pos > 6000 || blocked.contains(pos) || back >= 2) return Integer.MAX_VALUE;\\n        if(memo[pos][back] != -1) return memo[pos][back];\\n        memo[pos][back] = 1L + getMinJumps(pos + f, 0, f, b, home, blocked, memo);\\n        if(back == 0) memo[pos][back] = Math.min(memo[pos][back], 1L + getMinJumps(pos - b, 1, f, b, home, blocked, memo));\\n        return memo[pos][back];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548500,
                "title": "simplest-c-well-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& f, int a, int b, int x) \\n    {\\n        int res = 0; \\n        unordered_set<int> s(f.begin(),f.end());\\n        queue<pair<int,pair<int,int>>> q; // {coordinate,{jump,prev_state}}\\n        q.push({0,{0,0}}); // 0 means no backward jump was taken you can go backward\\n        s.insert(0);// we need not to visit 0 again so we put it in set\\n        \\n        \\n        while(q.size() )\\n        {\\n            int c=q.front().first;\\n            //cout<<c<<\" \";\\n            int jump = q.front().second.first;\\n            int prev = q.front().second.second;\\n            q.pop();\\n            if(c==x)\\n            return jump;\\n            int back =  c - b ; \\n            int forward =  c + a;\\n            if(prev==0 && back>0 && s.find(back)==s.end())\\n            {\\n                q.push({back,{jump+1,1}});// we will change prev to 1 so in next step we can\\'t go backward twice\\n                s.insert(back); // marks as visited\\n            }\\n            if(forward<=10000 && s.find(forward)==s.end())\\n            {\\n                q.push({forward,{jump+1,0}});// we will set prev to 0 so we can take backward step in next step \\n               s.insert(forward); // marks as visited\\n            }\\n\\n        }\\n\\n        return -1;\\n\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& f, int a, int b, int x) \\n    {\\n        int res = 0; \\n        unordered_set<int> s(f.begin(),f.end());\\n        queue<pair<int,pair<int,int>>> q; // {coordinate,{jump,prev_state}}\\n        q.push({0,{0,0}}); // 0 means no backward jump was taken you can go backward\\n        s.insert(0);// we need not to visit 0 again so we put it in set\\n        \\n        \\n        while(q.size() )\\n        {\\n            int c=q.front().first;\\n            //cout<<c<<\" \";\\n            int jump = q.front().second.first;\\n            int prev = q.front().second.second;\\n            q.pop();\\n            if(c==x)\\n            return jump;\\n            int back =  c - b ; \\n            int forward =  c + a;\\n            if(prev==0 && back>0 && s.find(back)==s.end())\\n            {\\n                q.push({back,{jump+1,1}});// we will change prev to 1 so in next step we can\\'t go backward twice\\n                s.insert(back); // marks as visited\\n            }\\n            if(forward<=10000 && s.find(forward)==s.end())\\n            {\\n                q.push({forward,{jump+1,0}});// we will set prev to 0 so we can take backward step in next step \\n               s.insert(forward); // marks as visited\\n            }\\n\\n        }\\n\\n        return -1;\\n\\n   }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3037209,
                "title": "recursive-solution-memoization-beats-97-69-runtime-97-85-memory",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  Here to solve this problem using Recursive \\n  First we start Recurisve function with start = 0\\n  We have to two moves :\\n    1. go from start to start + forwardJumb\\n    2. go from start to start - backwardJumb\\n But here we make boolean called isBack to make sure we do not \\n Make the second move twice , and check the current state not less than zero or greater than greatest move = 7000 and this \\nstate not forbidden\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*3)\\n- Space complexity\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(N*3)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isForbidden[7001];\\n    int memo[7001][2];\\n    int forwardJumb , backwardJumb , target;\\n    int solve(int start , bool isBack){\\n        if(start >7000 ||start <0 ||isForbidden[start])\\n            return 1e9;\\n       if(start ==target)\\n           return 0 ; \\n     int &ret =memo[start][isBack];\\n      if(ret!=-1){\\n          return ret;\\n      }\\n    int op1 = 1e9 , op2 = 1e9;\\n    ret = 1e9;\\n    if(!isBack)\\n    op1 = solve(start - backwardJumb, true) + 1;\\n    op2 = solve(start + forwardJumb , false) + 1;\\n    return ret =min(op1,op2) ; \\n\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i = 0 ;i<forbidden.size();i++){\\n            isForbidden[forbidden[i]] = true;\\n        }\\n        for(int i = 0 ;i<7001;i++){\\n           memo[i][0] = memo[i][1] = -1;\\n        }\\n        forwardJumb = a;\\n        backwardJumb = b;\\n        target = x;\\n        int val = solve(0,false);\\n        return val >=1e9 ?-1:val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isForbidden[7001];\\n    int memo[7001][2];\\n    int forwardJumb , backwardJumb , target;\\n    int solve(int start , bool isBack){\\n        if(start >7000 ||start <0 ||isForbidden[start])\\n            return 1e9;\\n       if(start ==target)\\n           return 0 ; \\n     int &ret =memo[start][isBack];\\n      if(ret!=-1){\\n          return ret;\\n      }\\n    int op1 = 1e9 , op2 = 1e9;\\n    ret = 1e9;\\n    if(!isBack)\\n    op1 = solve(start - backwardJumb, true) + 1;\\n    op2 = solve(start + forwardJumb , false) + 1;\\n    return ret =min(op1,op2) ; \\n\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i = 0 ;i<forbidden.size();i++){\\n            isForbidden[forbidden[i]] = true;\\n        }\\n        for(int i = 0 ;i<7001;i++){\\n           memo[i][0] = memo[i][1] = -1;\\n        }\\n        forwardJumb = a;\\n        backwardJumb = b;\\n        target = x;\\n        int val = solve(0,false);\\n        return val >=1e9 ?-1:val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829346,
                "title": "java-bfs-solution-with-line-by-line-explanation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Node{\\n        int val;\\n        boolean isBackward;\\n        public Node(int val,boolean isBackward){\\n            this.val = val;\\n            this.isBackward = isBackward;\\n        }\\n    } // we create a node to keep track of current processed element and isBackward boolean variable to keep track if current processed element was from a backward traversal \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> visited = new HashSet<>();\\n        for(int seen : forbidden){\\n            visited.add(seen);\\n        }// we are not allowed to process elements in forbidden , so it behaves similar to visited elements \\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(new Node(0,false));\\n        visited.add(0);\\n        int level = 0;\\n        int limit = 6000;\\n        // limit should be the maximum limit a node value can go\\n        // 6000 because \\n        // 2000 is the max value of x acc to constraint\\n        // 2000 is the max value of a acc to constraint\\n        // 2000 is the max value of b acc to constraint\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                Node curr = q.remove();\\n                if(curr.val == x){\\n                    return level;\\n                }// if current value is target , we return \\n                // for backward processing we check the current processed node has been from a backward proceeded node by checking isBackward , and we check if its non negative and if not already visisted we add in queue\\n                if(!curr.isBackward){\\n                    int nextBackPos = curr.val - b;\\n                    if(nextBackPos > 0 && !visited.contains(nextBackPos)){\\n                        q.offer(new Node(nextBackPos,true));\\n                        visited.add(nextBackPos);\\n                    }\\n                } \\n                // for forward processing , we check if not visisted and we check if its withtin limits , bcos if it exceeds the limit it will cause TLE , the program never ends , so define a limit and if conditions satisfies we add in queue \\n                int nextForwardPos = curr.val + a;\\n                if(nextForwardPos < limit && !visited.contains(nextForwardPos)){\\n                    q.offer(new Node(nextForwardPos,false));\\n                    visited.add(nextForwardPos);\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Node{\\n        int val;\\n        boolean isBackward;\\n        public Node(int val,boolean isBackward){\\n            this.val = val;\\n            this.isBackward = isBackward;\\n        }\\n    } // we create a node to keep track of current processed element and isBackward boolean variable to keep track if current processed element was from a backward traversal \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> visited = new HashSet<>();\\n        for(int seen : forbidden){\\n            visited.add(seen);\\n        }// we are not allowed to process elements in forbidden , so it behaves similar to visited elements \\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(new Node(0,false));\\n        visited.add(0);\\n        int level = 0;\\n        int limit = 6000;\\n        // limit should be the maximum limit a node value can go\\n        // 6000 because \\n        // 2000 is the max value of x acc to constraint\\n        // 2000 is the max value of a acc to constraint\\n        // 2000 is the max value of b acc to constraint\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                Node curr = q.remove();\\n                if(curr.val == x){\\n                    return level;\\n                }// if current value is target , we return \\n                // for backward processing we check the current processed node has been from a backward proceeded node by checking isBackward , and we check if its non negative and if not already visisted we add in queue\\n                if(!curr.isBackward){\\n                    int nextBackPos = curr.val - b;\\n                    if(nextBackPos > 0 && !visited.contains(nextBackPos)){\\n                        q.offer(new Node(nextBackPos,true));\\n                        visited.add(nextBackPos);\\n                    }\\n                } \\n                // for forward processing , we check if not visisted and we check if its withtin limits , bcos if it exceeds the limit it will cause TLE , the program never ends , so define a limit and if conditions satisfies we add in queue \\n                int nextForwardPos = curr.val + a;\\n                if(nextForwardPos < limit && !visited.contains(nextForwardPos)){\\n                    q.offer(new Node(nextForwardPos,false));\\n                    visited.add(nextForwardPos);\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819352,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6002, vector<int> (2,0));\\n        if(x == 0) return 0;\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            dp[num][0]++;\\n            dp[num][1]++;\\n        }\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({0,1});\\n        if(dp[x][1]) return -1;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                pair<int, int> tp = q.front();\\n                q.pop();\\n                int val = tp.first;\\n                int ab = tp.second;\\n                if(val == x) return ans;\\n                if(ab)\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                    tmp = val - b;\\n                    if(tmp >= 0 && !dp[tmp][0])\\n                    {\\n                        q.push({tmp, 0});\\n                        dp[tmp][0]=1;\\n                    }\\n                }\\n                else\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<vector<int>> dp(6002, vector<int> (2,0));\\n        if(x == 0) return 0;\\n        for(int &num : forbidden)\\n        {\\n            if(num == x) return -1;\\n            dp[num][0]++;\\n            dp[num][1]++;\\n        }\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({0,1});\\n        if(dp[x][1]) return -1;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                pair<int, int> tp = q.front();\\n                q.pop();\\n                int val = tp.first;\\n                int ab = tp.second;\\n                if(val == x) return ans;\\n                if(ab)\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                    tmp = val - b;\\n                    if(tmp >= 0 && !dp[tmp][0])\\n                    {\\n                        q.push({tmp, 0});\\n                        dp[tmp][0]=1;\\n                    }\\n                }\\n                else\\n                {\\n                    int tmp = val + a;\\n                    if(tmp <= 6001 && !dp[tmp][1])\\n                    {\\n                        q.push({tmp, 1});\\n                        dp[tmp][1]=1;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760953,
                "title": "java-bfs-easy-to-read-code",
                "content": "```\\nclass Step {\\n    int xValue, direction, stepsTaken;\\n    \\n    public Step(int xValue, int direction, int stepsTaken) {\\n        this.xValue = xValue;\\n        this.direction = direction;\\n        this.stepsTaken = stepsTaken;\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n        return (this.xValue + 1) * direction;\\n    }\\n    \\n    @Override\\n    public boolean equals(Object o) {\\n        Step that = (Step) o;\\n        return this.xValue == that.xValue && this.direction == that.direction;\\n    }\\n    \\n}\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Step> seen = new HashSet<>();\\n        for (int f : forbidden) {\\n            seen.add(new Step(f, 1, 0));\\n            seen.add(new Step(f, -1, 0));\\n        }\\n        Queue<Step> q = new LinkedList<>();\\n        q.add(new Step(0, 1, 0));\\n        while (!q.isEmpty()) {\\n            Step currStep = q.remove();\\n            if (currStep.xValue == x) return currStep.stepsTaken;\\n            //try moving forward\\n            // the reason why 6000 is becase: target x is max 2000, and a max 2000, \\n            // that means, x + a with max value to x + a + a \\n            if (currStep.xValue + a <= 6000) {\\n                Step nextStep = new Step(currStep.xValue + a, 1, currStep.stepsTaken + 1);\\n                if (!seen.contains(nextStep)) {\\n                    q.add(nextStep);\\n                    seen.add(nextStep);\\n                }\\n            }\\n            //try moving backward\\n            if (currStep.direction != -1 && currStep.xValue - b > 0) {\\n                Step nextStep = new Step(currStep.xValue - b, -1, currStep.stepsTaken + 1);\\n                if (!seen.contains(nextStep)) {\\n                    q.add(nextStep);\\n                    seen.add(nextStep);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Step {\\n    int xValue, direction, stepsTaken;\\n    \\n    public Step(int xValue, int direction, int stepsTaken) {\\n        this.xValue = xValue;\\n        this.direction = direction;\\n        this.stepsTaken = stepsTaken;\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n        return (this.xValue + 1) * direction;\\n    }\\n    \\n    @Override\\n    public boolean equals(Object o) {\\n        Step that = (Step) o;\\n        return this.xValue == that.xValue && this.direction == that.direction;\\n    }\\n    \\n}\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Step> seen = new HashSet<>();\\n        for (int f : forbidden) {\\n            seen.add(new Step(f, 1, 0));\\n            seen.add(new Step(f, -1, 0));\\n        }\\n        Queue<Step> q = new LinkedList<>();\\n        q.add(new Step(0, 1, 0));\\n        while (!q.isEmpty()) {\\n            Step currStep = q.remove();\\n            if (currStep.xValue == x) return currStep.stepsTaken;\\n            //try moving forward\\n            // the reason why 6000 is becase: target x is max 2000, and a max 2000, \\n            // that means, x + a with max value to x + a + a \\n            if (currStep.xValue + a <= 6000) {\\n                Step nextStep = new Step(currStep.xValue + a, 1, currStep.stepsTaken + 1);\\n                if (!seen.contains(nextStep)) {\\n                    q.add(nextStep);\\n                    seen.add(nextStep);\\n                }\\n            }\\n            //try moving backward\\n            if (currStep.direction != -1 && currStep.xValue - b > 0) {\\n                Step nextStep = new Step(currStep.xValue - b, -1, currStep.stepsTaken + 1);\\n                if (!seen.contains(nextStep)) {\\n                    q.add(nextStep);\\n                    seen.add(nextStep);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575572,
                "title": "c-simple-bfs",
                "content": "* vis[0][i] = 1= i is visited from left side\\n * vis[1][i] = 1= i is visited from the right side\\n * queue = {curr index, bool check}\\n * the bool variable tells us whether we can have a backward jump at this stage or not\\n * store the forbidden coordinates in a set\\n * push 0 into the queue\\n * start traversing, every time we have two options either move forward or backward\\n * check if that is possible or not\\n * if it is then add that one into the queue\\n * if at anytime we arrive at x then return the ans\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    typedef pair<int, bool> pi;\\n    int minimumJumps(vector<int> &forbidden, int a, int b, int x)\\n    {\\n        set<int> st(forbidden.begin(), forbidden.end());\\n        vector<vector<int>> vis(2, vector<int>(10000, 0));\\n        vis[0][0] = 1;\\n        vis[1][0] = 1;\\n        queue<pi> q;\\n        q.push({0, true});\\n        int ans = 0;\\n        while (!q.empty())\\n        {\\n            int n = q.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                int curr = q.front().first;\\n                bool canJumpBackward = q.front().second;\\n                q.pop();\\n                if (curr == x)\\n                    return ans;\\n                int p1 = curr + a;\\n                int p2 = curr - b;\\n                if (p1 < 10000 && vis[0][p1] == 0 && st.find(p1) == st.end())\\n                {\\n                    q.push({p1, true});\\n                    vis[0][p1] = 1;\\n                }\\n                if (p2 >= 0 && vis[1][p2] == 0 && st.find(p2) == st.end() && canJumpBackward == true)\\n                {\\n                    q.push({p2, false});\\n                    vis[1][p2] = 1;\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    typedef pair<int, bool> pi;\\n    int minimumJumps(vector<int> &forbidden, int a, int b, int x)\\n    {\\n        set<int> st(forbidden.begin(), forbidden.end());\\n        vector<vector<int>> vis(2, vector<int>(10000, 0));\\n        vis[0][0] = 1;\\n        vis[1][0] = 1;\\n        queue<pi> q;\\n        q.push({0, true});\\n        int ans = 0;\\n        while (!q.empty())\\n        {\\n            int n = q.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                int curr = q.front().first;\\n                bool canJumpBackward = q.front().second;\\n                q.pop();\\n                if (curr == x)\\n                    return ans;\\n                int p1 = curr + a;\\n                int p2 = curr - b;\\n                if (p1 < 10000 && vis[0][p1] == 0 && st.find(p1) == st.end())\\n                {\\n                    q.push({p1, true});\\n                    vis[0][p1] = 1;\\n                }\\n                if (p2 >= 0 && vis[1][p2] == 0 && st.find(p2) == st.end() && canJumpBackward == true)\\n                {\\n                    q.push({p2, false});\\n                    vis[1][p2] = 1;\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550370,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] nums, int a, int b, int x) {\\n        \\n        \\n        HashSet<Integer> set=new HashSet<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }\\n        \\n        HashMap<Integer,Integer> dp=new HashMap<>();\\n        HashSet<Integer> visited=new HashSet<>();\\n        boolean back=false;\\n        int res= Sol(set,a,b,0,x,back,dp,visited);\\n        \\n        if(res==Integer.MAX_VALUE) return -1;\\n        return res;\\n    }\\n    \\n    public int Sol(HashSet<Integer> set,int a,int b,int pos,int x,boolean back,HashMap<Integer,Integer>               dp,HashSet<Integer> vis){\\n         \\n         int res=Integer.MAX_VALUE;\\n        if(pos==x){\\n            return 0;\\n        }\\n        if(dp.containsKey(pos)) return dp.get(pos);\\n        \\n        if(pos>6000 || set.contains(pos) || pos<0 || vis.contains(pos) ) return res;\\n        \\n        vis.add(pos);\\n        int ans=res;\\n            if(!back)\\n            ans= Sol(set,a,b,pos-b,x,true,dp,vis);\\n           // else\\n            ans= Math.min(ans,Sol(set,a,b,pos+a,x,false,dp,vis));\\n        \\n         if(ans!=Integer.MAX_VALUE){\\n                res=Math.min(res,1+ans);\\n            }\\n        vis.remove(pos);\\n        dp.put(pos,res);\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] nums, int a, int b, int x) {\\n        \\n        \\n        HashSet<Integer> set=new HashSet<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }\\n        \\n        HashMap<Integer,Integer> dp=new HashMap<>();\\n        HashSet<Integer> visited=new HashSet<>();\\n        boolean back=false;\\n        int res= Sol(set,a,b,0,x,back,dp,visited);\\n        \\n        if(res==Integer.MAX_VALUE) return -1;\\n        return res;\\n    }\\n    \\n    public int Sol(HashSet<Integer> set,int a,int b,int pos,int x,boolean back,HashMap<Integer,Integer>               dp,HashSet<Integer> vis){\\n         \\n         int res=Integer.MAX_VALUE;\\n        if(pos==x){\\n            return 0;\\n        }\\n        if(dp.containsKey(pos)) return dp.get(pos);\\n        \\n        if(pos>6000 || set.contains(pos) || pos<0 || vis.contains(pos) ) return res;\\n        \\n        vis.add(pos);\\n        int ans=res;\\n            if(!back)\\n            ans= Sol(set,a,b,pos-b,x,true,dp,vis);\\n           // else\\n            ans= Math.min(ans,Sol(set,a,b,pos+a,x,false,dp,vis));\\n        \\n         if(ans!=Integer.MAX_VALUE){\\n                res=Math.min(res,1+ans);\\n            }\\n        vis.remove(pos);\\n        dp.put(pos,res);\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482322,
                "title": "c-clean-bidirectional-bfs-code-with-comments",
                "content": "```\\nclass Solution {\\n    //1 forward\\n    //0 backwards\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<pair<int,bool>> s; // we need a state of previous position also\\n        //we are using this set as our dp where int is curresponding to \"Position\" and bool value represents weather the last jump was in forward or backwards direction!\\n        \\n        for(auto &it :forbidden)\\n        {\\n             s.insert({it,false});\\n             s.insert({it,true});\\n        }\\n                            //BFS Traversal\\n        queue<vector<int>> q;\\n        q.push({0,1,0});\\n        s.insert({0,0});\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int currPos = q.front()[0];\\n                int prev = q.front()[1];\\n                int jTill = q.front()[2];\\n                if(currPos == x) return jTill;\\n                q.pop();\\n                \\n                //we can jump forward.... irrespective of previous jump\\n                int fPos = currPos + a;\\n                \\n                if(fPos < 6001 && s.find({fPos,true}) == s.end())\\n                {\\n                    q.push({fPos,1,jTill+1});\\n                }\\n                \\n                //once we encounter a perticular state we store it for future\\n                s.insert({fPos,true});\\n                \\n                //we can only jump backwards if we have made the previous jump in forward direction\\n                if(prev == 1)\\n                {\\n                    int bPos = currPos - b;\\n                    if(bPos < 6001 && bPos>=0 && s.find({bPos,false}) == s.end())\\n                    {\\n                        q.push({bPos,0,jTill+1});\\n                    }\\n                    \\n                    //once we encounter a perticular state we store it for future\\n                    s.insert({bPos,false}); \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    //1 forward\\n    //0 backwards\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<pair<int,bool>> s; // we need a state of previous position also\\n        //we are using this set as our dp where int is curresponding to \"Position\" and bool value represents weather the last jump was in forward or backwards direction!\\n        \\n        for(auto &it :forbidden)\\n        {\\n             s.insert({it,false});\\n             s.insert({it,true});\\n        }\\n                            //BFS Traversal\\n        queue<vector<int>> q;\\n        q.push({0,1,0});\\n        s.insert({0,0});\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int currPos = q.front()[0];\\n                int prev = q.front()[1];\\n                int jTill = q.front()[2];\\n                if(currPos == x) return jTill;\\n                q.pop();\\n                \\n                //we can jump forward.... irrespective of previous jump\\n                int fPos = currPos + a;\\n                \\n                if(fPos < 6001 && s.find({fPos,true}) == s.end())\\n                {\\n                    q.push({fPos,1,jTill+1});\\n                }\\n                \\n                //once we encounter a perticular state we store it for future\\n                s.insert({fPos,true});\\n                \\n                //we can only jump backwards if we have made the previous jump in forward direction\\n                if(prev == 1)\\n                {\\n                    int bPos = currPos - b;\\n                    if(bPos < 6001 && bPos>=0 && s.find({bPos,false}) == s.end())\\n                    {\\n                        q.push({bPos,0,jTill+1});\\n                    }\\n                    \\n                    //once we encounter a perticular state we store it for future\\n                    s.insert({bPos,false}); \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382606,
                "title": "simple-bfs-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\tunordered_set<int> forbi(forbidden.begin(), forbidden.end());\\n\\t\\t\\n\\t\\tint far = *max_element(forbidden.begin(),forbidden.end())+a+b;\\n        far = max(far,x+a+b);\\n        vector<vector<int>> visited(2,vector<int>(far+1));\\n\\t\\tqueue<pair<int,bool>> qu; \\n\\t\\t\\n\\t\\tqu.push({0,false});\\n\\t\\tvisited[0][0] = 1;\\n\\t\\tvisited[1][0] = 1;\\n\\t\\tint ans = 0;\\n\\t\\twhile(!qu.empty()) {\\n\\t\\t\\tint len = qu.size();\\n\\t\\t\\twhile(len > 0) {\\n\\t\\t\\t\\tlen--;\\n\\t\\t\\t\\tint cur = qu.front().first;\\n\\t\\t\\t\\tbool flag = qu.front().second;\\n\\t\\t\\t\\tif(cur == x) {\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\tif(forward <= far && visited[0][forward] == 0 && !forbi.count(forward)) {\\n\\t\\t\\t\\t\\tqu.push({forward,false});\\n\\t\\t\\t\\t\\tvisited[0][forward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(backward >=0 && visited[1][backward] == 0 && !forbi.count(backward) && !flag) {\\n\\t\\t\\t\\t\\tqu.push({backward,true});\\n\\t\\t\\t\\t\\tvisited[1][backward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\tunordered_set<int> forbi(forbidden.begin(), forbidden.end());\\n\\t\\t\\n\\t\\tint far = *max_element(forbidden.begin(),forbidden.end())+a+b;\\n        far = max(far,x+a+b);\\n        vector<vector<int>> visited(2,vector<int>(far+1));\\n\\t\\tqueue<pair<int,bool>> qu; \\n\\t\\t\\n\\t\\tqu.push({0,false});\\n\\t\\tvisited[0][0] = 1;\\n\\t\\tvisited[1][0] = 1;\\n\\t\\tint ans = 0;\\n\\t\\twhile(!qu.empty()) {\\n\\t\\t\\tint len = qu.size();\\n\\t\\t\\twhile(len > 0) {\\n\\t\\t\\t\\tlen--;\\n\\t\\t\\t\\tint cur = qu.front().first;\\n\\t\\t\\t\\tbool flag = qu.front().second;\\n\\t\\t\\t\\tif(cur == x) {\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\tif(forward <= far && visited[0][forward] == 0 && !forbi.count(forward)) {\\n\\t\\t\\t\\t\\tqu.push({forward,false});\\n\\t\\t\\t\\t\\tvisited[0][forward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(backward >=0 && visited[1][backward] == 0 && !forbi.count(backward) && !flag) {\\n\\t\\t\\t\\t\\tqu.push({backward,true});\\n\\t\\t\\t\\t\\tvisited[1][backward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304017,
                "title": "ruby-t-o-n-s-o-n-100-100-bfs",
                "content": "```\\n# @param {Integer[]} forbidden\\n# @param {Integer} a\\n# @param {Integer} b\\n# @param {Integer} x\\n# @return {Integer}\\ndef minimum_jumps(forbidden, a, b, x)\\n  return 0 if x == 0\\n  forbidden = Set.new(forbidden)\\n  queue = [[0, 0, false]]\\n  \\n  while (node, jump, last_backward = queue.shift)\\n    next_forward = node + a\\n    next_backward = node - b\\n    if !last_backward && next_backward >= 0 && next_backward < 6000 && !forbidden.include?(next_backward)\\n      return jump + 1 if next_backward == x\\n      queue << [next_backward, jump + 1, true]\\n      forbidden << next_backward\\n    end\\n    if next_forward < 6000 && !forbidden.include?(next_forward)\\n      return jump + 1 if next_forward == x\\n      queue << [next_forward, jump + 1, false]\\n      forbidden << next_forward\\n    end\\n  end\\n\\n  -1\\nend",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} forbidden\\n# @param {Integer} a\\n# @param {Integer} b\\n# @param {Integer} x\\n# @return {Integer}\\ndef minimum_jumps(forbidden, a, b, x)\\n  return 0 if x == 0\\n  forbidden = Set.new(forbidden)\\n  queue = [[0, 0, false]]\\n  \\n  while (node, jump, last_backward = queue.shift)\\n    next_forward = node + a\\n    next_backward = node - b\\n    if !last_backward && next_backward >= 0 && next_backward < 6000 && !forbidden.include?(next_backward)\\n      return jump + 1 if next_backward == x\\n      queue << [next_backward, jump + 1, true]\\n      forbidden << next_backward\\n    end\\n    if next_forward < 6000 && !forbidden.include?(next_forward)\\n      return jump + 1 if next_forward == x\\n      queue << [next_forward, jump + 1, false]\\n      forbidden << next_forward\\n    end\\n  end\\n\\n  -1\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 2285421,
                "title": "bfs-c-solution-97-25-faster",
                "content": "```\\nclass Solution {\\npublic:      \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n       vector<int> vis(6000,0);\\n       for(auto &i : forbidden) vis[i]=1;\\n        if(vis[x]==1) return -1;\\n        queue<pair<int,int>> q;\\n        q.push({0,1});\\n        int ans=0;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n               pair<int,int> cur_vx = q.front();\\n               q.pop();\\n               int par = cur_vx.first;\\n               int dir = cur_vx.second;\\n               if(par==x) return ans;\\n               if(vis[par]==1) continue;\\n               vis[par]=1;\\n                \\n               int l = par - b;\\n               int r = par + a;\\n               if(l>=0 && dir==1) q.push({l,0});\\n               if(par <= 2000 + b ) q.push({r,1});  \\n            } \\n            ans++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:      \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n       vector<int> vis(6000,0);\\n       for(auto &i : forbidden) vis[i]=1;\\n        if(vis[x]==1) return -1;\\n        queue<pair<int,int>> q;\\n        q.push({0,1}",
                "codeTag": "Java"
            },
            {
                "id": 2280533,
                "title": "golang-bfs",
                "content": "````\\n\\ntype Pos struct {\\n\\tpos        int\\n\\tisBackward bool\\n}\\n\\nfunc minimumJumps(forbidden []int, a int, b int, x int) int {\\n\\n\\tjumps := 0\\n\\tsearchBoundary := max(forbidden) + x + a + b\\n\\n\\tvisit := make(map[Pos]struct{})\\n\\n\\tfmap := make(map[int]struct{})\\n\\tfor _, x := range forbidden {\\n\\t\\tfmap[x] = struct{}{}\\n\\t}\\n\\n\\tisSeen := func(pos Pos) bool {\\n\\t\\t_, ok := visit[pos]\\n\\t\\treturn ok\\n\\t}\\n\\tisForbidden := func(pos int) bool {\\n\\t\\t_, ok := fmap[pos]\\n\\t\\treturn ok\\n\\t}\\n\\n\\tqueue := []Pos{{0, false}}\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tcurrlen := len(queue)\\n\\t\\tfor _, currPos := range queue[:currlen] {\\n\\n\\t\\t\\tcurr, isBackward := currPos.pos, currPos.isBackward\\n\\t\\t\\tif curr == x {\\n\\t\\t\\t\\treturn jumps\\n\\t\\t\\t}\\n\\n\\t\\t\\t// move forward\\n\\t\\t\\tnextPos := Pos{curr + a, false}\\n\\t\\t\\tif !isForbidden(nextPos.pos) &&      //not in forbidden list\\n\\t\\t\\t\\tnextPos.pos < searchBoundary &&   //witin boundary\\n\\t\\t\\t\\t!isSeen(nextPos) {    //not visited before \\n\\t\\t\\t\\tqueue = append(queue, nextPos)\\n\\t\\t\\t\\tvisit[Pos{nextPos.pos, false}] = struct{}{}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//move backward\\n\\t\\t\\tnextPos = Pos{curr - b, true}\\n\\t\\t\\tif !isForbidden(nextPos.pos) && //is not in forbidden list\\n\\t\\t\\t\\tnextPos.pos >= 0 && // within boundary\\n\\t\\t\\t\\t!isSeen(nextPos) && //not visited before\\n\\t\\t\\t\\t!isBackward { //two consecutive backward movement is not allowed\\n\\t\\t\\t\\tqueue = append(queue, nextPos)\\n\\t\\t\\t\\tvisit[nextPos] = struct{}{}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tqueue = queue[currlen:]\\n\\t\\tjumps++\\n\\t}\\n\\n\\treturn -1\\n\\n}\\n\\n//get max element from array\\nfunc max(arr []int) int {\\n\\tmax := arr[0]\\n\\tfor _, val := range arr[1:] {\\n\\t\\tif val > max {\\n\\t\\t\\tmax = val\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n\\n\\n`````",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "````\\n\\ntype Pos struct {\\n\\tpos        int\\n\\tisBackward bool\\n}\\n\\nfunc minimumJumps(forbidden []int, a int, b int, x int) int {\\n\\n\\tjumps := 0\\n\\tsearchBoundary := max(forbidden) + x + a + b\\n\\n\\tvisit := make(map[Pos]struct{})\\n\\n\\tfmap := make(map[int]struct{})\\n\\tfor _, x := range forbidden {\\n\\t\\tfmap[x] = struct{}{}\\n\\t}\\n\\n\\tisSeen := func(pos Pos) bool {\\n\\t\\t_, ok := visit[pos]\\n\\t\\treturn ok\\n\\t}\\n\\tisForbidden := func(pos int) bool {\\n\\t\\t_, ok := fmap[pos]\\n\\t\\treturn ok\\n\\t}\\n\\n\\tqueue := []Pos{{0, false}}\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tcurrlen := len(queue)\\n\\t\\tfor _, currPos := range queue[:currlen] {\\n\\n\\t\\t\\tcurr, isBackward := currPos.pos, currPos.isBackward\\n\\t\\t\\tif curr == x {\\n\\t\\t\\t\\treturn jumps\\n\\t\\t\\t}\\n\\n\\t\\t\\t// move forward\\n\\t\\t\\tnextPos := Pos{curr + a, false}\\n\\t\\t\\tif !isForbidden(nextPos.pos) &&      //not in forbidden list\\n\\t\\t\\t\\tnextPos.pos < searchBoundary &&   //witin boundary\\n\\t\\t\\t\\t!isSeen(nextPos) {    //not visited before \\n\\t\\t\\t\\tqueue = append(queue, nextPos)\\n\\t\\t\\t\\tvisit[Pos{nextPos.pos, false}] = struct{}{}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//move backward\\n\\t\\t\\tnextPos = Pos{curr - b, true}\\n\\t\\t\\tif !isForbidden(nextPos.pos) && //is not in forbidden list\\n\\t\\t\\t\\tnextPos.pos >= 0 && // within boundary\\n\\t\\t\\t\\t!isSeen(nextPos) && //not visited before\\n\\t\\t\\t\\t!isBackward { //two consecutive backward movement is not allowed\\n\\t\\t\\t\\tqueue = append(queue, nextPos)\\n\\t\\t\\t\\tvisit[nextPos] = struct{}{}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tqueue = queue[currlen:]\\n\\t\\tjumps++\\n\\t}\\n\\n\\treturn -1\\n\\n}\\n\\n//get max element from array\\nfunc max(arr []int) int {\\n\\tmax := arr[0]\\n\\tfor _, val := range arr[1:] {\\n\\t\\tif val > max {\\n\\t\\t\\tmax = val\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2271420,
                "title": "bfs-c-detailed-solution",
                "content": "```\\n//vis[x][0] --> visited the position x following forward direction \\n//vis[x][1] --> visited the position x following backward direction \\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n         queue<pair<int,int>>q;//q{pos,dir} [0->forward,1->backward]\\n         q.push({0,0}); // adding starting postion with direction as forward (0)\\n         int end=10000; // constraint(can\\'t go further than this)\\n         vector<vector<int>>vis(end+1,vector<int>(2,0));\\n        \\n        // visit the all forbidden zone\\n        for(auto zone:forbidden){\\n            if(zone<=end)vis[zone][0]=true;\\n            if(zone<=end)vis[zone][1]=true;\\n        }\\n        \\n        if(vis[x][0])return -1; // if home is at forbidden zone\\n        \\n        //starting point is both forward and backward visited(if we reach starting point in    \\n        //backward direction then we can\\'t go any further because forward of starting was already marked\\n        //in the begenning) and hence it will be a trap state\\n        vis[0][0]=true,vis[0][1]=true;\\n        \\n        \\n        int jumps=0;\\n        \\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                pair<int,int>p=q.front();\\n                q.pop();\\n                \\n                int pos=p.first;\\n                int dir=p.second;\\n                \\n                if(pos==x)return jumps;//destination reached\\n                \\n                 // if this position is travelled with forward direction then we can move forward as   \\n                 // well as backward direction.\\n                if(dir==0){ \\n                    if(((pos+a)<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                    if(((pos-b)>=0)&&(!vis[pos-b][1])){vis[pos-b][1]=true;q.push({pos-b,1});}\\n                        \\n                }\\n                // if this position is travelled with backward direction then we can move only in \\n                //forward direction\\n                else{ \\n                    if((pos+a<=end)&&(!vis[pos+a][0])){vis[pos+a][0]=true;q.push({pos+a,0});}\\n                }\\n            }\\n           jumps++; \\n            \\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n         queue<pair<int,int>>q;//q{pos,dir}",
                "codeTag": "Java"
            },
            {
                "id": 2191670,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& fb, int a, int b, int x) {\\n        int n=fb.size();\\n        if(x==0) return 0;\\n        map<int,int> mp;\\n        map<pair<int,int>,int> vis;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        for(int i=0;i<n;i++){\\n            mp[fb[i]]=1;\\n        }\\n        vis[{0,0}]=1;\\n        int step=1,fur=6000;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto curr=q.front();\\n                q.pop();\\n                int next_a=curr.first+a;\\n                if(next_a==x) return step;\\n                if(next_a>=0 && next_a<=fur && !vis.count({next_a,1}) && !mp.count(next_a)){\\n                    q.push({next_a,1});\\n                    vis[{next_a,1}]=1;\\n                }\\n                int next_b=curr.first-b;\\n                if(curr.second==1){\\n                    if(next_b==x) return step;\\n                    if(next_b>=0 && next_b<=fur && !vis.count({next_b,0}) && !mp.count(next_b)){\\n                        q.push({next_b,0});\\n                        vis[{next_b,0}]=1;\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumJumps(vector<int>& fb, int a, int b, int x) {\\n        int n=fb.size();\\n        if(x==0) return 0;\\n        map<int,int> mp;\\n        map<pair<int,int>,int> vis;\\n        queue<pair<int,int>> q;\\n        q.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2190113,
                "title": "rust-bfs",
                "content": "```rust\\nuse std::{\\n    borrow::Borrow,\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::hash_map::Entry::Occupied,\\n    collections::hash_map::Entry::Vacant,\\n    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},\\n    rc::Rc,\\n};\\n\\n\\n#[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\\nenum Move {\\n    Forward,\\n    Backward,\\n}\\n\\nimpl Solution {\\n    pub fn minimum_jumps(forbidden: Vec<i32>, right: i32, left: i32, current: i32) -> i32 {\\n        let mut res = 0;\\n        let mut queue = VecDeque::new();\\n        let mut visited: HashSet<(i32, Move)> = HashSet::new();\\n\\n        let min = 0;\\n        let max = std::cmp::max(*forbidden.iter().max().unwrap(), current) + right * 2 + left * 2;\\n\\n        for i in forbidden {\\n            visited.insert((i, Move::Forward));\\n            visited.insert((i, Move::Backward));\\n        }\\n\\n        queue.push_back((current, Move::Forward));\\n        queue.push_back((current, Move::Backward));\\n\\n        while !queue.is_empty() {\\n            let mut next_queue = VecDeque::new();\\n            while let Some(current) = queue.pop_front() {\\n                if visited.contains(&current) {\\n                    continue;\\n                }\\n                visited.insert(current);\\n                let (curr_idx, curr_move) = current;\\n\\n                if curr_idx == 0 {\\n                    return res;\\n                } else if curr_idx <= min || curr_idx >= max {\\n                    continue;\\n                }\\n\\n                match curr_move {\\n                    Move::Forward => {\\n                        next_queue.push_back((curr_idx - right, Move::Forward));\\n                        next_queue.push_back((curr_idx + left, Move::Backward));\\n                    }\\n                    Move::Backward => {\\n                        next_queue.push_back((curr_idx - right, Move::Forward));\\n                    }\\n                }\\n            }\\n\\n            queue = next_queue;\\n            res += 1;\\n\\n            // println!(\"{:?}\", queue);\\n        }\\n\\n        -1\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::{\\n    borrow::Borrow,\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::hash_map::Entry::Occupied,\\n    collections::hash_map::Entry::Vacant,\\n    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},\\n    rc::Rc,\\n};\\n\\n\\n#[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\\nenum Move {\\n    Forward,\\n    Backward,\\n}\\n\\nimpl Solution {\\n    pub fn minimum_jumps(forbidden: Vec<i32>, right: i32, left: i32, current: i32) -> i32 {\\n        let mut res = 0;\\n        let mut queue = VecDeque::new();\\n        let mut visited: HashSet<(i32, Move)> = HashSet::new();\\n\\n        let min = 0;\\n        let max = std::cmp::max(*forbidden.iter().max().unwrap(), current) + right * 2 + left * 2;\\n\\n        for i in forbidden {\\n            visited.insert((i, Move::Forward));\\n            visited.insert((i, Move::Backward));\\n        }\\n\\n        queue.push_back((current, Move::Forward));\\n        queue.push_back((current, Move::Backward));\\n\\n        while !queue.is_empty() {\\n            let mut next_queue = VecDeque::new();\\n            while let Some(current) = queue.pop_front() {\\n                if visited.contains(&current) {\\n                    continue;\\n                }\\n                visited.insert(current);\\n                let (curr_idx, curr_move) = current;\\n\\n                if curr_idx == 0 {\\n                    return res;\\n                } else if curr_idx <= min || curr_idx >= max {\\n                    continue;\\n                }\\n\\n                match curr_move {\\n                    Move::Forward => {\\n                        next_queue.push_back((curr_idx - right, Move::Forward));\\n                        next_queue.push_back((curr_idx + left, Move::Backward));\\n                    }\\n                    Move::Backward => {\\n                        next_queue.push_back((curr_idx - right, Move::Forward));\\n                    }\\n                }\\n            }\\n\\n            queue = next_queue;\\n            res += 1;\\n\\n            // println!(\"{:?}\", queue);\\n        }\\n\\n        -1\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2165190,
                "title": "c-dp-memoization-fast-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<int> fob;\\n    int dp[7001][2];\\n    int solver(int pos, int &home, int &a, int &b, bool left)\\n    {\\n        if(pos == home)return 0;\\n        if(pos < 0 || pos > 7000 || fob.find(pos) != fob.end())return 1e9;\\n        if(dp[pos][left] != -1) return dp[pos][left];\\n        \\n        dp[pos][left] = 1 + solver(pos + a, home, a, b, false);\\n        if(!left)\\n        {\\n            dp[pos][left] = min(dp[pos][left], 1 + solver(pos - b, home, a, b, true));\\n        }\\n        return dp[pos][left];\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(auto i: forbidden)fob.insert(i);\\n        memset(dp, -1, sizeof(dp));\\n        int ans = solver(0, x, a, b, false);\\n        return (ans >= 1e9)? -1: ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_set<int> fob;\\n    int dp[7001][2];\\n    int solver(int pos, int &home, int &a, int &b, bool left)\\n    {\\n        if(pos == home)return 0;\\n        if(pos < 0 || pos > 7000 || fob.find(pos) != fob.end())return 1e9;\\n        if(dp[pos][left] != -1) return dp[pos][left];\\n        \\n        dp[pos][left] = 1 + solver(pos + a, home, a, b, false);\\n        if(!left)\\n        {\\n            dp[pos][left] = min(dp[pos][left], 1 + solver(pos - b, home, a, b, true));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2164391,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> visited = new HashSet<>();\\n        int limit = 2000 + 2 * b + 1;\\n        for (int e : forbidden) {\\n            visited.add(e);\\n        }\\n        int steps = 0;\\n        Queue<Pair<Integer, Boolean>> q = new LinkedList<>();\\n        q.offer(new Pair<Integer, Boolean>(0, true));\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair<Integer, Boolean> pair = q.poll();\\n                int num = pair.getKey();\\n                boolean canJumpBackward = pair.getValue();\\n                if (num == x) {\\n                    return steps;\\n                }\\n                if (canJumpBackward) {\\n                   int backwardStep = num - b;\\n                   if (backwardStep > 0 && !visited.contains(backwardStep)) {\\n                       q.offer(new Pair<Integer, Boolean>(backwardStep, false));\\n                       visited.add(backwardStep);\\n                   }\\n                }\\n                int forwardStep = num + a;\\n                if (forwardStep < limit && !visited.contains(forwardStep)) {\\n                    q.offer(new Pair<Integer, Boolean>(forwardStep, true));\\n                    visited.add(forwardStep);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> visited = new HashSet<>();\\n        int limit = 2000 + 2 * b + 1;\\n        for (int e : forbidden) {\\n            visited.add(e);\\n        }\\n        int steps = 0;\\n        Queue<Pair<Integer, Boolean>> q = new LinkedList<>();\\n        q.offer(new Pair<Integer, Boolean>(0, true));\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair<Integer, Boolean> pair = q.poll();\\n                int num = pair.getKey();\\n                boolean canJumpBackward = pair.getValue();\\n                if (num == x) {\\n                    return steps;\\n                }\\n                if (canJumpBackward) {\\n                   int backwardStep = num - b;\\n                   if (backwardStep > 0 && !visited.contains(backwardStep)) {\\n                       q.offer(new Pair<Integer, Boolean>(backwardStep, false));\\n                       visited.add(backwardStep);\\n                   }\\n                }\\n                int forwardStep = num + a;\\n                if (forwardStep < limit && !visited.contains(forwardStep)) {\\n                    q.offer(new Pair<Integer, Boolean>(forwardStep, true));\\n                    visited.add(forwardStep);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143843,
                "title": "c-bfs-easy-to-understand",
                "content": "Simple Level Order Traversal.\\n\\nHow to identify If it\\'s a bfs based problem?\\n\\nThe thumb rule  is that if it asks to find the smallest or shortest type of problem in graph then there are 95% chances  that the problem will be solved with level order traversal using BFS technique. You can solve it recurssively but I think it is better to use BFS as in DFS it can go way deeper and we will get to the ans much later as compared to BFS.\\n\\nYou can optimize the Soln of DFS based approach using Memoization. Check out other threads as well for such soln.\\n\\n6000 was just an assumption of a safe long distance space. You can choice any number greater than 6000, it will work as well.\\n\\nPlease comment down all your doubts if there are any!\\n```\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\tset<int> st(forbidden.begin(), forbidden.end());\\n\\t\\tvector<int> visFwd(6000, 0);\\n\\t\\tvector<int>visBack(6000, 0);\\n\\t\\tqueue<pair<int,bool>> q; \\n\\t\\tq.push({0,false});\\n\\t\\tvisFwd[0] = 1;\\n\\t\\tvisBack[0] = 1;\\n\\t\\tint ans = 0;\\n\\t\\twhile(!q.empty()) {\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\twhile(size--) {\\n\\t\\t\\t\\tint cur = q.front().first;\\n\\t\\t\\t\\tbool flag = q.front().second;\\n\\t\\t\\t\\tq.pop();\\n                if(cur == x) {\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\tif(forward < 6000 && visFwd[forward] == 0 && !st.count(forward)) {\\n\\t\\t\\t\\t\\tq.push({forward,false});\\n\\t\\t\\t\\t\\tvisFwd[forward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(backward >=0 && visBack[backward] == 0 && !st.count(backward) && !flag) {\\n\\t\\t\\t\\t\\tq.push({backward,true});\\n\\t\\t\\t\\t\\tvisBack[backward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\tset<int> st(forbidden.begin(), forbidden.end());\\n\\t\\tvector<int> visFwd(6000, 0);\\n\\t\\tvector<int>visBack(6000, 0);\\n\\t\\tqueue<pair<int,bool>> q; \\n\\t\\tq.push({0,false});\\n\\t\\tvisFwd[0] = 1;\\n\\t\\tvisBack[0] = 1;\\n\\t\\tint ans = 0;\\n\\t\\twhile(!q.empty()) {\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\twhile(size--) {\\n\\t\\t\\t\\tint cur = q.front().first;\\n\\t\\t\\t\\tbool flag = q.front().second;\\n\\t\\t\\t\\tq.pop();\\n                if(cur == x) {\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint forward = cur + a;\\n\\t\\t\\t\\tint backward = cur - b;\\n\\t\\t\\t\\tif(forward < 6000 && visFwd[forward] == 0 && !st.count(forward)) {\\n\\t\\t\\t\\t\\tq.push({forward,false});\\n\\t\\t\\t\\t\\tvisFwd[forward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(backward >=0 && visBack[backward] == 0 && !st.count(backward) && !flag) {\\n\\t\\t\\t\\t\\tq.push({backward,true});\\n\\t\\t\\t\\t\\tvisBack[backward] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137388,
                "title": "c-code-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    set<int> s;\\n    int dp[6005][3];\\n    \\n    int func(int a,int b,int x,int pos,int prev){\\n        if (pos==x){\\n            return 0;\\n        }\\n       \\n        if (s.count(pos) || pos<0 || pos>6000){\\n            return 1e9;\\n        }\\n        \\n        if (dp[pos][prev]!=-1){\\n            return dp[pos][prev];\\n        }\\n        \\n        \\n      \\n        dp[pos][prev]=1+func(a,b,x,pos+a,0);\\n        if (prev==0){\\n            dp[pos][prev]=min(dp[pos][prev],1+func(a,b,x,pos-b,1));\\n        }\\n        \\n     return dp[pos][prev];\\n    }\\n    \\n    int minimumJumps(vector<int>& v, int a, int b, int x) {\\n        for (auto it: v){\\n            s.insert(it);\\n        }\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        int ans=func(a,b,x,0,0);\\n        if (ans>=1e9){\\n            return -1;\\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> s;\\n    int dp[6005][3];\\n    \\n    int func(int a,int b,int x,int pos,int prev){\\n        if (pos==x){\\n            return 0;\\n        }\\n       \\n        if (s.count(pos) || pos<0 || pos>6000){\\n            return 1e9;\\n        }\\n        \\n        if (dp[pos][prev]!=-1){\\n            return dp[pos][prev];\\n        }\\n        \\n        \\n      \\n        dp[pos][prev]=1+func(a,b,x,pos+a,0);\\n        if (prev==0){\\n            dp[pos][prev]=min(dp[pos][prev],1+func(a,b,x,pos-b,1));\\n        }\\n        \\n     return dp[pos][prev];\\n    }\\n    \\n    int minimumJumps(vector<int>& v, int a, int b, int x) {\\n        for (auto it: v){\\n            s.insert(it);\\n        }\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        int ans=func(a,b,x,0,0);\\n        if (ans>=1e9){\\n            return -1;\\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130948,
                "title": "python-bfs-solution-beats-93-98",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, fb: List[int], a: int, b: int, x: int) -> int:\\n        fb = set(fb)\\n        q = deque([[0,0,True]])\\n        while(q):\\n            n,l,isf = q.popleft()\\n            if(n<0 or n in fb or n>2000+2*b):\\n                continue\\n            fb.add(n)\\n            if(n==x):\\n                return l\\n            if isf and n-b>0:\\n                q.append([n-b,l+1,False])                \\n            q.append([n+a,l+1,True])\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, fb: List[int], a: int, b: int, x: int) -> int:\\n        fb = set(fb)\\n        q = deque([[0,0,True]])\\n        while(q):\\n            n,l,isf = q.popleft()\\n            if(n<0 or n in fb or n>2000+2*b):\\n                continue\\n            fb.add(n)\\n            if(n==x):\\n                return l\\n            if isf and n-b>0:\\n                q.append([n-b,l+1,False])                \\n            q.append([n+a,l+1,True])\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086839,
                "title": "what-s-wrong-in-this-bfs-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n        unordered_set<int>forbid;\\n        unordered_set<int>visited;\\n        for(int index = 0; index < forbidden.size(); index++)   forbid.insert(forbidden[index]);\\n        \\n        queue<pair<int, bool>>q;\\n        int level = 0;\\n        q.push({0, false});\\n        visited.insert(0);\\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int index = q.front().first;\\n                bool lastBackward = q.front().second;\\n                q.pop();\\n                \\n                if(index == x)  return level;\\n                \\n                int forward = index + a;\\n                if(forward <= 1e6  && !forbid.count(forward) && !visited.count(forward))\\n                {\\n                    q.push({forward, false});\\n                    visited.insert(forward);\\n                }\\n                \\n                int backward = index-b;\\n                if(!lastBackward && backward >=0 && !forbid.count(backward) && !visited.count(backward))\\n                {\\n                    q.push({backward, true});\\n                    visited.insert(backward);\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n        unordered_set<int>forbid;\\n        unordered_set<int>visited;\\n        for(int index = 0; index < forbidden.size(); index++)   forbid.insert(forbidden[index]);\\n        \\n        queue<pair<int, bool>>q;\\n        int level = 0;\\n        q.push({0, false});\\n        visited.insert(0);\\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int index = q.front().first;\\n                bool lastBackward = q.front().second;\\n                q.pop();\\n                \\n                if(index == x)  return level;\\n                \\n                int forward = index + a;\\n                if(forward <= 1e6  && !forbid.count(forward) && !visited.count(forward))\\n                {\\n                    q.push({forward, false});\\n                    visited.insert(forward);\\n                }\\n                \\n                int backward = index-b;\\n                if(!lastBackward && backward >=0 && !forbid.count(backward) && !visited.count(backward))\\n                {\\n                    q.push({backward, true});\\n                    visited.insert(backward);\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043357,
                "title": "python-solution-problem-is-missing-some-test-cases-or-am-i-wrong",
                "content": "I think the solution must hash not only the positions, but how much backwards leaps we\\'ve made so far. However, solution with visited only on positions is accepted as well.\\n\\nThe reason why I think that is because there could be a test case where we explore in this manner\\n(a = 2, b = 2\\n            node/backward leaps\\n1 -> 2,    (2,0)\\n2 >  4      (4, 0)\\n4 < 2      (2, 1) - not added to the queue because we already visited 2.\\n\\nWhat am I missing?\\n\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \"\"\"\\n        1. Approach one: BFS: linear -> we visit every \"edge\" and \"vertex\" only once \\n        where edge is numbers from [0, x]\\n        and the vertex is all possibilities in the graph (i + a, i - b) for i in range(len(X)))\\n        \\n        2. Approach is Dijkstra\\'s -> we are going to prioritize more promizing nodes first \\n        \\n        3. Approach is A*, we are going to add is heuristic to speed up the computation process\\n        \\n        BFS LLD:\\n        \\n        notes:\\n        since frog can\\'t jump twice in the row backwards, we need to mark each visited we the number of backward jumps so that we can explore the cell with different backward leaps at each point\\n        \\n        2. we will merge forbidden to visited for simplicity \\n        \\n        3. we will return immideatly if 0 is frobbiden or\\n        \\n        we stop when the q has no more nodes, and return -1\\n        we stop when we pop node with value x.\\n        \"\"\"\\n        \\n        q = deque()\\n        visited = set()\\n        for f in forbidden:\\n            for i in range(2):\\n                visited.add((f,i))\\n            \\n        q.append((0,0, 0))\\n        \\n        furthest = max([x]+forbidden) +a+b      \\n        while q:\\n            node, bck, distance = q.popleft()\\n            \\n            if (node,bck) in visited:\\n                continue \\n                \\n            if node == x:\\n                return distance\\n            \\n            visited.add((node,bck))\\n            \\n            left_jump = node - b \\n            right_jump = node + a\\n            \\n            if left_jump > 0 and bck == 0:\\n                if (left_jump, 1) not in visited:\\n                    q.append((left_jump, 1, distance + 1))\\n                \\n            if right_jump <= furthest:\\n                if (right_jump, 0) not in visited:\\n                    q.append((right_jump, 0, distance + 1))\\n                \\n        return -1\\n            \\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "I think the solution must hash not only the positions, but how much backwards leaps we\\'ve made so far. However, solution with visited only on positions is accepted as well.\\n\\nThe reason why I think that is because there could be a test case where we explore in this manner\\n(a = 2, b = 2\\n            node/backward leaps\\n1 -> 2,    (2,0)\\n2 >  4      (4, 0)\\n4 < 2      (2, 1) - not added to the queue because we already visited 2.\\n\\nWhat am I missing?\\n\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        \"\"\"\\n        1. Approach one: BFS: linear -> we visit every \"edge\" and \"vertex\" only once \\n        where edge is numbers from [0, x]\\n        and the vertex is all possibilities in the graph (i + a, i - b) for i in range(len(X)))\\n        \\n        2. Approach is Dijkstra\\'s -> we are going to prioritize more promizing nodes first \\n        \\n        3. Approach is A*, we are going to add is heuristic to speed up the computation process\\n        \\n        BFS LLD:\\n        \\n        notes:\\n        since frog can\\'t jump twice in the row backwards, we need to mark each visited we the number of backward jumps so that we can explore the cell with different backward leaps at each point\\n        \\n        2. we will merge forbidden to visited for simplicity \\n        \\n        3. we will return immideatly if 0 is frobbiden or\\n        \\n        we stop when the q has no more nodes, and return -1\\n        we stop when we pop node with value x.\\n        \"\"\"\\n        \\n        q = deque()\\n        visited = set()\\n        for f in forbidden:\\n            for i in range(2):\\n                visited.add((f,i))\\n            \\n        q.append((0,0, 0))\\n        \\n        furthest = max([x]+forbidden) +a+b      \\n        while q:\\n            node, bck, distance = q.popleft()\\n            \\n            if (node,bck) in visited:\\n                continue \\n                \\n            if node == x:\\n                return distance\\n            \\n            visited.add((node,bck))\\n            \\n            left_jump = node - b \\n            right_jump = node + a\\n            \\n            if left_jump > 0 and bck == 0:\\n                if (left_jump, 1) not in visited:\\n                    q.append((left_jump, 1, distance + 1))\\n                \\n            if right_jump <= furthest:\\n                if (right_jump, 0) not in visited:\\n                    q.append((right_jump, 0, distance + 1))\\n                \\n        return -1\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1937436,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        visited=set(forbidden)\\n        queue=[(0,0,True)]\\n        max_val=max([x]+forbidden) +a+b\\n        while queue:\\n            pos,steps,back=queue.pop(0)\\n            if pos==x:\\n                return steps\\n            \\n            if pos-b not in visited and back and pos-b>0:\\n                queue.append((pos-b,steps+1,not back))\\n                visited.add(pos-b)\\n            if pos+a not in visited  and pos+a<=max_val:\\n                queue.append((pos+a,steps+1,True))\\n                visited.add(pos+a)\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        visited=set(forbidden)\\n        queue=[(0,0,True)]\\n        max_val=max([x]+forbidden) +a+b\\n        while queue:\\n            pos,steps,back=queue.pop(0)\\n            if pos==x:\\n                return steps\\n            \\n            if pos-b not in visited and back and pos-b>0:\\n                queue.append((pos-b,steps+1,not back))\\n                visited.add(pos-b)\\n            if pos+a not in visited  and pos+a<=max_val:\\n                queue.append((pos+a,steps+1,True))\\n                visited.add(pos+a)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928962,
                "title": "java-bfs-solution",
                "content": "\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> set = new HashSet();\\n        Set<String> visit = new HashSet();\\n        for(int n : forbidden)\\n            set.add(n);\\n        \\n        Queue<int[]> q = new LinkedList();\\n        int moves = 0;\\n        int max = 2000 + 2*b;\\n        \\n        q.offer(new int[]{0, 0});\\n       \\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int[] current = q.poll();\\n                int pos = current[0], direction = current[1];\\n                \\n                if(pos == x) return moves;\\n                \\n                if(pos + a < max && !set.contains(pos + a) && !visit.contains(pos+a+\",\"+0))\\n                {\\n                    visit.add(pos+a+\",\"+0);\\n                    q.offer(new int[]{pos + a, 0});\\n                } \\n                \\n                if(direction == 0)\\n                {   \\n                    if(pos - b >= 0 && !set.contains(pos - b) && !visit.contains(pos-b+\",\"+1))\\n                    {\\n                        visit.add(pos-b+\",\"+1);\\n                        q.offer(new int[]{pos - b, 1});\\n                    }\\n                }\\n            }\\n            moves++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Set<Integer> set = new HashSet();\\n        Set<String> visit = new HashSet();\\n        for(int n : forbidden)\\n            set.add(n);\\n        \\n        Queue<int[]> q = new LinkedList();\\n        int moves = 0;\\n        int max = 2000 + 2*b;\\n        \\n        q.offer(new int[]{0, 0});\\n       \\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int[] current = q.poll();\\n                int pos = current[0], direction = current[1];\\n                \\n                if(pos == x) return moves;\\n                \\n                if(pos + a < max && !set.contains(pos + a) && !visit.contains(pos+a+\",\"+0))\\n                {\\n                    visit.add(pos+a+\",\"+0);\\n                    q.offer(new int[]{pos + a, 0});\\n                } \\n                \\n                if(direction == 0)\\n                {   \\n                    if(pos - b >= 0 && !set.contains(pos - b) && !visit.contains(pos-b+\",\"+1))\\n                    {\\n                        visit.add(pos-b+\",\"+1);\\n                        q.offer(new int[]{pos - b, 1});\\n                    }\\n                }\\n            }\\n            moves++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922705,
                "title": "cpp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        if(x == 0) return 0;\\n        \\n        int dp[6001] = {};\\n        \\n        for(int i: forbidden) dp[i] = -1;\\n        \\n        deque<pair<int, bool>> dq;\\n        dq.push_back({0, false});\\n        \\n        while(dq.size() > 0){\\n            \\n            auto [val, canGoBack] = dq.front();\\n            if(val == x) return dp[val];\\n            dq.pop_front();\\n            \\n            if(canGoBack && val - b > 0 && dp[val-b] == 0){\\n                dp[val-b] = 1 + dp[val];\\n                dq.push_back({val-b, false});\\n            }\\n            \\n            if(val + a <= 6000 && dp[val + a] == 0){\\n                dp[val + a] = 1 + dp[val];\\n                dq.push_back({val+a, true});\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        if(x == 0) return 0;\\n        \\n        int dp[6001] = {};\\n        \\n        for(int i: forbidden) dp[i] = -1;\\n        \\n        deque<pair<int, bool>> dq;\\n        dq.push_back({0, false});\\n        \\n        while(dq.size() > 0){\\n            \\n            auto [val, canGoBack] = dq.front();\\n            if(val == x) return dp[val];\\n            dq.pop_front();\\n            \\n            if(canGoBack && val - b > 0 && dp[val-b] == 0){\\n                dp[val-b] = 1 + dp[val];\\n                dq.push_back({val-b, false});\\n            }\\n            \\n            if(val + a <= 6000 && dp[val + a] == 0){\\n                dp[val + a] = 1 + dp[val];\\n                dq.push_back({val+a, true});\\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902702,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        int pos;\\n        int backcount;\\n        Pair(int pos,int backcount ){\\n            this.pos=pos;\\n            this.backcount=backcount;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        HashMap<Integer,Boolean> visited=new HashMap<>();\\n        Queue<Pair> queue=new LinkedList<>();\\n        for(int i:forbidden){\\n            visited.put(i,true);\\n        }\\n        queue.add(new Pair(0,0));\\n        \\n        int level=0;\\n        while(queue.size()>0){\\n            int size=queue.size();\\n            while(size-->0){\\n                Pair rem=queue.remove();\\n                if(rem.pos==x){\\n                    return level;\\n                }\\n                if(visited.containsKey(rem.pos)){\\n                    continue;\\n                }\\n                visited.put(rem.pos,true);\\n                if(rem.backcount==0&&rem.pos-b>=0){\\n                    queue.add(new Pair(rem.pos-b,1));\\n                }\\n                if(rem.pos<2000+b){\\n                    queue.add(new Pair(rem.pos+a,0));\\n                }\\n            }level++;\\n        }\\n    return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int pos;\\n        int backcount;\\n        Pair(int pos,int backcount ){\\n            this.pos=pos;\\n            this.backcount=backcount;\\n        }\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        HashMap<Integer,Boolean> visited=new HashMap<>();\\n        Queue<Pair> queue=new LinkedList<>();\\n        for(int i:forbidden){\\n            visited.put(i,true);\\n        }\\n        queue.add(new Pair(0,0));\\n        \\n        int level=0;\\n        while(queue.size()>0){\\n            int size=queue.size();\\n            while(size-->0){\\n                Pair rem=queue.remove();\\n                if(rem.pos==x){\\n                    return level;\\n                }\\n                if(visited.containsKey(rem.pos)){\\n                    continue;\\n                }\\n                visited.put(rem.pos,true);\\n                if(rem.backcount==0&&rem.pos-b>=0){\\n                    queue.add(new Pair(rem.pos-b,1));\\n                }\\n                if(rem.pos<2000+b){\\n                    queue.add(new Pair(rem.pos+a,0));\\n                }\\n            }level++;\\n        }\\n    return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893180,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        //marks forbidden position as visited\\n        set<int> visited(forbidden.begin(),forbidden.end());\\n\\n        queue<int> q;\\n        q.push(0);\\n        \\n        int step = 0;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n          \\n            //for all current level\\n            for(int i = 0; i < sz; i++){\\n                \\n                // to eliminate twice backword in a row we are pusing the value with negetive\\n                //to indicate that past move was backward\\n                \\n                int cur = q.front();\\n                q.pop();\\n                bool wasBack = cur < 0;\\n                cur = abs(cur);\\n                \\n                //if we reach distination\\n                if(cur == x) return step; \\n                \\n                int next = cur + a;\\n                \\n                //next < 6000 to handel when we are constantly going forward\\n                //outside the range of our interest\\n                // as max of x is 2000\\n                // and a ,b max is 2000\\n                if(next < 6000 && visited.find(next) == visited.end()){\\n                    visited.insert(next);\\n                    q.push(next);\\n                }\\n                \\n                next = cur - b;\\n                //past move wasnot back \\n                // we dont need to mark it visted\\n                //we we might come to it and with forward move and use one more backward\\n                // to reach destination\\n                if(!wasBack && next > 0 && visited.find(next) == visited.end()){\\n                    q.push(next * -1);\\n                }\\n            }\\n             step++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        //marks forbidden position as visited\\n        set<int> visited(forbidden.begin(),forbidden.end());\\n\\n        queue<int> q;\\n        q.push(0);\\n        \\n        int step = 0;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n          \\n            //for all current level\\n            for(int i = 0; i < sz; i++){\\n                \\n                // to eliminate twice backword in a row we are pusing the value with negetive\\n                //to indicate that past move was backward\\n                \\n                int cur = q.front();\\n                q.pop();\\n                bool wasBack = cur < 0;\\n                cur = abs(cur);\\n                \\n                //if we reach distination\\n                if(cur == x) return step; \\n                \\n                int next = cur + a;\\n                \\n                //next < 6000 to handel when we are constantly going forward\\n                //outside the range of our interest\\n                // as max of x is 2000\\n                // and a ,b max is 2000\\n                if(next < 6000 && visited.find(next) == visited.end()){\\n                    visited.insert(next);\\n                    q.push(next);\\n                }\\n                \\n                next = cur - b;\\n                //past move wasnot back \\n                // we dont need to mark it visted\\n                //we we might come to it and with forward move and use one more backward\\n                // to reach destination\\n                if(!wasBack && next > 0 && visited.find(next) == visited.end()){\\n                    q.push(next * -1);\\n                }\\n            }\\n             step++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878140,
                "title": "c-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[6005][2]={{0}},inf=1e9;\\n    set<int>st;\\n    int jump(int pos,int a,int b,int x,int cnt){\\n        if(pos==x)return 0;\\n        if(st.count(pos) || pos<0 || pos>6000) return inf;\\n        if(dp[pos][cnt]) return dp[pos][cnt];\\n        dp[pos][cnt]=1+jump(pos+a,a,b,x,0);\\n        return dp[pos][cnt]=min(dp[pos][cnt],cnt==0?1+jump(pos-b,a,b,x,1):dp[pos][cnt]);\\n    }\\n    int minimumJumps(vector<int>& f, int a, int b, int x) {\\n        st=set<int>(f.begin(),f.end());\\n        int ans= jump(0,a,b,x,0);\\n        return (ans>=inf)?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[6005][2]={{0}},inf=1e9;\\n    set<int>st;\\n    int jump(int pos,int a,int b,int x,int cnt){\\n        if(pos==x)return 0;\\n        if(st.count(pos) || pos<0 || pos>6000) return inf;\\n        if(dp[pos][cnt]) return dp[pos][cnt];\\n        dp[pos][cnt]=1+jump(pos+a,a,b,x,0);\\n        return dp[pos][cnt]=min(dp[pos][cnt],cnt==0?1+jump(pos-b,a,b,x,1):dp[pos][cnt]);\\n    }\\n    int minimumJumps(vector<int>& f, int a, int b, int x) {\\n        st=set<int>(f.begin(),f.end());\\n        int ans= jump(0,a,b,x,0);\\n        return (ans>=inf)?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846380,
                "title": "java-intuitive-solution-bfs-easy-with-comments-for-understanding",
                "content": "```\\nclass Solution {\\n    \\n    public class pair{\\n        int edge;\\n        boolean state;\\n        pair(int edge, boolean state){\\n            this.edge = edge;\\n            this.state = state;\\n        }\\n    }\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int ele : forbidden){\\n            // so that search could become easy for forbidden elements.\\n            list.add(ele);  \\n        }\\n        HashSet<String> vis = new HashSet<>(); \\n        // taking set as visited so that we don\\'t need to think about size of the visited array \\n\\t\\t// and will add node into it with the jump it came from\\n\\t\\t// e.g. if we reached at 2 from backward then we add b2 in visited set.\\n        Queue<pair> que = new LinkedList<>();\\n        que.add(new pair(0, false));\\n        // state true means from backward, false means from forward\\n        vis.add(\"f\" + 0);  // added from forward\\n        vis.add(\"b\" + 0);  // added from backward\\n        int level = 0;\\n        while(que.size() > 0){\\n            int size = que.size();\\n            while(size-- > 0){\\n                pair rem = que.remove();\\n                if(rem.edge == x){\\n                    return level;\\n                }\\n                \\n                int forward = rem.edge + a;\\n                int backward = rem.edge - b;\\n                boolean isback = rem.state;\\n                \\n                if(forward < 6000 && !list.contains(forward) && !vis.contains(\"f\" + forward)){\\n                    que.add(new pair(forward, false));\\n                    vis.add(\"f\" + forward);\\n                }\\n                if(backward >= 0 && !list.contains(backward) && !isback && !vis.contains(\"b\" + backward)){\\n                    que.add(new pair(backward, true));\\n                    vis.add(\"b\" + backward);\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public class pair{\\n        int edge;\\n        boolean state;\\n        pair(int edge, boolean state){\\n            this.edge = edge;\\n            this.state = state;\\n        }\\n    }\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int ele : forbidden){\\n            // so that search could become easy for forbidden elements.\\n            list.add(ele);  \\n        }\\n        HashSet<String> vis = new HashSet<>(); \\n        // taking set as visited so that we don\\'t need to think about size of the visited array \\n\\t\\t// and will add node into it with the jump it came from\\n\\t\\t// e.g. if we reached at 2 from backward then we add b2 in visited set.\\n        Queue<pair> que = new LinkedList<>();\\n        que.add(new pair(0, false));\\n        // state true means from backward, false means from forward\\n        vis.add(\"f\" + 0);  // added from forward\\n        vis.add(\"b\" + 0);  // added from backward\\n        int level = 0;\\n        while(que.size() > 0){\\n            int size = que.size();\\n            while(size-- > 0){\\n                pair rem = que.remove();\\n                if(rem.edge == x){\\n                    return level;\\n                }\\n                \\n                int forward = rem.edge + a;\\n                int backward = rem.edge - b;\\n                boolean isback = rem.state;\\n                \\n                if(forward < 6000 && !list.contains(forward) && !vis.contains(\"f\" + forward)){\\n                    que.add(new pair(forward, false));\\n                    vis.add(\"f\" + forward);\\n                }\\n                if(backward >= 0 && !list.contains(backward) && !isback && !vis.contains(\"b\" + backward)){\\n                    que.add(new pair(backward, true));\\n                    vis.add(\"b\" + backward);\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836781,
                "title": "bfs-using-set-with-detail-explanation-with-edge-case",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int minimumJumps(vector<int>& nums, int a, int b, int x) {\\n        \\n         queue<pair<int,pair<int,int>> > q;\\n        \\n        // put all element from forbidden array into set for check whether element present or not\\n        set<int> st;\\n        int n=nums.size(); \\n        for(int i=0;i<n;i++)\\n        {\\n            st.insert(nums[i]);\\n           \\n        }\\n        int ans=0;\\n         q.push({0,{0,0}});\\n      \\n        while(!q.empty())\\n        { \\n            \\n            int cnt=q.size();\\n             for(int i=0;i<cnt;i++)\\n             {\\n                      int curr=q.front().first;// curr position\\n                      int score=q.front().second.first; // step\\n                      int back=q.front().second.second;   // if back is 0 then we can traverse backside (jump backward twice in a row)\\n                      q.pop();\\n                      int forward=curr+a;\\n                      int backward=curr-b;\\n                 \\n                 \\n                      if(curr==x) // if curr position == x then return score\\n                           return score;\\n                 \\n                 \\n                      if(st.count(curr)) continue; // curr postion present in set then continue\\n                 \\n                       st.insert(curr);// otherwise put that element in set avoid repeatation on that position\\n                 \\n                    // backward operation\\n                       if(back==0 and backward>=0)\\n                         {\\n                            q.push({backward,{score+1,1}});\\n                         } \\n                    // forward operation\\n                       \\n                       if(backward<=2000)\\n                        {\\n                          q.push({forward,{score+1,0}});\\n                        }\\n              }\\n       }\\n         return -1;\\n    }\\n};\\n\\n\\n\\n\\n \\n\\nPLZZ UPVOTE IF YOU LIKE THE SOLUTION\\n     \\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int minimumJumps(vector<int>& nums, int a, int b, int x) {\\n        \\n         queue<pair<int,pair<int,int>> > q;\\n        \\n        // put all element from forbidden array into set for check whether element present or not\\n        set<int> st;\\n        int n=nums.size(); \\n        for(int i=0;i<n;i++)\\n        {\\n            st.insert(nums[i]);\\n           \\n        }\\n        int ans=0;\\n         q.push({0,{0,0}});\\n      \\n        while(!q.empty())\\n        { \\n            \\n            int cnt=q.size();\\n             for(int i=0;i<cnt;i++)\\n             {\\n                      int curr=q.front().first;// curr position\\n                      int score=q.front().second.first; // step\\n                      int back=q.front().second.second;   // if back is 0 then we can traverse backside (jump backward twice in a row)\\n                      q.pop();\\n                      int forward=curr+a;\\n                      int backward=curr-b;\\n                 \\n                 \\n                      if(curr==x) // if curr position == x then return score\\n                           return score;\\n                 \\n                 \\n                      if(st.count(curr)) continue; // curr postion present in set then continue\\n                 \\n                       st.insert(curr);// otherwise put that element in set avoid repeatation on that position\\n                 \\n                    // backward operation\\n                       if(back==0 and backward>=0)\\n                         {\\n                            q.push({backward,{score+1,1}});\\n                         } \\n                    // forward operation\\n                       \\n                       if(backward<=2000)\\n                        {\\n                          q.push({forward,{score+1,0}});\\n                        }\\n              }\\n       }\\n         return -1;\\n    }\\n};\\n\\n\\n\\n\\n \\n\\nPLZZ UPVOTE IF YOU LIKE THE SOLUTION\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828097,
                "title": "java-bfs",
                "content": "```\\nclass Position{\\n    int val;\\n    int direction;\\n    Position(int val, int direction){\\n        this.val = val;\\n        this.direction = direction;\\n    }\\n    @Override\\n    public String toString(){\\n        return this.val+\"#\"+this.direction;\\n    }\\n}\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x == 0)\\n            return 0;\\n        Set<Integer> forbiddenSet = new HashSet();\\n        Set<String> visited = new HashSet();\\n        for (int n: forbidden)\\n            forbiddenSet.add(n);\\n        Queue<Position> queue = new LinkedList();\\n        queue.offer(new Position(0,0));\\n        visited.add(0+\"#\"+0);\\n        int result = 0;\\n        int max = 10000;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            result++;\\n            while(size-->0){\\n                Position curr = queue.poll();\\n                int next_a = curr.val + a;\\n                if (next_a == x)\\n                    return result;\\n                if (next_a >= 0 && next_a < max && !forbiddenSet.contains(next_a) && visited.add(next_a+\"#\"+1))\\n                    queue.add(new Position(next_a, 1));\\n                if (curr.direction == 1){\\n                    int next_b = curr.val - b;\\n                    if (next_b == x)\\n                        return result;\\n                     if (next_b >= 0 && next_b < max && !forbiddenSet.contains(next_b) && visited.add(next_b+\"#\"+0))\\n                    queue.add(new Position(next_b, 0));\\n                    \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Position{\\n    int val;\\n    int direction;\\n    Position(int val, int direction){\\n        this.val = val;\\n        this.direction = direction;\\n    }\\n    @Override\\n    public String toString(){\\n        return this.val+\"#\"+this.direction;\\n    }\\n}\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x == 0)\\n            return 0;\\n        Set<Integer> forbiddenSet = new HashSet();\\n        Set<String> visited = new HashSet();\\n        for (int n: forbidden)\\n            forbiddenSet.add(n);\\n        Queue<Position> queue = new LinkedList();\\n        queue.offer(new Position(0,0));\\n        visited.add(0+\"#\"+0);\\n        int result = 0;\\n        int max = 10000;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            result++;\\n            while(size-->0){\\n                Position curr = queue.poll();\\n                int next_a = curr.val + a;\\n                if (next_a == x)\\n                    return result;\\n                if (next_a >= 0 && next_a < max && !forbiddenSet.contains(next_a) && visited.add(next_a+\"#\"+1))\\n                    queue.add(new Position(next_a, 1));\\n                if (curr.direction == 1){\\n                    int next_b = curr.val - b;\\n                    if (next_b == x)\\n                        return result;\\n                     if (next_b >= 0 && next_b < max && !forbiddenSet.contains(next_b) && visited.add(next_b+\"#\"+0))\\n                    queue.add(new Position(next_b, 0));\\n                    \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809146,
                "title": "easy-to-understand-standard-bfs",
                "content": "Don\\'t get confused by all the confusing top answers. Just apply standard bfs with some modifications\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        HashSet<Integer> visited = new HashSet<>();\\n        for(int val : forbidden){\\n             visited.add(val);\\n\\t\\t}\\n        Queue<int[]> queue = new LinkedList<>();\\n\\t\\t//adding initial state : (position, count of backward steps, jumps)\\n        queue.add(new int[]{0, 0, 0});\\n        visited.add(0);\\n        while(queue.size() > 0){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                int[] first = queue.remove();\\n                int currPos = first[0];\\n                int count = first[1];\\n                int steps = first[2];\\n                if(currPos == x)\\n                    return steps;\\n                int backward = currPos - b;\\n                int forward = currPos + a;\\n                if(!visited.contains(backward) && count < 1){\\n                    if(backward > 0){\\n                        queue.add(new int[]{backward, count + 1, steps + 1});\\n                        visited.add(backward);\\n                    }    \\n                }\\n                if(!visited.contains(forward)){\\n                    if(forward <= 8000){\\n                        queue.add(new int[]{forward, 0, steps + 1});\\n                        visited.add(forward);\\n                    }    \\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        HashSet<Integer> visited = new HashSet<>();\\n        for(int val : forbidden){\\n             visited.add(val);\\n\\t\\t}\\n        Queue<int[]> queue = new LinkedList<>();\\n\\t\\t//adding initial state : (position, count of backward steps, jumps)\\n        queue.add(new int[]{0, 0, 0});\\n        visited.add(0);\\n        while(queue.size() > 0){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                int[] first = queue.remove();\\n                int currPos = first[0];\\n                int count = first[1];\\n                int steps = first[2];\\n                if(currPos == x)\\n                    return steps;\\n                int backward = currPos - b;\\n                int forward = currPos + a;\\n                if(!visited.contains(backward) && count < 1){\\n                    if(backward > 0){\\n                        queue.add(new int[]{backward, count + 1, steps + 1});\\n                        visited.add(backward);\\n                    }    \\n                }\\n                if(!visited.contains(forward)){\\n                    if(forward <= 8000){\\n                        queue.add(new int[]{forward, 0, steps + 1});\\n                        visited.add(forward);\\n                    }    \\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807511,
                "title": "c-bfs-graph-easy-to-understand",
                "content": "\\n\\tclass Solution {\\n    public:\\n    int minimumJumps(vector<int>& fbdn, int a, int b, int x) {  \\n        if(x == 0) return 0;\\n\\t\\t\\n        queue<pair<int,int>>q;\\n        unordered_map<int,int>Map;\\n        set<pair<int,int>>vis;\\n        for(auto ele : fbdn) Map[ele]++;\\n        q.push({0,0});\\n        int steps = 0;\\n\\t\\t\\n        while(!q.empty()){\\n            int Size = q.size();\\n            for(int i = 0;i< Size;i++){\\n                auto [pos,times] = q.front();\\n                q.pop();\\n                if(pos < 0 || Map.count(pos) || pos > 10000 || vis.count({pos,times})) continue;\\n                if(pos == x || pos == x) return steps;\\n                vis.insert({pos, times});\\n                q.push({pos + a,0});\\n                if(times == 0) q.push({pos - b,1});\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n    public:\\n    int minimumJumps(vector<int>& fbdn, int a, int b, int x) {  \\n        if(x == 0) return 0;\\n\\t\\t\\n        queue<pair<int,int>>q;\\n        unordered_map<int,int>Map;\\n        set<pair<int,int>>vis;\\n        for(auto ele : fbdn) Map[ele]++;\\n        q.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1484679,
                "title": "java-bfs-solution",
                "content": "\\tclass Solution {\\n    class Node\\n    {\\n        int val;\\n        int dir;\\n        \\n        Node(int val, int dir)\\n        {\\n            this.val = val;\\n            this.dir = dir;\\n        }\\n        \\n        @Override\\n        public String toString()\\n        {\\n            return this.val + \" \" + this.dir;\\n        }\\n    }\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) \\n    {\\n        if(x == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        int steps = 0, furthest = 5000 + 2*b;\\n        Set<Integer> set =  new HashSet<>();\\n        Set<String> visited = new HashSet<>();\\n        for(int i = 0; i < forbidden.length; i++) \\n        {\\n            set.add(forbidden[i]);\\n            furthest = Math.max(furthest, forbidden[i] + 2*b);\\n        }\\n            \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(new Node(0,0));\\n        visited.add(0+\"-\"+0);\\n        steps++;\\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();   \\n            while(size-- > 0)\\n            {\\n                Node node = queue.poll();\\n                int nexta = node.val+a;\\n                \\n                if(nexta == x)\\n                {\\n                    return steps;\\n                }\\n                \\n                if(nexta >= 0 && nexta <= furthest && !set.contains(nexta) && \\n                   visited.add(nexta+\"-\"+1))\\n                {\\n                    queue.add(new Node(nexta, 1));\\n                }\\n                \\n                if(node.dir == 1)\\n                {\\n                    int nextb = node.val-b;\\n                    if(nextb == x)\\n                    {\\n                        return steps;\\n                    }\\n                    \\n                    if(nextb >= 0 && nextb <= furthest && !set.contains(nextb) && \\n                       visited.add(nextb+\"-\"+0))\\n                    {\\n                        queue.add(new Node(nextb, 0));    \\n                    }\\n                }\\n            }\\n            \\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    class Node\\n    {\\n        int val;\\n        int dir;\\n        \\n        Node(int val, int dir)\\n        {\\n            this.val = val;\\n            this.dir = dir;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1476948,
                "title": "c-dp-recursion",
                "content": "class Solution {\\npublic:\\n    \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\tunordered_map<int,int> mp;\\n    \\n    //here in dp 2D array eg dp[i][j] ,then i saves position & j saves if previously came backward or not\\n    int dp[6001][2];\\n\\n    int solve(int i,bool back,int a,int b,int x)\\n    {\\n        // if we reach the desired place return 0 ;\\n        if(i==x) return 0; \\n        \\n        //if position (i) is in negative or its a forbidden place or its beyond x\\n        //then return a max value;\\n        if(i<0 || mp.find(i)!=mp.end() || i>6000)\\n            return 1e9;\\n\\n        //memoziation\\n        if(dp[i][back]!=-1) return dp[i][back];\\n\\n        \\n        // go forward that is i+a;\\n        \\n        dp[i][back]=1+solve(i+a,false,a,b,x);\\n        \\n        //if back is false then previouly we didn\\'t go backward now we can\\n        if(!back)\\n        {\\n            // now we go backward make backward off \\n            \\n            dp[i][back]=min(dp[i][back],1+solve(i-b,1,a,b,x));\\n            \\n            //here we are taking minimum from going forward & backward;\\n        }\\n        return dp[i][back];\\n    }\\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        //save the forbidden cordinates to fetch in O(1) operation;\\n        for(auto &x :forbidden) mp[x]++; \\n\\n        memset(dp,-1,sizeof(dp));\\n\\n        // here second argument is false beccause at first we can go backward;\\n        int ans=solve(0,false,a,b,x);\\n\\n        if(ans>=1e9) return -1; //\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\tunordered_map<int,int> mp;\\n    \\n    //here in dp 2D array eg dp[i][j] ,then i saves position & j saves if previously came backward or not\\n    int dp[6001][2];\\n\\n    int solve(int i,bool back,int a,int b,int x)\\n    {\\n        // if we reach the desired place return 0 ;\\n        if(i==x) return 0; \\n        \\n        //if position (i) is in negative or its a forbidden place or its beyond x\\n        //then return a max value;\\n        if(i<0 || mp.find(i)!=mp.end() || i>6000)\\n            return 1e9;\\n\\n        //memoziation\\n        if(dp[i][back]!=-1) return dp[i][back];\\n\\n        \\n        // go forward that is i+a;\\n        \\n        dp[i][back]=1+solve(i+a,false,a,b,x);\\n        \\n        //if back is false then previouly we didn\\'t go backward now we can\\n        if(!back)\\n        {\\n            // now we go backward make backward off \\n            \\n            dp[i][back]=min(dp[i][back],1+solve(i-b,1,a,b,x));\\n            \\n            //here we are taking minimum from going forward & backward;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1416279,
                "title": "c-bfs-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool s[20000], v[20000];\\n    int minimumJumps(vector<int>& fb, int a, int b, int x) {\\n        queue<pair<int, int>> q;\\n        q.emplace(0, 0);\\n        int m = max(a, b);\\n        for (auto f : fb) s[f] = true;\\n        for (int i = 0; !q.empty(); i++) {\\n            for (int j = 0, e = q.size(); j < e; j++) {\\n                auto [cur, back] = q.front(); q.pop();\\n                if (cur == x) return i;\\n                \\n                if (cur <= x + 5 * m && !s[cur + a]) {\\n                    s[cur + a] = true;;\\n                    q.emplace(cur + a, 0);\\n                }\\n                if (cur - b > 0 && !back && !s[cur - b] && !v[cur - b]) {\\n                    v[cur - b] = true;\\n                    q.emplace(cur - b, 1);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool s[20000], v[20000];\\n    int minimumJumps(vector<int>& fb, int a, int b, int x) {\\n        queue<pair<int, int>> q;\\n        q.emplace(0, 0);\\n        int m = max(a, b);\\n        for (auto f : fb) s[f] = true;\\n        for (int i = 0; !q.empty(); i++) {\\n            for (int j = 0, e = q.size(); j < e; j++) {\\n                auto [cur, back] = q.front(); q.pop();\\n                if (cur == x) return i;\\n                \\n                if (cur <= x + 5 * m && !s[cur + a]) {\\n                    s[cur + a] = true;;\\n                    q.emplace(cur + a, 0);\\n                }\\n                if (cur - b > 0 && !back && !s[cur - b] && !v[cur - b]) {\\n                    v[cur - b] = true;\\n                    q.emplace(cur - b, 1);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314618,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        # each node in the queue is (position, jumped backward last time, number of steps)\\n        queue = collections.deque([(0, False, 0)])\\n        # Notice it is important to keep the False in seen not just the position\\n        seen = set([0, False])\\n        upper_bound = 6000\\n        def valid_position(pos, back):\\n            return 0 <= pos <= upper_bound and (pos, back) not in seen and pos not in forbidden\\n        \\n        while queue:\\n            for _ in range(len(queue)):\\n                pos, back, steps = queue.pop()\\n                if pos == x:\\n                    return steps\\n                if valid_position(pos + a, False):\\n                    seen.add((pos+a, back))\\n                    queue.appendleft((pos+a, False, steps+1))\\n                if not back and valid_position(pos-b, True):\\n                    seen.add((pos-b, True))\\n                    queue.appendleft((pos-b, True, steps+1))\\n        return -1                   \\n                        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        # each node in the queue is (position, jumped backward last time, number of steps)\\n        queue = collections.deque([(0, False, 0)])\\n        # Notice it is important to keep the False in seen not just the position\\n        seen = set([0, False])\\n        upper_bound = 6000\\n        def valid_position(pos, back):\\n            return 0 <= pos <= upper_bound and (pos, back) not in seen and pos not in forbidden\\n        \\n        while queue:\\n            for _ in range(len(queue)):\\n                pos, back, steps = queue.pop()\\n                if pos == x:\\n                    return steps\\n                if valid_position(pos + a, False):\\n                    seen.add((pos+a, back))\\n                    queue.appendleft((pos+a, False, steps+1))\\n                if not back and valid_position(pos-b, True):\\n                    seen.add((pos-b, True))\\n                    queue.appendleft((pos-b, True, steps+1))\\n        return -1                   \\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163359,
                "title": "faster-than-90-and-less-memory-than-92-c",
                "content": "```\\nstruct node{\\n    int   pos;      /* legal jump position */\\n    bool  backflag; /* if this pos is backward point*/\\n    int   jump;     /* step times */\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        node head = {0, false, 0};\\n        queue<node> q;\\n        q.push(head);\\n        bool visited[2001+2*2000] = {false};\\n        bool forbiddenList[2001+2*2000] = {false};\\n        int ret = -1;\\n\\n        for(auto c: forbidden)\\n        {\\n            forbiddenList[c] = true;\\n        }\\n        int backward = 0;\\n        int forward  = 0;\\n        while(q.empty() == false)\\n        {\\n            head = q.front();\\n            q.pop();\\n\\n            if(head.pos == x) /* bingo */\\n            {\\n                ret = head.jump;\\n                break;\\n            }\\n            if(visited[head.pos] == true)\\n                continue;\\n            if(head.backflag == false) //only set to visited when it isn\\'t backward node;\\n                visited[head.pos] = true;\\n\\n            forward  = head.pos + a; //go forward;\\n            backward = head.pos - b; //back;\\n            \\n            //handle the forward pos;\\n            if( (forward < 2000 + 2*2000 + 1)     && \\\\\\n                (forbiddenList[forward] == false) && \\\\\\n                (visited[forward] == false)/* cut the unnecessary path */ )\\n            {\\n                q.push({forward, false, head.jump+1});\\n            }\\n\\n            //handle the backward pos;\\n            if( (backward >0)                      && \\\\\\n                (forbiddenList[backward] == false) && \\\\\\n                (head.backflag == false)           && \\\\\\n                (visited[backward] == false) /* cut the unnecessary path */)\\n            {\\n                 q.push({backward, true, head.jump+1});\\n            }\\n        }\\n        return ret;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct node{\\n    int   pos;      /* legal jump position */\\n    bool  backflag; /* if this pos is backward point*/\\n    int   jump;     /* step times */\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        node head = {0, false, 0};\\n        queue<node> q;\\n        q.push(head);\\n        bool visited[2001+2*2000] = {false};\\n        bool forbiddenList[2001+2*2000] = {false};\\n        int ret = -1;\\n\\n        for(auto c: forbidden)\\n        {\\n            forbiddenList[c] = true;\\n        }\\n        int backward = 0;\\n        int forward  = 0;\\n        while(q.empty() == false)\\n        {\\n            head = q.front();\\n            q.pop();\\n\\n            if(head.pos == x) /* bingo */\\n            {\\n                ret = head.jump;\\n                break;\\n            }\\n            if(visited[head.pos] == true)\\n                continue;\\n            if(head.backflag == false) //only set to visited when it isn\\'t backward node;\\n                visited[head.pos] = true;\\n\\n            forward  = head.pos + a; //go forward;\\n            backward = head.pos - b; //back;\\n            \\n            //handle the forward pos;\\n            if( (forward < 2000 + 2*2000 + 1)     && \\\\\\n                (forbiddenList[forward] == false) && \\\\\\n                (visited[forward] == false)/* cut the unnecessary path */ )\\n            {\\n                q.push({forward, false, head.jump+1});\\n            }\\n\\n            //handle the backward pos;\\n            if( (backward >0)                      && \\\\\\n                (forbiddenList[backward] == false) && \\\\\\n                (head.backflag == false)           && \\\\\\n                (visited[backward] == false) /* cut the unnecessary path */)\\n            {\\n                 q.push({backward, true, head.jump+1});\\n            }\\n        }\\n        return ret;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146906,
                "title": "c-bfs-beats-95",
                "content": "```\\nclass Solution {\\n    struct Bug{\\n        int pos;\\n        bool isBackward;\\n    };\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        if(x == 0)\\n            return 0;\\n\\n        bool isVisited[6001][2] = {false, };\\n        isVisited[0][0] = isVisited[0][1] = true;\\n\\n        for(int num : forbidden) {\\n            isVisited[num][0] = isVisited[num][1] = true;\\n        }\\n\\n        queue<Bug> q;\\n\\n        q.push({0, false});\\n\\n        for(int jump = 0; !q.empty(); jump++) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                Bug bug = q.front();\\n                q.pop();\\n                if(!bug.isBackward && bug.pos >= b && !isVisited[bug.pos - b][1]) {\\n                    isVisited[bug.pos - b][1] = true;\\n                    if(bug.pos - b == x)\\n                        return jump + 1;\\n                    q.push({bug.pos - b, true});\\n                }\\n\\n                if(bug.pos + a <= 6000 && !isVisited[bug.pos + a][0]) {\\n                    isVisited[bug.pos + a][0] = true;\\n                    if(bug.pos + a == x)\\n                        return jump + 1;\\n                    q.push({bug.pos + a, false});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct Bug{\\n        int pos;\\n        bool isBackward;\\n    };\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        if(x == 0)\\n            return 0;\\n\\n        bool isVisited[6001][2] = {false, };\\n        isVisited[0][0] = isVisited[0][1] = true;\\n\\n        for(int num : forbidden) {\\n            isVisited[num][0] = isVisited[num][1] = true;\\n        }\\n\\n        queue<Bug> q;\\n\\n        q.push({0, false});\\n\\n        for(int jump = 0; !q.empty(); jump++) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n                Bug bug = q.front();\\n                q.pop();\\n                if(!bug.isBackward && bug.pos >= b && !isVisited[bug.pos - b][1]) {\\n                    isVisited[bug.pos - b][1] = true;\\n                    if(bug.pos - b == x)\\n                        return jump + 1;\\n                    q.push({bug.pos - b, true});\\n                }\\n\\n                if(bug.pos + a <= 6000 && !isVisited[bug.pos + a][0]) {\\n                    isVisited[bug.pos + a][0] = true;\\n                    if(bug.pos + a == x)\\n                        return jump + 1;\\n                    q.push({bug.pos + a, false});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112959,
                "title": "help-me-figure-out-what-s-wrong-with-this-bfs",
                "content": "I\\'m confused as to what is wrong with this BFS, I\\'m assuming only two types of jumps are possible from a particular point, a or a-b, cause two b\\'s can\\'t be together.\\n```\\nint f(vector<bool> &reds, int a, int b, int x){\\n        queue<pair<int,int> > q;\\n        q.push({0,0});\\n        reds[0]=true;\\n        while(!q.empty()){\\n            auto [p,c] = q.front();\\n            q.pop();\\n            if(p==x){\\n                return c;\\n            }\\n            int np = p+a;\\n                if(np>0 && np<=5000 && !reds[np]){\\n                    q.push({np,c+1});\\n                    reds[np]=true;\\n                }\\n            np = p+a-b;\\n                if(np>0 && np<=5000 && !reds[np]){\\n                    q.push({np,c+2});\\n                    reds[np]=true;\\n                }\\n        }\\n        return -1;\\n    }\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<bool> reds(50001,false);\\n        for(int el:forbidden){\\n            reds[el]=true;\\n        }\\n        return f(reds,a,b,x);\\n    }\\n\\t",
                "solutionTags": [],
                "code": "I\\'m confused as to what is wrong with this BFS, I\\'m assuming only two types of jumps are possible from a particular point, a or a-b, cause two b\\'s can\\'t be together.\\n```\\nint f(vector<bool> &reds, int a, int b, int x){\\n        queue<pair<int,int> > q;\\n        q.push({0,0});\\n        reds[0]=true;\\n        while(!q.empty()){\\n            auto [p,c] = q.front();\\n            q.pop();\\n            if(p==x){\\n                return c;\\n            }\\n            int np = p+a;\\n                if(np>0 && np<=5000 && !reds[np]){\\n                    q.push({np,c+1});\\n                    reds[np]=true;\\n                }\\n            np = p+a-b;\\n                if(np>0 && np<=5000 && !reds[np]){\\n                    q.push({np,c+2});\\n                    reds[np]=true;\\n                }\\n        }\\n        return -1;\\n    }\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        vector<bool> reds(50001,false);\\n        for(int el:forbidden){\\n            reds[el]=true;\\n        }\\n        return f(reds,a,b,x);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1103362,
                "title": "python3-bfs",
                "content": "\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        upper = max(forbidden | {x}) + a + b\\n        \\n        ans = 0\\n        queue = [(0, 0)]\\n        forbidden.add(0)\\n        while queue: \\n            newq = []\\n            for n, k in queue: \\n                if n == x: return ans\\n                if n+a <= upper and n+a not in forbidden: \\n                    newq.append((n+a, 0))\\n                    forbidden.add(n+a)\\n                if k == 0 and 0 <= n-b and n-b not in forbidden: \\n                    newq.append((n-b, 1))\\n            ans += 1\\n            queue = newq\\n        return -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        forbidden = set(forbidden)\\n        upper = max(forbidden | {x}) + a + b\\n        \\n        ans = 0\\n        queue = [(0, 0)]\\n        forbidden.add(0)\\n        while queue: \\n            newq = []\\n            for n, k in queue: \\n                if n == x: return ans\\n                if n+a <= upper and n+a not in forbidden: \\n                    newq.append((n+a, 0))\\n                    forbidden.add(n+a)\\n                if k == 0 and 0 <= n-b and n-b not in forbidden: \\n                    newq.append((n-b, 1))\\n            ans += 1\\n            queue = newq\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101895,
                "title": "why-does-it-not-work-if-i-push-next-in-the-queue-first-and-back-after-that",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<int> s(forbidden.begin(), forbidden.end());\\n        queue<vector<int>> q;\\n        q.push({0, 0, 1});\\n        while(!q.empty()) {\\n            auto it = q.front();\\n            q.pop();\\n            int start = it[0], steps = it[1], jump = it[2];\\n            if(start == x)\\n                return steps;\\n            if(s.find(start) != s.end())\\n                continue;\\n            s.insert(start);\\n            int next = start + a;\\n            int back = start - b;\\n            if(s.find(back) == s.end() && back > 0 && back < 7000 && jump == 1)\\n                q.push({back, steps + 1, 0});\\n            if(s.find(next) == s.end() && next > 0 && next < 7000)\\n                q.push({next, steps + 1, 1});\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<int> s(forbidden.begin(), forbidden.end());\\n        queue<vector<int>> q;\\n        q.push({0, 0, 1});\\n        while(!q.empty()) {\\n            auto it = q.front();\\n            q.pop();\\n            int start = it[0], steps = it[1], jump = it[2];\\n            if(start == x)\\n                return steps;\\n            if(s.find(start) != s.end())\\n                continue;\\n            s.insert(start);\\n            int next = start + a;\\n            int back = start - b;\\n            if(s.find(back) == s.end() && back > 0 && back < 7000 && jump == 1)\\n                q.push({back, steps + 1, 0});\\n            if(s.find(next) == s.end() && next > 0 && next < 7000)\\n                q.push({next, steps + 1, 1});\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086369,
                "title": "c-top-down-recursive-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[2][6005];\\n    int fun(int idx,int a,int b,int x,int back)\\n    {\\n         if(idx==x)\\n            return 0;\\n        if(idx>=6005||idx<0||dp[back][idx]==-2)\\n        {\\n            return 1e9;\\n        }\\n        \\n        if(dp[back][idx]!=-1)\\n            return dp[back][idx];\\n        \\n        \\n        dp[back][idx]=1+fun(idx+a,a,b,x,0);\\n        if(!back&&a!=b)\\n        {\\n            dp[back][idx]=min(dp[back][idx],1+fun(idx-b,a,b,x,1));\\n        }\\n        \\n        return dp[back][idx];\\n    }               \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        if(x==0)\\n            return 0;\\n        int i,n=forbidden.size();\\n        for(i=0;i<6005;i++)\\n        {\\n            dp[0][i]=-1;\\n            dp[1][i]=-1;\\n        }\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            dp[0][forbidden[i]]=-2;\\n            dp[1][forbidden[i]]=-2;\\n        }\\n        \\n        int res=fun(0,a,b,x,0);\\n        if(res>=1e9)\\n            return -1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[2][6005];\\n    int fun(int idx,int a,int b,int x,int back)\\n    {\\n         if(idx==x)\\n            return 0;\\n        if(idx>=6005||idx<0||dp[back][idx]==-2)\\n        {\\n            return 1e9;\\n        }\\n        \\n        if(dp[back][idx]!=-1)\\n            return dp[back][idx];\\n        \\n        \\n        dp[back][idx]=1+fun(idx+a,a,b,x,0);\\n        if(!back&&a!=b)\\n        {\\n            dp[back][idx]=min(dp[back][idx],1+fun(idx-b,a,b,x,1));\\n        }\\n        \\n        return dp[back][idx];\\n    }               \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        if(x==0)\\n            return 0;\\n        int i,n=forbidden.size();\\n        for(i=0;i<6005;i++)\\n        {\\n            dp[0][i]=-1;\\n            dp[1][i]=-1;\\n        }\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            dp[0][forbidden[i]]=-2;\\n            dp[1][forbidden[i]]=-2;\\n        }\\n        \\n        int res=fun(0,a,b,x,0);\\n        if(res>=1e9)\\n            return -1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065457,
                "title": "both-dfs-memoization-and-bfs-solutions-python",
                "content": "DFS + Memoization\\n\\n```\\nclass Solution(object):\\n    def is_pos_valid(self, pos, forbidden_map):\\n        if pos in forbidden_map or pos < 0:\\n            return False\\n        return True\\n    \\n    def calculate_jumps(self, dp, pos, b_jump, fwd, bwd):\\n        if fwd < 0 and bwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = -1\\n            return -1\\n        elif fwd >= 0 and bwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = fwd + 1\\n            return fwd + 1\\n        elif bwd >= 0 and fwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = bwd + 1\\n            return bwd + 1\\n        \\n        dp[str(pos) + \"$\" + str(b_jump)] = min(fwd, bwd) + 1\\n        \\n        return min(fwd, bwd) + 1\\n        \\n    def get_min_jumps(self, a, b, x, forbidden_map, current_pos, jumps, dp, visited, b_jumps):\\n        if str(current_pos) + \"$\" + str(b_jumps) in dp:            \\n            return dp[str(current_pos) + \"$\" + str(b_jumps)]\\n        \\n        if current_pos in visited and visited[current_pos]:\\n            return -1\\n        \\n        if not self.is_pos_valid(current_pos, forbidden_map):\\n            return -1\\n        \\n        if current_pos > 2000+a+b:\\n            return -1\\n            \\n        if b_jumps >= 2:\\n            return -1\\n        \\n        if current_pos == x:\\n            return 0\\n               \\n        visited[current_pos] = True\\n        fwd = self.get_min_jumps(a, b, x, forbidden_map, current_pos+a, jumps, dp, visited, 0)\\n        bwd = self.get_min_jumps(a, b, x, forbidden_map, current_pos-b, jumps, dp, visited, b_jumps+1)\\n        visited[current_pos] = False\\n        \\n        return self.calculate_jumps(dp, current_pos, b_jumps, fwd, bwd)\\n    \\n    def create_forbidden_map(self, forbidden):\\n        forbidden_map = {}\\n        for pos in forbidden:\\n            forbidden_map[pos] = True\\n            \\n        return forbidden_map\\n            \\n    def minimumJumps(self, forbidden, a, b, x):\\n        max_num = pow(10, 7)\\n        forbidden_map = self.create_forbidden_map(forbidden)\\n        dp = {}\\n        return self.get_min_jumps(a,b,x,forbidden_map,0, 0, dp, {}, 0)\\n```\\n\\n\\n=============\\n\\nBFS Solution\\n\\n```\\nclass Solution(object):\\n    def get_key(self, pos, b_jump):\\n        return str(pos) + \"$\" + str(b_jump)\\n    \\n    def is_pos_valid(self, pos, forbidden_map):\\n        if pos in forbidden_map or pos < 0:\\n            return False\\n        return True\\n    \\n    def create_forbidden_map(self, forbidden):\\n        forbidden_map = {}\\n        for pos in forbidden:\\n            forbidden_map[pos] = True\\n            \\n        return forbidden_map\\n        \\n    def get_min_jumps(self, a, b, x, forbidden_map, bfs):\\n        q = deque()\\n        q.append(bfs)\\n        visited = {}\\n        visited[self.get_key(0, 0)] = True\\n        limit = 2000 + a + b\\n        \\n        while len(q) > 0:\\n            element = q.popleft()\\n            pos = element[0]\\n            b_jumps = element[1]\\n            jumps = element[2]\\n            \\n            if pos == x:\\n                return jumps\\n            \\n            if self.is_pos_valid(pos+a, forbidden_map) and self.get_key(pos+a, 0) not in visited and pos < limit:\\n                visited[self.get_key(pos+a, 0)] = True\\n                q.append([pos+a, 0, jumps+1])\\n            if b_jumps != 1:\\n                if self.is_pos_valid(pos-b, forbidden_map) and self.get_key(pos-b, 1) not in visited and pos < limit:\\n                    visited[self.get_key(pos-b, 1)] = True\\n                    q.append([pos-b, 1, jumps+1])\\n                    \\n        return -1\\n            \\n    def minimumJumps(self, forbidden, a, b, x):\\n        forbidden_map = self.create_forbidden_map(forbidden)\\n        return self.get_min_jumps(a,b,x,forbidden_map, [0, 0, 0])\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def is_pos_valid(self, pos, forbidden_map):\\n        if pos in forbidden_map or pos < 0:\\n            return False\\n        return True\\n    \\n    def calculate_jumps(self, dp, pos, b_jump, fwd, bwd):\\n        if fwd < 0 and bwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = -1\\n            return -1\\n        elif fwd >= 0 and bwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = fwd + 1\\n            return fwd + 1\\n        elif bwd >= 0 and fwd < 0:\\n            dp[str(pos) + \"$\" + str(b_jump)] = bwd + 1\\n            return bwd + 1\\n        \\n        dp[str(pos) + \"$\" + str(b_jump)] = min(fwd, bwd) + 1\\n        \\n        return min(fwd, bwd) + 1\\n        \\n    def get_min_jumps(self, a, b, x, forbidden_map, current_pos, jumps, dp, visited, b_jumps):\\n        if str(current_pos) + \"$\" + str(b_jumps) in dp:            \\n            return dp[str(current_pos) + \"$\" + str(b_jumps)]\\n        \\n        if current_pos in visited and visited[current_pos]:\\n            return -1\\n        \\n        if not self.is_pos_valid(current_pos, forbidden_map):\\n            return -1\\n        \\n        if current_pos > 2000+a+b:\\n            return -1\\n            \\n        if b_jumps >= 2:\\n            return -1\\n        \\n        if current_pos == x:\\n            return 0\\n               \\n        visited[current_pos] = True\\n        fwd = self.get_min_jumps(a, b, x, forbidden_map, current_pos+a, jumps, dp, visited, 0)\\n        bwd = self.get_min_jumps(a, b, x, forbidden_map, current_pos-b, jumps, dp, visited, b_jumps+1)\\n        visited[current_pos] = False\\n        \\n        return self.calculate_jumps(dp, current_pos, b_jumps, fwd, bwd)\\n    \\n    def create_forbidden_map(self, forbidden):\\n        forbidden_map = {}\\n        for pos in forbidden:\\n            forbidden_map[pos] = True\\n            \\n        return forbidden_map\\n            \\n    def minimumJumps(self, forbidden, a, b, x):\\n        max_num = pow(10, 7)\\n        forbidden_map = self.create_forbidden_map(forbidden)\\n        dp = {}\\n        return self.get_min_jumps(a,b,x,forbidden_map,0, 0, dp, {}, 0)\\n```\n```\\nclass Solution(object):\\n    def get_key(self, pos, b_jump):\\n        return str(pos) + \"$\" + str(b_jump)\\n    \\n    def is_pos_valid(self, pos, forbidden_map):\\n        if pos in forbidden_map or pos < 0:\\n            return False\\n        return True\\n    \\n    def create_forbidden_map(self, forbidden):\\n        forbidden_map = {}\\n        for pos in forbidden:\\n            forbidden_map[pos] = True\\n            \\n        return forbidden_map\\n        \\n    def get_min_jumps(self, a, b, x, forbidden_map, bfs):\\n        q = deque()\\n        q.append(bfs)\\n        visited = {}\\n        visited[self.get_key(0, 0)] = True\\n        limit = 2000 + a + b\\n        \\n        while len(q) > 0:\\n            element = q.popleft()\\n            pos = element[0]\\n            b_jumps = element[1]\\n            jumps = element[2]\\n            \\n            if pos == x:\\n                return jumps\\n            \\n            if self.is_pos_valid(pos+a, forbidden_map) and self.get_key(pos+a, 0) not in visited and pos < limit:\\n                visited[self.get_key(pos+a, 0)] = True\\n                q.append([pos+a, 0, jumps+1])\\n            if b_jumps != 1:\\n                if self.is_pos_valid(pos-b, forbidden_map) and self.get_key(pos-b, 1) not in visited and pos < limit:\\n                    visited[self.get_key(pos-b, 1)] = True\\n                    q.append([pos-b, 1, jumps+1])\\n                    \\n        return -1\\n            \\n    def minimumJumps(self, forbidden, a, b, x):\\n        forbidden_map = self.create_forbidden_map(forbidden)\\n        return self.get_min_jumps(a,b,x,forbidden_map, [0, 0, 0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055681,
                "title": "javascript-bfs-solution-with-exmplanation",
                "content": "What I learned from this problem:\\n- reason why the limit is `2000+b`. the limit should be larger than the `(x+b)` or `forbidden_MAX+b`, due to the constraints, both `x` & `forbidden[i]` have a max value of 2000.\\n- use `datastructure/Queue`  or just Array, here just use Array is enough, because no sorting.\\n- destructure from array in ES6( [docs](https://googlechrome.github.io/samples/destructuring-es6/) )\\n\\n\\n```js\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    // 0 ------ x ---- x+b ----^\\n    //                 <------left\\n    var visited = new Set(forbidden);\\n    var limit = 2000+b; // max(x, forbidden_MAX) + b\\n    var q = [[0,0]];\\n    var step = 0;\\n    while(q.length>0)\\n    {\\n        var size = q.length;\\n        while(size>0)\\n        {\\n            var [cur,dir] = q.shift();\\n            size--;\\n            if(cur===x)\\n            {\\n                return step;\\n            }\\n            if(visited.has(cur))\\n            {\\n                continue;\\n            }\\n            visited.add(cur);\\n            if(dir === 0 && cur-b>=0)\\n            {\\n                q.push([cur-b, 1]);\\n            } \\n            if( cur <= limit )\\n            {\\n                q.push([cur+a, 0]);   \\n            }\\n           \\n        }\\n        step++;\\n    } // end while queue\\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    // 0 ------ x ---- x+b ----^\\n    //                 <------left\\n    var visited = new Set(forbidden);\\n    var limit = 2000+b; // max(x, forbidden_MAX) + b\\n    var q = [[0,0]];\\n    var step = 0;\\n    while(q.length>0)\\n    {\\n        var size = q.length;\\n        while(size>0)\\n        {\\n            var [cur,dir] = q.shift();\\n            size--;\\n            if(cur===x)\\n            {\\n                return step;\\n            }\\n            if(visited.has(cur))\\n            {\\n                continue;\\n            }\\n            visited.add(cur);\\n            if(dir === 0 && cur-b>=0)\\n            {\\n                q.push([cur-b, 1]);\\n            } \\n            if( cur <= limit )\\n            {\\n                q.push([cur+a, 0]);   \\n            }\\n           \\n        }\\n        step++;\\n    } // end while queue\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1006979,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n        if (x == 0)\\n            return 0;\\n        \\n        vector<vector<int>> steps(2, vector<int>(6001, INT_MAX));\\n        \\n        for(int i = 0; i < forbidden.size(); i++) \\n        {\\n            if(forbidden[i] < steps[0].size())\\n                steps[0][forbidden[i]] = steps[1][forbidden[i]] = -1;\\n        }\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        int step = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int pos = q.front().first;\\n                int dir = q.front().second;\\n                if(pos == x)\\n                    goto end;\\n                \\n                if (pos + a < steps[0].size() && steps[0][pos + a] == INT_MAX) {\\n                    steps[0][pos + a] = 1 + step;\\n                    q.push({pos + a, 0});\\n                }\\n                \\n                if (dir == 0 && pos - b >= 0 && steps[1][pos - b] == INT_MAX) {\\n                    steps[1][pos - b] = 1 + step;\\n                    q.push({pos - b, 1});\\n                }\\n                q.pop();\\n            }\\n            step++;    \\n        }\\n    end:\\n        int res = min(steps[0][x], steps[1][x]);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) \\n    {\\n        if (x == 0)\\n            return 0;\\n        \\n        vector<vector<int>> steps(2, vector<int>(6001, INT_MAX));\\n        \\n        for(int i = 0; i < forbidden.size(); i++) \\n        {\\n            if(forbidden[i] < steps[0].size())\\n                steps[0][forbidden[i]] = steps[1][forbidden[i]] = -1;\\n        }\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        int step = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int pos = q.front().first;\\n                int dir = q.front().second;\\n                if(pos == x)\\n                    goto end;\\n                \\n                if (pos + a < steps[0].size() && steps[0][pos + a] == INT_MAX) {\\n                    steps[0][pos + a] = 1 + step;\\n                    q.push({pos + a, 0});\\n                }\\n                \\n                if (dir == 0 && pos - b >= 0 && steps[1][pos - b] == INT_MAX) {\\n                    steps[1][pos - b] = 1 + step;\\n                    q.push({pos - b, 1});\\n                }\\n                q.pop();\\n            }\\n            step++;    \\n        }\\n    end:\\n        int res = min(steps[0][x], steps[1][x]);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003679,
                "title": "wrong-example-in-example-2-why-is-it-1-when-there-exists-a-solution",
                "content": "```\\nExample 2:\\n    Input: forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\\n    Output: -1\\nSolution: [15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 167, 154, 141, 128, 115, 102, 89, 76, 63, 50, 37, 24, 11]\\nSolution in 25 steps. \\n```\\nWhy is this solution wrong?",
                "solutionTags": [],
                "code": "```\\nExample 2:\\n    Input: forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\\n    Output: -1\\nSolution: [15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 167, 154, 141, 128, 115, 102, 89, 76, 63, 50, 37, 24, 11]\\nSolution in 25 steps. \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1002763,
                "title": "bfs-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\t\\tconst int n=6000;\\n\\t\\t\\tint v[n][2];\\n\\t\\t\\tmemset(v,-1,sizeof v);\\n\\t\\t\\tv[0][0]=v[0][1]=0;\\n\\t\\t\\tfor(int i:forbidden)v[i][0]=v[i][1]=INT_MAX;\\n\\t\\t\\tqueue<pair<int,bool>>q;\\n\\t\\t\\tq.push({0,1});\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint num=q.front().first;\\n\\t\\t\\t\\tbool ch=q.front().second;\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tif(num==x)return v[num][ch];\\n\\t\\t\\t\\tif(num+a<n&&v[num+a][0]==-1)\\n\\t\\t\\t\\t\\tq.push({num+a,0}),v[num+a][0]=v[num][ch]+1;\\n\\n\\t\\t\\t\\tif(!ch&&num-b>0&&v[num-b][1]==-1)\\n\\t\\t\\t\\t\\tq.push({num-b,1}),v[num-b][1]=v[num][ch]+1;\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n\\t\\t\\tconst int n=6000;\\n\\t\\t\\tint v[n][2];\\n\\t\\t\\tmemset(v,-1,sizeof v);\\n\\t\\t\\tv[0][0]=v[0][1]=0;\\n\\t\\t\\tfor(int i:forbidden)v[i][0]=v[i][1]=INT_MAX;\\n\\t\\t\\tqueue<pair<int,bool>>q;\\n\\t\\t\\tq.push({0,1}",
                "codeTag": "Java"
            },
            {
                "id": 958328,
                "title": "bfs-c",
                "content": "class Solution {\\n\\tpublic:\\n\\t\\n\\t\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int, int> m;\\n        bool visited[2][10000];\\n\\t\\t\\n\\t\\t\\n\\t\\t\\t// visited[ 0 ][ K ] = true ; means the Kth cell was reached by jumping forward,\\n\\t\\t\\t// visited[ 1 ][ K ] = true ; means the Kth cell was reached by jumping backward. \\n        memset(visited, false, sizeof(visited));\\n        queue<pair<int, int>> q;\\n\\t\\t\\t// queue<pair<val, 0>> indicates the val is obtained by moving forward\\n\\t\\t\\t//queue<pair<val, 1>> indicates the val is obtained by movind backward and so we cannot move backward again in this step\\n        pair<int, int> p;\\n        int level=0, size, forward, backward;\\n        q.push(make_pair(0, 0));\\n        \\n        for(int val : forbidden) \\n            m[val]=1;       //  m[val]==1 , means it is forbidden\\n    \\n        while(!q.empty())\\n        {\\n            size=q.size();\\n            while(size)\\n            {\\n                size--;\\n                p=q.front();\\n                q.pop();\\n                if(p.first==x)\\n                    return level;\\n                \\n                forward=p.first+a;\\n                backward=p.first-b;\\n                \\n                if(forward<6000 && m.find(forward)==m.end() && !visited[0][forward])\\n                {    \\n                    q.push(make_pair(forward, 0));\\n                    visited[0][forward]=true;\\n                }\\n                if(p.second==0 && p.first-b>0 && m.find(backward)==m.end() && !visited[1][backward])\\n                {\\n                    q.push(make_pair(backward, 1));\\n                    visited[1][backward]=true;\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\n\\t\\n\\t\\tint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_map<int, int> m;\\n        bool visited[2][10000];\\n\\t\\t\\n\\t\\t\\n\\t\\t\\t// visited[ 0 ][ K ] = true ; means the Kth cell was reached by jumping forward,\\n\\t\\t\\t// visited[ 1 ][ K ] = true ; means the Kth cell was reached by jumping backward. \\n        memset(visited, false, sizeof(visited));\\n        queue<pair<int, int>> q;\\n\\t\\t\\t// queue<pair<val, 0>> indicates the val is obtained by moving forward\\n\\t\\t\\t//queue<pair<val, 1>> indicates the val is obtained by movind backward and so we cannot move backward again in this step\\n        pair<int, int> p;\\n        int level=0, size, forward, backward;\\n        q.push(make_pair(0, 0));\\n        \\n        for(int val : forbidden) \\n            m[val]=1;       //  m[val]==1 , means it is forbidden\\n    \\n        while(!q.empty())\\n        {\\n            size=q.size();\\n            while(size)\\n            {\\n                size--;\\n                p=q.front();\\n                q.pop();\\n                if(p.first==x)\\n                    return level;\\n                \\n                forward=p.first+a;\\n                backward=p.first-b;\\n                \\n                if(forward<6000 && m.find(forward)==m.end() && !visited[0][forward])\\n                {    \\n                    q.push(make_pair(forward, 0));\\n                    visited[0][forward]=true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 953184,
                "title": "easy-c-bfs-solution",
                "content": "visited matrix to be marked as done when we can visit forward as well as backward from that particular index.\\n```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        unordered_set<int> forbiddenSet(forbidden.begin() , forbidden.end());\\n        \\n        queue<pair<int, bool>> q;\\n        q.push({0,false});\\n        bool isBackward = false;\\n        vector<pair<bool, bool>> visited( 6000, {false,false}); // to check if we have visited both forard and backward from the index.\\n        int steps = 0;\\n        visited[0].first = false;\\n        visited[0].second = false;\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            while(n != 0)\\n            {\\n                auto temp = q.front();\\n                q.pop();\\n                \\n                if( temp.first == x)\\n                    return steps;\\n                \\n                int forward = temp.first+a;\\n                if( forward < 6000 and !forbiddenSet.count(forward) and visited[temp.first].first == false)\\n                {\\n                    q.push({forward,false});\\n                    visited[temp.first].first = true;\\n                }\\n                \\n                if(!temp.second)\\n                {\\n                    int backward = temp.first-b;\\n                    if( backward >= 0 and !forbiddenSet.count(backward)  and visited[temp.first].second == false)\\n                    {\\n                        q.push({backward,true});\\n                        visited[temp.first].second = true;\\n                    }\\n                }\\n                n--;\\n            }\\n            steps++;\\n        }\\n        return -1;       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        unordered_set<int> forbiddenSet(forbidden.begin() , forbidden.end());\\n        \\n        queue<pair<int, bool>> q;\\n        q.push({0,false});\\n        bool isBackward = false;\\n        vector<pair<bool, bool>> visited( 6000, {false,false}); // to check if we have visited both forard and backward from the index.\\n        int steps = 0;\\n        visited[0].first = false;\\n        visited[0].second = false;\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            while(n != 0)\\n            {\\n                auto temp = q.front();\\n                q.pop();\\n                \\n                if( temp.first == x)\\n                    return steps;\\n                \\n                int forward = temp.first+a;\\n                if( forward < 6000 and !forbiddenSet.count(forward) and visited[temp.first].first == false)\\n                {\\n                    q.push({forward,false});\\n                    visited[temp.first].first = true;\\n                }\\n                \\n                if(!temp.second)\\n                {\\n                    int backward = temp.first-b;\\n                    if( backward >= 0 and !forbiddenSet.count(backward)  and visited[temp.first].second == false)\\n                    {\\n                        q.push({backward,true});\\n                        visited[temp.first].second = true;\\n                    }\\n                }\\n                n--;\\n            }\\n            steps++;\\n        }\\n        return -1;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951091,
                "title": "easiest-approach-c-explaining-1998-1999-2000-2000-test-case-bfs",
                "content": "**I have applied restriction by 5998 because a=1999,b=2000,x=2000\\nAt max we can make a forward jump of max(a,b)+x\\nWhy?Because we can only make a single backward jump at once and if the region of finding x is in [2000,4000] and we go move any further beyond this range for example 4005 then we wont be able to reach our target x=2000 as 4005(a)-2000(b)=2005 which is inside our range but now we cant move further back because at max only 1 backward jump is allowed . So for the test case beyond the range i have rejected it.\\n**\\nclass Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int>map(forbidden.begin(),forbidden.end());\\n        \\n        queue<pair<int,bool>>q;\\n        vector<vector<int>>vis(2,vector<int>(5998));// for the test case when a=1999 and b=2000 after 3 iterations value of a would 1999*3=5997 which would be less than 5998 that size needed to mark it visited.\\n        \\n       ** //Imp jump can be at max=max(a,b)+x because after that we cant go back as only 1 backward jump allowed at once**\\n        q.push({0,false});\\n        vis[0][0]=1;\\n        vis[1][0]=1;\\n        int ans=0;\\n        while(q.size()!=0){\\n            int n=q.size();\\n            while(n-->0){\\n                int cur=q.front().first;\\n                bool flag=q.front().second;\\n                if(cur==x){\\n                    return ans;\\n                }\\n                q.pop();\\n                int forw=cur+a;\\n                int back=cur-b;\\n                if(forw<5998 && vis[0][forw]==0 && !map.count(forw)){\\n                    q.push({forw,false});\\n                    vis[0][forw]=1;\\n                }\\n                if(back>=0 && vis[1][back]==0 && !map.count(back) && !flag){\\n                    q.push({back,true});\\n                    vis[1][back]=1;\\n                }\\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        unordered_set<int>map(forbidden.begin(),forbidden.end());\\n        \\n        queue<pair<int,bool>>q;\\n        vector<vector<int>>vis(2,vector<int>(5998));// for the test case when a=1999 and b=2000 after 3 iterations value of a would 1999*3=5997 which would be less than 5998 that size needed to mark it visited.\\n        \\n       ** //Imp jump can be at max=max(a,b)+x because after that we cant go back as only 1 backward jump allowed at once**\\n        q.push({0,false}",
                "codeTag": "Java"
            },
            {
                "id": 938985,
                "title": "working-code-passing-all-testcases",
                "content": "Most codes are failing the testcase where the value could go above 4000 , Value can go above 4000 and then come back down ...\\n```\\nclass Solution {\\npublic:\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<vector<int>> q;\\n        q.push({0,0});\\n        int c=0;\\n        q.push({-1});\\n        map<vector<int>,bool> visited;\\n        map<int,int> f;\\n        for(int i=0;i<forbidden.size();i++)\\n        {\\n            f[forbidden[i]]++;\\n        }\\n        while(q.size()>1)\\n        {\\n           vector<int> v = q.front();\\n            int front = v[0];\\n            cout<<front<<endl;\\n            q.pop();\\n            if(front>6000)\\n                continue;\\n            if(front ==-1)\\n           {\\n               c++;\\n               q.push({-1});\\n               continue;\\n           }\\n             if(visited[v]==1)\\n                continue;\\n            visited[v]=1;\\n            int back = v[1];\\n              if(front==x)\\n                return c;\\n            int z = front +a;\\n            int y = front - b;\\n            if(f[z]==false)\\n            {\\n                q.push({z,0});\\n            }\\n            if(back!=1)\\n            {\\n            if(f[y]==false&&y>=0)\\n            {\\n                q.push({y,1});\\n            }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        queue<vector<int>> q;\\n        q.push({0,0});\\n        int c=0;\\n        q.push({-1});\\n        map<vector<int>,bool> visited;\\n        map<int,int> f;\\n        for(int i=0;i<forbidden.size();i++)\\n        {\\n            f[forbidden[i]]++;\\n        }\\n        while(q.size()>1)\\n        {\\n           vector<int> v = q.front();\\n            int front = v[0];\\n            cout<<front<<endl;\\n            q.pop();\\n            if(front>6000)\\n                continue;\\n            if(front ==-1)\\n           {\\n               c++;\\n               q.push({-1});\\n               continue;\\n           }\\n             if(visited[v]==1)\\n                continue;\\n            visited[v]=1;\\n            int back = v[1];\\n              if(front==x)\\n                return c;\\n            int z = front +a;\\n            int y = front - b;\\n            if(f[z]==false)\\n            {\\n                q.push({z,0});\\n            }\\n            if(back!=1)\\n            {\\n            if(f[y]==false&&y>=0)\\n            {\\n                q.push({y,1});\\n            }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 937899,
                "title": "python-bfs-with-double-queue-80ms",
                "content": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x == 0: return 0\\n        forb = set(forbidden)\\n        mx = x + a if a >= b else max(x, *forbidden) + a + b\\n        queueA, queueB = [], [0]\\n        count = 0\\n        while queueA or queueB:\\n            qA, qB = [], []\\n\\n            for v in queueA + queueB:\\n                if v == x: return count\\n                n = v + a\\n                if n in forb or n > mx: continue\\n\\n                qA.append(n); forb.add(n)\\n                \\n            for v in queueA:\\n                n = v - b\\n                if n in forb or n <= 0: continue\\n\\n                qB.append(n); forb.add(n)\\n\\n            queueA, queueB = qA, qB\\n            count += 1\\n            \\n        return -1\\n```\\n* *queueA* is created after forward steps\\n* *queueB* is created after backward steps\\n* if *a >= b* then maximum position is not depending on *b* or *forbidden*\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x == 0: return 0\\n        forb = set(forbidden)\\n        mx = x + a if a >= b else max(x, *forbidden) + a + b\\n        queueA, queueB = [], [0]\\n        count = 0\\n        while queueA or queueB:\\n            qA, qB = [], []\\n\\n            for v in queueA + queueB:\\n                if v == x: return count\\n                n = v + a\\n                if n in forb or n > mx: continue\\n\\n                qA.append(n); forb.add(n)\\n                \\n            for v in queueA:\\n                n = v - b\\n                if n in forb or n <= 0: continue\\n\\n                qB.append(n); forb.add(n)\\n\\n            queueA, queueB = qA, qB\\n            count += 1\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936339,
                "title": "bfs",
                "content": "Neighbours is formed by the current state of the node.\\nIf current state has moved forward, then we can go either back or forward.\\nIf current state has moved backward, then we can only go forward.\\n\\n\\n```\\n    fun minimumJumps(forbidden: IntArray, a: Int, b: Int, target: Int): Int {\\n        val banned = forbidden.toSet()\\n\\t\\tval max = forbidden.max()!! + a + b + target\\n        val queue: Queue<Pair<Int, Boolean>> = LinkedList()\\n        val dist: MutableMap<Pair<Int, Boolean>, Int> = HashMap()\\n        queue.offer(0 to true)\\n        dist[0 to true] = 0\\n        \\n        fun neighbours(node: Pair<Int, Boolean>): List<Pair<Int, Boolean>> {\\n            val ans: MutableList<Pair<Int, Boolean>> = ArrayList()\\n            var (loc, canGoBack) = node\\n            var newLoc = loc + a\\n            if (newLoc < max && banned.contains(newLoc).not()) {\\n                ans.add(newLoc to true)\\n            }\\n            if (canGoBack) {\\n                newLoc = loc - b\\n                if (newLoc >= 0 && banned.contains(newLoc).not()) {\\n                    ans.add(newLoc to false)\\n                }\\n            }\\n            return ans\\n        }\\n        \\n        while (queue.isNotEmpty()) {\\n            val node = queue.poll()\\n            if (node.first == target) {\\n                return dist[node]!!\\n            }\\n            for (nei in neighbours(node)) {\\n                if (dist.contains(nei).not()) {\\n                    dist[nei] = 1 + dist[node]!!\\n                    queue.offer(nei)\\n                }\\n            }\\n        }\\n        \\n        return -1\\n    }\\n```\\n\\nSource: https://bit.ly/36AlnAl",
                "solutionTags": [
                    "Kotlin",
                    "Breadth-First Search"
                ],
                "code": "```\\n    fun minimumJumps(forbidden: IntArray, a: Int, b: Int, target: Int): Int {\\n        val banned = forbidden.toSet()\\n\\t\\tval max = forbidden.max()!! + a + b + target\\n        val queue: Queue<Pair<Int, Boolean>> = LinkedList()\\n        val dist: MutableMap<Pair<Int, Boolean>, Int> = HashMap()\\n        queue.offer(0 to true)\\n        dist[0 to true] = 0\\n        \\n        fun neighbours(node: Pair<Int, Boolean>): List<Pair<Int, Boolean>> {\\n            val ans: MutableList<Pair<Int, Boolean>> = ArrayList()\\n            var (loc, canGoBack) = node\\n            var newLoc = loc + a\\n            if (newLoc < max && banned.contains(newLoc).not()) {\\n                ans.add(newLoc to true)\\n            }\\n            if (canGoBack) {\\n                newLoc = loc - b\\n                if (newLoc >= 0 && banned.contains(newLoc).not()) {\\n                    ans.add(newLoc to false)\\n                }\\n            }\\n            return ans\\n        }\\n        \\n        while (queue.isNotEmpty()) {\\n            val node = queue.poll()\\n            if (node.first == target) {\\n                return dist[node]!!\\n            }\\n            for (nei in neighbours(node)) {\\n                if (dist.contains(nei).not()) {\\n                    dist[nei] = 1 + dist[node]!!\\n                    queue.offer(nei)\\n                }\\n            }\\n        }\\n        \\n        return -1\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935851,
                "title": "java-very-simple-bfs",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        var forbid = new HashSet<Integer>();\\n        for(int i : forbidden) forbid.add(i);\\n        \\n        var visited = new int[2*2000];\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        q.add(0); // at\\n        q.add(0); // #jumps\\n        q.add(0); // isBackward\\n        \\n        while(!q.isEmpty())\\n        {\\n            int at = q.remove();\\n            int j = q.remove();\\n            int isback = q.remove();\\n            \\n            if(at == x) return j;\\n            \\n            if(at+a < 2*2000 && !forbid.contains(at+a) && visited[at+a] < 4) \\n                {q.add(at+a); q.add(j+1); q.add(0); visited[at+a]++;}\\n            if(isback == 0 && at >= b && !forbid.contains(at-b) && visited[at-b] < 4)\\n                {q.add(at-b); q.add(j+1); q.add(1); visited[at-b]++;}\\n        }\\n        \\n        return -1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        var forbid = new HashSet<Integer>();\\n        for(int i : forbidden) forbid.add(i);\\n        \\n        var visited = new int[2*2000];\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        q.add(0); // at\\n        q.add(0); // #jumps\\n        q.add(0); // isBackward\\n        \\n        while(!q.isEmpty())\\n        {\\n            int at = q.remove();\\n            int j = q.remove();\\n            int isback = q.remove();\\n            \\n            if(at == x) return j;\\n            \\n            if(at+a < 2*2000 && !forbid.contains(at+a) && visited[at+a] < 4) \\n                {q.add(at+a); q.add(j+1); q.add(0); visited[at+a]++;}\\n            if(isback == 0 && at >= b && !forbid.contains(at-b) && visited[at-b] < 4)\\n                {q.add(at-b); q.add(j+1); q.add(1); visited[at-b]++;}\\n        }\\n        \\n        return -1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935810,
                "title": "java-bfs-set-pair-avoid-fixed-size-visited-array",
                "content": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\\n        Set<Pair<Integer, Integer>> set = new HashSet<>();\\n        int max = a + b + x;\\n        for (int i = 0; i < forbidden.length; i++) {\\n            set.add(new Pair<Integer, Integer>(forbidden[i], 0));\\n            set.add(new Pair<Integer, Integer>(forbidden[i], 1));\\n            max = Math.max(max, forbidden[i] + a + b);\\n        }\\n        queue.offer(new Pair<Integer, Integer>(0, 0));\\n        set.add(queue.peek());\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                Pair<Integer, Integer> p = queue.poll();\\n                if (p.getKey() == x) return steps;\\n                Pair<Integer, Integer> next = new Pair<Integer, Integer>(p.getKey() + a, 0);\\n                Pair<Integer, Integer> prev = new Pair<Integer, Integer>(p.getKey() - b, p.getValue() + 1);\\n                if (next.getKey() <= max && !set.contains(next)) {\\n                    set.add(next);\\n                    queue.offer(next);\\n                }\\n                if (prev.getKey() >= 0 && !set.contains(prev) && prev.getValue() < 2) {\\n                    set.add(prev);\\n                    queue.offer(prev);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\\n        Set<Pair<Integer, Integer>> set = new HashSet<>();\\n        int max = a + b + x;\\n        for (int i = 0; i < forbidden.length; i++) {\\n            set.add(new Pair<Integer, Integer>(forbidden[i], 0));\\n            set.add(new Pair<Integer, Integer>(forbidden[i], 1));\\n            max = Math.max(max, forbidden[i] + a + b);\\n        }\\n        queue.offer(new Pair<Integer, Integer>(0, 0));\\n        set.add(queue.peek());\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                Pair<Integer, Integer> p = queue.poll();\\n                if (p.getKey() == x) return steps;\\n                Pair<Integer, Integer> next = new Pair<Integer, Integer>(p.getKey() + a, 0);\\n                Pair<Integer, Integer> prev = new Pair<Integer, Integer>(p.getKey() - b, p.getValue() + 1);\\n                if (next.getKey() <= max && !set.contains(next)) {\\n                    set.add(next);\\n                    queue.offer(next);\\n                }\\n                if (prev.getKey() >= 0 && !set.contains(prev) && prev.getValue() < 2) {\\n                    set.add(prev);\\n                    queue.offer(prev);\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935524,
                "title": "java-with-no-need-to-track-state-beats-100",
                "content": "For the life of me I cannot understand why people insist on tacking state (do we go backwards or forwards) in a solution like mine.\\n\\nOnly put positions into the queue that you reached on going back.\\nAnd only go forward from those positions that are in the queue.\\n\\n```\\n\\tfinal private Set<Integer> fset = new HashSet<>();\\n\\tprivate int[] axis;\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x==0)\\n\\t\\t\\treturn 0;\\n\\t\\tfor (int f : forbidden)\\n\\t\\t\\tfset.add(f);\\n\\t\\tif (fset.contains(a) || fset.contains(x))\\n\\t\\t\\treturn -1;\\n\\n\\t\\tint maxLen=10000;\\n\\t\\t\\n\\t\\taxis=new int[maxLen];\\n\\t\\tArrays.fill(axis, -1);\\n\\t\\taxis[0]=0;\\n\\t\\taxis[a]=1;\\n\\t\\tint cnt=1;\\n\\t\\tQueue<Integer> backs = new LinkedList<>();\\n\\t\\tfor (int i=a;i<maxLen;i+=a) {\\n\\t\\t\\tif (fset.contains(i))\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tif (i==x)\\n\\t\\t\\t\\treturn cnt;\\n\\t\\t\\taxis[i]=cnt;\\n\\t\\t\\tcnt++;\\n\\t\\t\\tif (i-b>0 && axis[i-b]<0 && !fset.contains(i-b))\\n\\t\\t\\t\\tbacks.add(i-b);\\n\\t\\t}\\n\\t\\tif (b==a)\\n\\t\\t\\treturn -1;\\n\\n\\t\\twhile (!backs.isEmpty()) {\\n\\t\\t\\tint size=backs.size();\\n\\t\\t\\tfor (int i=0;i<size;i++) {\\n\\t\\t\\t\\tint back=backs.remove();\\n\\t\\t\\t\\tint base=axis[back+b]+1;\\n\\t\\t\\t\\taxis[back]=base;\\n\\t\\t\\t\\tif (back==x)\\n\\t\\t\\t\\t\\treturn base;\\n\\t\\t\\t\\tbase++;\\n\\t\\t\\t\\tfor (int j=back+a;j<maxLen;j+=a) {\\n\\t\\t\\t\\t\\tif (fset.contains(j))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tif (axis[j]>0)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\taxis[j]=base;\\n\\t\\t\\t\\t\\tif (j==x)\\n\\t\\t\\t\\t\\t\\treturn base;\\n\\t\\t\\t\\t\\tbase++;\\n\\t\\t\\t\\t\\tif (j-b>0 && axis[j-b]<0 && !fset.contains(j-b))\\n\\t\\t\\t\\t\\t\\tbacks.add(j-b);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n    \\n```",
                "solutionTags": [],
                "code": "```\\n\\tfinal private Set<Integer> fset = new HashSet<>();\\n\\tprivate int[] axis;\\n    \\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x==0)\\n\\t\\t\\treturn 0;\\n\\t\\tfor (int f : forbidden)\\n\\t\\t\\tfset.add(f);\\n\\t\\tif (fset.contains(a) || fset.contains(x))\\n\\t\\t\\treturn -1;\\n\\n\\t\\tint maxLen=10000;\\n\\t\\t\\n\\t\\taxis=new int[maxLen];\\n\\t\\tArrays.fill(axis, -1);\\n\\t\\taxis[0]=0;\\n\\t\\taxis[a]=1;\\n\\t\\tint cnt=1;\\n\\t\\tQueue<Integer> backs = new LinkedList<>();\\n\\t\\tfor (int i=a;i<maxLen;i+=a) {\\n\\t\\t\\tif (fset.contains(i))\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tif (i==x)\\n\\t\\t\\t\\treturn cnt;\\n\\t\\t\\taxis[i]=cnt;\\n\\t\\t\\tcnt++;\\n\\t\\t\\tif (i-b>0 && axis[i-b]<0 && !fset.contains(i-b))\\n\\t\\t\\t\\tbacks.add(i-b);\\n\\t\\t}\\n\\t\\tif (b==a)\\n\\t\\t\\treturn -1;\\n\\n\\t\\twhile (!backs.isEmpty()) {\\n\\t\\t\\tint size=backs.size();\\n\\t\\t\\tfor (int i=0;i<size;i++) {\\n\\t\\t\\t\\tint back=backs.remove();\\n\\t\\t\\t\\tint base=axis[back+b]+1;\\n\\t\\t\\t\\taxis[back]=base;\\n\\t\\t\\t\\tif (back==x)\\n\\t\\t\\t\\t\\treturn base;\\n\\t\\t\\t\\tbase++;\\n\\t\\t\\t\\tfor (int j=back+a;j<maxLen;j+=a) {\\n\\t\\t\\t\\t\\tif (fset.contains(j))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tif (axis[j]>0)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\taxis[j]=base;\\n\\t\\t\\t\\t\\tif (j==x)\\n\\t\\t\\t\\t\\t\\treturn base;\\n\\t\\t\\t\\t\\tbase++;\\n\\t\\t\\t\\t\\tif (j-b>0 && axis[j-b]<0 && !fset.contains(j-b))\\n\\t\\t\\t\\t\\t\\tbacks.add(j-b);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935443,
                "title": "go-bfs",
                "content": "I used BFS to solve this problem.  The basic idea is that you can move backwards only once so used a flag to keep track of that and you can move forwards each time.  I could not get this work without using the visited array.  Also I used 5000 because a,b <=2000 and x<=2000 so I suppose if you travel to 5000 which is about 3000 away from x and b cannot be greater than 2000,  You are not going to have chance to arrive at x, even if it is 2000.  \\n\\n```\\nfunc minimumJumps(forbidden []int, a int, b int, x int) int {\\n    forb := make(map[int]bool)\\n    for _, y := range forbidden {\\n        forb[y]=true\\n    }\\n    var queue [][3]int\\n    if _, found := forb[a]; found {\\n        return -1\\n    }\\n    var visited [5000]int\\n    visited[0]=1\\n    queue = append(queue, [3]int{0,1,0})\\n    for len(queue)>0 {\\n        cand := queue[0]\\n        loc := cand[0]\\n        steps := cand[2]\\n        flag := cand[1]\\n        if loc==x {\\n            return steps\\n        }\\n        queue[0]=[3]int{0,0,0}\\n        queue=queue[1:]\\n        backward := loc-b\\n        _, found := forb[backward]\\n        if flag==1 && !found && backward>=0 && visited[backward]==0 {\\n            queue=append(queue,[3]int{backward,0,steps+1})\\n            visited[backward]=1\\n        }\\n        forward := loc+a\\n        _, found = forb[forward]\\n        if !found && forward<5000 && visited[forward]==0 {\\n            queue=append(queue,[3]int{forward,1,steps+1})\\n            visited[forward]=1\\n        }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc minimumJumps(forbidden []int, a int, b int, x int) int {\\n    forb := make(map[int]bool)\\n    for _, y := range forbidden {\\n        forb[y]=true\\n    }\\n    var queue [][3]int\\n    if _, found := forb[a]; found {\\n        return -1\\n    }\\n    var visited [5000]int\\n    visited[0]=1\\n    queue = append(queue, [3]int{0,1,0})\\n    for len(queue)>0 {\\n        cand := queue[0]\\n        loc := cand[0]\\n        steps := cand[2]\\n        flag := cand[1]\\n        if loc==x {\\n            return steps\\n        }\\n        queue[0]=[3]int{0,0,0}\\n        queue=queue[1:]\\n        backward := loc-b\\n        _, found := forb[backward]\\n        if flag==1 && !found && backward>=0 && visited[backward]==0 {\\n            queue=append(queue,[3]int{backward,0,steps+1})\\n            visited[backward]=1\\n        }\\n        forward := loc+a\\n        _, found = forb[forward]\\n        if !found && forward<5000 && visited[forward]==0 {\\n            queue=append(queue,[3]int{forward,1,steps+1})\\n            visited[forward]=1\\n        }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935440,
                "title": "dfs-with-c",
                "content": "I should be more careful next time on what states I need to put in the dp and what should not be put. \\n```\\nclass Solution {\\npublic:\\n  \\n#define MAXN 10005\\n\\n\\ntypedef struct _Node { \\n    int value = -1; \\n}Node; \\n  \\nmap<pair<int,bool>,Node> f;\\n\\n\\nvoid dfs(int state, int a, int b, int x, int depth, bool inarow){\\n    if(state > MAXN)\\n        return;\\n    if(state < 0)\\n        return;\\n    pair<int,int> st = make_pair(state , inarow);\\n    if( (depth >= f[st].value && f[st].value >= 0) )\\n        return;\\n    Node xxx;\\n    xxx.value = depth;\\n    f[st] = xxx;\\n    \\n    if(state == x) return;\\n    if(inarow){\\n        dfs(state + a, a, b, x, depth + 1, false);\\n    }else{\\n        dfs(state + a, a, b, x, depth +1 , false);\\n        dfs(state - b, a, b, x, depth +1 , true);\\n    }\\n}\\n\\nint smin(int x, int y){\\n    if(x== y && x == -1)    return -1;\\n    if(x == -1) x = MAXN;\\n    if(y == -1) y = MAXN;\\n    return min(x,y);\\n}\\n\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        for(int i = 0; i < forbidden.size(); ++ i){\\n            Node xxx;\\n            xxx.value = 0;\\n            f[make_pair(forbidden[i],0)] = f[make_pair(forbidden[i],1)] = xxx;\\n        }\\n        \\n        dfs(0, a, b, x, 0, false);\\n        return smin(f[make_pair(x,0)].value,f[make_pair(x,1)].value);\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n#define MAXN 10005\\n\\n\\ntypedef struct _Node { \\n    int value = -1; \\n}Node; \\n  \\nmap<pair<int,bool>,Node> f;\\n\\n\\nvoid dfs(int state, int a, int b, int x, int depth, bool inarow){\\n    if(state > MAXN)\\n        return;\\n    if(state < 0)\\n        return;\\n    pair<int,int> st = make_pair(state , inarow);\\n    if( (depth >= f[st].value && f[st].value >= 0) )\\n        return;\\n    Node xxx;\\n    xxx.value = depth;\\n    f[st] = xxx;\\n    \\n    if(state == x) return;\\n    if(inarow){\\n        dfs(state + a, a, b, x, depth + 1, false);\\n    }else{\\n        dfs(state + a, a, b, x, depth +1 , false);\\n        dfs(state - b, a, b, x, depth +1 , true);\\n    }\\n}\\n\\nint smin(int x, int y){\\n    if(x== y && x == -1)    return -1;\\n    if(x == -1) x = MAXN;\\n    if(y == -1) y = MAXN;\\n    return min(x,y);\\n}\\n\\nint minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        \\n        for(int i = 0; i < forbidden.size(); ++ i){\\n            Node xxx;\\n            xxx.value = 0;\\n            f[make_pair(forbidden[i],0)] = f[make_pair(forbidden[i],1)] = xxx;\\n        }\\n        \\n        dfs(0, a, b, x, 0, false);\\n        return smin(f[make_pair(x,0)].value,f[make_pair(x,1)].value);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935383,
                "title": "86-87-passed-why-bfs-can-t-work-change-2000-4000-it-will-work",
                "content": "\\tvar minimumJumps = function(forbidden, a, b, x) {\\n\\t\\tforbidden = new Set(forbidden);\\n\\t\\tif (forbidden.has(0) || forbidden.has(x)) return -1;\\n\\t\\tif (x === 0) return 0;\\n\\t\\tconst seta = new Set([0]);\\n\\t\\tconst setb = new Set([0]);\\n\\n\\t\\tconst queue = [[0,0]];\\n\\t\\tlet step = 0;\\n\\n\\t\\twhile (queue.length) {\\n\\t\\t\\tlet size = queue.length;\\n\\n\\t\\t\\tfor (let i = 0; i < size; i++) {\\n\\t\\t\\t\\tlet [curr, time] = queue.shift();\\n\\t\\t\\t\\tlet na = curr + a;\\n\\n\\t\\t\\t\\tif (na >= 0 && !seta.has(na) && !forbidden.has(na)) {\\n\\t\\t\\t\\t\\tif (na === x) return step+1;\\n\\t\\t\\t\\t\\tif (!(a >= b && na > x+2*b)) {\\n\\t\\t\\t\\t\\t\\tqueue.push([na, 0]);\\n\\t\\t\\t\\t\\t\\tseta.add(na);   \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tlet nb = curr - b;\\n\\n\\t\\t\\t\\tif (nb >= 0 && time <= 1 && !setb.has(nb) && !forbidden.has(nb)) {\\n\\t\\t\\t\\t\\tif (nb === x) return step+1;\\n\\t\\t\\t\\t\\tqueue.push([nb, time+1]);\\n\\t\\t\\t\\t\\tsetb.add(nb);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tstep++;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t};",
                "solutionTags": [],
                "code": "\\tvar minimumJumps = function(forbidden, a, b, x) {\\n\\t\\tforbidden = new Set(forbidden);\\n\\t\\tif (forbidden.has(0) || forbidden.has(x)) return -1;\\n\\t\\tif (x === 0) return 0;\\n\\t\\tconst seta = new Set([0]);\\n\\t\\tconst setb = new Set([0]);\\n\\n\\t\\tconst queue = [[0,0]];\\n\\t\\tlet step = 0;\\n\\n\\t\\twhile (queue.length) {\\n\\t\\t\\tlet size = queue.length;\\n\\n\\t\\t\\tfor (let i = 0; i < size; i++) {\\n\\t\\t\\t\\tlet [curr, time] = queue.shift();\\n\\t\\t\\t\\tlet na = curr + a;\\n\\n\\t\\t\\t\\tif (na >= 0 && !seta.has(na) && !forbidden.has(na)) {\\n\\t\\t\\t\\t\\tif (na === x) return step+1;\\n\\t\\t\\t\\t\\tif (!(a >= b && na > x+2*b)) {\\n\\t\\t\\t\\t\\t\\tqueue.push([na, 0]);\\n\\t\\t\\t\\t\\t\\tseta.add(na);   \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tlet nb = curr - b;\\n\\n\\t\\t\\t\\tif (nb >= 0 && time <= 1 && !setb.has(nb) && !forbidden.has(nb)) {\\n\\t\\t\\t\\t\\tif (nb === x) return step+1;\\n\\t\\t\\t\\t\\tqueue.push([nb, time+1]);\\n\\t\\t\\t\\t\\tsetb.add(nb);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tstep++;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 4083736,
                "title": "easy-to-understand-javascript-solution-bfs",
                "content": "# Complexity\\n- Time complexity:\\n$$O(maxX*2)$$\\n\\n- Space complexity:\\n$$O(maxX*2)$$\\n\\n# Code\\n```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    const MAX_X = 2000 + a + b;\\n    const visited = new Set(forbidden);\\n    const queue = [{ position: 0, isBack: false }];\\n    let step = 0;\\n\\n    while (queue.length) {\\n        const size = queue.length;\\n\\n        for (let index = 0; index < size; index++) {\\n            const { position, isBack } = queue.shift();\\n\\n            if (position === x) return step;\\n            const forward = position + a;\\n            const back = position - b;\\n\\n            if (forward <= MAX_X && !visited.has(forward)) {\\n                visited.add(forward);\\n                queue.push({ position: forward, isBack: false });\\n            }\\n            if (back >= 0 && !isBack && !visited.has(back)) {\\n                queue.push({ position: back, isBack: true }); \\n            }\\n        }\\n        step += 1;\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    const MAX_X = 2000 + a + b;\\n    const visited = new Set(forbidden);\\n    const queue = [{ position: 0, isBack: false }];\\n    let step = 0;\\n\\n    while (queue.length) {\\n        const size = queue.length;\\n\\n        for (let index = 0; index < size; index++) {\\n            const { position, isBack } = queue.shift();\\n\\n            if (position === x) return step;\\n            const forward = position + a;\\n            const back = position - b;\\n\\n            if (forward <= MAX_X && !visited.has(forward)) {\\n                visited.add(forward);\\n                queue.push({ position: forward, isBack: false });\\n            }\\n            if (back >= 0 && !isBack && !visited.has(back)) {\\n                queue.push({ position: back, isBack: true }); \\n            }\\n        }\\n        step += 1;\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047716,
                "title": "recursion-memoization-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int dp[6001][2];\\n    unordered_map<int,int> mp;\\n    int f(int i, int back , int a ,int b, int x) \\n    {\\n        if(i==x) return 0;\\n        if(i<0 || i>6000 || back>=2 || mp.find(i)!=mp.end()) return 1e9;\\n        if(dp[i][back]!=-1) return dp[i][back];\\n        dp[i][back]=1+f(i+a,0,a,b,x); \\n        if(!back) dp[i][back]=min(dp[i][back],f(i-b,1,a,b,x)+1);  \\n        return dp[i][back];\\n    }\\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++) mp[forbidden[i]]=1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans=f(0,0,a,b,x);\\n        if(ans>1e9) return -1;\\n        return ans;               \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int dp[6001][2];\\n    unordered_map<int,int> mp;\\n    int f(int i, int back , int a ,int b, int x) \\n    {\\n        if(i==x) return 0;\\n        if(i<0 || i>6000 || back>=2 || mp.find(i)!=mp.end()) return 1e9;\\n        if(dp[i][back]!=-1) return dp[i][back];\\n        dp[i][back]=1+f(i+a,0,a,b,x); \\n        if(!back) dp[i][back]=min(dp[i][back],f(i-b,1,a,b,x)+1);  \\n        return dp[i][back];\\n    }\\n\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        for(int i=0;i<forbidden.size();i++) mp[forbidden[i]]=1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans=f(0,0,a,b,x);\\n        if(ans>1e9) return -1;\\n        return ans;               \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047456,
                "title": "upper-limit-to-search-with-b-greater-than-a",
                "content": "It\\'s not so difficult to find the upper limit of a breadth first search when $$b <= a$$. \\nFor the upper limit when $$b > a$$, this is a not so math-inclined approach. A movement sequence from A to Z across L like this \\n<pre>\\nM               Z    A      L    \\n|---------------|----|------|---|--|----|\\n                     |---------->      1\\n                                |==>   2\\n                <------------------|   3\\n</pre>\\ncan always be transformed into this without ever touching L\\n<pre>\\nM               Z     A     L      \\n|-|-------------|-----|-----|-----------|\\n  <-------------------|       1     \\n  |==>                        2\\n     |---------->             3\\n</pre>\\nIn the above pictures L stands for some upper limit. Both the first and third movement are single jumps, while the second might be composite of a serious of movements. Since our lovely frog is seeking her way with least jumps as possible, the second movement will never be longer than `b - a`, because if it were, she surely can go back `b - a` position(s) by two more jumps, a contradiction to the optimal assumption.\\nThe transformation can be achieved simply by switching the first the first jump and last jump. That\\'s to say, for any route that goes beyond some upper limit L, and can later go back (and might as well reach x finally),there is a corresponding route that \\n1. reaches the very same destination \\n2. does not goes beyond the limit L\\n3. does not goes back too far away to touch some lower limit which might be dangerous.\\n\\nRemaining task is to decide the accurate position of L which can be quite obvious from the above pictures.  \\n# Code\\n```ruby\\n# @param {Integer[]} forbidden\\n# @param {Integer} a\\n# @param {Integer} b\\n# @param {Integer} x\\n# @return {Integer}\\ndef minimum_jumps(forbidden, a, b, x)\\n  visited = Set.new\\n  lower = 0\\n  upper = [forbidden.max + a, x].max + b\\n  forbidden = forbidden.to_set\\n  q = [[0, 1, 0]]\\n  explore = lambda do |pos, dir, step|\\n    if pos >= lower && pos <= upper && !visited.include?(pos * dir) && !forbidden.include?(pos)\\n      visited << pos * dir\\n      q << [pos, dir, step]\\n    end\\n  end\\n  \\n  while (pos, dir, step = q.shift)\\n    return step if pos == x\\n\\n    explore[pos + a, 1, step + 1]\\n    explore[pos - b, -1, step + 1] if dir == 1\\n  end\\n\\n  -1\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[]} forbidden\\n# @param {Integer} a\\n# @param {Integer} b\\n# @param {Integer} x\\n# @return {Integer}\\ndef minimum_jumps(forbidden, a, b, x)\\n  visited = Set.new\\n  lower = 0\\n  upper = [forbidden.max + a, x].max + b\\n  forbidden = forbidden.to_set\\n  q = [[0, 1, 0]]\\n  explore = lambda do |pos, dir, step|\\n    if pos >= lower && pos <= upper && !visited.include?(pos * dir) && !forbidden.include?(pos)\\n      visited << pos * dir\\n      q << [pos, dir, step]\\n    end\\n  end\\n  \\n  while (pos, dir, step = q.shift)\\n    return step if pos == x\\n\\n    explore[pos + a, 1, step + 1]\\n    explore[pos - b, -1, step + 1] if dir == 1\\n  end\\n\\n  -1\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4034756,
                "title": "easy-solution",
                "content": "# Code\\n```javascript []\\n/**\\n * @param {number[]} forbidden\\n * @param {number} a\\n * @param {number} b\\n * @param {number} x\\n * @return {number}\\n */\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    let queue = [];\\n    const seen = new Set();\\n    const banned = new Set(forbidden);\\n\\n    queue.push([0, true])\\n    const maxPosition = a + b + Math.max(x, Math.max(...forbidden));\\n    let jumps = 0\\n\\n    while (queue.length) {\\n        let size = queue.length\\n\\n        while (size--) {\\n            let [cur, canGoBack] = queue.shift();\\n\\n            if (cur === x)\\n                return jumps;\\n            \\n            const forward = cur + a, backward = cur - b;\\n            const fkey = `${forward}-true`, bkey = `${backward}-false`;\\n\\n            if (!banned.has(forward) && forward <= maxPosition && !seen.has(fkey)) {\\n                queue.push([forward, true]);\\n                seen.add(fkey);\\n            }\\n    \\n            if (canGoBack && !banned.has(backward) && backward >= 0 && !seen.has(bkey)) {\\n                queue.push([backward, false]);\\n                seen.add(bkey);\\n            }\\n        }\\n\\n        jumps++;\\n    }\\n\\n    return -1\\n};\\n```\\n```python []\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = deque()\\n        seen = set()\\n        banned = set(forbidden)\\n\\n        jumps = 0\\n        queue.append((0, True))\\n        max_position = a + b + max(x, max(forbidden))\\n\\n        while queue:\\n            size = len(queue)\\n\\n            for _ in range(size):\\n                cur, can_go_backward = queue.popleft()\\n\\n                if cur == x:\\n                    return jumps\\n                \\n                forward = (cur + a, True)\\n                backward = (cur - b, False)\\n\\n                if forward[0] not in banned and forward[0] <= max_position and forward not in seen:\\n                    queue.append(forward)\\n                    seen.add(forward)\\n\\n                if can_go_backward and backward[0] not in banned and backward[0] >= 0 and backward not in seen:\\n                    queue.append(backward)\\n                    seen.add(backward)\\n                \\n            jumps += 1\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript []\\n/**\\n * @param {number[]} forbidden\\n * @param {number} a\\n * @param {number} b\\n * @param {number} x\\n * @return {number}\\n */\\nvar minimumJumps = function(forbidden, a, b, x) {\\n    let queue = [];\\n    const seen = new Set();\\n    const banned = new Set(forbidden);\\n\\n    queue.push([0, true])\\n    const maxPosition = a + b + Math.max(x, Math.max(...forbidden));\\n    let jumps = 0\\n\\n    while (queue.length) {\\n        let size = queue.length\\n\\n        while (size--) {\\n            let [cur, canGoBack] = queue.shift();\\n\\n            if (cur === x)\\n                return jumps;\\n            \\n            const forward = cur + a, backward = cur - b;\\n            const fkey = `${forward}-true`, bkey = `${backward}-false`;\\n\\n            if (!banned.has(forward) && forward <= maxPosition && !seen.has(fkey)) {\\n                queue.push([forward, true]);\\n                seen.add(fkey);\\n            }\\n    \\n            if (canGoBack && !banned.has(backward) && backward >= 0 && !seen.has(bkey)) {\\n                queue.push([backward, false]);\\n                seen.add(bkey);\\n            }\\n        }\\n\\n        jumps++;\\n    }\\n\\n    return -1\\n};\\n```\n```python []\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = deque()\\n        seen = set()\\n        banned = set(forbidden)\\n\\n        jumps = 0\\n        queue.append((0, True))\\n        max_position = a + b + max(x, max(forbidden))\\n\\n        while queue:\\n            size = len(queue)\\n\\n            for _ in range(size):\\n                cur, can_go_backward = queue.popleft()\\n\\n                if cur == x:\\n                    return jumps\\n                \\n                forward = (cur + a, True)\\n                backward = (cur - b, False)\\n\\n                if forward[0] not in banned and forward[0] <= max_position and forward not in seen:\\n                    queue.append(forward)\\n                    seen.add(forward)\\n\\n                if can_go_backward and backward[0] not in banned and backward[0] >= 0 and backward not in seen:\\n                    queue.append(backward)\\n                    seen.add(backward)\\n                \\n            jumps += 1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004958,
                "title": "java-simple-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n         int steps = 0, furthest = x + a + b;\\n        Queue<Pair<Integer, Integer>> q = new LinkedList();\\n        q.offer(new Pair(0, 0));\\n        Set<Pair<Integer, Integer>> set= new HashSet<>(q);\\n        for (int cur : forbidden) {\\n            set.add(new Pair(0, cur));\\n            set.add(new Pair(1, cur));\\n            furthest = Math.max(furthest, cur + a + b);\\n        }\\n        while (!q.isEmpty()) {\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                Pair<Integer, Integer> p = q.poll();\\n                int dir = p.getKey(), cur = p.getValue();\\n                if (cur == x) {\\n                    return steps;\\n                }\\n                Pair<Integer, Integer> forward = new Pair<>(0, cur+ a), backward = new Pair<>(1, cur- b);\\n                if (cur + a <= furthest && set.add(forward)) {\\n                    q.offer(forward);\\n                }\\n                if (dir == 0 && cur - b >= 0 && set.add(backward)) {\\n                    q.offer(backward);\\n                }\\n            }\\n            ++steps;\\n        }\\n        return -1;                \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n         int steps = 0, furthest = x + a + b;\\n        Queue<Pair<Integer, Integer>> q = new LinkedList();\\n        q.offer(new Pair(0, 0));\\n        Set<Pair<Integer, Integer>> set= new HashSet<>(q);\\n        for (int cur : forbidden) {\\n            set.add(new Pair(0, cur));\\n            set.add(new Pair(1, cur));\\n            furthest = Math.max(furthest, cur + a + b);\\n        }\\n        while (!q.isEmpty()) {\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                Pair<Integer, Integer> p = q.poll();\\n                int dir = p.getKey(), cur = p.getValue();\\n                if (cur == x) {\\n                    return steps;\\n                }\\n                Pair<Integer, Integer> forward = new Pair<>(0, cur+ a), backward = new Pair<>(1, cur- b);\\n                if (cur + a <= furthest && set.add(forward)) {\\n                    q.offer(forward);\\n                }\\n                if (dir == 0 && cur - b >= 0 && set.add(backward)) {\\n                    q.offer(backward);\\n                }\\n            }\\n            ++steps;\\n        }\\n        return -1;                \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000642,
                "title": "c-implementation-using-dynamic-programing",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[10001][3];\\n    int f(int i,int a,int b,int x,set<int> &st,int occ){\\n        // cout<<i<<\" \"<<x<<endl;\\n        if(st.find(i)!=st.end()){\\n            return 1e9;\\n        }\\n        if(i>10000){\\n            return 1e9;\\n        }\\n        if(i<0){\\n            return 1e9;\\n        }\\n       \\n        if(i==x){\\n          return 0;  \\n        }\\n        \\n        \\n        if(dp[i][occ]!=-1){\\n            return dp[i][occ];\\n        }\\n        \\n        st.insert(i);\\n        int ans=1e9;\\n        if(occ<=1){\\n            \\n        ans=min(ans,1+min(f(i+a,a,b,x,st,1),f(i-b,a,b,x,st,2)));\\n        }\\n        else{\\n            ans=1+min(ans,f(i+a,a,b,x,st,1));\\n        }\\n        st.erase(i);\\n        return dp[i][occ]=ans;\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<int>st;\\n        // if((abs(a-b)+x)%x!=0 && x%a!=0){\\n        //     return -1;\\n        // }       \\n        memset(dp,-1,sizeof(dp));\\n        for(auto c:forbidden){\\n            st.insert(c);\\n        }   \\n        \\n        int res=f(0,a,b,x,st,2);\\n        return res>=1e9?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10001][3];\\n    int f(int i,int a,int b,int x,set<int> &st,int occ){\\n        // cout<<i<<\" \"<<x<<endl;\\n        if(st.find(i)!=st.end()){\\n            return 1e9;\\n        }\\n        if(i>10000){\\n            return 1e9;\\n        }\\n        if(i<0){\\n            return 1e9;\\n        }\\n       \\n        if(i==x){\\n          return 0;  \\n        }\\n        \\n        \\n        if(dp[i][occ]!=-1){\\n            return dp[i][occ];\\n        }\\n        \\n        st.insert(i);\\n        int ans=1e9;\\n        if(occ<=1){\\n            \\n        ans=min(ans,1+min(f(i+a,a,b,x,st,1),f(i-b,a,b,x,st,2)));\\n        }\\n        else{\\n            ans=1+min(ans,f(i+a,a,b,x,st,1));\\n        }\\n        st.erase(i);\\n        return dp[i][occ]=ans;\\n    }\\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\\n        set<int>st;\\n        // if((abs(a-b)+x)%x!=0 && x%a!=0){\\n        //     return -1;\\n        // }       \\n        memset(dp,-1,sizeof(dp));\\n        for(auto c:forbidden){\\n            st.insert(c);\\n        }   \\n        \\n        int res=f(0,a,b,x,st,2);\\n        return res>=1e9?-1:res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3983359,
                "title": "python-boundary-intuition-not-formal-explained",
                "content": "# Intuition\\nIdea is that at each position we have two choices to make: move back or move forward. It is intuitive that to get the fewest number of jumps we can use a BFS exploration.\\n\\nThe more difficult part is how to bound the states: it is possible we might come up with way too many states that have no purpose.\\n\\nThe idea behind the boundary is this: we make an alternative formulation where we want to find a **pos** where there exists a path from **pos** to 0 and **pos** to x (and **pos** is not 0 or x). What is the range of values this starting **pos** can have?\\n\\nx is within 0-2000. Since b is also 0-2000, in order to land on x, we must necessarily pass through some set of nodes between 0-4000 (since we can leap back only 2000 at a time, we can not skip from 4001 to 2000 for example). \\n\\nThis implies that once we have checked states 0-4000, we can determine whether it is possible to reach x and 0 (because if we can\\'t within 0-4000, we can\\'t starting from 4001-infinity either). To check all 4000 states, we again use similar logic: to reach 0-4000, we must have **pos** be within 0-6000. If we can\\'t get to a desired state in 0-4000 from within 0-6000, then we definitely can\\'t do it starting from 6001-infinity, since you\\'ll for sure pass through 4000-6000 with a pos starting outside of 6000. \\n\\nThis means our maximum boundary is roughly 6000 in order to check all 4000 states, which then tells us whether we succeed.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = [0]\\n        dp = defaultdict(lambda: float(\\'inf\\'))\\n        dp[0] = 0\\n        seen = set()\\n        while queue:\\n            pos = queue.pop(0)\\n            if pos == x:\\n                return dp[pos]\\n            if pos - b == x and (pos-b) not in forbidden:\\n                return dp[pos]+1\\n            seen.add(pos)\\n            p1, p2 = pos+a, max(0,pos+a-b)\\n            if p1 not in seen and p1 < 6000 and p1 not in forbidden:\\n                seen.add(p1)\\n                queue.append(p1)\\n                dp[p1] = min(dp[p1], dp[pos]+1)\\n            if p2 not in seen and p2 < 6000 and p2 not in forbidden and (pos-b) not in forbidden and (pos-b) >= 0:\\n                seen.add(p2)\\n                queue.append(p2)\\n                dp[p2] = min(dp[p2], dp[pos]+2)\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        queue = [0]\\n        dp = defaultdict(lambda: float(\\'inf\\'))\\n        dp[0] = 0\\n        seen = set()\\n        while queue:\\n            pos = queue.pop(0)\\n            if pos == x:\\n                return dp[pos]\\n            if pos - b == x and (pos-b) not in forbidden:\\n                return dp[pos]+1\\n            seen.add(pos)\\n            p1, p2 = pos+a, max(0,pos+a-b)\\n            if p1 not in seen and p1 < 6000 and p1 not in forbidden:\\n                seen.add(p1)\\n                queue.append(p1)\\n                dp[p1] = min(dp[p1], dp[pos]+1)\\n            if p2 not in seen and p2 < 6000 and p2 not in forbidden and (pos-b) not in forbidden and (pos-b) >= 0:\\n                seen.add(p2)\\n                queue.append(p2)\\n                dp[p2] = min(dp[p2], dp[pos]+2)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961863,
                "title": "ts-bfs-66ms",
                "content": "# Complexity\\n![image.png](https://assets.leetcode.com/users/images/33300e18-54d5-49a9-b1f0-3705d91c37d2_1693037351.0296571.png)\\n\\n\\n# Code\\n```\\nfunction minimumJumps(forbidden: number[], a: number, b: number, x: number): number{\\n    // for tracking(column -> 0: forward / 1: backward)\\n    const check = Array.from({length:2}, () => new Array(10001).fill(0));\\n\\n    // check forbidden spot\\n    for(const danger of forbidden){\\n        check[1][danger] = 1;\\n        check[0][danger] = 1;\\n    }\\n\\n    // check start point(0)\\n    check[1][0] = 1;\\n    check[0][0] = 1;\\n    const queue =[[0,0]];\\n\\n    let answer = -1;\\n    let level = 0;\\n    while(queue.length) {\\n        const len = queue.length;\\n        for(let i = 0; i < len; i++) {\\n            const now = queue.shift();\\n            const dir = now[0];\\n            const move = now[1];\\n\\n            if(move === x) return level;\\n            if(move + a < 2000+a+b && check[0][move+a] === 0) {\\n                check[0][move+a] = 1;\\n                queue.push([0, move+a]);\\n            }\\n            if(move-b >= 0 && dir === 0 && check[1][move-b] === 0) {\\n                check[1][move-b] = 1;\\n                queue.push([1, move-b]);\\n            } \\n        }\\n        level++;\\n    }\\n\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunction minimumJumps(forbidden: number[], a: number, b: number, x: number): number{\\n    // for tracking(column -> 0: forward / 1: backward)\\n    const check = Array.from({length:2}, () => new Array(10001).fill(0));\\n\\n    // check forbidden spot\\n    for(const danger of forbidden){\\n        check[1][danger] = 1;\\n        check[0][danger] = 1;\\n    }\\n\\n    // check start point(0)\\n    check[1][0] = 1;\\n    check[0][0] = 1;\\n    const queue =[[0,0]];\\n\\n    let answer = -1;\\n    let level = 0;\\n    while(queue.length) {\\n        const len = queue.length;\\n        for(let i = 0; i < len; i++) {\\n            const now = queue.shift();\\n            const dir = now[0];\\n            const move = now[1];\\n\\n            if(move === x) return level;\\n            if(move + a < 2000+a+b && check[0][move+a] === 0) {\\n                check[0][move+a] = 1;\\n                queue.push([0, move+a]);\\n            }\\n            if(move-b >= 0 && dir === 0 && check[1][move-b] === 0) {\\n                check[1][move-b] = 1;\\n                queue.push([1, move-b]);\\n            } \\n        }\\n        level++;\\n    }\\n\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938854,
                "title": "easy-solution-java-bfs-beats-89",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    class Jump {\\n        public int value;\\n        public boolean canJump;\\n        public Jump(int value, boolean canJump) {\\n            this.value = value;\\n            this.canJump = canJump;\\n        }\\n\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<Jump> queue = new LinkedList<>();\\n        Set<Integer> seen = new HashSet<>();\\n        for (int forbid: forbidden) {\\n            seen.add(forbid);\\n        }\\n        if (seen.contains(0))\\n            return -1;\\n        if (x==0) {\\n            return 0;\\n        }\\n        queue.add(new Jump(0, true));\\n        seen.add(0);\\n\\n        int noOfJumps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for (int i =0; i<size; i++) {\\n                Jump currJump = queue.poll();\\n                int forward = currJump.value + a; \\n                int backward = currJump.value - b; \\n                if (currJump.value == x)\\n                    return noOfJumps;\\n                \\n                if (backward > 0 && currJump.canJump && !seen.contains(backward)) {\\n                    queue.add(new Jump(backward, false));\\n                    seen.add(backward);\\n                }\\n                \\n                if (forward < (2000 + 2 * b + 1) && !seen.contains(forward)) {\\n                    queue.add(new Jump(forward, true));\\n                    seen.add(forward);\\n                }\\n\\n            }\\n            noOfJumps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    class Jump {\\n        public int value;\\n        public boolean canJump;\\n        public Jump(int value, boolean canJump) {\\n            this.value = value;\\n            this.canJump = canJump;\\n        }\\n\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        Queue<Jump> queue = new LinkedList<>();\\n        Set<Integer> seen = new HashSet<>();\\n        for (int forbid: forbidden) {\\n            seen.add(forbid);\\n        }\\n        if (seen.contains(0))\\n            return -1;\\n        if (x==0) {\\n            return 0;\\n        }\\n        queue.add(new Jump(0, true));\\n        seen.add(0);\\n\\n        int noOfJumps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for (int i =0; i<size; i++) {\\n                Jump currJump = queue.poll();\\n                int forward = currJump.value + a; \\n                int backward = currJump.value - b; \\n                if (currJump.value == x)\\n                    return noOfJumps;\\n                \\n                if (backward > 0 && currJump.canJump && !seen.contains(backward)) {\\n                    queue.add(new Jump(backward, false));\\n                    seen.add(backward);\\n                }\\n                \\n                if (forward < (2000 + 2 * b + 1) && !seen.contains(forward)) {\\n                    queue.add(new Jump(forward, true));\\n                    seen.add(forward);\\n                }\\n\\n            }\\n            noOfJumps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933386,
                "title": "full-detailed-commented-solution-in-easy-words-bfs-beats-98-easy-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\n    //Pair class which will have the position and the direction\\n    class Pair\\n    {\\n         /* NOTE : Direction is boolean so : true -> traveling forward & false -> traveling backward*/\\n        int position;\\n        boolean direction;\\n        public Pair(int position, boolean direction)\\n        {\\n            this.position = position;\\n            this.direction = direction;\\n        }\\n\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n       \\n        //The total limit till where can go\\n        int limit = 2000 + 2 * b +1;\\n       \\n        //Visited Array to mark the forbidden nodes as well as the nodes which already visited\\n        boolean[] visited = new boolean[limit];\\n       \\n        //Marking all the forbidden values true so that whenever we will encounter these values we can skip.\\n        for(int n : forbidden)\\n        {\\n            visited[n] = true;\\n        }\\n        //We have to return minuimum steps this will keep the count\\n        int step = 0;\\n\\n        //Queue of type Pai.\\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        //Initially we will start from 0th position\\n        queue.add(new Pair(0,false));\\n        \\n        //Mark 0th postion visited \\n        visited[0] = true;\\n\\n        //Formal BFS Loop\\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            //Looping through the queue. \\n            for(int i = 0; i < size; i++)\\n            {\\n                //Removing the top element from the queue\\n                Pair p = queue.poll();\\n                \\n                //Extracting the position and the direction of the top most element of the queue.\\n                int position = p.position;\\n                boolean direction = p.direction;\\n                \\n                //Checking if the current position is equal to our destination if it is then return the steps \\n                if(position == x)\\n                    return step;\\n                \\n                //If Direction is false i.e. if we are moving in backward direction \\n                if(direction == false)\\n                {\\n                    // Get the backward location by subtracting current position from b\\n                    int moveBackward = position - b;\\n\\n                    //If backward value is greater than 0 and not visited then add it into the queue and \\n                    //mark it visited.\\n                    if(moveBackward > 0 && !visited[moveBackward])\\n                    {\\n                        queue.offer(new Pair(moveBackward,true));\\n                        visited[moveBackward] = true;\\n                    }\\n                }\\n               \\n                //If neither of the condition is true then that it means we are moving forward.\\n                //Get the next forward postion by adding a into current position \\n                int moveForward = position + a;\\n               \\n                //Check if moveForward value is less than the limit and not visited. If it is not \\n                //Then add this value into the queue and mark it as visited.\\n                if(moveForward < limit && !visited[moveForward])\\n                {\\n                    queue.offer(new Pair(moveForward,false));\\n                    visited[moveForward] = true;\\n                }\\n                \\n             }\\n             //Increment the step after looping the queue.\\n             step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //Pair class which will have the position and the direction\\n    class Pair\\n    {\\n         /* NOTE : Direction is boolean so : true -> traveling forward & false -> traveling backward*/\\n        int position;\\n        boolean direction;\\n        public Pair(int position, boolean direction)\\n        {\\n            this.position = position;\\n            this.direction = direction;\\n        }\\n\\n    }\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n       \\n        //The total limit till where can go\\n        int limit = 2000 + 2 * b +1;\\n       \\n        //Visited Array to mark the forbidden nodes as well as the nodes which already visited\\n        boolean[] visited = new boolean[limit];\\n       \\n        //Marking all the forbidden values true so that whenever we will encounter these values we can skip.\\n        for(int n : forbidden)\\n        {\\n            visited[n] = true;\\n        }\\n        //We have to return minuimum steps this will keep the count\\n        int step = 0;\\n\\n        //Queue of type Pai.\\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        //Initially we will start from 0th position\\n        queue.add(new Pair(0,false));\\n        \\n        //Mark 0th postion visited \\n        visited[0] = true;\\n\\n        //Formal BFS Loop\\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            //Looping through the queue. \\n            for(int i = 0; i < size; i++)\\n            {\\n                //Removing the top element from the queue\\n                Pair p = queue.poll();\\n                \\n                //Extracting the position and the direction of the top most element of the queue.\\n                int position = p.position;\\n                boolean direction = p.direction;\\n                \\n                //Checking if the current position is equal to our destination if it is then return the steps \\n                if(position == x)\\n                    return step;\\n                \\n                //If Direction is false i.e. if we are moving in backward direction \\n                if(direction == false)\\n                {\\n                    // Get the backward location by subtracting current position from b\\n                    int moveBackward = position - b;\\n\\n                    //If backward value is greater than 0 and not visited then add it into the queue and \\n                    //mark it visited.\\n                    if(moveBackward > 0 && !visited[moveBackward])\\n                    {\\n                        queue.offer(new Pair(moveBackward,true));\\n                        visited[moveBackward] = true;\\n                    }\\n                }\\n               \\n                //If neither of the condition is true then that it means we are moving forward.\\n                //Get the next forward postion by adding a into current position \\n                int moveForward = position + a;\\n               \\n                //Check if moveForward value is less than the limit and not visited. If it is not \\n                //Then add this value into the queue and mark it as visited.\\n                if(moveForward < limit && !visited[moveForward])\\n                {\\n                    queue.offer(new Pair(moveForward,false));\\n                    visited[moveForward] = true;\\n                }\\n                \\n             }\\n             //Increment the step after looping the queue.\\n             step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787228,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x==0:return 0\\n        queue=deque()\\n        queue.append([0,False])\\n        idx=0\\n        maxstop=a+b+max(x,max(forbidden))\\n        seen=set(forbidden)\\n        while queue:\\n            size=len(queue)\\n            idx+=1\\n            # print(\"test: \",queue)\\n            while size>0:\\n                node,forward = queue.popleft()\\n                size-=1\\n                if node in seen:continue\\n                seen.add(node)\\n\\n                if forward and node-b>=0:\\n                    if node-b==x:return idx    \\n                    queue.append([node-b,False])\\n                \\n                if node+a==x:return idx\\n                elif node+a<=maxstop:\\n                    queue.append([node+a,True])\\n                \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\\n        if x==0:return 0\\n        queue=deque()\\n        queue.append([0,False])\\n        idx=0\\n        maxstop=a+b+max(x,max(forbidden))\\n        seen=set(forbidden)\\n        while queue:\\n            size=len(queue)\\n            idx+=1\\n            # print(\"test: \",queue)\\n            while size>0:\\n                node,forward = queue.popleft()\\n                size-=1\\n                if node in seen:continue\\n                seen.add(node)\\n\\n                if forward and node-b>=0:\\n                    if node-b==x:return idx    \\n                    queue.append([node-b,False])\\n                \\n                if node+a==x:return idx\\n                elif node+a<=maxstop:\\n                    queue.append([node+a,True])\\n                \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773845,
                "title": "my-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The first solution is confusing as it uses a set to mark the visited sequence. The pair class have methods to help the set to remove the duplicates from it.\\n-  The second solution is quiet efficient as it only uses a boolean array to mark the visited combinations as a idx can be visited from backward and forward directions which is not unique.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution {\\n//     public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n//         if(x==0)return 0;\\n//         Set<Integer> set=new HashSet<>();\\n//         Set<Pair> v=new HashSet<>();\\n//         for(int f:forbidden){set.add(f);}\\n//         Queue<Pair> q=new LinkedList<>();\\n//         q.offer(new Pair(0,0,true));\\n//         v.add(new Pair(0,true));\\n        \\n//         while(!q.isEmpty()){\\n//             for(int i=q.size();i>0;i--)\\n//             {\\n//                 Pair p= q.poll();\\n//                 if(p.idx==x)return p.jumps;\\n//                 int f=p.idx+a;\\n//                 if(f<6000 && !set.contains(f)){\\n//                     Pair forw=new Pair(f,p.jumps+1,false);\\n//                     if(v.add(new Pair(f,false))) q.offer(forw);\\n//                 }\\n//                 if(p.flag)continue;\\n//                 int back=p.idx-b;\\n//                 if(!set.contains(back) && back>0){\\n//                     Pair backward=new Pair(back,p.jumps+1,true);\\n//                     if(v.add(new Pair(f,true)))q.offer(backward);\\n//                 }\\n//             }\\n//         }\\n//         return -1;\\n//     }\\n// }\\n// class Pair{\\n//     int idx;\\n//     int jumps;\\n//     boolean flag;\\n//     Pair(int idx,int jumps,boolean flag)\\n//     {\\n//         this.idx=idx;\\n//         this.jumps=jumps;\\n//         this.flag=flag;\\n//     }\\n//     Pair(int idx,boolean flag){\\n//         this.idx=idx;\\n//         this.flag=flag;\\n//     }\\n//     public int hashCode() {\\n//         return Objects.hash(idx, flag);\\n//     }\\n//     public boolean equals(Object obj) {\\n//         if (this == obj) {\\n//             return true;\\n//         }\\n//         Pair other = (Pair) obj;\\n//         return idx == other.idx && flag == other.flag;\\n//     }\\n// }\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x == 0) return 0;\\n\\n        int max=0;\\n        for(int f:forbidden)max=Math.max(max,f);\\n        max=Math.max(max,x);\\n        boolean[][] visited = new boolean[max+a+b+1][2];\\n\\n        for (int f : forbidden) {\\n            visited[f][0] = true;\\n            visited[f][1] = true;\\n        }\\n\\n        Queue<Pair> q = new LinkedList<>();\\n        q.offer(new Pair(0, 0, true));\\n        visited[0][0] = true;\\n\\n        while (!q.isEmpty()) {\\n            Pair p = q.poll();\\n            if (p.idx == x) return p.jumps;\\n\\n            int f = p.idx + a;\\n            if (f <= max+a+b && !visited[f][0]) {\\n                Pair forw = new Pair(f, p.jumps + 1, false);\\n                visited[f][0] = true;\\n                q.offer(forw);\\n            }\\n\\n            if (p.flag) continue;\\n\\n            int back = p.idx - b;\\n            if (back > 0 && !visited[back][1]) {\\n                Pair backward = new Pair(back, p.jumps + 1, true);\\n                visited[back][1] = true;\\n                q.offer(backward);\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\nclass Pair {\\n    int idx;\\n    int jumps;\\n    boolean flag;\\n\\n    Pair(int idx, int jumps, boolean flag) {\\n        this.idx = idx;\\n        this.jumps = jumps;\\n        this.flag = flag;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// class Solution {\\n//     public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n//         if(x==0)return 0;\\n//         Set<Integer> set=new HashSet<>();\\n//         Set<Pair> v=new HashSet<>();\\n//         for(int f:forbidden){set.add(f);}\\n//         Queue<Pair> q=new LinkedList<>();\\n//         q.offer(new Pair(0,0,true));\\n//         v.add(new Pair(0,true));\\n        \\n//         while(!q.isEmpty()){\\n//             for(int i=q.size();i>0;i--)\\n//             {\\n//                 Pair p= q.poll();\\n//                 if(p.idx==x)return p.jumps;\\n//                 int f=p.idx+a;\\n//                 if(f<6000 && !set.contains(f)){\\n//                     Pair forw=new Pair(f,p.jumps+1,false);\\n//                     if(v.add(new Pair(f,false))) q.offer(forw);\\n//                 }\\n//                 if(p.flag)continue;\\n//                 int back=p.idx-b;\\n//                 if(!set.contains(back) && back>0){\\n//                     Pair backward=new Pair(back,p.jumps+1,true);\\n//                     if(v.add(new Pair(f,true)))q.offer(backward);\\n//                 }\\n//             }\\n//         }\\n//         return -1;\\n//     }\\n// }\\n// class Pair{\\n//     int idx;\\n//     int jumps;\\n//     boolean flag;\\n//     Pair(int idx,int jumps,boolean flag)\\n//     {\\n//         this.idx=idx;\\n//         this.jumps=jumps;\\n//         this.flag=flag;\\n//     }\\n//     Pair(int idx,boolean flag){\\n//         this.idx=idx;\\n//         this.flag=flag;\\n//     }\\n//     public int hashCode() {\\n//         return Objects.hash(idx, flag);\\n//     }\\n//     public boolean equals(Object obj) {\\n//         if (this == obj) {\\n//             return true;\\n//         }\\n//         Pair other = (Pair) obj;\\n//         return idx == other.idx && flag == other.flag;\\n//     }\\n// }\\n\\nclass Solution {\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if (x == 0) return 0;\\n\\n        int max=0;\\n        for(int f:forbidden)max=Math.max(max,f);\\n        max=Math.max(max,x);\\n        boolean[][] visited = new boolean[max+a+b+1][2];\\n\\n        for (int f : forbidden) {\\n            visited[f][0] = true;\\n            visited[f][1] = true;\\n        }\\n\\n        Queue<Pair> q = new LinkedList<>();\\n        q.offer(new Pair(0, 0, true));\\n        visited[0][0] = true;\\n\\n        while (!q.isEmpty()) {\\n            Pair p = q.poll();\\n            if (p.idx == x) return p.jumps;\\n\\n            int f = p.idx + a;\\n            if (f <= max+a+b && !visited[f][0]) {\\n                Pair forw = new Pair(f, p.jumps + 1, false);\\n                visited[f][0] = true;\\n                q.offer(forw);\\n            }\\n\\n            if (p.flag) continue;\\n\\n            int back = p.idx - b;\\n            if (back > 0 && !visited[back][1]) {\\n                Pair backward = new Pair(back, p.jumps + 1, true);\\n                visited[back][1] = true;\\n                q.offer(backward);\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\nclass Pair {\\n    int idx;\\n    int jumps;\\n    boolean flag;\\n\\n    Pair(int idx, int jumps, boolean flag) {\\n        this.idx = idx;\\n        this.jumps = jumps;\\n        this.flag = flag;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755172,
                "title": "java-bfs-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    class Pair {\\n        int first;\\n        int second;\\n        Pair(int first, int second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n    /** \\n    Logic:- BFS Traversing so minimum ka tension nhi h.\\n    visited set string type so that we are not visiting same node again with same forward or backward case, if we have visited\\n    it with forward then backward is allowed and vice versa.\\n    checking for both cases forward and backward.\\n    **/\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if(x == 0) return 0;\\n        Set<Integer> forbid = new HashSet<>();\\n        for(int n : forbidden) forbid.add(n);\\n\\n        Queue<Pair> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        int ans = 1;\\n        int farMost = 10000;\\n\\n        q.add(new Pair(0, 0));\\n        visited.add(0 + \" \" + 0);\\n\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                Pair curr = q.poll();\\n                // Forward a \\n                int next_a = curr.first + a;\\n                if(next_a == x) return ans;\\n                if(next_a >= 0 && next_a <= farMost && !forbid.contains(next_a) && visited.add(next_a + \" \" + 1)){\\n                    q.add(new Pair(next_a, 1));\\n                } \\n                // Backward b\\n                if(curr.second == 1){\\n                    int next_b = curr.first - b;\\n                    if(next_b == x) return ans;\\n                    if(next_b >= 0 && next_b <= farMost && !forbid.contains(next_b) && visited.add(next_b + \" \" + 0)){\\n                        q.add(new Pair(next_b, 0));\\n                    } \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int first;\\n        int second;\\n        Pair(int first, int second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n    /** \\n    Logic:- BFS Traversing so minimum ka tension nhi h.\\n    visited set string type so that we are not visiting same node again with same forward or backward case, if we have visited\\n    it with forward then backward is allowed and vice versa.\\n    checking for both cases forward and backward.\\n    **/\\n    public int minimumJumps(int[] forbidden, int a, int b, int x) {\\n        if(x == 0) return 0;\\n        Set<Integer> forbid = new HashSet<>();\\n        for(int n : forbidden) forbid.add(n);\\n\\n        Queue<Pair> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        int ans = 1;\\n        int farMost = 10000;\\n\\n        q.add(new Pair(0, 0));\\n        visited.add(0 + \" \" + 0);\\n\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                Pair curr = q.poll();\\n                // Forward a \\n                int next_a = curr.first + a;\\n                if(next_a == x) return ans;\\n                if(next_a >= 0 && next_a <= farMost && !forbid.contains(next_a) && visited.add(next_a + \" \" + 1)){\\n                    q.add(new Pair(next_a, 1));\\n                } \\n                // Backward b\\n                if(curr.second == 1){\\n                    int next_b = curr.first - b;\\n                    if(next_b == x) return ans;\\n                    if(next_b >= 0 && next_b <= farMost && !forbid.contains(next_b) && visited.add(next_b + \" \" + 0)){\\n                        q.add(new Pair(next_b, 0));\\n                    } \\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753701,
                "title": "my-solution",
                "content": "```\\n/**\\n * normally, it\\'s unnecessary for the bug to reach a position `p`\\n * which is greater than (`x` + `b`)\\n * the reason is as following,\\n * 1. if `a` >= `b`, the bug can never reach the sweet home from the\\n *    position `p`, because the bug can only go backward once, and\\n *    then it must go forward, so the bug can reach the following\\n *    positions,\\n *    `p` - `b`\\n *    `p` - `b` + `a`\\n *    `p` - `b` + `a` - `b`\\n *    `p` - `b` + `a` - `b` + `a`\\n *    ...\\n *    because `a` >= `b`, these positions are all greater than or equal\\n *    to the position (`p` - `b`), and `p` is greater than (`x` + `b`),\\n *    so these positions are all greater than `x`\\n * 2. if `a` < `b`,\\n *    assume that the bug can reach the sweet home from the position `p`,\\n *    and the position `p` is the first position which is greather than\\n *    (`x` + `b`)\\n *    the positions on the path home are as following,\\n *    `p` - `b`\\n *    `p` - `b` + `a`\\n *    `p` - `b` + `a` - `b`\\n *    ...\\n *    `x`\\n *    assume that the position just before the position `p` is `q`,\\n *    `q` should be less than or equal to (`x` + `b`)\\n *    `p` = `q` + `a`\\n *    the above positions become the following ones,\\n *    `q` + `a` - `b`\\n *    `q` + `a` - `b` + `a`\\n *    `q` + `a` - `b` + `a` - `b`\\n *    ...\\n *    `x`\\n *    when the bug reach the position `q`, it can choose to go backward\\n *    and then go forward, the following actions follow the same schema,\\n *    so the positions become as following\\n *    `q` - `b` + `a`\\n *    `q` - `b` + `a` + `a`\\n *    `q` - `b` + `a` - `b` + `a`\\n *    ...\\n *    `x`\\n *    the above positions are always less than `q`, and `q` is less than or\\n *    equal to (`x` + `b`), so the above positions are always less than the\\n *    position (`x` + `b`)\\n *    so the bug should never reach a position which is greater than\\n *    (`x` + `b`)\\n * assume that currently the bug reaches a position `p`,\\n * and `p` + `a` > `x` + `b`,\\n * the smart bug decides to go backward,\\n * so it reaches the position (`p` - `b`),\\n * unfortunately, the position (`p` - `b`) is one of the forbidden one,\\n * so it can only go forward from `p` to reach `p` + `a`,\\n * that is the position (`p` + `a`) should be valid for the bug to reach.\\n * if `p` is in the range [`f`, `f` + `b`], both inclusive, where `f` is\\n * the maximum forbidden one, it\\'s possible that the bug can only have one\\n * option, that is stepping forward to reach to position (`p` + `a`)\\n * so it\\'s possible that the bug will reach the position (`f` + `a` + `b`)\\n * so the most right position the bug can reach should be\\n * max(`f` + `a` + `b`, `x` + `b`)\\n */\\nclass Solution {\\n public:\\n  int minimumJumps(const vector<int> &forbidden, const int a, const int b, const int x) {\\n    using q_node_t = pair<int, int>;   // {the position, the direction}\\n    constexpr int n_directions = 2;\\n    constexpr uint8_t all_visited = (1 << n_directions) - 1;\\n    constexpr int to_left = 0;\\n    constexpr int to_right = 1;\\n    const int jumps[] = {a, -b};\\n    /**\\n     * `max_reach` stands for the most right position where the bug can reach\\n     */\\n    const int max_reach = max(*max_element(forbidden.begin(), forbidden.end()) + a + b, x + b);\\n    uint8_t visited[max_reach + 1];\\n    memset(visited, 0, sizeof(visited));\\n    for (const int forbidden_position : forbidden) {\\n      visited[forbidden_position] = all_visited;\\n    }\\n    queue<q_node_t> q;\\n    q.emplace(0, to_right);\\n    q.emplace(0, to_left);\\n    visited[0] = all_visited;\\n    int steps = -1;\\n    while (!q.empty()) {\\n      ++steps;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [p, d] = q.front();\\n        if (p == x) {\\n          return steps;\\n        }\\n        q.pop();\\n\\n        for (const int dump : jumps) {\\n          const int np = p + dump;\\n          const int nd = dump > 0 ? to_right : to_left;\\n          if (np < 0 || np > max_reach || (d == to_left && nd == to_left) || ((visited[np] >> nd) & 0b1) == 0b1) {\\n            continue;\\n          }\\n          q.emplace(np, nd);\\n          visited[np] |= 1 << nd;\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * normally, it\\'s unnecessary for the bug to reach a position `p`\\n * which is greater than (`x` + `b`)\\n * the reason is as following,\\n * 1. if `a` >= `b`, the bug can never reach the sweet home from the\\n *    position `p`, because the bug can only go backward once, and\\n *    then it must go forward, so the bug can reach the following\\n *    positions,\\n *    `p` - `b`\\n *    `p` - `b` + `a`\\n *    `p` - `b` + `a` - `b`\\n *    `p` - `b` + `a` - `b` + `a`\\n *    ...\\n *    because `a` >= `b`, these positions are all greater than or equal\\n *    to the position (`p` - `b`), and `p` is greater than (`x` + `b`),\\n *    so these positions are all greater than `x`\\n * 2. if `a` < `b`,\\n *    assume that the bug can reach the sweet home from the position `p`,\\n *    and the position `p` is the first position which is greather than\\n *    (`x` + `b`)\\n *    the positions on the path home are as following,\\n *    `p` - `b`\\n *    `p` - `b` + `a`\\n *    `p` - `b` + `a` - `b`\\n *    ...\\n *    `x`\\n *    assume that the position just before the position `p` is `q`,\\n *    `q` should be less than or equal to (`x` + `b`)\\n *    `p` = `q` + `a`\\n *    the above positions become the following ones,\\n *    `q` + `a` - `b`\\n *    `q` + `a` - `b` + `a`\\n *    `q` + `a` - `b` + `a` - `b`\\n *    ...\\n *    `x`\\n *    when the bug reach the position `q`, it can choose to go backward\\n *    and then go forward, the following actions follow the same schema,\\n *    so the positions become as following\\n *    `q` - `b` + `a`\\n *    `q` - `b` + `a` + `a`\\n *    `q` - `b` + `a` - `b` + `a`\\n *    ...\\n *    `x`\\n *    the above positions are always less than `q`, and `q` is less than or\\n *    equal to (`x` + `b`), so the above positions are always less than the\\n *    position (`x` + `b`)\\n *    so the bug should never reach a position which is greater than\\n *    (`x` + `b`)\\n * assume that currently the bug reaches a position `p`,\\n * and `p` + `a` > `x` + `b`,\\n * the smart bug decides to go backward,\\n * so it reaches the position (`p` - `b`),\\n * unfortunately, the position (`p` - `b`) is one of the forbidden one,\\n * so it can only go forward from `p` to reach `p` + `a`,\\n * that is the position (`p` + `a`) should be valid for the bug to reach.\\n * if `p` is in the range [`f`, `f` + `b`], both inclusive, where `f` is\\n * the maximum forbidden one, it\\'s possible that the bug can only have one\\n * option, that is stepping forward to reach to position (`p` + `a`)\\n * so it\\'s possible that the bug will reach the position (`f` + `a` + `b`)\\n * so the most right position the bug can reach should be\\n * max(`f` + `a` + `b`, `x` + `b`)\\n */\\nclass Solution {\\n public:\\n  int minimumJumps(const vector<int> &forbidden, const int a, const int b, const int x) {\\n    using q_node_t = pair<int, int>;   // {the position, the direction}\\n    constexpr int n_directions = 2;\\n    constexpr uint8_t all_visited = (1 << n_directions) - 1;\\n    constexpr int to_left = 0;\\n    constexpr int to_right = 1;\\n    const int jumps[] = {a, -b};\\n    /**\\n     * `max_reach` stands for the most right position where the bug can reach\\n     */\\n    const int max_reach = max(*max_element(forbidden.begin(), forbidden.end()) + a + b, x + b);\\n    uint8_t visited[max_reach + 1];\\n    memset(visited, 0, sizeof(visited));\\n    for (const int forbidden_position : forbidden) {\\n      visited[forbidden_position] = all_visited;\\n    }\\n    queue<q_node_t> q;\\n    q.emplace(0, to_right);\\n    q.emplace(0, to_left);\\n    visited[0] = all_visited;\\n    int steps = -1;\\n    while (!q.empty()) {\\n      ++steps;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [p, d] = q.front();\\n        if (p == x) {\\n          return steps;\\n        }\\n        q.pop();\\n\\n        for (const int dump : jumps) {\\n          const int np = p + dump;\\n          const int nd = dump > 0 ? to_right : to_left;\\n          if (np < 0 || np > max_reach || (d == to_left && nd == to_left) || ((visited[np] >> nd) & 0b1) == 0b1) {\\n            continue;\\n          }\\n          q.emplace(np, nd);\\n          visited[np] |= 1 << nd;\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565893,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1567108,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1568547,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1576996,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1568487,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1576559,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1570397,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1733309,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1575580,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1575670,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1565893,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1567108,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1568547,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1576996,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1568487,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1576559,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1570397,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1733309,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1575580,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            },
            {
                "id": 1575670,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "I am not totally convinced that `max(x, max(forbidden)) + a + b` is the inclusive upper-bound beyond which the search should not continue. Could someone who\\'s well versed in number theory provide a tight proof? I suspect something something to do with gcd(a, b) but sadly my math skills have all evaporated."
                    },
                    {
                        "username": "wangtan83",
                        "content": "Hi Leetcoders,\\nWhen traversing the next numbers (whether it\\'s BFS/DFS/DP), can anyone explain why the max boundry is  max(max(forbidden) + a + b, x + b)?\\nI get the x+b part, but not the max(forbidden) + a + b.\\n\\nThank you."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@jakrigel](/jakrigel) Thank you! One part I don\\'t get is why `MAX = x+a+b` is the furthest needed for `a<b`?"
                    },
                    {
                        "username": "jakrigel",
                        "content": "I think that the easiest way to think of this is to imagine a few situations.\\n\\nEasiest is `if a > b` then once the current value has exceeded the reach of `MAX = x + b` then you can never get back. Seems you have that part down.\\n\\nThe tricky situations start to happen when `if a < b`. In this situation you can start to use combinations of +a and -b where you have the net result to walk backwards through the number line regardless of the limit on how many times in a row you can go backwards. If you ignored forbidden, then the furthest you ever need to go to create the walk back effect is `MAX = x + a + b` anything beyond that would potentially still be valid work, but it is unnecessary.\\n\\nNow if you do factor in the forbidden and you have a forbidden value that is out beyond x, you now have to use +a and -b to dance around a forbidden value that is now trying really hard to get in the way. So now to exceed this new artificial problem its not enough to just look at `MAX = x + a + b`, you now how to go out beyond the biggest possible forbidden value `MAX = max(forbidden) + a + b` before you can reasonably assume you exhausted all options and we are wasting time."
                    },
                    {
                        "username": "jitsingh",
                        "content": "i am getting 921 for following testcase, try increasing the upper limit for your recursion.\\nIs anyone else getting the same?\\n\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "True.. Same happened with me.. Plus I do not get logic of max(forbidden) for upper limit.. if a<b then we can always move backward. Not sure How upper limit would be decided.. Though I guess we can always prune some branches with some logic of b-n*a but that seems tricky.."
                    },
                    {
                        "username": "diavollo",
                        "content": "Yes I have the same answer and I don\\'t understand why it should return -1. Can someone explain us ?"
                    },
                    {
                        "username": "galmungral",
                        "content": "### I. INTUITION: What the upper bound `max(x,max(forbidden))+b+a` means\\nOnce we are able to perform a backward jump (`-b`) in the the \"simple\" region `(max(x,max(forbidden)), infinity)`, we no longer need to jump forward (`+a`).\\n\\n### II. OBSERVATIONS\\n#### 1. Order does not matter\\nFirst, if we ignore the forbidden points, a path `p` only needs to satify the condition that displacement `d(p[0...N]) == m*a-n*b == target`. Give `m` and `n`, any permutation with no consecutive `-b` jumps forms a valid path. This is obviously not true if the path crosses `[min(forbidden), max(forbidden)]`, but we can just focus on the (potentially empty) subpath that lies within the \"simple\" region `(max(forbidden), infinity)` where this property still holds.\\n\\n#### 2. If you overshoot the target, you eventually need to jump back\\nConsider a path `p` that intersects `(x, infinity)`, then for any `p[i...N]` where `p[i] > x` we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`. To make things simpler, we can move the boundary further to`X := max(x, max(forbidden)) >= x` and consider a subpath `p[i...N]`  where `p[i] > X`. We still have `d(p[i...N]) == m*a-n*b == x-p[i] < 0`, but since we are now in the \"simple\" region, we can utilize the commutativity of jumps.\\n\\n#### 3. Paths that are too spread out can always be shrinked\\nThis is what we shall prove.\\n\\n### III. PROOF: Given a path that intersects  `(X+b+a, infinity)`, there exists a path of equal length that lies within `[0, X+b+a]`:\\n\\nConsider the **first** `p[i]` that intersects `(X+b+a, infinity)`:\\n* By definition `p[i]` can only be reached from `p[i-1]` in `(X+b, X+b+a]` by a `+a` jump. \\n* Similarly, because `b > a`, `p[i-1]` can only be reached from `p[i-2]` by a `+a` jump, otherwise `p[i-2] == p[i-1]+b > X+b+b > X+b+a`, a contradiction (`p[i]` is supposed to be the first). \\n* For subpath `p[i-1...N]`, we have `m*a-n*b == d(p[i-1...N]) == x-p[i-1] < x-(X+b) <= -b`. Reordering the terms, we get `n > 1`, i.e. there is at least one `-b` jump in `p[i-1...N]`. We can move the **first** `-b` jump  to the start of the jump sequence. \\n* By definition, the first `-b` jump starts at some `p[j] > p[i] > X+b+a` and ends at `p[j+1] == p[j]-b > X+a`. After the transformation, it would start at `p\\'[i-1] == p[i-1] > X+b` and end at `p\\'[i] == p\\'[i-1]-b > X` . That is, the reordering happens within the \"simple\" region.\\n* Finally, it can be shown that such rearrangement won\\'t result in consecutive `-b` jumps.\\n\\nSo from `p\\'[i-1]` in `(X+b, X+b+a]`, instead of jumping into `(X+b+a, infinity)`, we can always jump back first to `p\\'[i] == p\\'[i-1]-b` in `(X, X+a]`, and then jump forward to `p\\'[i+1] == p\\'[i]` in `(X+a, X+2*a]`. \\n\\nAfter reordering one pair of `+a` and `-b`, the number of jumps is unchanged, but the size of the subpath intersecting `(X+b+a, infinity)` is shrinked by 2. We can repeat this process until no point lies beyonds `X+b+a`.  \\n\\nQ.E.D.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I don't understand **point 2** of **Observation**, what does  \n>we have the displacement `d(p[i...N]) == m*a-n*b == x-p[i] < 0`\n\nmean?"
                    },
                    {
                        "username": "dima8_88",
                        "content": "In this test we have\\n\\nforbidden = [1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,\\n1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,\\n1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,\\n160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,\\n1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,\\n1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,\\n46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n\\na = 806\\nb = 1994\\nx = 326\\n\\nMy Output is 921\\nExpected: -1\\n\\nI have built this solution \\n[0, 806, 1612, 2418, 424, 1230, 2036, 2842, 3648, 1654, 2460, 3266, 1272, 2078, 84, 890, 1696, 2502, 508, 1314, 2120, 2926, 932, 1738, 2544, 3350, 4156, 2162, 2968, 974, 1780, 2586, 592, 1398, 2204, 210, 1016, 1822, 2628, 634, 1440, 2246, 3052, 3858, 4664, 2670, 3476, 1482, 2288, 3094, 3900, 4706, 2712, 3518, 1524, 2330, 3136, 3942, 4748, 2754, 3560, 4366, 2372, 3178, 3984, 4790, 2796, 3602, 1608, 2414, 3220, 4026, 2032, 2838, 3644, 4450, 2456, 3262, 1268, 2074, 2880, 3686, 1692, 2498, 3304, 1310, 2116, 122, 928, 1734, 2540, 3346, 4152, 2158, 2964, 970, 1776, 2582, 588, 1394, 2200, 206, 1012, 1818, 2624, 3430, 4236, 2242, 3048, 1054, 1860, 2666, 672, 1478, 2284, 290, 1096, 1902, 2708, 714, 1520, 2326, 3132, 3938, 4744, 2750, 3556, 1562, 2368, 374, 1180, 1986, 2792, 3598, 1604, 2410, 416, 1222, 2028, 2834, 3640, 4446, 2452, 3258, 4064, 2070, 2876, 3682, 4488, 2494, 3300, 1306, 2112, 2918, 3724, 4530, 2536, 3342, 1348, 2154, 2960, 3766, 1772, 2578, 3384, 4190, 2196, 3002, 1008, 1814, 2620, 3426, 1432, 2238, 3044, 1050, 1856, 2662, 3468, 1474, 2280, 3086, 3892, 1898, 2704, 710, 1516, 2322, 328, 1134, 1940, 2746, 3552, 1558, 2364, 3170, 3976, 4782, 2788, 3594, 1600, 2406, 3212, 1218, 2024, 2830, 3636, 4442, 2448, 3254, 1260, 2066, 72, 878, 1684, 2490, 496, 1302, 2108, 114, 920, 1726, 2532, 3338, 4144, 2150, 2956, 962, 1768, 2574, 580, 1386, 2192, 198, 1004, 1810, 2616, 622, 1428, 2234, 240, 1046, 1852, 2658, 664, 1470, 2276, 282, 1088, 1894, 2700, 706, 1512, 2318, 3124, 1130, 1936, 2742, 748, 1554, 2360, 3166, 3972, 4778, 2784, 3590, 4396, 2402, 3208, 4014, 2020, 2826, 832, 1638, 2444, 450, 1256, 2062, 68, 874, 1680, 2486, 3292, 4098, 2104, 2910, 916, 1722, 2528, 3334, 4140, 2146, 2952, 958, 1764, 2570, 3376, 4182, 2188, 2994, 3800, 4606, 2612, 3418, 1424, 2230, 3036, 3842, 1848, 2654, 660, 1466, 2272, 3078, 3884, 1890, 2696, 702, 1508, 2314, 320, 1126, 1932, 2738, 3544, 4350, 2356, 3162, 3968, 1974, 2780, 786, 1592, 2398, 404, 1210, 2016, 22, 828, 1634, 2440, 3246, 4052, 2058, 2864, 3670, 4476, 2482, 3288, 1294, 2100, 2906, 3712, 4518, 2524, 3330, 1336, 2142, 148, 954, 1760, 2566, 3372, 4178, 2184, 2990, 996, 1802, 2608, 3414, 1420, 2226, 232, 1038, 1844, 2650, 656, 1462, 2268, 274, 1080, 1886, 2692, 698, 1504, 2310, 3116, 1122, 1928, 2734, 740, 1546, 2352, 358, 1164, 1970, 2776, 782, 1588, 2394, 400, 1206, 2012, 2818, 824, 1630, 2436, 3242, 1248, 2054, 60, 866, 1672, 2478, 3284, 1290, 2096, 2902, 908, 1714, 2520, 3326, 1332, 2138, 144, 950, 1756, 2562, 568, 1374, 2180, 186, 992, 1798, 2604, 610, 1416, 2222, 228, 1034, 1840, 2646, 3452, 4258, 2264, 3070, 1076, 1882, 2688, 694, 1500, 2306, 312, 1118, 1924, 2730, 3536, 4342, 2348, 3154, 3960, 4766, 2772, 3578, 1584, 2390, 396, 1202, 2008, 14, 820, 1626, 2432, 438, 1244, 2050, 56, 862, 1668, 2474, 3280, 1286, 2092, 98, 904, 1710, 2516, 522, 1328, 2134, 140, 946, 1752, 2558, 564, 1370, 2176, 182, 988, 1794, 2600, 3406, 1412, 2218, 224, 1030, 1836, 2642, 3448, 4254, 2260, 3066, 1072, 1878, 2684, 3490, 1496, 2302, 3108, 3914, 4720, 2726, 3532, 1538, 2344, 350, 1156, 1962, 2768, 774, 1580, 2386, 3192, 3998, 2004, 2810, 3616, 4422, 2428, 3234, 1240, 2046, 52, 858, 1664, 2470, 3276, 4082, 2088, 2894, 3700, 1706, 2512, 518, 1324, 2130, 136, 942, 1748, 2554, 560, 1366, 2172, 2978, 3784, 4590, 2596, 3402, 4208, 2214, 3020, 1026, 1832, 2638, 3444, 4250, 2256, 3062, 3868, 4674, 2680, 3486, 1492, 2298, 304, 1110, 1916, 2722, 728, 1534, 2340, 346, 1152, 1958, 2764, 770, 1576, 2382, 388, 1194, 2000, 2806, 812, 1618, 2424, 430, 1236, 2042, 2848, 854, 1660, 2466, 472, 1278, 2084, 90, 896, 1702, 2508, 514, 1320, 2126, 2932, 3738, 4544, 2550, 3356, 1362, 2168, 2974, 980, 1786, 2592, 598, 1404, 2210, 3016, 3822, 4628, 2634, 3440, 1446, 2252, 3058, 1064, 1870, 2676, 682, 1488, 2294, 3100, 1106, 1912, 2718, 724, 1530, 2336, 3142, 3948, 1954, 2760, 766, 1572, 2378, 3184, 3990, 1996, 2802, 808, 1614, 2420, 3226, 4032, 2038, 2844, 850, 1656, 2462, 3268, 4074, 2080, 2886, 3692, 4498, 2504, 3310, 1316, 2122, 128, 934, 1740, 2546, 3352, 1358, 2164, 2970, 3776, 1782, 2588, 594, 1400, 2206, 212, 1018, 1824, 2630, 636, 1442, 2248, 254, 1060, 1866, 2672, 678, 1484, 2290, 3096, 3902, 4708, 2714, 3520, 1526, 2332, 3138, 1144, 1950, 2756, 3562, 4368, 2374, 3180, 1186, 1992, 2798, 804, 1610, 2416, 3222, 1228, 2034, 40, 846, 1652, 2458, 3264, 4070, 2076, 2882, 3688, 1694, 2500, 506, 1312, 2118, 124, 930, 1736, 2542, 548, 1354, 2160, 2966, 3772, 4578, 2584, 3390, 1396, 2202, 3008, 3814, 1820, 2626, 3432, 4238, 2244, 3050, 1056, 1862, 2668, 674, 1480, 2286, 292, 1098, 1904, 2710, 716, 1522, 2328, 334, 1140, 1946, 2752, 758, 1564, 2370, 3176, 3982, 4788, 2794, 3600, 1606, 2412, 418, 1224, 2030, 2836, 3642, 4448, 2454, 3260, 1266, 2072, 78, 884, 1690, 2496, 502, 1308, 2114, 2920, 3726, 4532, 2538, 3344, 1350, 2156, 2962, 3768, 1774, 2580, 586, 1392, 2198, 3004, 3810, 1816, 2622, 628, 1434, 2240, 246, 1052, 1858, 2664, 3470, 4276, 2282, 3088, 1094, 1900, 2706, 712, 1518, 2324, 3130, 3936, 4742, 2748, 3554, 1560, 2366, 3172, 3978, 1984, 2790, 3596, 1602, 2408, 3214, 1220, 2026, 32, 838, 1644, 2450, 456, 1262, 2068, 2874, 880, 1686, 2492, 3298, 4104, 2110, 2916, 3722, 1728, 2534, 540, 1346, 2152, 158, 964, 1770, 2576, 3382, 4188, 2194, 3000, 3806, 1812, 2618, 3424, 1430, 2236, 242, 1048, 1854, 2660, 666, 1472, 2278, 284, 1090, 1896, 2702, 3508, 4314, 2320]\\n\\nWhy is it not true? Each of the values in this solution is not in forbidden. No double jumps either. Please, help?"
                    },
                    {
                        "username": "ntoskrnl",
                        "content": "TL;DR: To avoid TLE the upper bound for position should be `6000`. For all positions higher than that \\u2013 there is no way back.\\n\\nWhen I fisrst saw this task, I was surprised that it has such a low acceptance rate. After I attempted to solve it, I know why. People get rejected with TLE.\\n\\nI have approached this using BFS with keeping `state(position, canJumpBack)`. But I was getting TLE.\\nIt was obvious that the problem was due to position getting too large. I initially set the upper bound to a * x, but for the problem constraints it will be 4 000 000. This caused TLE on test cases where the is no solution.\\n\\nI had to reduce the upper bound by randomly until solution was accepted... But I coudn\\'t understand how this bound appear. I saw people here used 6000 as upper bound... This upper limit also works: `2000 + a + b` . That\\'s why 6000. Or maybe this limit comes from the fact that `x` in `[0..2000]` and max difference between `a` and `b` is `4000`?..."
                    },
                    {
                        "username": "jjz",
                        "content": "Here is the test case\\n[1906,1988,1693,483,900,1173,805,1593,1208,1084,300,614,1325,783,1104,1450,311,1506,1388,1567,1497,47,102,338,1937,888,111,195,1041,1570,686,1707,1521,1566,74,1264,667,1486,960,389,442,329,1577,1557,1494,1382,1688,779,484,410,227,1025,1417,1475,1042,1903,1920,1712,870,1813,1137,1732,18,1065,1653,1289,1636,147,1833,1168,1087,1408,881,1129,71,924,1718,1458,371,597,1790,889,414,784,1883,6,1650,1549,552,1233,1467,1514,1568,211,1301,772,377,1751,1699,1701,1214,1874,324,1991,1006,1413,41,289,1274,802,1892,1908,1960,1635,69,423,1795,96,1024,1596,1044,1513,1390,711,1806,1298,968,1160,1232,1315,1646,1178,169,1295,466,44,10,1250,1283,927,49,267,1773,342,1828,1949,1291,244,707,408,798,938,1542,690,639,1148,1081,431,752,120,1125,339,480,247,733,266,596,987,777,214,1005,1687,160,785,1010,1282,1135,922,671,1221,250,1982,398,1959,179,325,1313,577,1053,1436,185,1014,1851,1685,1143,1510,1972,830,681,390,972,1003,844,229,1246,1257,668,1765,619,276,1355,1544,1842,1340,1375,1944,790,606,345,1487,796,1985,1673,1503,180,1642,498,1805,201,104,1658,1633,1507,1142,541,865,1193,485,216,1849,359,1422,391,856,1864,470,1888,1698,760,1778,572,1057,48,189,1086,1704,1258,192,825,585,152,1865,1645,807,225,402,1198,1476,600,1914,975,1378,1190,24,1550,723,696,1131,1831,1880,1029,713,486,126,876,1270,1891,544,61,1356,1676,1239,36,1177,620,1723,1651,1136,141,1889,1123,624,1519,725,241,1253,1119,269,763,1120,1620,642,1713,966,1204,558,1344,550,316,412,886,1309,1648,599,1893,265,258,1561,477,1967,66,1296,75,1628,715,826,1942,1966,1407,159,646,1438,1730,768,411,287,499,467,46,302,661,526,848,1327,1097,166,413,1578,574,1304,925,504,914,978,1352,1103,1859,1167,1318,1454,1990,739,1252,132,529,1622,422,1744,1819,425,945,1767,1791,976,1226,1092,305,479,174,626,1063,662,1948,1978,524,512,1255,651,1678,1059]\\n806\\n1994\\n326\\n\\nIf you remove any boundary restrictions on BFS, you will be guarnateed to get the right answer if there exists a way to reach the home. The answer should be 921, not -1. No integer overflow detected. So I think any posted algorithms are wrong it they passed this test."
                    },
                    {
                        "username": "Puppy_Yu",
                        "content": "I got questions on this test case:\\n\\nforbidden =[8,3,16,6,12,20]\\na =15\\nb =13\\nx =11\\nOutput\\n25\\nExpected\\n-1\\n\\n15 * 12 - 13 * 13 = 11, 12+13=25 is the total steps\\nWhy does the test case expect result -1?\\nCan someone explain this? thank you!\\n\\n"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "It cannot jump backward twice in a row."
                    },
                    {
                        "username": "dkmar",
                        "content": "same question here\n\nEDIT: we both lack reading comprehension smh.\n> It cannot jump backward twice in a row."
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I have been trying to understand why we need to store 2 states for the visited array, since it should\\'nt matter from which direction you have visited a particular index once visited, you should\\'nt come to that index again.\\n\\ncan someone explain?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Its because you cannot travel backwards twice in a row"
                    },
                    {
                        "username": "zdi561",
                        "content": "[14,4,18,1,15]\\n3\\n15\\npassed in IDE but failed by evaluator"
                    }
                ]
            }
        ]
    },
    {
        "title": "Distribute Repeating Integers",
        "question_content": "<p>You are given an array of <code>n</code> integers, <code>nums</code>, where there are at most <code>50</code> unique values in the array. You are also given an array of <code>m</code> customer order quantities, <code>quantity</code>, where <code>quantity[i]</code> is the amount of integers the <code>i<sup>th</sup></code> customer ordered. Determine if it is possible to distribute <code>nums</code> such that:</p>\n\n<ul>\n\t<li>The <code>i<sup>th</sup></code> customer gets <strong>exactly</strong> <code>quantity[i]</code> integers,</li>\n\t<li>The integers the <code>i<sup>th</sup></code> customer gets are <strong>all equal</strong>, and</li>\n\t<li>Every customer is satisfied.</li>\n</ul>\n\n<p>Return <code>true</code><em> if it is possible to distribute </em><code>nums</code><em> according to the above conditions</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4], quantity = [2]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The 0<sup>th</sup> customer cannot be given two different integers.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,3], quantity = [2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The 0<sup>th</sup> customer is given [3,3]. The integers [1,2] are not used.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,2,2], quantity = [2,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The 0<sup>th</sup> customer is given [1,1], and the 1st customer is given [2,2].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>m == quantity.length</code></li>\n\t<li><code>1 &lt;= m &lt;= 10</code></li>\n\t<li><code>1 &lt;= quantity[i] &lt;= 10<sup>5</sup></code></li>\n\t<li>There are at most <code>50</code> unique values in <code>nums</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 935522,
                "title": "step-by-step-optimization-more-than-10-methods",
                "content": "> This is a very long post.\\n> I\\'ve been thinking about this problem for many days, trying to optimize it.\\n> This post shows step by step how I managed to reach the optimised methods.\\n> But I feel this is not yet the end. If one day I find a better solution, I will come back and update this post.\\n> Hope it helps. :)\\n\\n# Transformation\\n\\nFirst of all, the problem description is kind of... weird. Distributing n repeating numbers to m customers? That is a bit difficult to imagine and understand (at least for me).\\n\\nHowever, let\\'s do a simple \"transformation\", it will immediately become much clearer:\\n- In any case, the first thing we have to do, is ***counting the frequency of each number*** in `nums`. We don\\'t care about what the numbers are, but only the quantity.\\n- For any number, if the quantity of it is >= a customer\\'s order, we can distribute the number to that customer. And of course if the rest quantity of this number can satisfy any other customer\\'s order, we can continue distributing it.\\n\\t- For example, if we have *10* of number `a`, and we have customer orders *5*, *3*, and *1*, we can satisfy all 3 customers by number `a`.\\n- We want to figure out if we can satisfy all customers.\\n\\nNow the problem can be transformed to:\\n\\n> **We have N _containers/boxes/slots_, and we want to fit M _items/objects/sticks_ into them. Or, we want to allocate M chunks of _memory blocks/file spaces_ from fragmented _memory/hard drive_, which have N _continuous free spaces_.**\\n\\nMuch easier to imagine now, isn\\'t it? Code for the transformation would like:\\n\\n```cpp\\nbool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n\\tunordered_map<int, int> fm;\\n\\tfor (int n : nums) ++fm[n];\\n\\tvector<int> counts;\\n\\tfor (auto [ignore, f] : fm) counts.push_back(f);\\n\\treturn CanAllFit(counts, quantity);\\n}\\n\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n    // ...\\n}\\n```\\n\\nFrom now on, I will be only talk about **fitting _ITEMS_ into _CONTAINERS_**, and show how to implement the `CanAllFit(contSize, itemSize)` function.\\n\\n----\\n\\n# Solutions\\n\\nTo solve this problem, there are basically two directions:\\n1. For each _item_, try to put it into any _container_ that has enough space.\\n2. For each _container_, try any _combination of item(s)_ that total size is <= the container size.\\n\\nNote: \\n\\n- There exist other methods, but I will mainly focus on **Backtracking**.\\n- The times in the brackets are only based on current testcases. It is totally possible that in the future more testcases are added and the numbers become inaccurate. Some methods may even become TLE, even if they are AC now.\\n\\n## For each item, try the containers\\n\\n#### Ver 1 - Straightforward backtracking (TLE)\\n\\nBasically try all possible combinations\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (int &szCont : contSize) {\\n\\t\\t\\tif (szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\tszCont -= szItem;\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\tszCont += szItem;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\\n\\n#### Ver 1.1 - Sort items by size in descending order (700+ms)\\n\\nVer 1 would go TLE for testcases like: \\n- container sizes: [2,2,2,...,2] (50 containers with all size of 2)\\n- item sizes: [2,2,2,...,2,3] (9 of size 2 and 1 of size 3)\\n\\nReason: it\\'s actually trying every single way to fit the first 9 2s into the 50 containers - for example, it tries to put item1 in container1, then container2, then container3... Even if that makes absolutely no difference. In the worst case, it would try 50<sup>10</sup> times before it can return false.\\n\\nOn the other side, we can notice that: if we start with the biggest item, **once we find a bigger item that cannot fit into any of the rest containers, it fails. We don\\'t need to care about any of the smaller ones**.\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>()); // sort in descending order\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (int &szCont : contSize) {\\n\\t\\t\\tif (szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\tszCont -= szItem;\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\tszCont += szItem;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\\n\\nNow some one may ask: what if we can fit all the bigger ones but only not the smallest one? Would it be in the same situation?\\nNo, it\\'s not the same. In the worst case, say, we can fit first 9 (bigger) items but only not the last one, we\\'ll have **at most** 9 bigger containers for these items, (if we have one more container that can fit any of the bigger item, it will definitely fit the smaller one) so we try at most 9<sup>9</sup> times. This is definitely not good enough (and we\\'ll continue optimise it later) but much better than Ver 1.\\n\\nNote:\\n> If a testcase results a `true`, the calculation is usually very fast (we find any solution and we are done). It\\'s those testcases require you to _try all the possibilities and eventually fail_ time consuming.\\n\\n#### Ver 1.2 - Data Preprocess (Pruning) (236ms)\\n\\nIn addition to sorting the item by size, we can do more preprocesses to make the calculation faster:\\n- Sort the items by size, as well as the containers\\n- If any container is smaller than the smallest item, it\\'s useless. Get rid of them.\\n- If a container can just fit the smallest item (same size), we should put the item in that container, and forget about them. Prove:\\n\\t- If we don\\'t put the smallest item in the container with same size, and there exists a solution, the container must be empty (since it cannot fit any bigger item), and we can always move the smallest item into that container and all other items still fit.\\n\\t- If we put the smallest into the container with same size and cannot fit all other items, put it in another container (leave the one with same size empty, since it can\\'t fit any bigger item) will only make less room. We still cannot fit all other items.\\n- If the smallest container left (bigger than the smallest item) can only fit one item (smaller than the sum of the two smallest items left), we find _the biggest item that fits it_ and put the item in it. Prove:\\n\\t- Say, the biggest item that smaller or the same to the smallest container `C` is `X`. If we don\\'t put X in C, and there exists a solution, then C is either empty or has _ONE_ smaller (than X) item in it, and X is in a bigger container. We can always move X into C (if empty) or swap X with the smaller item and still have a solution (return true).\\n\\t- Similar to above, if there\\'s no solution when putting X in C, moving/swapping X out of C will not make more room, and there\\'s still no solution.\\n- After the preprocess, if there\\'s no item left, we successfully fitted all items, return true.\\n- Otherwise if there\\'s no container left, no way to fit rest of the items, return false.\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (int &szCont : contSize) {\\n\\t\\t\\tif (szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\tszCont -= szItem;\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\tszCont += szItem;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0);\\n}\\n```\\n\\n#### Ver 1.3 - Grouping the container sizes (216ms)\\n\\nFrom Ver 1.1 we realised that we are doing a lot of duplicated calculations.\\nWe may be able to use dynamic programming (DP) to remember calculated subresults. However, there is a problem: if we put one item into a container, it\\'s still possible to fit other item(s) into that container. This makes applying DP trickier.\\n\\nBut don\\'t worry. There is a simpler method: (Inspired by the problem [[subsets II](https://leetcode.com/problems/subsets-ii/)])\\n- Group the containers by size\\n- We try to put an item in one container, if we failed to find a solution, then we don\\'t bother putting that item in other containers with same size - just try a container with different size.\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\tmap<int, int, greater<int>> contSizeCount; // [key: sizes of containers | val: number of containers of this size]\\n\\tfor (int n : contSize) ++contSizeCount[n];\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (auto &[szCont, c] : contSizeCount) {\\n\\t\\t\\tif (!c || szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\t--c, ++contSizeCount[szCont - szItem];\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\t++c, --contSizeCount[szCont - szItem];\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\\n\\n#### Ver 1.4 - Combine Ver 1.2 and 1.3 (200ms)\\n\\nNote: even though methods used in ver 1.2 and 1.3 are completely different, they are both trying to reduce the cases that we need to calculate. So the improvement is rather less significant by combining both.\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tmap<int, int> contSizeCount; // [key: sizes of containers | val: number of containers of this size]\\n\\tfor (int n : contSize) ++contSizeCount[n];\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (auto &[szCont, c] : contSizeCount) {\\n\\t\\t\\tif (!c || szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\t--c, ++contSizeCount[szCont - szItem];\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\t++c, --contSizeCount[szCont - szItem];\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\\n\\n----\\n\\n## For each container, try the all combinations of items that fit it\\n\\nNow let\\'s look at the other way around.\\n\\nIn this method, we use a **bit mask** to represent the combination of items.\\nFor each container, we try ALL combinations of items (mask from 0 to all 1s)\\n\\nNote: \\n- `(1 << N) - 1` => a mask with N trailing 1s\\n- `if ((mask & avail) != mask)` => check if exists any 1 in `mask` is 0 at the same bit in `avail` => check if any item chosen for the combination is not available\\n- `avail ^ mask` => remove all 1 bits in `mask` from `avail` (mask is a subset of avail)\\n\\n#### Ver 2 - Try All Combinations (TLE)\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tfor (int mask = 0; mask < (1 << itemSize.size()); ++mask) {\\n\\t\\t\\tif ((mask & avail) != mask) continue;\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\\n\\n#### Ver 2.0.1 - Try All Submasks (TLE)\\n\\nWe can improve Ver2 slightly by calculating **next subset mask** directly instead of iterating through 0 to all 1s:\\n- `mask = (mask - 1) & avail`\\n\\nFor more details, read [this](https://cp-algorithms.com/algebra/all-submasks.html)\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\tif (!mask) break;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\\n\\n#### Ver 2.1 Dynamic Programming (700+ms)\\n\\nVer 2.0.1 still runs TLE. This is because we were repeatedly calculating the _same subproblem_.\\nFor example:\\n1. Suppose we put item A and B in container 1, and put C in container 2, then try to fit all the rest items into the rest containers and failed to find a solution. `[A, B][C]......`\\n2. We then move item B from container 1 to container 2, then we do the exactly same calculation for the rest. `[A][B, C]......`\\n\\nThis is the perfect situation to apply ***dynamic programming***.\\n\\nFor container _i_ and available item subset, we mark it `true` if we have checked it (and failed to find a solution), so we don\\'t need to check it again.\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\tif (!mask) break;\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\\n\\n#### Ver 2.2 DP with Remembered Subset Sums (448ms)\\n\\nIn Ver 2.1, we calculate the sum of a subset (total size of chosen items) every time.\\nWe can take one step further from by **remembering those sums**.\\n(I saw some other solutions that _precalculate_ all the sums, that also works. However, apparently we don\\'t need _all_ of them. So this method would be faster)\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tvector<int> subsetSum(1 << itemSize.size(), 0);\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tif (mask) {\\n\\t\\t\\t\\tint sum = subsetSum[mask];\\n\\t\\t\\t\\tif (!sum) {\\n\\t\\t\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\t\\t\\tsubsetSum[mask] = sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (BT(i + 1, avail)) return true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\\n\\n#### Ver 2.3 DP with Preprocess (544ms)\\n\\nOther than DP, we can also apply the pruning explained in Ver 1.2 to this method.\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\tif (!mask) break;\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\\n\\n#### Ver 2.4 Combine Ver 2.2 & 2.3 (388ms)\\n\\nThen combine DP and preprocessing together:\\n\\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tvector<int> subsetSum(1 << itemSize.size(), 0);\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tif (mask) {\\n\\t\\t\\t\\tint sum = subsetSum[mask];\\n\\t\\t\\t\\tif (!sum) {\\n\\t\\t\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\t\\t\\tsubsetSum[mask] = sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (BT(i + 1, avail)) return true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```cpp\\nbool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n\\tunordered_map<int, int> fm;\\n\\tfor (int n : nums) ++fm[n];\\n\\tvector<int> counts;\\n\\tfor (auto [ignore, f] : fm) counts.push_back(f);\\n\\treturn CanAllFit(counts, quantity);\\n}\\n\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n    // ...\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (int &szCont : contSize) {\\n\\t\\t\\tif (szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\tszCont -= szItem;\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\tszCont += szItem;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>()); // sort in descending order\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (int &szCont : contSize) {\\n\\t\\t\\tif (szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\tszCont -= szItem;\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\tszCont += szItem;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (int &szCont : contSize) {\\n\\t\\t\\tif (szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\tszCont -= szItem;\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\tszCont += szItem;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\tmap<int, int, greater<int>> contSizeCount; // [key: sizes of containers | val: number of containers of this size]\\n\\tfor (int n : contSize) ++contSizeCount[n];\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (auto &[szCont, c] : contSizeCount) {\\n\\t\\t\\tif (!c || szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\t--c, ++contSizeCount[szCont - szItem];\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\t++c, --contSizeCount[szCont - szItem];\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tmap<int, int> contSizeCount; // [key: sizes of containers | val: number of containers of this size]\\n\\tfor (int n : contSize) ++contSizeCount[n];\\n\\n\\tfunction<bool(int)> BT;\\n\\tBT = [&](int i) {\\n\\t\\tint szItem = itemSize[i];\\n\\t\\tfor (auto &[szCont, c] : contSizeCount) {\\n\\t\\t\\tif (!c || szCont < szItem) continue;\\n\\t\\t\\tif (i == itemSize.size() - 1) return true;\\n\\t\\t\\t--c, ++contSizeCount[szCont - szItem];\\n\\t\\t\\tif (BT(i + 1)) return true;\\n\\t\\t\\t++c, --contSizeCount[szCont - szItem];\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tfor (int mask = 0; mask < (1 << itemSize.size()); ++mask) {\\n\\t\\t\\tif ((mask & avail) != mask) continue;\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\tif (!mask) break;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\tif (!mask) break;\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tvector<int> subsetSum(1 << itemSize.size(), 0);\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tif (mask) {\\n\\t\\t\\t\\tint sum = subsetSum[mask];\\n\\t\\t\\t\\tif (!sum) {\\n\\t\\t\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\t\\t\\tsubsetSum[mask] = sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (BT(i + 1, avail)) return true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\tif (!mask) break;\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```\n```cpp\\nbool CanAllFit(vector<int> &contSize, vector<int> &itemSize) {\\n\\tsort(contSize.begin(), contSize.end(), greater<int>());\\n\\tsort(itemSize.begin(), itemSize.end(), greater<int>());\\n\\n\\twhile (!contSize.empty() && !itemSize.empty()) {\\n\\t\\tif (contSize.back() < itemSize.back()) contSize.pop_back();\\n\\t\\telse if (itemSize.size() == 1 || contSize.back() == itemSize.back()) contSize.pop_back(), itemSize.pop_back();\\n\\t\\telse if (contSize.back() < itemSize.back() + itemSize[itemSize.size() - 2]) {\\n\\t\\t\\titemSize.erase(lower_bound(itemSize.begin(), itemSize.end(), contSize.back(), greater<int>()));\\n\\t\\t\\tcontSize.pop_back();\\n\\t\\t} else break;\\n\\t}\\n\\tif (itemSize.empty()) return true;\\n\\tif (contSize.empty()) return false;\\n\\n\\tvector<int> subsetSum(1 << itemSize.size(), 0);\\n\\tvector<vector<bool>> dp(contSize.size(), vector(1 << itemSize.size(), false));\\n\\tfunction<bool(int, int)> BT;\\n\\tBT = [&](int i, int avail) {\\n\\t\\tif (!avail) return true;\\n\\t\\tif (i == contSize.size()) return false;\\n\\t\\tif (dp[i][avail]) return false;\\n\\t\\tfor (int mask = avail; ; mask = (mask - 1) & avail) {\\n\\t\\t\\tif (mask) {\\n\\t\\t\\t\\tint sum = subsetSum[mask];\\n\\t\\t\\t\\tif (!sum) {\\n\\t\\t\\t\\t\\tfor (int j = 0; (1 << j) <= mask; ++j)\\n\\t\\t\\t\\t\\t\\tif ((1 << j) & mask) sum += itemSize[j];\\n\\t\\t\\t\\t\\tsubsetSum[mask] = sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum <= contSize[i] && BT(i + 1, avail ^ mask)) return true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (BT(i + 1, avail)) return true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i][avail] = true;\\n\\t\\treturn false;\\n\\t};\\n\\n\\treturn BT(0, (1 << itemSize.size()) - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935476,
                "title": "c-dp-bitmask",
                "content": "1. First calculate the count of each type of value in nums and store in `vector a`\\n2. Now idea is to iterate over `a`  and try out each possible scenario of assigning this to different quantity orders i.e `b`. In particular the possibilities are to either use current element from `a` or skip it.\\n3. When considering the first option, we need to find a subset of `b`  over which we can distribute the current element from `a` . Using bitmask we can find all such subsets.\\n4. Since `m <= 10` (i.e size of `b`), there can be only 1024 subsets, we iterate over all of them. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int m, n;\\n    vector<int> a;\\n    vector<int> b;\\n    vector<vector<int> > dp;\\n    vector<int> cache;\\n    \\n    bool solve(int idx, int mask) {\\n        if(mask == (1 << m) - 1)\\n            return 1;\\n        \\n        if(idx == n)\\n            return 0;\\n        \\n        if(dp[idx][mask] != -1)\\n            return dp[idx][mask];\\n        \\n        for(int i = mask + 1; i < (1 << m); ++i) {\\n            if(mask != (mask & (i))) continue;\\n            \\n            if(a[idx] >= cache[i] - cache[mask] && solve(idx + 1, i)) {\\n                return dp[idx][mask] = true;\\n            }\\n        }\\n        \\n        return dp[idx][mask] = solve(idx + 1, mask);\\n    }\\n    \\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& b) {\\n        \\n        unordered_map<int, int> mp;\\n        for(int x: nums) {\\n            mp[x] += 1;\\n        }\\n        for(auto p: mp)\\n            a.push_back(p.second);\\n        \\n        this->b = b;\\n        this->m = b.size();\\n        this->n = a.size();\\n        \\n        dp.clear(); dp.resize(n, vector<int> ((1<<m), -1));\\n        cache.clear(); cache.resize(1024, 0);\\n        \\n        for(int mask = 0; mask < (1 << m); ++mask) {\\n            for(int i = 0; i < m; ++i) {\\n                if(mask & (1 << i)) {\\n                    cache[mask] += b[i];\\n                }\\n            }\\n        }\\n        \\n        return solve(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int m, n;\\n    vector<int> a;\\n    vector<int> b;\\n    vector<vector<int> > dp;\\n    vector<int> cache;\\n    \\n    bool solve(int idx, int mask) {\\n        if(mask == (1 << m) - 1)\\n            return 1;\\n        \\n        if(idx == n)\\n            return 0;\\n        \\n        if(dp[idx][mask] != -1)\\n            return dp[idx][mask];\\n        \\n        for(int i = mask + 1; i < (1 << m); ++i) {\\n            if(mask != (mask & (i))) continue;\\n            \\n            if(a[idx] >= cache[i] - cache[mask] && solve(idx + 1, i)) {\\n                return dp[idx][mask] = true;\\n            }\\n        }\\n        \\n        return dp[idx][mask] = solve(idx + 1, mask);\\n    }\\n    \\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& b) {\\n        \\n        unordered_map<int, int> mp;\\n        for(int x: nums) {\\n            mp[x] += 1;\\n        }\\n        for(auto p: mp)\\n            a.push_back(p.second);\\n        \\n        this->b = b;\\n        this->m = b.size();\\n        this->n = a.size();\\n        \\n        dp.clear(); dp.resize(n, vector<int> ((1<<m), -1));\\n        cache.clear(); cache.resize(1024, 0);\\n        \\n        for(int mask = 0; mask < (1 << m); ++mask) {\\n            for(int i = 0; i < m; ++i) {\\n                if(mask & (1 << i)) {\\n                    cache[mask] += b[i];\\n                }\\n            }\\n        }\\n        \\n        return solve(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935474,
                "title": "c-dfs-backtrack-solution",
                "content": "Given there are at most 50 unqiue values, and at most 10 customers.\\nIt\\'s a sign that we could do a backtrack.\\n\\nThe idea is to\\n1. count the occurance of each number\\n2. sort the customers\\' order quantities `DESC`\\n3. do a backtrack with DFS on the nubmers that are enough to be distributed to customers\\n\\n```\\nclass Solution {\\npublic:\\n    bool res = false;\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> conter;\\n        for (auto n : nums) {\\n            conter[n] += 1;\\n        }\\n\\t\\t\\n        vector<int> counts;\\n        for (auto& e : conter) counts.push_back(e.second);\\n\\t\\t\\n        sort(quantity.rbegin(), quantity.rend());\\n\\t\\t\\n        dfs(quantity, counts, 0);\\n\\t\\t\\n        return res;\\n    }\\n    \\n    void dfs(vector<int>& quantity, vector<int>& counts, int i) {\\n        if (i == quantity.size() || res) {\\n            res = true;\\n            return;\\n        }\\n\\t\\t\\n        for (int j = 0; j < counts.size(); j++) {\\n            int n = counts[j];\\n\\t\\t\\t\\n            if (n >= quantity[i]) {\\n                counts[j] -= quantity[i];\\n                dfs(quantity, counts, i + 1);\\n                counts[j] += quantity[i];\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool res = false;\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> conter;\\n        for (auto n : nums) {\\n            conter[n] += 1;\\n        }\\n\\t\\t\\n        vector<int> counts;\\n        for (auto& e : conter) counts.push_back(e.second);\\n\\t\\t\\n        sort(quantity.rbegin(), quantity.rend());\\n\\t\\t\\n        dfs(quantity, counts, 0);\\n\\t\\t\\n        return res;\\n    }\\n    \\n    void dfs(vector<int>& quantity, vector<int>& counts, int i) {\\n        if (i == quantity.size() || res) {\\n            res = true;\\n            return;\\n        }\\n\\t\\t\\n        for (int j = 0; j < counts.size(); j++) {\\n            int n = counts[j];\\n\\t\\t\\t\\n            if (n >= quantity[i]) {\\n                counts[j] -= quantity[i];\\n                dfs(quantity, counts, i + 1);\\n                counts[j] += quantity[i];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935824,
                "title": "c-state-compression-dp-o-50-3-m",
                "content": "It is a State Compression DP problem. Number of quantities is less, so we need to make integers choose quantities.\\n\\n`alg[i][j]` stores whether it is possible to distribute integers for `nums[i:]`, given that chosen quantities in the previous  integers is represented as a bitset `j`. For the `ith` integer, we can choose any subset of quantities that are not already chosen and distribute the `ith` integer into them, as long as there are enough integers for the subset.\\n\\nFor example, `i=1`, `j=10101`, which means the `0th` integer is already distributed into `0th, 2nd, 4th` quantities. For the `1th` integer, we have the following choices,\\n\\n1. `00000`, we don\\'t use the `1th` integer at all;\\n2. `01000`, the `1th` integer is distributed into the `1st` quantity;\\n3. `00010`, the `1th` integer is distributed into the `3rd` quantity;\\n4. `01010`, the `1th` integer is distributed into the `1rd` and `3rd` quantity;\\n\\nWe go with the choice with minimum step. \\n\\nThus, in general, for `alg[i][j]`, we have the following choices\\n\\n```python\\n# Choice1, choose a subset of available quantities,\\nfor subset in bitwise_not(j):\\n  if enough_number(i, subset):\\n\\talg[i][j] = min(alg[i][j], alg[i+1][j | subset])\\n\\n# Choice2, bypass this integer\\nalg[i + 1][j]\\n```\\n\\nThere is an efficient technique to traverse all subsets of a set, see [this post](https://cp-algorithms.com/algebra/all-submasks.html).\\n\\n```c++\\n// Use static 2d arrays to get it faster\\n\\nbool alg[52][1 << 10];\\n// ok[i][j]: if there are enough integers for the ith integer to be distributed into a quantity subset j\\nbool ok[52][1 << 10];\\n\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        memset(alg, 0, sizeof(alg));\\n        memset(ok, 0, sizeof(ok));\\n        \\n        unordered_map<int, int> num_to_cnt;\\n        for (auto const &num : nums) {\\n            num_to_cnt[num]++;\\n        }\\n        vector<int> cnts;\\n        for (auto const &[_, cnt] : num_to_cnt) {\\n            cnts.push_back(cnt);\\n        }\\n        \\n        int m = cnts.size();\\n        int n = quantity.size();\\n        alg[m][(1 << n) - 1] = true;\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < (1 << n); ++j) {\\n                int sum = 0;\\n                for (int k = 0; k < n; ++k) {\\n                    if ((j >> k) & 1) {\\n                        sum += quantity[k];\\n                    }\\n                }\\n                if (sum <= cnts[i]) {\\n                    ok[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        for (int i = m - 1; i >= 0; --i) {\\n            for (unsigned int j = 0; j < (1 << n); ++j) {\\n                alg[i][j] = alg[i + 1][j];\\n                unsigned int whole_set = (~j) & ((1 << n) - 1);\\n\\t\\t\\t\\t// https://cp-algorithms.com/algebra/all-submasks.html\\n                for (int subset = whole_set; subset > 0; subset = (subset - 1) & whole_set) {\\n                    if (ok[i][subset]) {\\n                        alg[i][j] = alg[i][j] || alg[i + 1][j | subset];\\n                    }\\n                }\\n            }\\n        }\\n        return alg[0][0];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```python\\n# Choice1, choose a subset of available quantities,\\nfor subset in bitwise_not(j):\\n  if enough_number(i, subset):\\n\\talg[i][j] = min(alg[i][j], alg[i+1][j | subset])\\n\\n# Choice2, bypass this integer\\nalg[i + 1][j]\\n```\n```c++\\n// Use static 2d arrays to get it faster\\n\\nbool alg[52][1 << 10];\\n// ok[i][j]: if there are enough integers for the ith integer to be distributed into a quantity subset j\\nbool ok[52][1 << 10];\\n\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        memset(alg, 0, sizeof(alg));\\n        memset(ok, 0, sizeof(ok));\\n        \\n        unordered_map<int, int> num_to_cnt;\\n        for (auto const &num : nums) {\\n            num_to_cnt[num]++;\\n        }\\n        vector<int> cnts;\\n        for (auto const &[_, cnt] : num_to_cnt) {\\n            cnts.push_back(cnt);\\n        }\\n        \\n        int m = cnts.size();\\n        int n = quantity.size();\\n        alg[m][(1 << n) - 1] = true;\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < (1 << n); ++j) {\\n                int sum = 0;\\n                for (int k = 0; k < n; ++k) {\\n                    if ((j >> k) & 1) {\\n                        sum += quantity[k];\\n                    }\\n                }\\n                if (sum <= cnts[i]) {\\n                    ok[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        for (int i = m - 1; i >= 0; --i) {\\n            for (unsigned int j = 0; j < (1 << n); ++j) {\\n                alg[i][j] = alg[i + 1][j];\\n                unsigned int whole_set = (~j) & ((1 << n) - 1);\\n\\t\\t\\t\\t// https://cp-algorithms.com/algebra/all-submasks.html\\n                for (int subset = whole_set; subset > 0; subset = (subset - 1) & whole_set) {\\n                    if (ok[i][subset]) {\\n                        alg[i][j] = alg[i][j] || alg[i + 1][j | subset];\\n                    }\\n                }\\n            }\\n        }\\n        return alg[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935428,
                "title": "java-backtrack-solution-got-accepted-with-88-ms",
                "content": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        for (int num : nums) {\\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        int idx = 0;\\n        int[] arrCounts = new int[counts.size()];\\n        for (var key : counts.keySet()) {\\n            arrCounts[idx++] = counts.get(key);\\n        }\\n        return solve(arrCounts, quantity);\\n    }\\n    \\n    private boolean solve(int[] counts, int[] quantity) {\\n        Arrays.sort(counts);\\n        Arrays.sort(quantity);\\n        reverse(quantity);\\n        return solve(counts, quantity, 0);\\n    }\\n    \\n    private void reverse(int[] arr) {\\n        for (int i = 0; i + i < arr.length; i++) {\\n            int tmp = arr[i];\\n            arr[i] = arr[arr.length - i - 1];\\n            arr[arr.length - i - 1] = tmp;\\n        }\\n    }\\n    \\n    private boolean solve(int[] counts, int[] quantity, int idx) {\\n        if (idx >= quantity.length) {\\n            return true;\\n        }\\n        \\n        for (int i = 0; i < counts.length; i++) {\\n            if (counts[i] >= quantity[idx]) {\\n                counts[i] -= quantity[idx];\\n                if (solve(counts, quantity, idx + 1)) {\\n                    return true;\\n                }\\n                counts[i] += quantity[idx];\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        for (int num : nums) {\\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        int idx = 0;\\n        int[] arrCounts = new int[counts.size()];\\n        for (var key : counts.keySet()) {\\n            arrCounts[idx++] = counts.get(key);\\n        }\\n        return solve(arrCounts, quantity);\\n    }\\n    \\n    private boolean solve(int[] counts, int[] quantity) {\\n        Arrays.sort(counts);\\n        Arrays.sort(quantity);\\n        reverse(quantity);\\n        return solve(counts, quantity, 0);\\n    }\\n    \\n    private void reverse(int[] arr) {\\n        for (int i = 0; i + i < arr.length; i++) {\\n            int tmp = arr[i];\\n            arr[i] = arr[arr.length - i - 1];\\n            arr[arr.length - i - 1] = tmp;\\n        }\\n    }\\n    \\n    private boolean solve(int[] counts, int[] quantity, int idx) {\\n        if (idx >= quantity.length) {\\n            return true;\\n        }\\n        \\n        for (int i = 0; i < counts.length; i++) {\\n            if (counts[i] >= quantity[idx]) {\\n                counts[i] -= quantity[idx];\\n                if (solve(counts, quantity, idx + 1)) {\\n                    return true;\\n                }\\n                counts[i] += quantity[idx];\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935554,
                "title": "python-3-o-50-3-m-bitmask-dp",
                "content": "based on @LarryNY solution\\n\\nremove an O(m) factor by precalculating subset sums\\n\\niterating through all submasks of all masks is O(3^m)\\nhttps://cp-algorithms.com/algebra/all-submasks.html\\n```\\nclass Solution:\\n    def canDistribute(self, a: List[int], customers: List[int]) -> bool:\\n        \\n        c = Counter(a)\\n        a = sorted(c.values())\\n        \\n        n = len(a)\\n        m = len(customers)\\n        \\n        ALL = (1 << m) - 1\\n        \\n        \\n        mask_sum = defaultdict(int)\\n        \\n        for mask in range(1 << m):\\n            for i in range(m):\\n                if (1 << i) & mask:\\n                    mask_sum[mask] += customers[i]\\n                    \\n        \\n        @lru_cache(None)\\n        def recurse(i, mask):\\n            \\n            if mask == 0:\\n                return True\\n            \\n            if i == n:\\n                return False\\n            \\n            submask = mask\\n            \\n            while submask:\\n                \\n                if mask_sum[submask] <= a[i] and recurse(i+1, mask ^ submask):\\n                    return True\\n                \\n                submask = (submask-1) & mask\\n            \\n            return recurse(i+1, mask)\\n                \\n        return recurse(0, ALL)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, a: List[int], customers: List[int]) -> bool:\\n        \\n        c = Counter(a)\\n        a = sorted(c.values())\\n        \\n        n = len(a)\\n        m = len(customers)\\n        \\n        ALL = (1 << m) - 1\\n        \\n        \\n        mask_sum = defaultdict(int)\\n        \\n        for mask in range(1 << m):\\n            for i in range(m):\\n                if (1 << i) & mask:\\n                    mask_sum[mask] += customers[i]\\n                    \\n        \\n        @lru_cache(None)\\n        def recurse(i, mask):\\n            \\n            if mask == 0:\\n                return True\\n            \\n            if i == n:\\n                return False\\n            \\n            submask = mask\\n            \\n            while submask:\\n                \\n                if mask_sum[submask] <= a[i] and recurse(i+1, mask ^ submask):\\n                    return True\\n                \\n                submask = (submask-1) & mask\\n            \\n            return recurse(i+1, mask)\\n                \\n        return recurse(0, ALL)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935414,
                "title": "python-backtracking",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        c = Counter(nums)\\n        m = len(quantity)\\n\\t\\t# we only need at most m different numbers, so we choose the ones which are most abundant\\n        left = sorted(c.values())[-m:]\\n        \\n\\t\\t# If the customer with most quantity required can\\'t be fulfilled, we don\\'t need to go further and answer will be false\\n        quantity.sort(reverse=True)\\n        \\n        def func(left, quantity, customer):\\n            if customer == len(quantity):\\n                return True\\n            \\n            for i in range(len(left)):\\n                if left[i] >= quantity[customer]:\\n                    left[i] -= quantity[customer]\\n                    if func(left, quantity, customer+1):\\n                        return True\\n                    left[i] += quantity[customer]\\n            return False\\n        \\n        return func(left, quantity, 0)",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        c = Counter(nums)\\n        m = len(quantity)\\n\\t\\t# we only need at most m different numbers, so we choose the ones which are most abundant\\n        left = sorted(c.values())[-m:]\\n        \\n\\t\\t# If the customer with most quantity required can\\'t be fulfilled, we don\\'t need to go further and answer will be false\\n        quantity.sort(reverse=True)\\n        \\n        def func(left, quantity, customer):\\n            if customer == len(quantity):\\n                return True\\n            \\n            for i in range(len(left)):\\n                if left[i] >= quantity[customer]:\\n                    left[i] -= quantity[customer]\\n                    if func(left, quantity, customer+1):\\n                        return True\\n                    left[i] += quantity[customer]\\n            return False\\n        \\n        return func(left, quantity, 0)",
                "codeTag": "Java"
            },
            {
                "id": 938428,
                "title": "java-backtrack-25-ms",
                "content": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        \\n        // Use a map to count the numbers, ex: nums:[5,7,4,7,4,7] -> {5:1, 7:3, 4:2}\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        for (int num : nums)\\n            freq.put(num, freq.getOrDefault(num, 0)+1);\\n        \\n        // Turn values of the map into array, ex: {5:1, 7:3, 4:2} -> [1, 3, 2]\\n        int[] dist = new int[freq.size()];\\n        int idx = 0;\\n        for (int f : freq.values())\\n            dist[idx++] = f;\\n        \\n\\t\\t// Fullfill the quantities from the biggest quantity to the smallest.\\n        // If the bigger quantity can\\'t be filled, the program will stop as early as possible.\\n        Arrays.sort(quantity);\\n        return rec(dist, quantity, quantity.length-1);\\n    }\\n    \\n    // try to fullfill the j-th order quantity\\n    private boolean rec(int[] dist, int[] quantity, int j) {\\n        \\n        // stop condition. We\\'ve fulfilled all the order quantities.\\n        if (j == -1)\\n            return true;\\n        \\n        Set<Integer> used = new HashSet<>();\\n        for (int i = 0 ; i < dist.length ; ++i) {\\n\\t\\t\\n\\t\\t\\t// Use a set to make sure that \\n\\t\\t\\t//   we don\\'t distribute from the same amount to this j-th order for more than once.\\n            // With this check, the program reduces from 97ms to 25 ms.\\n            if (dist[i] >= quantity[j] && used.add(dist[i])) {\\n                dist[i] -= quantity[j];\\n                if (rec(dist, quantity, j-1))\\n                    return true;\\n                dist[i] += quantity[j];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        \\n        // Use a map to count the numbers, ex: nums:[5,7,4,7,4,7] -> {5:1, 7:3, 4:2}\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        for (int num : nums)\\n            freq.put(num, freq.getOrDefault(num, 0)+1);\\n        \\n        // Turn values of the map into array, ex: {5:1, 7:3, 4:2} -> [1, 3, 2]\\n        int[] dist = new int[freq.size()];\\n        int idx = 0;\\n        for (int f : freq.values())\\n            dist[idx++] = f;\\n        \\n\\t\\t// Fullfill the quantities from the biggest quantity to the smallest.\\n        // If the bigger quantity can\\'t be filled, the program will stop as early as possible.\\n        Arrays.sort(quantity);\\n        return rec(dist, quantity, quantity.length-1);\\n    }\\n    \\n    // try to fullfill the j-th order quantity\\n    private boolean rec(int[] dist, int[] quantity, int j) {\\n        \\n        // stop condition. We\\'ve fulfilled all the order quantities.\\n        if (j == -1)\\n            return true;\\n        \\n        Set<Integer> used = new HashSet<>();\\n        for (int i = 0 ; i < dist.length ; ++i) {\\n\\t\\t\\n\\t\\t\\t// Use a set to make sure that \\n\\t\\t\\t//   we don\\'t distribute from the same amount to this j-th order for more than once.\\n            // With this check, the program reduces from 97ms to 25 ms.\\n            if (dist[i] >= quantity[j] && used.add(dist[i])) {\\n                dist[i] -= quantity[j];\\n                if (rec(dist, quantity, j-1))\\n                    return true;\\n                dist[i] += quantity[j];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938440,
                "title": "c-well-commented-dp-50-3-m",
                "content": "First we calculate need, where need[i] =  min frq a number needs to have to satisfy the set i, i < 1024 = 2^10\\n\\nThen we introduce the frqs one by one (at most 50 of these). For each, we iterate over all sets i and all submasks of that set i. If frq <= need[s], that means the integer corresponding to frq can satisfy the set s, which means if i-s (arithmetic minus and set minus) can be satisfied, then so can i.\\n```\\nclass Solution {\\npublic:\\n  bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n    unordered_map<int,int>frq;\\n    for(int num:nums)frq[num]++;\\n    int F=frq.size(),  m=quantity.size(); // #unique integers\\n    vector<int> need(1<<m);\\n    vector<bool> res(1<<m); \\n    res[0]=true;\\n    for(int i=0;i!=1<<m; ++i){\\n      int curr=0;\\n      for(int j=0;j!=m;++j){  // is j in the i\\'th set?\\n        if((1<<j)&i)curr+=quantity[j];\\n      }\\n      need[i]=curr;\\n    }\\n    for(auto p:frq){\\n      int have=p.second;\\n      auto temp=res;  // before we had \\'have\\'\\n      for(int i=(1<<m)-1;i; --i){\\n        for (int s=i; s; s=(s-1)&i){  // submask of i\\n          if(need[s] <= have){\\n            res[i] = res[i] || temp[i-s];\\n          }\\n        }\\n      }\\n    }\\n\\treturn res.back();    // (1<<m) - 1 = the complete set\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n    unordered_map<int,int>frq;\\n    for(int num:nums)frq[num]++;\\n    int F=frq.size(),  m=quantity.size(); // #unique integers\\n    vector<int> need(1<<m);\\n    vector<bool> res(1<<m); \\n    res[0]=true;\\n    for(int i=0;i!=1<<m; ++i){\\n      int curr=0;\\n      for(int j=0;j!=m;++j){  // is j in the i\\'th set?\\n        if((1<<j)&i)curr+=quantity[j];\\n      }\\n      need[i]=curr;\\n    }\\n    for(auto p:frq){\\n      int have=p.second;\\n      auto temp=res;  // before we had \\'have\\'\\n      for(int i=(1<<m)-1;i; --i){\\n        for (int s=i; s; s=(s-1)&i){  // submask of i\\n          if(need[s] <= have){\\n            res[i] = res[i] || temp[i-s];\\n          }\\n        }\\n      }\\n    }\\n\\treturn res.back();    // (1<<m) - 1 = the complete set\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340762,
                "title": "python3-dead-simple-backtracking-faster-than-98",
                "content": "1. Sort the `quantity` array in reverse order, since allocating larger quantities first will more quickly reduce the search space.\\n2. Get the frequency of each number in `nums`, ignoring the actual numbers.\\n3. Then further get the count of each frequency, storing this in `freqCounts`. We do this so that in our backtracking step, we don\\'t try allocating a quantity to two different but equal frequencies, as they would have an equivalent result.\\n4. In the backtracking, we try allocating each quantity to each unique frequency, simply decrementing and incrementing the frequency counts in each step.\\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        quantity.sort(reverse=True)\\n        freqCounts = defaultdict(int, Counter(Counter(nums).values()))\\n        def backtrack(i: int = 0) -> bool:\\n            if i == len(quantity):\\n                return True\\n            \\n            for freq, count in list(freqCounts.items()):\\n                if freq >= quantity[i] and count > 0:\\n                    freqCounts[freq] -= 1\\n                    freqCounts[freq - quantity[i]] += 1\\n                    if backtrack(i + 1):\\n                        return True\\n                    freqCounts[freq] += 1\\n                    freqCounts[freq - quantity[i]] -= 1\\n            \\n            return False\\n        \\n        return backtrack()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        quantity.sort(reverse=True)\\n        freqCounts = defaultdict(int, Counter(Counter(nums).values()))\\n        def backtrack(i: int = 0) -> bool:\\n            if i == len(quantity):\\n                return True\\n            \\n            for freq, count in list(freqCounts.items()):\\n                if freq >= quantity[i] and count > 0:\\n                    freqCounts[freq] -= 1\\n                    freqCounts[freq - quantity[i]] += 1\\n                    if backtrack(i + 1):\\n                        return True\\n                    freqCounts[freq] += 1\\n                    freqCounts[freq - quantity[i]] -= 1\\n            \\n            return False\\n        \\n        return backtrack()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937984,
                "title": "bit-mask-backtrack-with-explanation-proof-of-time-complexity-o-m-n-but-not-o-3-m",
                "content": "# **1. Bitmask -- from numbers to customers**\\nThe core of the problem is that, given a specific integer `x` (means that there is a number occuring `x` times in the input), how can we know which subset of customers it should be distributed to. Say, `x` = 10, and `quantity=[6,4,5, 9]`, then we can assign 10 to `6,4`, `4,5`, or just any single `4`, `5`, `6`,  `9` . So we use a bit-mask to iterate all possible combinations for each integer, and see if we can satisfy all customers. \\n\\nThe basic algorithm is that\\n* we will iterate through all bitmasks for the first integer\\n* and for each mask, iterate through all of its submasks for the second integer\\n* and for each mask, iterate through all of its submasks for the third integer\\n* ...\\n* If there is submasks that satisfies all customers (all bits being set, etc), then it\\'s true.\\n\\n\\n\\n**Iterate a subset of a bit mask is like**\\n```\\nfor (int m=0; m<(1<<n); ++m)\\n    for (int s=m; s; s=(s-1)&m)\\n ... s and m ...\\n ```\\n\\nBut what\\'s the complexity? Let\\'s first consider a simple situation that there is only 2 integers -- 2 levels of submask, which is shown in the above code.\\n\\n---\\n\\nLet\\'s prove that the inner loop will execute a total of O(3^n) iterations.\\n\\nProof:\\n* Consider the i-th bit. There are exactly three options for it:\\n\\t1. it is not included in the mask m (and therefore not included in submask s),\\n\\t2. it is included in m, but not included in s, or\\n\\t3. it is included in both m and s.\\n\\n\\nAs there are a total of n bits, there will be 3^n different combinations.\\n\\n---\\nIt is similar to see that when there is m levels, then for each bit, there will be (m+1) status (either picked by any level or not picked at all).\\n\\nSo the complexity would be (m+1)^n.\\n\\n---\\n\\nFor the specific problem, we can have an optimization that, we only need at most the first n largest integers (if n < m). SO the complexity is (min(m,n)+1)^n\\n\\n\\n```python\\nclass Solution:\\n    def canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n        cnt = collections.Counter(nums)\\n        avai = sorted([*cnt.values()])[-len(Q):]\\n        Q.sort(reverse=True)\\n        n = len(Q)\\n        @lru_cache(None)\\n        def is_ok(i, ns):\\n            needed = 0\\n            for j in range(n):\\n                if (1<<j) & ns:\\n                    needed += Q[j]\\n            return needed <= avai[i]\\n        # 1 is waiting, 0 is satisfied\\n        @lru_cache(None)\\n        def dfs(i, status):\\n            if i == len(avai) or status == 0:\\n                return status == 0\\n            if dfs(i+1, status):\\n                return True\\n            ns = status # need customer to be feeded as 1 bit\\n            while ns:\\n                if is_ok(i, ns) and dfs(i+1, ns^status):\\n                    return True\\n                ns = (ns - 1) & status\\n            return False\\n        return dfs(0, (1<<n)-1)\\n```\\n\\t\\t\\n\\n\\n\\n# 2. **Backtracking -- from customers to numbers**\\n\\nInstead of thinking how a kind of number can be distributed to different combination of customers, we can think about which number will a customer pick.\\n\\nTo do this, for each customer, we simply iterate over all possible numbers that can satisfy this customer and continue to the next customer.\\nIn worst case, for each customer (n totally), we have m choice, so the time complexity is O(m^n).\\nBut since the amount of data is small, that we can sort the numbers and use memorization to optimize it.\\nA sample python code:\\n\\n```python\\ndef canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n    cnt = collections.Counter(nums)\\n    avai = sorted([*cnt.values()])[-len(Q):]\\n    Q.sort(reverse=True)\\n    n = len(Q)\\n    @lru_cache(None)\\n    def dfs(cid, avai):\\n        \"\"\"\\n        cid: customer_id\\n        \"\"\"\\n        if cid == len(Q):\\n            return True\\n        for i in range(len(avai)):\\n            if avai[i] >= Q[cid]:\\n                new_avai = avai[:i]+avai[i+1:]\\n                if avai[i] > Q[cid]:\\n                    new_avai += (avai[i] - Q[cid]),\\n                if dfs(cid+1, tuple(sorted(new_avai, reverse=True))):\\n                    return True\\n        return False\\n    return dfs(0, tuple(avai[::-1]))\\n```",
                "solutionTags": [],
                "code": "```\\nfor (int m=0; m<(1<<n); ++m)\\n    for (int s=m; s; s=(s-1)&m)\\n ... s and m ...\\n ```\n```python\\nclass Solution:\\n    def canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n        cnt = collections.Counter(nums)\\n        avai = sorted([*cnt.values()])[-len(Q):]\\n        Q.sort(reverse=True)\\n        n = len(Q)\\n        @lru_cache(None)\\n        def is_ok(i, ns):\\n            needed = 0\\n            for j in range(n):\\n                if (1<<j) & ns:\\n                    needed += Q[j]\\n            return needed <= avai[i]\\n        # 1 is waiting, 0 is satisfied\\n        @lru_cache(None)\\n        def dfs(i, status):\\n            if i == len(avai) or status == 0:\\n                return status == 0\\n            if dfs(i+1, status):\\n                return True\\n            ns = status # need customer to be feeded as 1 bit\\n            while ns:\\n                if is_ok(i, ns) and dfs(i+1, ns^status):\\n                    return True\\n                ns = (ns - 1) & status\\n            return False\\n        return dfs(0, (1<<n)-1)\\n```\n```python\\ndef canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n    cnt = collections.Counter(nums)\\n    avai = sorted([*cnt.values()])[-len(Q):]\\n    Q.sort(reverse=True)\\n    n = len(Q)\\n    @lru_cache(None)\\n    def dfs(cid, avai):\\n        \"\"\"\\n        cid: customer_id\\n        \"\"\"\\n        if cid == len(Q):\\n            return True\\n        for i in range(len(avai)):\\n            if avai[i] >= Q[cid]:\\n                new_avai = avai[:i]+avai[i+1:]\\n                if avai[i] > Q[cid]:\\n                    new_avai += (avai[i] - Q[cid]),\\n                if dfs(cid+1, tuple(sorted(new_avai, reverse=True))):\\n                    return True\\n        return False\\n    return dfs(0, tuple(avai[::-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935599,
                "title": "c-backtracking",
                "content": "```\\npublic class Solution {\\n    public bool CanDistribute(int[] nums, int[] quantity) {\\n        var cnt = nums.GroupBy(x => x).Select(x => x.Count()).ToList();\\n        Array.Sort(quantity, (a,b) => b.CompareTo(a));\\n        return DFS(cnt, quantity, 0);\\n    }\\n    \\n    public bool DFS(List<int> cnt, int[] quantity, int idx)\\n    {\\n        if(idx == quantity.Length) return true;\\n        for(int i = 0; i < cnt.Count; i++)\\n        {\\n            if(cnt[i] >= quantity[idx])\\n            {\\n                cnt[i] -= quantity[idx];\\n                if(DFS(cnt, quantity, idx+1))\\n                    return true;\\n                cnt[i] += quantity[idx];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanDistribute(int[] nums, int[] quantity) {\\n        var cnt = nums.GroupBy(x => x).Select(x => x.Count()).ToList();\\n        Array.Sort(quantity, (a,b) => b.CompareTo(a));\\n        return DFS(cnt, quantity, 0);\\n    }\\n    \\n    public bool DFS(List<int> cnt, int[] quantity, int idx)\\n    {\\n        if(idx == quantity.Length) return true;\\n        for(int i = 0; i < cnt.Count; i++)\\n        {\\n            if(cnt[i] >= quantity[idx])\\n            {\\n                cnt[i] -= quantity[idx];\\n                if(DFS(cnt, quantity, idx+1))\\n                    return true;\\n                cnt[i] += quantity[idx];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388884,
                "title": "c-backtracking",
                "content": "```\\n\\n```public:\\n    map<int,int>mp;\\n    bool solve(vector<int>&q,int idx)\\n    {\\n        if(idx==q.size())\\n        {\\n            return true;\\n        }\\n        for(auto i:mp)\\n        {\\n            if(i.second>=q[idx])\\n            {\\n                mp[i.first]-=q[idx];\\n                if(solve(q,idx+1))\\n                {\\n                    return true;\\n                }\\n                mp[i.first]+=q[idx];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& q) {\\n        sort(q.begin(),q.end(),greater<int>());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        return solve(q,0);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 958560,
                "title": "dp-bitmask-faster-than-93-90-space-less-than-96-53",
                "content": "rather than going to all possiblilty and filtering out,  just moving to all the masks will reduce time from 4^n -> 3 ^n\\n```\\nclass Solution {\\npublic:\\n    int temp[1001];\\n    bool dp[51][1025];\\n    int cache[1025];\\n    int n;\\n    vector<int>a;\\n    bool solve(int ind, int mask){\\n        if(mask == 0)return true;\\n        if(ind == n)return false;\\n        if(!dp[ind][mask])return dp[ind][mask];\\n        for(int i = mask; i > 0; i = mask & (i - 1)){\\n            if(cache[i] <= a[ind] && solve(ind + 1, mask ^ i))return dp[ind][mask] = true;\\n        }\\n         return dp[ind][mask] = solve(ind + 1, mask);\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        for(int i : nums)temp[i]++;\\n        \\n        for(int i = 0; i < 1001; ++i){\\n            if(temp[i])a.push_back(temp[i]);\\n        }\\n        n = a.size();\\n        int m = quantity.size();\\n        for(int i = 0; i < 51; ++i)for(int j = 0; j < 1025; ++j)dp[i][j] = true;\\n        for(int i = 0; i < (1 << m); ++i){\\n            for(int b = 0; b < m; ++b){\\n                if((i >> b) & 1)cache[i] += quantity[b];\\n            }\\n        }\\n        return solve(0, (1 << m) - 1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int temp[1001];\\n    bool dp[51][1025];\\n    int cache[1025];\\n    int n;\\n    vector<int>a;\\n    bool solve(int ind, int mask){\\n        if(mask == 0)return true;\\n        if(ind == n)return false;\\n        if(!dp[ind][mask])return dp[ind][mask];\\n        for(int i = mask; i > 0; i = mask & (i - 1)){\\n            if(cache[i] <= a[ind] && solve(ind + 1, mask ^ i))return dp[ind][mask] = true;\\n        }\\n         return dp[ind][mask] = solve(ind + 1, mask);\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        for(int i : nums)temp[i]++;\\n        \\n        for(int i = 0; i < 1001; ++i){\\n            if(temp[i])a.push_back(temp[i]);\\n        }\\n        n = a.size();\\n        int m = quantity.size();\\n        for(int i = 0; i < 51; ++i)for(int j = 0; j < 1025; ++j)dp[i][j] = true;\\n        for(int i = 0; i < (1 << m); ++i){\\n            for(int b = 0; b < m; ++b){\\n                if((i >> b) & 1)cache[i] += quantity[b];\\n            }\\n        }\\n        return solve(0, (1 << m) - 1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940645,
                "title": "python-slow-but-straightforward",
                "content": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n        X = list(Counter(nums).values())\\n        Q.sort(reverse = True)\\n        def help(X, j):\\n            if j == len(Q): return True\\n            for i, y in enumerate(X):\\n                if y >= Q[j] and help(X[:i] + [y - Q[j]] + X[i + 1:], j + 1): return True\\n            return False\\n        return help(X, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n        X = list(Counter(nums).values())\\n        Q.sort(reverse = True)\\n        def help(X, j):\\n            if j == len(Q): return True\\n            for i, y in enumerate(X):\\n                if y >= Q[j] and help(X[:i] + [y - Q[j]] + X[i + 1:], j + 1): return True\\n            return False\\n        return help(X, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935426,
                "title": "java-dp-bitmasking-faster-than-100-o-n-3-40ms-well-commented",
                "content": "```\\n//Complexity should be O (   m(10) * numPiles(50) * Max(num(i))(1000)   ) \\n\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n  HashMap<String, Boolean> dp;\\n  int target;\\n\\n  public boolean canDistribute(int[] nums, int[] quantity) {\\n\\n    dp = new HashMap<>();\\n    HashMap<Integer, Integer> hm = new HashMap<>();\\n    for (int n : nums) {\\n      hm.put(n, hm.getOrDefault(n, 0) + 1);\\n    }\\n\\n\\n    //Make a target bitmask when every customer is satisfied!\\n    target = 0;\\n    for (int i = 0; i < quantity.length; i++) {\\n      target |= (1 << i);\\n    }\\n\\n\\n    //Make an array that represent piles of the same integer\\n    int[] remaining = new int[hm.size()];\\n    ArrayList<Integer> ls = new ArrayList<>(hm.values());\\n    for (int i = 0; i < remaining.length; i++)\\n      remaining[i] = ls.get(i);\\n\\n\\n    return magic(0, 0, remaining[0], remaining, quantity);\\n  }\\n\\n\\n  boolean magic(int taken, int pos, int remain, int[] remaining, int[] quantity) {\\n\\n\\n    //Have satisfied all customers\\n    if (taken == target)\\n      return true;\\n\\n    //Exhausted all piles\\n    if (pos == remaining.length)\\n      return false;\\n\\n\\n    //Search if we have already computed.\\n    String key = pos + \" \" + taken + \" \" + remain;\\n    if (dp.containsKey(key))\\n      return dp.get(key);\\n\\n\\n    boolean ans = false;\\n    boolean found = false;\\n\\n\\n    //Brute force check if this pile can satisfy any customer, if yes then  reduce pile.\\n    for (int i = 0; i < quantity.length; i++) {\\n      if ((taken & (1 << i)) == 0 && quantity[i] <= remain) {\\n        found = true;\\n        //dont change pile and iterate for remaining, after satisfying this customer.\\n        ans |= magic(taken | (1 << i), pos, remain - quantity[i], remaining, quantity);\\n\\n        if (ans)\\n          break;\\n      }\\n    }\\n\\n    //change pile if this pile cannot satisfy anyone anymore and we haven\\'t reached the end!\\n    if (!found && pos + 1 < remaining.length) {\\n      ans |= magic(taken, pos + 1, remaining[pos + 1], remaining, quantity);\\n    }\\n    dp.put(key, ans);\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//Complexity should be O (   m(10) * numPiles(50) * Max(num(i))(1000)   ) \\n\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n  HashMap<String, Boolean> dp;\\n  int target;\\n\\n  public boolean canDistribute(int[] nums, int[] quantity) {\\n\\n    dp = new HashMap<>();\\n    HashMap<Integer, Integer> hm = new HashMap<>();\\n    for (int n : nums) {\\n      hm.put(n, hm.getOrDefault(n, 0) + 1);\\n    }\\n\\n\\n    //Make a target bitmask when every customer is satisfied!\\n    target = 0;\\n    for (int i = 0; i < quantity.length; i++) {\\n      target |= (1 << i);\\n    }\\n\\n\\n    //Make an array that represent piles of the same integer\\n    int[] remaining = new int[hm.size()];\\n    ArrayList<Integer> ls = new ArrayList<>(hm.values());\\n    for (int i = 0; i < remaining.length; i++)\\n      remaining[i] = ls.get(i);\\n\\n\\n    return magic(0, 0, remaining[0], remaining, quantity);\\n  }\\n\\n\\n  boolean magic(int taken, int pos, int remain, int[] remaining, int[] quantity) {\\n\\n\\n    //Have satisfied all customers\\n    if (taken == target)\\n      return true;\\n\\n    //Exhausted all piles\\n    if (pos == remaining.length)\\n      return false;\\n\\n\\n    //Search if we have already computed.\\n    String key = pos + \" \" + taken + \" \" + remain;\\n    if (dp.containsKey(key))\\n      return dp.get(key);\\n\\n\\n    boolean ans = false;\\n    boolean found = false;\\n\\n\\n    //Brute force check if this pile can satisfy any customer, if yes then  reduce pile.\\n    for (int i = 0; i < quantity.length; i++) {\\n      if ((taken & (1 << i)) == 0 && quantity[i] <= remain) {\\n        found = true;\\n        //dont change pile and iterate for remaining, after satisfying this customer.\\n        ans |= magic(taken | (1 << i), pos, remain - quantity[i], remaining, quantity);\\n\\n        if (ans)\\n          break;\\n      }\\n    }\\n\\n    //change pile if this pile cannot satisfy anyone anymore and we haven\\'t reached the end!\\n    if (!found && pos + 1 < remaining.length) {\\n      ans |= magic(taken, pos + 1, remaining[pos + 1], remaining, quantity);\\n    }\\n    dp.put(key, ans);\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704738,
                "title": "c-simple-recursion-and-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quantity,map<int,int>& cnt, int index ) {\\n        //base case\\n        if(index >= quantity.size()) {\\n            return true;\\n        }\\n        \\n        for(auto it = cnt.begin(); it != cnt.end(); it++) {\\n            if(it->second >= quantity[index]) {\\n                \\n                cnt[it->first] = cnt[it->first] - quantity[index];\\n                \\n                bool aageKaSol = solve(quantity, cnt, index+1);\\n                if(aageKaSol == true)\\n                    return true;\\n                //BT\\n                cnt[it->first] = cnt[it->first] + quantity[index];\\n            }\\n        }   \\n      return false;  \\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int> cnt;\\n        //step1: create freq array\\n        for(int i=0; i<nums.size(); i++) {\\n            cnt[nums[i]]++;\\n        }\\n        //step2: sort quantity desc\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        \\n        bool ans = solve(quantity, cnt, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quantity,map<int,int>& cnt, int index ) {\\n        //base case\\n        if(index >= quantity.size()) {\\n            return true;\\n        }\\n        \\n        for(auto it = cnt.begin(); it != cnt.end(); it++) {\\n            if(it->second >= quantity[index]) {\\n                \\n                cnt[it->first] = cnt[it->first] - quantity[index];\\n                \\n                bool aageKaSol = solve(quantity, cnt, index+1);\\n                if(aageKaSol == true)\\n                    return true;\\n                //BT\\n                cnt[it->first] = cnt[it->first] + quantity[index];\\n            }\\n        }   \\n      return false;  \\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int> cnt;\\n        //step1: create freq array\\n        for(int i=0; i<nums.size(); i++) {\\n            cnt[nums[i]]++;\\n        }\\n        //step2: sort quantity desc\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        \\n        bool ans = solve(quantity, cnt, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240816,
                "title": "90-faster-java-backtrack-solution",
                "content": "java code is:\\n# \\n```\\nclass Solution {\\n    boolean find(int index,int arr[],int quantity[]){\\n        if(index<0)return true;\\n        boolean t=false;\\n        // Use a set to make sure that we don\\'t distribute from the same amount to this index-th order for more than once.\\n        Set<Integer>set=new HashSet<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]<quantity[index]||set.contains(arr[i]))continue;\\n            set.add(arr[i]);\\n            arr[i]-=quantity[index];\\n            t=t||find(index-1,arr,quantity);\\n            if(t)return true;\\n            arr[i]+=quantity[index];\\n        }\\n        return t;\\n    }\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        Map<Integer,Integer>freq=new HashMap<>();\\n        for(int num : nums) freq.put(num,freq.getOrDefault(num,0)+1);\\n        int arr[]=new int[freq.size()];\\n        int i=0;\\n        for(int val : freq.values())\\n            arr[i++]=val;\\n         // If the bigger quantity can\\'t be filled, the program will stop as early as possible.\\n        Arrays.sort(quantity);\\n        return find(quantity.length-1,arr,quantity);\\n    }\\n}\\n```\\n**Please,Upvote if this is helpful**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    boolean find(int index,int arr[],int quantity[]){\\n        if(index<0)return true;\\n        boolean t=false;\\n        // Use a set to make sure that we don\\'t distribute from the same amount to this index-th order for more than once.\\n        Set<Integer>set=new HashSet<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]<quantity[index]||set.contains(arr[i]))continue;\\n            set.add(arr[i]);\\n            arr[i]-=quantity[index];\\n            t=t||find(index-1,arr,quantity);\\n            if(t)return true;\\n            arr[i]+=quantity[index];\\n        }\\n        return t;\\n    }\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        Map<Integer,Integer>freq=new HashMap<>();\\n        for(int num : nums) freq.put(num,freq.getOrDefault(num,0)+1);\\n        int arr[]=new int[freq.size()];\\n        int i=0;\\n        for(int val : freq.values())\\n            arr[i++]=val;\\n         // If the bigger quantity can\\'t be filled, the program will stop as early as possible.\\n        Arrays.sort(quantity);\\n        return find(quantity.length-1,arr,quantity);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103429,
                "title": "python3-backtracking",
                "content": "**Algo**\\nThis a very typical backtracking application with two pruning techniques: \\n1) dealing with large values first\\n2) skipping repetative numbers. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        freq = {}\\n        for x in nums: freq[x] = 1 + freq.get(x, 0)\\n        \\n        vals = sorted(freq.values(), reverse=True)\\n        quantity.sort(reverse=True) # pruning - large values first  \\n        \\n        def fn(i): \\n            \"\"\"Return True if possible to distribute quantity[i:] to remaining.\"\"\"\\n            if i == len(quantity): return True \\n            seen = set()\\n            for k in range(len(vals)): \\n                if vals[k] >= quantity[i] and vals[k] not in seen: \\n                    seen.add(vals[k]) # pruning - unqiue values \\n                    vals[k] -= quantity[i]\\n                    if fn(i+1): return True \\n                    vals[k] += quantity[i] # backtracking\\n                    \\n        return fn(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        freq = {}\\n        for x in nums: freq[x] = 1 + freq.get(x, 0)\\n        \\n        vals = sorted(freq.values(), reverse=True)\\n        quantity.sort(reverse=True) # pruning - large values first  \\n        \\n        def fn(i): \\n            \"\"\"Return True if possible to distribute quantity[i:] to remaining.\"\"\"\\n            if i == len(quantity): return True \\n            seen = set()\\n            for k in range(len(vals)): \\n                if vals[k] >= quantity[i] and vals[k] not in seen: \\n                    seen.add(vals[k]) # pruning - unqiue values \\n                    vals[k] -= quantity[i]\\n                    if fn(i+1): return True \\n                    vals[k] += quantity[i] # backtracking\\n                    \\n        return fn(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938666,
                "title": "java-bitmask-dp-enumerating-all-subsets",
                "content": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int x : nums) {\\n            cnt.merge(x, 1, Integer::sum);\\n        }\\n        int n = cnt.size();\\n        int m = quantity.length;\\n        int[] freq = new int[n];\\n        int j = 0;\\n        for (int val : cnt.values()) {\\n            freq[j] = val;\\n            j++;\\n        }\\n        boolean[][] dp = new boolean[n + 1][1 << m];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = true;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            for (int state = 1; state < 1 << m; state++) {\\n                if (dp[i - 1][state]) {\\n                    dp[i][state] = true;\\n                    continue;\\n                }\\n                for (int subset = state; subset > 0; subset = (subset - 1) & state) {\\n                    if (!dp[i - 1][state - subset]) {\\n                        continue;\\n                    }\\n                    if (satisfy(freq[i - 1], quantity, subset)) {\\n                        dp[i][state] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (dp[i][(1 << m) - 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean satisfy(int cnt, int[] quantity, int bitmask) {\\n        for (int i = 0; i < quantity.length; i++) {\\n            if (((bitmask >> i) & 1) == 1) {\\n                cnt -= quantity[i];\\n                if (cnt < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int x : nums) {\\n            cnt.merge(x, 1, Integer::sum);\\n        }\\n        int n = cnt.size();\\n        int m = quantity.length;\\n        int[] freq = new int[n];\\n        int j = 0;\\n        for (int val : cnt.values()) {\\n            freq[j] = val;\\n            j++;\\n        }\\n        boolean[][] dp = new boolean[n + 1][1 << m];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = true;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            for (int state = 1; state < 1 << m; state++) {\\n                if (dp[i - 1][state]) {\\n                    dp[i][state] = true;\\n                    continue;\\n                }\\n                for (int subset = state; subset > 0; subset = (subset - 1) & state) {\\n                    if (!dp[i - 1][state - subset]) {\\n                        continue;\\n                    }\\n                    if (satisfy(freq[i - 1], quantity, subset)) {\\n                        dp[i][state] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (dp[i][(1 << m) - 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean satisfy(int cnt, int[] quantity, int bitmask) {\\n        for (int i = 0; i < quantity.length; i++) {\\n            if (((bitmask >> i) & 1) == 1) {\\n                cnt -= quantity[i];\\n                if (cnt < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936472,
                "title": "elegant-clean-c-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> m ;\\n    bool ans = false ;\\n    vector<int> occurrences ;\\n    \\n    void f(vector<int>& qt,int i=0,int j=0){\\n        if (i==qt.size())  ans = true  ;\\n        if (ans) return  ;\\n        for (int k=j;k<occurrences.size();k++){\\n            if (qt[i]<=occurrences[k]){\\n                occurrences[k] = occurrences[k] - qt[i] ;\\n                f(qt,i+1,j) ;\\n                occurrences[k] = occurrences[k] + qt[i] ;\\n            }\\n        }\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& qt) {\\n        for (int i:nums) m[i]++ ;\\n        for (auto y = m.begin();y!=m.end();y++) occurrences.push_back(y->second) ;\\n        sort(occurrences.begin(),occurrences.end()) ;\\n        sort(qt.begin(),qt.end()) ;\\n        reverse(qt.begin(),qt.end()) ;\\n        f(qt) ;\\n        return ans ;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> m ;\\n    bool ans = false ;\\n    vector<int> occurrences ;\\n    \\n    void f(vector<int>& qt,int i=0,int j=0){\\n        if (i==qt.size())  ans = true  ;\\n        if (ans) return  ;\\n        for (int k=j;k<occurrences.size();k++){\\n            if (qt[i]<=occurrences[k]){\\n                occurrences[k] = occurrences[k] - qt[i] ;\\n                f(qt,i+1,j) ;\\n                occurrences[k] = occurrences[k] + qt[i] ;\\n            }\\n        }\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& qt) {\\n        for (int i:nums) m[i]++ ;\\n        for (auto y = m.begin();y!=m.end();y++) occurrences.push_back(y->second) ;\\n        sort(occurrences.begin(),occurrences.end()) ;\\n        sort(qt.begin(),qt.end()) ;\\n        reverse(qt.begin(),qt.end()) ;\\n        f(qt) ;\\n        return ans ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204208,
                "title": "backtracking-decreasing-sorting-c-easy-solution",
                "content": "# Intuition\\nSimple Backtracking problem where we check if we can take that number of tasks to the n person or not !!\\n# Approach\\nBacktracking + Sorting \\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn+n)\\n\\n- Space complexity:\\n0(n) where n is number of unique elements in the array\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool solve(vector<int>&q,map<int,int>&cnt,int index){\\nif(index==q.size()){\\nreturn true;\\n}\\nfor(auto it=cnt.begin();it!=cnt.end();it++){\\nif(it->second>=q[index]){\\ncnt[it->first]=cnt[it->first]-q[index];\\nbool agee_kasol=solve(q,cnt,index+1);\\nif(agee_kasol==true)\\nreturn true;\\ncnt[it->first]=cnt[it->first]+q[index];\\n}\\n}\\nreturn false;\\n}\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {   \\nmap<int,int>cnt;\\nfor(int i=0;i<nums.size();i++)\\ncnt[nums[i]]++;\\n\\nsort(quantity.begin(),quantity.end(),greater<int>());\\n\\nbool ans=solve(quantity,cnt,0);\\nreturn ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool solve(vector<int>&q,map<int,int>&cnt,int index){\\nif(index==q.size()){\\nreturn true;\\n}\\nfor(auto it=cnt.begin();it!=cnt.end();it++){\\nif(it->second>=q[index]){\\ncnt[it->first]=cnt[it->first]-q[index];\\nbool agee_kasol=solve(q,cnt,index+1);\\nif(agee_kasol==true)\\nreturn true;\\ncnt[it->first]=cnt[it->first]+q[index];\\n}\\n}\\nreturn false;\\n}\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {   \\nmap<int,int>cnt;\\nfor(int i=0;i<nums.size();i++)\\ncnt[nums[i]]++;\\n\\nsort(quantity.begin(),quantity.end(),greater<int>());\\n\\nbool ans=solve(quantity,cnt,0);\\nreturn ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967275,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quant,   map<int,int>&cnt,int i)\\n    {\\n        if(i==quant.size())\\n        {\\n            return true;\\n        }\\n        for (auto it=cnt.begin(); it!=cnt.end(); it++)\\n        {\\n            if(it->second>=quant[i])\\n            {\\n               cnt[it->first] = cnt[it->first] - quant[i];\\n                bool aage= solve(quant,cnt,i+1);\\n                if(aage)\\n                {\\n                    return true;\\n                }else{\\n                      cnt[it->first] = cnt[it->first] +quant[i];\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quant) {\\n        // Step1:\\n        map<int,int>cnt;\\n       for(auto x:nums)\\n        {\\n            cnt[x]++;\\n        }\\n        \\n      // Step2 :\\n        sort(quant.begin(),quant.end(),greater<int>());\\n        \\n      bool ans =solve(quant,cnt,0);  \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quant,   map<int,int>&cnt,int i)\\n    {\\n        if(i==quant.size())\\n        {\\n            return true;\\n        }\\n        for (auto it=cnt.begin(); it!=cnt.end(); it++)\\n        {\\n            if(it->second>=quant[i])\\n            {\\n               cnt[it->first] = cnt[it->first] - quant[i];\\n                bool aage= solve(quant,cnt,i+1);\\n                if(aage)\\n                {\\n                    return true;\\n                }else{\\n                      cnt[it->first] = cnt[it->first] +quant[i];\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quant) {\\n        // Step1:\\n        map<int,int>cnt;\\n       for(auto x:nums)\\n        {\\n            cnt[x]++;\\n        }\\n        \\n      // Step2 :\\n        sort(quant.begin(),quant.end(),greater<int>());\\n        \\n      bool ans =solve(quant,cnt,0);  \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283414,
                "title": "why-is-this-solution-giving-tle-as-verdict",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool func(int idx,vector<int>&mp,vector<int>& quantity, map<pair<int,vector<int>>,bool>&dp){\\n        int cnt = 0;\\n        if(idx==quantity.size()){\\n            return true;\\n        }\\n        \\n        if(dp.find({idx,mp})!=dp.end()){\\n            return dp[{idx,mp}];\\n        }\\n        int f = 0;\\n        int res = false;\\n        for(int i = 0;i<mp.size();i++){\\n            if(i>0 && mp[i]==mp[i-1]){\\n                continue;\\n            }\\n            else if(mp[i]>=quantity[idx]){\\n                f=1;\\n                mp[i]-=quantity[idx];\\n                if(func(idx+1, mp, quantity,dp)){\\n                    return dp[{idx,mp}] = true;\\n                }\\n                mp[i]+=quantity[idx];\\n            }\\n        }\\n        if(!f){\\n            return dp[{idx,mp}] = false;\\n        }\\n        else{\\n            return dp[{idx,mp}] = res;\\n        }\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int>mp2;\\n        for(auto x:nums){\\n            mp2[x]++;\\n        }\\n        vector<int>mp;\\n        for(auto x:mp2){\\n            mp.push_back(x.second);\\n        }\\n        map<pair<int,vector<int>>,bool>dp;\\n        return func(0,mp,quantity,dp);\\n    }\\n};\\n```\\nPlease lmk. Thanks in advance!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool func(int idx,vector<int>&mp,vector<int>& quantity, map<pair<int,vector<int>>,bool>&dp){\\n        int cnt = 0;\\n        if(idx==quantity.size()){\\n            return true;\\n        }\\n        \\n        if(dp.find({idx,mp})!=dp.end()){\\n            return dp[{idx,mp}];\\n        }\\n        int f = 0;\\n        int res = false;\\n        for(int i = 0;i<mp.size();i++){\\n            if(i>0 && mp[i]==mp[i-1]){\\n                continue;\\n            }\\n            else if(mp[i]>=quantity[idx]){\\n                f=1;\\n                mp[i]-=quantity[idx];\\n                if(func(idx+1, mp, quantity,dp)){\\n                    return dp[{idx,mp}] = true;\\n                }\\n                mp[i]+=quantity[idx];\\n            }\\n        }\\n        if(!f){\\n            return dp[{idx,mp}] = false;\\n        }\\n        else{\\n            return dp[{idx,mp}] = res;\\n        }\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int>mp2;\\n        for(auto x:nums){\\n            mp2[x]++;\\n        }\\n        vector<int>mp;\\n        for(auto x:mp2){\\n            mp.push_back(x.second);\\n        }\\n        map<pair<int,vector<int>>,bool>dp;\\n        return func(0,mp,quantity,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781767,
                "title": "java-simple-clean-code-99-fast-backtrack",
                "content": "In this solution, quantity is sorted and duplicate operations are avoided. Another takeway is the \"copyOfRange\" method in Arrays.\\n\\n```\\npublic boolean canDistribute(int[] nums, int[] quantity) {\\n    int[] counter = count(nums);\\n    Arrays.sort(quantity);\\n\\t\\n    return dfs(counter, quantity, quantity.length - 1);\\n  }\\n\\n  private boolean dfs(int[] counter, int[] quantity, int quantityId) {\\n    if(quantityId < 0) return true;\\n\\n    for(int i = 0; i < counter.length; i++){\\n      if(i > 0 && counter[i] == counter[i-1]) continue;\\n\\n      if(counter[i] >= quantity[quantityId]){\\n        counter[i] -= quantity[quantityId];\\n        if(dfs(counter, quantity, quantityId - 1))\\n          return true;\\n        counter[i] += quantity[quantityId];\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  private int[] count(int[] nums){\\n    int[] counter = new int[1001];\\n    for(int n : nums){\\n      counter[n]++;\\n    }\\n\\n    Arrays.sort(counter);\\n    return Arrays.copyOfRange(counter, counter.length - 50, counter.length);\\n  }\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "In this solution, quantity is sorted and duplicate operations are avoided. Another takeway is the \"copyOfRange\" method in Arrays.\\n\\n```\\npublic boolean canDistribute(int[] nums, int[] quantity) {\\n    int[] counter = count(nums);\\n    Arrays.sort(quantity);\\n\\t\\n    return dfs(counter, quantity, quantity.length - 1);\\n  }\\n\\n  private boolean dfs(int[] counter, int[] quantity, int quantityId) {\\n    if(quantityId < 0) return true;\\n\\n    for(int i = 0; i < counter.length; i++){\\n      if(i > 0 && counter[i] == counter[i-1]) continue;\\n\\n      if(counter[i] >= quantity[quantityId]){\\n        counter[i] -= quantity[quantityId];\\n        if(dfs(counter, quantity, quantityId - 1))\\n          return true;\\n        counter[i] += quantity[quantityId];\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  private int[] count(int[] nums){\\n    int[] counter = new int[1001];\\n    for(int n : nums){\\n      counter[n]++;\\n    }\\n\\n    Arrays.sort(counter);\\n    return Arrays.copyOfRange(counter, counter.length - 50, counter.length);\\n  }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1710389,
                "title": "easy-peasy-backtracking-solution-c",
                "content": "class Solution {\\npublic:\\n\\n    map<int,int> mp;\\n    bool fun(vector<int> &quantity, vector<int> &arr, int idx)\\n    {\\n        if(idx==quantity.size())\\n        {\\n            return true;\\n        }\\n        for(int i=0; i<arr.size();i++)\\n        {\\n            if(i>0 && arr[i]==arr[i-1]) //skip the elements on which we have already made a function call\\n                continue;\\n            if(arr[i]>=quantity[idx]) \\n            {\\n                arr[i]-=quantity[idx]; //either we pick nums[i]\\n                if(fun(quantity,arr,idx+1))\\n                    return true;\\n                arr[i]+=quantity[idx]; //or not\\n            }\\n        }\\n        return false;\\n       }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n       \\n        for(int i=0;i<nums.size();i++)\\n        {\\n           mp[nums[i]]++;\\n        }\\n        vector<int> arr;  \\n        for(auto x:mp)\\n            arr.push_back(x.second);\\n        return fun(quantity,arr,0);\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    map<int,int> mp;\\n    bool fun(vector<int> &quantity, vector<int> &arr, int idx)\\n    {\\n        if(idx==quantity.size())\\n        {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1710275,
                "title": "best-java-solution-100",
                "content": "class Solution\\n{\\n  public boolean canDistribute (int[]nums, int[]quantity)\\n  {\\n    int n = quantity.length;\\n      Arrays.sort (quantity);\\n    for (int i = 0; i < n / 2; i++)\\n      {\\n\\tint temp = quantity[i];\\n\\t  quantity[i] = quantity[n - i - 1];\\n\\n\\t  quantity[n - i - 1] = temp;\\n      }\\n    // In upper section sort and reverse quantity    \\n    int r[] = new int[1001];\\n    Arrays.fill (r, 0);\\n    int count = 1;\\n    for (int i = 0; i < nums.length; i++)\\n      {\\n\\tr[nums[i]]++;\\n      }\\n\\n    for (int i = 0; i < quantity.length; i++)\\n      {\\n\\tint j = 0, k = 0, l = 0;\\n\\n\\tfor (j = 1; j < r.length; j++)  //case 1 loop\\n\\t  {\\n\\n\\t    if (quantity[i] == r[j])\\n\\t      {\\n\\t\\tr[j] = 0;\\n\\n\\t\\tbreak;\\n\\t      }\\n\\t  }\\n\\tif (j == r.length)\\n\\t  {\\n\\t    for (k = 1; k < r.length; k++)     //case 2 loop\\n\\t      {\\n\\t\\tif (quantity[i] < r[k])\\n\\t\\t  {\\n\\t\\t    if (r[k] != 0 && (r[k] % quantity[i]) == 0)\\n\\t\\t      {\\n\\n\\t\\t\\tr[k] = (r[k] - quantity[i]);\\n\\n\\t\\t\\tbreak;\\n\\t\\t      }\\n\\t\\t  }\\n\\t      }\\n\\t  }\\n\\tif (k == r.length)\\n\\t  {\\n\\t    for (l = 1; l < r.length; l++)    //case 3 loop\\n\\t      {\\n\\t\\tif (quantity[i] < r[l])\\n\\t\\t  {\\n\\t\\t    r[l] -= quantity[i];\\n\\n\\t\\t    break;\\n\\t\\t  }\\n\\t      }\\n\\t  }\\n\\tif (j == r.length && k == r.length && l == r.length)\\n\\t  {\\n\\t    return false;\\n\\t  }\\n      }\\n    return true;\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution\\n{\\n  public boolean canDistribute (int[]nums, int[]quantity)\\n  {\\n    int n = quantity.length;\\n      Arrays.sort (quantity);\\n    for (int i = 0; i < n / 2; i++)\\n      {\\n\\tint temp = quantity[i];\\n\\t  quantity[i] = quantity[n - i - 1];\\n\\n\\t  quantity[n - i - 1] = temp;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1560161,
                "title": "java-9-ms-26-lines-dfs-beat-95",
                "content": "```\\npublic boolean canDistribute(int[] nums, int[] quantity) {\\n\\tint[] count = new int[1001];\\n\\tfor (int num : nums)\\n\\t\\t++count[num];\\n\\tArrays.sort(quantity);\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tfor (int num : count)\\n\\t\\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n\\treturn dfs(quantity, map, quantity.length - 1);\\n}\\n\\nprivate boolean dfs(int[] quantity, Map<Integer, Integer> map, int curr) {\\n\\tif (curr == -1)\\n\\t\\treturn true;\\n\\tfor (int key : new HashSet<>(map.keySet()))\\n\\t\\tif (key >= quantity[curr]) {\\n\\t\\t\\tmap.put(key, map.get(key) - 1);\\n\\t\\t\\tmap.remove(key, 0);\\n\\t\\t\\tmap.put(key - quantity[curr], map.getOrDefault(key - quantity[curr], 0) + 1);\\n\\t\\t\\tif (dfs(quantity, map, curr - 1))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tmap.put(key - quantity[curr], map.get(key - quantity[curr]) - 1);\\n\\t\\t\\tmap.remove(key - quantity[curr], 0);\\n\\t\\t\\tmap.put(key, map.getOrDefault(key, 0) + 1);\\n\\t\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canDistribute(int[] nums, int[] quantity) {\\n\\tint[] count = new int[1001];\\n\\tfor (int num : nums)\\n\\t\\t++count[num];\\n\\tArrays.sort(quantity);\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tfor (int num : count)\\n\\t\\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n\\treturn dfs(quantity, map, quantity.length - 1);\\n}\\n\\nprivate boolean dfs(int[] quantity, Map<Integer, Integer> map, int curr) {\\n\\tif (curr == -1)\\n\\t\\treturn true;\\n\\tfor (int key : new HashSet<>(map.keySet()))\\n\\t\\tif (key >= quantity[curr]) {\\n\\t\\t\\tmap.put(key, map.get(key) - 1);\\n\\t\\t\\tmap.remove(key, 0);\\n\\t\\t\\tmap.put(key - quantity[curr], map.getOrDefault(key - quantity[curr], 0) + 1);\\n\\t\\t\\tif (dfs(quantity, map, curr - 1))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tmap.put(key - quantity[curr], map.get(key - quantity[curr]) - 1);\\n\\t\\t\\tmap.remove(key - quantity[curr], 0);\\n\\t\\t\\tmap.put(key, map.getOrDefault(key, 0) + 1);\\n\\t\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1489459,
                "title": "simple-dfs-with-bitmasking",
                "content": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        \\n        arr=[0]*(1001)\\n        for i in nums:\\n            arr[i]+=1\\n            \\n        arr.sort(reverse=True)\\n        #print(arr)\\n        arr=arr[:10]\\n        dict={}\\n        def dfs(ind,arr):\\n            if ind==m:\\n                return True\\n            if (ind,tuple(arr)) in dict:\\n                return dict[(ind,tuple(arr))]\\n            \\n            for i in range(0,10):\\n                if arr[i]>=quantity[ind]:\\n                    arr[i]-=quantity[ind]\\n                    a=dfs(ind+1,arr)\\n                    arr[i]+=quantity[ind]\\n                    if a:\\n                        dict[(ind,tuple(arr))]=True\\n                        \\n                        return True\\n                    \\n            dict[(ind,tuple(arr))]=False\\n            return False\\n        m=len(quantity)\\n        return dfs(0,arr)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        \\n        arr=[0]*(1001)\\n        for i in nums:\\n            arr[i]+=1\\n            \\n        arr.sort(reverse=True)\\n        #print(arr)\\n        arr=arr[:10]\\n        dict={}",
                "codeTag": "Java"
            },
            {
                "id": 1293102,
                "title": "python-bfs-bitmask",
                "content": "```\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        # BFS bismask\\n        # Time: O(3^m) \\n\\t\\t# ref : https://cp-algorithms.com/algebra/all-submasks.html\\n        \\n        counts = sorted(\\n            Counter(nums).values(),\\n            reverse = True\\n        )[:len(quantity)]\\n        N, M = len(counts), len(quantity)\\n        \\n        subsums = [0] * (1 << M)\\n        for mask in range(1 << M):\\n            for i in range(M):\\n                if mask & (1 << i):\\n                    subsums[mask] += quantity[i]\\n        \\n        # q is reachable masks (of satisfied customers) in level i (counts[:i] have been exhausted)\\n        q = {0}\\n        for i in range(N):\\n            q_next = set()\\n            for mask in q:\\n                not_mask = ((1 << M) - 1) ^ mask\\n                submask = not_mask\\n                while submask:\\n                    if subsums[submask] <= counts[i]:\\n                        next_mask = mask | submask\\n                        if next_mask == (1 << M) - 1:\\n                            return True\\n                        q_next.add(next_mask)\\n                    submask = (submask - 1) & not_mask\\n            q = q_next\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Bitmask"
                ],
                "code": "```\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        # BFS bismask\\n        # Time: O(3^m) \\n\\t\\t# ref : https://cp-algorithms.com/algebra/all-submasks.html\\n        \\n        counts = sorted(\\n            Counter(nums).values(),\\n            reverse = True\\n        )[:len(quantity)]\\n        N, M = len(counts), len(quantity)\\n        \\n        subsums = [0] * (1 << M)\\n        for mask in range(1 << M):\\n            for i in range(M):\\n                if mask & (1 << i):\\n                    subsums[mask] += quantity[i]\\n        \\n        # q is reachable masks (of satisfied customers) in level i (counts[:i] have been exhausted)\\n        q = {0}\\n        for i in range(N):\\n            q_next = set()\\n            for mask in q:\\n                not_mask = ((1 << M) - 1) ^ mask\\n                submask = not_mask\\n                while submask:\\n                    if subsums[submask] <= counts[i]:\\n                        next_mask = mask | submask\\n                        if next_mask == (1 << M) - 1:\\n                            return True\\n                        q_next.add(next_mask)\\n                    submask = (submask - 1) & not_mask\\n            q = q_next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1110578,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>&q, map<int,int>&count, int idx){\\n        if(idx==q.size()){\\n            return true;\\n        }\\n        for(auto it=count.begin();it!=count.end();it++){\\n            if(it->second>=q[idx]){\\n                count[it->first]-=q[idx];\\n                if(solve(q,count,idx+1))\\n                    return true;\\n                count[it->first]+=q[idx];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int>count;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            count[nums[i]]++;\\n        }\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n        return solve(quantity,count,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>&q, map<int,int>&count, int idx){\\n        if(idx==q.size()){\\n            return true;\\n        }\\n        for(auto it=count.begin();it!=count.end();it++){\\n            if(it->second>=q[idx]){\\n                count[it->first]-=q[idx];\\n                if(solve(q,count,idx+1))\\n                    return true;\\n                count[it->first]+=q[idx];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int>count;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            count[nums[i]]++;\\n        }\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n        return solve(quantity,count,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084121,
                "title": "c-dfs",
                "content": "sort quantity in descending order.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> mp;\\n        for(auto a: nums) mp[a]++;\\n        \\n        \\n        vector<int> cnt;\\n        for(auto& [k, v] : mp) cnt.push_back(v);\\n        \\n        \\n        priority_queue<int> pq;\\n        for(auto a : cnt) {\\n            if(a > 0) pq.push(a);\\n        }\\n        sort(quantity.begin(), quantity.end(), [](int& a, int&b) { return a > b;});\\n\\n        return helper(cnt, quantity, 0);\\n    }\\n    \\n    bool helper(vector<int>& cnt, vector<int>& quantity, int pos) {\\n        if(pos == quantity.size()) return true;\\n        \\n        for(int i=0; i<cnt.size(); ++i) {\\n            int cur = cnt[i];\\n            if(cur >= quantity[pos]) {\\n                cnt[i] = cur - quantity[pos];\\n                if(helper(cnt, quantity, pos+1)) return true;\\n                cnt[i] = cur;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> mp;\\n        for(auto a: nums) mp[a]++;\\n        \\n        \\n        vector<int> cnt;\\n        for(auto& [k, v] : mp) cnt.push_back(v);\\n        \\n        \\n        priority_queue<int> pq;\\n        for(auto a : cnt) {\\n            if(a > 0) pq.push(a);\\n        }\\n        sort(quantity.begin(), quantity.end(), [](int& a, int&b) { return a > b;});\\n\\n        return helper(cnt, quantity, 0);\\n    }\\n    \\n    bool helper(vector<int>& cnt, vector<int>& quantity, int pos) {\\n        if(pos == quantity.size()) return true;\\n        \\n        for(int i=0; i<cnt.size(); ++i) {\\n            int cur = cnt[i];\\n            if(cur >= quantity[pos]) {\\n                cnt[i] = cur - quantity[pos];\\n                if(helper(cnt, quantity, pos+1)) return true;\\n                cnt[i] = cur;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962695,
                "title": "dfs-solution",
                "content": "First of all, we create a map mapping the repeat time to the number of integers repeated that time in the array. For example, for array [1,1,2,3], the map is {2:1, 1: 2}. Then, for each customer order, we need to choose the integer, from the integers repeating more than the order quantity, to satisfy his order. As long as each customer\\'s order is satisfied, we are able to distribute the array. One way to determine is by considering all possible distributions. As long as one of distribution satisfy the conditions, it is ok. This is backtracing. \\n```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        def dfs(idx):\\n            if idx >= len(quantity):\\n                return True\\n            repeat_array = list(repeat_map.keys())\\n            for r in repeat_array:\\n                # we can use certain integer, repeated r times, \\n                # satisfy the order\\n                if r >= quantity[idx]:\\n                    # update the map after the order is satisfied\\n                    repeat_map[r] -= 1\\n                    if repeat_map[r] == 0:\\n                        del repeat_map[r]\\n                    repeat_map[r-quantity[idx]] = repeat_map.get(r-quantity[idx],0)+1\\n                    if dfs(idx+1):\\n                        return True\\n                    # recover to the original state\\n                    repeat_map[r-quantity[idx]] -= 1\\n                    if repeat_map[r-quantity[idx]] == 0:\\n                        del repeat_map[r-quantity[idx]]\\n                    repeat_map[r] = repeat_map.get(r, 0)+1\\n            return False\\n        \\n        \\n        num_map = [0]*1001\\n        for n in nums:\\n            num_map[n] += 1\\n        # map repeat time to the number of integers repeated exactly that time. \\n        repeat_map = {}\\n        for n in num_map:\\n            repeat_map[n] = repeat_map.get(n, 0)+1\\n        if dfs(0):\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        def dfs(idx):\\n            if idx >= len(quantity):\\n                return True\\n            repeat_array = list(repeat_map.keys())\\n            for r in repeat_array:\\n                # we can use certain integer, repeated r times, \\n                # satisfy the order\\n                if r >= quantity[idx]:\\n                    # update the map after the order is satisfied\\n                    repeat_map[r] -= 1\\n                    if repeat_map[r] == 0:\\n                        del repeat_map[r]\\n                    repeat_map[r-quantity[idx]] = repeat_map.get(r-quantity[idx],0)+1\\n                    if dfs(idx+1):\\n                        return True\\n                    # recover to the original state\\n                    repeat_map[r-quantity[idx]] -= 1\\n                    if repeat_map[r-quantity[idx]] == 0:\\n                        del repeat_map[r-quantity[idx]]\\n                    repeat_map[r] = repeat_map.get(r, 0)+1\\n            return False\\n        \\n        \\n        num_map = [0]*1001\\n        for n in nums:\\n            num_map[n] += 1\\n        # map repeat time to the number of integers repeated exactly that time. \\n        repeat_map = {}\\n        for n in num_map:\\n            repeat_map[n] = repeat_map.get(n, 0)+1\\n        if dfs(0):\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942307,
                "title": "c-backtracking-greedy-with-some-optimizations-beat-99",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<int>& freq, vector<int>& q, int index) {\\n        if (index >= q.size()) return true;\\n        \\n        int j = 0;\\n        for (int i = 0; i < freq.size(); i = j) {\\n            // Optimization 2: reduce double count.\\n            for (j = i; j < freq.size() && freq[j] == freq[i]; j++);\\n            \\n            if (q[index] > freq[i]) continue;\\n            freq[i] -= q[index];\\n            if (dfs(freq, q, index + 1)) {\\n                return true;\\n            }\\n            freq[i] += q[index];\\n        } \\n        \\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int total = 0;\\n        for (auto q: quantity) total += q;\\n        if (total > nums.size()) return false;\\n        \\n        unordered_map<int, int> m1;\\n        for (auto n: nums) m1[n]++;\\n        vector<int> freq;\\n        for (auto it: m1) freq.push_back(it.second);\\n        \\n        // Optimization 1: Greedy, start from the large integer.\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        sort(freq.begin(), freq.end(), greater<int>());\\n        return dfs(freq, quantity, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<int>& freq, vector<int>& q, int index) {\\n        if (index >= q.size()) return true;\\n        \\n        int j = 0;\\n        for (int i = 0; i < freq.size(); i = j) {\\n            // Optimization 2: reduce double count.\\n            for (j = i; j < freq.size() && freq[j] == freq[i]; j++);\\n            \\n            if (q[index] > freq[i]) continue;\\n            freq[i] -= q[index];\\n            if (dfs(freq, q, index + 1)) {\\n                return true;\\n            }\\n            freq[i] += q[index];\\n        } \\n        \\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int total = 0;\\n        for (auto q: quantity) total += q;\\n        if (total > nums.size()) return false;\\n        \\n        unordered_map<int, int> m1;\\n        for (auto n: nums) m1[n]++;\\n        vector<int> freq;\\n        for (auto it: m1) freq.push_back(it.second);\\n        \\n        // Optimization 1: Greedy, start from the large integer.\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        sort(freq.begin(), freq.end(), greater<int>());\\n        return dfs(freq, quantity, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936501,
                "title": "java-dp-bottom-up-bitmasking-o-n-3-m-time-complexity",
                "content": "```\\n/*\\nTime Complexity = O(N * (3 ^ M)) where N = \\'unique values\\' in nums ( = 50), M = size of \\'quantity\\'\\n*/\\n\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int rows = 0, cols = quantity.length;\\n        Map<Integer, Integer> frequencyByNumber = new HashMap<Integer, Integer>();\\n        for(int i = 0; i < nums.length; i++) {\\n            frequencyByNumber.put(nums[i], 1 + frequencyByNumber.getOrDefault(nums[i], 0));\\n        }\\n        List<Integer> numbers = new ArrayList<Integer>(frequencyByNumber.keySet());\\n        rows = numbers.size();\\n        int[] requirement = new int[(1 << cols)];\\n        for(int mask = 0; mask < (1 << cols); mask++) {\\n            for(int i = 0; i < cols; i++) {\\n                if((mask & (1 << i)) != 0) {\\n                    requirement[mask] += quantity[i];\\n                }\\n            }\\n        }\\n        boolean[][] DP = new boolean[rows + 1][(1 << cols)];\\n        DP[0][0] = true;\\n        for(int i = 0; i < rows; i++) {\\n            for(int mask = ((1 << cols) - 1); mask >= 0; mask--) {\\n                DP[i + 1][mask] = DP[i + 1][mask] || DP[i][mask];\\n                for(int subMask = mask; subMask > 0; subMask = ((subMask - 1) & mask)) {\\n                    if(requirement[subMask] <= frequencyByNumber.get(numbers.get(i)) && DP[i][mask ^ subMask]) {\\n                        DP[i + 1][mask] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return DP[rows][(1 << cols) - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nTime Complexity = O(N * (3 ^ M)) where N = \\'unique values\\' in nums ( = 50), M = size of \\'quantity\\'\\n*/\\n\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int rows = 0, cols = quantity.length;\\n        Map<Integer, Integer> frequencyByNumber = new HashMap<Integer, Integer>();\\n        for(int i = 0; i < nums.length; i++) {\\n            frequencyByNumber.put(nums[i], 1 + frequencyByNumber.getOrDefault(nums[i], 0));\\n        }\\n        List<Integer> numbers = new ArrayList<Integer>(frequencyByNumber.keySet());\\n        rows = numbers.size();\\n        int[] requirement = new int[(1 << cols)];\\n        for(int mask = 0; mask < (1 << cols); mask++) {\\n            for(int i = 0; i < cols; i++) {\\n                if((mask & (1 << i)) != 0) {\\n                    requirement[mask] += quantity[i];\\n                }\\n            }\\n        }\\n        boolean[][] DP = new boolean[rows + 1][(1 << cols)];\\n        DP[0][0] = true;\\n        for(int i = 0; i < rows; i++) {\\n            for(int mask = ((1 << cols) - 1); mask >= 0; mask--) {\\n                DP[i + 1][mask] = DP[i + 1][mask] || DP[i][mask];\\n                for(int subMask = mask; subMask > 0; subMask = ((subMask - 1) & mask)) {\\n                    if(requirement[subMask] <= frequencyByNumber.get(numbers.get(i)) && DP[i][mask ^ subMask]) {\\n                        DP[i + 1][mask] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return DP[rows][(1 << cols) - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936159,
                "title": "java-intuitive-recursive-solution-trying-all-possibilities-76ms",
                "content": "It does\\'t matter which numbers we give out. It is the frequencies of numbers that tell whether we can give out that particular number or not. \\n\\nThe key for this to get accepted is processing quantity requests in decreasing order.\\n\\n```\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        // frequency of numbers in nums array\\n        int[] freq = new int[1001]; // 1 <= nums[i] <= 1000\\n        int count = 0;\\n        for (int num : nums) {\\n            freq[num]++;\\n            if (freq[num] == 1) count++;\\n        }\\n        \\n        // stores frequencies of unique numbers appearing in nums.\\n        int[] numFreq = new int[count];\\n        int idx = 0;\\n        for (int i = 0; i < freq.length; i++) {\\n            if (freq[i] == 0) continue; // i didn\\'t occur in nums array.\\n            numFreq[idx++] = freq[i];\\n        }\\n        \\n        // without this sort, we get TLE. couldn\\'t figure this during contest. damn it!\\n        // Processing large quantity requests first reduces recursion tree size.\\n        Arrays.sort(quantity);\\n        // Java doesn\\'t have sort ints in decreasing order. So, we will process from end.\\n        return distribute(numFreq, quantity, quantity.length-1);\\n    }\\n    \\n    private boolean distribute(int[] numFreq, int[] quantity, int idx) {\\n        // try all num frequencies which can satisfy quantity[idx]\\n        boolean result = false;\\n        for (int i = 0; i < numFreq.length; i++) {\\n            if (numFreq[i] >= quantity[idx]) {\\n                numFreq[i] -= quantity[idx];\\n                result = idx == 0 ? true : distribute(numFreq, quantity, idx-1);\\n                if (result) break;\\n                numFreq[i] += quantity[idx]; // backtrack. it didn\\'t work.\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        // frequency of numbers in nums array\\n        int[] freq = new int[1001]; // 1 <= nums[i] <= 1000\\n        int count = 0;\\n        for (int num : nums) {\\n            freq[num]++;\\n            if (freq[num] == 1) count++;\\n        }\\n        \\n        // stores frequencies of unique numbers appearing in nums.\\n        int[] numFreq = new int[count];\\n        int idx = 0;\\n        for (int i = 0; i < freq.length; i++) {\\n            if (freq[i] == 0) continue; // i didn\\'t occur in nums array.\\n            numFreq[idx++] = freq[i];\\n        }\\n        \\n        // without this sort, we get TLE. couldn\\'t figure this during contest. damn it!\\n        // Processing large quantity requests first reduces recursion tree size.\\n        Arrays.sort(quantity);\\n        // Java doesn\\'t have sort ints in decreasing order. So, we will process from end.\\n        return distribute(numFreq, quantity, quantity.length-1);\\n    }\\n    \\n    private boolean distribute(int[] numFreq, int[] quantity, int idx) {\\n        // try all num frequencies which can satisfy quantity[idx]\\n        boolean result = false;\\n        for (int i = 0; i < numFreq.length; i++) {\\n            if (numFreq[i] >= quantity[idx]) {\\n                numFreq[i] -= quantity[idx];\\n                result = idx == 0 ? true : distribute(numFreq, quantity, idx-1);\\n                if (result) break;\\n                numFreq[i] += quantity[idx]; // backtrack. it didn\\'t work.\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935541,
                "title": "java-backtracking-324-ms-faster-than-80-00-54-3-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int m = nums.length;\\n        int n = quantity.length;\\n        Map<Integer, Integer> cnts = new HashMap<>();\\n        for (int num : nums) {\\n            cnts.put(num, cnts.getOrDefault(num, 0) + 1);\\n        }\\n        Arrays.sort(quantity);\\n        return dfs(new ArrayList<>(cnts.values()), quantity.length - 1, quantity);\\n    }\\n\\n    private boolean dfs(List<Integer> cnts, int pos, int[] quantity) {\\n        if (pos < 0) {\\n            return true;\\n        }\\n        for (int i = 0; i < cnts.size(); ++i) {\\n            if (cnts.get(i) >= quantity[pos]) {\\n                cnts.set(i, cnts.get(i) - quantity[pos]);\\n                if (dfs(cnts, pos - 1, quantity)) {\\n                    return true;\\n                }\\n                cnts.set(i, cnts.get(i) + quantity[pos]);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int m = nums.length;\\n        int n = quantity.length;\\n        Map<Integer, Integer> cnts = new HashMap<>();\\n        for (int num : nums) {\\n            cnts.put(num, cnts.getOrDefault(num, 0) + 1);\\n        }\\n        Arrays.sort(quantity);\\n        return dfs(new ArrayList<>(cnts.values()), quantity.length - 1, quantity);\\n    }\\n\\n    private boolean dfs(List<Integer> cnts, int pos, int[] quantity) {\\n        if (pos < 0) {\\n            return true;\\n        }\\n        for (int i = 0; i < cnts.size(); ++i) {\\n            if (cnts.get(i) >= quantity[pos]) {\\n                cnts.set(i, cnts.get(i) - quantity[pos]);\\n                if (dfs(cnts, pos - 1, quantity)) {\\n                    return true;\\n                }\\n                cnts.set(i, cnts.get(i) + quantity[pos]);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935492,
                "title": "c-backtrack-backtrack-with-explanation",
                "content": "The algorithm consists of:\\n1) Counting the occurance of each number in input array;\\n2) Leave only ```quantity.size()``` amount of the most frequently met numbers;\\n3) Sort quantity in descending order for better performance;\\n4) Run backtrack;\\n5) Return true, if backtrack found at least 1 solution, otherwise return false.\\n```\\nclass Solution {\\npublic:\\n    bool backtrack(vector<int> &n, const vector<int> &q, int k) {\\n        if (k == q.size())\\n            return true;  // All customers are satisfied\\n        for (int i = 0; i < n.size(); ++i) {\\n            if (n[i] >= q[k]) {\\n                n[i] -= q[k];  \\n                if (backtrack(n, q, k + 1)) {  // Trying to satisfy next customer\\n                    return true;\\n                }\\n                n[i] += q[k];\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& n, vector<int>& q) {\\n        if (q.size() == 0) {\\n            return true;\\n        }\\n\\t\\t// Calculate repeated nums\\n\\t\\tvector<int> count(1001, 0);\\n        for (int i = 0; i < n.size(); ++i) {\\n            ++count[n[i]];\\n        }\\n        \\n\\t\\t// Sort in reversed order\\n        sort(count.begin(), count.end(), greater<int>());\\n        sort(q.begin(), q.end(), greater<int>());\\n\\t\\t\\n        // Max number of unique numbers we can use to satisfy each customer\\n        count.resize(q.size());\\n        \\n        return backtrack(count, q, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```quantity.size()```\n```\\nclass Solution {\\npublic:\\n    bool backtrack(vector<int> &n, const vector<int> &q, int k) {\\n        if (k == q.size())\\n            return true;  // All customers are satisfied\\n        for (int i = 0; i < n.size(); ++i) {\\n            if (n[i] >= q[k]) {\\n                n[i] -= q[k];  \\n                if (backtrack(n, q, k + 1)) {  // Trying to satisfy next customer\\n                    return true;\\n                }\\n                n[i] += q[k];\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& n, vector<int>& q) {\\n        if (q.size() == 0) {\\n            return true;\\n        }\\n\\t\\t// Calculate repeated nums\\n\\t\\tvector<int> count(1001, 0);\\n        for (int i = 0; i < n.size(); ++i) {\\n            ++count[n[i]];\\n        }\\n        \\n\\t\\t// Sort in reversed order\\n        sort(count.begin(), count.end(), greater<int>());\\n        sort(q.begin(), q.end(), greater<int>());\\n\\t\\t\\n        // Max number of unique numbers we can use to satisfy each customer\\n        count.resize(q.size());\\n        \\n        return backtrack(count, q, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935392,
                "title": "python3-sort-backtracking",
                "content": "```\\nfrom collections import Counter\\nimport bisect\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        nums = list(Counter(nums).values())\\n        nums.sort()\\n        \\n        quantity.sort(reverse=True)\\n        \\n        def solve(qi):\\n            if qi == len(quantity):\\n                return True\\n            elif len(nums)==0:\\n                return False\\n            else:\\n                cs = bisect.bisect_left(nums, quantity[qi])\\n                if cs < len(nums) and nums[cs]>=quantity[qi]:\\n                    for x in range(cs,len(nums)):\\n                        r = nums.pop(x)\\n                        rem = r -  quantity[qi]\\n                        idx = bisect.bisect_right(nums, rem)\\n                        bisect.insort(nums, rem)\\n                        if solve(qi+1):\\n                            return True\\n                        del nums[idx]\\n                        nums.insert(idx, r)\\n                \\n                return False\\n        \\n        return solve(0)\\n```   \\nPrune search by fulfilling largest orders first. Use insort to maintain remaining orders as the list is small.\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nimport bisect\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        nums = list(Counter(nums).values())\\n        nums.sort()\\n        \\n        quantity.sort(reverse=True)\\n        \\n        def solve(qi):\\n            if qi == len(quantity):\\n                return True\\n            elif len(nums)==0:\\n                return False\\n            else:\\n                cs = bisect.bisect_left(nums, quantity[qi])\\n                if cs < len(nums) and nums[cs]>=quantity[qi]:\\n                    for x in range(cs,len(nums)):\\n                        r = nums.pop(x)\\n                        rem = r -  quantity[qi]\\n                        idx = bisect.bisect_right(nums, rem)\\n                        bisect.insort(nums, rem)\\n                        if solve(qi+1):\\n                            return True\\n                        del nums[idx]\\n                        nums.insert(idx, r)\\n                \\n                return False\\n        \\n        return solve(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974700,
                "title": "1655-distribute-repeating-integers",
                "content": "```\\nclass Solution {\\n public:\\n  bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n    // validDistribution[i][j] := true if it\\'s possible to distribute i-th freq\\n    // into a subset of quantity represented by the mask j\\n    const vector<int> freqs = getFreqs(nums);\\n    const vector<vector<bool>> validDistribution =\\n        getValidDistribuition(freqs, quantity);\\n    const int n = freqs.size();\\n    const int m = quantity.size();\\n    const int maxMask = 1 << m;\\n    // dp[i][j] := true if it\\'s possible to distribute freqs[i:] with selected\\n    // quantity represented by the mask j\\n    vector<vector<bool>> dp(n + 1, vector<bool>(maxMask));\\n    dp[n][maxMask - 1] = true;\\n\\n    for (int i = n - 1; i >= 0; --i)\\n      for (int mask = 0; mask < maxMask; ++mask) {\\n        dp[i][mask] = dp[i + 1][mask];\\n        const int availableMask = ~mask & (maxMask - 1);\\n        for (int submask = availableMask; submask > 0;\\n             submask = (submask - 1) & availableMask)\\n          if (validDistribution[i][submask])\\n            dp[i][mask] = dp[i][mask] || dp[i + 1][mask | submask];\\n      }\\n\\n    return dp[0][0];\\n  }\\n\\n private:\\n  vector<int> getFreqs(const vector<int>& nums) {\\n    vector<int> freqs;\\n    unordered_map<int, int> count;\\n    for (const int num : nums)\\n      ++count[num];\\n    for (const auto& [_, freq] : count)\\n      freqs.push_back(freq);\\n    return freqs;\\n  }\\n\\n  vector<vector<bool>> getValidDistribuition(const vector<int>& freqs,\\n                                             const vector<int>& quantity) {\\n    const int maxMask = 1 << quantity.size();\\n    vector<vector<bool>> validDistribution(freqs.size(), vector<bool>(maxMask));\\n    for (int i = 0; i < freqs.size(); ++i)\\n      for (int mask = 0; mask < maxMask; ++mask)\\n        if (freqs[i] >= getQuantitySum(quantity, mask))\\n          validDistribution[i][mask] = true;\\n    return validDistribution;\\n  }\\n\\n  // Returns the sum of the selected quantity represented by the `mask`.\\n  int getQuantitySum(const vector<int>& quantity, int mask) {\\n    int sum = 0;\\n    for (int i = 0; i < quantity.size(); ++i)\\n      if (mask >> i & 1)\\n        sum += quantity[i];\\n    return sum;\\n  }\\n};\\n",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "class Solution {\\n public:\\n  bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n    // validDistribution[i][j] := true if it\\'s possible to distribute i-th freq\\n    // into a subset of quantity represented by the mask j\\n    const vector<int> freqs = getFreqs(nums);\\n    const vector<vector<bool>> validDistribution =\\n        getValidDistribuition(freqs, quantity);\\n    const int n = freqs.size();\\n    const int m = quantity.size();\\n    const int maxMask = 1 << m;\\n    // dp[i][j] := true if it\\'s possible to distribute freqs[i:] with selected\\n    // quantity represented by the mask j\\n    vector<vector<bool>> dp(n + 1, vector<bool>(maxMask));\\n    dp[n][maxMask - 1] = true;\\n\\n    for (int i = n - 1; i >= 0; --i)\\n      for (int mask = 0; mask < maxMask; ++mask) {\\n        dp[i][mask] = dp[i + 1][mask];\\n        const int availableMask = ~mask & (maxMask - 1);\\n        for (int submask = availableMask; submask > 0;\\n             submask = (submask - 1) & availableMask)\\n          if (validDistribution[i][submask])\\n            dp[i][mask] = dp[i][mask] || dp[i + 1][mask | submask];\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 3907242,
                "title": "c-backtracking-easy",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<int> &frq, vector<int> &quantity, int idx){\\n        // Base condition\\n        if(idx >= quantity.size()) return true;\\n\\n        for(auto &f : frq){\\n            if(f >= quantity[idx]){\\n                f -= quantity[idx];\\n                if(helper(frq, quantity, idx + 1)) return true;\\n                // Back tracking\\n                f += quantity[idx];\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        // Intution\\n        // The idea in here is really very simple. First we will count the frequencies of characters present in the nums vector and then we will store them inside a map\\n        unordered_map<int, int> mp;\\n        for(auto & num : nums){\\n            mp[num] += 1;\\n        }\\n        vector<int> frq;\\n        for(auto itr = mp.begin() ; itr != mp.end() ; itr++){\\n            frq.push_back(itr->second);\\n        }\\n        // Reverse sorting the frq and the quantity array so that the frequencies can be correctly related\\n        sort(frq.rbegin(), frq.rend());\\n        sort(quantity.rbegin(), quantity.rend());\\n        return helper(frq, quantity, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool helper(vector<int> &frq, vector<int> &quantity, int idx){\\n        // Base condition\\n        if(idx >= quantity.size()) return true;\\n\\n        for(auto &f : frq){\\n            if(f >= quantity[idx]){\\n                f -= quantity[idx];\\n                if(helper(frq, quantity, idx + 1)) return true;\\n                // Back tracking\\n                f += quantity[idx];\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        // Intution\\n        // The idea in here is really very simple. First we will count the frequencies of characters present in the nums vector and then we will store them inside a map\\n        unordered_map<int, int> mp;\\n        for(auto & num : nums){\\n            mp[num] += 1;\\n        }\\n        vector<int> frq;\\n        for(auto itr = mp.begin() ; itr != mp.end() ; itr++){\\n            frq.push_back(itr->second);\\n        }\\n        // Reverse sorting the frq and the quantity array so that the frequencies can be correctly related\\n        sort(frq.rbegin(), frq.rend());\\n        sort(quantity.rbegin(), quantity.rend());\\n        return helper(frq, quantity, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880824,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_distinct_nums * (3 ^ n_quantity))\\n * Space Complexity: O(n_distinct_nums + (2 ^ n_quantity))\\n * where `n_distinct_nums` is the number of distinct elements of the vector `nums`\\n *       `n_quantity` is the length of the vector `quantity`\\n */\\nclass Solution {\\n public:\\n  bool canDistribute(const vector<int> &nums, const vector<int> &quantity) {\\n    constexpr int range = 2;\\n    unordered_map<int, int> num_to_count;\\n    for (const int num : nums) {\\n      ++num_to_count[num];\\n    }\\n\\n    vector<int> counts;\\n    for (const auto [_, count] : num_to_count) {\\n      counts.emplace_back(count);\\n    }\\n\\n    const int n_quantity = static_cast<int>(quantity.size());\\n    const int layouts = 1 << n_quantity;\\n    int layout_to_count[layouts];\\n    memset(layout_to_count, 0, sizeof(layout_to_count));\\n    for (int i = 0; i < n_quantity; ++i) {\\n      for (int sub_layout = 0; sub_layout < (1 << i); ++sub_layout) {\\n        layout_to_count[(1 << i) | sub_layout] = quantity[i] + layout_to_count[sub_layout];\\n      }\\n    }\\n\\n    bool dp[range][layouts];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0] = true;\\n    const int n_distinct_nums = static_cast<int>(counts.size());\\n    for (int i = 0; i < n_distinct_nums && !dp[previous][layouts - 1]; ++i) {\\n      const int count = counts[i];\\n      dp[current][0] = true;\\n      for (int current_layout = 1; current_layout < layouts; ++current_layout) {\\n        dp[current][current_layout] = dp[previous][current_layout];\\n        for (int sub_layout = current_layout; sub_layout > 0; sub_layout = (sub_layout - 1) & current_layout) {\\n          if (layout_to_count[sub_layout] <= count && dp[previous][current_layout ^ sub_layout]) {\\n            dp[current][current_layout] = true;\\n          }\\n        }\\n      }\\n\\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    return dp[previous][layouts - 1];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_distinct_nums * (3 ^ n_quantity))\\n * Space Complexity: O(n_distinct_nums + (2 ^ n_quantity))\\n * where `n_distinct_nums` is the number of distinct elements of the vector `nums`\\n *       `n_quantity` is the length of the vector `quantity`\\n */\\nclass Solution {\\n public:\\n  bool canDistribute(const vector<int> &nums, const vector<int> &quantity) {\\n    constexpr int range = 2;\\n    unordered_map<int, int> num_to_count;\\n    for (const int num : nums) {\\n      ++num_to_count[num];\\n    }\\n\\n    vector<int> counts;\\n    for (const auto [_, count] : num_to_count) {\\n      counts.emplace_back(count);\\n    }\\n\\n    const int n_quantity = static_cast<int>(quantity.size());\\n    const int layouts = 1 << n_quantity;\\n    int layout_to_count[layouts];\\n    memset(layout_to_count, 0, sizeof(layout_to_count));\\n    for (int i = 0; i < n_quantity; ++i) {\\n      for (int sub_layout = 0; sub_layout < (1 << i); ++sub_layout) {\\n        layout_to_count[(1 << i) | sub_layout] = quantity[i] + layout_to_count[sub_layout];\\n      }\\n    }\\n\\n    bool dp[range][layouts];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0] = true;\\n    const int n_distinct_nums = static_cast<int>(counts.size());\\n    for (int i = 0; i < n_distinct_nums && !dp[previous][layouts - 1]; ++i) {\\n      const int count = counts[i];\\n      dp[current][0] = true;\\n      for (int current_layout = 1; current_layout < layouts; ++current_layout) {\\n        dp[current][current_layout] = dp[previous][current_layout];\\n        for (int sub_layout = current_layout; sub_layout > 0; sub_layout = (sub_layout - 1) & current_layout) {\\n          if (layout_to_count[sub_layout] <= count && dp[previous][current_layout ^ sub_layout]) {\\n            dp[current][current_layout] = true;\\n          }\\n        }\\n      }\\n\\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    return dp[previous][layouts - 1];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828403,
                "title": "using-recursion-and-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    bool canDistributeHelper(vector<int>& counts, vector<int>& quantity, int ithCustomer)\\n    {\\n        // Base case\\n        if(ithCustomer == quantity.size())\\n        {\\n            return true;\\n        }\\n\\n        for(int i=0; i<counts.size(); i++)\\n        {\\n            if(counts[i] >= quantity[ithCustomer])\\n            {\\n                counts[i] -= quantity[ithCustomer];\\n\\n                if(canDistributeHelper(counts, quantity, ithCustomer + 1))\\n                {\\n                    return true;\\n                }\\n                counts[i] += quantity[ithCustomer]; // backtrack\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> countMap;\\n        for(auto num:nums)\\n        {\\n            countMap[num]++;\\n        }\\n        vector<int> counts;\\n        for(auto it: countMap)\\n        {\\n            counts.push_back(it.second);\\n        }\\n        sort(quantity.rbegin(),quantity.rend()); // sort DESC\\n        return canDistributeHelper(counts, quantity, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    bool canDistributeHelper(vector<int>& counts, vector<int>& quantity, int ithCustomer)\\n    {\\n        // Base case\\n        if(ithCustomer == quantity.size())\\n        {\\n            return true;\\n        }\\n\\n        for(int i=0; i<counts.size(); i++)\\n        {\\n            if(counts[i] >= quantity[ithCustomer])\\n            {\\n                counts[i] -= quantity[ithCustomer];\\n\\n                if(canDistributeHelper(counts, quantity, ithCustomer + 1))\\n                {\\n                    return true;\\n                }\\n                counts[i] += quantity[ithCustomer]; // backtrack\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> countMap;\\n        for(auto num:nums)\\n        {\\n            countMap[num]++;\\n        }\\n        vector<int> counts;\\n        for(auto it: countMap)\\n        {\\n            counts.push_back(it.second);\\n        }\\n        sort(quantity.rbegin(),quantity.rend()); // sort DESC\\n        return canDistributeHelper(counts, quantity, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797874,
                "title": "easy-c-map-solution",
                "content": "**Intuition:**\\n\\nThe problem requires checking if it is possible to distribute the integers in `nums` among the customers such that each customer receives exactly `quantity[i]` integers, all integers the customer receives are equal, and all customers are satisfied. To achieve this, we need to try all possible combinations of the integers in `nums` and check if they can satisfy the given quantities for each customer.\\n\\n**Approach:**\\n\\n1. Create a frequency map (`freqMap`) to store the count of each unique integer in `nums`.\\n2. Extract the unique integers from `freqMap` and store them in the `uniqueNums` array.\\n3. Use backtracking to try all possible combinations of `uniqueNums` and check if they can satisfy the orders for each customer. Start with the first customer (`idx = 0`) and recursively explore all possibilities.\\n4. During backtracking, for each unique integer, check if it has enough frequency to satisfy the current customer\\'s order. If yes, reduce its frequency and continue with the next customer. If no, backtrack and try other possibilities.\\n5. If we can satisfy all customers\\' orders, return `true`; otherwise, return `false`.\\n\\n**Complexity Analysis:**\\n\\nLet N be the length of `nums` (number of integers) and M be the number of customers.\\n\\n- Time Complexity: The time complexity of this approach is O(2^M * N). For each customer, we have two choices for each unique integer in `nums`: either include it in the current customer\\'s order or exclude it. This results in 2^M possible combinations to check.\\n- Space Complexity: The space complexity is O(N + M) to store the frequency map (`freqMap`) and the recursion stack.\\n\\n# Code\\n```\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> freqMap;\\n        for (int num : nums) {\\n            freqMap[num]++;\\n        }\\n        sort(quantity.rbegin(), quantity.rend());\\n        vector<int> uniqueNums;\\n        for (auto& entry : freqMap) {\\n            uniqueNums.push_back(entry.first);\\n        }\\n        \\n        return backtrack(uniqueNums, freqMap, quantity, 0);\\n    }\\n    \\n    bool backtrack(vector<int>& uniqueNums, unordered_map<int, int>& freqMap, vector<int>& quantity, int idx) {\\n        if (idx == quantity.size()) {\\n            return true; // All customers are satisfied\\n        }\\n        \\n        for (int i = 0; i < uniqueNums.size(); i++) {\\n            int num = uniqueNums[i];\\n            if (freqMap[num] >= quantity[idx]) {\\n                freqMap[num] -= quantity[idx]; // Decrease the frequency of current number\\n                if (backtrack(uniqueNums, freqMap, quantity, idx + 1)) {\\n                    return true;\\n                }\\n                freqMap[num] += quantity[idx]; // Backtrack by increasing the frequency\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> freqMap;\\n        for (int num : nums) {\\n            freqMap[num]++;\\n        }\\n        sort(quantity.rbegin(), quantity.rend());\\n        vector<int> uniqueNums;\\n        for (auto& entry : freqMap) {\\n            uniqueNums.push_back(entry.first);\\n        }\\n        \\n        return backtrack(uniqueNums, freqMap, quantity, 0);\\n    }\\n    \\n    bool backtrack(vector<int>& uniqueNums, unordered_map<int, int>& freqMap, vector<int>& quantity, int idx) {\\n        if (idx == quantity.size()) {\\n            return true; // All customers are satisfied\\n        }\\n        \\n        for (int i = 0; i < uniqueNums.size(); i++) {\\n            int num = uniqueNums[i];\\n            if (freqMap[num] >= quantity[idx]) {\\n                freqMap[num] -= quantity[idx]; // Decrease the frequency of current number\\n                if (backtrack(uniqueNums, freqMap, quantity, idx + 1)) {\\n                    return true;\\n                }\\n                freqMap[num] += quantity[idx]; // Backtrack by increasing the frequency\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3768146,
                "title": "distribute-repeating-integers-recursive-backtracking",
                "content": "# Intuition\\nUpon analyzing the problem, my initial thoughts on how to solve it are as follows:\\n\\n1. To satisfy the given conditions, each customer must receive a specific quantity of integers, and all the integers for each customer must be equal.\\n2. We need to determine if it is possible to distribute the given `nums` array in a way that satisfies all the customers\\' orders.\\n3. We can start by counting the frequency of each unique value in the `nums` array. This will give us an idea of the available quantities we have to distribute.\\n4. We can then sort the customers\\' order quantities in descending order to prioritize larger orders.\\n5. Next, we can try to distribute the integers from the `nums` array to satisfy each customer\\'s order quantity.\\n6. We can use recursion with backtracking to explore different possible distributions. We start with the largest order quantity and iterate over the available quantities. For each available quantity, we try to satisfy the current customer\\'s order by reducing the quantity from the available pool.\\n7. If we successfully distribute the integers for the current customer, we move on to the next customer and repeat the process recursively.\\n8. If at any point we are unable to satisfy a customer\\'s order, we backtrack by restoring the quantity for the previous customer and try different options.\\n9. If we are able to distribute all the integers and satisfy all the customers\\' orders, we return `true`. Otherwise, we return `false`.\\n\\nThis initial approach of using recursion with backtracking should help us explore different distribution possibilities and determine if it is possible to satisfy all the customers\\' orders according to the given conditions.\\n\\n# Approach\\nTo solve the problem, we can use a recursive approach with backtracking. Here\\'s the step-by-step approach:\\n\\n1. Create a frequency map to count the occurrences of each unique number in the `nums` array.\\n2. Convert the frequency map into a list of frequencies.\\n3. Sort the `quantity` array in descending order to prioritize larger orders.\\n4. Implement a recursive function, `distribute`, that takes the following parameters:\\n   - `frequencies`: A list of frequencies.\\n   - `quantity`: The `quantity` array.\\n   - `index`: The index of the current customer we are trying to satisfy.\\n5. Check the base case: If `index` is equal to the length of the `quantity` array, return `true` (all customers are satisfied).\\n6. Iterate over the frequencies list:\\n   - Get the current frequency.\\n   - If the frequency is greater than or equal to the current customer\\'s order quantity (`quantity[index]`):\\n     - Subtract the order quantity from the current frequency.\\n     - Recursively call the `distribute` function for the next customer (`index + 1`).\\n     - If the recursive call returns `true`, return `true`.\\n     - Otherwise, backtrack by restoring the frequency back to its original value.\\n7. If no distribution is possible for any frequency, return `false`.\\n8. Finally, call the `distribute` function with the initial parameters (`frequencies`, `quantity`, and `0`) and return the result.\\n\\nThe recursive `distribute` function tries to distribute the available frequencies to satisfy each customer\\'s order. It explores different possibilities by iterating over the frequencies and recursively calling itself for the next customer. If a distribution is successful for all customers, it returns `true`. If not, it backtracks and tries different options.\\n\\nBy following this approach, we can determine if it is possible to distribute the integers from the `nums` array to satisfy all the customers\\' orders according to the given conditions.\\n\\n# Complexity\\n- Time complexity:\\nO(2^m * n)\\n\\n- Space complexity:\\nO(n + m)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n   // Count the frequency of each unique number in nums\\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\\n        for (int num : nums) {\\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        // Convert the frequency map to a list of frequencies\\n        List<Integer> frequencies = new ArrayList<>(frequencyMap.values());\\n        \\n        // Sort the quantities in descending order to prioritize larger orders\\n        Arrays.sort(quantity);\\n        reverse(quantity);\\n        \\n        return distribute(frequencies, quantity, 0);\\n    }\\n    \\n    private boolean distribute(List<Integer> frequencies, int[] quantity, int index) {\\n        // Base case: All customers are satisfied\\n        if (index == quantity.length) {\\n            return true;\\n        }\\n        \\n        // Try to satisfy the current customer\\'s order quantity\\n        int orderQuantity = quantity[index];\\n        for (int i = 0; i < frequencies.size(); i++) {\\n            int frequency = frequencies.get(i);\\n            if (frequency >= orderQuantity) {\\n                // Use the current frequency to satisfy the order quantity\\n                frequencies.set(i, frequency - orderQuantity);\\n                \\n                // Recursively distribute the remaining quantities\\n                if (distribute(frequencies, quantity, index + 1)) {\\n                    return true;\\n                }\\n                \\n                // Backtrack: restore the frequency to its original value\\n                frequencies.set(i, frequency);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void reverse(int[] array) {\\n        int left = 0, right = array.length - 1;\\n        while (left < right) {\\n            int temp = array[left];\\n            array[left] = array[right];\\n            array[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n   // Count the frequency of each unique number in nums\\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\\n        for (int num : nums) {\\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        // Convert the frequency map to a list of frequencies\\n        List<Integer> frequencies = new ArrayList<>(frequencyMap.values());\\n        \\n        // Sort the quantities in descending order to prioritize larger orders\\n        Arrays.sort(quantity);\\n        reverse(quantity);\\n        \\n        return distribute(frequencies, quantity, 0);\\n    }\\n    \\n    private boolean distribute(List<Integer> frequencies, int[] quantity, int index) {\\n        // Base case: All customers are satisfied\\n        if (index == quantity.length) {\\n            return true;\\n        }\\n        \\n        // Try to satisfy the current customer\\'s order quantity\\n        int orderQuantity = quantity[index];\\n        for (int i = 0; i < frequencies.size(); i++) {\\n            int frequency = frequencies.get(i);\\n            if (frequency >= orderQuantity) {\\n                // Use the current frequency to satisfy the order quantity\\n                frequencies.set(i, frequency - orderQuantity);\\n                \\n                // Recursively distribute the remaining quantities\\n                if (distribute(frequencies, quantity, index + 1)) {\\n                    return true;\\n                }\\n                \\n                // Backtrack: restore the frequency to its original value\\n                frequencies.set(i, frequency);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void reverse(int[] array) {\\n        int left = 0, right = array.length - 1;\\n        while (left < right) {\\n            int temp = array[left];\\n            array[left] = array[right];\\n            array[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752005,
                "title": "backtracking-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>& counts, vector<int>& qnty, int cus_indx)\\n    {\\n        //base case\\n        if(cus_indx >= qnty.size())\\n        {\\n            return true;\\n        }\\n\\n        for(int i=0;i<counts.size();i++)\\n        {\\n            if(counts[i] >= qnty[cus_indx])\\n            {\\n                counts[i] -= qnty[cus_indx];\\n                if(helper(counts, qnty, cus_indx + 1) == true){\\n                    return true;\\n                }\\n                counts[i] += qnty[cus_indx];//backtrack\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> mp;\\n        for(int num : nums)\\n        {\\n            mp[num] += 1;\\n        }\\n\\n        vector<int> counts;\\n        for(auto it : mp)\\n        {\\n            counts.push_back(it.second);\\n        }\\n//agar mai sabse max quantity ko satisfy nahi kar paunga toh jaldi false condition dhoond loonga toh depth of recursion kam ho jayega aur back jaunga TLE se\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        int start_cus_indx = 0;\\n        return helper(counts, quantity, start_cus_indx);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>& counts, vector<int>& qnty, int cus_indx)\\n    {\\n        //base case\\n        if(cus_indx >= qnty.size())\\n        {\\n            return true;\\n        }\\n\\n        for(int i=0;i<counts.size();i++)\\n        {\\n            if(counts[i] >= qnty[cus_indx])\\n            {\\n                counts[i] -= qnty[cus_indx];\\n                if(helper(counts, qnty, cus_indx + 1) == true){\\n                    return true;\\n                }\\n                counts[i] += qnty[cus_indx];//backtrack\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> mp;\\n        for(int num : nums)\\n        {\\n            mp[num] += 1;\\n        }\\n\\n        vector<int> counts;\\n        for(auto it : mp)\\n        {\\n            counts.push_back(it.second);\\n        }\\n//agar mai sabse max quantity ko satisfy nahi kar paunga toh jaldi false condition dhoond loonga toh depth of recursion kam ho jayega aur back jaunga TLE se\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        int start_cus_indx = 0;\\n        return helper(counts, quantity, start_cus_indx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708434,
                "title": "easy-simple-and-fastest-way-in-c",
                "content": "# Code\\n```\\nclass Solution {\\n    bool helper(vector<int>& arr, vector<int>& q, int idx) {\\n\\n        if(idx >= q.size()) {\\n            return true;\\n        }\\n\\n        for(int i=0; i<arr.size(); i++) {\\n            if(arr[i] >= q[idx]) { \\n                arr[i] -= q[idx];\\n                if(helper(arr, q, idx+1))\\n                    return true;\\n                arr[i] += q[idx];\\n            }\\n        }\\n        return false;\\n    }\\n    void print(multiset<int>& arr) {\\n        for(int a : arr) cout<<a<<\" \";\\n            cout<<endl;\\n    }\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> mp;\\n        int len = nums.size();\\n\\n        for(int i=0; i<len; i++)  {\\n            mp[nums[i]]++;\\n        }\\n\\n        vector<int> arr;\\n        for(auto m : mp) {\\n            arr.push_back(m.second);\\n        }\\n\\n        // to optimize the algo arrange quantity arr in decending order.\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n\\n        return helper(arr, quantity, 0);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool helper(vector<int>& arr, vector<int>& q, int idx) {\\n\\n        if(idx >= q.size()) {\\n            return true;\\n        }\\n\\n        for(int i=0; i<arr.size(); i++) {\\n            if(arr[i] >= q[idx]) { \\n                arr[i] -= q[idx];\\n                if(helper(arr, q, idx+1))\\n                    return true;\\n                arr[i] += q[idx];\\n            }\\n        }\\n        return false;\\n    }\\n    void print(multiset<int>& arr) {\\n        for(int a : arr) cout<<a<<\" \";\\n            cout<<endl;\\n    }\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> mp;\\n        int len = nums.size();\\n\\n        for(int i=0; i<len; i++)  {\\n            mp[nums[i]]++;\\n        }\\n\\n        vector<int> arr;\\n        for(auto m : mp) {\\n            arr.push_back(m.second);\\n        }\\n\\n        // to optimize the algo arrange quantity arr in decending order.\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n\\n        return helper(arr, quantity, 0);\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3683549,
                "title": "begineers-friendly-c-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(map<int, int> &mp, vector<int>& qt, int i){\\n        if(i == qt.size())\\n        return true;\\n\\n        for(auto it:mp){\\n            if(it.second >= qt[i]){\\n                mp[it.first] = mp[it.first] - qt[i];\\n                \\n                bool ans = solve(mp, qt, i+1);\\n\\n                if(ans == true)\\n                return true;\\n                else\\n                mp[it.first] = mp[it.first] + qt[i];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int, int> mp;\\n\\n        for(auto it:nums){\\n            mp[it]++;\\n        }\\n\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        return solve(mp, quantity, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(map<int, int> &mp, vector<int>& qt, int i){\\n        if(i == qt.size())\\n        return true;\\n\\n        for(auto it:mp){\\n            if(it.second >= qt[i]){\\n                mp[it.first] = mp[it.first] - qt[i];\\n                \\n                bool ans = solve(mp, qt, i+1);\\n\\n                if(ans == true)\\n                return true;\\n                else\\n                mp[it.first] = mp[it.first] + qt[i];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int, int> mp;\\n\\n        for(auto it:nums){\\n            mp[it]++;\\n        }\\n\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n        return solve(mp, quantity, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608628,
                "title": "c-solution-easy-to-understand-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool solve(vector<int>& quantity,vector<int>& counts,int ithcustomer)\\n{\\n    //base case\\n    if(ithcustomer == quantity.size())\\n    {\\n        return true;\\n    }\\n\\n    for(int i=0;i<counts.size();i++)\\n    {\\n        if(counts[i]>=quantity[ithcustomer]) // that means we can allocate to the customer \\n        {\\n          counts[i]-=quantity[ithcustomer];\\n          //recursive call\\n          if(solve(quantity,counts,ithcustomer+1))\\n          {\\n           return true;   \\n          }\\n          //backtrack\\n          counts[i]+=quantity[ithcustomer];\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n     //first i need to create a mapping for getting the frequency\\n     unordered_map<int,int>freq;\\n     for(auto num:nums)\\n     {\\n         freq[num]++;\\n     }\\n     vector<int>counts;\\n     for(auto it:freq)\\n     {\\n         counts.push_back(it.second); // so in counts we will be having only frequencies corresponding to integers\\n     }\\n     //************now sorting the quantity in decreasing order in order to get the false case faster******************\\n     sort(quantity.rbegin(),quantity.rend());\\n     return solve(quantity,counts,0); // this 0 refers to the ith customer\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool solve(vector<int>& quantity,vector<int>& counts,int ithcustomer)\\n{\\n    //base case\\n    if(ithcustomer == quantity.size())\\n    {\\n        return true;\\n    }\\n\\n    for(int i=0;i<counts.size();i++)\\n    {\\n        if(counts[i]>=quantity[ithcustomer]) // that means we can allocate to the customer \\n        {\\n          counts[i]-=quantity[ithcustomer];\\n          //recursive call\\n          if(solve(quantity,counts,ithcustomer+1))\\n          {\\n           return true;   \\n          }\\n          //backtrack\\n          counts[i]+=quantity[ithcustomer];\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n     //first i need to create a mapping for getting the frequency\\n     unordered_map<int,int>freq;\\n     for(auto num:nums)\\n     {\\n         freq[num]++;\\n     }\\n     vector<int>counts;\\n     for(auto it:freq)\\n     {\\n         counts.push_back(it.second); // so in counts we will be having only frequencies corresponding to integers\\n     }\\n     //************now sorting the quantity in decreasing order in order to get the false case faster******************\\n     sort(quantity.rbegin(),quantity.rend());\\n     return solve(quantity,counts,0); // this 0 refers to the ith customer\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593131,
                "title": "distribute-repeating-integers-c-solution-backtrack",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canDistribute_helper(vector<int>& count, vector<int>& quantity, int ithCustomer){\\n        // base case\\n        if(ithCustomer == quantity.size()){\\n            return true;\\n        }\\n\\n        for(int i=0; i < count.size(); i++){\\n            if(count[i] >= quantity[ithCustomer]){\\n                count[i] -= quantity[ithCustomer];\\n                if(canDistribute_helper(count, quantity, ithCustomer+1)){\\n                    return true;\\n                }\\n                count[i] += quantity[ithCustomer]; // backtrack\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n       unordered_map<int, int>countNum;\\n       for(auto num: nums){\\n           countNum[num]++;\\n       } \\n       vector<int>count;\\n       for(auto i: countNum){\\n           count.push_back(i.second); // to access the count from map\\n       }\\n       sort(quantity.rbegin(), quantity.rend()); // Decreasing sort to reduce time complexity to find elements\\n       return canDistribute_helper(count, quantity, 0); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canDistribute_helper(vector<int>& count, vector<int>& quantity, int ithCustomer){\\n        // base case\\n        if(ithCustomer == quantity.size()){\\n            return true;\\n        }\\n\\n        for(int i=0; i < count.size(); i++){\\n            if(count[i] >= quantity[ithCustomer]){\\n                count[i] -= quantity[ithCustomer];\\n                if(canDistribute_helper(count, quantity, ithCustomer+1)){\\n                    return true;\\n                }\\n                count[i] += quantity[ithCustomer]; // backtrack\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n       unordered_map<int, int>countNum;\\n       for(auto num: nums){\\n           countNum[num]++;\\n       } \\n       vector<int>count;\\n       for(auto i: countNum){\\n           count.push_back(i.second); // to access the count from map\\n       }\\n       sort(quantity.rbegin(), quantity.rend()); // Decreasing sort to reduce time complexity to find elements\\n       return canDistribute_helper(count, quantity, 0); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579113,
                "title": "easy-and-beginner-friendly-using-recursion-and-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool canDistribute_helper( vector<int>&  count,vector<int>& quantity,int i){\\n    if(i>=quantity.size()){\\n        return true;\\n    }\\n\\n\\n    for(int j=0; j<count.size(); j++){\\n        if(count[j]>=quantity[i]){\\n            count[j]-=quantity[i];\\n           if(canDistribute_helper(count,quantity,i+1)){\\n               return true;\\n           }\\n            count[j]+=quantity[i];\\n        }\\n    }\\n    return false;\\n}\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        sort(nums.begin(),nums.end());\\n        sort(quantity.rbegin(),quantity.rend());\\n        unordered_map<int,int>counts;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            counts[nums[i]]++;\\n        }\\n        vector<int>count;\\n        for(auto i:counts){\\n            count.push_back(i.second);\\n        }\\n        return canDistribute_helper(count,quantity,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool canDistribute_helper( vector<int>&  count,vector<int>& quantity,int i){\\n    if(i>=quantity.size()){\\n        return true;\\n    }\\n\\n\\n    for(int j=0; j<count.size(); j++){\\n        if(count[j]>=quantity[i]){\\n            count[j]-=quantity[i];\\n           if(canDistribute_helper(count,quantity,i+1)){\\n               return true;\\n           }\\n            count[j]+=quantity[i];\\n        }\\n    }\\n    return false;\\n}\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        sort(nums.begin(),nums.end());\\n        sort(quantity.rbegin(),quantity.rend());\\n        unordered_map<int,int>counts;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            counts[nums[i]]++;\\n        }\\n        vector<int>count;\\n        for(auto i:counts){\\n            count.push_back(i.second);\\n        }\\n        return canDistribute_helper(count,quantity,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573933,
                "title": "easiest-small-solution-c-simple-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool sol(map<int,int> &mp,vector<int> &q,int ind){\\n        if(ind >= q.size()) return true;\\n        for(auto &i:mp){\\n            if(i.second >= q[ind]){\\n                i.second -= q[ind];\\n                bool ans = sol(mp,q,ind+1);\\n                if(ans) return true;\\n                i.second += q[ind];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& q) {\\n        map<int,int> mp;\\n        for(auto i:nums) mp[i]++;\\n        sort(q.rbegin(),q.rend());\\n        return sol(mp,q,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool sol(map<int,int> &mp,vector<int> &q,int ind){\\n        if(ind >= q.size()) return true;\\n        for(auto &i:mp){\\n            if(i.second >= q[ind]){\\n                i.second -= q[ind];\\n                bool ans = sol(mp,q,ind+1);\\n                if(ans) return true;\\n                i.second += q[ind];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& q) {\\n        map<int,int> mp;\\n        for(auto i:nums) mp[i]++;\\n        sort(q.rbegin(),q.rend());\\n        return sol(mp,q,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571885,
                "title": "easy-solution",
                "content": "# Complexity\\n- Time complexity: `O(nlogN)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // void printf(vector<int>&a){\\n    //     for(auto it:a)cout<<it<<\" \";\\n    //     cout<<endl;\\n    // }\\n    // bool check(vector<int>&a, int quan){\\n    //     int maxi = *max_element(a.begin(),a.end());\\n    //     //cout<<maxi;\\n    //     int n = a.size();\\n    //     if(maxi<quan) return false;\\n\\n    //     else{\\n    //         for(int i = n-1; i>=0; i--){\\n    //             if(a[i]>quan){\\n    //                 a[i] = a[i] - quan;\\n    //                 break;\\n    //             }\\n    //         }\\n    //         sort(a.begin(),a.end());\\n    //     }\\n    //     return true;\\n    // }\\n\\n    bool helper(vector<int>&freq, vector<int>&quan, int q = 0){\\n        if(q>=quan.size()) return true;\\n\\n        bool ans;\\n        for(int i = 0; i<freq.size(); i++){\\n            if(freq[i]>=quan[q]){\\n                freq[i] = freq[i] - quan[q];\\n                ans = helper(freq,quan,q+1);\\n                if(ans)return true;\\n                freq[i]=freq[i] + quan[q];\\n            }\\n        }\\n\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        \\n        unordered_map<int,int>mp;\\n\\n        for(auto it:nums)mp[it]++;\\n        vector<int>freq;\\n        for(auto it:mp)freq.push_back(it.second);\\n        sort(quantity.rbegin(),quantity.rend());\\n        return helper(freq,quantity);\\n        \\n        \\n        \\n        // map<int,int>mp;\\n        // for(auto it:nums)mp[it]++;\\n        // //sort(quantity.begin(),quantity.end(),greater<int>());\\n        // //unordered_set<int>freq;\\n        // //set<int>freq;\\n\\n        // vector<int>freq;\\n        // //int freq[mp.size()];\\n        // for(auto it:mp)freq.push_back(it.second);\\n        // //for(int i = 0; i<mp.size(); i++)freq[i] = mp.second;\\n        // // int max_ele = *max_element(quantity.begin(),quantity.end());\\n        // // return ((accumulate(freq.begin(),freq.end(),0)>=accumulate(quantity.begin(),quantity.end(),0)) && (find(freq.begin(),freq.end(),max_ele)!=freq.end()))? true : false;\\n        // sort(freq.begin(),freq.end());\\n        // //printf(freq);\\n        // bool flag = true;\\n        // //unordered_set<int>:: iterator itr;\\n        // //set<int>:: iterator itr;\\n        // vector<int>:: iterator itr;\\n        // //vector<int>:: iterator result;\\n        \\n        \\n        // for(auto it:quantity){\\n        //     //int *itr = find(freq, freq+mp.size(), it);\\n        //     //printf(freq);\\n        //     itr = find(freq.begin(),freq.end(),it);\\n        //     if(itr!=freq.end()){\\n        //         *itr = 0;\\n        //     }\\n        //     //result = max_element(freq.begin(),freq.end());\\n        //     // int *result = maxi(freq);\\n        //     // cout<<*result;\\n        //     //else if((result!=freq.end()) && (*result>it)){\\n        //     // else if(result!=freq.end()){\\n        //     //     *result = *result-it;\\n        //     // }\\n        //     //cout<<*(freq.end()-1);\\n        //     //cout<<*result;\\n        //     // else if(*result>it){\\n        //     //     *\\n        //     // }\\n\\n        //     else if(check(freq,it)) continue;\\n        //     else{\\n        //         flag = !flag;\\n        //         break;\\n        //     }\\n        // }\\n        // return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // void printf(vector<int>&a){\\n    //     for(auto it:a)cout<<it<<\" \";\\n    //     cout<<endl;\\n    // }\\n    // bool check(vector<int>&a, int quan){\\n    //     int maxi = *max_element(a.begin(),a.end());\\n    //     //cout<<maxi;\\n    //     int n = a.size();\\n    //     if(maxi<quan) return false;\\n\\n    //     else{\\n    //         for(int i = n-1; i>=0; i--){\\n    //             if(a[i]>quan){\\n    //                 a[i] = a[i] - quan;\\n    //                 break;\\n    //             }\\n    //         }\\n    //         sort(a.begin(),a.end());\\n    //     }\\n    //     return true;\\n    // }\\n\\n    bool helper(vector<int>&freq, vector<int>&quan, int q = 0){\\n        if(q>=quan.size()) return true;\\n\\n        bool ans;\\n        for(int i = 0; i<freq.size(); i++){\\n            if(freq[i]>=quan[q]){\\n                freq[i] = freq[i] - quan[q];\\n                ans = helper(freq,quan,q+1);\\n                if(ans)return true;\\n                freq[i]=freq[i] + quan[q];\\n            }\\n        }\\n\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        \\n        unordered_map<int,int>mp;\\n\\n        for(auto it:nums)mp[it]++;\\n        vector<int>freq;\\n        for(auto it:mp)freq.push_back(it.second);\\n        sort(quantity.rbegin(),quantity.rend());\\n        return helper(freq,quantity);\\n        \\n        \\n        \\n        // map<int,int>mp;\\n        // for(auto it:nums)mp[it]++;\\n        // //sort(quantity.begin(),quantity.end(),greater<int>());\\n        // //unordered_set<int>freq;\\n        // //set<int>freq;\\n\\n        // vector<int>freq;\\n        // //int freq[mp.size()];\\n        // for(auto it:mp)freq.push_back(it.second);\\n        // //for(int i = 0; i<mp.size(); i++)freq[i] = mp.second;\\n        // // int max_ele = *max_element(quantity.begin(),quantity.end());\\n        // // return ((accumulate(freq.begin(),freq.end(),0)>=accumulate(quantity.begin(),quantity.end(),0)) && (find(freq.begin(),freq.end(),max_ele)!=freq.end()))? true : false;\\n        // sort(freq.begin(),freq.end());\\n        // //printf(freq);\\n        // bool flag = true;\\n        // //unordered_set<int>:: iterator itr;\\n        // //set<int>:: iterator itr;\\n        // vector<int>:: iterator itr;\\n        // //vector<int>:: iterator result;\\n        \\n        \\n        // for(auto it:quantity){\\n        //     //int *itr = find(freq, freq+mp.size(), it);\\n        //     //printf(freq);\\n        //     itr = find(freq.begin(),freq.end(),it);\\n        //     if(itr!=freq.end()){\\n        //         *itr = 0;\\n        //     }\\n        //     //result = max_element(freq.begin(),freq.end());\\n        //     // int *result = maxi(freq);\\n        //     // cout<<*result;\\n        //     //else if((result!=freq.end()) && (*result>it)){\\n        //     // else if(result!=freq.end()){\\n        //     //     *result = *result-it;\\n        //     // }\\n        //     //cout<<*(freq.end()-1);\\n        //     //cout<<*result;\\n        //     // else if(*result>it){\\n        //     //     *\\n        //     // }\\n\\n        //     else if(check(freq,it)) continue;\\n        //     else{\\n        //         flag = !flag;\\n        //         break;\\n        //     }\\n        // }\\n        // return flag;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3558640,
                "title": "best-optimised-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& counts, vector<int>& quantity,int ithCustomer){\\n        //base\\n        if(ithCustomer == quantity.size()){\\n            return true;//completed all the conditions\\n        }\\n        \\n        for(int i=0;i<counts.size();i++){\\n            if(counts[i] >= quantity[ithCustomer]){\\n                counts[i] -= quantity[ithCustomer];\\n                if(solve(counts,quantity,ithCustomer+1)){\\n                    return true;//completed all the conditions\\n                }\\n                counts[i] += quantity[ithCustomer];//backtrack\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int>count;\\n        for(auto num:nums){\\n            count[num]++;\\n        }\\n\\n        vector<int>counts;\\n        for(auto it:count){\\n            counts.push_back(it.second);//pushing values into vector\\n        }\\n\\n        sort(quantity.rbegin(),quantity.rend());//sort decreasing order\\n        return solve(counts,quantity,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& counts, vector<int>& quantity,int ithCustomer){\\n        //base\\n        if(ithCustomer == quantity.size()){\\n            return true;//completed all the conditions\\n        }\\n        \\n        for(int i=0;i<counts.size();i++){\\n            if(counts[i] >= quantity[ithCustomer]){\\n                counts[i] -= quantity[ithCustomer];\\n                if(solve(counts,quantity,ithCustomer+1)){\\n                    return true;//completed all the conditions\\n                }\\n                counts[i] += quantity[ithCustomer];//backtrack\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int>count;\\n        for(auto num:nums){\\n            count[num]++;\\n        }\\n\\n        vector<int>counts;\\n        for(auto it:count){\\n            counts.push_back(it.second);//pushing values into vector\\n        }\\n\\n        sort(quantity.rbegin(),quantity.rend());//sort decreasing order\\n        return solve(counts,quantity,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546331,
                "title": "backtracking-with-memoization-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know we only have 10 customers at worst. We also know we have at most 50 unique items in our set up. We can backtrack on the customers and on the items, and can limit ourselves to only as many items as we have customers if we go in greatest reversed order of items present. This lets us limit ourselves appropriately to a space at worst of 10^10. We can allow ourselves to stop early by utilizing a backtracking string to target the current items and current customers as a key, thus letting us memoize results and reduce computational time altogether. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind your number of items, your number of customers, and then check to make sure you at least have enough items to match customers before any combinations. \\n\\nThen, get the frequency of your items. \\nTurn nums into the sorted form of the frequencies (not the items, the frequencies) in reverse order for as many as you have customers. This lets you focus on a subset of size 10^10 at worst. \\n\\nSort your quantities in reverse. \\n\\nIf your sum of item frequencies is less than the sum of your quantity, you can also return False already. \\n\\nOtherwise, set up a memo \\n\\nDuring the backtracking phase, pass in the current items, customer index, and current customer statuses \\n- Build a backtrack key using the items sorted | customer status sorted as a string \\n- If your customer index is past the total number number of customers, set memo at backtrack key to true and return true \\n- If you have the backtrack key in the memo, return what you found already and skip the preprocess. This is the reason for the sorting as it combines similar set ups with different location strings. \\n- otherwise, get the current amount as quantity at customer index \\n- set your current item index to 0 \\n- while your current item index is in range of your current items length \\n    - if the item here is not big enough -> move forward by 1 until it is \\n    - otherwise \\n        - if the current item index is greater than 0 and we have matching items here \\n            - go until the last version of these if you can \\n            - if you end up out of range, break \\n            - otherwise if you end up at a bad spot, move forward one and continue \\n        - otherwise try to use the current item to satisfy the current customer, updating in both lists appropriately \\n        - make a temp key of doing so \\n        - if you have seen this temp key and it doesn\\'t work \\n            - unset what you did and move forward one and continue \\n        - if you saw it and it did work \\n            - set memo for the backtrack key and return True \\n        - otherwise, go check it out\\n            - then update the memo\\n            - if it was true, update memo for backtrack key and return \\n            - otherwise, undo the look, move forward and continue \\n- if you never got a success in the loop, update the memo here and return False \\n\\nTo solve, kick off backtrack with nums, 0, quantity           \\n\\n# Complexity\\n- Time complexity : O (Sum m! / (i!(m-i)!) for i in range 1, m-1, where m is number of customers)\\n    - O(10^10) at worst since we do 10^10 considerations in our backtracking is the naive amount \\n    - However, we can limit down since our sort for the backtrack keys worked (never caused an error) to O(3629822) operations, since we now know that we are dealing with combinatory states where no repeats are allowed and order doesn\\'t matter (otherwise, the backtrack keys would have caused a problem). Due to this, we get the time complexity of combinations with no repeats instead of permutations with repeats for the backtrack process.   \\n    - This puts our overall time complexity in the form of O(Sum m!/(i!(m-i)!) for i in range 1, m-1), where m is the number of customers according to the problem statement. For comparison sakes, this is about 2750 times faster than O(10^10)\\n\\n- Space complexity : Due to backtracking nature, we match our space complexity unfortunately, but due handidly beat the space in the other case due to our size reduction. If someone is interested, this can potentially be done in bottom up form and save us the massive amounts of space with the time savings. \\n\\n# Code\\n```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool :\\n        \\'\\'\\'\\n            at most 50 unique values in the array \\n            customer quantities -> no more than 10 customers -> m \\n                                -> each customer can order between 1 and 10^5, the number of items range as well \\n            nums -> amount of items \\n            want to distribute nums so that \\n                each customer gets exactly customer_i items (so if there are not exactly i items not gonna work)\\n                the integers that compose the ith customer order are all equal and sum to customer i items \\n                every customer can be satisfied \\n        \\n        \\'\\'\\'\\n        # get number of items and number of customers \\n        number_of_items = len(nums)\\n        number_of_customers = len(quantity) \\n        # before doing frequency work, if you do not have enough items, you\\'ll never satisfy everyone \\n        if number_of_items < number_of_customers : \\n            return False \\n        # find out your frequency of your items \\n        frequency_of_items = collections.Counter(nums)\\n        # and limit yourself to the best for your customers \\n        nums = sorted(frequency_of_items.values(), reverse=True)[:number_of_customers]\\n        quantity.sort(reverse = True)\\n        # if you still can\\'t satisfy everyone, don\\'t try and return False \\n        if sum(nums) < sum(quantity) : \\n            return False \\n        # set up a memo to track your progress \\n        self.memo = dict() \\n\\n        def backtrack(current_items, customer_index, current_customers) :\\n            # set up a backtrack key where you use the sorted form of each to capture as many possible alternate substates as you can \\n            backtrack_key = \"\".join([str(c_it) for c_it in sorted(current_items)]) + \"-\" + \"\".join([str(c_c) for c_c in sorted(current_customers)]) \\n            # if you reached the end, mark it and return True. Otherwise, if you\\'ve seen this, return what you already found! \\n            if customer_index == number_of_customers : \\n                self.memo[backtrack_key] = True\\n                return True \\n            elif backtrack_key in self.memo : \\n                return self.memo[backtrack_key]\\n\\n            # figure out how much you have \\n            current_amount = quantity[customer_index]\\n\\n            # consider all your items \\n            c_i = 0 \\n            while c_i < len(current_items) :\\n                # if we have an item that is gte here  \\n                if current_items[c_i] >= current_amount :\\n                    # if we are past 0 and have a matching situation  \\n                    if c_i > 0 and current_items[c_i] == current_items[c_i - 1] :\\n                        # go until you run out of room, or until you run out of matches, or until you run into a problem  \\n                        while c_i < len(current_items) and current_items[c_i] == current_items[c_i - 1] and current_items[c_i] >= current_amount : \\n                            c_i += 1 \\n                        # if you ran out of room, nothing to do here, break \\n                        if c_i >= len(current_items) : \\n                            break \\n                        elif current_items[c_i] < current_amount :\\n                            # otherwise, if you ran out items, skip on to the next  \\n                            c_i += 1 \\n                            continue  \\n                    # otherwise, if you have not run out room, and you do have an item worth looking at \\n                    # look at it \\n                    current_items[c_i] -= current_amount\\n                    current_customers[customer_index] = 0 \\n                    # get the key \\n                    temp_key = \"\".join([str(c_it) for c_it in sorted(current_items)]) + \"-\" + \"\".join([str(c_c) for c_c in sorted(current_customers)])\\n                    # check if you have it and it doesn\\'t work \\n                    if temp_key in self.memo and self.memo[temp_key] == False :\\n                        # if it doesn\\'t, unset the looking and then move forward one  \\n                        current_items[c_i] += current_amount\\n                        current_customers[customer_index] = current_amount\\n                        c_i += 1 \\n                        continue \\n                    elif temp_key in self.memo and self.memo[temp_key] == True : \\n                        # if you have the key and it worked already, skip out of there after resetting your backtrack key as well \\n                        self.memo[backtrack_key] = True\\n                        return True \\n                    elif temp_key not in self.memo : \\n                        # otherwise if we have not seen this thing, set up a temp result and lock it in \\n                        temp_result = backtrack(current_items, customer_index + 1, current_customers) \\n                        self.memo[temp_key] = temp_result \\n                        if temp_result == True : \\n                            # on success, update and return \\n                            self.memo[backtrack_key] = True \\n                            return True \\n                        else : \\n                            # on failure, unset and continue \\n                            current_items[c_i] += current_amount \\n                            current_customers[customer_index] = current_amount\\n                            c_i += 1 \\n                            continue \\n                else : \\n                    c_i += 1 \\n                    continue \\n\\n            # if you ran out of room or weren\\'t able to make it work -> set False and return it \\n            self.memo[backtrack_key] = False\\n            return False \\n        \\n        # kick it off with our altered nums and quantities \\n        return backtrack(nums, 0, quantity)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool :\\n        \\'\\'\\'\\n            at most 50 unique values in the array \\n            customer quantities -> no more than 10 customers -> m \\n                                -> each customer can order between 1 and 10^5, the number of items range as well \\n            nums -> amount of items \\n            want to distribute nums so that \\n                each customer gets exactly customer_i items (so if there are not exactly i items not gonna work)\\n                the integers that compose the ith customer order are all equal and sum to customer i items \\n                every customer can be satisfied \\n        \\n        \\'\\'\\'\\n        # get number of items and number of customers \\n        number_of_items = len(nums)\\n        number_of_customers = len(quantity) \\n        # before doing frequency work, if you do not have enough items, you\\'ll never satisfy everyone \\n        if number_of_items < number_of_customers : \\n            return False \\n        # find out your frequency of your items \\n        frequency_of_items = collections.Counter(nums)\\n        # and limit yourself to the best for your customers \\n        nums = sorted(frequency_of_items.values(), reverse=True)[:number_of_customers]\\n        quantity.sort(reverse = True)\\n        # if you still can\\'t satisfy everyone, don\\'t try and return False \\n        if sum(nums) < sum(quantity) : \\n            return False \\n        # set up a memo to track your progress \\n        self.memo = dict() \\n\\n        def backtrack(current_items, customer_index, current_customers) :\\n            # set up a backtrack key where you use the sorted form of each to capture as many possible alternate substates as you can \\n            backtrack_key = \"\".join([str(c_it) for c_it in sorted(current_items)]) + \"-\" + \"\".join([str(c_c) for c_c in sorted(current_customers)]) \\n            # if you reached the end, mark it and return True. Otherwise, if you\\'ve seen this, return what you already found! \\n            if customer_index == number_of_customers : \\n                self.memo[backtrack_key] = True\\n                return True \\n            elif backtrack_key in self.memo : \\n                return self.memo[backtrack_key]\\n\\n            # figure out how much you have \\n            current_amount = quantity[customer_index]\\n\\n            # consider all your items \\n            c_i = 0 \\n            while c_i < len(current_items) :\\n                # if we have an item that is gte here  \\n                if current_items[c_i] >= current_amount :\\n                    # if we are past 0 and have a matching situation  \\n                    if c_i > 0 and current_items[c_i] == current_items[c_i - 1] :\\n                        # go until you run out of room, or until you run out of matches, or until you run into a problem  \\n                        while c_i < len(current_items) and current_items[c_i] == current_items[c_i - 1] and current_items[c_i] >= current_amount : \\n                            c_i += 1 \\n                        # if you ran out of room, nothing to do here, break \\n                        if c_i >= len(current_items) : \\n                            break \\n                        elif current_items[c_i] < current_amount :\\n                            # otherwise, if you ran out items, skip on to the next  \\n                            c_i += 1 \\n                            continue  \\n                    # otherwise, if you have not run out room, and you do have an item worth looking at \\n                    # look at it \\n                    current_items[c_i] -= current_amount\\n                    current_customers[customer_index] = 0 \\n                    # get the key \\n                    temp_key = \"\".join([str(c_it) for c_it in sorted(current_items)]) + \"-\" + \"\".join([str(c_c) for c_c in sorted(current_customers)])\\n                    # check if you have it and it doesn\\'t work \\n                    if temp_key in self.memo and self.memo[temp_key] == False :\\n                        # if it doesn\\'t, unset the looking and then move forward one  \\n                        current_items[c_i] += current_amount\\n                        current_customers[customer_index] = current_amount\\n                        c_i += 1 \\n                        continue \\n                    elif temp_key in self.memo and self.memo[temp_key] == True : \\n                        # if you have the key and it worked already, skip out of there after resetting your backtrack key as well \\n                        self.memo[backtrack_key] = True\\n                        return True \\n                    elif temp_key not in self.memo : \\n                        # otherwise if we have not seen this thing, set up a temp result and lock it in \\n                        temp_result = backtrack(current_items, customer_index + 1, current_customers) \\n                        self.memo[temp_key] = temp_result \\n                        if temp_result == True : \\n                            # on success, update and return \\n                            self.memo[backtrack_key] = True \\n                            return True \\n                        else : \\n                            # on failure, unset and continue \\n                            current_items[c_i] += current_amount \\n                            current_customers[customer_index] = current_amount\\n                            c_i += 1 \\n                            continue \\n                else : \\n                    c_i += 1 \\n                    continue \\n\\n            # if you ran out of room or weren\\'t able to make it work -> set False and return it \\n            self.memo[backtrack_key] = False\\n            return False \\n        \\n        # kick it off with our altered nums and quantities \\n        return backtrack(nums, 0, quantity)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540265,
                "title": "javascript-dfs-dp-backtracking-discretization-518ms",
                "content": "use discretization to minimize the values to improve running speed (solve TLE)\\nexample: discretize([535,535,547,413,547])  // [ 1, 1, 2, 0, 2 ] (413->0 535->1, 547->2)\\n```\\nlet b, f;\\nconst canDistribute = (a, B) => {\\n    B.sort((x, y) => y - x);\\n    let [d, ct] = discretize(a);\\n    b = B, f = Array(ct + 1).fill(0);\\n    d.map(x => f[x]++);\\n    f.sort((x, y) => x - y);\\n    f = f.filter((x, i) => i >= f.length - Math.min(f.length, b.length))\\n    return dfs(0);\\n};\\n\\nconst dfs = (idx) => {\\n    if (idx >= b.length) return true;\\n    for (let i = 0; i < f.length; i++) {\\n        if (f[i] >= b[idx]) {\\n            f[i] -= b[idx];\\n            if (dfs(idx + 1)) return true;\\n            f[i] += b[idx];\\n        }\\n    }\\n    return false;\\n};\\n\\nconst discretize = (a) => {\\n    let n = a.length, d = a.map((x, i) => [i, x]).sort((x, y) => x[1] - y[1] || x[0] - y[0]), cur = 0, res = Array(n).fill(0);\\n    d.map((e, i) => {\\n        if (i - 1 >= 0 && e[1] != d[i - 1][1]) cur++;\\n        res[e[0]] = cur;\\n    })\\n    return [res, cur];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nlet b, f;\\nconst canDistribute = (a, B) => {\\n    B.sort((x, y) => y - x);\\n    let [d, ct] = discretize(a);\\n    b = B, f = Array(ct + 1).fill(0);\\n    d.map(x => f[x]++);\\n    f.sort((x, y) => x - y);\\n    f = f.filter((x, i) => i >= f.length - Math.min(f.length, b.length))\\n    return dfs(0);\\n};\\n\\nconst dfs = (idx) => {\\n    if (idx >= b.length) return true;\\n    for (let i = 0; i < f.length; i++) {\\n        if (f[i] >= b[idx]) {\\n            f[i] -= b[idx];\\n            if (dfs(idx + 1)) return true;\\n            f[i] += b[idx];\\n        }\\n    }\\n    return false;\\n};\\n\\nconst discretize = (a) => {\\n    let n = a.length, d = a.map((x, i) => [i, x]).sort((x, y) => x[1] - y[1] || x[0] - y[0]), cur = 0, res = Array(n).fill(0);\\n    d.map((e, i) => {\\n        if (i - 1 >= 0 && e[1] != d[i - 1][1]) cur++;\\n        res[e[0]] = cur;\\n    })\\n    return [res, cur];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418226,
                "title": "easy-methode-simple-approach-simple-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canDistributeHelper(vector<int>& count, vector<int>& quantity,int ithCustomer){\\n        if(ithCustomer == quantity.size()){\\n            return true;\\n        }\\n        for(int i=0;i<count.size();i++){\\n            if(count[i] >= quantity[ithCustomer]){\\n                count[i] -= quantity[ithCustomer];\\n                if(canDistributeHelper(count,quantity,ithCustomer+1)){\\n                    return true;\\n                }\\n                count[i] += quantity[ithCustomer];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> countMap;\\n        for(auto num : nums){\\n            countMap[num]++;\\n\\n        }\\n        vector<int>count;\\n        for(auto it:countMap){\\n            count.push_back(it.second);\\n        }\\n        sort(quantity.rbegin(),quantity.rend());\\n        return canDistributeHelper(count,quantity,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canDistributeHelper(vector<int>& count, vector<int>& quantity,int ithCustomer){\\n        if(ithCustomer == quantity.size()){\\n            return true;\\n        }\\n        for(int i=0;i<count.size();i++){\\n            if(count[i] >= quantity[ithCustomer]){\\n                count[i] -= quantity[ithCustomer];\\n                if(canDistributeHelper(count,quantity,ithCustomer+1)){\\n                    return true;\\n                }\\n                count[i] += quantity[ithCustomer];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> countMap;\\n        for(auto num : nums){\\n            countMap[num]++;\\n\\n        }\\n        vector<int>count;\\n        for(auto it:countMap){\\n            count.push_back(it.second);\\n        }\\n        sort(quantity.rbegin(),quantity.rend());\\n        return canDistributeHelper(count,quantity,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354901,
                "title": "easy-peasy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool solve(vector<int>& quantity,map<int,int> &count,int index){\\n//base case\\nif(index == quantity.size()){\\n  return true;\\n}\\n\\n//rec\\n\\nfor(auto it=count.begin();it!=count.end();it++)\\n{ //for example:(2,2) check if 2 >= quantity[index]\\n  if(it->second >= quantity[index]){\\n    count[it->first]=count[it->first]-quantity[index];\\n    bool solver=solve(quantity,count,index+1);\\n    if(solver == true){\\n      return true;\\n    }\\n    //backtracking(if the current state is false,backtrack to pevious state)\\n    count[it->first]=count[it->first]+quantity[index];\\n  }\\n}\\n\\nreturn false;\\n}\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int>count;\\n        for(int i=0;i<nums.size();i++){\\n          count[nums[i]]++;\\n        }\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\nbool ans=solve(quantity,count,0);\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool solve(vector<int>& quantity,map<int,int> &count,int index){\\n//base case\\nif(index == quantity.size()){\\n  return true;\\n}\\n\\n//rec\\n\\nfor(auto it=count.begin();it!=count.end();it++)\\n{ //for example:(2,2) check if 2 >= quantity[index]\\n  if(it->second >= quantity[index]){\\n    count[it->first]=count[it->first]-quantity[index];\\n    bool solver=solve(quantity,count,index+1);\\n    if(solver == true){\\n      return true;\\n    }\\n    //backtracking(if the current state is false,backtrack to pevious state)\\n    count[it->first]=count[it->first]+quantity[index];\\n  }\\n}\\n\\nreturn false;\\n}\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int>count;\\n        for(int i=0;i<nums.size();i++){\\n          count[nums[i]]++;\\n        }\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\nbool ans=solve(quantity,count,0);\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333895,
                "title": "importance-of-failing-fast-on-backtrack",
                "content": "# Intuition\\n\\nDisclaimer: I originally came with a very similar solution, but was at the threshold of failure due to TLE until I checked the fastest solutions. Unfortunately I dont have the handle of the person to give the credit.\\n\\nThe difference between my code and the faster version is that on the original code I processed the quantity values in the order that they were provided, or even worst some versions were processing the quantity values from smallest to biggest! To achieve the best performance we must process from biggest to smallest.\\n\\nThe reason for this is simple, the bigger quantities have less matching scenarios, causing the backtrack tree to have smaller initial situations, therefore we avoid testing a lot of levels just to fail at the end (i.e we fail faster in this scenario)\\n\\n# Approach\\n- Backtrack\\n\\n# Complexity\\n- Time complexity:\\n$$O(nums.length^{quantity.length})$$\\n\\n- Space complexity:\\n$$O(quantity.length)$$\\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/0b958d5e-05d7-4649-a082-82974456d189_1679610091.3029313.png)\\n\\n```java\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        // Counting the frequency of each item\\n        int[] tmp=new int[1001];\\n        for(int n: nums) tmp[n]++;\\n        // removing items with frequency 0 to enhance performance\\n        int nonZeroCount=0;\\n        for(int f: tmp) if(f!=0) nonZeroCount++;\\n        int[] fa=new int[nonZeroCount];\\n        for(int f: tmp) if(f!=0) fa[--nonZeroCount]=f;\\n\\n        // This was not originally in my code and makes all\\n        // the difference in the world\\n        Arrays.sort(quantity);\\n        // It is important to decrease the index so we process\\n        // bigger items first\\n        return helper(quantity.length-1,fa,quantity);\\n    }\\n    boolean helper(int in, int[] fa, int[] quantity) {\\n        if(in==-1) return true;\\n        int need=quantity[in];\\n        for(int i=fa.length-1;i>-1;i--) {\\n            if(fa[i]<need||i>0&&fa[i]==fa[i-1]) continue;\\n            fa[i]-=need;\\n            // Notice that we decrease the index so to process\\n            // bigger values first\\n            if(helper(in-1,fa,quantity)) return true;\\n            fa[i]+=need;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        // Counting the frequency of each item\\n        int[] tmp=new int[1001];\\n        for(int n: nums) tmp[n]++;\\n        // removing items with frequency 0 to enhance performance\\n        int nonZeroCount=0;\\n        for(int f: tmp) if(f!=0) nonZeroCount++;\\n        int[] fa=new int[nonZeroCount];\\n        for(int f: tmp) if(f!=0) fa[--nonZeroCount]=f;\\n\\n        // This was not originally in my code and makes all\\n        // the difference in the world\\n        Arrays.sort(quantity);\\n        // It is important to decrease the index so we process\\n        // bigger items first\\n        return helper(quantity.length-1,fa,quantity);\\n    }\\n    boolean helper(int in, int[] fa, int[] quantity) {\\n        if(in==-1) return true;\\n        int need=quantity[in];\\n        for(int i=fa.length-1;i>-1;i--) {\\n            if(fa[i]<need||i>0&&fa[i]==fa[i-1]) continue;\\n            fa[i]-=need;\\n            // Notice that we decrease the index so to process\\n            // bigger values first\\n            if(helper(in-1,fa,quantity)) return true;\\n            fa[i]+=need;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280041,
                "title": "c-easy-solution-backtraking-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int i,vector<int>& nums,vector<int>& q,map<int,int>& mp,int n,int m){\\n        if(i==m){\\n            return true;\\n        }\\n        for(auto it:mp){\\n            if(it.second>=q[i]){\\n                mp[it.first]-=q[i];\\n                int temp=find(i+1,nums,q,mp,n,m);\\n                if(temp){\\n                    return true;\\n                }         \\n                mp[it.first]+=q[i];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int n=nums.size(),m=quantity.size();\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n       map<int,int> mp;\\n       for(int i=0;i<n;i++){\\n           mp[nums[i]]++;\\n       }\\n       return find(0,nums,quantity,mp,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int i,vector<int>& nums,vector<int>& q,map<int,int>& mp,int n,int m){\\n        if(i==m){\\n            return true;\\n        }\\n        for(auto it:mp){\\n            if(it.second>=q[i]){\\n                mp[it.first]-=q[i];\\n                int temp=find(i+1,nums,q,mp,n,m);\\n                if(temp){\\n                    return true;\\n                }         \\n                mp[it.first]+=q[i];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int n=nums.size(),m=quantity.size();\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n       map<int,int> mp;\\n       for(int i=0;i<n;i++){\\n           mp[nums[i]]++;\\n       }\\n       return find(0,nums,quantity,mp,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251846,
                "title": "simple-explaination-c-backtracking",
                "content": "# Approach:\\n\\nThe problem requires us to distribute elements from a given array into groups based on a given quantity distribution.\\nWe can use a recursive approach to check if it\\'s possible to distribute the elements to satisfy the given quantity distribution.\\n# Algorithm:\\n\\n1. First, count the occurrences of each element in the given array using an unordered map.\\n2. Sort the quantity distribution in non-increasing order.\\n3. Call a recursive function with arguments quantity, cnt (unordered map), and index.\\n4. The recursive function checks if we have satisfied all the quantities in the quantity vector. If we have, it returns true.\\n5. If not, it loops through each element in the cnt unordered map and checks if we can use it to satisfy the current quantity at index index in the quantity vector.\\n6. If we can, we subtract the count of that element from cnt, call the solve function recursively with the next index, and check if the recursive call returns true.\\n7. If it does, we return true. If not, we add the count of that element back to cnt and continue with the next element in the map.\\n8. If we\\'ve checked all elements in the map and none of them can be used to satisfy the current quantity, we return false.\\n# Space Complexity:\\n\\n- The space complexity of the algorithm is O(N+M) where N is the size of the nums array and M is the number of unique elements in nums.\\n- This is because we\\'re using an unordered map to count the occurrences of each element in nums, which has space complexity O(M).\\n- The recursion stack space used by the recursive function is also O(M) since the function will recurse M times at most.\\n# Time Complexity:\\n\\n- The time complexity of the algorithm is O(N * 2^M) where N is the size of the nums array and M is the number of unique elements in nums.\\n- This is because for each element in nums, we check if we can use it to satisfy each quantity in the quantity vector. There are M unique elements, so we need to make M choices for each element in nums.\\n- Since we use backtracking to explore all possible choices, the time complexity of the algorithm is O(N * 2^M).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quantity, unordered_map<int,int>&cnt, int index)\\n    {\\n        if(index == quantity.size())\\n        {\\n            return true;\\n        }\\n\\n        for(auto it = cnt.begin(); it != cnt.end(); it++)\\n        {\\n            if(it -> second >= quantity[index])\\n            {\\n                cnt[it->first] = cnt[it->first] - quantity[index];\\n                \\n                bool aageKaAns = solve(quantity, cnt , index + 1);\\n\\n                if( aageKaAns == true )\\n                {\\n                    return true;\\n                }\\n                else\\n                {\\n                    cnt[it->first] = cnt[it->first] + quantity[index];\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n       unordered_map<int,int>cnt;\\n\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n\\n        for(auto& it : nums)\\n        {\\n            cnt[it]++;\\n        }\\n\\n        return solve(quantity, cnt , 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quantity, unordered_map<int,int>&cnt, int index)\\n    {\\n        if(index == quantity.size())\\n        {\\n            return true;\\n        }\\n\\n        for(auto it = cnt.begin(); it != cnt.end(); it++)\\n        {\\n            if(it -> second >= quantity[index])\\n            {\\n                cnt[it->first] = cnt[it->first] - quantity[index];\\n                \\n                bool aageKaAns = solve(quantity, cnt , index + 1);\\n\\n                if( aageKaAns == true )\\n                {\\n                    return true;\\n                }\\n                else\\n                {\\n                    cnt[it->first] = cnt[it->first] + quantity[index];\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n       unordered_map<int,int>cnt;\\n\\n        sort(quantity.begin(), quantity.end(), greater<int>());\\n\\n        for(auto& it : nums)\\n        {\\n            cnt[it]++;\\n        }\\n\\n        return solve(quantity, cnt , 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248942,
                "title": "python-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canDistribute(self, nums, quantity):\\n        n, m = len(nums), len(quantity)\\n\\n        dict1 = collections.Counter(nums)\\n\\n        quantity.sort(reverse = True)\\n\\n        def dfs(i):\\n            if i == m:\\n                return True \\n\\n            for key,val in dict1.items():\\n                if val >= quantity[i]:\\n                    dict1[key] -= quantity[i]\\n\\n                    if dfs(i+1):\\n                        return True\\n\\n                    dict1[key] += quantity[i]\\n\\n            return False \\n\\n        return dfs(0)\\n\\n\\n\\n            \\n\\n\\n\\n        \\n\\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums, quantity):\\n        n, m = len(nums), len(quantity)\\n\\n        dict1 = collections.Counter(nums)\\n\\n        quantity.sort(reverse = True)\\n\\n        def dfs(i):\\n            if i == m:\\n                return True \\n\\n            for key,val in dict1.items():\\n                if val >= quantity[i]:\\n                    dict1[key] -= quantity[i]\\n\\n                    if dfs(i+1):\\n                        return True\\n\\n                    dict1[key] += quantity[i]\\n\\n            return False \\n\\n        return dfs(0)\\n\\n\\n\\n            \\n\\n\\n\\n        \\n\\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242963,
                "title": "c-easiest-solution-using-recursion-and-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quantity,map<int,int>&cnt,int index){\\n        // base case\\n        if(index == quantity.size()){\\n            return true;\\n        }\\n        for(auto it = cnt.begin() ;it!=cnt.end() ;it++){\\n            if(it->second >= quantity[index]){\\n                //action\\n                cnt[it->first] = cnt[it->first] - quantity[index];\\n                //recursive relation\\n                bool aagesolution = solve(quantity,cnt,index+1);\\n                if(aagesolution){\\n                    return true;\\n                }\\n                else{\\n                    //backtrack \\n                    cnt[it->first]  = cnt[it->first] + quantity[index];\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int> cnt;\\n        for(int i =0;i<nums.size();i++){\\n            cnt[nums[i]]++;\\n        }\\n\\n        //sort the quantity in decreasing order\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n\\n        bool ans = solve(quantity,cnt,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& quantity,map<int,int>&cnt,int index){\\n        // base case\\n        if(index == quantity.size()){\\n            return true;\\n        }\\n        for(auto it = cnt.begin() ;it!=cnt.end() ;it++){\\n            if(it->second >= quantity[index]){\\n                //action\\n                cnt[it->first] = cnt[it->first] - quantity[index];\\n                //recursive relation\\n                bool aagesolution = solve(quantity,cnt,index+1);\\n                if(aagesolution){\\n                    return true;\\n                }\\n                else{\\n                    //backtrack \\n                    cnt[it->first]  = cnt[it->first] + quantity[index];\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int,int> cnt;\\n        for(int i =0;i<nums.size();i++){\\n            cnt[nums[i]]++;\\n        }\\n\\n        //sort the quantity in decreasing order\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n\\n        bool ans = solve(quantity,cnt,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213418,
                "title": "using-java-backtracking-approach",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    private void reverseArray(int[] arr){\\n        int l=0,h=arr.length-1;\\n        while(l<h){\\n            int temp=arr[l];\\n            arr[l]=arr[h];\\n            arr[h]=temp;\\n            l++;\\n            h--;\\n        }\\n        return;\\n    }\\n\\n \\n    private boolean recursive_approach(int a1Idx,int[] arr1,int[] arr2){\\n        int n=arr1.length;\\n        if(a1Idx==n){\\n            return true;\\n        }\\n\\n        //maximum this loop runs upto 50 times as\\n        //we can have atmost 50 unique values\\n        for(int i=0;i<arr2.length;i++){\\n            \\n            if(arr2[i]>=arr1[a1Idx]){\\n                arr2[i]=arr2[i]-arr1[a1Idx];\\n                boolean flage=recursive_approach(a1Idx+1,arr1,arr2);\\n                if(flage==true) return true;\\n                arr2[i]=arr2[i]+arr1[a1Idx];\\n            }\\n            \\n            \\n        }\\n        return false;\\n    }\\n\\n   \\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n\\n        Map<Integer,Integer>mp=new HashMap<>();\\n\\n        //atmost we can have 50 unique values\\n        //tracks the count of the unique keys present\\n        for(int i:nums){\\n            mp.put(i,mp.getOrDefault(i,0)+1);\\n        }\\n\\n        int[] frequencyArr=new int[mp.size()];\\n        int idx=0;\\n        for(var e:mp.keySet()){\\n            frequencyArr[idx++]=mp.get(e);\\n        }\\n\\n        \\n        Arrays.sort(quantity);\\n        Arrays.sort(frequencyArr);\\n        reverseArray(quantity);\\n\\n\\n        //recursive_approach\\n        boolean flage=recursive_approach(0,quantity,frequencyArr);\\n        return flage;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    private void reverseArray(int[] arr){\\n        int l=0,h=arr.length-1;\\n        while(l<h){\\n            int temp=arr[l];\\n            arr[l]=arr[h];\\n            arr[h]=temp;\\n            l++;\\n            h--;\\n        }\\n        return;\\n    }\\n\\n \\n    private boolean recursive_approach(int a1Idx,int[] arr1,int[] arr2){\\n        int n=arr1.length;\\n        if(a1Idx==n){\\n            return true;\\n        }\\n\\n        //maximum this loop runs upto 50 times as\\n        //we can have atmost 50 unique values\\n        for(int i=0;i<arr2.length;i++){\\n            \\n            if(arr2[i]>=arr1[a1Idx]){\\n                arr2[i]=arr2[i]-arr1[a1Idx];\\n                boolean flage=recursive_approach(a1Idx+1,arr1,arr2);\\n                if(flage==true) return true;\\n                arr2[i]=arr2[i]+arr1[a1Idx];\\n            }\\n            \\n            \\n        }\\n        return false;\\n    }\\n\\n   \\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n\\n        Map<Integer,Integer>mp=new HashMap<>();\\n\\n        //atmost we can have 50 unique values\\n        //tracks the count of the unique keys present\\n        for(int i:nums){\\n            mp.put(i,mp.getOrDefault(i,0)+1);\\n        }\\n\\n        int[] frequencyArr=new int[mp.size()];\\n        int idx=0;\\n        for(var e:mp.keySet()){\\n            frequencyArr[idx++]=mp.get(e);\\n        }\\n\\n        \\n        Arrays.sort(quantity);\\n        Arrays.sort(frequencyArr);\\n        reverseArray(quantity);\\n\\n\\n        //recursive_approach\\n        boolean flage=recursive_approach(0,quantity,frequencyArr);\\n        return flage;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192952,
                "title": "python3-memory-efficient-and-fast-dfs-with-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis can be approached as a DFS problem with memoization and greedy search space reduction.\\n\\nFirst, one should observe the recursive property of the problem: A customer comes and wants a certain amount of equal integers. There might be mutliple equal integers we could give him, which the changes the equal integers we can give the next customer.\\n\\nSo we need a recursion, that has as input the current customer we are dealing with and which are left and the amount of equal integers we have left. The customers that are left can be coded as a pointer into the customer array. The amount of equal integers ist more difficult. At first, on can realize that we count the amount of equal integers per integer, but it does not really matter which customer gets which integer, it is only important how many we have of those. E.G. if we have four 4\\'s and four 3\\'s our recursive relation does not care or change if we give the customer 4s or 3s. Therefore we can code our state of integers left as a dict, that tells us we have: 3 equal integers two times for the example above.\\n\\nWe can then use these two things (count of equal integers and pointer into the customer array) to make a unique key for a state. Also that state repeats so we can add memoization to not compute problems again. I use a frozenset over the items of our counter dict as a pythonic and fast way to make a hashable tuple from the dict.\\n\\nThe second thing one needs to figure our is that we can decrease our search space much faster by dealing with difficult customers first (the ones wanting a whole lot of equal numbers), as there are only a few possibilities of those, which reduces the number of splits at the beginning of our recursion tree.\\n\\nThe problem really needs some time to figure out. Maybe try to look at my code. I myself was really surpised, I figured this out\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach includes memoization, state coding and search space reduction\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI haven\\'t figured it out yet, please let me know if you have an idea.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nI haven\\'t figured it out yet, please let me know if you have an idea.\\n# Code\\n```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n\\n        # count the amount of same integers\\n        cn = collections.Counter(collections.Counter(nums).values())\\n        \\n        # sort the customers to deal with the most difficult ones first\\n        quantity.sort(reverse=True)\\n\\n        # make recursive dfs with memoization\\n        cache = dict()\\n        def dfs(items, idx):\\n            if idx >= len(quantity): return True\\n            tp_it = frozenset(items.items())\\n            if (tp_it, idx) not in cache:\\n\\n                # go though all the frequent items\\n                result = False\\n                for qnti, nq in list(items.items()):\\n                    \\n                    # check whether we have similar integers\\n                    if not nq or qnti < quantity[idx]: continue\\n\\n                    # update our items\\n                    items[qnti] -= 1\\n                    items[qnti-quantity[idx]] += 1\\n\\n                    # recurse deeper\\n                    if dfs(items, idx+1):\\n                        result = True\\n                        break\\n\\n                    # undo changes to items\\n                    items[qnti] += 1\\n                    items[qnti-quantity[idx]] -= 1\\n                \\n                # set the cache\\n                cache[(tp_it, idx)] = result\\n            return cache[(tp_it, idx)]\\n        return dfs(cn, 0)\\n\\n                    \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n\\n        # count the amount of same integers\\n        cn = collections.Counter(collections.Counter(nums).values())\\n        \\n        # sort the customers to deal with the most difficult ones first\\n        quantity.sort(reverse=True)\\n\\n        # make recursive dfs with memoization\\n        cache = dict()\\n        def dfs(items, idx):\\n            if idx >= len(quantity): return True\\n            tp_it = frozenset(items.items())\\n            if (tp_it, idx) not in cache:\\n\\n                # go though all the frequent items\\n                result = False\\n                for qnti, nq in list(items.items()):\\n                    \\n                    # check whether we have similar integers\\n                    if not nq or qnti < quantity[idx]: continue\\n\\n                    # update our items\\n                    items[qnti] -= 1\\n                    items[qnti-quantity[idx]] += 1\\n\\n                    # recurse deeper\\n                    if dfs(items, idx+1):\\n                        result = True\\n                        break\\n\\n                    # undo changes to items\\n                    items[qnti] += 1\\n                    items[qnti-quantity[idx]] -= 1\\n                \\n                # set the cache\\n                cache[(tp_it, idx)] = result\\n            return cache[(tp_it, idx)]\\n        return dfs(cn, 0)\\n\\n                    \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187911,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn can_distribute(nums: Vec<i32>, quantity: Vec<i32>) -> bool {\\n        use std::collections::HashMap;\\n\\n        fn backtrack(counts: &mut Vec<i32>, quantity: &Vec<i32>, index: usize) -> bool {\\n            if index == quantity.len() {\\n                return true;\\n            }\\n            for i in 0..counts.len() {\\n                if counts[i] >= quantity[index] {\\n                    let p = quantity[index];\\n                    counts[i] -= p;\\n                    if backtrack(counts, quantity, index + 1) {\\n                        return true;\\n                    }\\n                    counts[i] += p;\\n                }\\n            }\\n            false\\n        }\\n\\n        let mut counts = HashMap::new();\\n        for n in nums.iter() {\\n            *counts.entry(*n).or_insert(0) += 1;\\n        }\\n        let mut counts = counts.values().copied().collect::<Vec<_>>();\\n        counts.sort_by(|a, b| b.cmp(a));\\n        let mut quantity = quantity;\\n        quantity.sort_by(|a, b| b.cmp(a));\\n\\n        backtrack(&mut counts, &quantity, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn can_distribute(nums: Vec<i32>, quantity: Vec<i32>) -> bool {\\n        use std::collections::HashMap;\\n\\n        fn backtrack(counts: &mut Vec<i32>, quantity: &Vec<i32>, index: usize) -> bool {\\n            if index == quantity.len() {\\n                return true;\\n            }\\n            for i in 0..counts.len() {\\n                if counts[i] >= quantity[index] {\\n                    let p = quantity[index];\\n                    counts[i] -= p;\\n                    if backtrack(counts, quantity, index + 1) {\\n                        return true;\\n                    }\\n                    counts[i] += p;\\n                }\\n            }\\n            false\\n        }\\n\\n        let mut counts = HashMap::new();\\n        for n in nums.iter() {\\n            *counts.entry(*n).or_insert(0) += 1;\\n        }\\n        let mut counts = counts.values().copied().collect::<Vec<_>>();\\n        counts.sort_by(|a, b| b.cmp(a));\\n        let mut quantity = quantity;\\n        quantity.sort_by(|a, b| b.cmp(a));\\n\\n        backtrack(&mut counts, &quantity, 0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3170542,
                "title": "c-backtrack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& A, vector<int>& Q) {\\n        int cnt[1001]{}, m = Q.size();\\n        unordered_set<int> keys;\\n        for(auto e : A) {\\n            cnt[e]++;\\n            keys.insert(e);\\n        }\\n\\n        sort(rbegin(Q), rend(Q));\\n\\n        function<bool(int)> dfs = [&](int t) {\\n            if(t >= m) return true;\\n            for(auto k : keys) {\\n                if(cnt[k] >= Q[t]) {\\n                    cnt[k] -= Q[t];\\n                    if(dfs(t+1)) return true;\\n                    cnt[k] += Q[t];\\n                }\\n            }\\n            return false;\\n        };\\n        return dfs(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& A, vector<int>& Q) {\\n        int cnt[1001]{}, m = Q.size();\\n        unordered_set<int> keys;\\n        for(auto e : A) {\\n            cnt[e]++;\\n            keys.insert(e);\\n        }\\n\\n        sort(rbegin(Q), rend(Q));\\n\\n        function<bool(int)> dfs = [&](int t) {\\n            if(t >= m) return true;\\n            for(auto k : keys) {\\n                if(cnt[k] >= Q[t]) {\\n                    cnt[k] -= Q[t];\\n                    if(dfs(t+1)) return true;\\n                    cnt[k] += Q[t];\\n                }\\n            }\\n            return false;\\n        };\\n        return dfs(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095291,
                "title": "c-easy-backtracking-method",
                "content": "# Intuition\\nWe need to try more ways in which we distrubute the repeating numbers, because we can distribute them in more ways but not all of them will satisfy all customers.\\n\\n# Approach\\nCreate a histogram(count how many times each number was seen) and we will try to satisfy all customers while going through the histogram, once we have a good match we try to solve using that number from the histogram as modified, if that doesn\\'t work, we go back, revert the change and try another permutation.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool Solve(vector<int>& quantity, map<int, int>& pairs, int qindex){\\n        if(qindex == quantity.size()){\\n            return true;\\n        }\\n\\n        for(auto& element : pairs){\\n            if(quantity[qindex] <= element.second){\\n                element.second -= quantity[qindex];\\n                if(Solve(quantity, pairs, qindex + 1)){\\n                    return true;\\n                }\\n                element.second += quantity[qindex];\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int, int> pairs;\\n        \\n        for(auto& n : nums){\\n            ++pairs[n];\\n        }\\n\\n        std::sort(quantity.begin(), quantity.end(), greater<>());\\n\\n        return Solve(quantity, pairs, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool Solve(vector<int>& quantity, map<int, int>& pairs, int qindex){\\n        if(qindex == quantity.size()){\\n            return true;\\n        }\\n\\n        for(auto& element : pairs){\\n            if(quantity[qindex] <= element.second){\\n                element.second -= quantity[qindex];\\n                if(Solve(quantity, pairs, qindex + 1)){\\n                    return true;\\n                }\\n                element.second += quantity[qindex];\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        map<int, int> pairs;\\n        \\n        for(auto& n : nums){\\n            ++pairs[n];\\n        }\\n\\n        std::sort(quantity.begin(), quantity.end(), greater<>());\\n\\n        return Solve(quantity, pairs, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076334,
                "title": "python-dfs-solution-cache-in-tuple-99-faster",
                "content": "```\\ndef canDistribute(self, nums: List[int], q: List[int]) -> bool:\\n\\tnums = sorted(nlargest(len(q), Counter(nums).values()), reverse=True)\\n\\tq = sorted(q, reverse=True)\\n\\n\\t@lru_cache(None)\\n\\tdef dfs(tup, i):\\n\\t\\tif i == len(q):\\n\\t\\t\\treturn True\\n\\t\\tfor k in range(len(tup)):\\n\\t\\t\\tif tup[k] >= q[i]:\\n\\t\\t\\t\\tnxt = list(tup[:k])+[tup[k]-q[i]]+list(tup[k+1:])\\n\\t\\t\\t\\tif dfs(tuple(sorted(nxt, reverse=True)), i+1):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\treturn dfs(tuple(nums), 0)\\n```",
                "solutionTags": [],
                "code": "```\\ndef canDistribute(self, nums: List[int], q: List[int]) -> bool:\\n\\tnums = sorted(nlargest(len(q), Counter(nums).values()), reverse=True)\\n\\tq = sorted(q, reverse=True)\\n\\n\\t@lru_cache(None)\\n\\tdef dfs(tup, i):\\n\\t\\tif i == len(q):\\n\\t\\t\\treturn True\\n\\t\\tfor k in range(len(tup)):\\n\\t\\t\\tif tup[k] >= q[i]:\\n\\t\\t\\t\\tnxt = list(tup[:k])+[tup[k]-q[i]]+list(tup[k+1:])\\n\\t\\t\\t\\tif dfs(tuple(sorted(nxt, reverse=True)), i+1):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\treturn dfs(tuple(nums), 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3060161,
                "title": "74-87-faster-c-bitmask-dp-simple-clean-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[1<<10][51];\\n    vector<ll>pre;\\n\\n    ll solve(vector<ll>&container,vector<int>&quantity,ll mask,ll index,ll m,ll n){\\n        if(mask==(1<<m)-1){\\n            return 1;\\n        }\\n        if(index>=n){\\n            return 0;\\n        }\\n        if(dp[mask][index]!=-1){\\n            return dp[mask][index];\\n        }\\n        ll answer=0,current=mask^((1<<m)-1);\\n        answer=(answer+solve(container,quantity,mask,index+1,m,n));\\n        for(ll i=current;i>0;i=(i-1)&current){\\n            if(pre[i]>container[index]){\\n                continue;\\n            }\\n            answer=(answer+solve(container,quantity,mask|i,index+1,m,n));\\n        }\\n        return dp[mask][index]=answer;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        ll m=quantity.size();\\n        memset(dp,-1,sizeof(dp));\\n        unordered_map<ll,ll>mp1;\\n        for(auto &x:nums){\\n            mp1[x]++;\\n        }\\n        vector<ll>container;\\n        for(auto &x:mp1){\\n            container.push_back(x.second);\\n        }\\n        pre.resize(1<<m);\\n        for(ll i=0;i<(1<<m);i++){\\n            ll sum=0;\\n            for(ll j=0;j<m;j++){\\n                if(i&(1<<j)){\\n                    sum+=quantity[j];\\n                }\\n            }\\n            pre[i]=sum;\\n        }\\n        ll n=container.size();\\n        return solve(container,quantity,0,0,m,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[1<<10][51];\\n    vector<ll>pre;\\n\\n    ll solve(vector<ll>&container,vector<int>&quantity,ll mask,ll index,ll m,ll n){\\n        if(mask==(1<<m)-1){\\n            return 1;\\n        }\\n        if(index>=n){\\n            return 0;\\n        }\\n        if(dp[mask][index]!=-1){\\n            return dp[mask][index];\\n        }\\n        ll answer=0,current=mask^((1<<m)-1);\\n        answer=(answer+solve(container,quantity,mask,index+1,m,n));\\n        for(ll i=current;i>0;i=(i-1)&current){\\n            if(pre[i]>container[index]){\\n                continue;\\n            }\\n            answer=(answer+solve(container,quantity,mask|i,index+1,m,n));\\n        }\\n        return dp[mask][index]=answer;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        ll m=quantity.size();\\n        memset(dp,-1,sizeof(dp));\\n        unordered_map<ll,ll>mp1;\\n        for(auto &x:nums){\\n            mp1[x]++;\\n        }\\n        vector<ll>container;\\n        for(auto &x:mp1){\\n            container.push_back(x.second);\\n        }\\n        pre.resize(1<<m);\\n        for(ll i=0;i<(1<<m);i++){\\n            ll sum=0;\\n            for(ll j=0;j<m;j++){\\n                if(i&(1<<j)){\\n                    sum+=quantity[j];\\n                }\\n            }\\n            pre[i]=sum;\\n        }\\n        ll n=container.size();\\n        return solve(container,quantity,0,0,m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045265,
                "title": "c-tried-to-explain-every-step-backtracking-easy-solution",
                "content": "```\\n/*\\nIntution :\\n\\n1-> Count the frequencies and make an array out of it\\n2-> Sort the quantities in descending order. We do this to get an early termination if for\\n    the max value in quantity we are not able to find a collection of integers\\n3-> Call the recursive function\\n4-> Recursive Code is explained below\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    bool solve(vector<int>& freq, vector<int>& quantity, int idx) {\\n        \\n        // If we have fullly traversed the quantity array means that we were able to satisfy\\n        // everyone so return true\\n        if(idx == quantity.size())\\n            return true;\\n        \\n        // For every \\'quantity\\' value check if freq array has a value that can satisfy it\\n        // If yes call the recursive function for the next quantity value \\n        \\n        // As true will only be hit when we get to the end of the \\'quantity\\' array \\n        // This would lead to a chain of return true statements that would finally return\\n        // true to our calling function\\n        \\n        for(int i=0; i<freq.size(); i++) {\\n            \\n            if(freq[i] >= quantity[idx]) {\\n                freq[i] -= quantity[idx];\\n                \\n                // Calling Recursively\\n                if(solve(freq,quantity,idx+1)) {\\n                    return true;\\n                }\\n                // backtracting step\\n                // as it may be possible that we would want to assign a different collection \\n                // of integers to this particular customer\\n                else {\\n                    freq[i] += quantity[idx];\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> freq;\\n        \\n        // 1)\\n        for(int i=0; i<nums.size(); i++) {\\n            if(i == nums.size()-1) {\\n                freq.push_back(1);\\n                continue;\\n            }\\n            \\n            int count = 1;\\n            int n = nums[i];\\n            if(i+1 < nums.size())\\n                i += 1;\\n            \\n            while(true and i<nums.size()) {\\n                if(nums[i] == n) {\\n                    count++;\\n                    i++;\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            i -= 1;\\n            freq.push_back(count);\\n        }\\n        // ---------------------------------------------------------------------------------\\n        \\n        // 2)\\n        auto compare = [](auto &a, auto &b) {\\n            return a > b;\\n        };\\n        sort(quantity.begin(), quantity.end(), compare); \\n        \\n        // ---------------------------------------------------------------------------------\\n        \\n        // 3)\\n        return solve(freq, quantity, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/*\\nIntution :\\n\\n1-> Count the frequencies and make an array out of it\\n2-> Sort the quantities in descending order. We do this to get an early termination if for\\n    the max value in quantity we are not able to find a collection of integers\\n3-> Call the recursive function\\n4-> Recursive Code is explained below\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    bool solve(vector<int>& freq, vector<int>& quantity, int idx) {\\n        \\n        // If we have fullly traversed the quantity array means that we were able to satisfy\\n        // everyone so return true\\n        if(idx == quantity.size())\\n            return true;\\n        \\n        // For every \\'quantity\\' value check if freq array has a value that can satisfy it\\n        // If yes call the recursive function for the next quantity value \\n        \\n        // As true will only be hit when we get to the end of the \\'quantity\\' array \\n        // This would lead to a chain of return true statements that would finally return\\n        // true to our calling function\\n        \\n        for(int i=0; i<freq.size(); i++) {\\n            \\n            if(freq[i] >= quantity[idx]) {\\n                freq[i] -= quantity[idx];\\n                \\n                // Calling Recursively\\n                if(solve(freq,quantity,idx+1)) {\\n                    return true;\\n                }\\n                // backtracting step\\n                // as it may be possible that we would want to assign a different collection \\n                // of integers to this particular customer\\n                else {\\n                    freq[i] += quantity[idx];\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> freq;\\n        \\n        // 1)\\n        for(int i=0; i<nums.size(); i++) {\\n            if(i == nums.size()-1) {\\n                freq.push_back(1);\\n                continue;\\n            }\\n            \\n            int count = 1;\\n            int n = nums[i];\\n            if(i+1 < nums.size())\\n                i += 1;\\n            \\n            while(true and i<nums.size()) {\\n                if(nums[i] == n) {\\n                    count++;\\n                    i++;\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            i -= 1;\\n            freq.push_back(count);\\n        }\\n        // ---------------------------------------------------------------------------------\\n        \\n        // 2)\\n        auto compare = [](auto &a, auto &b) {\\n            return a > b;\\n        };\\n        sort(quantity.begin(), quantity.end(), compare); \\n        \\n        // ---------------------------------------------------------------------------------\\n        \\n        // 3)\\n        return solve(freq, quantity, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017877,
                "title": "explanation-and-typescript-solution",
                "content": "\\nLet (dp1) represent ways to choose customers.\\ndp1[i] => sum of integers ordered by customers represented by bits of i (in binary form)\\nfor eg. if i = 5 => 101 in binary => hence dp1[i] = quantity[2] + quantity[0] where quantity[i] is the amount of integers the ith customer ordered.\\n\\nlet dp represent, whether it is possible to distribute numbers to customer satisfying the criteria (given in question).\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/76114205-34d1-4183-9592-b13732de07c0_1673159686.07661.png)\\n\\n\\n\\n\\n\\n\\n\\n```\\nfunction canDistribute(nums: number[], quantity: number[]): boolean {\\n    const mapNums = new Map<number, number>();\\n    for (let i = 0; i < nums.length; i++) {\\n      let Acount = mapNums.get(nums[i]) || 0;\\n      mapNums.set(nums[i], count + 1);\\n    }\\n    const numsFreq: number[] = [];\\n    let iterator = mapNums.values();\\n    while (true) {\\n      let value = iterator.next();\\n      if (value.done) break;\\n      numsFreq.push(value.value);\\n    }\\n    numsFreq.sort((a, b) => a - b);\\n    const len = Math.pow(2, quantity.length);\\n    const dp1 = new Array<number>(len);\\n\\n    dp1[0] = 0;\\n\\n    const m = quantity.length;\\n\\n    for (let i = 1; i < len; i++) {\\n      let res = 0;\\n      for (let j = 0; j < m; j++) {\\n        let bit = (i >> j) & 1;\\n        if (bit === 1) res += quantity[j];\\n      }\\n      dp1[i] = res;\\n    }\\n    const dp = new Array<boolean[]>(numsFreq.length);\\n    for (let i = 0; i < dp.length; i++) {\\n      dp[i] = new Array<boolean>(len);\\n      for (let j = 0; j < dp[i].length; j++) {\\n        dp[i][j] = true;\\n      }\\n    }\\n\\n    for (let i = 0; i < dp.length; i++) {\\n      for (let j = 1; j < dp[i].length; j++) {\\n        if (i === 0) dp[i][j] = dp1[j] <= numsFreq[i];\\n        else {\\n          let res = false;\\n          for (let k = 0; k <= j; k++) {\\n            let xored = k ^ j;\\n            if (xored > j) continue;\\n            if (xored === j) {\\n              if (dp1[j] <= numsFreq[i]) {\\n                res = true;\\n                break;\\n              }\\n            } else {\\n              if (dp[i - 1][k] && dp1[xored] <= numsFreq[i]) {\\n                res = true;\\n                break;\\n              }\\n            }\\n          }\\n          dp[i][j] = res;\\n        }\\n      }\\n      if (dp[i][dp[i].length - 1]) return true;\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nfunction canDistribute(nums: number[], quantity: number[]): boolean {\\n    const mapNums = new Map<number, number>();\\n    for (let i = 0; i < nums.length; i++) {\\n      let Acount = mapNums.get(nums[i]) || 0;\\n      mapNums.set(nums[i], count + 1);\\n    }\\n    const numsFreq: number[] = [];\\n    let iterator = mapNums.values();\\n    while (true) {\\n      let value = iterator.next();\\n      if (value.done) break;\\n      numsFreq.push(value.value);\\n    }\\n    numsFreq.sort((a, b) => a - b);\\n    const len = Math.pow(2, quantity.length);\\n    const dp1 = new Array<number>(len);\\n\\n    dp1[0] = 0;\\n\\n    const m = quantity.length;\\n\\n    for (let i = 1; i < len; i++) {\\n      let res = 0;\\n      for (let j = 0; j < m; j++) {\\n        let bit = (i >> j) & 1;\\n        if (bit === 1) res += quantity[j];\\n      }\\n      dp1[i] = res;\\n    }\\n    const dp = new Array<boolean[]>(numsFreq.length);\\n    for (let i = 0; i < dp.length; i++) {\\n      dp[i] = new Array<boolean>(len);\\n      for (let j = 0; j < dp[i].length; j++) {\\n        dp[i][j] = true;\\n      }\\n    }\\n\\n    for (let i = 0; i < dp.length; i++) {\\n      for (let j = 1; j < dp[i].length; j++) {\\n        if (i === 0) dp[i][j] = dp1[j] <= numsFreq[i];\\n        else {\\n          let res = false;\\n          for (let k = 0; k <= j; k++) {\\n            let xored = k ^ j;\\n            if (xored > j) continue;\\n            if (xored === j) {\\n              if (dp1[j] <= numsFreq[i]) {\\n                res = true;\\n                break;\\n              }\\n            } else {\\n              if (dp[i - 1][k] && dp1[xored] <= numsFreq[i]) {\\n                res = true;\\n                break;\\n              }\\n            }\\n          }\\n          dp[i][j] = res;\\n        }\\n      }\\n      if (dp[i][dp[i].length - 1]) return true;\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2986447,
                "title": "c-backtracking-self-explainable",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mpp;\\n    bool solve(int ind,vector<int>& quantity){\\n        if(ind==quantity.size()){\\n            return true;\\n        }\\n        for(auto& it:mpp){\\n            if(it.second>=quantity[ind]){\\n                it.second = it.second-quantity[ind];\\n                bool ans = solve(ind+1,quantity);\\n                if(ans){\\n                    return ans;\\n                }\\n                it.second = it.second+quantity[ind];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        for(int i=0;i<nums.size();i++){\\n            mpp[nums[i]]++;\\n        }\\n        //sorting optimizes the code\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n        return solve(0,quantity);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mpp;\\n    bool solve(int ind,vector<int>& quantity){\\n        if(ind==quantity.size()){\\n            return true;\\n        }\\n        for(auto& it:mpp){\\n            if(it.second>=quantity[ind]){\\n                it.second = it.second-quantity[ind];\\n                bool ans = solve(ind+1,quantity);\\n                if(ans){\\n                    return ans;\\n                }\\n                it.second = it.second+quantity[ind];\\n            }\\n        }\\n        return false;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        for(int i=0;i<nums.size();i++){\\n            mpp[nums[i]]++;\\n        }\\n        //sorting optimizes the code\\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n        return solve(0,quantity);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985011,
                "title": "python-bitmask-dp",
                "content": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], qy: List[int]) -> bool:\\n        fr=Counter(nums)\\n        frx=[fr[k] for k in fr]\\n        rbm=[0]\\n        for i in range(len(qy)):rbm[0]|=1<<i\\n        @cache\\n        def dp(fi,ost,bm):\\n            if bm==rbm[0]:return True\\n            if fi>=len(frx):return True if bm==rbm[0] else False\\n            if ost==0:\\n                if fi+1>=len(frx):return True if bm==rbm[0] else False\\n                return dp(fi+1,frx[fi+1],bm)\\n            for i in range(len(qy)):\\n                k=1<<i\\n                if bm&k!=0:continue\\n                if qy[i]<=ost:\\n                    if dp(fi,ost-qy[i],bm|k):return True\\n            if fi+1>=len(frx):return False  \\n            return dp(fi+1,frx[fi+1],bm)\\n        return dp(0,frx[0],0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], qy: List[int]) -> bool:\\n        fr=Counter(nums)\\n        frx=[fr[k] for k in fr]\\n        rbm=[0]\\n        for i in range(len(qy)):rbm[0]|=1<<i\\n        @cache\\n        def dp(fi,ost,bm):\\n            if bm==rbm[0]:return True\\n            if fi>=len(frx):return True if bm==rbm[0] else False\\n            if ost==0:\\n                if fi+1>=len(frx):return True if bm==rbm[0] else False\\n                return dp(fi+1,frx[fi+1],bm)\\n            for i in range(len(qy)):\\n                k=1<<i\\n                if bm&k!=0:continue\\n                if qy[i]<=ost:\\n                    if dp(fi,ost-qy[i],bm|k):return True\\n            if fi+1>=len(frx):return False  \\n            return dp(fi+1,frx[fi+1],bm)\\n        return dp(0,frx[0],0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914918,
                "title": "swift-solution-100-efficient-in-terms-of-time-and-space-complexity",
                "content": "# Approach\\n1. Count the frequencies of each number in nums, and store the frequencies in an array cnts.\\n2. Remove all the zeros from cnts, and store the remaining non-zeros in a list.\\n3. Call the recursive function f with the sorted list q of quanta, and the index of the last element in q.\\n4. If the index i is -1, return true.\\n5. Otherwise, for each element e in the list, if e is greater than or equal to q[i], subtract q[i] from e, and call f with the updated list and the index i-1.\\n6. If f returns true, return true.\\n7. Otherwise, restore the value of e to its original value, and proceed to the next element in the list.\\n8. If f fails to return true for all elements in the list, return false.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    var list = [Int]()\\n    \\n    func f(_ q: [Int], _ i: Int) -> Bool {\\n        if i<0 { return true }\\n        for j in 0..<list.count {\\n            var e = list[j]\\n            if e>=q[i] {\\n                list[j] = e-q[i]\\n                if f(q, i-1) { return true }\\n                list[j] = e\\n            }\\n        }\\n        return false\\n    }\\n    \\n    func canDistribute(_ nums: [Int], _ q: [Int]) -> Bool {\\n        var cnts = [Int](repeating: 0, count: 1001)\\n        for n in nums { cnts[n] += 1 }\\n        for n in cnts {\\n            if n>0 { list.append(n) }\\n        }\\n        return f(q.sorted(), q.count-1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    var list = [Int]()\\n    \\n    func f(_ q: [Int], _ i: Int) -> Bool {\\n        if i<0 { return true }\\n        for j in 0..<list.count {\\n            var e = list[j]\\n            if e>=q[i] {\\n                list[j] = e-q[i]\\n                if f(q, i-1) { return true }\\n                list[j] = e\\n            }\\n        }\\n        return false\\n    }\\n    \\n    func canDistribute(_ nums: [Int], _ q: [Int]) -> Bool {\\n        var cnts = [Int](repeating: 0, count: 1001)\\n        for n in nums { cnts[n] += 1 }\\n        for n in cnts {\\n            if n>0 { list.append(n) }\\n        }\\n        return f(q.sorted(), q.count-1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631467,
                "title": "simple-short-code",
                "content": "```\\nclass Solution{\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll n, m;\\n    vi(ll)freq, cost;\\n    vi(vi(ll))dp;\\n    void getFreq(const vi(int)&v){\\n        vi(ll)ump(100001);\\n        for(ll it:v){\\n            ++ump[it];\\n        }\\n        for(auto it:ump){\\n            if(it>0){\\n                freq.pb(it);\\n            }\\n        }\\n    }\\n    void getCost(const vi(int)&q){\\n        for(ll bm=0;bm<cost.size();++bm){\\n            for(ll i=0;i<n;++i){\\n                if((bm>>i)&1){\\n                    cost[bm]+=q[i];\\n                }\\n            }\\n        }\\n    }\\n    bool func(const vi(int)&q, ll in, ll bm){\\n        if(__builtin_popcount(bm)==n){\\n            return true;\\n        }\\n        if(in==m){\\n            return false;\\n        }\\n        ll&ans=dp[bm][in];\\n        if(ans==-1){\\n            ans=0;\\n            for(ll it=bm;it<cost.size() && !ans;++it){\\n                if(bm!=(it&bm) || freq[in]<cost[bm^it]){\\n                    continue;\\n                }\\n                freq[in]-=cost[bm^it];\\n                ans|=func(q, in+1, it);\\n                freq[in]+=cost[bm^it];\\n            }\\n        }\\n        return ans;\\n    }\\n    bool canDistribute(vector<int>&v, vector<int>&q) {\\n        getFreq(v);\\n        m=freq.size(), n=q.size();\\n        dp.assign(1<<n, vi(ll)(m, -1)), cost.assign(1<<n, 0);\\n        getCost(q);\\n        return func(q, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution{\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll n, m;\\n    vi(ll)freq, cost;\\n    vi(vi(ll))dp;\\n    void getFreq(const vi(int)&v){\\n        vi(ll)ump(100001);\\n        for(ll it:v){\\n            ++ump[it];\\n        }\\n        for(auto it:ump){\\n            if(it>0){\\n                freq.pb(it);\\n            }\\n        }\\n    }\\n    void getCost(const vi(int)&q){\\n        for(ll bm=0;bm<cost.size();++bm){\\n            for(ll i=0;i<n;++i){\\n                if((bm>>i)&1){\\n                    cost[bm]+=q[i];\\n                }\\n            }\\n        }\\n    }\\n    bool func(const vi(int)&q, ll in, ll bm){\\n        if(__builtin_popcount(bm)==n){\\n            return true;\\n        }\\n        if(in==m){\\n            return false;\\n        }\\n        ll&ans=dp[bm][in];\\n        if(ans==-1){\\n            ans=0;\\n            for(ll it=bm;it<cost.size() && !ans;++it){\\n                if(bm!=(it&bm) || freq[in]<cost[bm^it]){\\n                    continue;\\n                }\\n                freq[in]-=cost[bm^it];\\n                ans|=func(q, in+1, it);\\n                freq[in]+=cost[bm^it];\\n            }\\n        }\\n        return ans;\\n    }\\n    bool canDistribute(vector<int>&v, vector<int>&q) {\\n        getFreq(v);\\n        m=freq.size(), n=q.size();\\n        dp.assign(1<<n, vi(ll)(m, -1)), cost.assign(1<<n, 0);\\n        getCost(q);\\n        return func(q, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522526,
                "title": "c-backtracking-with-explanation",
                "content": "The procedure first computes frequencies and then tries to find if any straightforward solution exists. Let\\'s consider nf the number of buckets of numbers and nq the number of quantities. If a solution exists for the problem then at least one solution using the nq largest buckets of numbers exists. As the result buckers of numbers from nq + 1 to nf are ignored. A straightforward solution consists of assigning the largest bucket to the largest frequency, the second largest bucket to the second largest frequency and so on.\\n\\nAn implication of the lack of a straightforward solution is that at least one bucket of numbers doesn\\'t help, also the procedure drops the smallest remaining one (the less impactful one). Then the procedure tries to further reduce nf: if the smallest bucket is smaller than the smallest quantity there is no point to keep the bucket, and if the smallest bucket is smaller than the 2nd smallest quantity, then the only possible assignment for the bucket is the smallest quantity. In that case the procedure also drops the smallest quantity.\\n\\nThen the  procedure computes totf defined as the total sum of numbers in the buckets and checks if totf is enough compared to the total number of quantities preq[0], with preq the prefix sum of quantities in reverse order. Finally, if there is enough numbers to assign, the procedure checks if there is just 1 or less remaining buckets as in this case the problem is straightforward again.\\n\\nThe backtrack is very standard: at the kth level of the backtrack, the procedure tries to assign the 1st bucket to the kth quantity, then the 2nd bucket to the kth quantity ans so on till the last bucket. Of course, the procedure only considers buckets whith enough remaining numbers rem[i]. This was enough to make the backtrack working but I added two more things.\\n\\nInitialization of i = k == 0 || qnt[k] < qnt[k - 1] ? 0 : im1 means that if the quantity k is the same than the quantity k - 1 then the procedure doesn\\'t start iterating from the first bucket as this will generate assignments that the procedure already visited. It is enough to start with the previously assigned bucket.\\n\\nKeep totf updated and check if there is enough remaining numbers to be assigned before calling the recursion. The procedure compute the remaining numbers needed preq[k + 1] - preq[nq] with a prefix sum as nq may decrease when the function bound updates totf.\\n\\nIn order to keep totf updated, the function bound first checks if the considered bucket still contains enough remaining numbers to be assigned to the smallest quantity. If no, it removes the whole remaining bucket size from totf as no further assignments can be done. Then it checks if the considered bucket still contains enough remaining numbers to be assigned to the 2nd smallest quantity. If no, the best possible use of the remaing numbers is to assign them to the smallest quantity, it removes the whole remaining bucket size from totf and it drops the smallest quantity. Finally it just remove the number assigned numbers qnt[k] from totf if it can\\'t do better.\\n\\n```\\nclass Solution {\\npublic:\\n\\tbool canDistribute(vector<int>& nums, vector<int>& qnt) {\\n\\t\\tvector<int> frq(1001, 0);\\n\\t\\tfor (auto n : nums) {\\n\\t\\t\\tfrq[n]++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tsort(frq.begin(), frq.end(), greater<int>());\\n\\t\\tsort(qnt.begin(), qnt.end(), greater<int>());\\n\\t\\tint nf = min(nf, (int)qnt.size());\\n\\t\\tint nq = (int)qnt.size();\\n\\n\\t\\tbool str = nf == nq;\\n\\t\\tfor (int i = 0; str && i < nf; i++) {\\n\\t\\t\\tif (qnt[i] > frq[i]) {\\n\\t\\t\\t\\tstr = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (str) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\twhile (--nf > 0 && (frq[nf - 1] < qnt[nq - 1] || (nq > 1 && frq[nf - 1] >= qnt[nq - 1] && frq[nf - 1] < qnt[nq - 2]))) {\\n\\t\\t\\tif (frq[nf - 1] >= qnt[nq - 1]) {\\n\\t\\t\\t\\tnq--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<int> rem(frq.begin(), frq.begin() + nf);\\n\\t\\tvector<int> preq(11, 0);\\n\\t\\tint totf = 0;\\n\\t\\tfor (int i = nq - 1; i >= 0; preq[i--] = (i == nq - 1 ? 0 : preq[i + 1]) + qnt[i]);\\n\\t\\tfor (int i = 0; i < nf; totf += frq[i++]);\\n\\t\\tif (totf < preq[0]) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif (nf <= 1) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfunction<int(int, int, int)> bound = [&](int k, int i, int t1) {\\n\\t\\t\\tif (nq - 1 > k && rem[i] < qnt[nq - 1]) {\\n\\t\\t\\t\\treturn totf - t1;\\n\\t\\t\\t}\\n\\t\\t\\tif (nq - 2 > k && rem[i] < qnt[nq - 2]) {\\n\\t\\t\\t\\tnq--;\\n\\t\\t\\t\\treturn totf - t1;\\n\\t\\t\\t}\\n\\t\\t\\treturn totf - qnt[k];\\n\\t\\t};\\n\\n\\t\\tfunction<bool(int, int)> bt = [&](int k, int im1) {\\n\\t\\t\\tfor (int i = k == 0 || qnt[k] < qnt[k - 1] ? 0 : im1; i < nf; i++) {\\n\\t\\t\\t\\tif (frq[i] < qnt[k]) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (rem[i] >= qnt[k]) {\\n\\t\\t\\t\\t\\tif (k + 1 == nq) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint t1 = rem[i], t2 = totf, t3 = nq;\\n\\t\\t\\t\\t\\trem[i] -= qnt[k];\\n\\t\\t\\t\\t\\ttotf = bound(k, i, t1);\\n\\t\\t\\t\\t\\tif (totf >= preq[k + 1] - preq[nq]) {\\n\\t\\t\\t\\t\\t\\tif (bt(k + 1, i)) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\trem[i] = t1; totf = t2; nq = t3;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\n\\t\\treturn bt(0, 0);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool canDistribute(vector<int>& nums, vector<int>& qnt) {\\n\\t\\tvector<int> frq(1001, 0);\\n\\t\\tfor (auto n : nums) {\\n\\t\\t\\tfrq[n]++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tsort(frq.begin(), frq.end(), greater<int>());\\n\\t\\tsort(qnt.begin(), qnt.end(), greater<int>());\\n\\t\\tint nf = min(nf, (int)qnt.size());\\n\\t\\tint nq = (int)qnt.size();\\n\\n\\t\\tbool str = nf == nq;\\n\\t\\tfor (int i = 0; str && i < nf; i++) {\\n\\t\\t\\tif (qnt[i] > frq[i]) {\\n\\t\\t\\t\\tstr = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (str) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\twhile (--nf > 0 && (frq[nf - 1] < qnt[nq - 1] || (nq > 1 && frq[nf - 1] >= qnt[nq - 1] && frq[nf - 1] < qnt[nq - 2]))) {\\n\\t\\t\\tif (frq[nf - 1] >= qnt[nq - 1]) {\\n\\t\\t\\t\\tnq--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<int> rem(frq.begin(), frq.begin() + nf);\\n\\t\\tvector<int> preq(11, 0);\\n\\t\\tint totf = 0;\\n\\t\\tfor (int i = nq - 1; i >= 0; preq[i--] = (i == nq - 1 ? 0 : preq[i + 1]) + qnt[i]);\\n\\t\\tfor (int i = 0; i < nf; totf += frq[i++]);\\n\\t\\tif (totf < preq[0]) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif (nf <= 1) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfunction<int(int, int, int)> bound = [&](int k, int i, int t1) {\\n\\t\\t\\tif (nq - 1 > k && rem[i] < qnt[nq - 1]) {\\n\\t\\t\\t\\treturn totf - t1;\\n\\t\\t\\t}\\n\\t\\t\\tif (nq - 2 > k && rem[i] < qnt[nq - 2]) {\\n\\t\\t\\t\\tnq--;\\n\\t\\t\\t\\treturn totf - t1;\\n\\t\\t\\t}\\n\\t\\t\\treturn totf - qnt[k];\\n\\t\\t};\\n\\n\\t\\tfunction<bool(int, int)> bt = [&](int k, int im1) {\\n\\t\\t\\tfor (int i = k == 0 || qnt[k] < qnt[k - 1] ? 0 : im1; i < nf; i++) {\\n\\t\\t\\t\\tif (frq[i] < qnt[k]) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (rem[i] >= qnt[k]) {\\n\\t\\t\\t\\t\\tif (k + 1 == nq) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint t1 = rem[i], t2 = totf, t3 = nq;\\n\\t\\t\\t\\t\\trem[i] -= qnt[k];\\n\\t\\t\\t\\t\\ttotf = bound(k, i, t1);\\n\\t\\t\\t\\t\\tif (totf >= preq[k + 1] - preq[nq]) {\\n\\t\\t\\t\\t\\t\\tif (bt(k + 1, i)) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\trem[i] = t1; totf = t2; nq = t3;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\n\\t\\treturn bt(0, 0);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380994,
                "title": "python3-backtracking",
                "content": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        \\n        #We only need the 10 largest frequencies.\\n        freq = sorted(collections.Counter(nums).values())[-10:]\\n        quantity.sort(reverse = True)\\n        \\n        def dfs(i):\\n            if i == len(quantity):\\n                return True\\n            \\n            for j in range(len(freq)):\\n                if freq[j] >= quantity[i]:\\n                    freq[j] += -quantity[i]\\n                    if dfs(i+1):\\n                        return True\\n                    freq[j] += quantity[i]\\n            return False\\n        \\n        return dfs(0)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        \\n        #We only need the 10 largest frequencies.\\n        freq = sorted(collections.Counter(nums).values())[-10:]\\n        quantity.sort(reverse = True)\\n        \\n        def dfs(i):\\n            if i == len(quantity):\\n                return True\\n            \\n            for j in range(len(freq)):\\n                if freq[j] >= quantity[i]:\\n                    freq[j] += -quantity[i]\\n                    if dfs(i+1):\\n                        return True\\n                    freq[j] += quantity[i]\\n            return False\\n        \\n        return dfs(0)",
                "codeTag": "Java"
            },
            {
                "id": 2296608,
                "title": "java-backtracking-10ms-99-speed-no-memo-or-dp-explained",
                "content": "#### Optimization\\nTwo optimizations (1 and 2) are needed to avoid TLE, both of them are quite crucial.\\n1. Consider a test case such as `[1,1,2,2,3,3,4,4,5,5,6,6,7,7...]` where each element appears twice. The naive way would be to count them and have `count[1]=2, count[2]=2, count[3]=2, ...` This however is very inefficient because the backtracking function will be checking a lot of layers. Think about it in another way, we should have a `FREQ` array that has `freq[2] = 7`, meaning there are 7 numbers with frequency of 2. This way, backtracking function will only check 1 spot.\\n\\n2. If the max quantity requested is more than the max frequency appears, we ought to return false right away.\\n\\n3. As a bonus, we should remove the frequency key if it reaches 0 before making the next recursive call. This way it won\\'t be checking empty keys.\\n\\n#### Some Details\\nRemoving/adding a key from hashmap will get you Concurrent Modification error. We will use bitset in replace of it.\\nBitSet operates close to `O(1)` for this problem and does not have Concurrent Modification restriction.\\n\\n#### Java\\n#### 10ms (109 / 109 test cases passed.)\\n```Java\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int[] arr = new int[1001];\\n        int max = 0;\\n        for (int n : nums){\\n            max = Math.max(++arr[n], max);\\n        }\\n        int min = Arrays.stream(quantity).max().getAsInt();\\n        if (max < min){ // optimization 2\\n            return false;\\n        }\\n        int[] map = new int[max+1]; // freq map\\n        BitSet bit = new BitSet();\\n        for (int i = 0; i <= 1000; i++) if (arr[i] > 0){ // optimization 1\\n            map[arr[i]]++;\\n            bit.set(arr[i]);\\n        }\\n        return solve(0, map, quantity, bit);\\n    }\\n\\n    private boolean solve(int idx, int[] map, int[] q, BitSet bit){\\n        if (idx==q.length){\\n            return true;\\n        }\\n        for (int key = bit.nextSetBit(0); key >= 0; key = bit.nextSetBit(key+1)){\\n            if (q[idx]>key){\\n                continue;\\n            }\\n            if (--map[key]==0){ // optimization 3\\n                bit.clear(key);\\n            }\\n            if (key-q[idx]>0){\\n                map[key-q[idx]]++;\\n                bit.set(key-q[idx]);\\n            }\\n            if (solve(idx+1, map, q, bit)){\\n                return true;\\n            }\\n            if (key-q[idx]>0&&--map[key-q[idx]]==0){\\n                bit.clear(key-q[idx]);\\n            }\\n            if (++map[key]==1){\\n                bit.set(key);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int[] arr = new int[1001];\\n        int max = 0;\\n        for (int n : nums){\\n            max = Math.max(++arr[n], max);\\n        }\\n        int min = Arrays.stream(quantity).max().getAsInt();\\n        if (max < min){ // optimization 2\\n            return false;\\n        }\\n        int[] map = new int[max+1]; // freq map\\n        BitSet bit = new BitSet();\\n        for (int i = 0; i <= 1000; i++) if (arr[i] > 0){ // optimization 1\\n            map[arr[i]]++;\\n            bit.set(arr[i]);\\n        }\\n        return solve(0, map, quantity, bit);\\n    }\\n\\n    private boolean solve(int idx, int[] map, int[] q, BitSet bit){\\n        if (idx==q.length){\\n            return true;\\n        }\\n        for (int key = bit.nextSetBit(0); key >= 0; key = bit.nextSetBit(key+1)){\\n            if (q[idx]>key){\\n                continue;\\n            }\\n            if (--map[key]==0){ // optimization 3\\n                bit.clear(key);\\n            }\\n            if (key-q[idx]>0){\\n                map[key-q[idx]]++;\\n                bit.set(key-q[idx]);\\n            }\\n            if (solve(idx+1, map, q, bit)){\\n                return true;\\n            }\\n            if (key-q[idx]>0&&--map[key-q[idx]]==0){\\n                bit.clear(key-q[idx]);\\n            }\\n            if (++map[key]==1){\\n                bit.set(key);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275211,
                "title": "c-simple-logic-beats-95",
                "content": "```\\nclass Solution {\\npublic:\\n    string getKey(map<int,vector<int>> &fc, int idx) {\\n        string k = \"\";\\n        for (auto p : fc) {\\n            k += \"(\"+to_string(p.first)+\"+\"+to_string(p.second.size())+\"),\";\\n        }\\n        k += to_string(idx);\\n        return k;\\n    }\\n    \\n    bool searchFeasible(map<int,vector<int>> &fc, int idx, vector<int> &qu, unordered_set<string> &mem) {\\n        if (idx == qu.size()) return true;\\n        \\n        string k = getKey(fc, idx);\\n        if (mem.count(k)) return false;\\n        mem.insert(k);\\n        \\n        vector<int> counts;\\n        for (auto ff : fc) {\\n            counts.push_back(ff.first);\\n        }\\n        \\n        for (auto ff : counts) {\\n            if (ff >= qu[idx]) {\\n                int itemCount = ff;\\n                int itemId = fc[itemCount].back(); fc[itemCount].pop_back();\\n                if(fc[itemCount].empty()) fc.erase(itemCount);\\n                if (itemCount-qu[idx]) fc[itemCount-qu[idx]].push_back(itemId);\\n                \\n                if (searchFeasible(fc, idx+1, qu, mem)) return true;\\n\\n                if (itemCount-qu[idx]) fc[itemCount-qu[idx]].pop_back();\\n                if (fc[itemCount-qu[idx]].empty()) fc.erase(itemCount-qu[idx]);\\n                fc[itemCount].push_back(itemId);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> catalog;\\n        map<int,vector<int>> freqCount; \\n        unordered_set<string> mem;\\n        for (auto n : nums) {\\n            ++catalog[n];\\n        }\\n        \\n        for (auto c : catalog) {\\n            freqCount[c.second].push_back(c.first);\\n        }\\n        \\n        sort(quantity.begin(), quantity.end(), [] (int l, int r) {return l > r;});\\n        return searchFeasible(freqCount, 0, quantity, mem);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getKey(map<int,vector<int>> &fc, int idx) {\\n        string k = \"\";\\n        for (auto p : fc) {\\n            k += \"(\"+to_string(p.first)+\"+\"+to_string(p.second.size())+\"),\";\\n        }\\n        k += to_string(idx);\\n        return k;\\n    }\\n    \\n    bool searchFeasible(map<int,vector<int>> &fc, int idx, vector<int> &qu, unordered_set<string> &mem) {\\n        if (idx == qu.size()) return true;\\n        \\n        string k = getKey(fc, idx);\\n        if (mem.count(k)) return false;\\n        mem.insert(k);\\n        \\n        vector<int> counts;\\n        for (auto ff : fc) {\\n            counts.push_back(ff.first);\\n        }\\n        \\n        for (auto ff : counts) {\\n            if (ff >= qu[idx]) {\\n                int itemCount = ff;\\n                int itemId = fc[itemCount].back(); fc[itemCount].pop_back();\\n                if(fc[itemCount].empty()) fc.erase(itemCount);\\n                if (itemCount-qu[idx]) fc[itemCount-qu[idx]].push_back(itemId);\\n                \\n                if (searchFeasible(fc, idx+1, qu, mem)) return true;\\n\\n                if (itemCount-qu[idx]) fc[itemCount-qu[idx]].pop_back();\\n                if (fc[itemCount-qu[idx]].empty()) fc.erase(itemCount-qu[idx]);\\n                fc[itemCount].push_back(itemId);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> catalog;\\n        map<int,vector<int>> freqCount; \\n        unordered_set<string> mem;\\n        for (auto n : nums) {\\n            ++catalog[n];\\n        }\\n        \\n        for (auto c : catalog) {\\n            freqCount[c.second].push_back(c.first);\\n        }\\n        \\n        sort(quantity.begin(), quantity.end(), [] (int l, int r) {return l > r;});\\n        return searchFeasible(freqCount, 0, quantity, mem);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250601,
                "title": "python-easy-backtracking-solution-faster-than-90-beats-98-for-space",
                "content": "\\tclass Solution:\\n\\t\\tdef canDistribute(self, nums: List[int], quan: List[int]) -> bool:\\n\\t\\t\\th = {}\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\th[i] = 1 + h.get(i, 0)\\n\\t\\t\\tn = len(quan)\\n\\t\\t\\tquan.sort(reverse = True)\\n\\t\\t\\tdef solve(i):\\n\\t\\t\\t\\tnonlocal h\\n\\t\\t\\t\\tnonlocal n\\n\\t\\t\\t\\tif i == n:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tfor key, val in h.items():\\n\\t\\t\\t\\t\\tif val >= quan[i]:\\n\\t\\t\\t\\t\\t\\th[key] -= quan[i]\\n\\t\\t\\t\\t\\t\\tif solve(i+1):\\n\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\th[key] += quan[i]\\n\\t\\t\\t\\treturn False\\n\\t\\t\\treturn solve(0)",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef canDistribute(self, nums: List[int], quan: List[int]) -> bool:\\n\\t\\t\\th = {}",
                "codeTag": "Java"
            },
            {
                "id": 2227779,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    bool solve(int pos, vector<int> &v, vector<int> &q){\\n        if(pos == q.size())\\n            return true;\\n        for(int i=0; i < v.size(); i++){\\n            if(i && v[i] == v[i-1])    // skip the elements which we have already checked\\n                continue;\\n            if(v[i] >= q[pos]){\\n                v[i] -= q[pos];\\n                if(solve(pos+1, v, q))\\n                    return true;\\n                v[i] += q[pos];\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        for(int i : nums)\\n            mp[i]++;\\n        vector<int> v;\\n        for(auto i : mp)\\n            v.push_back(i.second);\\n        sort(quantity.rbegin(), quantity.rend());\\n        return solve(0, v, quantity);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    bool solve(int pos, vector<int> &v, vector<int> &q){\\n        if(pos == q.size())\\n            return true;\\n        for(int i=0; i < v.size(); i++){\\n            if(i && v[i] == v[i-1])    // skip the elements which we have already checked\\n                continue;\\n            if(v[i] >= q[pos]){\\n                v[i] -= q[pos];\\n                if(solve(pos+1, v, q))\\n                    return true;\\n                v[i] += q[pos];\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        for(int i : nums)\\n            mp[i]++;\\n        vector<int> v;\\n        for(auto i : mp)\\n            v.push_back(i.second);\\n        sort(quantity.rbegin(), quantity.rend());\\n        return solve(0, v, quantity);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217939,
                "title": "c-solution-dp-with-bit-masking",
                "content": "```\\nclass Solution {\\nprivate:\\n    //dp table defined by two variables:-\\n    //1. index->let uniqueValues be the array representing all the unique values present in nums\\n    //then index tells us which index of that array we are on\\n    //2. mask-> a bitmask which tells us which orders have been fullfilled\\n    vector<vector<int>>mem;\\n    //stores the total quantity demanded for a particular set of orders\\n    vector<int>total;\\n    //stores the count of the unique values present in nums\\n    unordered_map<int,int>cnts;\\n    int findTotalQuantity(vector<int>&quantity,int mask){\\n        int ans=0;\\n        //iterate thorugh the bitmask by setting the rightmost bit to zero, and add the \\n        //quantity of that position to the answer.\\n        while(mask){\\n            int pos=log2(mask&(-mask));\\n            mask-=mask&(-mask);\\n            ans+=quantity[pos];\\n        }\\n        return ans;\\n    }\\n    //for subset of unfullfilled orders we will see if the current index has enough frequency \\n    //to cover the total quantity demanded by the subset, if yes then mark that subset in the mask\\n    //and perform a recursive call, if any of them return true, then return true, else return false.\\n    bool solve(vector<int>&uniqueValues,int index,int mask){\\n        int size=total.size();\\n        int m=log2(size);\\n        if(mask==(1<<m)-1){\\n            return true;\\n        } else if(index==uniqueValues.size()){\\n            return false;\\n        } else if(mem[index][mask]!=-1){\\n            return mem[index][mask];\\n        } else {\\n\\t\\t//ignore the current index and move on\\n            bool ans=solve(uniqueValues,index+1,mask);\\n            if(ans){\\n                return mem[index][mask]=true;\\n            } else {\\n\\t\\t\\t//try every possible subset of the orders that have not been completed\\n                int remainingOrders=((1<<m)-1)^mask;\\n                int value=uniqueValues[index];\\n                for(int submask=remainingOrders;submask>0;submask=(submask-1)&remainingOrders){\\n                    if(cnts[value]>=total[submask]){\\n                        if(solve(uniqueValues,index+1,mask|submask)){\\n                            return mem[index][mask]=true;\\n                        }\\n                    }\\n                }\\n                return mem[index][mask]=false;\\n            }\\n        }\\n    }\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int m=quantity.size();\\n        for(int i=0;i<nums.size();i++){\\n            cnts[nums[i]]++;\\n        }\\n        vector<int>uniqueValues;\\n        for(unordered_map<int,int>::iterator it=cnts.begin();it!=cnts.end();it++){\\n            uniqueValues.push_back(it->first);\\n        }\\n        int n=uniqueValues.size();\\n        mem=vector<vector<int>>(n,vector<int>(1<<m,-1));\\n        total=vector<int>(1<<m,-1);\\n        for(int mask=0;mask<(1<<m);mask++){\\n            total[mask]=findTotalQuantity(quantity,mask);\\n        }\\n        return solve(uniqueValues,0,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\nprivate:\\n    //dp table defined by two variables:-\\n    //1. index->let uniqueValues be the array representing all the unique values present in nums\\n    //then index tells us which index of that array we are on\\n    //2. mask-> a bitmask which tells us which orders have been fullfilled\\n    vector<vector<int>>mem;\\n    //stores the total quantity demanded for a particular set of orders\\n    vector<int>total;\\n    //stores the count of the unique values present in nums\\n    unordered_map<int,int>cnts;\\n    int findTotalQuantity(vector<int>&quantity,int mask){\\n        int ans=0;\\n        //iterate thorugh the bitmask by setting the rightmost bit to zero, and add the \\n        //quantity of that position to the answer.\\n        while(mask){\\n            int pos=log2(mask&(-mask));\\n            mask-=mask&(-mask);\\n            ans+=quantity[pos];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2189118,
                "title": "welp-python-backtracking-bruteforce-worked",
                "content": "```py\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def canDistribute(self, nums, quantity):\\n        \"\"\"\\n            observations:\\n                at most 50 unique values in nums\\n            \\n            distribute the asked quantity of nums to query\\n            \\n            now for a queery like:\\n                [1,1,1,1,2,2,2]  q = [1, 4] , we cant take query1 \"1\" out from  list of 1, bcz if we do, 1 remains = 3 and we wont be able to fulfil 2nd query q2 = \"4\", \\n                \\n            I think we can be a lil greedy and always give away the lowest fulfilling char so we have 3 \"2\" and 4 \"1\" so we fulfil any query less than 3 using 2 \\n                    \\n        \"\"\"\\n        \\n        \"\"\"\\n        s = SortedList([(c, num) for num, c in Counter(nums).items()])\\n        s1 = s.copy()\\n        n = len(s)\\n        quantity.sort(reverse=True)\\n        \\n        \\n        \\n        for q in quantity:\\n            i = s.bisect_left((q, 0))\\n            if i >= n:\\n                return False # cant fill this query\\n            curr_c, curr_elem = s.pop(i)\\n            if curr_c < q:\\n                return False # cant fill\\n            elif curr_c == q:\\n                # exact match\\n                s.add((0, curr_elem)) # no more left\\n            else:\\n                s.add((curr_c - q, curr_elem))\\n        \\n        return True\\n        \"\"\"\\n        \"\"\"\\n        ^ code doesnt work for the case\\n        \\n        [1,1,2,2,1]\\n        [2,2,1]\\n        \\n        which was actually last test case L.. But idea being the hypothesis that give the lowest count element first doesnt stand true, we need look ahead, i.e DP\\n        \\n        bounded sequence donot matter dp ( we need tuple)\\n        \\n        dp(?)\\n        states\\n        state transition\\n        base\\n        \"\"\"\\n        quantity.sort(reverse=True)\\n        counts = Counter(nums)\\n        \\n        \\n        def dp(qi, c):\\n            \\n            \\n            if qi == len(quantity):\\n                return True\\n            \\n            needed_elems = quantity[qi]\\n            \\n            for i in c:\\n                if c[i] >= needed_elems:\\n                    \\n                    c[i] -= needed_elems\\n                    if dp(qi+1, c) == True:\\n                        return True\\n                    c[i] += needed_elems\\n            \\n            return False\\n    \\n        return dp(0, counts)\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```py\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def canDistribute(self, nums, quantity):\\n        \"\"\"\\n            observations:\\n                at most 50 unique values in nums\\n            \\n            distribute the asked quantity of nums to query\\n            \\n            now for a queery like:\\n                [1,1,1,1,2,2,2]  q = [1, 4] , we cant take query1 \"1\" out from  list of 1, bcz if we do, 1 remains = 3 and we wont be able to fulfil 2nd query q2 = \"4\", \\n                \\n            I think we can be a lil greedy and always give away the lowest fulfilling char so we have 3 \"2\" and 4 \"1\" so we fulfil any query less than 3 using 2 \\n                    \\n        \"\"\"\\n        \\n        \"\"\"\\n        s = SortedList([(c, num) for num, c in Counter(nums).items()])\\n        s1 = s.copy()\\n        n = len(s)\\n        quantity.sort(reverse=True)\\n        \\n        \\n        \\n        for q in quantity:\\n            i = s.bisect_left((q, 0))\\n            if i >= n:\\n                return False # cant fill this query\\n            curr_c, curr_elem = s.pop(i)\\n            if curr_c < q:\\n                return False # cant fill\\n            elif curr_c == q:\\n                # exact match\\n                s.add((0, curr_elem)) # no more left\\n            else:\\n                s.add((curr_c - q, curr_elem))\\n        \\n        return True\\n        \"\"\"\\n        \"\"\"\\n        ^ code doesnt work for the case\\n        \\n        [1,1,2,2,1]\\n        [2,2,1]\\n        \\n        which was actually last test case L.. But idea being the hypothesis that give the lowest count element first doesnt stand true, we need look ahead, i.e DP\\n        \\n        bounded sequence donot matter dp ( we need tuple)\\n        \\n        dp(?)\\n        states\\n        state transition\\n        base\\n        \"\"\"\\n        quantity.sort(reverse=True)\\n        counts = Counter(nums)\\n        \\n        \\n        def dp(qi, c):\\n            \\n            \\n            if qi == len(quantity):\\n                return True\\n            \\n            needed_elems = quantity[qi]\\n            \\n            for i in c:\\n                if c[i] >= needed_elems:\\n                    \\n                    c[i] -= needed_elems\\n                    if dp(qi+1, c) == True:\\n                        return True\\n                    c[i] += needed_elems\\n            \\n            return False\\n    \\n        return dp(0, counts)\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186765,
                "title": "c-recursion-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(int pos , vector<int>&freq , vector<int>&Q ){\\n        if(pos >= Q.size()) return true ;\\n        \\n        for(int i = 0 ; i < freq.size() ; ++i ){\\n            if(freq[i] < Q[pos]) continue  ;\\n            \\n            freq[i] -= Q[pos] ;\\n            if(solve(pos + 1 , freq,Q)) return true ;\\n            freq[i] += Q[pos] ;\\n        }\\n        \\n        return false ;\\n        \\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& Q) {\\n        int f[1001] = {} ;\\n        for(auto &x : nums) ++f[x] ;\\n        vector<int> freq ; \\n        for(auto &x : f) if(x) freq.push_back(x) ;\\n\\t\\t//Keep larger frequencies first\\n        sort(rbegin(Q),rend(Q)) ;\\n        return solve(0,freq,Q) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int pos , vector<int>&freq , vector<int>&Q ){\\n        if(pos >= Q.size()) return true ;\\n        \\n        for(int i = 0 ; i < freq.size() ; ++i ){\\n            if(freq[i] < Q[pos]) continue  ;\\n            \\n            freq[i] -= Q[pos] ;\\n            if(solve(pos + 1 , freq,Q)) return true ;\\n            freq[i] += Q[pos] ;\\n        }\\n        \\n        return false ;\\n        \\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& Q) {\\n        int f[1001] = {} ;\\n        for(auto &x : nums) ++f[x] ;\\n        vector<int> freq ; \\n        for(auto &x : f) if(x) freq.push_back(x) ;\\n\\t\\t//Keep larger frequencies first\\n        sort(rbegin(Q),rend(Q)) ;\\n        return solve(0,freq,Q) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104328,
                "title": "c-17-dfs-backtracking-with-optimizations",
                "content": "# [C++17] DFS/Backtracking with optimizations\\n\\n```\\n// Idea / Approach: DFS/Backtracking without memo; how to do a memo?\\n// TODO: Implement a memo for the last k-elements in the supplies of numbers\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        // sort the demands descendingly\\n        sort(quantity.begin(), quantity.end(), greater<>());\\n        // do a frequency statistics over the numbers.\\n        auto freqDesc = doFrequencyStatistics(nums);\\n        // remove the useless entries from freqDesc\\n        {\\n            while (!freqDesc.empty() && freqDesc.back() < quantity.back()) {\\n                freqDesc.pop_back();\\n            }\\n            if (freqDesc.empty()) {\\n                return false;\\n            }\\n        }\\n        multiset<int> supplies(freqDesc.begin(), freqDesc.end());\\n        // greedy: find the exact matches, and remove them\\n        vector<int> demands;\\n        {\\n            demands.reserve(quantity.size());\\n            for (auto d : quantity) {\\n                if (auto iter = supplies.find(d); iter != supplies.end()) {\\n                    supplies.erase(iter);\\n                } else {\\n                    demands.emplace_back(d);\\n                }\\n            }\\n        }\\n        if (demands.empty()) {\\n            return true;\\n        }\\n        // dfs ie backtracking\\n        return dfs(supplies, demands, 0);\\n    }\\n\\n    /// dfs from i-th distinct number and c-th customer\\n    bool dfs(multiset<int>& supplies, const vector<int>& demands, int c) {\\n        int currDemand = demands[c];\\n        if (c == demands.size() - 1) { // the last customer\\n            if (!supplies.empty() && *supplies.rbegin() >= currDemand) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        auto supp2 = supplies;\\n        int prevSupply = -1;\\n        for (auto iter = supplies.rbegin(); iter != supplies.rend() && *iter >= currDemand;\\n             ++iter) {\\n            if (*iter == prevSupply) {\\n                continue; // skip duplicated counts\\n            }\\n            prevSupply = *iter;\\n\\n            supp2.erase(supp2.find(*iter));\\n            if (*iter > currDemand) {\\n                supp2.insert(*iter - currDemand);\\n            }\\n            if (dfs(supp2, demands, c + 1)) {\\n                return true;\\n            }\\n            // restore supp2\\n            supp2.insert(*iter);\\n            if (*iter > currDemand) {\\n                supp2.erase(supp2.find(*iter - currDemand));\\n            }\\n        }\\n        return false;\\n    }\\n\\n    static inline vector<int> doFrequencyStatistics(const vector<int>& nums) {\\n        unordered_map<int, int> freqMap;\\n        for (auto a : nums) {\\n            ++freqMap[a];\\n        }\\n        vector<int> freqs;\\n        for (auto [i, freq] : freqMap) {\\n            freqs.emplace_back(freq);\\n        }\\n        sort(freqs.begin(), freqs.end(), greater<>());\\n        return freqs;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Idea / Approach: DFS/Backtracking without memo; how to do a memo?\\n// TODO: Implement a memo for the last k-elements in the supplies of numbers\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        // sort the demands descendingly\\n        sort(quantity.begin(), quantity.end(), greater<>());\\n        // do a frequency statistics over the numbers.\\n        auto freqDesc = doFrequencyStatistics(nums);\\n        // remove the useless entries from freqDesc\\n        {\\n            while (!freqDesc.empty() && freqDesc.back() < quantity.back()) {\\n                freqDesc.pop_back();\\n            }\\n            if (freqDesc.empty()) {\\n                return false;\\n            }\\n        }\\n        multiset<int> supplies(freqDesc.begin(), freqDesc.end());\\n        // greedy: find the exact matches, and remove them\\n        vector<int> demands;\\n        {\\n            demands.reserve(quantity.size());\\n            for (auto d : quantity) {\\n                if (auto iter = supplies.find(d); iter != supplies.end()) {\\n                    supplies.erase(iter);\\n                } else {\\n                    demands.emplace_back(d);\\n                }\\n            }\\n        }\\n        if (demands.empty()) {\\n            return true;\\n        }\\n        // dfs ie backtracking\\n        return dfs(supplies, demands, 0);\\n    }\\n\\n    /// dfs from i-th distinct number and c-th customer\\n    bool dfs(multiset<int>& supplies, const vector<int>& demands, int c) {\\n        int currDemand = demands[c];\\n        if (c == demands.size() - 1) { // the last customer\\n            if (!supplies.empty() && *supplies.rbegin() >= currDemand) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        auto supp2 = supplies;\\n        int prevSupply = -1;\\n        for (auto iter = supplies.rbegin(); iter != supplies.rend() && *iter >= currDemand;\\n             ++iter) {\\n            if (*iter == prevSupply) {\\n                continue; // skip duplicated counts\\n            }\\n            prevSupply = *iter;\\n\\n            supp2.erase(supp2.find(*iter));\\n            if (*iter > currDemand) {\\n                supp2.insert(*iter - currDemand);\\n            }\\n            if (dfs(supp2, demands, c + 1)) {\\n                return true;\\n            }\\n            // restore supp2\\n            supp2.insert(*iter);\\n            if (*iter > currDemand) {\\n                supp2.erase(supp2.find(*iter - currDemand));\\n            }\\n        }\\n        return false;\\n    }\\n\\n    static inline vector<int> doFrequencyStatistics(const vector<int>& nums) {\\n        unordered_map<int, int> freqMap;\\n        for (auto a : nums) {\\n            ++freqMap[a];\\n        }\\n        vector<int> freqs;\\n        for (auto [i, freq] : freqMap) {\\n            freqs.emplace_back(freq);\\n        }\\n        sort(freqs.begin(), freqs.end(), greater<>());\\n        return freqs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091316,
                "title": "python-without-bit-masking-backtracking-beats-94-73-time",
                "content": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        cnt = Counter(nums)\\n        l = []\\n        for k, v in cnt.items():\\n            l.append(v)\\n        l = sorted(l, reverse=True)\\n        n = len(quantity)\\n        \\n        @lru_cache(None)\\n        def dp(i, left):\\n            if i == n:\\n                return True\\n            left = list(left)\\n            for j, c in enumerate(left):\\n                if c >= quantity[i]:\\n                    left[j] -= quantity[i]\\n                    if dp(i+1, tuple(sorted(left))):  # Sort the tuple to avoid unnecessary repitition since it doesn\\'t matter which number is assigned to each order.\\n                        return True\\n                    left[j] += quantity[i]\\n            return False\\n        \\n        return dp(0, tuple(l))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        cnt = Counter(nums)\\n        l = []\\n        for k, v in cnt.items():\\n            l.append(v)\\n        l = sorted(l, reverse=True)\\n        n = len(quantity)\\n        \\n        @lru_cache(None)\\n        def dp(i, left):\\n            if i == n:\\n                return True\\n            left = list(left)\\n            for j, c in enumerate(left):\\n                if c >= quantity[i]:\\n                    left[j] -= quantity[i]\\n                    if dp(i+1, tuple(sorted(left))):  # Sort the tuple to avoid unnecessary repitition since it doesn\\'t matter which number is assigned to each order.\\n                        return True\\n                    left[j] += quantity[i]\\n            return False\\n        \\n        return dp(0, tuple(l))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053729,
                "title": "python-dfs-with-bitmask-o-n-3-m",
                "content": "Let\\'s analyze the time complexity.\\nIf we fix i and mask, dfs(i, mask) takes 2^j where j is the number of ones in the binary representation of mask.\\nSince there are mCj masks whose number of ones in binary representaion is j, the complexity becomes\\nsum_{j from 0 to m} mCj * 2^j = (2+1)^m = 3^m. \\nFinally, we have n possibilities for i, the total time complexity becomes O(n*3^m)\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        c = sorted(Counter(nums).values(), reverse = True)\\n        n = len(c)\\n        m = len(quantity)\\n        mask_sum = defaultdict(int)\\n        for mask in range(1<<m):\\n            for i in range(m):\\n                if (1<<i) & mask:\\n                    mask_sum[mask] += quantity[i]\\n        @lru_cache(None)\\n        def dfs(i, mask):\\n            if mask == 0: return True\\n            if i == n: return False\\n            submask = mask\\n            while submask:\\n                if mask_sum[submask] <= c[i] and dfs(i+1, mask^submask):\\n                    return True\\n                submask = (submask-1) & mask\\n            return False\\n        return dfs(0, (1<<m)-1)\\n        \\n        \\n            \\n            \\n            \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "Let\\'s analyze the time complexity.\\nIf we fix i and mask, dfs(i, mask) takes 2^j where j is the number of ones in the binary representation of mask.\\nSince there are mCj masks whose number of ones in binary representaion is j, the complexity becomes\\nsum_{j from 0 to m} mCj * 2^j = (2+1)^m = 3^m. \\nFinally, we have n possibilities for i, the total time complexity becomes O(n*3^m)\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        c = sorted(Counter(nums).values(), reverse = True)\\n        n = len(c)\\n        m = len(quantity)\\n        mask_sum = defaultdict(int)\\n        for mask in range(1<<m):\\n            for i in range(m):\\n                if (1<<i) & mask:\\n                    mask_sum[mask] += quantity[i]\\n        @lru_cache(None)\\n        def dfs(i, mask):\\n            if mask == 0: return True\\n            if i == n: return False\\n            submask = mask\\n            while submask:\\n                if mask_sum[submask] <= c[i] and dfs(i+1, mask^submask):\\n                    return True\\n                submask = (submask-1) & mask\\n            return False\\n        return dfs(0, (1<<m)-1)\\n        \\n        \\n            \\n            \\n            \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1876491,
                "title": "c-dfs-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> cnt;\\n    vector<unordered_map<string, int>> memo;\\n    \\n    bool dfs(vector<int> &quantity, string &mem, int index) {\\n        if (index == quantity.size())\\n            return true;\\n        \\n        bool pos = false;\\n        if (memo[index].count(mem))\\n            return memo[index][mem];\\n        \\n        for (auto &[k, v]: cnt) {\\n            if (v >= quantity[index]) {\\n                cnt[k] -= quantity[index];\\n                mem += cnt[k] + \\'0\\';\\n                pos = pos || dfs(quantity, mem, index + 1);\\n                mem.pop_back();\\n                if (pos) return true;\\n                cnt[k] += quantity[index];\\n            }\\n        }\\n        return memo[index][mem] = pos;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int n = quantity.size();\\n        string mem = \"\";\\n        memo = vector<unordered_map<string, int>>(n);\\n\\n        for (int i: nums)\\n            cnt[i]++;\\n\\n        return dfs(quantity, mem, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> cnt;\\n    vector<unordered_map<string, int>> memo;\\n    \\n    bool dfs(vector<int> &quantity, string &mem, int index) {\\n        if (index == quantity.size())\\n            return true;\\n        \\n        bool pos = false;\\n        if (memo[index].count(mem))\\n            return memo[index][mem];\\n        \\n        for (auto &[k, v]: cnt) {\\n            if (v >= quantity[index]) {\\n                cnt[k] -= quantity[index];\\n                mem += cnt[k] + \\'0\\';\\n                pos = pos || dfs(quantity, mem, index + 1);\\n                mem.pop_back();\\n                if (pos) return true;\\n                cnt[k] += quantity[index];\\n            }\\n        }\\n        return memo[index][mem] = pos;\\n    }\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int n = quantity.size();\\n        string mem = \"\";\\n        memo = vector<unordered_map<string, int>>(n);\\n\\n        for (int i: nums)\\n            cnt[i]++;\\n\\n        return dfs(quantity, mem, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813206,
                "title": "subtraction-and-backtracking-c",
                "content": "\\t  inline  bool helper(vector<int> &buckets,vector<int> &quantity,int k)\\n\\t\\t{\\n        if(quantity.size()==k)\\n            return true;\\n        \\n        for(int i=0;i<buckets.size();i++)\\n            if(buckets[i]-quantity[k]>=0)\\n            {\\n                buckets[i]-=quantity[k];\\n                \\n                if(helper(buckets,quantity,k+1))\\n                    return true;\\n                \\n                buckets[i]+=quantity[k];\\n            }\\n                \\n        \\n        return false;\\n    }\\n    \\n    \\n\\t   inline bool canDistribute(vector<int>& nums, vector<int>& quantity) \\n\\t\\t{\\n        unordered_map<int,int> hash;\\n        \\n        for(int i=0;i<nums.size();i++)\\n            hash[nums[i]]++;\\n        \\n        vector<int> buckets;\\n        \\n        for(auto &ell:hash)\\n             buckets.push_back(ell.second);\\n        \\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n        sort(buckets.begin(),buckets.end(),greater<int>());\\n        \\n        return helper(buckets,quantity,0);\\n    }",
                "solutionTags": [],
                "code": "\\t  inline  bool helper(vector<int> &buckets,vector<int> &quantity,int k)\\n\\t\\t{\\n        if(quantity.size()==k)\\n            return true;\\n        \\n        for(int i=0;i<buckets.size();i++)\\n            if(buckets[i]-quantity[k]>=0)\\n            {\\n                buckets[i]-=quantity[k];\\n                \\n                if(helper(buckets,quantity,k+1))\\n                    return true;\\n                \\n                buckets[i]+=quantity[k];\\n            }\\n                \\n        \\n        return false;\\n    }\\n    \\n    \\n\\t   inline bool canDistribute(vector<int>& nums, vector<int>& quantity) \\n\\t\\t{\\n        unordered_map<int,int> hash;\\n        \\n        for(int i=0;i<nums.size();i++)\\n            hash[nums[i]]++;\\n        \\n        vector<int> buckets;\\n        \\n        for(auto &ell:hash)\\n             buckets.push_back(ell.second);\\n        \\n        sort(quantity.begin(),quantity.end(),greater<int>());\\n        sort(buckets.begin(),buckets.end(),greater<int>());\\n        \\n        return helper(buckets,quantity,0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1676209,
                "title": "dp-o-n-q-2-q-c-solution-with-no-comments-or-explanation",
                "content": "Time complexity of O(n.q.2^q) and space complexity of O(n.2^q), where n = length of nums array ( < 10^5), q = length of quantity array ( < 10)\\n```\\n    vector<unordered_set<int>> dp;\\n    int customerSatisfied(int customers, int customer){\\n        return customers & (1 << customer);\\n    }\\n    \\n    int newCustomer(int customers, int customer){\\n        return customers ^ (1 << customer);\\n    }\\n    \\n    int find(int i, vector<int> &nums, vector<int>& quantity, int* cond, int customers, int n, int q){\\n        if(customers == (1 << q) - 1) return true;\\n        if(i == n) return false;\\n        //cout << i << endl;\\n        if(dp[i].find(customers) != dp[i].end()) return false;\\n        \\n        bool res;\\n        for(int j = 0; j < q; j++){\\n            if(customerSatisfied(customers, j)) continue;\\n            if(cond[i] - i + 1 >= quantity[j]){\\n                res = find(i + quantity[j], nums, quantity, cond, newCustomer(customers, j), n, q);\\n                if(res) return true;\\n            }\\n        }\\n        \\n        res = find(cond[i]+1, nums, quantity, cond, customers, n, q);\\n        if(res) return true;\\n        dp[i].insert(customers);\\n        return false;\\n        \\n    }\\n    \\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int *cond = new int[n];\\n        cond[n-1] = n-1;\\n        for(int i = n-2; i >= 0; i--){\\n            if(nums[i] == nums[i+1]) cond[i] = cond[i+1];\\n            else cond[i] = i;\\n        }\\n        int q = quantity.size();\\n        dp = vector(n, unordered_set<int>());\\n        return find(0, nums, quantity, cond, 0, n, q);\\n        \\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    vector<unordered_set<int>> dp;\\n    int customerSatisfied(int customers, int customer){\\n        return customers & (1 << customer);\\n    }\\n    \\n    int newCustomer(int customers, int customer){\\n        return customers ^ (1 << customer);\\n    }\\n    \\n    int find(int i, vector<int> &nums, vector<int>& quantity, int* cond, int customers, int n, int q){\\n        if(customers == (1 << q) - 1) return true;\\n        if(i == n) return false;\\n        //cout << i << endl;\\n        if(dp[i].find(customers) != dp[i].end()) return false;\\n        \\n        bool res;\\n        for(int j = 0; j < q; j++){\\n            if(customerSatisfied(customers, j)) continue;\\n            if(cond[i] - i + 1 >= quantity[j]){\\n                res = find(i + quantity[j], nums, quantity, cond, newCustomer(customers, j), n, q);\\n                if(res) return true;\\n            }\\n        }\\n        \\n        res = find(cond[i]+1, nums, quantity, cond, customers, n, q);\\n        if(res) return true;\\n        dp[i].insert(customers);\\n        return false;\\n        \\n    }\\n    \\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int *cond = new int[n];\\n        cond[n-1] = n-1;\\n        for(int i = n-2; i >= 0; i--){\\n            if(nums[i] == nums[i+1]) cond[i] = cond[i+1];\\n            else cond[i] = i;\\n        }\\n        int q = quantity.size();\\n        dp = vector(n, unordered_set<int>());\\n        return find(0, nums, quantity, cond, 0, n, q);\\n        \\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 1514301,
                "title": "python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        #Backtracking approach\\n        counter = {}\\n        for num in nums:\\n            counter[num] = counter.get(num, 0) + 1\\n        freq_counter = {val: sum(1 for key in counter.keys() if counter[key] == val) for val in counter.values()}\\n        res = False\\n        #Call inner function with quantity array sorted in reverse\\n        def check_distribute(freq_counter, quantity):\\n            #print(f\\'Currently: freq_counter {freq_counter} and quantity: {quantity}\\')\\n            nonlocal res\\n            if not quantity:\\n                #All customers served\\n                #print(\\'!\\')\\n                res = True\\n                return \\n            else:\\n                if not res:\\n                    quant = quantity[-1]\\n                    for key in freq_counter:\\n                        if key < quant or freq_counter[key] == 0:\\n                            continue\\n                        else:\\n                            diff = key - quant\\n                            new_count = freq_counter[key] - 1\\n                            check_distribute({**freq_counter, key: new_count, diff: freq_counter.get(diff,0) + 1},quantity[:-1])\\n        #Call inner function \\n        check_distribute(freq_counter,sorted(quantity))\\n        return res \\n\\t```\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        #Backtracking approach\\n        counter = {}\\n        for num in nums:\\n            counter[num] = counter.get(num, 0) + 1\\n        freq_counter = {val: sum(1 for key in counter.keys() if counter[key] == val) for val in counter.values()}\\n        res = False\\n        #Call inner function with quantity array sorted in reverse\\n        def check_distribute(freq_counter, quantity):\\n            #print(f\\'Currently: freq_counter {freq_counter} and quantity: {quantity}\\')\\n            nonlocal res\\n            if not quantity:\\n                #All customers served\\n                #print(\\'!\\')\\n                res = True\\n                return \\n            else:\\n                if not res:\\n                    quant = quantity[-1]\\n                    for key in freq_counter:\\n                        if key < quant or freq_counter[key] == 0:\\n                            continue\\n                        else:\\n                            diff = key - quant\\n                            new_count = freq_counter[key] - 1\\n                            check_distribute({**freq_counter, key: new_count, diff: freq_counter.get(diff,0) + 1},quantity[:-1])\\n        #Call inner function \\n        check_distribute(freq_counter,sorted(quantity))\\n        return res \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1504805,
                "title": "python-iterative-dp-with-explanation-and-picture",
                "content": "![image](https://assets.leetcode.com/users/images/85fd017c-b649-4e50-821f-6dd1895f8d57_1633447604.9101381.jpeg)\\n```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n        same_items = sorted(Counter(nums).values())\\n        m, n = len(Q), len(same_items)\\n        masks = [sum(Q[i] for i in range(m) if mask & 1<<i) for mask in range(1<<m)]  # I call entries of this array \"Q_sums\"\\n        valids = set()   # These are the bitmasks that correspond to possible maps same_items[idx] --> Q[i] for all i in mask\\n        winner = (1<<m) - 1\\n        for idx in range(n):\\n            new_valids = set()\\n            for mask, x in enumerate(masks):\\n                if same_items[idx] >= x:\\n                    if mask == winner: return True\\n                    new_valids.add(mask)\\n            for x in valids.copy():\\n                for y in new_valids:\\n                    if x & y == 0: \\n                        merged_mask = x | y\\n                        if merged_mask == winner: return True\\n                        valids.add(merged_mask)\\n            valids.update(new_valids)            \\n        return False\\n        # It seems like what I want to check for is if same_items has enough items to distribute across Q\\n        # So, from indices of same_items, we generate bitmasks saying which objects of Q that we are covering\\n        # Thus, a valid bitmask for same_items[idx] is one whose Q_sum <= same_items[idx].\\n        # Further, each entry of Q cannot cannot receive items from different same_items[idx]. Hence, two compatible\\n        # bitmasks x, y are s.t. x & y == 0. \\n        # Therefore, we return true iff we encounter the bitmask (1<<m) - 1 (eg 11111 if m = 5)\\n        \\n        # We propagate bitmasks by first finding all valid masks for same_items[0]. Then we find all valid masks for same_items[1].\\n        # We keep a set of valid masks encountered so far, since it\\'s possible that a valid distribution of items from same_items does \\n        # not involve all items in same_items (as the picture I drew illustrates). Then, for same_items[idx] we put valid masks\\n        # in new_valids, and then for each entry in new_valids, we loop over valids and toss in compatible masks. Continue until see winner or loop ends.\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], Q: List[int]) -> bool:\\n        same_items = sorted(Counter(nums).values())\\n        m, n = len(Q), len(same_items)\\n        masks = [sum(Q[i] for i in range(m) if mask & 1<<i) for mask in range(1<<m)]  # I call entries of this array \"Q_sums\"\\n        valids = set()   # These are the bitmasks that correspond to possible maps same_items[idx] --> Q[i] for all i in mask\\n        winner = (1<<m) - 1\\n        for idx in range(n):\\n            new_valids = set()\\n            for mask, x in enumerate(masks):\\n                if same_items[idx] >= x:\\n                    if mask == winner: return True\\n                    new_valids.add(mask)\\n            for x in valids.copy():\\n                for y in new_valids:\\n                    if x & y == 0: \\n                        merged_mask = x | y\\n                        if merged_mask == winner: return True\\n                        valids.add(merged_mask)\\n            valids.update(new_valids)            \\n        return False\\n        # It seems like what I want to check for is if same_items has enough items to distribute across Q\\n        # So, from indices of same_items, we generate bitmasks saying which objects of Q that we are covering\\n        # Thus, a valid bitmask for same_items[idx] is one whose Q_sum <= same_items[idx].\\n        # Further, each entry of Q cannot cannot receive items from different same_items[idx]. Hence, two compatible\\n        # bitmasks x, y are s.t. x & y == 0. \\n        # Therefore, we return true iff we encounter the bitmask (1<<m) - 1 (eg 11111 if m = 5)\\n        \\n        # We propagate bitmasks by first finding all valid masks for same_items[0]. Then we find all valid masks for same_items[1].\\n        # We keep a set of valid masks encountered so far, since it\\'s possible that a valid distribution of items from same_items does \\n        # not involve all items in same_items (as the picture I drew illustrates). Then, for same_items[idx] we put valid masks\\n        # in new_valids, and then for each entry in new_valids, we loop over valids and toss in compatible masks. Continue until see winner or loop ends.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499692,
                "title": "c-bitmask-dp-with-mask-enumeration-time-complexity-o-50-3-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int getQuantityUsed(int mask, vector<int>&quantity){\\n        int sz = quantity.size();\\n        int total = 0;\\n        int i, j;\\n        for(i = 0; i < sz; i++){\\n            j = sz - 1 - i;\\n            if((1 << i) & mask){\\n                total += quantity[j];\\n            }\\n        }\\n        return total;\\n    }\\n    \\n    bool canDistribute(vector<int>&nums, vector<int>&quantity){\\n        int i, j, k, l;\\n        int sz = quantity.size();\\n        int len = nums.size();\\n        int bitmask = 1 << sz;\\n        unordered_map<int, int>hashMap;\\n        vector<int>uniqueNums; \\n        \\n        for(i = 0; i < len; i++){\\n            if(hashMap.find(nums[i]) == hashMap.end()){\\n                hashMap[nums[i]] = 1;\\n                uniqueNums.push_back(nums[i]);\\n            }\\n            else{\\n                hashMap[nums[i]]++;\\n            }\\n        }        \\n        \\n        len = uniqueNums.size();\\n        vector<vector<bool>>isValid(len, vector<bool>(bitmask));\\n        for(i = 0; i < len; i++){\\n            for(j = 0; j < bitmask; j++){\\n                if(getQuantityUsed(j, quantity) <= hashMap[uniqueNums[i]]){\\n                    isValid[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<bool>>dp(bitmask, vector<bool>(len + 1));\\n        for(i = 0; i <= len; i++){\\n            dp[0][i] = true;\\n        }\\n        for(i = 1; i < bitmask; i++){\\n            for(j = 1; j <= len; j++){\\n                dp[i][j] = dp[i][j - 1];\\n                for(k = i; k; k = (k - 1) & i){\\n                    if(isValid[j - 1][k]){\\n                        dp[i][j] = dp[i][j] || dp[i - k][j - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[bitmask - 1][len];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getQuantityUsed(int mask, vector<int>&quantity){\\n        int sz = quantity.size();\\n        int total = 0;\\n        int i, j;\\n        for(i = 0; i < sz; i++){\\n            j = sz - 1 - i;\\n            if((1 << i) & mask){\\n                total += quantity[j];\\n            }\\n        }\\n        return total;\\n    }\\n    \\n    bool canDistribute(vector<int>&nums, vector<int>&quantity){\\n        int i, j, k, l;\\n        int sz = quantity.size();\\n        int len = nums.size();\\n        int bitmask = 1 << sz;\\n        unordered_map<int, int>hashMap;\\n        vector<int>uniqueNums; \\n        \\n        for(i = 0; i < len; i++){\\n            if(hashMap.find(nums[i]) == hashMap.end()){\\n                hashMap[nums[i]] = 1;\\n                uniqueNums.push_back(nums[i]);\\n            }\\n            else{\\n                hashMap[nums[i]]++;\\n            }\\n        }        \\n        \\n        len = uniqueNums.size();\\n        vector<vector<bool>>isValid(len, vector<bool>(bitmask));\\n        for(i = 0; i < len; i++){\\n            for(j = 0; j < bitmask; j++){\\n                if(getQuantityUsed(j, quantity) <= hashMap[uniqueNums[i]]){\\n                    isValid[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<bool>>dp(bitmask, vector<bool>(len + 1));\\n        for(i = 0; i <= len; i++){\\n            dp[0][i] = true;\\n        }\\n        for(i = 1; i < bitmask; i++){\\n            for(j = 1; j <= len; j++){\\n                dp[i][j] = dp[i][j - 1];\\n                for(k = i; k; k = (k - 1) & i){\\n                    if(isValid[j - 1][k]){\\n                        dp[i][j] = dp[i][j] || dp[i - k][j - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[bitmask - 1][len];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482717,
                "title": "dp-memoized-approach",
                "content": "```\\nclass Solution {\\n    map<vector<int>,int> dp[11];\\n    int n,m;\\npublic:\\n    bool solver(int st,vector<int> q,vector<int> f){\\n        sort(f.begin(),f.end(),greater<int>());\\n        if(dp[st].find(f)!=dp[st].end())\\n            return dp[st][f];\\n        if(st==(m-1))\\n            return f[0]>=q[st];\\n        bool next=0;\\n        for(int i=0;i<n;i++){\\n            if(next)\\n                break;\\n            if(f[i]>=q[st]){\\n                f[i]-=q[st];\\n                next=solver(st+1,q,f);\\n                f[i]+=q[st];\\n            }\\n            else\\n                break;\\n        }\\n        return dp[st][f]=next;\\n    }\\n    \\n    bool canDistribute(vector<int>& a, vector<int>& q) {\\n        vector<int> f(1002,0);\\n        for(auto e:a)\\n            f[e]++;\\n        vector<int> t;\\n        for(auto e:f)\\n            if(e)\\n                t.push_back(e);\\n        n=t.size();\\n        m=q.size();\\n        return solver(0,q,t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    map<vector<int>,int> dp[11];\\n    int n,m;\\npublic:\\n    bool solver(int st,vector<int> q,vector<int> f){\\n        sort(f.begin(),f.end(),greater<int>());\\n        if(dp[st].find(f)!=dp[st].end())\\n            return dp[st][f];\\n        if(st==(m-1))\\n            return f[0]>=q[st];\\n        bool next=0;\\n        for(int i=0;i<n;i++){\\n            if(next)\\n                break;\\n            if(f[i]>=q[st]){\\n                f[i]-=q[st];\\n                next=solver(st+1,q,f);\\n                f[i]+=q[st];\\n            }\\n            else\\n                break;\\n        }\\n        return dp[st][f]=next;\\n    }\\n    \\n    bool canDistribute(vector<int>& a, vector<int>& q) {\\n        vector<int> f(1002,0);\\n        for(auto e:a)\\n            f[e]++;\\n        vector<int> t;\\n        for(auto e:f)\\n            if(e)\\n                t.push_back(e);\\n        n=t.size();\\n        m=q.size();\\n        return solver(0,q,t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397945,
                "title": "c-dp-fast",
                "content": "```\\n\\tbool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> hm;\\n        for(int n:nums){\\n            hm[n]++;\\n        }\\n        vector<int> freq;\\n        for(auto p:hm){\\n            freq.push_back(p.second);\\n        }\\n        int n=freq.size(),m=quantity.size();\\n        vector<vector<int>> poss(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<(1<<m);j++){\\n                int sum=0;\\n                for(int k=0;k<m && sum<=freq[i];k++){\\n                    if(j&(1<<k)){\\n                        sum+=quantity[k];\\n                    }\\n                }\\n                if(sum<=freq[i]){\\n                    poss[i].push_back(j);\\n                }\\n            }\\n        }\\n        bool dp[n+1][1<<m];\\n        for(int i=n;i>=0;i--){\\n            for(int j=0;j<(1<<m);j++){\\n                if(i==n){\\n                    dp[i][j]=j+1==1<<m;\\n                }else{\\n                    dp[i][j]=false;\\n                    for(int k:poss[i]){\\n                        if(dp[i][j]){\\n                            break;\\n                        }\\n                        if((k&j)==0 && dp[i+1][j|k]){\\n                            dp[i][j]=true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tbool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int,int> hm;\\n        for(int n:nums){\\n            hm[n]++;\\n        }\\n        vector<int> freq;\\n        for(auto p:hm){\\n            freq.push_back(p.second);\\n        }\\n        int n=freq.size(),m=quantity.size();\\n        vector<vector<int>> poss(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<(1<<m);j++){\\n                int sum=0;\\n                for(int k=0;k<m && sum<=freq[i];k++){\\n                    if(j&(1<<k)){\\n                        sum+=quantity[k];\\n                    }\\n                }\\n                if(sum<=freq[i]){\\n                    poss[i].push_back(j);\\n                }\\n            }\\n        }\\n        bool dp[n+1][1<<m];\\n        for(int i=n;i>=0;i--){\\n            for(int j=0;j<(1<<m);j++){\\n                if(i==n){\\n                    dp[i][j]=j+1==1<<m;\\n                }else{\\n                    dp[i][j]=false;\\n                    for(int k:poss[i]){\\n                        if(dp[i][j]){\\n                            break;\\n                        }\\n                        if((k&j)==0 && dp[i+1][j|k]){\\n                            dp[i][j]=true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1220772,
                "title": "swift-dfs-backtrack-solution",
                "content": "The question is essentially asking if the quantity\\'s array can be fulfilled given the number of orders. In example 3, ***nums = [1,1,2,2], quantity = [2,2]*** the result is true because there are 2 similar orders that can be taken by the first customer, and the next customer also takes another 2 similar orders. It doesn\\'t matter what the numbers are in the nums array, rather how many repeated numbers are there in the nums array.\\n    \\n```\\nclass Solution {\\n    \\n    /*\\n    Task:\\n        1. Get the frequency count for each number using a dictionary\\n        2. Convert the values in the dictionary to an array \\n        3. Sort the quantity in descending order\\n        4. Backtrack\\n            I. If there is an order that is less than what we need in the quantity array,\\n\\t\\t\\tkeep moving forward to see if the next order can fulfill the quantity. \\n\\t\\t\\t\\n            II. Otherwise, remove the quantity from the orders array and see if the rest of the quantitys can be fulfilled.\\n    */\\n    \\n    func canDistribute(_ nums: [Int], _ quantity: [Int]) -> Bool {\\n        var map: [Int: Int] = [:]\\n        for num in nums {\\n            map[num, default: 0] += 1\\n        }\\n\\n        var orders: [Int] = Array(map.values)\\n        \\n        // Descendiing order\\n        var sortedQuantity = quantity.sorted { $0 > $1 } \\n        \\n        return helper(sortedQuantity, &orders, 0)\\n    }\\n    \\n    func helper(_ quantity: [Int], _ orders: inout [Int], _ start: Int) -> Bool {\\n        \\n        // All customer\\'s get their orders\\n        if start == quantity.count { return true }\\n        \\n        for index in 0..<orders.count {\\n            var num = orders[index]\\n            \\n            // We need an order that is >= the quantity\\n            if num < quantity[start] { continue }\\n            \\n            // Quantity amount gets taken by customer\\n            orders[index] -= quantity[start]\\n            \\n            // Check if the next customers will also get their orders\\n            if helper(quantity, &orders, start+1) {\\n                return true\\n            }\\n            \\n            // Backtrack\\n            orders[index] += quantity[start]      \\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n    Task:\\n        1. Get the frequency count for each number using a dictionary\\n        2. Convert the values in the dictionary to an array \\n        3. Sort the quantity in descending order\\n        4. Backtrack\\n            I. If there is an order that is less than what we need in the quantity array,\\n\\t\\t\\tkeep moving forward to see if the next order can fulfill the quantity. \\n\\t\\t\\t\\n            II. Otherwise, remove the quantity from the orders array and see if the rest of the quantitys can be fulfilled.\\n    */\\n    \\n    func canDistribute(_ nums: [Int], _ quantity: [Int]) -> Bool {\\n        var map: [Int: Int] = [:]\\n        for num in nums {\\n            map[num, default: 0] += 1\\n        }\\n\\n        var orders: [Int] = Array(map.values)\\n        \\n        // Descendiing order\\n        var sortedQuantity = quantity.sorted { $0 > $1 } \\n        \\n        return helper(sortedQuantity, &orders, 0)\\n    }\\n    \\n    func helper(_ quantity: [Int], _ orders: inout [Int], _ start: Int) -> Bool {\\n        \\n        // All customer\\'s get their orders\\n        if start == quantity.count { return true }\\n        \\n        for index in 0..<orders.count {\\n            var num = orders[index]\\n            \\n            // We need an order that is >= the quantity\\n            if num < quantity[start] { continue }\\n            \\n            // Quantity amount gets taken by customer\\n            orders[index] -= quantity[start]\\n            \\n            // Check if the next customers will also get their orders\\n            if helper(quantity, &orders, start+1) {\\n                return true\\n            }\\n            \\n            // Backtrack\\n            orders[index] += quantity[start]      \\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068287,
                "title": "python-3-knapsack-brute-force-with-memorization-732m-beat-97",
                "content": "Each specific number is a bag. # of the number is the size of the bag. Quantity[i] is an item with size quantity[i]. Then, just use brute-force with memo. \\nO(50^10)\\n\\n```\\n        if sum(quantity) > len(nums): return False\\n        c = Counter(nums)\\n        # sizes of bags\\n        bags = list(c.values())\\n        bags.sort(reverse = True)\\n        \\n        quantity.sort(reverse = True)\\n        \\n        @lru_cache(None)\\n        def tryone(idx,bags):\\n            if idx == len(quantity): return True\\n            return any( tryone(idx + 1, tuple(sorted(bags[:b] + (bags[b] - quantity[idx],) + bags[b+1:], reverse = True))  )\\n                for b in range(len(bags)) if bags[b] >= quantity[idx])\\n            \\n        return tryone(0, tuple(bags))\\n```",
                "solutionTags": [],
                "code": "```\\n        if sum(quantity) > len(nums): return False\\n        c = Counter(nums)\\n        # sizes of bags\\n        bags = list(c.values())\\n        bags.sort(reverse = True)\\n        \\n        quantity.sort(reverse = True)\\n        \\n        @lru_cache(None)\\n        def tryone(idx,bags):\\n            if idx == len(quantity): return True\\n            return any( tryone(idx + 1, tuple(sorted(bags[:b] + (bags[b] - quantity[idx],) + bags[b+1:], reverse = True))  )\\n                for b in range(len(bags)) if bags[b] >= quantity[idx])\\n            \\n        return tryone(0, tuple(bags))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1065905,
                "title": "python3-easy-to-understand-backtracking-solution",
                "content": "It doesn\\'t matter what the contents of num are. So tracking the count of each item in nums is sufficient. Going one step further, we can maintain a count of counts and  update the counter while backtracking.\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        def backtrack(i, cntr):\\n            if i == len(quantity):\\n                return True\\n            \\n\\t\\t\\t# cnt is the number of times some element is occuring in the array.\\n\\t\\t\\t# If we use one of those nums, decrement the count of that num count\\n\\t\\t\\t# Now the number of elems in the bucket we chose would have decreased and\\n\\t\\t\\t# this new count needs to be added to the counter\\n\\t\\t\\t# If the number of buckets of  some count becomes zero, remove it from the counter\\n\\t\\t\\t# If backtrack returns False, just reverse these operations\\n\\t\\t\\t# A temp counter is necessary for these operations because we are changing the size of the original counter\\n\\t\\t\\ttemp_counter = cntr.copy()\\n            for cnt in cntr:\\n                if cnt >= quantity[i]:\\n                    temp_counter[cnt] -= 1\\n                    if temp_counter[cnt] == 0:\\n                        temp_counter.pop(cnt)\\n                    rem = cnt - quantity[i]\\n                    temp_counter[rem] += 1\\n                    \\n                    if backtrack(i+1, temp_counter):\\n                        return True\\n                    \\n                    temp_counter[rem] -= 1\\n                    if temp_counter[rem] == 0:\\n                        temp_counter.pop(rem)\\n                    temp_counter[cnt] += 1\\n                    \\n            return False\\n        \\n        count_of_counts = Counter(Counter(nums).values())\\n        quantity.sort(reverse=True)\\n        return backtrack(0, count_of_counts)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        def backtrack(i, cntr):\\n            if i == len(quantity):\\n                return True\\n            \\n\\t\\t\\t# cnt is the number of times some element is occuring in the array.\\n\\t\\t\\t# If we use one of those nums, decrement the count of that num count\\n\\t\\t\\t# Now the number of elems in the bucket we chose would have decreased and\\n\\t\\t\\t# this new count needs to be added to the counter\\n\\t\\t\\t# If the number of buckets of  some count becomes zero, remove it from the counter\\n\\t\\t\\t# If backtrack returns False, just reverse these operations\\n\\t\\t\\t# A temp counter is necessary for these operations because we are changing the size of the original counter\\n\\t\\t\\ttemp_counter = cntr.copy()\\n            for cnt in cntr:\\n                if cnt >= quantity[i]:\\n                    temp_counter[cnt] -= 1\\n                    if temp_counter[cnt] == 0:\\n                        temp_counter.pop(cnt)\\n                    rem = cnt - quantity[i]\\n                    temp_counter[rem] += 1\\n                    \\n                    if backtrack(i+1, temp_counter):\\n                        return True\\n                    \\n                    temp_counter[rem] -= 1\\n                    if temp_counter[rem] == 0:\\n                        temp_counter.pop(rem)\\n                    temp_counter[cnt] += 1\\n                    \\n            return False\\n        \\n        count_of_counts = Counter(Counter(nums).values())\\n        quantity.sort(reverse=True)\\n        return backtrack(0, count_of_counts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049282,
                "title": "c-no-dp-only-recursion-passed",
                "content": "```\\n\\tbool go(vector<int> &pool, vector<int> &qty, int i) {\\n        if(i == qty.size())             return true;\\n        \\n        bool ans = false;\\n        for(int j=0; j<pool.size(); j++) {\\n            if(pool[j] >= qty[i]) {\\n                pool[j] -= qty[i];\\n                if(go(pool, qty, i+1))  return true;\\n                pool[j] += qty[i];\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& qty) {\\n        unordered_map<int, int> cnt;\\n        for(auto val: nums) {\\n            cnt[val]++;\\n        }\\n        \\n        vector<int> pool;   // max size = 50\\n        for(auto p: cnt) {\\n            pool.push_back(p.second);\\n        }\\n        // larger qty first \\n        sort(qty.begin(), qty.end(), greater<int>());\\n        \\n        return go(pool, qty, 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tbool go(vector<int> &pool, vector<int> &qty, int i) {\\n        if(i == qty.size())             return true;\\n        \\n        bool ans = false;\\n        for(int j=0; j<pool.size(); j++) {\\n            if(pool[j] >= qty[i]) {\\n                pool[j] -= qty[i];\\n                if(go(pool, qty, i+1))  return true;\\n                pool[j] += qty[i];\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& qty) {\\n        unordered_map<int, int> cnt;\\n        for(auto val: nums) {\\n            cnt[val]++;\\n        }\\n        \\n        vector<int> pool;   // max size = 50\\n        for(auto p: cnt) {\\n            pool.push_back(p.second);\\n        }\\n        // larger qty first \\n        sort(qty.begin(), qty.end(), greater<int>());\\n        \\n        return go(pool, qty, 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1049062,
                "title": "c-kind-of-greedy",
                "content": "Sort quantity in reverse order, and put number counts in multiset.\\nIterate through quantities.  For each one quantity, find the exact count first.  If none, find the exact mutliple of count.  If still none, try the largest count.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity)\\n    {\\n        unordered_map<int, int> mp;\\n        for (auto & d : nums)\\n            mp[d]++;\\n        \\n        multiset<int, greater<int>> ss;\\n        for (auto & it : mp)\\n            ss.emplace(it.second);\\n        \\n        sort(quantity.rbegin(), quantity.rend());\\n        \\n        for (auto & q : quantity) {\\n            if (ss.size() == 0)\\n                return false;\\n            \\n            int maxcnt = *ss.begin();\\n            if (maxcnt < q)\\n                return false;\\n            \\n            bool fFound = false;\\n            \\n            for (int i = q; i <= maxcnt; i += q) {\\n                auto it = ss.find(i);\\n                \\n                if (it != ss.end()) {\\n                    fFound = true;\\n                    ss.erase(it);\\n                    \\n                    if (i != q)\\n                        ss.emplace(i - q);\\n                    break;\\n                }\\n            }\\n            \\n            if (!fFound) {\\n                auto it = ss.begin();\\n                int x = *it;\\n                \\n                ss.erase(it);\\n                ss.emplace(x - q);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity)\\n    {\\n        unordered_map<int, int> mp;\\n        for (auto & d : nums)\\n            mp[d]++;\\n        \\n        multiset<int, greater<int>> ss;\\n        for (auto & it : mp)\\n            ss.emplace(it.second);\\n        \\n        sort(quantity.rbegin(), quantity.rend());\\n        \\n        for (auto & q : quantity) {\\n            if (ss.size() == 0)\\n                return false;\\n            \\n            int maxcnt = *ss.begin();\\n            if (maxcnt < q)\\n                return false;\\n            \\n            bool fFound = false;\\n            \\n            for (int i = q; i <= maxcnt; i += q) {\\n                auto it = ss.find(i);\\n                \\n                if (it != ss.end()) {\\n                    fFound = true;\\n                    ss.erase(it);\\n                    \\n                    if (i != q)\\n                        ss.emplace(i - q);\\n                    break;\\n                }\\n            }\\n            \\n            if (!fFound) {\\n                auto it = ss.begin();\\n                int x = *it;\\n                \\n                ss.erase(it);\\n                ss.emplace(x - q);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048601,
                "title": "c-dfs-beat-98",
                "content": "some optimization:\\n1) preprocess, remove all the frequency less than min of quantity;\\n2) preprocess, remove the frenquecy and quantity which equal\\n3) start dfs from the largest quantity to smallest\\n4) recored visited fequency to get rid of duplicate\\n\\n```\\nclass Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        auto [vfeq, vquant] = preprocess(nums, quantity);\\n        return dfs(vfeq, vquant, 0);\\n    }\\n    \\n    bool dfs(vector<int>& vfeq, const vector<int>& vquant, int i){\\n        if(i == vquant.size()){\\n            return true;\\n        }\\n        set<int> visited;\\n        for(auto& f:vfeq){\\n            if(f < vquant[i] || visited.count(f)) continue;\\n            visited.insert(f);\\n            f-=vquant[i];\\n            if(dfs(vfeq, vquant, i+1)) return true;\\n            f+=vquant[i];\\n        }\\n        return false;\\n    }\\n    \\n    pair<vector<int>, vector<int>> preprocess(vector<int>& nums, vector<int>& quantity){\\n        unordered_map<int,int> cnt; \\n        for(auto x:nums) cnt[x]++;\\n\\n        map<int,int> feqs;\\n        for(auto [x, n]:cnt) feqs[n]++;\\n        sort(quantity.begin(), quantity.end());\\n        while(!feqs.empty() && feqs.begin()->first < quantity[0]) feqs.erase(feqs.begin());\\n        map<int,int> mQuanti;\\n        for(auto x:quantity) mQuanti[x]++;\\n        for(auto& [n, cnt] : mQuanti) {\\n            int y = feqs[n];\\n            feqs[n] -= min(y, cnt);\\n            cnt -= min(y, cnt);\\n        }\\n        \\n        vector<int> vfeq, vquant;\\n        for(auto [n, cnt] : feqs) while(cnt-- >0) vfeq.push_back(n);\\n        for(auto [n, cnt] : mQuanti) while(cnt-- >0) vquant.push_back(n);\\n        sort(vquant.begin(), vquant.end(), greater());\\n        return pair{vfeq, vquant};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        auto [vfeq, vquant] = preprocess(nums, quantity);\\n        return dfs(vfeq, vquant, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 998750,
                "title": "java-greedy-dfs-backtracing",
                "content": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int sum=0;\\n        for(int q:quantity) sum+=q;\\n\\t\\t// if sum is greater than number count, not possible\\n        if(sum>nums.length) return false;\\n        Map<Integer,Integer> cnts=new HashMap<>();\\n        for(int num:nums) {\\n\\t\\t\\t// group numbers\\n            cnts.put(num,cnts.getOrDefault(num,0)+1);\\n        }\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(var cnt:cnts.values()) {\\n\\t\\t\\t// group counts\\n            map.put(cnt,map.getOrDefault(cnt,0)+1);\\n        }\\n\\t\\t// sort quantity\\n        Arrays.sort(quantity);\\n\\t\\t// let\\'s start from high to low to improve performace\\n        return dfs(map,quantity,quantity.length-1);\\n    }\\n    \\n    boolean dfs(Map<Integer,Integer> map,int[]  arr,int idx) {\\n        if (idx<0) return true;\\n        if(map.containsKey(arr[idx])) {\\n            // greedy, take exactly match\\n            var cnt=map.get(arr[idx]);\\n            if(cnt==1) {\\n                map.remove(arr[idx]);\\n            } else {\\n                map.put(arr[idx],cnt-1);\\n            }\\n            if(dfs(map,arr,idx-1)) return true;\\n            // if it doesn\\'t work, backtracking\\n            map.put(arr[idx],cnt);\\n            return false;\\n        } else {\\n            var keys=new ArrayList<>(map.keySet());\\n            for(int key:keys) {\\n                if(key<arr[idx]) continue;\\n\\t\\t\\t\\t// take away from this cnt and update map accordingly\\n                var cnt=map.get(key);\\n                if(cnt==1) {\\n                    map.remove(key);\\n                } else {\\n                    map.put(key,cnt-1);\\n                }\\n                var r=key-arr[idx];\\n                var rc=map.getOrDefault(r,0);\\n                map.put(r,rc+1);\\n                if(dfs(map,arr,idx-1)) return true;\\n                // if it doesn\\'t work, backtracking\\n                map.put(key,cnt);\\n                if(rc==0) {\\n                    map.remove(r);\\n                } else {\\n                    map.put(r,rc);\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int sum=0;\\n        for(int q:quantity) sum+=q;\\n\\t\\t// if sum is greater than number count, not possible\\n        if(sum>nums.length) return false;\\n        Map<Integer,Integer> cnts=new HashMap<>();\\n        for(int num:nums) {\\n\\t\\t\\t// group numbers\\n            cnts.put(num,cnts.getOrDefault(num,0)+1);\\n        }\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(var cnt:cnts.values()) {\\n\\t\\t\\t// group counts\\n            map.put(cnt,map.getOrDefault(cnt,0)+1);\\n        }\\n\\t\\t// sort quantity\\n        Arrays.sort(quantity);\\n\\t\\t// let\\'s start from high to low to improve performace\\n        return dfs(map,quantity,quantity.length-1);\\n    }\\n    \\n    boolean dfs(Map<Integer,Integer> map,int[]  arr,int idx) {\\n        if (idx<0) return true;\\n        if(map.containsKey(arr[idx])) {\\n            // greedy, take exactly match\\n            var cnt=map.get(arr[idx]);\\n            if(cnt==1) {\\n                map.remove(arr[idx]);\\n            } else {\\n                map.put(arr[idx],cnt-1);\\n            }\\n            if(dfs(map,arr,idx-1)) return true;\\n            // if it doesn\\'t work, backtracking\\n            map.put(arr[idx],cnt);\\n            return false;\\n        } else {\\n            var keys=new ArrayList<>(map.keySet());\\n            for(int key:keys) {\\n                if(key<arr[idx]) continue;\\n\\t\\t\\t\\t// take away from this cnt and update map accordingly\\n                var cnt=map.get(key);\\n                if(cnt==1) {\\n                    map.remove(key);\\n                } else {\\n                    map.put(key,cnt-1);\\n                }\\n                var r=key-arr[idx];\\n                var rc=map.getOrDefault(r,0);\\n                map.put(r,rc+1);\\n                if(dfs(map,arr,idx-1)) return true;\\n                // if it doesn\\'t work, backtracking\\n                map.put(key,cnt);\\n                if(rc==0) {\\n                    map.remove(r);\\n                } else {\\n                    map.put(r,rc);\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998010,
                "title": "p23-5",
                "content": "DP with bm\\nAssign each color to subse of customers",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 988773,
                "title": "java-easy-solution-by-dfs-with-pruning-22ms-beats-97-solutions",
                "content": "Not re-use the same frequency for every customer, for example:\\n[1,1,2,2,3,3,4,4,4]\\n[2,3]\\nWe know the answer is true, [1,1,4,4,4] or [2,2,4,4,4] or [3,3,4,4,4]\\n\\nThe first customer could apply two1 or two2 or two3. No matter which one picked, the result must be the same. We don\\'t have to try all of the two1 or two2 or two3 to the first cutomer.\\n\\n\\n```\\nclass Solution {\\n    boolean dfs(int idx, Set<Integer> set, int[] f, int[] quantity) {\\n        if(idx==quantity.length) return true;\\n        \\n        int pre = 0;\\n        Set<Integer> visitF = new HashSet<>();\\n        \\n        for(int num : set) { //not loop from 1-1000, because at most 50 unique numbers\\n            if(f[num]<quantity[idx]) continue;\\n            if(visitF.contains(f[num])) continue; // no necessary to re-use the same frequency\\n            visitF.add(f[num]);\\n            f[num]=f[num]-quantity[idx];\\n                if(dfs(idx+1, set, f, quantity)) {\\n                    return true;\\n                }\\n                f[num]=f[num]+quantity[idx];\\n        }\\n        \\n        return false;\\n    }\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int[] f = new int[1001];\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++) {\\n            set.add(nums[i]);\\n            f[nums[i]]++;\\n        }\\n        \\n        return dfs(0, set, f, quantity);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean dfs(int idx, Set<Integer> set, int[] f, int[] quantity) {\\n        if(idx==quantity.length) return true;\\n        \\n        int pre = 0;\\n        Set<Integer> visitF = new HashSet<>();\\n        \\n        for(int num : set) { //not loop from 1-1000, because at most 50 unique numbers\\n            if(f[num]<quantity[idx]) continue;\\n            if(visitF.contains(f[num])) continue; // no necessary to re-use the same frequency\\n            visitF.add(f[num]);\\n            f[num]=f[num]-quantity[idx];\\n                if(dfs(idx+1, set, f, quantity)) {\\n                    return true;\\n                }\\n                f[num]=f[num]+quantity[idx];\\n        }\\n        \\n        return false;\\n    }\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int[] f = new int[1001];\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++) {\\n            set.add(nums[i]);\\n            f[nums[i]]++;\\n        }\\n        \\n        return dfs(0, set, f, quantity);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959938,
                "title": "c-solution-no-bit-masking",
                "content": "//Backtracking solution\\n//Memoization on index and sorted dictionary values list\\n\\n\\npublic class Solution \\n{\\n    public bool CanDistribute(int[] nums, int[] quantity)\\n\\t{\\n        Dictionary<int, int> count = new Dictionary<int, int>();\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!count.ContainsKey(nums[i]))\\n                count.Add(nums[i], 0);\\n            count[nums[i]]++;\\n        }\\n        \\n        return CanDistribute(count, count.Keys.ToList<int>(), quantity, 0);\\n    }\\n    \\n    Dictionary<string, bool> memo = new Dictionary<string, bool>();\\n    private bool CanDistribute(Dictionary<int, int> count, List<int> keys, int[] quantity, int start)\\n    {\\n        if(start >= quantity.Length) return true;\\n        \\n        List<int> vals = count.Values.ToList();\\n        vals.Sort();\\n        string key = start+\"#\"+string.Join(\" \", vals);\\n        \\n        if(memo.ContainsKey(key)) return memo[key];\\n        foreach(var k in keys)\\n        {\\n            if(count[k] >= quantity[start])\\n            {\\n                count[k] -= quantity[start];\\n                if(CanDistribute(count, keys, quantity, start+1))\\n                    return memo[key] = true;\\n                count[k] += quantity[start];\\n            }\\n        }\\n        \\n        return memo[key] = false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution \\n{\\n    public bool CanDistribute(int[] nums, int[] quantity)\\n\\t{\\n        Dictionary<int, int> count = new Dictionary<int, int>();\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(!count.ContainsKey(nums[i]))\\n                count.Add(nums[i], 0);\\n            count[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 948154,
                "title": "just-be-very-greedy-o-nlgn-solution",
                "content": "First, sort the quantity in the descending order, so we always try to serve the largest needs first, then apply as below: \\n\\n**The sequence of the principles of being greedy: **\\n\\n1. for the current largest need, if we find a repeat frequency just equal to this need, then we serve \\n2. for the current largest need, if there are any other needs with the same needed amount, then we try to find the largest combinational sum of these needs with the same amount, if there is any repeat frequency matched, then we serve \\n3. for the current largest need, find the largest repeat frequency that can satisfy this need, if there is no, then return false. if there is, subtract the need, put the rest back to the repeat frequency pool \\n\\nSo just iterate over the need values array until the end \\n\\n\\n```Scala\\n  def canDistribute(nums: Array[Int], quantity: Array[Int]): Boolean = {\\n    val sq = quantity.sortWith(_ >= _)\\n    import scala.collection.mutable.HashMap\\n    import java.util.TreeMap\\n    val stats = new HashMap[Int, Int]()\\n    val map = new TreeMap[Int, Int]((a: Int, b: Int) => -Integer.compare(a, b))\\n    nums.foreach(x => stats.put(x, stats.getOrElse(x, 0) + 1))\\n    stats.values.foreach(x => map.put(x, map.getOrDefault(x, 0) + 1))\\n\\n    var i = 0\\n    while (i < sq.length) {\\n      val v = sq(i)\\n      if (map.isEmpty) return false\\n      val maxKey = map.firstKey()\\n      if (maxKey < v) return false\\n\\n      var j = i\\n      while (j < sq.length && v == sq(j)) j += 1\\n      j -= 1\\n      while (j >= i) {\\n        val sum = (j - i + 1) * v\\n        if (map.containsKey(sum)) {\\n          map.put(sum, map.get(sum) - 1)\\n          if (map.get(sum) == 0) map remove sum\\n          i = j + 1\\n        } else if (i == j) {\\n          val remain = maxKey - v\\n          map.put(maxKey, map.get(maxKey) - 1)\\n          if (map.get(maxKey) == 0) map remove maxKey\\n          if (remain != 0) map.put(remain, map.getOrDefault(remain, 0) + 1)\\n          i += 1\\n        }\\n        j -= 1\\n      }\\n    }\\n    true\\n  }\\n```",
                "solutionTags": [],
                "code": "```Scala\\n  def canDistribute(nums: Array[Int], quantity: Array[Int]): Boolean = {\\n    val sq = quantity.sortWith(_ >= _)\\n    import scala.collection.mutable.HashMap\\n    import java.util.TreeMap\\n    val stats = new HashMap[Int, Int]()\\n    val map = new TreeMap[Int, Int]((a: Int, b: Int) => -Integer.compare(a, b))\\n    nums.foreach(x => stats.put(x, stats.getOrElse(x, 0) + 1))\\n    stats.values.foreach(x => map.put(x, map.getOrDefault(x, 0) + 1))\\n\\n    var i = 0\\n    while (i < sq.length) {\\n      val v = sq(i)\\n      if (map.isEmpty) return false\\n      val maxKey = map.firstKey()\\n      if (maxKey < v) return false\\n\\n      var j = i\\n      while (j < sq.length && v == sq(j)) j += 1\\n      j -= 1\\n      while (j >= i) {\\n        val sum = (j - i + 1) * v\\n        if (map.containsKey(sum)) {\\n          map.put(sum, map.get(sum) - 1)\\n          if (map.get(sum) == 0) map remove sum\\n          i = j + 1\\n        } else if (i == j) {\\n          val remain = maxKey - v\\n          map.put(maxKey, map.get(maxKey) - 1)\\n          if (map.get(maxKey) == 0) map remove maxKey\\n          if (remain != 0) map.put(remain, map.getOrDefault(remain, 0) + 1)\\n          i += 1\\n        }\\n        j -= 1\\n      }\\n    }\\n    true\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 947984,
                "title": "java-4ms-state-compression-handling-duplicates",
                "content": "```\\nclass Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        // compress the states first\\n        int[] counts = new int[1001];\\n        int n = 0;\\n        for(int i: nums) {\\n            counts[i] ++;\\n            if (counts[i] == 1) {\\n                n++;\\n            }\\n        }\\n        \\n        nums = new int[n];\\n        int j = 0;\\n        for(int i: counts) {\\n            if (i > 0) {\\n                nums[j++] = i;\\n            }\\n        }\\n        \\n        int m = quantity.length;\\n        int[] distrib = new int[m];\\n        Arrays.fill(distrib, -1);\\n        \\n        return distribute(nums, distrib, quantity, 0);\\n    }\\n    \\n    boolean distribute(int[] nums, int[] distrib, int[] quantity, int i) {\\n        int m = quantity.length;\\n        if (i == m) return true;\\n        \\n        int n = nums.length;\\n        int q = quantity[i];\\n        Set<Integer> used = new HashSet<>();\\n        for(int j = 0; j < n; j++) {\\n            int k = nums[j];\\n            if (k < q || used.contains(k)) continue;\\n            nums[j] -= q;\\n            distrib[i] = j;\\n            used.add(k); // Avoid duplicates. TLE without it.\\n            if (distribute(nums, distrib, quantity, i+1)) return true;\\n            nums[j] += q;\\n        }\\n        \\n        distrib[i] = -1;\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        // compress the states first\\n        int[] counts = new int[1001];\\n        int n = 0;\\n        for(int i: nums) {\\n            counts[i] ++;\\n            if (counts[i] == 1) {\\n                n++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 947356,
                "title": "go-backtracking-without-sort",
                "content": "```\\nfunc canDistribute(nums []int, quantity []int) bool {\\n    fm := make(map[int]int)\\n    \\n    for _, n := range nums {\\n        fm[n]++\\n    }\\n    \\n    return dfs(fm, quantity)\\n}\\n\\nfunc dfs(fm map[int]int, quantity []int) bool {\\n    if len(quantity) == 0 {\\n        return true\\n    }\\n    \\n    // Visited storage\\n    visited := make(map[int]bool)\\n    \\n    for i := range fm {\\n        // Just to make sure that same frequency is not visited again\\n        if visited[fm[i]] {\\n            continue\\n        }\\n        \\n        visited[fm[i]] = true\\n        \\n        if fm[i] >= quantity[0] {\\n            fm[i]-=quantity[0]\\n            if dfs(fm, quantity[1:]) {\\n                return true\\n            }\\n            fm[i]+=quantity[0]\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nfunc canDistribute(nums []int, quantity []int) bool {\\n    fm := make(map[int]int)\\n    \\n    for _, n := range nums {\\n        fm[n]++\\n    }\\n    \\n    return dfs(fm, quantity)\\n}\\n\\nfunc dfs(fm map[int]int, quantity []int) bool {\\n    if len(quantity) == 0 {\\n        return true\\n    }\\n    \\n    // Visited storage\\n    visited := make(map[int]bool)\\n    \\n    for i := range fm {\\n        // Just to make sure that same frequency is not visited again\\n        if visited[fm[i]] {\\n            continue\\n        }\\n        \\n        visited[fm[i]] = true\\n        \\n        if fm[i] >= quantity[0] {\\n            fm[i]-=quantity[0]\\n            if dfs(fm, quantity[1:]) {\\n                return true\\n            }\\n            fm[i]+=quantity[0]\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 943743,
                "title": "beginner-friendly-clean-beats-88-brute-force-backtracking",
                "content": "complexity analysis:\\n* preparing v and f would take O(N)\\n* max depth of recursion is m\\n\\t* for each resurion there is loop O(unique values)\\n\\t\\t* for each loop processing cost at max O(3*unique values)\\n*  Total number of call to recursive funtion m*(unique values)\\n\\t\\t\\n**hence time complexity will be O(N)+(3m(unique values^2))(unique values)m=O(3m^2(unique values^3))**\\n\\nIm really doubtfull at my complexity analysis will be thankful if u would help me to arrive at correct one if mine is wrong.\\n\\n\\n\\n```\\nimport bisect\\n\\nclass Solution:\\n    def toDistribute(self,values,freq,index,quantity):\\n        if index>=len(quantity):\\n            return True\\n        start=bisect.bisect_left(values,quantity[index])\\n        for i,val in enumerate(values[start:],start):\\n            if freq[i]==0:\\n                continue\\n            try:\\n                pos=values.index(val-quantity)\\n                freq[i]-=1\\n                freq[pos]+=1\\n                if self.toDistribute(values,freq,index+1,quantity):\\n                    return True\\n                freq[i]+=1\\n                freq[pos]-=1\\n                \\n            except:\\n                pos=bisect.bisect(values,val-quantity[index])\\n                freq[i]-=1\\n                temp_v=values[:pos]+[val-quantity[index]]+values[pos:]\\n                temp_f=freq[:pos]+[1]+freq[pos:]\\n                if self.toDistribute(temp_v,temp_f,index+1,quantity):\\n                    return True\\n                freq[i]+=1\\n        return False\\n    \\n\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        val=collections.Counter(nums).values()\\n        freq=collections.Counter(val)\\n        v=list(freq.keys())\\n        v.sort()\\n        f=[]\\n        for val in v:\\n            f.append(freq[val])\\n        return self.toDistribute(v,f,0,quantity)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n    def toDistribute(self,values,freq,index,quantity):\\n        if index>=len(quantity):\\n            return True\\n        start=bisect.bisect_left(values,quantity[index])\\n        for i,val in enumerate(values[start:],start):\\n            if freq[i]==0:\\n                continue\\n            try:\\n                pos=values.index(val-quantity)\\n                freq[i]-=1\\n                freq[pos]+=1\\n                if self.toDistribute(values,freq,index+1,quantity):\\n                    return True\\n                freq[i]+=1\\n                freq[pos]-=1\\n                \\n            except:\\n                pos=bisect.bisect(values,val-quantity[index])\\n                freq[i]-=1\\n                temp_v=values[:pos]+[val-quantity[index]]+values[pos:]\\n                temp_f=freq[:pos]+[1]+freq[pos:]\\n                if self.toDistribute(temp_v,temp_f,index+1,quantity):\\n                    return True\\n                freq[i]+=1\\n        return False\\n    \\n\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        val=collections.Counter(nums).values()\\n        freq=collections.Counter(val)\\n        v=list(freq.keys())\\n        v.sort()\\n        f=[]\\n        for val in v:\\n            f.append(freq[val])\\n        return self.toDistribute(v,f,0,quantity)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 939739,
                "title": "rust-backtracking",
                "content": "Convert counts into array of counts per unique value. Then assign each quantity using backtracking.\\n\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    fn backtrack(counts: &mut Vec<i32>, quantity: &Vec<i32>, index: usize) -> bool {\\n        if index == quantity.len() {\\n            return true;\\n        }\\n        for i in 0..counts.len() {\\n            if counts[i] >= quantity[index] {\\n                let p = quantity[index];\\n                counts[i] -= p;\\n                if (Self::backtrack(counts, quantity, index+1)) {\\n                    return true;\\n                }\\n                counts[i] += p;\\n            }\\n        }\\n        false\\n    }\\n    \\n    \\n    pub fn can_distribute(nums: Vec<i32>, mut quantity: Vec<i32>) -> bool {\\n        let mut counts = HashMap::new();\\n        for n in nums.iter() {\\n            let mut entry = counts.entry(*n).or_insert(0);\\n            *entry += 1;\\n        }\\n        let mut counts = counts.values().map(|x| *x).collect::<Vec<_>>();\\n        counts.sort_by(|a,b| b.cmp(a));\\n        quantity.sort_by(|a,b| b.cmp(a));\\n        \\n        Self::backtrack(&mut counts, &quantity, 0)\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Backtracking"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    fn backtrack(counts: &mut Vec<i32>, quantity: &Vec<i32>, index: usize) -> bool {\\n        if index == quantity.len() {\\n            return true;\\n        }\\n        for i in 0..counts.len() {\\n            if counts[i] >= quantity[index] {\\n                let p = quantity[index];\\n                counts[i] -= p;\\n                if (Self::backtrack(counts, quantity, index+1)) {\\n                    return true;\\n                }\\n                counts[i] += p;\\n            }\\n        }\\n        false\\n    }\\n    \\n    \\n    pub fn can_distribute(nums: Vec<i32>, mut quantity: Vec<i32>) -> bool {\\n        let mut counts = HashMap::new();\\n        for n in nums.iter() {\\n            let mut entry = counts.entry(*n).or_insert(0);\\n            *entry += 1;\\n        }\\n        let mut counts = counts.values().map(|x| *x).collect::<Vec<_>>();\\n        counts.sort_by(|a,b| b.cmp(a));\\n        quantity.sort_by(|a,b| b.cmp(a));\\n        \\n        Self::backtrack(&mut counts, &quantity, 0)\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 939618,
                "title": "simple-python3-12-lines",
                "content": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        c = Counter(nums)\\n        m = len(quantity)\\n        \\n        unique_nums = sorted(c.values())[-m:]\\n        \\n        quantity.sort(reverse=True)\\n        \\n        def backtrack(unique_nums, cust):\\n            if cust == len(quantity): return True\\n            \\n            for i, v in enumerate(unique_nums):\\n                if v < quantity[cust]: continue\\n                    \\n                unique_nums[i] -= quantity[cust]\\n                if backtrack(unique_nums, cust+1): return True\\n                unique_nums[i] += quantity[cust]\\n        \\n        return backtrack(unique_nums, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        c = Counter(nums)\\n        m = len(quantity)\\n        \\n        unique_nums = sorted(c.values())[-m:]\\n        \\n        quantity.sort(reverse=True)\\n        \\n        def backtrack(unique_nums, cust):\\n            if cust == len(quantity): return True\\n            \\n            for i, v in enumerate(unique_nums):\\n                if v < quantity[cust]: continue\\n                    \\n                unique_nums[i] -= quantity[cust]\\n                if backtrack(unique_nums, cust+1): return True\\n                unique_nums[i] += quantity[cust]\\n        \\n        return backtrack(unique_nums, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938775,
                "title": "wrong-solution",
                "content": "I think my solution is wrong, although it passes all the testcases. Can anybody provide me with a crush test?\\n```\\nclass Solution {\\n    \\n    int getSum(int[] quantity, int start, int end, int sum, int target) {\\n        int res = sum;\\n        for(int i=start; i<=end; i++) {\\n            if(sum+quantity[i]>target) break;\\n            res = Math.max(res, getSum(quantity, i+1, end, sum+quantity[i], target));\\n        }\\n        return res;\\n    }\\n    \\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        if(nums.length<2) {\\n            if(quantity.length>1||quantity[0]>1) return false;\\n            return true;\\n        }\\n        Arrays.sort(nums);\\n        Arrays.sort(quantity);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<Integer> distinct = new ArrayList<>();\\n        for(int i=1; i<nums.length; i++) {\\n            int q = 1;\\n            while(i<nums.length&&nums[i]==nums[i-1]) {\\n                q++;\\n                i++;\\n            }\\n            if(map.containsKey(q)) {\\n                map.put(q, map.get(q) + 1);\\n            } else {\\n                distinct.add(q);\\n                map.put(q, 1);\\n            }\\n        }\\n        Collections.sort(distinct); \\n        int pos = distinct.size() - 1;\\n        for(int i=quantity.length-1; i>=0; i--) {\\n            if(distinct.isEmpty()) return false;\\n            if(distinct.get(distinct.size() - 1)<quantity[i]) return false;\\n            int l = 0, r = distinct.size() - 1;\\n            while(l<=r) {\\n                int mid = (l+r) / 2;\\n                if(distinct.get(mid)==quantity[i]) {\\n                    l = mid;\\n                    break;\\n                }\\n                if(distinct.get(mid)<quantity[i]) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            }\\n            pos = l;\\n            if(distinct.get(pos)!=quantity[i]) {\\n                int bestSum = 0;\\n                for(int j=pos; j<distinct.size(); j++) {\\n                    int temp = getSum(quantity, 0, i - 1, quantity[i], distinct.get(j));\\n                    if(temp>bestSum) {\\n                        bestSum = temp;\\n                        pos = j;\\n                    }\\n                }\\n            }\\n            int rem = distinct.get(pos) - quantity[i];\\n            if(map.get(distinct.get(pos))>1) {\\n                map.put(distinct.get(pos), map.get(distinct.get(pos)) - 1);\\n            } else {\\n                map.remove(distinct.get(pos));\\n                distinct.remove(pos);\\n            }\\n            if(rem>0) {\\n                if(map.containsKey(rem)) {\\n                    map.put(rem, map.get(rem) + 1);\\n                } else {\\n                    map.put(rem, 1);\\n                    l = 0;\\n                    r = pos - 1;\\n                    while(l<=r) {\\n                        int mid = (l+r) / 2;\\n                        if(distinct.get(mid)<rem) {\\n                            l = mid + 1;\\n                        } else {\\n                            r = mid - 1;\\n                        }\\n                    }\\n                    distinct.add(r + 1, rem);\\n                }\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int getSum(int[] quantity, int start, int end, int sum, int target) {\\n        int res = sum;\\n        for(int i=start; i<=end; i++) {\\n            if(sum+quantity[i]>target) break;\\n            res = Math.max(res, getSum(quantity, i+1, end, sum+quantity[i], target));\\n        }\\n        return res;\\n    }\\n    \\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        if(nums.length<2) {\\n            if(quantity.length>1||quantity[0]>1) return false;\\n            return true;\\n        }\\n        Arrays.sort(nums);\\n        Arrays.sort(quantity);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<Integer> distinct = new ArrayList<>();\\n        for(int i=1; i<nums.length; i++) {\\n            int q = 1;\\n            while(i<nums.length&&nums[i]==nums[i-1]) {\\n                q++;\\n                i++;\\n            }\\n            if(map.containsKey(q)) {\\n                map.put(q, map.get(q) + 1);\\n            } else {\\n                distinct.add(q);\\n                map.put(q, 1);\\n            }\\n        }\\n        Collections.sort(distinct); \\n        int pos = distinct.size() - 1;\\n        for(int i=quantity.length-1; i>=0; i--) {\\n            if(distinct.isEmpty()) return false;\\n            if(distinct.get(distinct.size() - 1)<quantity[i]) return false;\\n            int l = 0, r = distinct.size() - 1;\\n            while(l<=r) {\\n                int mid = (l+r) / 2;\\n                if(distinct.get(mid)==quantity[i]) {\\n                    l = mid;\\n                    break;\\n                }\\n                if(distinct.get(mid)<quantity[i]) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid - 1;\\n                }\\n            }\\n            pos = l;\\n            if(distinct.get(pos)!=quantity[i]) {\\n                int bestSum = 0;\\n                for(int j=pos; j<distinct.size(); j++) {\\n                    int temp = getSum(quantity, 0, i - 1, quantity[i], distinct.get(j));\\n                    if(temp>bestSum) {\\n                        bestSum = temp;\\n                        pos = j;\\n                    }\\n                }\\n            }\\n            int rem = distinct.get(pos) - quantity[i];\\n            if(map.get(distinct.get(pos))>1) {\\n                map.put(distinct.get(pos), map.get(distinct.get(pos)) - 1);\\n            } else {\\n                map.remove(distinct.get(pos));\\n                distinct.remove(pos);\\n            }\\n            if(rem>0) {\\n                if(map.containsKey(rem)) {\\n                    map.put(rem, map.get(rem) + 1);\\n                } else {\\n                    map.put(rem, 1);\\n                    l = 0;\\n                    r = pos - 1;\\n                    while(l<=r) {\\n                        int mid = (l+r) / 2;\\n                        if(distinct.get(mid)<rem) {\\n                            l = mid + 1;\\n                        } else {\\n                            r = mid - 1;\\n                        }\\n                    }\\n                    distinct.add(r + 1, rem);\\n                }\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938232,
                "title": "python-bfs-beats-97",
                "content": "<details>\\n\\n<summary><b>Approach: (click to show)</b></summary>\\n\\n1. Count how many times each number appears in nums. (this is the frequency of the number)\\n2. Start at the first customer i = 0 and for all frequencies grater than quantity[0] try using that number to satisfy customer i.  \\n3. When you use frequency[j] to satisfy customer i, subtract quantity[i] from frequency[j] to show quantity[i] of that number was used.\\n4. Move on to the next customer (i += 1) and repeat the process until all customers are satisfied (True) or no path is found (False).\\n\\n</details>\\n\\n<details>\\n<summary><b>Optimizations: (click to show)</b></summary>\\n\\n1. If the frequency of a number <b>exactly</b> matches a value in quantity, <b>use it</b> and remove that value from quantity.\\n\\n    i.e. nums = [4, 4, 2, 3] ; quantity = [2, 2]\\n         use [4, 4] immediately so nums = [2, 3] and quantity = [2]\\n\\n2. Sort quantity in <b>reverse</b> order (largest to smallest) so that we address the larger cusomer requests first.  <b>This helps identify False answers faster.</b>\\n\\n3. Do not try to use the same frequency twice when looking at the remaining numbers.  <b>used</b> keeps track of the frequencies tired already for quantity[i].\\n\\n4. Use a priority queue (heap) so that if a solution exists we will arrive at it sooner and can stop early.  <b>This helps identify True answers faster.</b>\\n\\n</details>\\n\\n```python\\ndef canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n\\n\\t# 1. Find the frequency of each number\\n\\tfreq = collections.Counter(list(collections.Counter(nums).values()))\\n\\n\\t# 2. If the quantity[i] is in freq, use that number.\\n\\t#    i.e. quantity = [2, 2] ; nums = [1, 1, 2, 3] use [1, 1] right away\\n\\t#         so we get quantity = [2] and nums = [2, 3]\\n\\tremoved = set()\\n\\tfor i in range(len(quantity)):\\n\\t\\tif freq[quantity[i]] > 0:\\n\\t\\t\\tfreq[quantity[i]] -= 1\\n\\t\\t\\tremoved.add(i)\\n\\tquantity = [quantity[i] for i in range(len(quantity)) if i not in removed]\\n\\n\\tif not quantity: return True \\n\\tfreqs = sum(([key]*freq[key] for key in freq), [])\\n\\n\\t# 3. Sort the quantities in reverse order, this helps identify False cases much faster.\\n\\tquantity.sort(reverse = True)\\n\\n\\t# 4. Breadth First Search\\n\\tq = [(0, freqs)]\\n\\twhile q:\\n\\t\\ti, freqs = heapq.heappop(q)\\n\\t\\ti = -i\\n\\t\\tif i == len(quantity):\\n\\t\\t\\treturn True\\n\\t\\tquant = quantity[i]\\n\\t\\tused = set()                                                                        # keep track of the freqs[j] values used for quantity[i]\\n\\t\\tfor j in range(len(freqs)):\\n\\t\\t\\tif freqs[j] >= quant and freqs[j] not in used:                                  # do not use the same value more than once for quantity[i]\\n\\t\\t\\t\\tused.add(freqs[j])\\n\\t\\t\\t\\tif freqs[j] > quant:\\n\\t\\t\\t\\t\\theapq.heappush(q, (-(i+1), freqs[:j] + [freqs[j]-quant] + freqs[j+1:]))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\theapq.heappush(q, (-(i+1), freqs[:j] + freqs[j+1:]))                    # freqs[j] == quantity[i] we can stop checking other frequencies\\n\\t\\t\\t\\t\\tbreak\\n\\treturn False\\n```\\n\\n<details>\\n\\n<summary><b>Here is a more efficient implementation: (click to show)</b></summary>\\n\\nSo in the first solution the frequency of each number is stored in a list. i.e. nums = [1, 1, 1, 2, 4, 4, 5, 5] ; freqs = [3, 1, 2, 2]\\n\\nIt is more efficient to store freqs as a counter instead. i.e. freqs = {3: 1, 1: 1, 2: 2}\\nBecause a counter:\\n1. uses less space when there are many repeat values\\n2. can be updated in O(1) time and \\n3. we can check if quantity[i] is in freqs in O(1) time.  \\n\\n<b>However, the python heapq module does not play nice with counters</b> because Counters are not comparable.  \\ni.e. is Counter({3:1, 2:3, 1:1}) greater than Counter({2:1, 1:1, 3:3})? Python doesn\\'t know...\\n\\nTo use a counter with a heap, we a custom heap class that ignores the Counter part of an item when comparing items in the heap.  \\ni.e. item1 = ( 5, Counter({1:1, 2:2}) ) ; item2 = ( 3, Counter({7:1, 1:2}) ).  is item1 > item 2? Yes, because 5 > 3 and ignore the Counter.  \\n\\n<details>\\n\\n<summary><b>Solution: (click to show)</b></summary>\\n\\n```python\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        \\n        # 1. Find the frequency of each number\\n        freqs = collections.Counter(list(collections.Counter(nums).values()))\\n        \\n        # 2. If the quantity[i] is in freq, use that number.\\n        #    i.e. quantity = [2, 2] ; nums = [1, 1, 2, 3] use [1, 1] right away\\n        #         so we get quantity = [2] and nums = [2, 3]\\n        removed = set()\\n        for i in range(len(quantity)):\\n            if freqs[quantity[i]] > 0:\\n                freqs[quantity[i]] -= 1\\n                removed.add(i)\\n        quantity = [quantity[i] for i in range(len(quantity)) if i not in removed]\\n        \\n        if not quantity: return True \\n        \\n        # 3. Sort the quantities in reverse order, this helps identify False cases much faster.\\n        quantity.sort(reverse = True)\\n        \\n        # 4. Breadth First Search\\n        q = Max_Heap([(0, freqs)])\\n        while not q.is_empty():\\n            i, freqs = q.heappop()\\n            \\n            if i == len(quantity):\\n                return True\\n            quant = quantity[i]\\n            \\n            if quant in freqs and freqs[quant] > 0:\\n                new_freqs = freqs.copy()\\n                new_freqs[quant] -= 1\\n                q.heappush((i+1, new_freqs))\\n                continue\\n\\n            for f in freqs:\\n                if f > quant and freqs[f] > 0:\\n                    new_freqs = freqs.copy()\\n                    new_freqs[f] -= 1\\n                    new_freqs[f-quant] += 1\\n                    q.heappush((i+1, new_freqs))\\n            \\n        return False\\n```\\n\\n</details>\\n\\n<details>\\n\\n<summary><b>Custom Max Heap Class: (click to show)</b></summary>\\n\\n```python\\nclass Max_Heap(object):\\n    def __init__(self, arr):\\n        self.arr = arr if arr else []\\n    \\n    def heappush(self, val):\\n        self.arr.append(val)\\n        i = len(self.arr) - 1\\n        while True:\\n            i, b = self.bubble_up(i)\\n            if not b: \\n                break\\n    \\n    def heappop(self):\\n        if len(self.arr) == 1:\\n            return self.arr.pop()\\n        res = self.arr[0]\\n        self.arr[0] = self.arr.pop()\\n        i = 0\\n        while True:\\n            i, b = self.bubble_down(i)\\n            if not b:\\n                break\\n        \\n        return res\\n    \\n    def bubble_up(self, i):\\n        if not i: return (i, False)\\n        \\n        j = (i + 1) // 2\\n        if self.arr[j][0] < self.arr[i][0]:\\n            self.arr[i], self.arr[j] = self.arr[j], self.arr[i]\\n            return (j, True)\\n        \\n        return (i, False)\\n    \\n    def bubble_down(self, i):\\n        j = (i+1) * 2\\n        if j - 1 >= len(self.arr): \\n            return (i, False)\\n        \\n        if j == len(self.arr):\\n            # only consider left branch\\n            if self.arr[j-1][0] > self.arr[i][0]:\\n                self.arr[i], self.arr[j-1] = self.arr[j-1], self.arr[i]\\n            return (j, False)\\n        \\n        # consider left and right branch\\n        j = max((j, j-1), key = lambda x: self.arr[x][0])\\n        if self.arr[j][0] > self.arr[i][0]:\\n            self.arr[i], self.arr[j] = self.arr[j], self.arr[i]\\n            return (j, True)\\n        return (i, False)\\n\\n    def is_empty(self):\\n        return not bool(self.arr)\\n```\\n\\n</details>\\n\\n</details>\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndef canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n\\n\\t# 1. Find the frequency of each number\\n\\tfreq = collections.Counter(list(collections.Counter(nums).values()))\\n\\n\\t# 2. If the quantity[i] is in freq, use that number.\\n\\t#    i.e. quantity = [2, 2] ; nums = [1, 1, 2, 3] use [1, 1] right away\\n\\t#         so we get quantity = [2] and nums = [2, 3]\\n\\tremoved = set()\\n\\tfor i in range(len(quantity)):\\n\\t\\tif freq[quantity[i]] > 0:\\n\\t\\t\\tfreq[quantity[i]] -= 1\\n\\t\\t\\tremoved.add(i)\\n\\tquantity = [quantity[i] for i in range(len(quantity)) if i not in removed]\\n\\n\\tif not quantity: return True \\n\\tfreqs = sum(([key]*freq[key] for key in freq), [])\\n\\n\\t# 3. Sort the quantities in reverse order, this helps identify False cases much faster.\\n\\tquantity.sort(reverse = True)\\n\\n\\t# 4. Breadth First Search\\n\\tq = [(0, freqs)]\\n\\twhile q:\\n\\t\\ti, freqs = heapq.heappop(q)\\n\\t\\ti = -i\\n\\t\\tif i == len(quantity):\\n\\t\\t\\treturn True\\n\\t\\tquant = quantity[i]\\n\\t\\tused = set()                                                                        # keep track of the freqs[j] values used for quantity[i]\\n\\t\\tfor j in range(len(freqs)):\\n\\t\\t\\tif freqs[j] >= quant and freqs[j] not in used:                                  # do not use the same value more than once for quantity[i]\\n\\t\\t\\t\\tused.add(freqs[j])\\n\\t\\t\\t\\tif freqs[j] > quant:\\n\\t\\t\\t\\t\\theapq.heappush(q, (-(i+1), freqs[:j] + [freqs[j]-quant] + freqs[j+1:]))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\theapq.heappush(q, (-(i+1), freqs[:j] + freqs[j+1:]))                    # freqs[j] == quantity[i] we can stop checking other frequencies\\n\\t\\t\\t\\t\\tbreak\\n\\treturn False\\n```\n```python\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        \\n        # 1. Find the frequency of each number\\n        freqs = collections.Counter(list(collections.Counter(nums).values()))\\n        \\n        # 2. If the quantity[i] is in freq, use that number.\\n        #    i.e. quantity = [2, 2] ; nums = [1, 1, 2, 3] use [1, 1] right away\\n        #         so we get quantity = [2] and nums = [2, 3]\\n        removed = set()\\n        for i in range(len(quantity)):\\n            if freqs[quantity[i]] > 0:\\n                freqs[quantity[i]] -= 1\\n                removed.add(i)\\n        quantity = [quantity[i] for i in range(len(quantity)) if i not in removed]\\n        \\n        if not quantity: return True \\n        \\n        # 3. Sort the quantities in reverse order, this helps identify False cases much faster.\\n        quantity.sort(reverse = True)\\n        \\n        # 4. Breadth First Search\\n        q = Max_Heap([(0, freqs)])\\n        while not q.is_empty():\\n            i, freqs = q.heappop()\\n            \\n            if i == len(quantity):\\n                return True\\n            quant = quantity[i]\\n            \\n            if quant in freqs and freqs[quant] > 0:\\n                new_freqs = freqs.copy()\\n                new_freqs[quant] -= 1\\n                q.heappush((i+1, new_freqs))\\n                continue\\n\\n            for f in freqs:\\n                if f > quant and freqs[f] > 0:\\n                    new_freqs = freqs.copy()\\n                    new_freqs[f] -= 1\\n                    new_freqs[f-quant] += 1\\n                    q.heappush((i+1, new_freqs))\\n            \\n        return False\\n```\n```python\\nclass Max_Heap(object):\\n    def __init__(self, arr):\\n        self.arr = arr if arr else []\\n    \\n    def heappush(self, val):\\n        self.arr.append(val)\\n        i = len(self.arr) - 1\\n        while True:\\n            i, b = self.bubble_up(i)\\n            if not b: \\n                break\\n    \\n    def heappop(self):\\n        if len(self.arr) == 1:\\n            return self.arr.pop()\\n        res = self.arr[0]\\n        self.arr[0] = self.arr.pop()\\n        i = 0\\n        while True:\\n            i, b = self.bubble_down(i)\\n            if not b:\\n                break\\n        \\n        return res\\n    \\n    def bubble_up(self, i):\\n        if not i: return (i, False)\\n        \\n        j = (i + 1) // 2\\n        if self.arr[j][0] < self.arr[i][0]:\\n            self.arr[i], self.arr[j] = self.arr[j], self.arr[i]\\n            return (j, True)\\n        \\n        return (i, False)\\n    \\n    def bubble_down(self, i):\\n        j = (i+1) * 2\\n        if j - 1 >= len(self.arr): \\n            return (i, False)\\n        \\n        if j == len(self.arr):\\n            # only consider left branch\\n            if self.arr[j-1][0] > self.arr[i][0]:\\n                self.arr[i], self.arr[j-1] = self.arr[j-1], self.arr[i]\\n            return (j, False)\\n        \\n        # consider left and right branch\\n        j = max((j, j-1), key = lambda x: self.arr[x][0])\\n        if self.arr[j][0] > self.arr[i][0]:\\n            self.arr[i], self.arr[j] = self.arr[j], self.arr[i]\\n            return (j, True)\\n        return (i, False)\\n\\n    def is_empty(self):\\n        return not bool(self.arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937377,
                "title": "c-o-m-3-m",
                "content": "```\\nclass Solution {\\n    void gen(int now, int state, int sum, const vector<int> &q, vector<int> &a) {\\n        if (now >= q.size()) {\\n            a[state] = sum;\\n            return;\\n        }\\n        gen(now + 1, state, sum, q, a);\\n        gen(now + 1, state | (1 << now), sum + q[now], q, a);\\n    }\\n    \\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> have;\\n        for (int x : nums) {\\n            ++have[x];\\n        }\\n        vector<int> v;\\n        for (const auto& p : have) {\\n            v.push_back(p.second);\\n        }\\n        sort(v.begin(), v.end());\\n        const int m = quantity.size();\\n        const int s = 1 << m;\\n        vector<int> a(s);\\n        gen(0, 0, 0, quantity, a);\\n        vector<bool> dp(s);\\n        dp[0] = true;\\n        int sum = 0;\\n        for (int t = max(0, ((int) v.size()) - m); t < v.size(); ++t) {\\n            sum += v[t];\\n            for (int i = s - 1; i >= 0; --i) {\\n                if (a[i] > sum) continue;\\n                for (int j = i; !dp[i]; j = (j - 1) & i) {\\n                    dp[i] = dp[j] && a[i ^ j] <= v[t];\\n                    if (j == 0) break;\\n                }\\n            }\\n        }\\n        return dp[s - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void gen(int now, int state, int sum, const vector<int> &q, vector<int> &a) {\\n        if (now >= q.size()) {\\n            a[state] = sum;\\n            return;\\n        }\\n        gen(now + 1, state, sum, q, a);\\n        gen(now + 1, state | (1 << now), sum + q[now], q, a);\\n    }\\n    \\npublic:\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> have;\\n        for (int x : nums) {\\n            ++have[x];\\n        }\\n        vector<int> v;\\n        for (const auto& p : have) {\\n            v.push_back(p.second);\\n        }\\n        sort(v.begin(), v.end());\\n        const int m = quantity.size();\\n        const int s = 1 << m;\\n        vector<int> a(s);\\n        gen(0, 0, 0, quantity, a);\\n        vector<bool> dp(s);\\n        dp[0] = true;\\n        int sum = 0;\\n        for (int t = max(0, ((int) v.size()) - m); t < v.size(); ++t) {\\n            sum += v[t];\\n            for (int i = s - 1; i >= 0; --i) {\\n                if (a[i] > sum) continue;\\n                for (int j = i; !dp[i]; j = (j - 1) & i) {\\n                    dp[i] = dp[j] && a[i ^ j] <= v[t];\\n                    if (j == 0) break;\\n                }\\n            }\\n        }\\n        return dp[s - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937346,
                "title": "python-3-dp-status-compression-solution",
                "content": "since quantity is limited so we can use bitmap to store the status.\\nwe only care fre of numbers in nums, thus we want to get a cnt first.\\nthen we want to allocate each fre to each quantity.\\nthe relation is like a typic dp problem:\\ndp(i,j)=dp(i-1,j) or dp(i-1,j-s) where i means we have  subarray cnt[0...j],j means we need to satisfy subquantity j. s means one sub-bit of j such that cnt[i] will satisfy s bit-map group=>sums_need(s)<=cnt[i]\\neg: the final j is (1<<m)-1) which is like 11111..1111 means we want to satisfy all m numbers in quantity.\\nthus we want to iterate all sub-bit of j, there is a way to do that descending:sub=(sub-1)&j, which will remove leftmost 1 bit and recover all 1 after removed 1 bit, so we will get highest bit from all remain one.\\nthen we need to compare sums of subset number and cnt[i], we can pre-calcualte it.\\n```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        cnt=sorted(collections.Counter(nums).values(),reverse=True)[:len(quantity)]\\n        m,n=len(quantity),len(cnt)\\n        mask_sums=[0]*(1<<m)#pre-calculate sums of need for mask x.\\n        for bit in range(1,1<<m):\\n            for i in range(m):#add sums for each bit 1.\\n                if bit &(1<<i):\\n                    mask_sums[bit]+=quantity[i]\\n        \\n        @lru_cache(None)\\n        def dp(i,j):#find if exist dp(i-1,j-s) value is True or dp(i,j-s) is True\\n            if i<0:#no element,only True when no quantity required\\n                return j==0\\n            if j==0 or dp(i-1,j):#dp(i,j) is depend on dp(i-1,j) or any(dp(i-1,j-sub) is true)\\n                return True\\n            sub=j\\n            while sub!=0:\\n                if dp(i-1,j-sub) and cnt[i]>=mask_sums[sub]:\\n                    return True\\n                sub=(sub-1)&j   \\n            return False\\n        return dp(n-1,(1<<m)-1)",
                "solutionTags": [],
                "code": "since quantity is limited so we can use bitmap to store the status.\\nwe only care fre of numbers in nums, thus we want to get a cnt first.\\nthen we want to allocate each fre to each quantity.\\nthe relation is like a typic dp problem:\\ndp(i,j)=dp(i-1,j) or dp(i-1,j-s) where i means we have  subarray cnt[0...j],j means we need to satisfy subquantity j. s means one sub-bit of j such that cnt[i] will satisfy s bit-map group=>sums_need(s)<=cnt[i]\\neg: the final j is (1<<m)-1) which is like 11111..1111 means we want to satisfy all m numbers in quantity.\\nthus we want to iterate all sub-bit of j, there is a way to do that descending:sub=(sub-1)&j, which will remove leftmost 1 bit and recover all 1 after removed 1 bit, so we will get highest bit from all remain one.\\nthen we need to compare sums of subset number and cnt[i], we can pre-calcualte it.\\n```\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        cnt=sorted(collections.Counter(nums).values(),reverse=True)[:len(quantity)]\\n        m,n=len(quantity),len(cnt)\\n        mask_sums=[0]*(1<<m)#pre-calculate sums of need for mask x.\\n        for bit in range(1,1<<m):\\n            for i in range(m):#add sums for each bit 1.\\n                if bit &(1<<i):\\n                    mask_sums[bit]+=quantity[i]\\n        \\n        @lru_cache(None)\\n        def dp(i,j):#find if exist dp(i-1,j-s) value is True or dp(i,j-s) is True\\n            if i<0:#no element,only True when no quantity required\\n                return j==0\\n            if j==0 or dp(i-1,j):#dp(i,j) is depend on dp(i-1,j) or any(dp(i-1,j-sub) is true)\\n                return True\\n            sub=j\\n            while sub!=0:\\n                if dp(i-1,j-sub) and cnt[i]>=mask_sums[sub]:\\n                    return True\\n                sub=(sub-1)&j   \\n            return False\\n        return dp(n-1,(1<<m)-1)",
                "codeTag": "Java"
            },
            {
                "id": 936820,
                "title": "java-solution-backtracking-less-code",
                "content": "```\\nclass Solution {\\n    \\n    List<Integer> list = new ArrayList<>();\\n    \\n    boolean f(int[] q, int i){\\n        if(i<0) return true;\\n        for(int j=0; j<list.size(); j++){\\n            int e = list.get(j);\\n            if(e>=q[i]){\\n                list.set(j, e-q[i]);\\n                if(f(q, i-1)) return true;\\n                list.set(j, e);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean canDistribute(int[] nums, int[] q) {\\n        int[] cnts = new int[1001];\\n        for(int n:nums) cnts[n]++;\\n        for(int n:cnts)\\n            if(n>0) list.add(n);\\n        Arrays.sort(q); // try the largest quatity first\\n        return f(q, q.length-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    List<Integer> list = new ArrayList<>();\\n    \\n    boolean f(int[] q, int i){\\n        if(i<0) return true;\\n        for(int j=0; j<list.size(); j++){\\n            int e = list.get(j);\\n            if(e>=q[i]){\\n                list.set(j, e-q[i]);\\n                if(f(q, i-1)) return true;\\n                list.set(j, e);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean canDistribute(int[] nums, int[] q) {\\n        int[] cnts = new int[1001];\\n        for(int n:nums) cnts[n]++;\\n        for(int n:cnts)\\n            if(n>0) list.add(n);\\n        Arrays.sort(q); // try the largest quatity first\\n        return f(q, q.length-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936431,
                "title": "c-dp-bitmasking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int n, m;\\n    \\n    bool isPossible(int mask, int val, vector<int> & quantity){\\n        \\n        for(int i = 0; i < n; i++){\\n            if((mask & (1 << i))){\\n                if(val >= quantity[i])\\n                    val -= quantity[i];\\n                else \\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool helper(int idx, int mask, vector<int> &quantity, vector<int> &arr){\\n        if(mask == (1 << n)-1) return true;\\n        if(idx == m) return false;\\n        \\n        if(dp[idx][mask] != -1) return dp[idx][mask];\\n        \\n        int tempMask = (~mask) & ((1 << n)-1);\\n        \\n\\t\\t// to check among all the possible subsets of the elements not included currently in mask. \\n        for(int s = tempMask; ; s = (s-1) & tempMask){\\n            if(isPossible(s, arr[idx], quantity)){\\n                if(helper(idx+1, mask | s, quantity, arr)) \\n                    return dp[idx][mask] =  true;\\n            }\\n            if(s == 0) break;\\n        }\\n        \\n        return dp[idx][mask] = false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> freq;\\n        \\n        for(int x : nums) freq[x]++;\\n        \\n        vector<int> arr;\\n        \\n        for(auto p : freq) arr.push_back(p.second);\\n        sort(arr.begin(), arr.end());\\n        sort(quantity.begin(), quantity.end());\\n        \\n        m = arr.size();\\n        n = quantity.size();\\n        \\n        dp.resize(m, vector<int>((1 << n), -1));\\n        \\n        return helper(0, 0, quantity, arr);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int n, m;\\n    \\n    bool isPossible(int mask, int val, vector<int> & quantity){\\n        \\n        for(int i = 0; i < n; i++){\\n            if((mask & (1 << i))){\\n                if(val >= quantity[i])\\n                    val -= quantity[i];\\n                else \\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool helper(int idx, int mask, vector<int> &quantity, vector<int> &arr){\\n        if(mask == (1 << n)-1) return true;\\n        if(idx == m) return false;\\n        \\n        if(dp[idx][mask] != -1) return dp[idx][mask];\\n        \\n        int tempMask = (~mask) & ((1 << n)-1);\\n        \\n\\t\\t// to check among all the possible subsets of the elements not included currently in mask. \\n        for(int s = tempMask; ; s = (s-1) & tempMask){\\n            if(isPossible(s, arr[idx], quantity)){\\n                if(helper(idx+1, mask | s, quantity, arr)) \\n                    return dp[idx][mask] =  true;\\n            }\\n            if(s == 0) break;\\n        }\\n        \\n        return dp[idx][mask] = false;\\n    }\\n    \\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        unordered_map<int, int> freq;\\n        \\n        for(int x : nums) freq[x]++;\\n        \\n        vector<int> arr;\\n        \\n        for(auto p : freq) arr.push_back(p.second);\\n        sort(arr.begin(), arr.end());\\n        sort(quantity.begin(), quantity.end());\\n        \\n        m = arr.size();\\n        n = quantity.size();\\n        \\n        dp.resize(m, vector<int>((1 << n), -1));\\n        \\n        return helper(0, 0, quantity, arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936233,
                "title": "cpp14-dp-backtracking-solution",
                "content": "dp[index][state] denotes whether we can satisfy customers upto index = index , such that we have already satisfied some customers and our current state of frequency is state.  \\n\\n```\\nclass Solution {\\npublic:\\n    map<vector<int> , int>dp ;\\n    int n ;\\n    vector<int> quant;\\n    map<int,int> freq ;\\n    bool solve(int index)\\n    {\\n        if(index == n) return true ;\\n        bool does = false;\\n        vector<int> currstate ;\\n        for(auto x : freq ) currstate.push_back(x.second);\\n        sort(currstate.begin(), currstate.end()) ;\\n        currstate.push_back(1e9+index);\\n        if(dp[currstate]){\\n            if(dp[currstate] == 1) return true;\\n            return false;\\n        }\\n        for(auto x : freq){\\n             int demand = quant[index];\\n             int curr = x.first;\\n             if(freq[curr] >= demand){\\n                freq[curr]-=demand;\\n                does = does | solve(index + 1);\\n                if(does == true){\\n                    dp[currstate] = 1;\\n                    return true;\\n                }\\n                freq[curr]+=demand;\\n             }\\n        }\\n        if(does == true) dp[currstate] = 1;\\n        if(does == false) dp[currstate] = 2;\\n        return does ;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        freq.clear();\\n        dp.clear() ;\\n        quant = quantity;\\n        for(auto x : nums ) freq[x]++;\\n        n = quantity.size();\\n        return solve(0);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<vector<int> , int>dp ;\\n    int n ;\\n    vector<int> quant;\\n    map<int,int> freq ;\\n    bool solve(int index)\\n    {\\n        if(index == n) return true ;\\n        bool does = false;\\n        vector<int> currstate ;\\n        for(auto x : freq ) currstate.push_back(x.second);\\n        sort(currstate.begin(), currstate.end()) ;\\n        currstate.push_back(1e9+index);\\n        if(dp[currstate]){\\n            if(dp[currstate] == 1) return true;\\n            return false;\\n        }\\n        for(auto x : freq){\\n             int demand = quant[index];\\n             int curr = x.first;\\n             if(freq[curr] >= demand){\\n                freq[curr]-=demand;\\n                does = does | solve(index + 1);\\n                if(does == true){\\n                    dp[currstate] = 1;\\n                    return true;\\n                }\\n                freq[curr]+=demand;\\n             }\\n        }\\n        if(does == true) dp[currstate] = 1;\\n        if(does == false) dp[currstate] = 2;\\n        return does ;\\n    }\\n\\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\\n        freq.clear();\\n        dp.clear() ;\\n        quant = quantity;\\n        for(auto x : nums ) freq[x]++;\\n        n = quantity.size();\\n        return solve(0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935864,
                "title": "java-dp-o-50-m-2-2m",
                "content": "```\\nclass Solution {\\n    int sz = 50;\\n\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int m = quantity.length;\\n        boolean[][] dp = new boolean[sz][1 << m];\\n        dp[0][0] = true;\\n        int[] freqs = new int[sz];\\n        Arrays.sort(nums);\\n        int prev = -1, ptr = -1;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != prev) {\\n                prev = nums[i];\\n                ptr++;\\n            }\\n            freqs[ptr]++;\\n        }\\n        for(int ind = 1; ind <= sz - 1 && freqs[ind - 1] != 0; ind++) {\\n            int freq = freqs[ind - 1];\\n            for(int pre = 0; pre < (1 << m); pre++) {\\n                if(!dp[ind - 1][pre]) continue;\\n                dp[ind][pre] = true;\\n                for(int nxt = 0; nxt < (1 << m); nxt++) {\\n                    if((nxt & pre) != 0) continue;\\n                    int acc = 0;\\n                    for(int i = 0; i < m; i++) {\\n                        if((nxt & (1 << i)) != 0) {\\n                            acc += quantity[i];\\n                        }\\n                    }\\n                    if(acc > freq) continue;\\n                    dp[ind][nxt | pre] = true;\\n                    if((nxt | pre) == (1 << m) - 1) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int sz = 50;\\n\\n    public boolean canDistribute(int[] nums, int[] quantity) {\\n        int m = quantity.length;\\n        boolean[][] dp = new boolean[sz][1 << m];\\n        dp[0][0] = true;\\n        int[] freqs = new int[sz];\\n        Arrays.sort(nums);\\n        int prev = -1, ptr = -1;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != prev) {\\n                prev = nums[i];\\n                ptr++;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1800423,
                "content": [
                    {
                        "username": "qinzhe",
                        "content": "The explanation of the first example is wrong? Should not it be \"The 0th customer cannot be given two same integers.\"?"
                    },
                    {
                        "username": "takru",
                        "content": "num = [1,1,1,1,2,2,2,2,2,2,2,2,2] quant = [3,3,3,4], how is this true?"
                    },
                    {
                        "username": "Saketh_123",
                        "content": "2 is distributed thrice and 1 is distributed 4 times\\n"
                    },
                    {
                        "username": "sahilkece0202",
                        "content": "will give 4 ones to 3rd index , after that 3-3 two\\'s to 0th,1st ,2nd index"
                    }
                ]
            },
            {
                "id": 1837837,
                "content": [
                    {
                        "username": "qinzhe",
                        "content": "The explanation of the first example is wrong? Should not it be \"The 0th customer cannot be given two same integers.\"?"
                    },
                    {
                        "username": "takru",
                        "content": "num = [1,1,1,1,2,2,2,2,2,2,2,2,2] quant = [3,3,3,4], how is this true?"
                    },
                    {
                        "username": "Saketh_123",
                        "content": "2 is distributed thrice and 1 is distributed 4 times\\n"
                    },
                    {
                        "username": "sahilkece0202",
                        "content": "will give 4 ones to 3rd index , after that 3-3 two\\'s to 0th,1st ,2nd index"
                    }
                ]
            }
        ]
    },
    {
        "title": "Design an Ordered Stream",
        "question_content": "<p>There is a stream of <code>n</code> <code>(idKey, value)</code> pairs arriving in an <strong>arbitrary</strong> order, where <code>idKey</code> is an integer between <code>1</code> and <code>n</code> and <code>value</code> is a string. No two pairs have the same <code>id</code>.</p>\n\n<p>Design a stream that returns the values in <strong>increasing order of their IDs</strong> by returning a <strong>chunk</strong> (list) of values after each insertion. The concatenation of all the <strong>chunks</strong> should result in a list of the sorted values.</p>\n\n<p>Implement the <code>OrderedStream</code> class:</p>\n\n<ul>\n\t<li><code>OrderedStream(int n)</code> Constructs the stream to take <code>n</code> values.</li>\n\t<li><code>String[] insert(int idKey, String value)</code> Inserts the pair <code>(idKey, value)</code> into the stream, then returns the <strong>largest possible chunk</strong> of currently inserted values that appear next in the order.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/10/q1.gif\" style=\"width: 682px; height: 240px;\" /></strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;OrderedStream&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;]\n[[5], [3, &quot;ccccc&quot;], [1, &quot;aaaaa&quot;], [2, &quot;bbbbb&quot;], [5, &quot;eeeee&quot;], [4, &quot;ddddd&quot;]]\n<strong>Output</strong>\n[null, [], [&quot;aaaaa&quot;], [&quot;bbbbb&quot;, &quot;ccccc&quot;], [], [&quot;ddddd&quot;, &quot;eeeee&quot;]]\n\n<strong>Explanation</strong>\n// Note that the values ordered by ID is [&quot;aaaaa&quot;, &quot;bbbbb&quot;, &quot;ccccc&quot;, &quot;ddddd&quot;, &quot;eeeee&quot;].\nOrderedStream os = new OrderedStream(5);\nos.insert(3, &quot;ccccc&quot;); // Inserts (3, &quot;ccccc&quot;), returns [].\nos.insert(1, &quot;aaaaa&quot;); // Inserts (1, &quot;aaaaa&quot;), returns [&quot;aaaaa&quot;].\nos.insert(2, &quot;bbbbb&quot;); // Inserts (2, &quot;bbbbb&quot;), returns [&quot;bbbbb&quot;, &quot;ccccc&quot;].\nos.insert(5, &quot;eeeee&quot;); // Inserts (5, &quot;eeeee&quot;), returns [].\nos.insert(4, &quot;ddddd&quot;); // Inserts (4, &quot;ddddd&quot;), returns [&quot;ddddd&quot;, &quot;eeeee&quot;].\n// Concatentating all the chunks returned:\n// [] + [&quot;aaaaa&quot;] + [&quot;bbbbb&quot;, &quot;ccccc&quot;] + [] + [&quot;ddddd&quot;, &quot;eeeee&quot;] = [&quot;aaaaa&quot;, &quot;bbbbb&quot;, &quot;ccccc&quot;, &quot;ddddd&quot;, &quot;eeeee&quot;]\n// The resulting order is the same as the order above.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= id &lt;= n</code></li>\n\t<li><code>value.length == 5</code></li>\n\t<li><code>value</code>&nbsp;consists only of lowercase letters.</li>\n\t<li>Each call to <code>insert</code>&nbsp;will have a unique <code>id.</code></li>\n\t<li>Exactly <code>n</code> calls will be made to <code>insert</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2380873,
                "title": "bad-problem-description",
                "content": "What is the problem asking for, the description and the example are so conflicting. English is my first language, I have never had any issues with understanding problems on LC. I am a premium user, please fix this.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 935933,
                "title": "java-straightforward-solution",
                "content": "Well, the problem statement is not very clear even there is a GIF, although I work it out. The problem statement makes it feel as a medium problem, I guess. \\n\\nBasically, the idea is that you need to return a longest list that start at index of ptr. if ptr is not pointing an element, you need to return a empty list.\\n```\\nclass OrderedStream {\\n    int ptr;\\n    String[] res;\\n    \\n    public OrderedStream(int n) {\\n        ptr = 0;\\n        res = new String[n];\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        List<String> list = new ArrayList<>();\\n        \\n        res[id - 1] = value;\\n        while (ptr < res.length && res[ptr] != null) {\\n            list.add(res[ptr]);\\n            ptr++;\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n    int ptr;\\n    String[] res;\\n    \\n    public OrderedStream(int n) {\\n        ptr = 0;\\n        res = new String[n];\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        List<String> list = new ArrayList<>();\\n        \\n        res[id - 1] = value;\\n        while (ptr < res.length && res[ptr] != null) {\\n            list.add(res[ptr]);\\n            ptr++;\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935945,
                "title": "python3-simple-solution",
                "content": "\\n```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.data = [None]*n\\n        self.ptr = 0 # 0-indexed \\n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        id -= 1 # 0-indexed \\n        self.data[id] = value \\n        if id > self.ptr: return [] # not reaching ptr \\n        \\n        while self.ptr < len(self.data) and self.data[self.ptr]: self.ptr += 1 # update self.ptr \\n        return self.data[id:self.ptr]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.data = [None]*n\\n        self.ptr = 0 # 0-indexed \\n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        id -= 1 # 0-indexed \\n        self.data[id] = value \\n        if id > self.ptr: return [] # not reaching ptr \\n        \\n        while self.ptr < len(self.data) and self.data[self.ptr]: self.ptr += 1 # update self.ptr \\n        return self.data[id:self.ptr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249014,
                "title": "question-explained-with-example-solution-in-java",
                "content": "There are \\'n\\' number of  (key, value) pair provided in random order. First, we need to sort the \"values\" into a String array, based on their respective \\'keys\\' as index of the array. The question asks us to return **longest possible contiguous subarray from the pointer position, during every iteration of insertion of value into the array.**\\n\\nLets say, n=5, and the (Key, Value) pairs are (3,\"c\") (1,\"a\") (2,\"b\") (5,\"e\") (4,\"d\"). \\nLets declare a pointer variable ptr=1;     (but while coding, you have to consider \\'zero based indexing\\' for the string array arr[ ]. So ptr=0; ) \\n\\nLets **declare an array** of Strings, arr[ ], of size \\'n\\'. (This is done in **public OrderedStream(int n)**)\\n\\nInitially the array is filled with null, ( *Bold part of the array is where ptr is pointing* )\\narr = | **null** | null | null | null | null |   (ptr=1)\\n\\n***Iteration 1 :*** (3,\"c\") is passed to  public List<String> insert(int idKey, String value), ptr is at position 1 of the array.\\n\\narr = | **null** | null | \"c\" | null | null |     =====> pointer is a null, so do nothing. return [ ]\\n\\n***Iteration 2:*** insert (1,\"a\")\\narr = | **\"a\"** | null | \"c\" | null | null |     =====> pointer is not a null,  chunk = \"a\" , so move the pointer ptr forward, check the next position arr[1] for a value.\\narr = | \"a\" | **null** | \"c\" | null | null |     =====> But, arr[1] is null, so \"a\" is the longest chunk of subarray that exists at this point of time. So, return chunk = [\"a\"] \\n\\n\\n***Iteration 3:*** insert (2,\"b\")\\narr = | \"a\" | **\"b\"** | \"c\" | null | null |  =====> pointer is not null, so, chunk = \"b\". Move the pointer to next position 3, \\narr = | \"a\" | \"b\" | **\"c\"** | null | null |  =====>pointer is not null, so add \"c\" to the chunk, chunk =\" b+ c\", move the pointer to 4, value at 4 is null. So return the chunk [\"b\",\"c\"]\\n\\n***Iteration 4:*** insert (5,\"e\")\\narr = | \"a\" | \"b\" | \"c\" | **null**  | \"e\" |                 =====>pointer is null, so do nothing. return [ ]\\n\\n***Iteration 5:*** insert (4,\"d\")\\narr = | \"a\" | \"b\" | \"c\" | **\"d\"** | \"e\" |       =====>pointer is not null, so chunk = \"d\", pointer moves to position 5.\\narr = | \"a\" | \"b\" | \"c\" | \"d\" | **\"e\"** |       =====>pointer is not null so chunk = \"d\" + \"e\" pointer moves to 6.\\n\\n6 is greater than length of array. So return chunk [\"d\" , \"e\" ] .\\n\\n\\n```class OrderedStream {\\n    public String stream[];\\n    public int ptr=0; \\n\\n    public OrderedStream(int n) {\\n        stream=new String[n];\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        stream[idKey-1]=value;\\n        List<String> chunk = new ArrayList<>();\\n        while(ptr < stream.length && stream[ptr]!=null)\\n        {\\n            chunk.add(stream[ptr]);\\n            ptr++;\\n        }\\n        return chunk;\\n    }\\n}\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class OrderedStream {\\n    public String stream[];\\n    public int ptr=0; \\n\\n    public OrderedStream(int n) {\\n        stream=new String[n];\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        stream[idKey-1]=value;\\n        List<String> chunk = new ArrayList<>();\\n        while(ptr < stream.length && stream[ptr]!=null)\\n        {\\n            chunk.add(stream[ptr]);\\n            ptr++;\\n        }\\n        return chunk;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336087,
                "title": "latest-python-solution-explained-for-newly-updated-description-faster-than-90",
                "content": "The idea behind this problem is simple but the description is confusing.\\nSo let me explain a bit.\\n\\nBasically , we need to store every incoming value at the given index. And \\nwith every incoming index, we have to check\\n\\n* If the current index is less than the incoming index, the we have to return\\n    an empty list\\n\\n* Else , we have to return an sliced list from the incoming index to the first index\\n    where there is no insertion till yet.\\n\\nSolution:\\n* Initialize a list of size n with None\\n* Maintain the current index with self.ptr\\n* For every insert call, with idKey, value \\n    * Assign the list[idKey-1] to the value # Since array is 0-index reduce 1\\n    * Check if the current index is less than incoming index(idKey-1) and return []\\n    * Else return sliced list from incoming index(idKey-1) till we do not encounter  None.\\n\\n\\n```\\nclass OrderedStream:\\n\\n    def __init__(self, n):\\n        self.stream = [None]*n\\n        self.ptr = 0\\n\\n    def insert(self, idKey, value):\\n        idKey -= 1\\n        self.stream[idKey] = value\\n        if self.ptr < idKey:\\n            return []\\n        else:\\n            while self.ptr < len(self.stream) and self.stream[self.ptr] is not None:\\n                self.ptr += 1\\n            return self.stream[idKey:self.ptr]\\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n):\\n        self.stream = [None]*n\\n        self.ptr = 0\\n\\n    def insert(self, idKey, value):\\n        idKey -= 1\\n        self.stream[idKey] = value\\n        if self.ptr < idKey:\\n            return []\\n        else:\\n            while self.ptr < len(self.stream) and self.stream[self.ptr] is not None:\\n                self.ptr += 1\\n            return self.stream[idKey:self.ptr]\\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666265,
                "title": "bloomberg-question-with-variation",
                "content": "I recently got this quesiton in a phone interview at Bloomberg with a minor variation. The variation was that you won\\'t be given **size** in advance. So, try to solve this question without using variable **n** in the constructor. Here is my implementation.\\n\\n```\\nclass OrderedStream {\\n    private Map<Integer, String> buffer;\\n    private int currentPointer;\\n    public OrderedStream(int n) {\\n        currentPointer = 1;\\n        buffer = new HashMap<>();\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        List<String> values = new ArrayList<>();\\n        if (idKey == currentPointer) {\\n            values.add(value);\\n            while (buffer.containsKey(++currentPointer))\\n                values.add(buffer.remove(currentPointer));\\n        } else\\n            buffer.put(idKey, value);\\n        return values;\\n    }\\n}\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream obj = new OrderedStream(n);\\n * List<String> param_1 = obj.insert(idKey,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n    private Map<Integer, String> buffer;\\n    private int currentPointer;\\n    public OrderedStream(int n) {\\n        currentPointer = 1;\\n        buffer = new HashMap<>();\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        List<String> values = new ArrayList<>();\\n        if (idKey == currentPointer) {\\n            values.add(value);\\n            while (buffer.containsKey(++currentPointer))\\n                values.add(buffer.remove(currentPointer));\\n        } else\\n            buffer.put(idKey, value);\\n        return values;\\n    }\\n}\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream obj = new OrderedStream(n);\\n * List<String> param_1 = obj.insert(idKey,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078564,
                "title": "javascript-elegant-solution-using-an-array-and-pointer-with-explanation",
                "content": "This is a rather simple problem, all we need to do is to store all the data that was passed to `insert()` function, return some data if the condition is true, and keep track of where we were last time.\\n\\nLook how clean this solution is:\\n```javascript\\nclass OrderedStream {\\n  constructor(n) {\\n    this.pointer = 0\\n    this.list = []\\n  }\\n\\n  insert(id, value) {\\n    let chunk = []\\n    this.list[id - 1] = value\\n    while(this.list[this.pointer]) {\\n      chunk.push(this.list[this.pointer])\\n      this.pointer++\\n    }\\n    return chunk\\n  }\\n}\\n```\\n\\nWith explanation:\\n```javascript\\nclass OrderedStream {\\n  // Define a construction function and set some values as object properties to keep our data persistent between invocations\\n  constructor(n) {\\n    this.pointer = 0\\n    // this will create an array of length (n) and set all values to \\'undefined\\'\\n    this.list = []\\n  }\\n\\n  insert(id, value) {\\n    // will be used to store values that pass the condition and to be returned\\n    let chunk = []\\n    // since array indices start from zero and id in this problem from 1 we need to decrement it\\n    this.list[id - 1] = value\\n    // every time we insert a value we have to look if there is a value at the index (pointer) that should be returned\\n    // if there is any we copy it and then iterate to the next element until the condition is no longer true\\n    while(this.list[this.pointer]) {\\n      chunk.push(this.list[this.pointer])\\n      this.pointer++\\n    }\\n    return chunk\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass OrderedStream {\\n  constructor(n) {\\n    this.pointer = 0\\n    this.list = []\\n  }\\n\\n  insert(id, value) {\\n    let chunk = []\\n    this.list[id - 1] = value\\n    while(this.list[this.pointer]) {\\n      chunk.push(this.list[this.pointer])\\n      this.pointer++\\n    }\\n    return chunk\\n  }\\n}\\n```\n```javascript\\nclass OrderedStream {\\n  // Define a construction function and set some values as object properties to keep our data persistent between invocations\\n  constructor(n) {\\n    this.pointer = 0\\n    // this will create an array of length (n) and set all values to \\'undefined\\'\\n    this.list = []\\n  }\\n\\n  insert(id, value) {\\n    // will be used to store values that pass the condition and to be returned\\n    let chunk = []\\n    // since array indices start from zero and id in this problem from 1 we need to decrement it\\n    this.list[id - 1] = value\\n    // every time we insert a value we have to look if there is a value at the index (pointer) that should be returned\\n    // if there is any we copy it and then iterate to the next element until the condition is no longer true\\n    while(this.list[this.pointer]) {\\n      chunk.push(this.list[this.pointer])\\n      this.pointer++\\n    }\\n    return chunk\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936090,
                "title": "c-array",
                "content": "```cpp\\nvector<string> s;\\nint ptr = 1;\\nOrderedStream(int n) : s(n + 1) {}\\nvector<string> insert(int id, string value) {\\n    s[id] = value;\\n    vector<string> res;\\n    while (ptr < s.size() && !s[ptr].empty())\\n        res.push_back(s[ptr++]);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<string> s;\\nint ptr = 1;\\nOrderedStream(int n) : s(n + 1) {}\\nvector<string> insert(int id, string value) {\\n    s[id] = value;\\n    vector<string> res;\\n    while (ptr < s.size() && !s[ptr].empty())\\n        res.push_back(s[ptr++]);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 937843,
                "title": "python-using-dict-212ms-14-6mb",
                "content": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.seen = {}\\n        self.ptr = 1\\n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        seen, ptr = self.seen, self.ptr\\n        \\n        seen[id] = value\\n        result = []\\n        while ptr in seen:\\n            result.append(seen[ptr])\\n            del seen[ptr]\\n            ptr += 1\\n        \\n        self.ptr = ptr\\n        return result\\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(id,value)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.seen = {}\\n        self.ptr = 1\\n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        seen, ptr = self.seen, self.ptr\\n        \\n        seen[id] = value\\n        result = []\\n        while ptr in seen:\\n            result.append(seen[ptr])\\n            del seen[ptr]\\n            ptr += 1\\n        \\n        self.ptr = ptr\\n        return result\\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(id,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935934,
                "title": "c-self-explainatory",
                "content": "```\\nclass OrderedStream {\\npublic:\\n    \\n    vector<string>res;\\n    int ptr;\\n    OrderedStream(int n) {\\n        res.resize(n);\\n        ptr = 1;\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        res[id-1] = value;\\n        vector<string> ans;\\n        \\n        if(ptr == id) {\\n            int i = ptr - 1;\\n            \\n            for(; i < res.size(); i++) {\\n                if(res[i] == \"\")\\n                    break;\\n                ans.push_back(res[i]);\\n            }\\n            ptr = i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    \\n    vector<string>res;\\n    int ptr;\\n    OrderedStream(int n) {\\n        res.resize(n);\\n        ptr = 1;\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        res[id-1] = value;\\n        vector<string> ans;\\n        \\n        if(ptr == id) {\\n            int i = ptr - 1;\\n            \\n            for(; i < res.size(); i++) {\\n                if(res[i] == \"\")\\n                    break;\\n                ans.push_back(res[i]);\\n            }\\n            ptr = i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938271,
                "title": "java-faster-than-100-understand-the-requirments-is-much-harder-than-problem-itself",
                "content": "```\\nclass OrderedStream {\\n    \\n    private String[] values;\\n    private int ptr;\\n\\n    public OrderedStream(int n) {\\n        values = new String[n];\\n        ptr = 0;\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        values[id - 1] = value;\\n\\n        List<String> result = new ArrayList();\\n        while (ptr < values.length && values[ptr] != null) {\\n            result.add(values[ptr++]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n    \\n    private String[] values;\\n    private int ptr;\\n\\n    public OrderedStream(int n) {\\n        values = new String[n];\\n        ptr = 0;\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        values[id - 1] = value;\\n\\n        List<String> result = new ArrayList();\\n        while (ptr < values.length && values[ptr] != null) {\\n            result.add(values[ptr++]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148962,
                "title": "python3-solution-better-description-because-this-one-is-really-bad",
                "content": "The description as of June 13th, 2022 mentions nothing a ptr. There is a ptr that should be initialized at 1. If an item is inserted with an idKey above the ptr, return nothing. If an item is inserted that matches the ptr, return the largest chunk of contiguous values above the ptr. The ptr should update to the index immediately after the returned chunk. \\n\\n```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.ptr = 1\\n        self.hashmap = dict()\\n        \\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.hashmap[idKey] = value\\n        output = []\\n        if idKey > self.ptr:\\n            return output\\n        \\n        while idKey in self.hashmap:\\n            output.append(self.hashmap[idKey])\\n            idKey += 1\\n            self.ptr = idKey\\n            \\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.ptr = 1\\n        self.hashmap = dict()\\n        \\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.hashmap[idKey] = value\\n        output = []\\n        if idKey > self.ptr:\\n            return output\\n        \\n        while idKey in self.hashmap:\\n            output.append(self.hashmap[idKey])\\n            idKey += 1\\n            self.ptr = idKey\\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759398,
                "title": "c-god-solution",
                "content": "**Map STL**\\n```\\nclass OrderedStream {\\npublic:\\n    map<int,string> mp;\\n    int maxSize = -1,currIndex = 1;\\n    \\n    OrderedStream(int n) {\\n        maxSize = n;\\n        for(int i=1;i<=n;i++) mp[i] = \"----\";\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string> res;\\n        mp[idKey] = value;\\n        int i =1;\\n        for(int i=currIndex;i<=maxSize;i++){\\n            if(mp[i] != \"----\"){\\n                res.push_back(mp[i]);\\n            }else{\\n                currIndex = i;\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```\\n<br>\\n<div> Happy coding </div>\\nPlease do upvote this post.\\n\\n![image](https://assets.leetcode.com/users/images/5ce11bf6-0db9-4239-bbb9-dfe5d76443f3_1666346629.9681695.gif)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    map<int,string> mp;\\n    int maxSize = -1,currIndex = 1;\\n    \\n    OrderedStream(int n) {\\n        maxSize = n;\\n        for(int i=1;i<=n;i++) mp[i] = \"----\";\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string> res;\\n        mp[idKey] = value;\\n        int i =1;\\n        for(int i=currIndex;i<=maxSize;i++){\\n            if(mp[i] != \"----\"){\\n                res.push_back(mp[i]);\\n            }else{\\n                currIndex = i;\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550059,
                "title": "c-easy-to-understand",
                "content": "```\\nclass OrderedStream {\\npublic:\\n    vector<string> stream;\\n    int i=0;\\n    OrderedStream(int n) \\n    {\\n        stream.resize(n);\\n        \\n    }\\n    \\n    vector<string> insert(int idKey, string value)\\n    {\\n        vector<string> res;\\n        stream[idKey-1]=value;\\n        while(i<stream.size()&&stream[i]!=\"\")\\n        {\\n            res.push_back(stream[i]);\\n            i++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    vector<string> stream;\\n    int i=0;\\n    OrderedStream(int n) \\n    {\\n        stream.resize(n);\\n        \\n    }\\n    \\n    vector<string> insert(int idKey, string value)\\n    {\\n        vector<string> res;\\n        stream[idKey-1]=value;\\n        while(i<stream.size()&&stream[i]!=\"\")\\n        {\\n            res.push_back(stream[i]);\\n            i++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "codeTag": "Java"
            },
            {
                "id": 2044809,
                "title": "super-clear-illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/71bcfb09-61a6-46cb-9c06-189364872183_1652705869.6314733.png)\\n\\n\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        \"\"\" O(N)S\"\"\"\\n        self.arr = [None] * (n + 1)\\n        self.ptr = 1\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.arr[idKey] = value\\n        while self.ptr < len(self.arr) and self.arr[self.ptr] is not None:\\n            self.ptr += 1\\n        return self.arr[idKey:self.ptr]",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/71bcfb09-61a6-46cb-9c06-189364872183_1652705869.6314733.png)\\n\\n\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        \"\"\" O(N)S\"\"\"\\n        self.arr = [None] * (n + 1)\\n        self.ptr = 1\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.arr[idKey] = value\\n        while self.ptr < len(self.arr) and self.arr[self.ptr] is not None:\\n            self.ptr += 1\\n        return self.arr[idKey:self.ptr]",
                "codeTag": "Java"
            },
            {
                "id": 943787,
                "title": "c-easiest-solutin",
                "content": "```\\nclass OrderedStream {\\npublic:\\n    vector<string> stream ; //to get input\\n    int i=0;\\n    OrderedStream(int n) {\\n        stream.resize(n); //change the size of the vector when orderedStream is called\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        vector<string> result;\\n        stream[id-1] = value; // value is stored in the ith position\\n        while(i<stream.size() && stream[i]!=\"\") //stream[i] !=\"\" because an entry is printed only if the entry before it is printed\\n        {\\n            result.push_back(stream[i]);\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(id,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    vector<string> stream ; //to get input\\n    int i=0;\\n    OrderedStream(int n) {\\n        stream.resize(n); //change the size of the vector when orderedStream is called\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        vector<string> result;\\n        stream[id-1] = value; // value is stored in the ith position\\n        while(i<stream.size() && stream[i]!=\"\") //stream[i] !=\"\" because an entry is printed only if the entry before it is printed\\n        {\\n            result.push_back(stream[i]);\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(id,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582389,
                "title": "easiest-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass OrderedStream {\\npublic:\\n\\n    string v[1000];\\n    int curr=0;\\n\\n    OrderedStream(int n) {\\n\\n\\n        \\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        v[idKey-1]=value;\\n        vector<string>ans;\\n        while(v[curr]!=\"\"){\\n            ans.push_back(v[curr]);\\n            curr++;\\n        }\\n        return ans;\\n\\n        \\n        \\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Design",
                    "Data Stream"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n\\n    string v[1000];\\n    int curr=0;\\n\\n    OrderedStream(int n) {\\n\\n\\n        \\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        v[idKey-1]=value;\\n        vector<string>ans;\\n        while(v[curr]!=\"\"){\\n            ans.push_back(v[curr]);\\n            curr++;\\n        }\\n        return ans;\\n\\n        \\n        \\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936157,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.val=[[] for i in range(n+1)]\\n        self.left=0\\n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.val[id-1]=value\\n        if self.left!=id-1:\\n            return []\\n        ans=[]\\n        while self.val[self.left]!=[]:\\n            ans.append(self.val[self.left])\\n            self.left+=1 \\n        return ans\\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(id,value)\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.val=[[] for i in range(n+1)]\\n        self.left=0\\n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.val[id-1]=value\\n        if self.left!=id-1:\\n            return []\\n        ans=[]\\n        while self.val[self.left]!=[]:\\n            ans.append(self.val[self.left])\\n            self.left+=1 \\n        return ans\\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(id,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505295,
                "title": "notmy-orderedstream",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass OrderedStream {\\n\\tconstructor(n) {\\n\\t\\tthis.pointer = 0;\\n\\t\\tthis.list = [];\\n\\t}\\n\\n\\tinsert(id, val) {\\n\\t\\tlet chunk = [];\\n\\t\\tthis.list[id - 1] = val;\\n\\t\\twhile (this.list[this.pointer]) {\\n\\t\\t\\tchunk.push(this.list[this.pointer]);\\n\\t\\t\\tthis.pointer++;\\n\\t\\t}\\n\\t\\treturn chunk;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass OrderedStream {\\n\\tconstructor(n) {\\n\\t\\tthis.pointer = 0;\\n\\t\\tthis.list = [];\\n\\t}\\n\\n\\tinsert(id, val) {\\n\\t\\tlet chunk = [];\\n\\t\\tthis.list[id - 1] = val;\\n\\t\\twhile (this.list[this.pointer]) {\\n\\t\\t\\tchunk.push(this.list[this.pointer]);\\n\\t\\t\\tthis.pointer++;\\n\\t\\t}\\n\\t\\treturn chunk;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680900,
                "title": "c-easy-solution-clean-code",
                "content": "```\\nclass OrderedStream {\\npublic:\\n    int pointer = 0;\\n    vector<string>stream;\\n    \\n    OrderedStream(int n) {\\n        stream.resize(n);\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string>ans;\\n        \\n        stream[idKey-1] = value;\\n        \\n        while(pointer<stream.size() and stream[pointer] != \"\"){\\n            ans.push_back(stream[pointer]);\\n            pointer++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    int pointer = 0;\\n    vector<string>stream;\\n    \\n    OrderedStream(int n) {\\n        stream.resize(n);\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string>ans;\\n        \\n        stream[idKey-1] = value;\\n        \\n        while(pointer<stream.size() and stream[pointer] != \"\"){\\n            ans.push_back(stream[pointer]);\\n            pointer++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414348,
                "title": "javascript-simple-array-solution-98-faster-27-less-memory",
                "content": "I didn\\'t use a hash table, I just initialized an array with a pointer and when the pointer had data I push it into a result array and returned the result array. See below:\\n```\\n/**\\n * @param {number} n\\n */\\nvar OrderedStream = function(n) {\\n  // initialize array\\n  this.arr = [];\\n  // start pointer at index of 0\\n  this.p = 0;\\n  //set array to have length of n\\n  this.arr.length = n;\\n};\\n\\n/** \\n * @param {number} idKey \\n * @param {string} value\\n * @return {string[]}\\n */\\nOrderedStream.prototype.insert = function(idKey, value) {\\n  // push the value into array at index of idKey\\n  this.arr[idKey - 1] = value;\\n  // initialize result array\\n  let result = [];\\n  \\n  // while the pointer has a value, push that value into the result array and advance the pointer\\n  while (this.arr[this.p]) {\\n    result.push(this.arr[this.p]);\\n    this.p++;\\n  }\\n  // return the result array which will either be empty if the pointer was null, or will have the chunks pushed into it\\n  return result;\\n};\\n\\n/** \\n * Your OrderedStream object will be instantiated and called as such:\\n * var obj = new OrderedStream(n)\\n * var param_1 = obj.insert(idKey,value)\\n */\\n ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n */\\nvar OrderedStream = function(n) {\\n  // initialize array\\n  this.arr = [];\\n  // start pointer at index of 0\\n  this.p = 0;\\n  //set array to have length of n\\n  this.arr.length = n;\\n};\\n\\n/** \\n * @param {number} idKey \\n * @param {string} value\\n * @return {string[]}\\n */\\nOrderedStream.prototype.insert = function(idKey, value) {\\n  // push the value into array at index of idKey\\n  this.arr[idKey - 1] = value;\\n  // initialize result array\\n  let result = [];\\n  \\n  // while the pointer has a value, push that value into the result array and advance the pointer\\n  while (this.arr[this.p]) {\\n    result.push(this.arr[this.p]);\\n    this.p++;\\n  }\\n  // return the result array which will either be empty if the pointer was null, or will have the chunks pushed into it\\n  return result;\\n};\\n\\n/** \\n * Your OrderedStream object will be instantiated and called as such:\\n * var obj = new OrderedStream(n)\\n * var param_1 = obj.insert(idKey,value)\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1397388,
                "title": "bad-description-c-solved-using-animation-in-example",
                "content": "```\\nclass OrderedStream {\\npublic:\\n    vector<string> vec;\\n    int n, pointer;\\n    OrderedStream(int n) {\\n        vec.resize(n+1, \"\");\\n        this->n       = n;\\n        this->pointer = 1;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string> result;\\n        vec[idKey] = value;\\n        if(idKey == pointer) {\\n            while(pointer <= n && vec[pointer] != \"\") {\\n                result.push_back(vec[pointer]);\\n                pointer++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    vector<string> vec;\\n    int n, pointer;\\n    OrderedStream(int n) {\\n        vec.resize(n+1, \"\");\\n        this->n       = n;\\n        this->pointer = 1;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string> result;\\n        vec[idKey] = value;\\n        if(idKey == pointer) {\\n            while(pointer <= n && vec[pointer] != \"\") {\\n                result.push_back(vec[pointer]);\\n                pointer++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160489,
                "title": "c-solution-with-explanation",
                "content": "```\\nclass OrderedStream {\\nprivate:\\n    std::vector<string> stream;\\n    int readIdx;\\n    \\npublic:\\n    OrderedStream(int n) {\\n        // resize the vector stream\\n        stream.resize(n);\\n        // Initialize the readIdx to starting point\\n        readIdx = 0;        \\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        // Insert the value at specified index\\n        stream[idKey-1] = value;\\n               \\n        // Current string at readidx is filled, need to return\\n        // the longest possible chunk. Loop all the values of\\n        // the stream starting from read idx and append it to\\n        // result only if it is not empty or reaches an index\\n        // where the string is empty\\n        int start = readIdx;\\n        while(readIdx < stream.size() && !stream[readIdx].empty()) {\\n            // String is inserted at this read Idx, increament the\\n            // readIdx and numelem\\n            readIdx++;\\n        }\\n        \\n        return vector<string>(stream.begin()+start, stream.begin()+readIdx);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\nprivate:\\n    std::vector<string> stream;\\n    int readIdx;\\n    \\npublic:\\n    OrderedStream(int n) {\\n        // resize the vector stream\\n        stream.resize(n);\\n        // Initialize the readIdx to starting point\\n        readIdx = 0;        \\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        // Insert the value at specified index\\n        stream[idKey-1] = value;\\n               \\n        // Current string at readidx is filled, need to return\\n        // the longest possible chunk. Loop all the values of\\n        // the stream starting from read idx and append it to\\n        // result only if it is not empty or reaches an index\\n        // where the string is empty\\n        int start = readIdx;\\n        while(readIdx < stream.size() && !stream[readIdx].empty()) {\\n            // String is inserted at this read Idx, increament the\\n            // readIdx and numelem\\n            readIdx++;\\n        }\\n        \\n        return vector<string>(stream.begin()+start, stream.begin()+readIdx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109931,
                "title": "c-solution-bloomberg-high-frequency-problem",
                "content": "This is the Bloomberg High Frequency Problem. They asked the same question wrapping it as printing package of a UDP process. \\n\\n```\\nclass OrderedStream {\\nprivate:\\n    int id = 1; \\n    \\n    unordered_map<int, string> m;\\npublic:\\n    OrderedStream(int n) {\\n        \\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        m[idKey] = value; vector<string> res;\\n        \\n        while (m.find(id) != m.end()) {\\n            res.emplace_back(m[id]); id++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\nprivate:\\n    int id = 1; \\n    \\n    unordered_map<int, string> m;\\npublic:\\n    OrderedStream(int n) {\\n        \\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        m[idKey] = value; vector<string> res;\\n        \\n        while (m.find(id) != m.end()) {\\n            res.emplace_back(m[id]); id++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941816,
                "title": "golang-solution",
                "content": "```\\ntype OrderedStream struct {\\n    ptr int\\n    list []string\\n}\\n\\nfunc Constructor(n int) OrderedStream {\\n    return OrderedStream{0,make([]string,n)}\\n}\\n\\n\\nfunc (this *OrderedStream) Insert(id int, value string) []string {\\n    this.list[id-1] = value\\n    if this.list[this.ptr] == \"\" {\\n        return []string{}\\n    } else {\\n        for i,v := range this.list[this.ptr:]{\\n            if v == \"\" {\\n                temp := this.ptr\\n                this.ptr += i\\n                return this.list[temp:this.ptr]\\n            }\\n        }\\n    }\\n    return this.list[this.ptr:]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype OrderedStream struct {\\n    ptr int\\n    list []string\\n}\\n\\nfunc Constructor(n int) OrderedStream {\\n    return OrderedStream{0,make([]string,n)}\\n}\\n\\n\\nfunc (this *OrderedStream) Insert(id int, value string) []string {\\n    this.list[id-1] = value\\n    if this.list[this.ptr] == \"\" {\\n        return []string{}\\n    } else {\\n        for i,v := range this.list[this.ptr:]{\\n            if v == \"\" {\\n                temp := this.ptr\\n                this.ptr += i\\n                return this.list[temp:this.ptr]\\n            }\\n        }\\n    }\\n    return this.list[this.ptr:]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493026,
                "title": "c-solution-hashmaps-arrays",
                "content": "\\n## MAPS\\n```\\nclass OrderedStream {\\npublic:\\n    map<int,string> mp;\\n    int count=1;\\n    OrderedStream(int n) {\\n        count=1;\\n    }\\n    vector<string> insert(int idKey, string value) {\\n        mp.insert({idKey,value});\\n        vector<string> ans;\\n        for (auto vl: mp){\\n            if (vl.first==count){\\n                count++;\\n                ans.push_back(vl.second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```\\n\\n## ARRAYS\\n```\\nclass OrderedStream {\\npublic:\\n    string arr[1005];\\n    int count=1; int n;\\n    OrderedStream(int n) {\\n        count=1;\\n        for (int i=1; i<=n; i++)arr[i]=\"NULLSTRING\";\\n        this->n= n;\\n    }\\n    vector<string> insert(int idKey, string value) {\\n        arr[idKey]= value;\\n        vector<string> ans;\\n        while (count<=n && arr[count]!= \"NULLSTRING\"){\\n            ans.push_back(arr[count]);\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Design",
                    "Data Stream"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    map<int,string> mp;\\n    int count=1;\\n    OrderedStream(int n) {\\n        count=1;\\n    }\\n    vector<string> insert(int idKey, string value) {\\n        mp.insert({idKey,value});\\n        vector<string> ans;\\n        for (auto vl: mp){\\n            if (vl.first==count){\\n                count++;\\n                ans.push_back(vl.second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```\n```\\nclass OrderedStream {\\npublic:\\n    string arr[1005];\\n    int count=1; int n;\\n    OrderedStream(int n) {\\n        count=1;\\n        for (int i=1; i<=n; i++)arr[i]=\"NULLSTRING\";\\n        this->n= n;\\n    }\\n    vector<string> insert(int idKey, string value) {\\n        arr[idKey]= value;\\n        vector<string> ans;\\n        while (count<=n && arr[count]!= \"NULLSTRING\"){\\n            ans.push_back(arr[count]);\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211182,
                "title": "java-o-n-explanation-and-code-with-comments",
                "content": "Even though the description may not be entirely clear, paying close attention to the attached GIF will help.\\n\\n1) A pointer starts at 0-th position (0-based)\\n2) String data is inserted at K-th position (idKey minus 1)\\n3) Try to move pointer all the way to right if locations are filled\\n\\n```\\nclass OrderedStream {\\n    String[] values; //For index-wise data insertion\\n    int ptr = 0; //Starting position of pointer\\n    \\n    public OrderedStream(int n) {\\n        values = new String[n];\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        List<String> output = new ArrayList();\\n        values[idKey - 1] = value;\\n\\t\\t//While values[ptr] is filled, forward ptr\\n        while (ptr < values.length && values[ptr] != null) {\\n            output.add(values[ptr++]);\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n    String[] values; //For index-wise data insertion\\n    int ptr = 0; //Starting position of pointer\\n    \\n    public OrderedStream(int n) {\\n        values = new String[n];\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        List<String> output = new ArrayList();\\n        values[idKey - 1] = value;\\n\\t\\t//While values[ptr] is filled, forward ptr\\n        while (ptr < values.length && values[ptr] != null) {\\n            output.add(values[ptr++]);\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614963,
                "title": "python-holding-last-min-index",
                "content": "```\\nclass OrderedStream(object):\\n\\n    def __init__(self, n):\\n        \"\"\"\\n        :type n: int\\n        \"\"\"\\n        self.values = [None] * n\\n        self.returned_min = 0\\n        \\n\\n    def insert(self, idKey, value):\\n        \"\"\"\\n        :type idKey: int\\n        :type value: str\\n        :rtype: List[str]\\n        \"\"\"\\n        self.values[idKey-1] = value\\n        \\n        ret = []\\n\\t\\t# Value not None and index in boundary of values array size\\n        while self.returned_min < len(self.values) and self.values[self.returned_min]:\\n            ret.append(self.values[self.returned_min])\\n\\t\\t\\t# Holding last min index returned\\n            self.returned_min += 1\\n        \\n        return ret\\n        \\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```\\n\\nThe idea is that None value holes are skipped until filled, min boundary of the last returned non-None value is kept in `returned_min`  variable",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass OrderedStream(object):\\n\\n    def __init__(self, n):\\n        \"\"\"\\n        :type n: int\\n        \"\"\"\\n        self.values = [None] * n\\n        self.returned_min = 0\\n        \\n\\n    def insert(self, idKey, value):\\n        \"\"\"\\n        :type idKey: int\\n        :type value: str\\n        :rtype: List[str]\\n        \"\"\"\\n        self.values[idKey-1] = value\\n        \\n        ret = []\\n\\t\\t# Value not None and index in boundary of values array size\\n        while self.returned_min < len(self.values) and self.values[self.returned_min]:\\n            ret.append(self.values[self.returned_min])\\n\\t\\t\\t# Holding last min index returned\\n            self.returned_min += 1\\n        \\n        return ret\\n        \\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453235,
                "title": "javascript-easy-solution",
                "content": "```\\n/**\\n * @param {number} n\\n */\\nvar OrderedStream = function(n) {\\n    arr = new Array(n);\\n    plt = 0;\\n};\\n\\n/** \\n * @param {number} idKey \\n * @param {string} value\\n * @return {string[]}\\n */\\nOrderedStream.prototype.insert = function(idKey, value) {\\n    arr[idKey-1] = value;\\n    let tempArr = [];\\n    for(let i = plt; i < arr.length;i++){\\n        if(typeof arr[i] != \"undefined\"){\\n            tempArr.push(arr[i]);\\n            plt++;\\n        }else{\\n            break;\\n        }\\n            \\n    }\\n    return tempArr;\\n};\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n */\\nvar OrderedStream = function(n) {\\n    arr = new Array(n);\\n    plt = 0;\\n};\\n\\n/** \\n * @param {number} idKey \\n * @param {string} value\\n * @return {string[]}\\n */\\nOrderedStream.prototype.insert = function(idKey, value) {\\n    arr[idKey-1] = value;\\n    let tempArr = [];\\n    for(let i = plt; i < arr.length;i++){\\n        if(typeof arr[i] != \"undefined\"){\\n            tempArr.push(arr[i]);\\n            plt++;\\n        }else{\\n            break;\\n        }\\n            \\n    }\\n    return tempArr;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1189344,
                "title": "java-5-lines-solution",
                "content": "```\\nprivate String[] values;\\nprivate int i = 0;\\n\\npublic OrderedStream(int n) {\\n\\tvalues = new String[n];\\n}\\n\\npublic List<String> insert(int idKey, String value) {\\n\\t// Below 5 lines do the magic\\n\\tvalues[idKey - 1] = value;   \\n\\tList<String> res = new ArrayList<>();\\n\\twhile (i < values.length && values[i] != null) {\\n\\t\\tres.add(values[i]);\\n\\t\\ti++;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate String[] values;\\nprivate int i = 0;\\n\\npublic OrderedStream(int n) {\\n\\tvalues = new String[n];\\n}\\n\\npublic List<String> insert(int idKey, String value) {\\n\\t// Below 5 lines do the magic\\n\\tvalues[idKey - 1] = value;   \\n\\tList<String> res = new ArrayList<>();\\n\\twhile (i < values.length && values[i] != null) {\\n\\t\\tres.add(values[i]);\\n\\t\\ti++;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1087474,
                "title": "simple-solution-in-java",
                "content": "```\\nclass OrderedStream {\\n    private String[] s;\\n    private int next;\\n    public OrderedStream(int n) {\\n        s=new String[n+1];\\n        next=1;\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        s[id]=value;\\n        List<String> tmp=new ArrayList<>();\\n        if(id==next){\\n            while(next<s.length && s[next]!=null){\\n                tmp.add(s[next++]);\\n            }\\n                \\n        }\\n        return tmp;\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\n    private String[] s;\\n    private int next;\\n    public OrderedStream(int n) {\\n        s=new String[n+1];\\n        next=1;\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        s[id]=value;\\n        List<String> tmp=new ArrayList<>();\\n        if(id==next){\\n            while(next<s.length && s[next]!=null){\\n                tmp.add(s[next++]);\\n            }\\n                \\n        }\\n        return tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954502,
                "title": "python-solution-easy-and-straight-forward",
                "content": "```\\nclass OrderedStream:\\n    def __init__(self, n: int):\\n        self.stream = [None]*(n+1)\\n        self.temp = 1\\n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.stream[id] = value\\n        ans = []\\n        while self.temp < len(self.stream) and self.stream[self.temp]:\\n            ans.append(self.stream[self.temp])\\n            self.temp += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass OrderedStream:\\n    def __init__(self, n: int):\\n        self.stream = [None]*(n+1)\\n        self.temp = 1\\n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.stream[id] = value\\n        ans = []\\n        while self.temp < len(self.stream) and self.stream[self.temp]:\\n            ans.append(self.stream[self.temp])\\n            self.temp += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935959,
                "title": "c-store-id-value-in-simple-array-main-part-is-understanding-question",
                "content": "```csharp\\npublic class OrderedStream\\n{\\n    string[] ordered;\\n    int ptr;\\n\\n    public OrderedStream(int n)\\n    {\\n        ordered = new string[n + 1];\\n        ptr = 1;\\n    }\\n\\n    public IList<string> Insert(int id, string value)\\n    {\\n        ordered[id] = value;\\n        List<string> result = new List<string>();\\n\\n        int i = id;\\n\\n        if (ptr == id)\\n        {                    \\n            for (; i < ordered.Length; i++)\\n            {\\n                if (ordered[i] != null)\\n                {\\n                    result.Add(ordered[i]);\\n                }\\n\\n                else\\n                {\\n                    break;\\n                }\\n            }                    \\n            \\n            ptr = i;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class OrderedStream\\n{\\n    string[] ordered;\\n    int ptr;\\n\\n    public OrderedStream(int n)\\n    {\\n        ordered = new string[n + 1];\\n        ptr = 1;\\n    }\\n\\n    public IList<string> Insert(int id, string value)\\n    {\\n        ordered[id] = value;\\n        List<string> result = new List<string>();\\n\\n        int i = id;\\n\\n        if (ptr == id)\\n        {                    \\n            for (; i < ordered.Length; i++)\\n            {\\n                if (ordered[i] != null)\\n                {\\n                    result.Add(ordered[i]);\\n                }\\n\\n                else\\n                {\\n                    break;\\n                }\\n            }                    \\n            \\n            ptr = i;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962763,
                "title": "python-solution-with-a-hint-before-the-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf you don\\'t want to go through my code, I suggest you to watch the example video and observe the \"ptr\" and how it is incrementing and returning things based on the ptr value.\\n\\n# Code\\n```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.arr = [\"\"] * n\\n        self.ptr = 0\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.arr[idKey-1] = value\\n        res = []\\n        if self.ptr == idKey - 1:\\n            while self.ptr < len(self.arr) and self.arr[self.ptr] != \"\":\\n                print(self.ptr)\\n                res.append(self.arr[self.ptr])\\n                self.ptr += 1\\n\\n        return res\\n\\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.arr = [\"\"] * n\\n        self.ptr = 0\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.arr[idKey-1] = value\\n        res = []\\n        if self.ptr == idKey - 1:\\n            while self.ptr < len(self.arr) and self.arr[self.ptr] != \"\":\\n                print(self.ptr)\\n                res.append(self.arr[self.ptr])\\n                self.ptr += 1\\n\\n        return res\\n\\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686499,
                "title": "python-easy-solution",
                "content": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.arr = [-1] * (n + 1)\\n        self.n = n\\n        self.ptr = 1\\n\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        ans = []\\n        self.arr[idKey] = value\\n        \\n        while self.ptr <= self.n and self.arr[self.ptr] != -1:\\n            ans.append(self.arr[self.ptr])\\n            self.ptr += 1\\n        \\n        return ans\\n        \\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.arr = [-1] * (n + 1)\\n        self.n = n\\n        self.ptr = 1\\n\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        ans = []\\n        self.arr[idKey] = value\\n        \\n        while self.ptr <= self.n and self.arr[self.ptr] != -1:\\n            ans.append(self.arr[self.ptr])\\n            self.ptr += 1\\n        \\n        return ans\\n        \\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628132,
                "title": "c-solution-with-explanation",
                "content": "OG solution: https://leetcode.com/problems/design-an-ordered-stream/discuss/936090/C%2B%2B-Array\\nFirst create a vector that will store the strings in the stream and over which we will iterate. Resize it to n+1 because the idKey will start from 1 and not 0.\\nIn the insert function, assign the value to appropriate idKey and check if the ptr is less than the stream size (because in the next step we are indexing into s to check if the value is empty at that index. Once checked that we have value, add that to return vector and go ahead, until we have some value at those indexes. \\n```\\nclass OrderedStream {\\npublic:\\n    int ptr = 1;\\n    vector<string> s;\\n    OrderedStream(int n) {\\n        s.resize(n+1);\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string> ret;\\n        s[idKey] = value;\\n        while(ptr<s.size() && !s[ptr].empty())\\n            ret.push_back(s[ptr++]);\\n        return ret;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n ```\\n Time complexity: O(N)\\n Space complexity: O(N)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    int ptr = 1;\\n    vector<string> s;\\n    OrderedStream(int n) {\\n        s.resize(n+1);\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string> ret;\\n        s[idKey] = value;\\n        while(ptr<s.size() && !s[ptr].empty())\\n            ret.push_back(s[ptr++]);\\n        return ret;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2479401,
                "title": "c-string-array-easy-solution",
                "content": "```\\nclass OrderedStream {\\npublic:\\n    string dp[1005];\\n    int ptr;\\n    OrderedStream(int n){\\n        ptr = 1;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n     dp[idKey] = value;\\n        if(dp[ptr] != \"\"){\\n            vector<string> ans;\\n            for(int i=ptr;i<=1005;i++){\\n                if(dp[i] != \"\"){\\n                    ans.push_back(dp[i]);\\n                    ptr = i+1;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            return ans;\\n        }\\n        return {};\\n    }\\n};\\n\\n```\\n```\\nPlease upvote if it was helpful for you, thank you!\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    string dp[1005];\\n    int ptr;\\n    OrderedStream(int n){\\n        ptr = 1;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n     dp[idKey] = value;\\n        if(dp[ptr] != \"\"){\\n            vector<string> ans;\\n            for(int i=ptr;i<=1005;i++){\\n                if(dp[i] != \"\"){\\n                    ans.push_back(dp[i]);\\n                    ptr = i+1;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            return ans;\\n        }\\n        return {};\\n    }\\n};\\n\\n```\n```\\nPlease upvote if it was helpful for you, thank you!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312111,
                "title": "java-well-formatted-solution",
                "content": "The basic idea is to have a pointer and an array of strings and move the pointer with each insert if required.\\nSpace: O(n), Time: O(n)\\n\\n```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass OrderedStream {\\n    String[] stream;\\n    int ptr = 0;\\n\\n    public OrderedStream(int n) {\\n        this.stream = new String[n];\\n    }\\n\\n    public List<String> insert(int idKey, String value) {\\n        stream[idKey - 1] = value;\\n\\n        List<String> result = new ArrayList<>();\\n        for (int i = ptr; i < stream.length; i++) {\\n            String element = this.stream[i];\\n\\n            if (element == null) {\\n                break;\\n            }\\n            result.add(element);\\n            ptr++;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass OrderedStream {\\n    String[] stream;\\n    int ptr = 0;\\n\\n    public OrderedStream(int n) {\\n        this.stream = new String[n];\\n    }\\n\\n    public List<String> insert(int idKey, String value) {\\n        stream[idKey - 1] = value;\\n\\n        List<String> result = new ArrayList<>();\\n        for (int i = ptr; i < stream.length; i++) {\\n            String element = this.stream[i];\\n\\n            if (element == null) {\\n                break;\\n            }\\n            result.add(element);\\n            ptr++;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145790,
                "title": "python-3-simple-solution",
                "content": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.stream = [\\'\\'] * (n + 1)\\n        self.i = 0\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.stream[idKey - 1] = value\\n        res = []\\n\\n        while self.stream[self.i]:\\n            res.append(self.stream[self.i])\\n            self.i += 1\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.stream = [\\'\\'] * (n + 1)\\n        self.i = 0\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.stream[idKey - 1] = value\\n        res = []\\n\\n        while self.stream[self.i]:\\n            res.append(self.stream[self.i])\\n            self.i += 1\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1994366,
                "title": "python-commented-beats-90-iteration-codesplitting",
                "content": "class OrderedStream:\\n\\n    def __init__(self, n: int):\\n      self.arr = [None]*n # initialize the array for size n\\n      self.ptr = 0 # remeber where the stream pointer is at\\n    def get_chunk(self):\\n      chunk = []\\n      \\n      # Construct the next chunk by checking bounds, and ensuring value is not None\\n      while self.ptr < len(self.arr) and self.arr[self.ptr]:\\n        chunk.append(self.arr[self.ptr])\\n        self.ptr+=1 # Update the pointer\\n      return chunk\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n      # set the arr\\'s 0-indexed value to the incoming value\\n      self.arr[idKey-1] = value\\n      return self.get_chunk() # then return the chunk",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class OrderedStream:\\n\\n    def __init__(self, n: int):\\n      self.arr = [None]*n # initialize the array for size n\\n      self.ptr = 0 # remeber where the stream pointer is at\\n    def get_chunk(self):\\n      chunk = []\\n      \\n      # Construct the next chunk by checking bounds, and ensuring value is not None\\n      while self.ptr < len(self.arr) and self.arr[self.ptr]:\\n        chunk.append(self.arr[self.ptr])\\n        self.ptr+=1 # Update the pointer\\n      return chunk\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n      # set the arr\\'s 0-indexed value to the incoming value\\n      self.arr[idKey-1] = value\\n      return self.get_chunk() # then return the chunk",
                "codeTag": "Java"
            },
            {
                "id": 1976047,
                "title": "easy-typescript-solution",
                "content": "```\\nclass OrderedStream {\\n    stream: string[]\\n    index: number;\\n    constructor(n: number) {\\n        this.stream = []\\n        this.index = 0;\\n    }\\n\\n    insert(idKey: number, value: string): string[] {\\n        this.stream[idKey-1] = value;\\n        \\n        if(this.index === idKey-1) {\\n            while(this.stream[this.index]) {\\n                this.index++;\\n            }\\n        }\\n        return this.stream.slice(idKey-1,this.index);\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass OrderedStream {\\n    stream: string[]\\n    index: number;\\n    constructor(n: number) {\\n        this.stream = []\\n        this.index = 0;\\n    }\\n\\n    insert(idKey: number, value: string): string[] {\\n        this.stream[idKey-1] = value;\\n        \\n        if(this.index === idKey-1) {\\n            while(this.stream[this.index]) {\\n                this.index++;\\n            }\\n        }\\n        return this.stream.slice(idKey-1,this.index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948382,
                "title": "java-okay-sweetie-i-know-you-think-you-re-explaining-yourself-but-you-re-really-not",
                "content": "While I am reading the description, the voice of Penny from BIG BANG THEORY pop out.\\n\\n****Penny: Okay, sweetie, I know you think you\\u2019re explaining yourself, but you\\u2019re really not.****\\n\\n```\\nclass OrderedStream {\\n    String values[];\\n    int top=0;\\n    public OrderedStream(int n) {\\n        this.values=new String[n+1];\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        LinkedList<String> res=new LinkedList();\\n        values[idKey]=value;        \\n        for(int i=top+1;i<=idKey;i++){\\n            if(values[i]==null){\\n                break;\\n            }\\n            top=i;\\n        }\\n        if(top<idKey){\\n            return res;\\n        }\\n        for(int i=idKey;i<values.length;i++){\\n            if(values[i]!=null){\\n                top=i;\\n                res.add(values[i]);\\n            }else{\\n                return res;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n    String values[];\\n    int top=0;\\n    public OrderedStream(int n) {\\n        this.values=new String[n+1];\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        LinkedList<String> res=new LinkedList();\\n        values[idKey]=value;        \\n        for(int i=top+1;i<=idKey;i++){\\n            if(values[i]==null){\\n                break;\\n            }\\n            top=i;\\n        }\\n        if(top<idKey){\\n            return res;\\n        }\\n        for(int i=idKey;i<values.length;i++){\\n            if(values[i]!=null){\\n                top=i;\\n                res.add(values[i]);\\n            }else{\\n                return res;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768985,
                "title": "2-easy-to-understand-and-simple-python3-solutions-using-list-and-dictionary",
                "content": "**Method 1 - using List**\\n\\n```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.val = [0]*n\\n        self.cur = 0\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.val[idKey-1] = value\\n        ans = []\\n        for i in range(self.cur,self.n):\\n            if self.val[i] == 0:\\n                self.cur = i\\n                return ans\\n            ans.append(self.val[i])\\n        return ans\\n            \\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```\\n\\nRuntime - 477ms\\nMemory Usage - 14.7mb\\n\\n**Method 2 - using Dictionary**\\n\\n```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.d = {}\\n        self.cur = 1\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.d[idKey] = value\\n        ans = []\\n        for i in range(self.cur,self.n+1):\\n            if i not in self.d:\\n                self.cur = i\\n                return ans\\n            ans.append(self.d[i])\\n        return ans\\n            \\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```\\n\\nRuntime - 228ms\\nMemory Usage - 14.7mb\\n\\nFor solutions to other LeetCode problems that I have solved, you can check my github repository :\\nhttps://github.com/harshitpoddar09/LeetCode-Solutions\\n\\nPlease upvote if you found this useful so that others can get help as well!\\n",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.val = [0]*n\\n        self.cur = 0\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.val[idKey-1] = value\\n        ans = []\\n        for i in range(self.cur,self.n):\\n            if self.val[i] == 0:\\n                self.cur = i\\n                return ans\\n            ans.append(self.val[i])\\n        return ans\\n            \\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```\n```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.d = {}\\n        self.cur = 1\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.d[idKey] = value\\n        ans = []\\n        for i in range(self.cur,self.n+1):\\n            if i not in self.d:\\n                self.cur = i\\n                return ans\\n            ans.append(self.d[i])\\n        return ans\\n            \\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698147,
                "title": "js-o-n-solution-using-hashmap",
                "content": "```\\nclass OrderedStream {\\n    constructor(n) {\\n        this.map = new Map();\\n        this.key = 1;\\n    }\\n    insert(idKey, value) {\\n        this.map.set(idKey, value);\\t\\t// add the key-value to the map\\n        const result = [];\\n\\t\\t// until able to find the key in the map, add it to the resultant chunk\\n\\t\\t// each time the next greater key is found, it will start the result from that key value\\n        while(this.map.has(this.key)) { // O(n)\\n            result.push(this.map.get(this.key));\\n            ++this.key;\\n        }\\n        return result;\\n    }\\n}\\n```\\nTime Complexity = O(n)\\nSpace Complexity = O(n)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass OrderedStream {\\n    constructor(n) {\\n        this.map = new Map();\\n        this.key = 1;\\n    }\\n    insert(idKey, value) {\\n        this.map.set(idKey, value);\\t\\t// add the key-value to the map\\n        const result = [];\\n\\t\\t// until able to find the key in the map, add it to the resultant chunk\\n\\t\\t// each time the next greater key is found, it will start the result from that key value\\n        while(this.map.has(this.key)) { // O(n)\\n            result.push(this.map.get(this.key));\\n            ++this.key;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681947,
                "title": "java-solution",
                "content": "```\\nclass OrderedStream {\\n    String[] arr;\\n    int ptr;\\n    public OrderedStream(int n) {\\n        arr = new String[n];\\n        ptr = 0;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        arr[idKey-1] = value;\\n        List<String> list = new ArrayList<>();\\n        while(ptr < arr.length && arr[ptr] != null){\\n            list.add(arr[ptr++]);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n    String[] arr;\\n    int ptr;\\n    public OrderedStream(int n) {\\n        arr = new String[n];\\n        ptr = 0;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        arr[idKey-1] = value;\\n        List<String> list = new ArrayList<>();\\n        while(ptr < arr.length && arr[ptr] != null){\\n            list.add(arr[ptr++]);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462681,
                "title": "simplest-solution-c",
                "content": "```\\nclass OrderedStream {\\npublic:\\n    vector<string> temporary;\\n    int currentPosition = 0;\\n    \\n    OrderedStream(int n) {\\n        temporary.resize(n);\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string> answer;\\n        temporary[ idKey - 1 ] = value;\\n        \\n        while( currentPosition < temporary.size() && temporary[currentPosition] != \"\") {\\n            answer.push_back(temporary[currentPosition]);\\n            currentPosition++;\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    vector<string> temporary;\\n    int currentPosition = 0;\\n    \\n    OrderedStream(int n) {\\n        temporary.resize(n);\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string> answer;\\n        temporary[ idKey - 1 ] = value;\\n        \\n        while( currentPosition < temporary.size() && temporary[currentPosition] != \"\") {\\n            answer.push_back(temporary[currentPosition]);\\n            currentPosition++;\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387887,
                "title": "java-solution",
                "content": "```\\nclass OrderedStream {\\n    \\n    private int lo = 1;\\n    private String[] vals;\\n\\n    public OrderedStream(int n) {\\n        vals = new String[n+1];\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        vals[idKey] = value;\\n        \\n        var retList = new ArrayList<String>();\\n        while (lo < vals.length && vals[lo] != null) {\\n            retList.add(vals[lo++]);\\n        }\\n        return retList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n    \\n    private int lo = 1;\\n    private String[] vals;\\n\\n    public OrderedStream(int n) {\\n        vals = new String[n+1];\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        vals[idKey] = value;\\n        \\n        var retList = new ArrayList<String>();\\n        while (lo < vals.length && vals[lo] != null) {\\n            retList.add(vals[lo++]);\\n        }\\n        return retList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297427,
                "title": "python-93-fast-solution-5-lines-only",
                "content": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.li=[0]*(n+1)\\n        self.ptr=0\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.li[idKey-1]=value\\n        end=self.li.index(0)\\n        k=self.ptr\\n        self.ptr=end\\n        return self.li[k:end]\\n        \\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.li=[0]*(n+1)\\n        self.ptr=0\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.li[idKey-1]=value\\n        end=self.li.index(0)\\n        k=self.ptr\\n        self.ptr=end\\n        return self.li[k:end]\\n        \\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274748,
                "title": "c-short-and-easy",
                "content": "```\\nclass OrderedStream {\\npublic:\\n    vector<string>v;\\n    int i; //global index variable, to help us return output as vector gets filled\\n    OrderedStream(int n) {\\n        v.resize(n, \"\"), i = 0;\\n    }\\n    vector<string> insert(int id, string value) {\\n         v[id - 1] = value; //since id is starting from 1\\n        vector<string>res;\\n         while(i < v.size() and v[i].size() != 0)\\n             res.push_back(v[i++]); //keep pushing the continuous values\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    vector<string>v;\\n    int i; //global index variable, to help us return output as vector gets filled\\n    OrderedStream(int n) {\\n        v.resize(n, \"\"), i = 0;\\n    }\\n    vector<string> insert(int id, string value) {\\n         v[id - 1] = value; //since id is starting from 1\\n        vector<string>res;\\n         while(i < v.size() and v[i].size() != 0)\\n             res.push_back(v[i++]); //keep pushing the continuous values\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223736,
                "title": "javascript-simple-and-concise-solution",
                "content": "```\\nvar OrderedStream = function(n) {\\n    this.pointer = 0;\\n    this.streamArray = new Array(n).fill(undefined);\\n};\\nOrderedStream.prototype.insert = function(idKey, value) {\\n    this.streamArray[idKey-1] = value;\\n    if(this.streamArray[this.pointer] === undefined){\\n        return [];\\n    }else{\\n        const result = [];\\n        while(this.streamArray[this.pointer] !== undefined){\\n            result.push(this.streamArray[this.pointer]);\\n            this.pointer++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar OrderedStream = function(n) {\\n    this.pointer = 0;\\n    this.streamArray = new Array(n).fill(undefined);\\n};\\nOrderedStream.prototype.insert = function(idKey, value) {\\n    this.streamArray[idKey-1] = value;\\n    if(this.streamArray[this.pointer] === undefined){\\n        return [];\\n    }else{\\n        const result = [];\\n        while(this.streamArray[this.pointer] !== undefined){\\n            result.push(this.streamArray[this.pointer]);\\n            this.pointer++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1218404,
                "title": "python-priority-queue",
                "content": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.ans = []\\n        \\n        self.counter = 1\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        ans = []\\n        heapq.heappush(self.ans, (idKey, value))\\n        \\n        x = heapq.heappop(self.ans) if self.ans else None\\n        while x and self.counter == x[0]:\\n            ans.append(x[1])\\n            x = heapq.heappop(self.ans) if self.ans else None\\n            self.counter += 1\\n        if x:\\n            heapq.heappush(self.ans, x)\\n        \\n        return ans\\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.ans = []\\n        \\n        self.counter = 1\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        ans = []\\n        heapq.heappush(self.ans, (idKey, value))\\n        \\n        x = heapq.heappop(self.ans) if self.ans else None\\n        while x and self.counter == x[0]:\\n            ans.append(x[1])\\n            x = heapq.heappop(self.ans) if self.ans else None\\n            self.counter += 1\\n        if x:\\n            heapq.heappush(self.ans, x)\\n        \\n        return ans\\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212496,
                "title": "self-explanatory-o-n-easy-to-understand-using-java",
                "content": "```\\nclass OrderedStream {\\n    private String[] streams;\\n    private int counter = 0;\\n    public OrderedStream(int n) {\\n        streams = new String[n];\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        List<String> stream = new ArrayList<String>();\\n        streams[idKey-1] = value;\\n        while (counter < streams.length && streams[counter] != null) \\n        {\\n\\t\\tstream.add(streams[counter]);\\n\\t\\tcounter++;\\n\\t    }\\n        return stream;\\n    }\\n}\\n```\\n\\nPS: Do upvote if you like the solution and understood it easily :-)",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass OrderedStream {\\n    private String[] streams;\\n    private int counter = 0;\\n    public OrderedStream(int n) {\\n        streams = new String[n];\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        List<String> stream = new ArrayList<String>();\\n        streams[idKey-1] = value;\\n        while (counter < streams.length && streams[counter] != null) \\n        {\\n\\t\\tstream.add(streams[counter]);\\n\\t\\tcounter++;\\n\\t    }\\n        return stream;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211793,
                "title": "c-faster-than-95-with-explanation",
                "content": "## Basic Idea\\nAs we are given the total number of strings to be inserted, we can use an array of strings of length n to save them, according to their index (which is idKey -1). We also keep track of the next index to start the chunk building from, i.e the next unpublished string in the stream.\\n\\nThe stream is initialized to n empty strings, (as sentinels), and next is set to 0\\nFor each insert call, we first put the given string at its position. Then we traverse the array from the position next, uptil we find another empty string and keep on adding them to the chunk, this way we find the largest possible contiguous chunk starting from the position next. Then we update next to the new empty position, and continue.\\n\\n## Code\\n```\\nclass OrderedStream {\\n    vector<string> stream;\\n    int next;\\n    int l;\\npublic:\\n    OrderedStream(int n) {\\n        stream = vector<string>(n, \"\");\\n        next = 0;\\n        l = n;\\n    }\\n    vector<string> insert(int idKey, string value) {\\n        vector<string> chunk;\\n        stream[idKey-1] = value;\\n        if(idKey == next + 1) {\\n            //we found the next string in the stream\\n            while(next < l && stream[next] != \"\") {\\n                chunk.push_back(stream[next]);\\n                next++;\\n            }\\n        }\\n        return chunk;\\n    }\\n};\\n```\\n\\n## Complexity\\n**Time:** **O(n)**, as in all cases, the sum of the lengths of all the chunks will be exactly n, and the runtime of the function depends on the size of the current chunk.\\n**Space: O(n)**, as an array of n strings is required to store the stream itself, and each chunk is stored separately, whose lengths add upto n.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\n    vector<string> stream;\\n    int next;\\n    int l;\\npublic:\\n    OrderedStream(int n) {\\n        stream = vector<string>(n, \"\");\\n        next = 0;\\n        l = n;\\n    }\\n    vector<string> insert(int idKey, string value) {\\n        vector<string> chunk;\\n        stream[idKey-1] = value;\\n        if(idKey == next + 1) {\\n            //we found the next string in the stream\\n            while(next < l && stream[next] != \"\") {\\n                chunk.push_back(stream[next]);\\n                next++;\\n            }\\n        }\\n        return chunk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147786,
                "title": "python3-solution-and-most-importantly-question-explained",
                "content": "Problem: Question is asking to return the stream of strings starting from the location **idKey**. \\nIdea: Keep global variable ```self.loc```; if the idKey is equal to ```self.loc``` then return the array of strings. Otherwise return ```[]```\\n\\nI hope this helps someone!\\nP.S.: It\\'s better to skip this question! ;p\\n\\n```\\nclass OrderedStream:\\n    def __init__(self, n: int):\\n        self.ls = [\"\" for i in range(n)]\\n        self.loc = 0\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.ls[idKey - 1] = value\\n        res = []\\n        \\n        if(self.loc == (idKey - 1)):\\n            while(self.loc < len(self.ls) and self.ls[self.loc] != \"\"):\\n                res.append(self.ls[self.loc])\\n                self.loc += 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```self.loc```\n```self.loc```\n```[]```\n```\\nclass OrderedStream:\\n    def __init__(self, n: int):\\n        self.ls = [\"\" for i in range(n)]\\n        self.loc = 0\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.ls[idKey - 1] = value\\n        res = []\\n        \\n        if(self.loc == (idKey - 1)):\\n            while(self.loc < len(self.ls) and self.ls[self.loc] != \"\"):\\n                res.append(self.ls[self.loc])\\n                self.loc += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138375,
                "title": "java-simple",
                "content": "```\\nclass OrderedStream {\\n    private int ptr;\\n    private String[] arr;\\n    public OrderedStream(int n) {\\n        arr = new String[n+1];\\n        ptr = 1;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        arr[idKey] = value;\\n        List<String> str = new ArrayList<>();\\n        while(ptr < arr.length && arr[ptr] != null )\\n        {\\n            str.add(arr[ptr]);\\n            ptr++;\\n        }\\n        return str;\\n    }\\n}\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream obj = new OrderedStream(n);\\n * List<String> param_1 = obj.insert(idKey,value);\\n */\\n ```\\n please upvote , if u find my code easy to understand",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\n    private int ptr;\\n    private String[] arr;\\n    public OrderedStream(int n) {\\n        arr = new String[n+1];\\n        ptr = 1;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        arr[idKey] = value;\\n        List<String> str = new ArrayList<>();\\n        while(ptr < arr.length && arr[ptr] != null )\\n        {\\n            str.add(arr[ptr]);\\n            ptr++;\\n        }\\n        return str;\\n    }\\n}\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream obj = new OrderedStream(n);\\n * List<String> param_1 = obj.insert(idKey,value);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1038108,
                "title": "c-clean-code",
                "content": "```\\nclass OrderedStream {\\n    vector<string> stream;\\n    int pointer;\\npublic:\\n    OrderedStream(int n) {\\n        stream.resize(n + 1);\\n        pointer = 1;\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        stream[id] = value;\\n        vector<string> result;\\n        \\n        while (pointer < stream.size() and not stream[pointer].empty())\\n            result.push_back(stream[pointer++]);\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\n    vector<string> stream;\\n    int pointer;\\npublic:\\n    OrderedStream(int n) {\\n        stream.resize(n + 1);\\n        pointer = 1;\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        stream[id] = value;\\n        vector<string> result;\\n        \\n        while (pointer < stream.size() and not stream[pointer].empty())\\n            result.push_back(stream[pointer++]);\\n        \\n        return result;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1013951,
                "title": "python3-solution",
                "content": "Hard mode: take a shot every time you have to type `self`.\\n```python\\nclass OrderedStream:\\n    \\n    def __init__(self, n: int):\\n        self.S = [None]*(n+1)\\n        self.i = 1\\n        \\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.S[id] = value\\n        while self.i < len(self.S):\\n            if not self.S[self.i]:\\n                break\\n            self.i += 1\\n        return self.S[id:self.i]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass OrderedStream:\\n    \\n    def __init__(self, n: int):\\n        self.S = [None]*(n+1)\\n        self.i = 1\\n        \\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.S[id] = value\\n        while self.i < len(self.S):\\n            if not self.S[self.i]:\\n                break\\n            self.i += 1\\n        return self.S[id:self.i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987703,
                "title": "java-solution",
                "content": "```   private String[] arr;\\n    public OrderedStream(int n) {\\n        arr = new String[n];\\n    }\\n\\n    public List<String> insert(int id, String value) {\\n        int index = (id-1);\\n\\t\\tList<String> list = new ArrayList<>();\\n        \\n\\t\\tif(index < 0 || index > arr.length) return list;\\n        \\n        arr[index] = value;\\n        for(int i=0; i< arr.length; i++){\\n            if(arr[i] == null) return list;\\n            else {\\n                if(i >= index){\\n                    list.add(arr[i]);\\n                 }\\n            }\\n        }\\n        return list;\\n    }\\n```",
                "solutionTags": [],
                "code": "```   private String[] arr;\\n    public OrderedStream(int n) {\\n        arr = new String[n];\\n    }\\n\\n    public List<String> insert(int id, String value) {\\n        int index = (id-1);\\n\\t\\tList<String> list = new ArrayList<>();\\n        \\n\\t\\tif(index < 0 || index > arr.length) return list;\\n        \\n        arr[index] = value;\\n        for(int i=0; i< arr.length; i++){\\n            if(arr[i] == null) return list;\\n            else {\\n                if(i >= index){\\n                    list.add(arr[i]);\\n                 }\\n            }\\n        }\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 943303,
                "title": "c-faster-than-99-33-memory-usage-less-than-97-76",
                "content": "```\\nclass OrderedStream {\\n    public:\\n        // Initialize \"pointer\" (btw not an actual pointer) & stream vector\\n        int ptr=0;\\n        vector<string> stream;\\n\\n        OrderedStream(int n) {\\n            // Constructor makes stream vector of size n\\n            vector<string> strm(n);\\n            stream = strm;\\n        }\\n\\n        vector<string> insert(int id, string value) {\\n            // decrease id by one to correspond with vector idx (i.e. start from 0)\\n            --id;\\n            \\n\\t\\t\\t// create a vector to be returned by function\\n            vector<string> returnVec;\\n            \\n\\t\\t\\t// at index id in stream vector, set the value\\n            stream[id] = value;\\n            \\n            // if stream at index ptr is not empty...\\n            if (stream[ptr] != \"\") {\\n                \\n\\t\\t\\t\\t// create a new int to mark the start index\\n                int start_idx = ptr;\\n                \\n\\t\\t\\t\\t// while stream at index ptr is not empty, move ptr to the next index\\n                while (stream[ptr] != \"\" && ptr != stream.size()) ptr++;\\n                \\n\\t\\t\\t\\t// set returnVec to a sliced version of the stream vector\\n                // (i.e. stream[start_idx:ptr])\\n                returnVec = vector<string>(stream.begin()+start_idx, stream.begin()+ptr);\\n            }\\n            return returnVec;\\n        }\\n}; \\n\\n```\\n\\nJust my first go at it, im sure it could be improved. Welcome to any suggestions.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\n    public:\\n        // Initialize \"pointer\" (btw not an actual pointer) & stream vector\\n        int ptr=0;\\n        vector<string> stream;\\n\\n        OrderedStream(int n) {\\n            // Constructor makes stream vector of size n\\n            vector<string> strm(n);\\n            stream = strm;\\n        }\\n\\n        vector<string> insert(int id, string value) {\\n            // decrease id by one to correspond with vector idx (i.e. start from 0)\\n            --id;\\n            \\n\\t\\t\\t// create a vector to be returned by function\\n            vector<string> returnVec;\\n            \\n\\t\\t\\t// at index id in stream vector, set the value\\n            stream[id] = value;\\n            \\n            // if stream at index ptr is not empty...\\n            if (stream[ptr] != \"\") {\\n                \\n\\t\\t\\t\\t// create a new int to mark the start index\\n                int start_idx = ptr;\\n                \\n\\t\\t\\t\\t// while stream at index ptr is not empty, move ptr to the next index\\n                while (stream[ptr] != \"\" && ptr != stream.size()) ptr++;\\n                \\n\\t\\t\\t\\t// set returnVec to a sliced version of the stream vector\\n                // (i.e. stream[start_idx:ptr])\\n                returnVec = vector<string>(stream.begin()+start_idx, stream.begin()+ptr);\\n            }\\n            return returnVec;\\n        }\\n}; \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939478,
                "title": "c-98",
                "content": "```\\nclass OrderedStream {\\npublic:\\n    OrderedStream(int n) {\\n        vec.resize(n);\\n    }\\n    \\n    vector<string> insert(int id, const string& value) {\\n        vec[--id]=value;\\n        vector<string> ans;\\n        while(pos<vec.size()) {\\n            if(vec[pos].empty()) break;\\n            ans.push_back(vec[pos++]);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<string> vec;\\n    int pos=0;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    OrderedStream(int n) {\\n        vec.resize(n);\\n    }\\n    \\n    vector<string> insert(int id, const string& value) {\\n        vec[--id]=value;\\n        vector<string> ans;\\n        while(pos<vec.size()) {\\n            if(vec[pos].empty()) break;\\n            ans.push_back(vec[pos++]);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<string> vec;\\n    int pos=0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938978,
                "title": "100-fastest-in-c",
                "content": "```\\ntypedef struct {\\n    int ptr;\\n    int size;\\n    char** value;\\n} OrderedStream;\\n\\n\\nOrderedStream* orderedStreamCreate(int n) {\\n    OrderedStream *orderedStream = (OrderedStream*)malloc(sizeof(OrderedStream));\\n    orderedStream->ptr=1;\\n    orderedStream->size=n;\\n    orderedStream->value=(char**)malloc(sizeof(char*)*n);\\n    for(int i=0;i<n; i++){\\n        *(orderedStream->value+i)=NULL;\\n    }\\n    return orderedStream;\\n}\\n\\nchar ** orderedStreamInsert(OrderedStream* obj, int id, char * value, int* retSize) {\\n    *(obj->value+id-1)=value;\\n    int count=0;\\n    if(id==obj->ptr){\\n        while(id-1+count<obj->size&&*(obj->value+id-1+count)!=NULL)\\n            count++;\\n        obj->ptr=id+count;\\n    }\\n    *retSize=count;\\n    return obj->value+id-1;\\n}\\n\\nvoid orderedStreamFree(OrderedStream* obj) {\\n    free(obj->value);\\n    free(obj);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct {\\n    int ptr;\\n    int size;\\n    char** value;\\n} OrderedStream;\\n\\n\\nOrderedStream* orderedStreamCreate(int n) {\\n    OrderedStream *orderedStream = (OrderedStream*)malloc(sizeof(OrderedStream));\\n    orderedStream->ptr=1;\\n    orderedStream->size=n;\\n    orderedStream->value=(char**)malloc(sizeof(char*)*n);\\n    for(int i=0;i<n; i++){\\n        *(orderedStream->value+i)=NULL;\\n    }\\n    return orderedStream;\\n}\\n\\nchar ** orderedStreamInsert(OrderedStream* obj, int id, char * value, int* retSize) {\\n    *(obj->value+id-1)=value;\\n    int count=0;\\n    if(id==obj->ptr){\\n        while(id-1+count<obj->size&&*(obj->value+id-1+count)!=NULL)\\n            count++;\\n        obj->ptr=id+count;\\n    }\\n    *retSize=count;\\n    return obj->value+id-1;\\n}\\n\\nvoid orderedStreamFree(OrderedStream* obj) {\\n    free(obj->value);\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 936572,
                "title": "65ms-java-faster-than-100-w-comments",
                "content": "If any question feel free to ask.\\n```\\nclass OrderedStream {\\n    String[] arr; //Stores the String values in the id\\'th index.\\n    int size; //size of orderedstream\\n    int ptr; //pointer to hold current position\\n    \\n    public OrderedStream(int n) {\\n        size = n;\\n        arr = new String[size+1]; //size+1 cuz of id starts from 1.\\n        ptr = 1; //it starts from 1 cuz of id is between 1 and n\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        List<String> list = new ArrayList<>(); //local list to return.\\n        arr[id] = value; //puts the string value to the index of id.\\n\\t\\t\\n\\t\\t//This loop iterates untill our pointer points null. While it is not null\\n\\t\\t//It points value of pointer and add it to our List to return.\\n        while(ptr<=size){\\n             if(arr[ptr]==null)break;//If our pointer is null then we can break the loop.\\n             list.add(arr[ptr++]);//If pointer is not null then add pointer value to list and increase the pointer for next values.\\n        }\\n\\t\\t\\n        return list;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n    String[] arr; //Stores the String values in the id\\'th index.\\n    int size; //size of orderedstream\\n    int ptr; //pointer to hold current position\\n    \\n    public OrderedStream(int n) {\\n        size = n;\\n        arr = new String[size+1]; //size+1 cuz of id starts from 1.\\n        ptr = 1; //it starts from 1 cuz of id is between 1 and n\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        List<String> list = new ArrayList<>(); //local list to return.\\n        arr[id] = value; //puts the string value to the index of id.\\n\\t\\t\\n\\t\\t//This loop iterates untill our pointer points null. While it is not null\\n\\t\\t//It points value of pointer and add it to our List to return.\\n        while(ptr<=size){\\n             if(arr[ptr]==null)break;//If our pointer is null then we can break the loop.\\n             list.add(arr[ptr++]);//If pointer is not null then add pointer value to list and increase the pointer for next values.\\n        }\\n\\t\\t\\n        return list;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936287,
                "title": "java-simple-hashmap",
                "content": "```\\nclass OrderedStream {\\n    int index = 1;\\n    Map<Integer, String> map = new HashMap<>();\\n    \\n    public OrderedStream(int n) {\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        map.put(id, value);\\n        List<String> result = new ArrayList<>();\\n        while (map.containsKey(index))\\n            result.add(map.get(index++));\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\n    int index = 1;\\n    Map<Integer, String> map = new HashMap<>();\\n    \\n    public OrderedStream(int n) {\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        map.put(id, value);\\n        List<String> result = new ArrayList<>();\\n        while (map.containsKey(index))\\n            result.add(map.get(index++));\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936204,
                "title": "javascript-solution-using-array-184-ms",
                "content": "```\\nvar OrderedStream = function(n) {\\n    this.arr = new Array(n);\\n    this.index = 0;\\n};\\n\\nOrderedStream.prototype.insert = function(id, value) {\\n    this.arr[id - 1] = value;\\n    const result = [];\\n    while (this.arr[this.index]) {\\n        result.push(this.arr[this.index++]);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar OrderedStream = function(n) {\\n    this.arr = new Array(n);\\n    this.index = 0;\\n};\\n\\nOrderedStream.prototype.insert = function(id, value) {\\n    this.arr[id - 1] = value;\\n    const result = [];\\n    while (this.arr[this.index]) {\\n        result.push(this.arr[this.index++]);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3697553,
                "title": "solution-with-runtime-97-1-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass OrderedStream {\\n    String[] arr;\\n    int ptr = 1;\\n\\n    public OrderedStream(int n) {\\n        arr = new String[n + 1];\\n    }\\n\\n    public List<String> insert(int idKey, String value) {\\n        ArrayList<String> k = new ArrayList<>();\\n        arr[idKey] = value;\\n\\n        if (ptr != idKey) return k;\\n        \\n        for (int i = ptr; i < arr.length && arr[i] != null; i++) {\\n            k.add(arr[i]);\\n            ptr++;\\n        }\\n\\n        return k;\\n    }\\n}\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream obj = new OrderedStream(n);\\n * List<String> param_1 = obj.insert(idKey,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n    String[] arr;\\n    int ptr = 1;\\n\\n    public OrderedStream(int n) {\\n        arr = new String[n + 1];\\n    }\\n\\n    public List<String> insert(int idKey, String value) {\\n        ArrayList<String> k = new ArrayList<>();\\n        arr[idKey] = value;\\n\\n        if (ptr != idKey) return k;\\n        \\n        for (int i = ptr; i < arr.length && arr[i] != null; i++) {\\n            k.add(arr[i]);\\n            ptr++;\\n        }\\n\\n        return k;\\n    }\\n}\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream obj = new OrderedStream(n);\\n * List<String> param_1 = obj.insert(idKey,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636939,
                "title": "c-using-array",
                "content": "# Code\\n```\\npublic class OrderedStream\\n{\\n    private readonly string?[] _data;\\n    private int _ptr;\\n\\n    public OrderedStream(int n)\\n    {\\n        _data = new string[n + 1];\\n        _ptr = 1;\\n    }\\n\\n    public IList<string> Insert(int idKey, string value)\\n    {\\n        _data[idKey] = value;\\n        var res = new List<string>();\\n        for (var i = _ptr; i < _data.Length; i++)\\n        {\\n            if (_data[i] != null)\\n            {\\n                res.Add(_data[i]!);\\n            }\\n            else\\n            {\\n                _ptr = i;\\n                break;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class OrderedStream\\n{\\n    private readonly string?[] _data;\\n    private int _ptr;\\n\\n    public OrderedStream(int n)\\n    {\\n        _data = new string[n + 1];\\n        _ptr = 1;\\n    }\\n\\n    public IList<string> Insert(int idKey, string value)\\n    {\\n        _data[idKey] = value;\\n        var res = new List<string>();\\n        for (var i = _ptr; i < _data.Length; i++)\\n        {\\n            if (_data[i] != null)\\n            {\\n                res.Add(_data[i]!);\\n            }\\n            else\\n            {\\n                _ptr = i;\\n                break;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626497,
                "title": "easy-java-solution-beats-99-onine-submissions",
                "content": "# Code\\n```\\nclass OrderedStream {\\n    private String[] data;\\n    private int ptr;\\n\\n    public OrderedStream(int n) {\\n        data = new String[n + 1];\\n        ptr = 1;\\n    }\\n\\n    public String[] insert(int idKey, String value) {\\n        data[idKey] = value;\\n        List<String> res = new ArrayList<>();\\n        for (int i = ptr; i < data.length; i++) {\\n            if (data[i] != null) {\\n                res.add(data[i]);\\n            } else {\\n                ptr = i;\\n                break;\\n            }\\n        }\\n        return res.toArray(new String[0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Design",
                    "Data Stream"
                ],
                "code": "```\\nclass OrderedStream {\\n    private String[] data;\\n    private int ptr;\\n\\n    public OrderedStream(int n) {\\n        data = new String[n + 1];\\n        ptr = 1;\\n    }\\n\\n    public String[] insert(int idKey, String value) {\\n        data[idKey] = value;\\n        List<String> res = new ArrayList<>();\\n        for (int i = ptr; i < data.length; i++) {\\n            if (data[i] != null) {\\n                res.add(data[i]);\\n            } else {\\n                ptr = i;\\n                break;\\n            }\\n        }\\n        return res.toArray(new String[0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081780,
                "title": "easy-understandabe-java-code-trust-me",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass OrderedStream {\\n    String[] stream;\\n    int ptr=0;\\n\\n\\n    public OrderedStream(int n) {\\n        stream=new String[n+1];\\n        m=n;\\n    }\\n    public List<String> insert(int idKey, String value) {\\n        List<String> list=new ArrayList<>();\\n        stream[idKey-1]=value;\\n        while(stream[ptr]!=null)\\n        {\\n            list.add(stream[ptr]);\\n            ptr++;\\n        }\\n        return list;\\n    }\\n}\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream obj = new OrderedStream(n);\\n * List<String> param_1 = obj.insert(idKey,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n    String[] stream;\\n    int ptr=0;\\n\\n\\n    public OrderedStream(int n) {\\n        stream=new String[n+1];\\n        m=n;\\n    }\\n    public List<String> insert(int idKey, String value) {\\n        List<String> list=new ArrayList<>();\\n        stream[idKey-1]=value;\\n        while(stream[ptr]!=null)\\n        {\\n            list.add(stream[ptr]);\\n            ptr++;\\n        }\\n        return list;\\n    }\\n}\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream obj = new OrderedStream(n);\\n * List<String> param_1 = obj.insert(idKey,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032452,
                "title": "java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nthe time complexity of the code is dominated by the insert() method, which is O(k) where k is the number of elements inserted so far.\\n\\n- Space complexity:\\nThe space complexity of this code is O(n), where n is the number of elements that the stream can hold.\\n\\n# Code\\n```\\nclass OrderedStream {\\n    private String[] data;\\n    private int ptr;\\n\\n    public OrderedStream(int n) {\\n        data = new String[n + 1];\\n        ptr = 1;\\n    }\\n\\n    public String[] insert(int idKey, String value) {\\n        data[idKey] = value;\\n        List<String> res = new ArrayList<>();\\n        for (int i = ptr; i < data.length; i++) {\\n            if (data[i] != null) {\\n                res.add(data[i]);\\n            } else {\\n                ptr = i;\\n                break;\\n            }\\n        }\\n        return res.toArray(new String[0]);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n    private String[] data;\\n    private int ptr;\\n\\n    public OrderedStream(int n) {\\n        data = new String[n + 1];\\n        ptr = 1;\\n    }\\n\\n    public String[] insert(int idKey, String value) {\\n        data[idKey] = value;\\n        List<String> res = new ArrayList<>();\\n        for (int i = ptr; i < data.length; i++) {\\n            if (data[i] != null) {\\n                res.add(data[i]);\\n            } else {\\n                ptr = i;\\n                break;\\n            }\\n        }\\n        return res.toArray(new String[0]);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884764,
                "title": "c-easy-solution",
                "content": "```\\nclass OrderedStream {\\nprivate:\\n    vector<string> data;\\n    int i,x;\\npublic:\\n    OrderedStream(int n) {\\n        x=n;\\n        data.resize(n,\"\");\\n        i=1;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string> ans;\\n        data[idKey-1] = value;\\n        if(idKey == i){\\n            for(int j=i-1; j<x; ++j){\\n                if(!data[j].empty()) ans.push_back(data[j]),i++;\\n                else break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass OrderedStream {\\nprivate:\\n    vector<string> data;\\n    int i,x;\\npublic:\\n    OrderedStream(int n) {\\n        x=n;\\n        data.resize(n,\"\");\\n        i=1;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string> ans;\\n        data[idKey-1] = value;\\n        if(idKey == i){\\n            for(int j=i-1; j<x; ++j){\\n                if(!data[j].empty()) ans.push_back(data[j]),i++;\\n                else break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858268,
                "title": "120ms-go-solution",
                "content": "\\n```\\ntype OrderedStream struct {\\n  hm map[int]string\\n  n int\\n  posPtr int  \\n}\\n\\nfunc Constructor(n int) OrderedStream {\\n  return OrderedStream {\\n    hm: make(map[int]string),\\n    n: n,\\n    posPtr: 1,\\n  }\\n}\\n\\n\\nfunc (this *OrderedStream) Insert(idKey int, value string) []string {\\n  this.hm[idKey] = value\\n\\n  ans := []string{}\\n  for this.posPtr <= this.n && this.hm[this.posPtr] != \"\" {\\n    ans = append(ans, this.hm[this.posPtr])\\n    this.posPtr++\\n  }\\n\\n  return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype OrderedStream struct {\\n  hm map[int]string\\n  n int\\n  posPtr int  \\n}\\n\\nfunc Constructor(n int) OrderedStream {\\n  return OrderedStream {\\n    hm: make(map[int]string),\\n    n: n,\\n    posPtr: 1,\\n  }\\n}\\n\\n\\nfunc (this *OrderedStream) Insert(idKey int, value string) []string {\\n  this.hm[idKey] = value\\n\\n  ans := []string{}\\n  for this.posPtr <= this.n && this.hm[this.posPtr] != \"\" {\\n    ans = append(ans, this.hm[this.posPtr])\\n    this.posPtr++\\n  }\\n\\n  return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2712191,
                "title": "rust-hashmap",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\n#[derive(Default)]\\nstruct OrderedStream {\\n    ptr : usize,\\n    store : HashMap<usize, String>\\n}\\n\\n\\nimpl OrderedStream {\\n\\n    fn new(n: i32) -> Self {\\n        Default::default()\\n    }\\n    \\n    fn insert(&mut self, id_key: i32, value: String) -> Vec<String> {\\n        let id_key = (id_key - 1) as usize;\\n        self.store.insert(id_key, value);\\n        \\n        let mut res = vec![];\\n        \\n        if id_key == self.ptr{\\n            while let Some(val) = self.store.remove(&self.ptr){\\n                res.push(val);\\n                self.ptr+=1;\\n            }\\n        }\\n        \\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\n#[derive(Default)]\\nstruct OrderedStream {\\n    ptr : usize,\\n    store : HashMap<usize, String>\\n}\\n\\n\\nimpl OrderedStream {\\n\\n    fn new(n: i32) -> Self {\\n        Default::default()\\n    }\\n    \\n    fn insert(&mut self, id_key: i32, value: String) -> Vec<String> {\\n        let id_key = (id_key - 1) as usize;\\n        self.store.insert(id_key, value);\\n        \\n        let mut res = vec![];\\n        \\n        if id_key == self.ptr{\\n            while let Some(val) = self.store.remove(&self.ptr){\\n                res.push(val);\\n                self.ptr+=1;\\n            }\\n        }\\n        \\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2576431,
                "title": "java-o-n-time-o-n-space-with-explanation-in-code",
                "content": "```\\n// NOTE: \\n// To understand the question, the concatenation of all the chunks should result in a list of the SORTED values.\\n// That is why calling the function of insert(3, \"ccccc\") will NOT return anything. \\n// In other words, calling insert(1, \"ccccc\") returns \"ccccc\"\\nclass OrderedStream {\\n\\n    private String[] record;\\n\\t\\n\\t//The starting index  of the next output when insert() is called\\n    private int outputIndex;  \\n\\t\\n    public OrderedStream(int n) {\\n        // Store current (idKey, Value) into this array\\n        record = new String[n + 1];\\n        Arrays.fill(record, \"\");\\n        \\n        // The outputIndex is the starting index of the chunk, which is to be \\n        // returned via \"insert\" function. We will need to update outputIndex accordingly\\n        outputIndex = 1;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        List<String> result = new ArrayList<>();\\n        \\n        // Regardless of idKey equals to outputIndex or not, need to store current (idKey, Value)\\n        record[idKey] = value;\\n        \\n        if (idKey == outputIndex) {\\n            int i = outputIndex;\\n            while (i < record.length && record[i] != \"\") {\\n                result.add(record[i]);\\n                ++i;\\n            }\\n            // outputIndex has scanned the current continuous non-empty value,\\n            // the next available value is i. \\n            // Otherwise, it violates \"The concatenation of all the chunks should \\n            // result in a list of the sorted values.\"\\n            outputIndex = i;\\n        }\\n        return result;\\n    }\\n}\\n ```",
                "solutionTags": [],
                "code": "```\\n// NOTE: \\n// To understand the question, the concatenation of all the chunks should result in a list of the SORTED values.\\n// That is why calling the function of insert(3, \"ccccc\") will NOT return anything. \\n// In other words, calling insert(1, \"ccccc\") returns \"ccccc\"\\nclass OrderedStream {\\n\\n    private String[] record;\\n\\t\\n\\t//The starting index  of the next output when insert() is called\\n    private int outputIndex;  \\n\\t\\n    public OrderedStream(int n) {\\n        // Store current (idKey, Value) into this array\\n        record = new String[n + 1];\\n        Arrays.fill(record, \"\");\\n        \\n        // The outputIndex is the starting index of the chunk, which is to be \\n        // returned via \"insert\" function. We will need to update outputIndex accordingly\\n        outputIndex = 1;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        List<String> result = new ArrayList<>();\\n        \\n        // Regardless of idKey equals to outputIndex or not, need to store current (idKey, Value)\\n        record[idKey] = value;\\n        \\n        if (idKey == outputIndex) {\\n            int i = outputIndex;\\n            while (i < record.length && record[i] != \"\") {\\n                result.add(record[i]);\\n                ++i;\\n            }\\n            // outputIndex has scanned the current continuous non-empty value,\\n            // the next available value is i. \\n            // Otherwise, it violates \"The concatenation of all the chunks should \\n            // result in a list of the sorted values.\"\\n            outputIndex = i;\\n        }\\n        return result;\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2519324,
                "title": "python3-runtime-faster-than-90-82-memory-less-than-93-18-testing",
                "content": "```\\n\"\"\"\\nexercise: 1656. Design an Ordered Stream\\nhttps://leetcode.com/problems/design-an-ordered-stream/\\ncompany: Bloomberg\\n\"\"\"\\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.pairs = dict()\\n        self.pointer = 0\\n\\n    def insert(self, idKey: int, value: str) -> list[str]:\\n        self.pairs[idKey] = value\\n\\n        temp = list()\\n        while self.pointer + 1 in self.pairs:\\n            self.pointer += 1\\n\\n            temp.append(self.pairs[self.pointer])\\n\\n        return temp\\n\\n\\nif __name__ == \\'__main__\\':\\n    os = OrderedStream(5)\\n\\n    assert os.insert(3, \"ccccc\").__eq__([])\\n    assert os.insert(1, \"aaaaa\").__eq__([\\'aaaaa\\'])\\n    assert os.insert(2, \"bbbbb\").__eq__([\"bbbbb\", \"ccccc\"])\\n    assert os.insert(5, \"eeeee\").__eq__([])\\n    assert os.insert(4, \"ddddd\").__eq__([\"ddddd\", \"eeeee\"])\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\nexercise: 1656. Design an Ordered Stream\\nhttps://leetcode.com/problems/design-an-ordered-stream/\\ncompany: Bloomberg\\n\"\"\"\\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.pairs = dict()\\n        self.pointer = 0\\n\\n    def insert(self, idKey: int, value: str) -> list[str]:\\n        self.pairs[idKey] = value\\n\\n        temp = list()\\n        while self.pointer + 1 in self.pairs:\\n            self.pointer += 1\\n\\n            temp.append(self.pairs[self.pointer])\\n\\n        return temp\\n\\n\\nif __name__ == \\'__main__\\':\\n    os = OrderedStream(5)\\n\\n    assert os.insert(3, \"ccccc\").__eq__([])\\n    assert os.insert(1, \"aaaaa\").__eq__([\\'aaaaa\\'])\\n    assert os.insert(2, \"bbbbb\").__eq__([\"bbbbb\", \"ccccc\"])\\n    assert os.insert(5, \"eeeee\").__eq__([])\\n    assert os.insert(4, \"ddddd\").__eq__([\"ddddd\", \"eeeee\"])\\n",
                "codeTag": "Java"
            },
            {
                "id": 2502277,
                "title": "rust-idiomatic-solution",
                "content": "```\\nstruct OrderedStream {\\n    arr: Vec<Option<String>>,\\n    ptr: usize\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl OrderedStream {\\n\\n    fn new(n: i32) -> Self {\\n        Self {\\n            arr: vec![None; n as usize],\\n            ptr: 0\\n        }\\n    }\\n    \\n    fn insert(&mut self, id_key: i32, value: String) -> Vec<String> {\\n        let id_key = id_key as usize - 1;\\n        self.arr[id_key] = Some(value);\\n        \\n        if id_key > self.ptr {\\n            return vec![];\\n        }\\n        \\n        while let Some(Some(_)) = self.arr.get(self.ptr) {\\n            self.ptr += 1;\\n        }\\n        self.arr[id_key..self.ptr].iter_mut().map(|opt| opt.take().unwrap()).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct OrderedStream {\\n    arr: Vec<Option<String>>,\\n    ptr: usize\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl OrderedStream {\\n\\n    fn new(n: i32) -> Self {\\n        Self {\\n            arr: vec![None; n as usize],\\n            ptr: 0\\n        }\\n    }\\n    \\n    fn insert(&mut self, id_key: i32, value: String) -> Vec<String> {\\n        let id_key = id_key as usize - 1;\\n        self.arr[id_key] = Some(value);\\n        \\n        if id_key > self.ptr {\\n            return vec![];\\n        }\\n        \\n        while let Some(Some(_)) = self.arr.get(self.ptr) {\\n            self.ptr += 1;\\n        }\\n        self.arr[id_key..self.ptr].iter_mut().map(|opt| opt.take().unwrap()).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2466923,
                "title": "c-based-solution-to-terrible-problem-with-explanation-beats-150",
                "content": "```\\nclass OrderedStream {\\nprivate:\\n    int k; //pointer to min index\\n    vector<string> chunks; //chunky boy\\npublic:\\n    OrderedStream(int n) {\\n        k = 1; //init to first pos\\n        \\n        for(int i = 0; i < n; i++) {\\n            chunks.push_back(\"-1\"); //init all pos to -1 (unvisited)\\n        }\\n        \\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string> chunk{}; //output chonk\\n        chunks[idKey-1] = value; //replace -1 with actual value, 0-indexed\\n        \\n        if(idKey == k) { //if we are on our min pointer\\n            while(k <= chunks.size() && chunks[k-1] != \"-1\") { //and we are within bounds and haven\\'t visited this index yet, \\n                chunk.push_back(chunks[k-1]); //push to output chonk\\n                k++; //increase pointer, will increase to next \"-1\" unvisited index\\n            }\\n        }\\n        \\n        return chunk;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\nprivate:\\n    int k; //pointer to min index\\n    vector<string> chunks; //chunky boy\\npublic:\\n    OrderedStream(int n) {\\n        k = 1; //init to first pos\\n        \\n        for(int i = 0; i < n; i++) {\\n            chunks.push_back(\"-1\"); //init all pos to -1 (unvisited)\\n        }\\n        \\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string> chunk{}; //output chonk\\n        chunks[idKey-1] = value; //replace -1 with actual value, 0-indexed\\n        \\n        if(idKey == k) { //if we are on our min pointer\\n            while(k <= chunks.size() && chunks[k-1] != \"-1\") { //and we are within bounds and haven\\'t visited this index yet, \\n                chunk.push_back(chunks[k-1]); //push to output chonk\\n                k++; //increase pointer, will increase to next \"-1\" unvisited index\\n            }\\n        }\\n        \\n        return chunk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457503,
                "title": "simple-c-solution",
                "content": "```\\nclass OrderedStream {\\npublic:\\n    vector<string> s;\\n    int ptr=1;\\n    OrderedStream(int n) {\\n        s.resize(n+1);\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        s[idKey]=value;\\n        vector<string> res;\\n        while(ptr<s.size() && !s[ptr].empty())\\n            res.push_back(s[ptr++]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    vector<string> s;\\n    int ptr=1;\\n    OrderedStream(int n) {\\n        s.resize(n+1);\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        s[idKey]=value;\\n        vector<string> res;\\n        while(ptr<s.size() && !s[ptr].empty())\\n            res.push_back(s[ptr++]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454083,
                "title": "c-easy-straightforward",
                "content": "```\\nclass OrderedStream {\\npublic:\\n    \\n    vector<string> orderedStream; \\n    \\n    int start;\\n    \\n    OrderedStream(int n) {\\n        for(int i=0; i<n; i++){\\n            orderedStream.push_back(\"\");\\n        }\\n        \\n        start = 0;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        orderedStream[idKey-1] = value; \\n        \\n        vector<string> ans;\\n        \\n        for(int i=start; i<orderedStream.size(); i++){\\n            if(orderedStream[i] != \"\"){\\n                start++; \\n                ans.push_back(orderedStream[i]);\\n            }\\n            else{\\n                return ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    \\n    vector<string> orderedStream; \\n    \\n    int start;\\n    \\n    OrderedStream(int n) {\\n        for(int i=0; i<n; i++){\\n            orderedStream.push_back(\"\");\\n        }\\n        \\n        start = 0;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        orderedStream[idKey-1] = value; \\n        \\n        vector<string> ans;\\n        \\n        for(int i=start; i<orderedStream.size(); i++){\\n            if(orderedStream[i] != \"\"){\\n                start++; \\n                ans.push_back(orderedStream[i]);\\n            }\\n            else{\\n                return ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2300767,
                "title": "c-easy-global-pointer",
                "content": "We just need a **global pointer** to store the **last index** till which the elements have been printed or sent to the output stream. The only way to do it (approach the problem) is in a linear fashion, from the starting index. Hence, the logic of the solution.\\n**Please upvote if you find the solution good.\\n*Thank You!!***\\n```\\nclass OrderedStream {\\npublic:\\n    int lastval = -1, n;\\n    vector<string> v;\\n    OrderedStream(int n) {\\n        v = vector<string>(n);\\n        this->n = n;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        v[idKey-1] = value;\\n        if(idKey - 1 - lastval == 1) {\\n            int idx = idKey-1;\\n            vector<string> temp;\\n            while(idx < n and v[idx].size()) temp.push_back(v[idx++]);\\n            lastval = idx-1;\\n            return temp;\\n        }\\n        return {};\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    int lastval = -1, n;\\n    vector<string> v;\\n    OrderedStream(int n) {\\n        v = vector<string>(n);\\n        this->n = n;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        v[idKey-1] = value;\\n        if(idKey - 1 - lastval == 1) {\\n            int idx = idKey-1;\\n            vector<string> temp;\\n            while(idx < n and v[idx].size()) temp.push_back(v[idx++]);\\n            lastval = idx-1;\\n            return temp;\\n        }\\n        return {};\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2257043,
                "title": "c-easy",
                "content": "```\\nclass OrderedStream {\\npublic:\\n\\n\\t// Keep track how many values we have returned alredy.\\n    int startIndex = 0;\\n    vector<string> val;\\n    \\n    OrderedStream(int n) {\\n        val.resize(n+1,\"\");\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string> ans;\\n        val[idKey - 1] = value;\\n        \\n\\t\\t// Push values to answer vector until value is not NULL or EMPTY\\n        while(val[startIndex] != \"\"){\\n            ans.push_back(val[startIndex]);\\n            startIndex++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n\\n\\t// Keep track how many values we have returned alredy.\\n    int startIndex = 0;\\n    vector<string> val;\\n    \\n    OrderedStream(int n) {\\n        val.resize(n+1,\"\");\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string> ans;\\n        val[idKey - 1] = value;\\n        \\n\\t\\t// Push values to answer vector until value is not NULL or EMPTY\\n        while(val[startIndex] != \"\"){\\n            ans.push_back(val[startIndex]);\\n            startIndex++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054571,
                "title": "reverse-engineered-solution-to-understand-the-problem-lol",
                "content": "The problem description is so unclear that to finally understand **what the heck author is asking for** I had to find some solution here on discussion and reverse engineer it back to the problem description. \\n\\nDo you guys also find the unstoppable animated gif so annoying?\\n\\nThis is surly the most frustraifing \"easy\" so far...",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2026476,
                "title": "c-elegant-solution",
                "content": "It is quite hard to understand the requirements at first, but the animation makes it easier.\\nSo, we know in advance that we will be having an array of strings of length *n*, and therefore\\nthe constructor allocates a vector of empty strings. That is quite easy.\\n\\nInserting a value is also easy, since it is guaranteed, by the problem description, that each pair\\nwill have a unique *id*. You just replace the empty string on a position given by *idKey* (-1, since\\nwe count from 0) with string *value*.\\n\\nNow comes the tricky part. Upon each insertion, you need to return a list of strings such that it\\nis a continuos chunk, with no empty strings between them. You start off from index *lastIndex*, and in a \\naux buffer you *push_back* all non-empty strings that come afterwards, and you increment *lastIndex*\\nafter each push. Also, pay attention that you cannot check *arr.at(lastIndex)* if *lastIndex* is out of range.\\nThat will throw you a runtime error which is hard to figure out. That\\'s why you need *lastIndex < arr.size()*.\\n\\nNo dynamic allocation, so no destructor is needed.\\n\\n\\n```\\nclass OrderedStream {\\npublic:\\n    OrderedStream(int n) : arr {vector<string>(n, \"\")} \\n    {\\n    }\\n    \\n    vector<string> insert(int idKey, string value) \\n    {\\n        arr.at(idKey-1) = value;  \\n        \\n        vector<string> ret{};\\n        \\n        while (lastIndex < arr.size() && arr.at(lastIndex) != \"\")\\n        {\\n            ret.push_back(arr.at(lastIndex++));\\n        }\\n        \\n        return ret;\\n    }\\n    \\nprivate:\\n    vector<string> arr;\\n    int lastIndex{0};\\n};\\n```\\n\\nThanks to [@RedaKerouicha](https://leetcode.com/RedaKerouicha) for pointing out that *vector<string> arr{};* should be *vector<string> arr;* since we initialize it in the constructor.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    OrderedStream(int n) : arr {vector<string>(n, \"\")} \\n    {\\n    }\\n    \\n    vector<string> insert(int idKey, string value) \\n    {\\n        arr.at(idKey-1) = value;  \\n        \\n        vector<string> ret{};\\n        \\n        while (lastIndex < arr.size() && arr.at(lastIndex) != \"\")\\n        {\\n            ret.push_back(arr.at(lastIndex++));\\n        }\\n        \\n        return ret;\\n    }\\n    \\nprivate:\\n    vector<string> arr;\\n    int lastIndex{0};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968548,
                "title": "c-array-easy",
                "content": "```\\nclass OrderedStream {\\npublic:\\n    vector<string>v;\\n    int id=1;\\n    OrderedStream(int n) {\\n        v=vector<string>(n+1,\"\");\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        v[idKey]=value;\\n        vector<string> ans;\\n        while(id<v.size() && v[id]!=\"\")ans.push_back(v[id++]);\\n        return ans;        \\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    vector<string>v;\\n    int id=1;\\n    OrderedStream(int n) {\\n        v=vector<string>(n+1,\"\");\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        v[idKey]=value;\\n        vector<string> ans;\\n        while(id<v.size() && v[id]!=\"\")ans.push_back(v[id++]);\\n        return ans;        \\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949000,
                "title": "c-python-vector-based-hashmap-global-tracking-index",
                "content": "[C++/Python] vector based hashmap & global tracking index\\n\\nApproach 1: vector based hashmap + global tracking index (C++ version)\\n```\\nclass OrderedStream { // BEST: use global index to track order 1~n\\npublic:\\n    OrderedStream(int n):_vs(n+1), _idx(1) { }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        _vs[idKey]=value;\\n        vector<string> ans;\\n        while(_idx< _vs.size() && !_vs[_idx].empty())\\n            ans.push_back(_vs[_idx++]);\\n        return ans;\\n    }\\nprivate:\\n    vector<string> _vs;\\n    int _idx;\\n};\\n```\\n\\nApproach 1: Python\\n```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self._vs = [None]*(n+1)\\n        self._ptr = 1\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self._vs[idKey] = value\\n        ans = []\\n        while self._ptr < len(self._vs) and _vs[self._ptr]:\\n            ans.append(_vs[self._ptr])\\n            self._ptr+=1\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass OrderedStream { // BEST: use global index to track order 1~n\\npublic:\\n    OrderedStream(int n):_vs(n+1), _idx(1) { }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        _vs[idKey]=value;\\n        vector<string> ans;\\n        while(_idx< _vs.size() && !_vs[_idx].empty())\\n            ans.push_back(_vs[_idx++]);\\n        return ans;\\n    }\\nprivate:\\n    vector<string> _vs;\\n    int _idx;\\n};\\n```\n```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self._vs = [None]*(n+1)\\n        self._ptr = 1\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self._vs[idKey] = value\\n        ans = []\\n        while self._ptr < len(self._vs) and _vs[self._ptr]:\\n            ans.append(_vs[self._ptr])\\n            self._ptr+=1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825983,
                "title": "simple-python-solution-faster-than-99-28",
                "content": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.start = 1\\n        self.ls = [None]*(n+1)\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.ls[idKey] = value\\n        if self.ls[self.start] is None:\\n            return []\\n        \\n        ans = []\\n        \\n        while self.start <= self.n and self.ls[self.start] is not None:\\n            ans.append(self.ls[self.start])\\n            self.start+=1\\n        \\n        return ans\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```\\n\\nIf there are any questions do comment",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.start = 1\\n        self.ls = [None]*(n+1)\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.ls[idKey] = value\\n        if self.ls[self.start] is None:\\n            return []\\n        \\n        ans = []\\n        \\n        while self.start <= self.n and self.ls[self.start] is not None:\\n            ans.append(self.ls[self.start])\\n            self.start+=1\\n        \\n        return ans\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789325,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass OrderedStream {\\n    Map<Integer, String> stream;\\n    int ptr; // intialize ptr, then find the longest contiguous increasing sequence of ids from the ptr\\n    public OrderedStream(int n) {\\n        this.stream = new HashMap<>();\\n        this.ptr = 1;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        stream.put(idKey, value);\\n        \\n        List<String> result = new ArrayList<>();\\n        \\n\\t\\t// if the id which the ptr is currently pointing to, is populated, find the longest contiguous sequence of data (chunks) available, else return empty list\\n        while(stream.containsKey(ptr))\\n        {\\n\\t\\t//increment the ptr to next id until we reach an id that is not yet populated. Next time we\\'ll start reading data from that id if it gets populated.\\n            result.add(stream.get(ptr++));\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream obj = new OrderedStream(n);\\n * List<String> param_1 = obj.insert(idKey,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n    Map<Integer, String> stream;\\n    int ptr; // intialize ptr, then find the longest contiguous increasing sequence of ids from the ptr\\n    public OrderedStream(int n) {\\n        this.stream = new HashMap<>();\\n        this.ptr = 1;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        stream.put(idKey, value);\\n        \\n        List<String> result = new ArrayList<>();\\n        \\n\\t\\t// if the id which the ptr is currently pointing to, is populated, find the longest contiguous sequence of data (chunks) available, else return empty list\\n        while(stream.containsKey(ptr))\\n        {\\n\\t\\t//increment the ptr to next id until we reach an id that is not yet populated. Next time we\\'ll start reading data from that id if it gets populated.\\n            result.add(stream.get(ptr++));\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream obj = new OrderedStream(n);\\n * List<String> param_1 = obj.insert(idKey,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772940,
                "title": "java-hashmap-solution",
                "content": "```\\nclass OrderedStream {\\n\\n    Map<Integer, String> store;\\n    int lastIndex = 0;\\n\\n    public OrderedStream(int n) {\\n        store = new HashMap<>(n);\\n    }\\n\\n    public List<String> insert(int idKey, String value) {\\n        List<String> res = new ArrayList<>();\\n        store.put(idKey, value);\\n        while(store.containsKey(lastIndex+1)) {\\n            res.add(store.get(++lastIndex));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n\\n    Map<Integer, String> store;\\n    int lastIndex = 0;\\n\\n    public OrderedStream(int n) {\\n        store = new HashMap<>(n);\\n    }\\n\\n    public List<String> insert(int idKey, String value) {\\n        List<String> res = new ArrayList<>();\\n        store.put(idKey, value);\\n        while(store.containsKey(lastIndex+1)) {\\n            res.add(store.get(++lastIndex));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767811,
                "title": "cpp-solution",
                "content": "```\\nclass OrderedStream {\\n    vector<string> strm;\\n    int cptr = 0;\\npublic:\\n    OrderedStream(int n) {\\n        strm.resize(n);\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        strm[idKey - 1] = value;\\n        vector<string> rstrm;\\n        while(cptr < strm.size() and strm[cptr] != \"\")\\n            rstrm.push_back(strm[cptr++]);\\n        return rstrm;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\n    vector<string> strm;\\n    int cptr = 0;\\npublic:\\n    OrderedStream(int n) {\\n        strm.resize(n);\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        strm[idKey - 1] = value;\\n        vector<string> rstrm;\\n        while(cptr < strm.size() and strm[cptr] != \"\")\\n            rstrm.push_back(strm[cptr++]);\\n        return rstrm;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736416,
                "title": "rust-solution-with-hashmap",
                "content": "Since there is only one rust-tagged solution for this problem, I will post another one which is \\ntaken from here https://rustgym.com/leetcode/1656\\n\\n```rust\\nuse std::collections::HashMap;\\n\\nstruct OrderedStream {\\n    kv: HashMap<i32, String>,\\n    n: i32, \\n    i: i32,\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl OrderedStream {\\n\\n    fn new(n: i32) -> Self {\\n        OrderedStream {\\n            kv: HashMap::new(),\\n            n: n,\\n            i: 1\\n        }\\n    }\\n    \\n    fn insert(&mut self, id_key: i32, value: String) -> Vec<String> {\\n        self.kv.insert(id_key, value);\\n        let mut res: Vec<String> = Vec::new();\\n        if self.i == id_key {\\n            for j in id_key..=self.n {\\n                if let Some(v) = self.kv.get(&j) {\\n                    res.push(v.to_string());\\n                    self.i += 1;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nstruct OrderedStream {\\n    kv: HashMap<i32, String>,\\n    n: i32, \\n    i: i32,\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl OrderedStream {\\n\\n    fn new(n: i32) -> Self {\\n        OrderedStream {\\n            kv: HashMap::new(),\\n            n: n,\\n            i: 1\\n        }\\n    }\\n    \\n    fn insert(&mut self, id_key: i32, value: String) -> Vec<String> {\\n        self.kv.insert(id_key, value);\\n        let mut res: Vec<String> = Vec::new();\\n        if self.i == id_key {\\n            for j in id_key..=self.n {\\n                if let Some(v) = self.kv.get(&j) {\\n                    res.push(v.to_string());\\n                    self.i += 1;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1669129,
                "title": "python-solution-based-on-heap",
                "content": "```\\nimport heapq\\n\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.idx = 1\\n        self.heap = []\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        result = []\\n        \\n        if idKey == self.idx:\\n            result.append(value)\\n            self.idx += 1\\n            \\n            while self.heap and self.heap[0][0] == self.idx:\\n                result.append(heapq.heappop(self.heap)[1])\\n                self.idx += 1\\n        else:\\n            heapq.heappush(self.heap, (idKey, value))\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.idx = 1\\n        self.heap = []\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        result = []\\n        \\n        if idKey == self.idx:\\n            result.append(value)\\n            self.idx += 1\\n            \\n            while self.heap and self.heap[0][0] == self.idx:\\n                result.append(heapq.heappop(self.heap)[1])\\n                self.idx += 1\\n        else:\\n            heapq.heappush(self.heap, (idKey, value))\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663270,
                "title": "python3-solution",
                "content": "```python\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.index=0\\n        self.lt=[None]*n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.lt[idKey-1]=value\\n        if idKey!=self.index+1:\\n            return []\\n        num=0\\n        output=list()\\n        for ele in self.lt[self.index:]:\\n            if ele is None:\\n                break\\n            output.append(ele)\\n            num+=1\\n        self.index+=num\\n        return output\\n```",
                "solutionTags": [],
                "code": "```python\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.index=0\\n        self.lt=[None]*n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.lt[idKey-1]=value\\n        if idKey!=self.index+1:\\n            return []\\n        num=0\\n        output=list()\\n        for ele in self.lt[self.index:]:\\n            if ele is None:\\n                break\\n            output.append(ele)\\n            num+=1\\n        self.index+=num\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651350,
                "title": "java-explained-the-confusing-description-clean-solution",
                "content": "// Confusing descriptoin. Here is what I understood from the GIF\\n// when insert() is called, return the longest list that starts at index of pointer. If there is not an elemnt at pointer(start), then return empty list\\n\\n// The POINTER is the next START window\\n\\n// TC : O(N) -> avg run time -> since we iterate the array once\\n// SC : O(N) -> to store keys in worst case\\n```\\nclass OrderedStream {\\n\\n    private String[] arr;\\n    private int currentPtr;\\n    \\n    public OrderedStream(int n) {\\n        this.arr = new String[n];\\n        this.currentPtr = 0;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        arr[idKey-1] = value;\\n        \\n        List<String> result = new ArrayList<>();\\n        for(int i = currentPtr; i < arr.length; i++) { // run only starts from pointer, we do not need to start from 0\\n            if(arr[i] == null) break; // if there is no element, this breaks the chain so come out of the for loop\\n            result.add(arr[i]);\\n            currentPtr++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\n\\n    private String[] arr;\\n    private int currentPtr;\\n    \\n    public OrderedStream(int n) {\\n        this.arr = new String[n];\\n        this.currentPtr = 0;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        arr[idKey-1] = value;\\n        \\n        List<String> result = new ArrayList<>();\\n        for(int i = currentPtr; i < arr.length; i++) { // run only starts from pointer, we do not need to start from 0\\n            if(arr[i] == null) break; // if there is no element, this breaks the chain so come out of the for loop\\n            result.add(arr[i]);\\n            currentPtr++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628771,
                "title": "c-vector",
                "content": "```\\nclass OrderedStream {\\n    vector<string> data;\\n    int N;\\n    int ptr;\\npublic:\\n    OrderedStream(int n) : data(n), N{n}, ptr{1} {\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        data[id-1] = move(value);\\n        vector<string> ret;\\n        if(ptr != id)\\n            return ret;\\n        while(ptr <= N) {\\n            if(data[ptr-1] == \"\")\\n                break;\\n            ret.emplace_back(data[ptr-1]);\\n            ++ptr;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\n    vector<string> data;\\n    int N;\\n    int ptr;\\npublic:\\n    OrderedStream(int n) : data(n), N{n}, ptr{1} {\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        data[id-1] = move(value);\\n        vector<string> ret;\\n        if(ptr != id)\\n            return ret;\\n        while(ptr <= N) {\\n            if(data[ptr-1] == \"\")\\n                break;\\n            ret.emplace_back(data[ptr-1]);\\n            ++ptr;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604906,
                "title": "c-t-o-n-s-o-n-vector-approach",
                "content": "```\\nclass OrderedStream final {\\npublic:\\n    explicit OrderedStream() noexcept = default;\\n    explicit OrderedStream(const OrderedStream&) noexcept = default;\\n\\n    OrderedStream(int n) : stream_(std::vector<std::string>(n, \"\")), current_index_(0) {}\\n\\n    std::vector<std::string> insert(int id, std::string value) {\\n        std::vector<std::string> response;\\n        stream_[id - 1] = std::move(value);\\n\\n        for (; current_index_ < stream_.size(); ++current_index_) {\\n            if (!stream_[current_index_].empty()) {\\n                response.push_back(stream_[current_index_]);\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return response;\\n    }\\n\\nprivate:\\n    std::vector<std::string> stream_;\\n    int current_index_;\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(id,value);\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream final {\\npublic:\\n    explicit OrderedStream() noexcept = default;\\n    explicit OrderedStream(const OrderedStream&) noexcept = default;\\n\\n    OrderedStream(int n) : stream_(std::vector<std::string>(n, \"\")), current_index_(0) {}\\n\\n    std::vector<std::string> insert(int id, std::string value) {\\n        std::vector<std::string> response;\\n        stream_[id - 1] = std::move(value);\\n\\n        for (; current_index_ < stream_.size(); ++current_index_) {\\n            if (!stream_[current_index_].empty()) {\\n                response.push_back(stream_[current_index_]);\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return response;\\n    }\\n\\nprivate:\\n    std::vector<std::string> stream_;\\n    int current_index_;\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(id,value);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584120,
                "title": "swift-7-sloc-292ms-beats-100-1656-design-an-ordered-stream",
                "content": "```swift\\nclass OrderedStream {    \\n    var buffer: [String]\\n    var baseIndex: Int = 0\\n\\n    init(_ n: Int) {\\n        buffer = [String](repeating: \"\", count: n)\\n    }\\n    \\n    func insert(_ idKey: Int, _ value: String) -> [String] {\\n        buffer[idKey - 1] = value\\n        let output = buffer[baseIndex...].prefix { !$0.isEmpty }\\n        baseIndex += output.count\\n        return Array(output)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass OrderedStream {    \\n    var buffer: [String]\\n    var baseIndex: Int = 0\\n\\n    init(_ n: Int) {\\n        buffer = [String](repeating: \"\", count: n)\\n    }\\n    \\n    func insert(_ idKey: Int, _ value: String) -> [String] {\\n        buffer[idKey - 1] = value\\n        let output = buffer[baseIndex...].prefix { !$0.isEmpty }\\n        baseIndex += output.count\\n        return Array(output)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545690,
                "title": "simple-python-o-n-time-and-o-n-speace",
                "content": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.seen = [0] * n\\n        self.ptr = 0\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.seen[idKey - 1] = value\\n        if idKey - 1 == self.ptr:\\n            # return all continuous values\\n            j = idKey - 1\\n            result = []\\n            while j < len(self.seen) and self.seen[j] != 0:\\n                result.append(self.seen[j])\\n                j += 1\\n            self.ptr = j\\n            return result\\n        elif idKey - 1 > self.ptr:\\n            return []\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.seen = [0] * n\\n        self.ptr = 0\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.seen[idKey - 1] = value\\n        if idKey - 1 == self.ptr:\\n            # return all continuous values\\n            j = idKey - 1\\n            result = []\\n            while j < len(self.seen) and self.seen[j] != 0:\\n                result.append(self.seen[j])\\n                j += 1\\n            self.ptr = j\\n            return result\\n        elif idKey - 1 > self.ptr:\\n            return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515116,
                "title": "python",
                "content": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.index = 0\\n        self.n = n\\n        self.map = [None]*n\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.map[idKey-1] = value\\n        if idKey - 1 == self.index:\\n            while self.index < self.n and self.map[self.index]:\\n                self.index += 1\\n        return self.map[idKey-1: self.index]\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.index = 0\\n        self.n = n\\n        self.map = [None]*n\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.map[idKey-1] = value\\n        if idKey - 1 == self.index:\\n            while self.index < self.n and self.map[self.index]:\\n                self.index += 1\\n        return self.map[idKey-1: self.index]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458198,
                "title": "ruby-solution",
                "content": "```\\nclass OrderedStream\\n  def initialize(n)\\n    @cap = n\\n    @map = {}\\n    @start = 1\\n  end\\n\\n  def insert(id_key, value)\\n    return [] if id_key > cap || id_key < 1\\n    ans = []\\n    \\n    map[id_key] = value\\n    if start == id_key\\n      while map[start]\\n        ans.push(map[start])\\n        @start+=1\\n      end\\n    end\\n    \\n    ans\\n  end\\n  \\n  private\\n  \\n  attr_accessor :cap, :map, :start\\nend\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream\\n  def initialize(n)\\n    @cap = n\\n    @map = {}\\n    @start = 1\\n  end\\n\\n  def insert(id_key, value)\\n    return [] if id_key > cap || id_key < 1\\n    ans = []\\n    \\n    map[id_key] = value\\n    if start == id_key\\n      while map[start]\\n        ans.push(map[start])\\n        @start+=1\\n      end\\n    end\\n    \\n    ans\\n  end\\n  \\n  private\\n  \\n  attr_accessor :cap, :map, :start\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444616,
                "title": "java-hashmap-min-heap",
                "content": "class OrderedStream {`\\n\\n    Map<Integer, String> idMap;\\n    Queue<Integer> queue;\\n    int lastPrintedIndex;\\n    \\n    public OrderedStream(int n) {\\n        idMap = new HashMap<>(n);\\n        queue = new PriorityQueue<>(); //Min heap Can we use a binary array instead? \\n        lastPrintedIndex = 1;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        idMap.put(idKey, value);\\n        queue.offer(idKey);\\n        List<String> chunk = new ArrayList<>();\\n        \\n        while(!queue.isEmpty() &&lastPrintedIndex == queue.peek())\\n        {\\n            chunk.add(idMap.get(queue.poll()));\\n            lastPrintedIndex++;          \\n        }\\n        return chunk;\\n    }\\n}\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream obj = new OrderedStream(n);\\n * List<String> param_1 = obj.insert(idKey,value);\\n */",
                "solutionTags": [],
                "code": "class OrderedStream {`\\n\\n    Map<Integer, String> idMap;\\n    Queue<Integer> queue;\\n    int lastPrintedIndex;\\n    \\n    public OrderedStream(int n) {\\n        idMap = new HashMap<>(n);\\n        queue = new PriorityQueue<>(); //Min heap Can we use a binary array instead? \\n        lastPrintedIndex = 1;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        idMap.put(idKey, value);\\n        queue.offer(idKey);\\n        List<String> chunk = new ArrayList<>();\\n        \\n        while(!queue.isEmpty() &&lastPrintedIndex == queue.peek())\\n        {\\n            chunk.add(idMap.get(queue.poll()));\\n            lastPrintedIndex++;          \\n        }\\n        return chunk;\\n    }\\n}\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream obj = new OrderedStream(n);\\n * List<String> param_1 = obj.insert(idKey,value);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1389616,
                "title": "c-easy-to-understand",
                "content": "```\\nclass OrderedStream {\\n    int curr = 1;\\n    vector<string> values;\\n    int n;\\n    \\npublic:\\n    OrderedStream(int n) {\\n        values.resize(n+1, \"\");\\n        this->n = n;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        values[idKey] = value;\\n        vector<string> answer;\\n        \\n        while((curr <= n) && (values[curr] != \"\"))\\n        {\\n            answer.push_back(values[curr]);\\n            curr++;\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\n    int curr = 1;\\n    vector<string> values;\\n    int n;\\n    \\npublic:\\n    OrderedStream(int n) {\\n        values.resize(n+1, \"\");\\n        this->n = n;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        values[idKey] = value;\\n        vector<string> answer;\\n        \\n        while((curr <= n) && (values[curr] != \"\"))\\n        {\\n            answer.push_back(values[curr]);\\n            curr++;\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381636,
                "title": "clean-python-o-n-space-and-time",
                "content": "```\\nclass OrderedStream(object):\\n\\n    def __init__(self, n):\\n        \"\"\"\\n        :type n: int\\n        \"\"\"\\n        self.currentPointer = 0\\n        self.n = n\\n        self.array = [None for _ in range(n)]\\n\\n    def insert(self, idKey, value):\\n        \"\"\"\\n        :type idKey: int\\n        :type value: str\\n        :rtype: List[str]\\n        \"\"\"\\n        array = []\\n        self.array[idKey-1] = value\\n        for i in range(self.currentPointer, self.n):\\n            if not self.array[i]:\\n                break\\n            array.append(self.array[i])\\n        self.currentPointer = i\\n        return array\\n",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream(object):\\n\\n    def __init__(self, n):\\n        \"\"\"\\n        :type n: int\\n        \"\"\"\\n        self.currentPointer = 0\\n        self.n = n\\n        self.array = [None for _ in range(n)]\\n\\n    def insert(self, idKey, value):\\n        \"\"\"\\n        :type idKey: int\\n        :type value: str\\n        :rtype: List[str]\\n        \"\"\"\\n        array = []\\n        self.array[idKey-1] = value\\n        for i in range(self.currentPointer, self.n):\\n            if not self.array[i]:\\n                break\\n            array.append(self.array[i])\\n        self.currentPointer = i\\n        return array\\n",
                "codeTag": "Java"
            },
            {
                "id": 1374917,
                "title": "java-simple-solution",
                "content": "**Runtime: 68 ms, faster than 65.17% of Java online submissions for Design an Ordered Stream.\\nMemory Usage: 40.4 MB, less than 56.40% of Java online submissions for Design an Ordered Stream.**\\n```\\nclass OrderedStream {\\n    int ptr;\\n    String []arr;\\n    public OrderedStream(int n) {\\n        arr = new String[n];\\n        ptr = 0;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        ArrayList<String> res = new ArrayList<>();\\n        arr[idKey-1] = value;\\n        while(ptr < arr.length && arr[ptr] != null)res.add(arr[ptr++]);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n    int ptr;\\n    String []arr;\\n    public OrderedStream(int n) {\\n        arr = new String[n];\\n        ptr = 0;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        ArrayList<String> res = new ArrayList<>();\\n        arr[idKey-1] = value;\\n        while(ptr < arr.length && arr[ptr] != null)res.add(arr[ptr++]);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357807,
                "title": "java-solution-using-array",
                "content": "\\tclass OrderedStream {\\n    String[] words = null;\\n    int ptr = 0;\\n    public OrderedStream(int n) {\\n        this.words = new String[n];\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        words[idKey-1] = value;\\n        List<String> res = new ArrayList<>();\\n        if(idKey-1 == ptr)\\n        {\\n            while(ptr < words.length && words[ptr] != null)\\n            {\\n                res.add(words[ptr++]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "\\tclass OrderedStream {\\n    String[] words = null;\\n    int ptr = 0;\\n    public OrderedStream(int n) {\\n        this.words = new String[n];\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        words[idKey-1] = value;\\n        List<String> res = new ArrayList<>();\\n        if(idKey-1 == ptr)\\n        {\\n            while(ptr < words.length && words[ptr] != null)\\n            {\\n                res.add(words[ptr++]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1354937,
                "title": "c-faster-solution-using-an-string-array",
                "content": "```\\npublic class OrderedStream {\\n    string[] arr = new string[]{};\\n    int pointer = 0;\\n    public OrderedStream(int n) {\\n        arr = new string[n];\\n    }\\n    \\n    public IList<string> Insert(int idKey, string value) {\\n           arr[idKey-1] = value;\\n        IList<string> list = new List<string>();\\n        while(pointer < arr.Length && arr[pointer] != null)\\n        {\\n            list.Add(arr[pointer++]);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class OrderedStream {\\n    string[] arr = new string[]{};\\n    int pointer = 0;\\n    public OrderedStream(int n) {\\n        arr = new string[n];\\n    }\\n    \\n    public IList<string> Insert(int idKey, string value) {\\n           arr[idKey-1] = value;\\n        IList<string> list = new List<string>();\\n        while(pointer < arr.Length && arr[pointer] != null)\\n        {\\n            list.Add(arr[pointer++]);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314138,
                "title": "java-simple-solution-using-arrays-and-single-pointer",
                "content": "```\\nclass OrderedStream {\\n    private String sArray[];\\n    private int ptr;\\n    public OrderedStream(int n) {\\n         sArray =  new String[n+1];\\n         ptr = 1;        \\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        List<String> list = new ArrayList<>();\\n        sArray[idKey] = value;\\n        if(sArray[ptr] == null)\\n            return list;\\n        else{\\n            while(sArray[ptr]!=null ){\\n                list.add(sArray[ptr]);\\n                ptr++;\\n                if(ptr >= sArray.length)\\n                    break;\\n            }\\n            return list;\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\n    private String sArray[];\\n    private int ptr;\\n    public OrderedStream(int n) {\\n         sArray =  new String[n+1];\\n         ptr = 1;        \\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        List<String> list = new ArrayList<>();\\n        sArray[idKey] = value;\\n        if(sArray[ptr] == null)\\n            return list;\\n        else{\\n            while(sArray[ptr]!=null ){\\n                list.add(sArray[ptr]);\\n                ptr++;\\n                if(ptr >= sArray.length)\\n                    break;\\n            }\\n            return list;\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285878,
                "title": "simple-solution-using-python3",
                "content": "```\\ndef insert(self, idKey: int, value: str) -> List[str]:\\n        self.data[idKey-1] = value           #enter value at the given idKey\\n        temp=[] \\n        if self.data[self.ptr]==None:        #check if there\\'s a value present at the current pointer value\\n            return []                                   #return empty array if yes\\n        else:\\n            while self.data[self.ptr]!=None:         #else iterate through the array until an empty slot is found\\n                temp.append(self.data[self.ptr])    # append all the values to temporary array \"temp\"\\n                self.ptr+=1                    \\n                if len(self.data)==self.ptr:              #return temp array when you reach the end of array.\\n                    return temp\\n            return temp                                       # or return temp when empty slot is found\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef insert(self, idKey: int, value: str) -> List[str]:\\n        self.data[idKey-1] = value           #enter value at the given idKey\\n        temp=[] \\n        if self.data[self.ptr]==None:        #check if there\\'s a value present at the current pointer value\\n            return []                                   #return empty array if yes\\n        else:\\n            while self.data[self.ptr]!=None:         #else iterate through the array until an empty slot is found\\n                temp.append(self.data[self.ptr])    # append all the values to temporary array \"temp\"\\n                self.ptr+=1                    \\n                if len(self.data)==self.ptr:              #return temp array when you reach the end of array.\\n                    return temp\\n            return temp                                       # or return temp when empty slot is found\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1283945,
                "title": "python3-solution-faster-than-62-14-less-than-81-58-memory-usage",
                "content": "To be honest for a python solution we don\\'t need to know the size of the data structure so we can simply disregard the `\\'n\\'` value for our initializer. All we really need is to set a pointer to the first position(1 per problem\\'s constraints) & an easy place to hold our data which would be a lovely hashmap. \\n\\n\\tdef __init__(self, n: int):\\n\\t\\t\\tself.ptr = 1\\n\\t\\t\\tself.data_holder = {}\\n\\t\\t\\t\\nFor insert, just break it down into substeps:\\n1. Insert data. \\n2. Create a list for the return of the stream. Your list will start appending from the data holder where pointer will be your key that will get incremented by 1 on each iteration. If such key is not in the data holder, then we can just return the list we have. This will aslo take care of the start position of the pointer for the next insert. \\n\\n```\\ndef insert(self, idKey: int, value: str) -> List[str]:\\n        self.data_holder[idKey] = value\\n        l = []\\n        while self.data_holder.get(self.ptr, False): \\n            l.append(self.data_holder[self.ptr])\\n            self.ptr += 1 \\n        return l\\n```\\n\\nPlease lmk how this may be optimized or done in a more \\'pythonic\\' like prettier way. Ty.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef insert(self, idKey: int, value: str) -> List[str]:\\n        self.data_holder[idKey] = value\\n        l = []\\n        while self.data_holder.get(self.ptr, False): \\n            l.append(self.data_holder[self.ptr])\\n            self.ptr += 1 \\n        return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1273244,
                "title": "python-3-solution-with-explanation",
                "content": "Problem analysis:\\nwe need ot record all inputs but only return \"in-order\". As such, we need a way to remember both the value (we need to return this) and the idkey (to know if we should return the string). This is stored in an attribute called next. There is another attriubute called lookout used to record whether the desired idkey has been entered and whether to begin returning values.\\n```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.next = {}\\n        self.lookout = 1\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        #we always append idkey and value into self.next\\n        self.next[idKey] = value\\n        output = []\\n        while self.lookout <= self.n:\\n            #it starts from 1 so we just need to iterate through keys and find the longest consecutive sequence of arrays and return it\\n            if self.lookout in self.next.keys():\\n                output.append(self.next[self.lookout])\\n                self.lookout += 1\\n            else:\\n                break\\n        return output",
                "solutionTags": [],
                "code": "Problem analysis:\\nwe need ot record all inputs but only return \"in-order\". As such, we need a way to remember both the value (we need to return this) and the idkey (to know if we should return the string). This is stored in an attribute called next. There is another attriubute called lookout used to record whether the desired idkey has been entered and whether to begin returning values.\\n```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.next = {}\\n        self.lookout = 1\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        #we always append idkey and value into self.next\\n        self.next[idKey] = value\\n        output = []\\n        while self.lookout <= self.n:\\n            #it starts from 1 so we just need to iterate through keys and find the longest consecutive sequence of arrays and return it\\n            if self.lookout in self.next.keys():\\n                output.append(self.next[self.lookout])\\n                self.lookout += 1\\n            else:\\n                break\\n        return output",
                "codeTag": "Java"
            },
            {
                "id": 1245120,
                "title": "c-easy-solution",
                "content": "```\\nclass OrderedStream {\\npublic:\\n    \\n    vector<string>result;\\n    int ptr;\\n    OrderedStream(int n) {\\n        result.resize(n);\\n        ptr = 1;\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        result[id-1] = value;\\n        vector<string> answer;\\n        \\n        if(ptr == id) {\\n            int i = ptr - 1;\\n            \\n            for(; i < result.size(); i++) {\\n                if(result[i] == \"\")\\n                    break;\\n                answer.push_back(result[i]);\\n            }\\n            ptr = i+1;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    \\n    vector<string>result;\\n    int ptr;\\n    OrderedStream(int n) {\\n        result.resize(n);\\n        ptr = 1;\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        result[id-1] = value;\\n        vector<string> answer;\\n        \\n        if(ptr == id) {\\n            int i = ptr - 1;\\n            \\n            for(; i < result.size(); i++) {\\n                if(result[i] == \"\")\\n                    break;\\n                answer.push_back(result[i]);\\n            }\\n            ptr = i+1;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244623,
                "title": "kotlin-easy-one",
                "content": "```\\nclass OrderedStream(n: Int) {\\n    private var orderedStreamArray: Array<String> = Array(n) { \"0\" }\\n    private var pointer = 0\\n\\n    fun insert(idKey: Int, value: String): List<String> {\\n        orderedStreamArray[idKey-1] = value\\n        val tempList = orderedStreamArray.takeWhile { it != \"0\"  }.toList()\\n        return tempList.drop(pointer).apply { pointer = tempList.size }\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream(n: Int) {\\n    private var orderedStreamArray: Array<String> = Array(n) { \"0\" }\\n    private var pointer = 0\\n\\n    fun insert(idKey: Int, value: String): List<String> {\\n        orderedStreamArray[idKey-1] = value\\n        val tempList = orderedStreamArray.takeWhile { it != \"0\"  }.toList()\\n        return tempList.drop(pointer).apply { pointer = tempList.size }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238077,
                "title": "java-faster-than-98-75-memory-less-98-46-easy-to-understand",
                "content": "```java\\nclass OrderedStream {\\n\\n        private int pointer;\\n        private final String[] array;\\n\\n        public OrderedStream(int n) {\\n            array = new String[n];\\n        }\\n\\n        public List<String> insert(int idKey, String value) {\\n            array[idKey - 1] = value;\\n            if(array[pointer] == null) return new ArrayList<>();\\n\\n            List<String> list = new ArrayList<>();\\n            for(int i = pointer; i < array.length; i++) {\\n                if(array[i] == null) {\\n                    pointer = i;\\n                    break;\\n                }\\n                list.add(array[i]);\\n            }\\n            return list;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass OrderedStream {\\n\\n        private int pointer;\\n        private final String[] array;\\n\\n        public OrderedStream(int n) {\\n            array = new String[n];\\n        }\\n\\n        public List<String> insert(int idKey, String value) {\\n            array[idKey - 1] = value;\\n            if(array[pointer] == null) return new ArrayList<>();\\n\\n            List<String> list = new ArrayList<>();\\n            for(int i = pointer; i < array.length; i++) {\\n                if(array[i] == null) {\\n                    pointer = i;\\n                    break;\\n                }\\n                list.add(array[i]);\\n            }\\n            return list;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233780,
                "title": "python-simple-solution",
                "content": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.data = [None] * (n+1)\\n        self.cur = 0\\n        \\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        res = []        \\n        self.data[idKey-1] = value\\n        while self.data[self.cur]:\\n            res.append(self.data[self.cur])\\n            self.cur += 1\\n        return res\\n        \\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.data = [None] * (n+1)\\n        self.cur = 0\\n        \\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        res = []        \\n        self.data[idKey-1] = value\\n        while self.data[self.cur]:\\n            res.append(self.data[self.cur])\\n            self.cur += 1\\n        return res\\n        \\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228756,
                "title": "python-easy-to-understand",
                "content": "I agree with the posters that the description here sucks, but I used the animation to arrive at the code below.\\n\\n```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n\\t\\t#Like the animation, you need to maintain a pointer and an array of size n which is passed through the constructor.\\n        self.pointer = 0\\n        self.array = [None] * n\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n\\t\\t#The idKey is 1-indexed so subtract 1 to make it 0-indexed for an array. Set the value here.\\n        self.array[idKey - 1] = value\\n        res = []\\n        \\n\\t\\t#If you inserted where the pointer is pointing, now you have to loop until the pointer hits a Null value\\n\\t\\t#in the array, or you\\'ve exhausted the array. Again, subtract 1 from the idKey to make it 0 index and start\\n\\t\\t#concatenating your result array with each value you see at the current pointer. And that\\'s your answer.\\n\\t\\t#Notice that the pointer stays where you left it in this loop, don\\'t put it back to 0 again.\\n        if (idKey - 1) == self.pointer:\\n            for i in range(self.pointer, len(self.array)):\\n                if self.array[self.pointer] == None:\\n                    break\\n                res.append(self.array[self.pointer])\\n                self.pointer += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n\\t\\t#Like the animation, you need to maintain a pointer and an array of size n which is passed through the constructor.\\n        self.pointer = 0\\n        self.array = [None] * n\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n\\t\\t#The idKey is 1-indexed so subtract 1 to make it 0-indexed for an array. Set the value here.\\n        self.array[idKey - 1] = value\\n        res = []\\n        \\n\\t\\t#If you inserted where the pointer is pointing, now you have to loop until the pointer hits a Null value\\n\\t\\t#in the array, or you\\'ve exhausted the array. Again, subtract 1 from the idKey to make it 0 index and start\\n\\t\\t#concatenating your result array with each value you see at the current pointer. And that\\'s your answer.\\n\\t\\t#Notice that the pointer stays where you left it in this loop, don\\'t put it back to 0 again.\\n        if (idKey - 1) == self.pointer:\\n            for i in range(self.pointer, len(self.array)):\\n                if self.array[self.pointer] == None:\\n                    break\\n                res.append(self.array[self.pointer])\\n                self.pointer += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144134,
                "title": "c-solution",
                "content": "```\\nclass OrderedStream {\\npublic: \\n    vector<string> vec;\\n    int ptr = 0;\\n    OrderedStream(int n) {\\n        vec.resize(n);\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        vector<string> res;\\n        vec[id - 1] = value;\\n        while(ptr < vec.size() && vec[ptr].size() > 0){\\n            res.push_back(vec[ptr]);\\n            ptr++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\npublic: \\n    vector<string> vec;\\n    int ptr = 0;\\n    OrderedStream(int n) {\\n        vec.resize(n);\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        vector<string> res;\\n        vec[id - 1] = value;\\n        while(ptr < vec.size() && vec[ptr].size() > 0){\\n            res.push_back(vec[ptr]);\\n            ptr++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137729,
                "title": "simple-javascript-w-detailed-explanations",
                "content": "```\\nvar OrderedStream = function(n) {\\n    // Initialize an array with n empty elements\\n    this.stream = new Array(n);\\n};\\n\\nOrderedStream.prototype.insert = function(idKey, value) {\\n    // Set the chunk value of the stream at the given idKey\\n    // NOTE: Since idKey starts at 1, its corresponding index is idKey - 1\\n    const chunkIndex = idKey - 1;\\n    this.stream[chunkIndex] = value;\\n    \\n    // Initialize an empty result array\\n    const result = [];\\n    \\n    // Loop through all chunks in the stream or until an empty chunk is reached\\n    for (let i = 0; i < this.stream.length; i++) {\\n        \\n        // Get the value of the current chunk\\n        const chunkValue = this.stream[i];\\n        \\n        // If the index of the recently inserted chunk or a subsequent non-empty chunk is encountered, add its value to the result\\n        if (chunkValue !== undefined && i >= chunkIndex) {\\n            result.push(chunkValue)\\n        \\n          // If an undefined (empty) chunk is encountered, stop the loop\\n        } else if (chunkValue === undefined) {\\n            break;\\n        }\\n\\n    }\\n    \\n    // Return the result array\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar OrderedStream = function(n) {\\n    // Initialize an array with n empty elements\\n    this.stream = new Array(n);\\n};\\n\\nOrderedStream.prototype.insert = function(idKey, value) {\\n    // Set the chunk value of the stream at the given idKey\\n    // NOTE: Since idKey starts at 1, its corresponding index is idKey - 1\\n    const chunkIndex = idKey - 1;\\n    this.stream[chunkIndex] = value;\\n    \\n    // Initialize an empty result array\\n    const result = [];\\n    \\n    // Loop through all chunks in the stream or until an empty chunk is reached\\n    for (let i = 0; i < this.stream.length; i++) {\\n        \\n        // Get the value of the current chunk\\n        const chunkValue = this.stream[i];\\n        \\n        // If the index of the recently inserted chunk or a subsequent non-empty chunk is encountered, add its value to the result\\n        if (chunkValue !== undefined && i >= chunkIndex) {\\n            result.push(chunkValue)\\n        \\n          // If an undefined (empty) chunk is encountered, stop the loop\\n        } else if (chunkValue === undefined) {\\n            break;\\n        }\\n\\n    }\\n    \\n    // Return the result array\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1116340,
                "title": "c-concise-solution",
                "content": "```\\nvector<string> v;\\nint i = 0;\\n\\nOrderedStream(int n) : v(n) {}\\n\\nvector<string> insert(int idKey, string value, vector<string> res = {}) {\\n\\tfor (v[idKey - 1] = value; i < v.size() && !v[i].empty();) res.push_back(v[i++]);\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> v;\\nint i = 0;\\n\\nOrderedStream(int n) : v(n) {}\\n\\nvector<string> insert(int idKey, string value, vector<string> res = {}) {\\n\\tfor (v[idKey - 1] = value; i < v.size() && !v[i].empty();) res.push_back(v[i++]);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113098,
                "title": "javascript-simple-fast-solution",
                "content": "```\\n/**\\n * @param {number} n\\n */\\nvar OrderedStream = function(n) {\\n    this.map = {};\\n    this.size = n;\\n    \\n    for (var i = 1; i <= this.size; i++) {\\n        this.map[i] = \\'\\';\\n    }\\n};\\n\\n/** \\n * @param {number} idKey \\n * @param {string} value\\n * @return {string[]}\\n */\\nOrderedStream.prototype.insert = function(idKey, value) {\\n    this.map[idKey] = value;\\n    var result = [];\\n    \\n    if (idKey > 1) {\\n        for (let i = 1; i < idKey; i++) {\\n            if (!this.map[i]) {\\n                return [];\\n            }\\n        }\\n    }\\n    \\n    result.push(value);\\n    \\n    if (idKey + 1 <= this.size) {\\n        for (var i = idKey + 1; i <= this.size; i++) {\\n            if (this.map[i]) {\\n                result.push(this.map[i]);\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n\\n/** \\n * Your OrderedStream object will be instantiated and called as such:\\n * var obj = new OrderedStream(n)\\n * var param_1 = obj.insert(idKey,value)\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n */\\nvar OrderedStream = function(n) {\\n    this.map = {};\\n    this.size = n;\\n    \\n    for (var i = 1; i <= this.size; i++) {\\n        this.map[i] = \\'\\';\\n    }\\n};\\n\\n/** \\n * @param {number} idKey \\n * @param {string} value\\n * @return {string[]}\\n */\\nOrderedStream.prototype.insert = function(idKey, value) {\\n    this.map[idKey] = value;\\n    var result = [];\\n    \\n    if (idKey > 1) {\\n        for (let i = 1; i < idKey; i++) {\\n            if (!this.map[i]) {\\n                return [];\\n            }\\n        }\\n    }\\n    \\n    result.push(value);\\n    \\n    if (idKey + 1 <= this.size) {\\n        for (var i = idKey + 1; i <= this.size; i++) {\\n            if (this.map[i]) {\\n                result.push(this.map[i]);\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n\\n/** \\n * Your OrderedStream object will be instantiated and called as such:\\n * var obj = new OrderedStream(n)\\n * var param_1 = obj.insert(idKey,value)\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1102047,
                "title": "c-very-simple-solution-with-a-dictionary-and-while-loop",
                "content": "```\\npublic class OrderedStream {\\n\\n    private int _readPosition = 1;\\n    private readonly Dictionary<int, string> _internalDict = new Dictionary<int, string>();\\n    \\n    public OrderedStream(int n) {\\n    }\\n    \\n    public IList<string> Insert(int idKey, string value) {\\n        _internalDict[idKey] = value;\\n        \\n        return Read();\\n    }\\n    \\n    private IList<string> Read() {\\n        \\n        var retVal = new List<string>();\\n        \\n        while(_internalDict.TryGetValue(_readPosition, out var value)){\\n            retVal.Add(value);\\n            _readPosition++;\\n        }\\n        \\n       return retVal;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "```\\npublic class OrderedStream {\\n\\n    private int _readPosition = 1;\\n    private readonly Dictionary<int, string> _internalDict = new Dictionary<int, string>();\\n    \\n    public OrderedStream(int n) {\\n    }\\n    \\n    public IList<string> Insert(int idKey, string value) {\\n        _internalDict[idKey] = value;\\n        \\n        return Read();\\n    }\\n    \\n    private IList<string> Read() {\\n        \\n        var retVal = new List<string>();\\n        \\n        while(_internalDict.TryGetValue(_readPosition, out var value)){\\n            retVal.Add(value);\\n            _readPosition++;\\n        }\\n        \\n       return retVal;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1098821,
                "title": "python-98-low-memory-faster-than-93",
                "content": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.stream = [None]*(n+1)\\n        self.lowestId = 1\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        nextEl = []\\n        self.stream[idKey] = value\\n        if idKey > self.lowestId:\\n          return []\\n        else:\\n          for i in range(self.lowestId,len(self.stream)):\\n            if self.stream[i] is None:\\n              self.lowestId = i\\n              break\\n            else:\\n              nextEl.append(self.stream[i])\\n        return nextEl    \\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.stream = [None]*(n+1)\\n        self.lowestId = 1\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        nextEl = []\\n        self.stream[idKey] = value\\n        if idKey > self.lowestId:\\n          return []\\n        else:\\n          for i in range(self.lowestId,len(self.stream)):\\n            if self.stream[i] is None:\\n              self.lowestId = i\\n              break\\n            else:\\n              nextEl.append(self.stream[i])\\n        return nextEl    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094204,
                "title": "rust-create-the-chunk-to-return-from-insert-using-an-iterator",
                "content": "This solution produces the return value for our `OrderedStream::insert()` method using iterators after the insertion takes place:\\n\\n```\\n#[derive(Default)]\\nstruct OrderedStream {\\n    buf: Vec<Option<String>>,\\n    idx: usize,\\n}\\n\\nimpl OrderedStream {\\n    fn new(n: i32) -> Self {\\n        Default::default()\\n    }\\n\\n    fn insert(&mut self, id_key: i32, value: String) -> Vec<String> {\\n        self.buf.resize(self.buf.len().max(id_key as _), None);\\n        self.buf[id_key as usize - 1] = Some(value);\\n        let chunk: Vec<_> = self.buf[self.idx..]\\n            .iter()\\n            .take_while(|x| x.is_some())\\n            .map(|x| x.clone().unwrap())\\n            .collect();\\n        self.idx += chunk.len();\\n        chunk\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#[derive(Default)]\\nstruct OrderedStream {\\n    buf: Vec<Option<String>>,\\n    idx: usize,\\n}\\n\\nimpl OrderedStream {\\n    fn new(n: i32) -> Self {\\n        Default::default()\\n    }\\n\\n    fn insert(&mut self, id_key: i32, value: String) -> Vec<String> {\\n        self.buf.resize(self.buf.len().max(id_key as _), None);\\n        self.buf[id_key as usize - 1] = Some(value);\\n        let chunk: Vec<_> = self.buf[self.idx..]\\n            .iter()\\n            .take_while(|x| x.is_some())\\n            .map(|x| x.clone().unwrap())\\n            .collect();\\n        self.idx += chunk.len();\\n        chunk\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1090135,
                "title": "rust",
                "content": "```\\nstruct OrderedStream {\\n    stream: Vec<String>,\\n    pointer: usize,\\n    low: usize,\\n}\\n\\nimpl OrderedStream {\\n\\n    fn new(n: i32) -> Self {\\n        OrderedStream {\\n            stream: vec![String::new(); (n+1) as usize],\\n            pointer: 0,\\n            low: 0\\n        }\\n    }\\n\\n    fn insert(&mut self, id_key: i32, value: String) -> Vec<String> {\\n        self.stream[(id_key - 1) as usize] = value;\\n        while self.stream[self.pointer] != String::new() {\\n            self.pointer += 1;\\n        }\\n        let result = self.stream[self.low..self.pointer].to_vec();\\n        if !result.is_empty() {\\n            self.low = self.pointer;\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct OrderedStream {\\n    stream: Vec<String>,\\n    pointer: usize,\\n    low: usize,\\n}\\n\\nimpl OrderedStream {\\n\\n    fn new(n: i32) -> Self {\\n        OrderedStream {\\n            stream: vec![String::new(); (n+1) as usize],\\n            pointer: 0,\\n            low: 0\\n        }\\n    }\\n\\n    fn insert(&mut self, id_key: i32, value: String) -> Vec<String> {\\n        self.stream[(id_key - 1) as usize] = value;\\n        while self.stream[self.pointer] != String::new() {\\n            self.pointer += 1;\\n        }\\n        let result = self.stream[self.low..self.pointer].to_vec();\\n        if !result.is_empty() {\\n            self.low = self.pointer;\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1088819,
                "title": "c-highly-readable-code-without-loss-of-performance-const-correct-comment-on-one-based-indices",
                "content": "By the way, what is with the really low ratings (tons of thumbs down) for this exercise? I thought it was perfectly reasonable and a good exercise for practicing a few little subtleties and gotchas. Maybe an older version of it was worse?\\n\\nOr, is it just because the author of the exercise snuck in some **one-based indexing** to see if people were paying attention? That would be kind of sad if so, if people judged things on such a frivolous basis so quickly and harshly. Breaking with convention even slightly shouldn\\'t be met with such extreme reactions if you ask me. A calm and adaptable mind is more productive generally I think.\\n\\nAnyway though, enough of my rambling. Here\\'s my implementation:\\n\\n```C++\\ntemplate <typename TInt>\\ninline TInt to_zero_indexed(const TInt one_indexed) {\\n    return one_indexed - 1;\\n}\\n//The reason I made this function is to keep intentions explicit to maximize readability. \\n//Also, I made it a template for generality, on principle (not that it matters much here).\\n\\nclass OrderedStream {\\nprivate:\\n    vector<string> data;\\n    size_t current_stream_pos = 0;  //one past the current contiguous data segment\\npublic:\\n    OrderedStream(const int elem_count) :\\n        data(elem_count)\\n    { }\\n    \\n    size_t scan_for_contiguous_index() {\\n        for (size_t i = 0; i < data.size(); ++i) {\\n            if (data[i].empty()) { return i; }\\n        }\\n        return data.size();\\n    }\\n    \\n    vector<string> insert(\\n        const int id_key, \\n        const string value\\n    ) {\\n        //assert(to_zero_indexed(id_key) >= 0);\\n        //assert(to_zero_indexed(id_key) < data.size());\\n        //I\\'d leave these assertions in if this were production code.\\n        \\n        data[to_zero_indexed(id_key)] = value;\\n        \\n        const size_t prev_stream_pos = current_stream_pos;\\n        current_stream_pos = scan_for_contiguous_index();\\n        \\n        return vector<string>(\\n            data.begin() + prev_stream_pos, \\n            data.begin() + current_stream_pos\\n        );\\n    }\\n};\\n\\n//LeetCode performance metrics (very unreliable as always though):\\n//  88 ms, faster than 97.63% \\n//  81 MB, less than 97.96% \\n```",
                "solutionTags": [],
                "code": "```C++\\ntemplate <typename TInt>\\ninline TInt to_zero_indexed(const TInt one_indexed) {\\n    return one_indexed - 1;\\n}\\n//The reason I made this function is to keep intentions explicit to maximize readability. \\n//Also, I made it a template for generality, on principle (not that it matters much here).\\n\\nclass OrderedStream {\\nprivate:\\n    vector<string> data;\\n    size_t current_stream_pos = 0;  //one past the current contiguous data segment\\npublic:\\n    OrderedStream(const int elem_count) :\\n        data(elem_count)\\n    { }\\n    \\n    size_t scan_for_contiguous_index() {\\n        for (size_t i = 0; i < data.size(); ++i) {\\n            if (data[i].empty()) { return i; }\\n        }\\n        return data.size();\\n    }\\n    \\n    vector<string> insert(\\n        const int id_key, \\n        const string value\\n    ) {\\n        //assert(to_zero_indexed(id_key) >= 0);\\n        //assert(to_zero_indexed(id_key) < data.size());\\n        //I\\'d leave these assertions in if this were production code.\\n        \\n        data[to_zero_indexed(id_key)] = value;\\n        \\n        const size_t prev_stream_pos = current_stream_pos;\\n        current_stream_pos = scan_for_contiguous_index();\\n        \\n        return vector<string>(\\n            data.begin() + prev_stream_pos, \\n            data.begin() + current_stream_pos\\n        );\\n    }\\n};\\n\\n//LeetCode performance metrics (very unreliable as always though):\\n//  88 ms, faster than 97.63% \\n//  81 MB, less than 97.96% \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086112,
                "title": "c-faster-than-98-71-of-the-submissions-in-c",
                "content": "The question basically asks us to insert the value at a given key and return the values in increasing order of their keys such that the concatenation of such chunks gives the entire list sorted according to their keys.\\nThe question sounds a little confusing but the example in the question clears it.\\n\\n**Approach:**\\nWe keep a variable pointing at the start of the vector from which it has to return. The code will return a empty vector till it doesn\\'t recieve a value at the position pointed by the variable. As soon as it recieves a value at that position, it searches for next position that is yet to recieve a value, inserting the values in another vector to return. The code below makes the idea more clear.\\n\\n**Solution:**\\n\\n```\\nclass OrderedStream {\\npublic:\\n    vector<string> v;\\n    int x;\\n    OrderedStream(int n) {\\n        x = 0;\\n        v.resize(n);\\n        for(auto &it:v) it = \"0\"; \\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        v[idKey-1] = value;\\n        vector<string> ans;\\n        if(idKey-1==x)\\n        {\\n            for(;x<v.size(); x++)\\n                if(v[x]!=\"0\") ans.push_back(v[x]);\\n                else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    vector<string> v;\\n    int x;\\n    OrderedStream(int n) {\\n        x = 0;\\n        v.resize(n);\\n        for(auto &it:v) it = \"0\"; \\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        v[idKey-1] = value;\\n        vector<string> ans;\\n        if(idKey-1==x)\\n        {\\n            for(;x<v.size(); x++)\\n                if(v[x]!=\"0\") ans.push_back(v[x]);\\n                else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081980,
                "title": "java-solution-using-next-pointer",
                "content": "```\\nclass OrderedStream {\\n\\n    private String[] arr;\\n    private int next;\\n    \\n    public OrderedStream(int n) {\\n        this.arr = new String[n+1];\\n        this.next = 1;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        List<String> list = new LinkedList<>();\\n        arr[idKey] = value;\\n        if(idKey == next){\\n            while (next < arr.length && arr[next] != null) list.add(arr[next++]);\\n        }    \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass OrderedStream {\\n\\n    private String[] arr;\\n    private int next;\\n    \\n    public OrderedStream(int n) {\\n        this.arr = new String[n+1];\\n        this.next = 1;\\n    }\\n    \\n    public List<String> insert(int idKey, String value) {\\n        List<String> list = new LinkedList<>();\\n        arr[idKey] = value;\\n        if(idKey == next){\\n            while (next < arr.length && arr[next] != null) list.add(arr[next++]);\\n        }    \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037166,
                "title": "java-easy-solution",
                "content": "\\n    private String[] values;\\n    private int ptr;\\n\\n    public OrderedStream(int n) {\\n        values = new String[n];\\n        ptr = 0;\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        values[id - 1] = value;\\n\\n        List<String> result = new ArrayList();\\n        while (ptr < values.length && values[ptr] != null) {\\n            result.add(values[ptr++]);\\n        }\\n\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "\\n    private String[] values;\\n    private int ptr;\\n\\n    public OrderedStream(int n) {\\n        values = new String[n];\\n        ptr = 0;\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        values[id - 1] = value;\\n\\n        List<String> result = new ArrayList();\\n        while (ptr < values.length && values[ptr] != null) {\\n            result.add(values[ptr++]);\\n        }\\n\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1025703,
                "title": "python3-simple-solution",
                "content": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.l = []\\n        self.a = 0\\n        for i in range(n):\\n            self.l.append(0)\\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.l[id-1] = value\\n        ans = []\\n        for i in range(self.a,len(self.l)):\\n            if self.l[i] != 0:\\n                ans.append(self.l[i])\\n                self.a += 1\\n            else:\\n                break\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.l = []\\n        self.a = 0\\n        for i in range(n):\\n            self.l.append(0)\\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.l[id-1] = value\\n        ans = []\\n        for i in range(self.a,len(self.l)):\\n            if self.l[i] != 0:\\n                ans.append(self.l[i])\\n                self.a += 1\\n            else:\\n                break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024372,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass OrderedStream {\\nprivate:\\n    int ptr;\\n    vector <string> store;\\npublic:\\n    OrderedStream(int n) : store(n+1, \"\") {\\n        ptr = 1;\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        vector <string> chunk;\\n        \\n        store[id] = value;\\n        \\n        while(ptr < store.size() && store[ptr] != \"\") {\\n            chunk.push_back(store[ptr]);\\n            ptr++;\\n        }\\n        \\n        return chunk;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(id,value);\\n */\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass OrderedStream {\\nprivate:\\n    int ptr;\\n    vector <string> store;\\npublic:\\n    OrderedStream(int n) : store(n+1, \"\") {\\n        ptr = 1;\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        vector <string> chunk;\\n        \\n        store[id] = value;\\n        \\n        while(ptr < store.size() && store[ptr] != \"\") {\\n            chunk.push_back(store[ptr]);\\n            ptr++;\\n        }\\n        \\n        return chunk;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(id,value);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1023345,
                "title": "python3-faster-then-92-91-o-n",
                "content": "```\\nPlatform: leetcode.com\\n1656. Design an Ordered Stream\\nLink: https://leetcode.com/problems/design-an-ordered-stream\\nDifficulty: Easy\\nAuthor: hritik5102\\nDate: 18/1/2021\\nPost Discussion : https://leetcode.com/problems/design-an-ordered-stream/discuss/1023345\\nSubmission: https://leetcode.com/submissions/detail/444632966/(Time, Space) Complexity : O(n), O(n)\\n```\\n\\n\\n```\\nclass OrderedStream:\\n    d,ptr = [],1    \\n    def __init__(self, n: int):\\n        self.n = n\\n        self.d = [0]*self.n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.d[id-1] = value\\n        res = []\\n\\n        if self.d[self.ptr-1]==0:\\n            return res\\n        else:\\n            for i in range(self.ptr-1,self.n):\\n                if self.d[i]==0:\\n                    break\\n                self.ptr+=1\\n                res+=[self.d[i]]\\n        return res\\n\\t\\t\\nobj = OrderedStream(5)\\nprint(obj.insert(3, \"ccccc\"))\\nprint(obj.insert(1, \"aaaaa\"))\\nprint(obj.insert(2, \"bbbbb\"))\\nprint(obj.insert(5, \"eeeee\"))\\nprint(obj.insert(4, \"ddddd\"))\\n\\n\\'\\'\\'\\nAnother example \\nobj = OrderedStream(9)\\n\\nprint(obj.insert(9,\"nghbm\"))\\nprint(obj.insert(7,\"hgeob\"))\\nprint(obj.insert(6,\"mwlrz\"))\\nprint(obj.insert(4,\"oalee\"))\\nprint(obj.insert(2,\"bouhq\"))\\nprint(obj.insert(1,\"mnknb\"))\\nprint(obj.insert(5,\"qkxbj\"))\\nprint(obj.insert(8,\"iydkk\"))\\nprint(obj.insert(3,\"oqdnf\"))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nPlatform: leetcode.com\\n1656. Design an Ordered Stream\\nLink: https://leetcode.com/problems/design-an-ordered-stream\\nDifficulty: Easy\\nAuthor: hritik5102\\nDate: 18/1/2021\\nPost Discussion : https://leetcode.com/problems/design-an-ordered-stream/discuss/1023345\\nSubmission: https://leetcode.com/submissions/detail/444632966/(Time, Space) Complexity : O(n), O(n)\\n```\n```\\nclass OrderedStream:\\n    d,ptr = [],1    \\n    def __init__(self, n: int):\\n        self.n = n\\n        self.d = [0]*self.n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.d[id-1] = value\\n        res = []\\n\\n        if self.d[self.ptr-1]==0:\\n            return res\\n        else:\\n            for i in range(self.ptr-1,self.n):\\n                if self.d[i]==0:\\n                    break\\n                self.ptr+=1\\n                res+=[self.d[i]]\\n        return res\\n\\t\\t\\nobj = OrderedStream(5)\\nprint(obj.insert(3, \"ccccc\"))\\nprint(obj.insert(1, \"aaaaa\"))\\nprint(obj.insert(2, \"bbbbb\"))\\nprint(obj.insert(5, \"eeeee\"))\\nprint(obj.insert(4, \"ddddd\"))\\n\\n\\'\\'\\'\\nAnother example \\nobj = OrderedStream(9)\\n\\nprint(obj.insert(9,\"nghbm\"))\\nprint(obj.insert(7,\"hgeob\"))\\nprint(obj.insert(6,\"mwlrz\"))\\nprint(obj.insert(4,\"oalee\"))\\nprint(obj.insert(2,\"bouhq\"))\\nprint(obj.insert(1,\"mnknb\"))\\nprint(obj.insert(5,\"qkxbj\"))\\nprint(obj.insert(8,\"iydkk\"))\\nprint(obj.insert(3,\"oqdnf\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013695,
                "title": "java-solution-with-hashmap",
                "content": "```\\nclass OrderedStream {\\n    Map<Integer, String> availableValues;\\n    int val;\\n\\n    public OrderedStream(int n) {\\n        val = 1;\\n        availableValues = new HashMap<>(n);\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        availableValues.put(Integer.valueOf(id), value);\\n        List<String> result = new ArrayList<>();\\n        \\n        while(true){\\n            if(availableValues.containsKey(val)){\\n                result.add(availableValues.get(val));\\n                val++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\n    Map<Integer, String> availableValues;\\n    int val;\\n\\n    public OrderedStream(int n) {\\n        val = 1;\\n        availableValues = new HashMap<>(n);\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        availableValues.put(Integer.valueOf(id), value);\\n        List<String> result = new ArrayList<>();\\n        \\n        while(true){\\n            if(availableValues.containsKey(val)){\\n                result.add(availableValues.get(val));\\n                val++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 987712,
                "title": "javascript",
                "content": "```\\nvar OrderedStream = function(n) {\\n    this.ar = new Array(n)\\n    this.i=0\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} value\\n * @return {string[]}\\n */\\nOrderedStream.prototype.insert = function(id, value) {    \\n    let ar = this.ar\\n    ar[id-1]=value\\n    \\n    let res = []\\n    \\n    // id-1 is index of start position\\n    if (id-1 === this.i) {\\n        // while there are elements in object from id-1 index -> return them\\n        while (ar[this.i]) {\\n            res.push(ar[this.i++]);\\n        }\\n    }\\n\\n    return res\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar OrderedStream = function(n) {\\n    this.ar = new Array(n)\\n    this.i=0\\n};\\n\\n/** \\n * @param {number} id \\n * @param {string} value\\n * @return {string[]}\\n */\\nOrderedStream.prototype.insert = function(id, value) {    \\n    let ar = this.ar\\n    ar[id-1]=value\\n    \\n    let res = []\\n    \\n    // id-1 is index of start position\\n    if (id-1 === this.i) {\\n        // while there are elements in object from id-1 index -> return them\\n        while (ar[this.i]) {\\n            res.push(ar[this.i++]);\\n        }\\n    }\\n\\n    return res\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 982329,
                "title": "ruby-create-pointer-move-it-in-a-loop",
                "content": "##### Leetcode: 1656. Design an Ordered Stream.\\n\\nCreate pointer at the first element in the array, on each insertion move pointer until meet an empty cell. Push each non empty cell value to the answer array for a current insert call. If pointer points at the empty cell return array would be empty one.\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 1656. Design an Ordered Stream.\\n# https://leetcode.com/problems/design-an-ordered-stream/\\n# Runtime: 188 ms, faster than 60.00% of Ruby online submissions for Design an Ordered Stream.\\n# Memory Usage: 211.2 MB, less than 46.67% of Ruby online submissions for Design an Ordered Stream.\\n\\nclass OrderedStream\\n\\n=begin\\n    :type n: Integer\\n=end\\n    def initialize(n)\\n       \\n        @a = Array.new(n)\\n        @next = 0\\n        \\n        \\n    end\\n\\n\\n=begin\\n    :type id: Integer\\n    :type value: String\\n    :rtype: String[]\\n=end\\n    def insert(id, value)\\n        @a[id-1] = value\\n        x = []\\n        if @a[@next].nil?\\n            x = []\\n        else\\n            while ! @a[@next].nil?\\n                x.push(@a[@next])\\n                @next += 1\\n            end\\n        end\\n        return x\\n    end\\n\\n\\nend\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream.new(n)\\n# param_1 = obj.insert(id, value)\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1656. Design an Ordered Stream.\\n# https://leetcode.com/problems/design-an-ordered-stream/\\n# Runtime: 188 ms, faster than 60.00% of Ruby online submissions for Design an Ordered Stream.\\n# Memory Usage: 211.2 MB, less than 46.67% of Ruby online submissions for Design an Ordered Stream.\\n\\nclass OrderedStream\\n\\n=begin\\n    :type n: Integer\\n=end\\n    def initialize(n)\\n       \\n        @a = Array.new(n)\\n        @next = 0\\n        \\n        \\n    end\\n\\n\\n=begin\\n    :type id: Integer\\n    :type value: String\\n    :rtype: String[]\\n=end\\n    def insert(id, value)\\n        @a[id-1] = value\\n        x = []\\n        if @a[@next].nil?\\n            x = []\\n        else\\n            while ! @a[@next].nil?\\n                x.push(@a[@next])\\n                @next += 1\\n            end\\n        end\\n        return x\\n    end\\n\\n\\nend\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream.new(n)\\n# param_1 = obj.insert(id, value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980004,
                "title": "easy-java-solution",
                "content": "```\\nclass OrderedStream {\\n   HashMap<Integer,String> hm;\\n    int idx;\\n    public OrderedStream(int n) {\\n       hm=new HashMap<Integer,String>();\\n        for(int i=1;i<=n;i++)\\n            hm.put(i,\"\");\\n        idx=1;\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        \\n        hm.put(id,value);\\n        List<String> ans=new ArrayList<>();\\n        for(int i=idx;i<=hm.size();i++){\\n            if(hm.containsKey(i) && !hm.get(i).equals(\"\")){\\n                ans.add(hm.get(i));\\n                idx++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream obj = new OrderedStream(n);\\n * List<String> param_1 = obj.insert(id,value);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\n   HashMap<Integer,String> hm;\\n    int idx;\\n    public OrderedStream(int n) {\\n       hm=new HashMap<Integer,String>();\\n        for(int i=1;i<=n;i++)\\n            hm.put(i,\"\");\\n        idx=1;\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        \\n        hm.put(id,value);\\n        List<String> ans=new ArrayList<>();\\n        for(int i=idx;i<=hm.size();i++){\\n            if(hm.containsKey(i) && !hm.get(i).equals(\"\")){\\n                ans.add(hm.get(i));\\n                idx++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream obj = new OrderedStream(n);\\n * List<String> param_1 = obj.insert(id,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955320,
                "title": "c-using-vectors-self-explanatory",
                "content": "```\\nclass OrderedStream {\\n    vector<string> chunks;\\n    int nextToBeSeen;\\n\\npublic:\\n    OrderedStream(int n) : chunks(vector<string>(n)), nextToBeSeen(0) { }\\n    \\n    vector<string> insert(int id, string value) {\\n        chunks[id - 1] = value;\\n        \\n        vector<string> result = {};\\n        \\n        while (nextToBeSeen < chunks.size() and chunks[nextToBeSeen] != \"\")\\n            result.push_back(chunks[nextToBeSeen++]);\\n        \\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\n    vector<string> chunks;\\n    int nextToBeSeen;\\n\\npublic:\\n    OrderedStream(int n) : chunks(vector<string>(n)), nextToBeSeen(0) { }\\n    \\n    vector<string> insert(int id, string value) {\\n        chunks[id - 1] = value;\\n        \\n        vector<string> result = {};\\n        \\n        while (nextToBeSeen < chunks.size() and chunks[nextToBeSeen] != \"\")\\n            result.push_back(chunks[nextToBeSeen++]);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947961,
                "title": "kt-js-py3-cpp-array",
                "content": "**Synopsis:**\\n\\nInsert each `k`<sup>th</sup> value into an array of strings `A`, and return the result `res` of the monotonically increasing `i`<sup>th</sup> index of adjacent non-empty string values in `A`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass OrderedStream(N_: Int) {\\n    private var i = 0\\n    private var N = N_\\n    private var A = MutableList<String>(N) { \"\" }\\n    fun insert(k: Int, value: String): List<String> {\\n        var res = mutableListOf<String>()\\n        A[k - 1] = value  // -1 for 0-based indexing\\n        while (i < N && 0 < A[i].length)\\n            res.add(A[i++])\\n        return res\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass OrderedStream {\\n    constructor(N) {\\n        this.i = 0;\\n        this.N = N;\\n        this.A = Array(N).fill(\\'\\');\\n    }\\n    insert(k, value, res = []) {\\n        this.A[k - 1] = value;  // -1 for 0-based indexing\\n        while (this.i < this.N && this.A[this.i].length)\\n            res.push(this.A[this.i++]);\\n        return res;\\n    }\\n}\\n```\\n\\n*Python3*\\n```\\nclass OrderedStream:\\n    def __init__(self, N: int):\\n        self.i = 0\\n        self.N = N\\n        self.A = [\\'\\'] * N\\n    def insert(self, k: int, value: str) -> List[str]:\\n        res = []\\n        self.A[k - 1] = value  # -1 for 0-based indexing\\n        while self.i < self.N and len(self.A[self.i]):\\n            res.append(self.A[self.i])\\n            self.i += 1\\n        return res\\n```\\n\\n*C++*\\n```\\nclass OrderedStream {\\n    using VS = vector<string>;\\n    int i, N;\\n    VS A;\\npublic:\\n    OrderedStream(int N) : i{ 0 }, N{ N }, A(N) {}\\n    VS insert(int k, string value, VS res = {}) {\\n        A[k - 1] = value;  // -1 for 0-based indexing\\n        while (i < N && !A[i].empty())\\n            res.push_back(A[i++]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream(N_: Int) {\\n    private var i = 0\\n    private var N = N_\\n    private var A = MutableList<String>(N) { \"\" }\\n    fun insert(k: Int, value: String): List<String> {\\n        var res = mutableListOf<String>()\\n        A[k - 1] = value  // -1 for 0-based indexing\\n        while (i < N && 0 < A[i].length)\\n            res.add(A[i++])\\n        return res\\n    }\\n}\\n```\n```\\nclass OrderedStream {\\n    constructor(N) {\\n        this.i = 0;\\n        this.N = N;\\n        this.A = Array(N).fill(\\'\\');\\n    }\\n    insert(k, value, res = []) {\\n        this.A[k - 1] = value;  // -1 for 0-based indexing\\n        while (this.i < this.N && this.A[this.i].length)\\n            res.push(this.A[this.i++]);\\n        return res;\\n    }\\n}\\n```\n```\\nclass OrderedStream:\\n    def __init__(self, N: int):\\n        self.i = 0\\n        self.N = N\\n        self.A = [\\'\\'] * N\\n    def insert(self, k: int, value: str) -> List[str]:\\n        res = []\\n        self.A[k - 1] = value  # -1 for 0-based indexing\\n        while self.i < self.N and len(self.A[self.i]):\\n            res.append(self.A[self.i])\\n            self.i += 1\\n        return res\\n```\n```\\nclass OrderedStream {\\n    using VS = vector<string>;\\n    int i, N;\\n    VS A;\\npublic:\\n    OrderedStream(int N) : i{ 0 }, N{ N }, A(N) {}\\n    VS insert(int k, string value, VS res = {}) {\\n        A[k - 1] = value;  // -1 for 0-based indexing\\n        while (i < N && !A[i].empty())\\n            res.push_back(A[i++]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946964,
                "title": "python-hashmap-pointer-beats-97",
                "content": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.pos = {}\\n        self.cur = 1\\n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.pos[id] = value\\n        out = [] \\n        while self.cur in self.pos:\\n            out.append(self.pos[self.cur])\\n            self.cur += 1\\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.pos = {}\\n        self.cur = 1\\n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.pos[id] = value\\n        out = [] \\n        while self.cur in self.pos:\\n            out.append(self.pos[self.cur])\\n            self.cur += 1\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943423,
                "title": "c-simple-solution",
                "content": "```\\nclass OrderedStream {\\npublic:\\n    vector<string> st;\\n    int pos = 0;\\n    OrderedStream(int n) {\\n        st.resize(n);\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        vector<string> resp;\\n        st[id-1] = value;\\n        while (pos < st.size() && st[pos] != \"\") {\\n            resp.push_back(st[pos]);\\n            pos++;\\n        }\\n        return resp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    vector<string> st;\\n    int pos = 0;\\n    OrderedStream(int n) {\\n        st.resize(n);\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        vector<string> resp;\\n        st[id-1] = value;\\n        while (pos < st.size() && st[pos] != \"\") {\\n            resp.push_back(st[pos]);\\n            pos++;\\n        }\\n        return resp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937332,
                "title": "go-golang-solution",
                "content": ">Runtime: 80 ms, faster than 100.00% of Go online submissions for Design an Ordered Stream.\\nMemory Usage: 6.7 MB, less than 100.00% of Go online submissions for Design an Ordered Stream.\\n\\n```go\\ntype OrderedStream struct {\\n    p int\\n    s []string\\n}\\n\\nfunc Constructor(n int) OrderedStream {\\n    return OrderedStream{ 0, make([]string, n + 1) }\\n}\\n\\nfunc (this *OrderedStream) Insert(id int, value string) []string {\\n    tmp := []string{}\\n    this.s[id - 1] = value\\n    for this.s[this.p] != \"\" {\\n        tmp = append(tmp, this.s[this.p])\\n        this.p++\\n    }\\n    return tmp\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\ntype OrderedStream struct {\\n    p int\\n    s []string\\n}\\n\\nfunc Constructor(n int) OrderedStream {\\n    return OrderedStream{ 0, make([]string, n + 1) }\\n}\\n\\nfunc (this *OrderedStream) Insert(id int, value string) []string {\\n    tmp := []string{}\\n    this.s[id - 1] = value\\n    for this.s[this.p] != \"\" {\\n        tmp = append(tmp, this.s[this.p])\\n        this.p++\\n    }\\n    return tmp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936897,
                "title": "python-generator",
                "content": "Speaking of \"streams\", let\\'s take advantage of the fact that LeetCode doesn\\'t check that the result is a `list`. This gets accepted:\\n```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.values = {}\\n        self.ptr = 1\\n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.values[id] = value\\n        while self.ptr in self.values:\\n            yield self.values.pop(self.ptr)\\n            self.ptr += 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.values = {}\\n        self.ptr = 1\\n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.values[id] = value\\n        while self.ptr in self.values:\\n            yield self.values.pop(self.ptr)\\n            self.ptr += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936234,
                "title": "java-simple-soln-question-description-is-confusing-though",
                "content": "```\\nclass OrderedStream {\\n\\n    class Node{\\n        int num;\\n        String str;\\n        public Node(int n, String s){\\n            this.num = n;\\n            this.str = s;\\n        }\\n    }\\n\\n    private static  final int startIndex = 1;\\n    private int size;\\n    private int ptr;\\n    private TreeMap<Integer, Node> treeMap = new TreeMap<>();\\n    public OrderedStream(int n) {\\n        size = n;\\n        ptr = 1;\\n    }\\n\\n    public List<String> insert(int id, String value) {\\n        List<String> res = new ArrayList<>();\\n        treeMap.put(id, new Node(id, value));\\n        if(id == ptr){\\n            int i = id;\\n            for (i = id; i <= size; i++){\\n                if(treeMap.containsKey(i)){\\n                    res.add(treeMap.get(i).str);\\n                }else{\\n                    break;\\n                }\\n            }\\n            ptr= i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream {\\n\\n    class Node{\\n        int num;\\n        String str;\\n        public Node(int n, String s){\\n            this.num = n;\\n            this.str = s;\\n        }\\n    }\\n\\n    private static  final int startIndex = 1;\\n    private int size;\\n    private int ptr;\\n    private TreeMap<Integer, Node> treeMap = new TreeMap<>();\\n    public OrderedStream(int n) {\\n        size = n;\\n        ptr = 1;\\n    }\\n\\n    public List<String> insert(int id, String value) {\\n        List<String> res = new ArrayList<>();\\n        treeMap.put(id, new Node(id, value));\\n        if(id == ptr){\\n            int i = id;\\n            for (i = id; i <= size; i++){\\n                if(treeMap.containsKey(i)){\\n                    res.add(treeMap.get(i).str);\\n                }else{\\n                    break;\\n                }\\n            }\\n            ptr= i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936174,
                "title": "easy-c-solution-sortedset-dictionary",
                "content": "```\\n       public class OrderedStream\\n        {\\n            private SortedSet<int> _idMap = new SortedSet<int>();\\n            private IDictionary<int, string> _map = new Dictionary<int, string>();\\n            private IList<int> _removeIds = new List<int>();\\n            private int _ptr = 1;\\n\\n            public OrderedStream(int n)\\n            {\\n            }\\n\\n            public IList<string> Insert(int id, string value)\\n            {\\n                IList<string> res = new List<string>();\\n\\n                _idMap.Add(id);\\n                _map[id] = value;\\n\\n                _removeIds.Clear();\\n                \\n                foreach (var idx in _idMap)\\n                {\\n                    if (idx < _ptr)\\n                    {\\n                        _removeIds.Add(idx);\\n                        continue;\\n                    }\\n\\n                    break;\\n                }\\n\\n                foreach (var removeId in _removeIds)\\n                {\\n                    _idMap.Remove(removeId);\\n                    _map.Remove(removeId);\\n                }\\n\\n                foreach (var idx in _idMap)\\n                {\\n                    if (idx == _ptr)\\n                    {\\n                        res.Add(_map[idx]);\\n                        _ptr++;\\n                        continue;\\n                    }\\n\\n                    break;\\n                }\\n\\n                return res;\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n       public class OrderedStream\\n        {\\n            private SortedSet<int> _idMap = new SortedSet<int>();\\n            private IDictionary<int, string> _map = new Dictionary<int, string>();\\n            private IList<int> _removeIds = new List<int>();\\n            private int _ptr = 1;\\n\\n            public OrderedStream(int n)\\n            {\\n            }\\n\\n            public IList<string> Insert(int id, string value)\\n            {\\n                IList<string> res = new List<string>();\\n\\n                _idMap.Add(id);\\n                _map[id] = value;\\n\\n                _removeIds.Clear();\\n                \\n                foreach (var idx in _idMap)\\n                {\\n                    if (idx < _ptr)\\n                    {\\n                        _removeIds.Add(idx);\\n                        continue;\\n                    }\\n\\n                    break;\\n                }\\n\\n                foreach (var removeId in _removeIds)\\n                {\\n                    _idMap.Remove(removeId);\\n                    _map.Remove(removeId);\\n                }\\n\\n                foreach (var idx in _idMap)\\n                {\\n                    if (idx == _ptr)\\n                    {\\n                        res.Add(_map[idx]);\\n                        _ptr++;\\n                        continue;\\n                    }\\n\\n                    break;\\n                }\\n\\n                return res;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936147,
                "title": "c-simple-and-easy-to-read",
                "content": "\\'\\'\\'\\nclass OrderedStream {\\n\\npublic:\\n\\n\\n\\n    vector<string>v;\\n    int ptr;\\n    OrderedStream(int n) {\\n        v=vector<string>(n+1,\"\");\\n        ptr=1;\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        v[id]=value;\\n        \\n        vector<string>temp;\\n        while(ptr<v.size())\\n        {\\n            if(v[ptr]!=\"\")\\n                temp.push_back(v[ptr++]);\\n            else\\n                break;\\n        }\\n        return temp;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Please Upvote my solution **",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass OrderedStream {\\n\\npublic:\\n\\n\\n\\n    vector<string>v;\\n    int ptr;\\n    OrderedStream(int n) {\\n        v=vector<string>(n+1,\"\");\\n        ptr=1;\\n    }\\n    \\n    vector<string> insert(int id, string value) {\\n        v[id]=value;\\n        \\n        vector<string>temp;\\n        while(ptr<v.size())\\n        {\\n            if(v[ptr]!=\"\")\\n                temp.push_back(v[ptr++]);\\n            else\\n                break;\\n        }\\n        return temp;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Please Upvote my solution **",
                "codeTag": "Java"
            },
            {
                "id": 936088,
                "title": "python-time-o-n-100-space-o-n-100-6-lines-clean-yield",
                "content": "1. \\'yield\\' is a good way to return list that element needed to check, since it can save memory and save code!\\n2. Tail None is a stop sign for end of data, and save action of \\'check if self.ptr in range\\'\\n```\\n# Platform: leetcode.com\\n# No. 1656. Design an Ordered Stream\\n# Link: https://leetcode.com/problems/design-an-ordered-stream/\\n# Difficulty: Eas\\n# Dev: Chumicat\\n# Date: 2020/11/15\\n# Submission: https://leetcode.com/submissions/detail/420399391/\\n# (Time, Space) Complexity : O(n), O(n)\\n#\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(id,value)\\nclass OrderedStream:\\n    def __init__(self, n: int):\\n        self.data = [None]*(n+1)   # Use a tail None to mark end\\n        self.ptr = 0\\n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.data[id-1] = value\\n        while self.data[self.ptr]:\\n            yield self.data[self.ptr]\\n            self.ptr += 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Platform: leetcode.com\\n# No. 1656. Design an Ordered Stream\\n# Link: https://leetcode.com/problems/design-an-ordered-stream/\\n# Difficulty: Eas\\n# Dev: Chumicat\\n# Date: 2020/11/15\\n# Submission: https://leetcode.com/submissions/detail/420399391/\\n# (Time, Space) Complexity : O(n), O(n)\\n#\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(id,value)\\nclass OrderedStream:\\n    def __init__(self, n: int):\\n        self.data = [None]*(n+1)   # Use a tail None to mark end\\n        self.ptr = 0\\n\\n    def insert(self, id: int, value: str) -> List[str]:\\n        self.data[id-1] = value\\n        while self.data[self.ptr]:\\n            yield self.data[self.ptr]\\n            self.ptr += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936071,
                "title": "kotlin-do-what-is-asked",
                "content": "```\\nclass OrderedStream(n: Int) {\\n\\n    private val nums = Array<String>(n) { \"\" } // Array of size n\\n    private var ptr = 0 // initialized pointer\\n    \\n    fun insert(id: Int, value: String): List<String> {\\n        nums[id-1] = value // Insert the pair\\n        \\n        val res = mutableListOf<String>()\\n        \\n        if (ptr >= nums.size || nums[ptr].isEmpty()) // If there\\'s no value at the point, return\\n            return res\\n        \\n        res.add(nums[ptr])\\n        \\n        while (true) {\\n            if (++ptr >= nums.size || nums[ptr].isEmpty()) // Increment ptr and check breaking condition\\n                break\\n                \\n            res.add(nums[ptr])\\n        }\\n        \\n        return res\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass OrderedStream(n: Int) {\\n\\n    private val nums = Array<String>(n) { \"\" } // Array of size n\\n    private var ptr = 0 // initialized pointer\\n    \\n    fun insert(id: Int, value: String): List<String> {\\n        nums[id-1] = value // Insert the pair\\n        \\n        val res = mutableListOf<String>()\\n        \\n        if (ptr >= nums.size || nums[ptr].isEmpty()) // If there\\'s no value at the point, return\\n            return res\\n        \\n        res.add(nums[ptr])\\n        \\n        while (true) {\\n            if (++ptr >= nums.size || nums[ptr].isEmpty()) // Increment ptr and check breaking condition\\n                break\\n                \\n            res.add(nums[ptr])\\n        }\\n        \\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935960,
                "title": "javascript-simple-solution",
                "content": "```\\nvar OrderedStream = function(n) {\\n    this.parts = new Array(n);\\n    this.head = 0;\\n};\\n\\nOrderedStream.prototype.insert = function(id, value) {\\n    this.parts[id-1] = value;\\n    \\n    let res = [];\\n    if (id-1 === this.head) {\\n        while (this.parts[this.head]) {\\n            res.push(this.parts[this.head++]);\\n        }\\n    }\\n    \\n    return res;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar OrderedStream = function(n) {\\n    this.parts = new Array(n);\\n    this.head = 0;\\n};\\n\\nOrderedStream.prototype.insert = function(id, value) {\\n    this.parts[id-1] = value;\\n    \\n    let res = [];\\n    if (id-1 === this.head) {\\n        while (this.parts[this.head]) {\\n            res.push(this.parts[this.head++]);\\n        }\\n    }\\n    \\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 935927,
                "title": "java-simple",
                "content": "```java\\nclass OrderedStream {\\n\\n    private String[] stream;\\n    private int ptr;\\n    public OrderedStream(int n) {\\n        this.stream = new String[n + 1];\\n        this.ptr = 1;\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        stream[id] = value;\\n        List<String> list = new LinkedList<>();\\n        while (ptr < stream.length && stream[ptr] != null) {\\n            list.add(stream[ptr++]);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass OrderedStream {\\n\\n    private String[] stream;\\n    private int ptr;\\n    public OrderedStream(int n) {\\n        this.stream = new String[n + 1];\\n        this.ptr = 1;\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        stream[id] = value;\\n        List<String> list = new LinkedList<>();\\n        while (ptr < stream.length && stream[ptr] != null) {\\n            list.add(stream[ptr++]);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086772,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass OrderedStream \\n{\\n    std::map<int, std::string> mp; // idkey value pairs\\n    int ptr;\\npublic:\\n    OrderedStream(int n) : ptr {1}\\n    {\\n        ;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) \\n    {\\n        std::vector<std::string> result;\\n        mp[idKey] = value;\\n        while(mp.find(ptr) != mp.end())\\n        {\\n            result.push_back(mp[ptr]);\\n            ptr++;\\n        }\\n        return result;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass OrderedStream \\n{\\n    std::map<int, std::string> mp; // idkey value pairs\\n    int ptr;\\npublic:\\n    OrderedStream(int n) : ptr {1}\\n    {\\n        ;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) \\n    {\\n        std::vector<std::string> result;\\n        mp[idKey] = value;\\n        while(mp.find(ptr) != mp.end())\\n        {\\n            result.push_back(mp[ptr]);\\n            ptr++;\\n        }\\n        return result;\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081162,
                "title": "python3-beats-100-in-time-and-95-in-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.stream = [None] * n\\n        self.ptr = 0\\n        self.n = n\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.stream[idKey - 1] = value\\n        start = self.ptr\\n        while self.ptr < self.n and self.stream[self.ptr]:\\n            self.ptr += 1\\n        \\n        if start == self.ptr:\\n            return []\\n        else:\\n            return self.stream[start:self.ptr]\\n        \\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.stream = [None] * n\\n        self.ptr = 0\\n        self.n = n\\n\\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.stream[idKey - 1] = value\\n        start = self.ptr\\n        while self.ptr < self.n and self.stream[self.ptr]:\\n            self.ptr += 1\\n        \\n        if start == self.ptr:\\n            return []\\n        else:\\n            return self.stream[start:self.ptr]\\n        \\n\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077983,
                "title": "bad-problem-description",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass OrderedStream {\\nprivate:\\n    int pos=1;\\n    unordered_map<int,string>mp;\\n    int size;\\n    vector<string>empty;\\npublic:\\n    OrderedStream(int n) {\\n        size=n;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string>output;\\n        if(mp[idKey].empty()){\\n            mp[idKey]=value;\\n        }\\n        if(idKey!=pos)return empty;\\n        if(idKey==pos){\\n            output.push_back(mp[pos]);\\n            pos++;\\n            while(!mp[pos].empty()&&pos<=size){\\n                output.push_back(mp[pos]);\\n                pos++;\\n            }\\n\\n        }\\n\\n        return output;\\n        \\n\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass OrderedStream {\\nprivate:\\n    int pos=1;\\n    unordered_map<int,string>mp;\\n    int size;\\n    vector<string>empty;\\npublic:\\n    OrderedStream(int n) {\\n        size=n;\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        vector<string>output;\\n        if(mp[idKey].empty()){\\n            mp[idKey]=value;\\n        }\\n        if(idKey!=pos)return empty;\\n        if(idKey==pos){\\n            output.push_back(mp[pos]);\\n            pos++;\\n            while(!mp[pos].empty()&&pos<=size){\\n                output.push_back(mp[pos]);\\n                pos++;\\n            }\\n\\n        }\\n\\n        return output;\\n        \\n\\n    }\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063167,
                "title": "horror",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass OrderedStream {\\npublic:\\n    OrderedStream(int n) {\\n        values = vector<string>(n + 1);\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        values[idKey] = value;\\n        if(idKey == ptr)\\n        {\\n            int newPtr = ptr;\\n            while(newPtr < values.size() && values[newPtr] != \"\")\\n            {\\n                newPtr++;\\n            }\\n            int oldPtr = ptr;\\n            ptr = newPtr;\\n            return vector(values.begin() + oldPtr, values.begin() + newPtr);\\n        }        \\n        return vector<string>();\\n    }\\nprivate:\\n    int ptr = 1;\\n    vector<string> values;\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass OrderedStream {\\npublic:\\n    OrderedStream(int n) {\\n        values = vector<string>(n + 1);\\n    }\\n    \\n    vector<string> insert(int idKey, string value) {\\n        values[idKey] = value;\\n        if(idKey == ptr)\\n        {\\n            int newPtr = ptr;\\n            while(newPtr < values.size() && values[newPtr] != \"\")\\n            {\\n                newPtr++;\\n            }\\n            int oldPtr = ptr;\\n            ptr = newPtr;\\n            return vector(values.begin() + oldPtr, values.begin() + newPtr);\\n        }        \\n        return vector<string>();\\n    }\\nprivate:\\n    int ptr = 1;\\n    vector<string> values;\\n};\\n\\n/**\\n * Your OrderedStream object will be instantiated and called as such:\\n * OrderedStream* obj = new OrderedStream(n);\\n * vector<string> param_1 = obj->insert(idKey,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048739,
                "title": "simple-solution",
                "content": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.stream = [\"\"]*(n+1)\\n        self.pointer = 0\\n        \\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.stream[idKey-1] = value\\n        while self.stream[self.pointer]:\\n            self.pointer += 1\\n        return self.stream[idKey-1: self.pointer]\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass OrderedStream:\\n\\n    def __init__(self, n: int):\\n        self.stream = [\"\"]*(n+1)\\n        self.pointer = 0\\n        \\n    def insert(self, idKey: int, value: str) -> List[str]:\\n        self.stream[idKey-1] = value\\n        while self.stream[self.pointer]:\\n            self.pointer += 1\\n        return self.stream[idKey-1: self.pointer]\\n\\n# Your OrderedStream object will be instantiated and called as such:\\n# obj = OrderedStream(n)\\n# param_1 = obj.insert(idKey,value)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565715,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1566375,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1564596,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1625306,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1685939,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1674637,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1807584,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1753872,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1732495,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1740289,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1565715,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1566375,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1564596,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1625306,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1685939,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1674637,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1807584,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1753872,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1732495,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1740289,
                "content": [
                    {
                        "username": "shaniquagoyal",
                        "content": "I understood the code written by those that submitted the answers but it\\'s so hard to know the way to approach this kind of question because I never understood what was supposed to be done.\\n\\nIf one doesn\\'t get a clear understanding of the problem at hand how is one supposed to find it\\'s solution?"
                    },
                    {
                        "username": "vivek2299",
                        "content": "See, you can understand problem by creating your own desired test cases... to check if your assumption for problem is right or not"
                    },
                    {
                        "username": "eduard92",
                        "content": "In interview you can ask.. Here you just downvote.\\nI guess this questions might be added by interviewers themselves to make the candidate talk with them or get rejected easily."
                    },
                    {
                        "username": "rahul123agarwal99",
                        "content": "I thought i am only the one who is having difficulty in understanding the problem, but after looking at thje discussion i feel many have faced the same difficulty."
                    },
                    {
                        "username": "nadabao",
                        "content": "For such leetcode easy question, it seems now the \"difficulty\" comes from deliberately adding lengthy and confusing description, which is annoying for starting a coding contest.\\n\\nDon\\'t laugh at me, I spent more time on this question (thanks to the description) than solving Q2 or Q3. lol"
                    },
                    {
                        "username": "cavey621",
                        "content": "i set a timer of 15mins for this easy question. now time\\'s up but I haven\\'t understood the question yet. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not the only one!"
                    },
                    {
                        "username": "Axes",
                        "content": "true"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I had to dislike the description from the deepest of my heart.\n"
                    },
                    {
                        "username": "Gismet",
                        "content": "For those who don\\'t understand the problem from the problem description.\\nPlease look at the picture explanation given in the example.\\npay attention to ptr in the picture. "
                    },
                    {
                        "username": "khaled_achech",
                        "content": "Thank you, that really helped me, I was confused on why the first insert returned an empty list"
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Intended output `[[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]`\\n\\nHow does this make sense for the given example?"
                    },
                    {
                        "username": "kush_ishere",
                        "content": "Thanks, I just wasted 30 mins on this problem, and then came to your discussion and was able to understand the clever ptr in the video."
                    },
                    {
                        "username": "ngnhathuy1224",
                        "content": "You saved my time. Idk why they didn\\'t point out that effing pointer."
                    },
                    {
                        "username": "wenxx194",
                        "content": "I hope they can add your comment in the question\\'s description. Lol."
                    },
                    {
                        "username": "mahmoudrabbas",
                        "content": "***Here's my explanation***\n\nyou gotta make an *OrderedStream* class  which has a method \"insert\" that takes two params (idKey, stringVal) and return \"List<String>\"...\n\nhere is what you have to do :\n[1] you should have an integer variable to \"act\" like a pointer, it is initially starts by 1.\n[2] in each \"insert\", if the \"idkey\" is same value as the current pointer,  return \"list\" of strings and increment the pointer.\n[3] else, return an \"empty list []\".\n\n\n**NOTE**\n- you should return a list of the all strings that come after that idkey when (idkey==pointer).\n\n\n*How it would be judged*\n\nOrderedStream os = new OrderedStream(5), and (ptr = 1)\n\nos.insert(1,\"aaaa\"), since the idkey is the same as the current ptr, so return [\"aaaa\"], then the pointer would be 2.\n\nos.insert(3,\"cccc\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(4,\"dddd\"), idkey is not equal to current ptr, so return [], and the pointer stays the same.\n\nos.insert(2,\"bbbb\"), since the idkey is the same as the current ptr, so return [\"bbbb\", \"cccc\", \"dddd\"], then the pointer would be 5.\n\nos.insert(5,\"eeee\"), since the idkey is the same as the current ptr, so return [\"eeee\"].\n\n\n\nhope you guys get it!"
                    },
                    {
                        "username": "JustinMei",
                        "content": "Clear and understandable explanations!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Top-1 of the ugliest problem descriptions I\\'ve seen on LC so far.\\n\\nYou get the problem? - FAANG drying to hire you. No solution required. :)"
                    },
                    {
                        "username": "vinaydiwakar10",
                        "content": "dont read all the extra info in description. follow the image if there is a value is present where ptr is at then return the largest chunk that is existing i.e increment ptr until u read null value. make sure ptr is less than the size of the main list"
                    },
                    {
                        "username": "sourchi",
                        "content": "If an interviewer asks you this question it\\'s a red flag showing you shouldn\\'t take that position "
                    },
                    {
                        "username": "eduard92",
                        "content": "I will probably not pass if he wants it done in 10 minutes, like they usually do."
                    }
                ]
            },
            {
                "id": 1765167,
                "content": [
                    {
                        "username": "aakash_abhishek",
                        "content": "Unable to understand the question. Feeling better after reading the discussion comments."
                    },
                    {
                        "username": "java_run",
                        "content": "I have tried my best to explain this question in my solution ! \\nPlease go through it : \\n\\nhttps://leetcode.com/problems/design-an-ordered-stream/solutions/3542813/well-explained-solution-with-intuition/"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "The description may be better but the gif gives intuitive understanding what to do. Spent around 10 minutes to approach this problem. Not so bad problem IMHO as for the number of downvotes."
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Except the output is expecting something that\\'s entirely different than what the gif wants.\\n\\nI would have expected `[\\'aaaaa\\', \\'bbbbb\\', \\'ccccc\\', \\'ddddd\\', \\'eeeee\\']` to be the expected output based on the gif.\\n\\nNot `[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]` This makes no sense, genuinely. Why are b and c grouped? Why isn\\'t a in the first empty list?\\n\\nIt follows no pattern and has no reasonable solution to be that way."
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "C3T0",
                        "content": "The description of this question is remarkable. I\\'m still at the reading phase of the problem. Good for me!"
                    },
                    {
                        "username": "ganeshn12",
                        "content": "Instead of reading the whole description again and again, if you follow the video, you will easily understand the question "
                    },
                    {
                        "username": "camaro360degree",
                        "content": "Wtf? The question is inexplicably lame. Hard Pass."
                    },
                    {
                        "username": "Digiton",
                        "content": "To understand the problem save gif animation and then play it manually frame-by-frame, everything will become clear. It's about reconstruction IP packets in right order when they come in random order. Think about VoIP or video streaming - when all the packets needed to play the fragment are received, we can play it.\nOf course in real live streaming, we skipping fragments after some timeout if it not received."
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "This question\\'s description is not understandable/////"
                    },
                    {
                        "username": "rengatta10",
                        "content": "Just imagine you\\'re building a bridge for a robot piece by piece. The robot will only be able to move if it has parts connecting to its location.\\nThe output will be the parts of the bridge that the robot has traversed over after placing the part."
                    },
                    {
                        "username": "abdumaliksobirov007",
                        "content": "Related to a person who writes the description:\\nPlease, write the description in a comprehensible way as the current one is so illegible.\\nThank you in advence!"
                    }
                ]
            },
            {
                "id": 1760032,
                "content": [
                    {
                        "username": "aakash_abhishek",
                        "content": "Unable to understand the question. Feeling better after reading the discussion comments."
                    },
                    {
                        "username": "java_run",
                        "content": "I have tried my best to explain this question in my solution ! \\nPlease go through it : \\n\\nhttps://leetcode.com/problems/design-an-ordered-stream/solutions/3542813/well-explained-solution-with-intuition/"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "The description may be better but the gif gives intuitive understanding what to do. Spent around 10 minutes to approach this problem. Not so bad problem IMHO as for the number of downvotes."
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Except the output is expecting something that\\'s entirely different than what the gif wants.\\n\\nI would have expected `[\\'aaaaa\\', \\'bbbbb\\', \\'ccccc\\', \\'ddddd\\', \\'eeeee\\']` to be the expected output based on the gif.\\n\\nNot `[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]` This makes no sense, genuinely. Why are b and c grouped? Why isn\\'t a in the first empty list?\\n\\nIt follows no pattern and has no reasonable solution to be that way."
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "C3T0",
                        "content": "The description of this question is remarkable. I\\'m still at the reading phase of the problem. Good for me!"
                    },
                    {
                        "username": "ganeshn12",
                        "content": "Instead of reading the whole description again and again, if you follow the video, you will easily understand the question "
                    },
                    {
                        "username": "camaro360degree",
                        "content": "Wtf? The question is inexplicably lame. Hard Pass."
                    },
                    {
                        "username": "Digiton",
                        "content": "To understand the problem save gif animation and then play it manually frame-by-frame, everything will become clear. It's about reconstruction IP packets in right order when they come in random order. Think about VoIP or video streaming - when all the packets needed to play the fragment are received, we can play it.\nOf course in real live streaming, we skipping fragments after some timeout if it not received."
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "This question\\'s description is not understandable/////"
                    },
                    {
                        "username": "rengatta10",
                        "content": "Just imagine you\\'re building a bridge for a robot piece by piece. The robot will only be able to move if it has parts connecting to its location.\\nThe output will be the parts of the bridge that the robot has traversed over after placing the part."
                    },
                    {
                        "username": "abdumaliksobirov007",
                        "content": "Related to a person who writes the description:\\nPlease, write the description in a comprehensible way as the current one is so illegible.\\nThank you in advence!"
                    }
                ]
            },
            {
                "id": 1757979,
                "content": [
                    {
                        "username": "aakash_abhishek",
                        "content": "Unable to understand the question. Feeling better after reading the discussion comments."
                    },
                    {
                        "username": "java_run",
                        "content": "I have tried my best to explain this question in my solution ! \\nPlease go through it : \\n\\nhttps://leetcode.com/problems/design-an-ordered-stream/solutions/3542813/well-explained-solution-with-intuition/"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "The description may be better but the gif gives intuitive understanding what to do. Spent around 10 minutes to approach this problem. Not so bad problem IMHO as for the number of downvotes."
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Except the output is expecting something that\\'s entirely different than what the gif wants.\\n\\nI would have expected `[\\'aaaaa\\', \\'bbbbb\\', \\'ccccc\\', \\'ddddd\\', \\'eeeee\\']` to be the expected output based on the gif.\\n\\nNot `[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]` This makes no sense, genuinely. Why are b and c grouped? Why isn\\'t a in the first empty list?\\n\\nIt follows no pattern and has no reasonable solution to be that way."
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "C3T0",
                        "content": "The description of this question is remarkable. I\\'m still at the reading phase of the problem. Good for me!"
                    },
                    {
                        "username": "ganeshn12",
                        "content": "Instead of reading the whole description again and again, if you follow the video, you will easily understand the question "
                    },
                    {
                        "username": "camaro360degree",
                        "content": "Wtf? The question is inexplicably lame. Hard Pass."
                    },
                    {
                        "username": "Digiton",
                        "content": "To understand the problem save gif animation and then play it manually frame-by-frame, everything will become clear. It's about reconstruction IP packets in right order when they come in random order. Think about VoIP or video streaming - when all the packets needed to play the fragment are received, we can play it.\nOf course in real live streaming, we skipping fragments after some timeout if it not received."
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "This question\\'s description is not understandable/////"
                    },
                    {
                        "username": "rengatta10",
                        "content": "Just imagine you\\'re building a bridge for a robot piece by piece. The robot will only be able to move if it has parts connecting to its location.\\nThe output will be the parts of the bridge that the robot has traversed over after placing the part."
                    },
                    {
                        "username": "abdumaliksobirov007",
                        "content": "Related to a person who writes the description:\\nPlease, write the description in a comprehensible way as the current one is so illegible.\\nThank you in advence!"
                    }
                ]
            },
            {
                "id": 1757500,
                "content": [
                    {
                        "username": "aakash_abhishek",
                        "content": "Unable to understand the question. Feeling better after reading the discussion comments."
                    },
                    {
                        "username": "java_run",
                        "content": "I have tried my best to explain this question in my solution ! \\nPlease go through it : \\n\\nhttps://leetcode.com/problems/design-an-ordered-stream/solutions/3542813/well-explained-solution-with-intuition/"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "The description may be better but the gif gives intuitive understanding what to do. Spent around 10 minutes to approach this problem. Not so bad problem IMHO as for the number of downvotes."
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Except the output is expecting something that\\'s entirely different than what the gif wants.\\n\\nI would have expected `[\\'aaaaa\\', \\'bbbbb\\', \\'ccccc\\', \\'ddddd\\', \\'eeeee\\']` to be the expected output based on the gif.\\n\\nNot `[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]` This makes no sense, genuinely. Why are b and c grouped? Why isn\\'t a in the first empty list?\\n\\nIt follows no pattern and has no reasonable solution to be that way."
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "C3T0",
                        "content": "The description of this question is remarkable. I\\'m still at the reading phase of the problem. Good for me!"
                    },
                    {
                        "username": "ganeshn12",
                        "content": "Instead of reading the whole description again and again, if you follow the video, you will easily understand the question "
                    },
                    {
                        "username": "camaro360degree",
                        "content": "Wtf? The question is inexplicably lame. Hard Pass."
                    },
                    {
                        "username": "Digiton",
                        "content": "To understand the problem save gif animation and then play it manually frame-by-frame, everything will become clear. It's about reconstruction IP packets in right order when they come in random order. Think about VoIP or video streaming - when all the packets needed to play the fragment are received, we can play it.\nOf course in real live streaming, we skipping fragments after some timeout if it not received."
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "This question\\'s description is not understandable/////"
                    },
                    {
                        "username": "rengatta10",
                        "content": "Just imagine you\\'re building a bridge for a robot piece by piece. The robot will only be able to move if it has parts connecting to its location.\\nThe output will be the parts of the bridge that the robot has traversed over after placing the part."
                    },
                    {
                        "username": "abdumaliksobirov007",
                        "content": "Related to a person who writes the description:\\nPlease, write the description in a comprehensible way as the current one is so illegible.\\nThank you in advence!"
                    }
                ]
            },
            {
                "id": 1742431,
                "content": [
                    {
                        "username": "aakash_abhishek",
                        "content": "Unable to understand the question. Feeling better after reading the discussion comments."
                    },
                    {
                        "username": "java_run",
                        "content": "I have tried my best to explain this question in my solution ! \\nPlease go through it : \\n\\nhttps://leetcode.com/problems/design-an-ordered-stream/solutions/3542813/well-explained-solution-with-intuition/"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "The description may be better but the gif gives intuitive understanding what to do. Spent around 10 minutes to approach this problem. Not so bad problem IMHO as for the number of downvotes."
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Except the output is expecting something that\\'s entirely different than what the gif wants.\\n\\nI would have expected `[\\'aaaaa\\', \\'bbbbb\\', \\'ccccc\\', \\'ddddd\\', \\'eeeee\\']` to be the expected output based on the gif.\\n\\nNot `[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]` This makes no sense, genuinely. Why are b and c grouped? Why isn\\'t a in the first empty list?\\n\\nIt follows no pattern and has no reasonable solution to be that way."
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "C3T0",
                        "content": "The description of this question is remarkable. I\\'m still at the reading phase of the problem. Good for me!"
                    },
                    {
                        "username": "ganeshn12",
                        "content": "Instead of reading the whole description again and again, if you follow the video, you will easily understand the question "
                    },
                    {
                        "username": "camaro360degree",
                        "content": "Wtf? The question is inexplicably lame. Hard Pass."
                    },
                    {
                        "username": "Digiton",
                        "content": "To understand the problem save gif animation and then play it manually frame-by-frame, everything will become clear. It's about reconstruction IP packets in right order when they come in random order. Think about VoIP or video streaming - when all the packets needed to play the fragment are received, we can play it.\nOf course in real live streaming, we skipping fragments after some timeout if it not received."
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "This question\\'s description is not understandable/////"
                    },
                    {
                        "username": "rengatta10",
                        "content": "Just imagine you\\'re building a bridge for a robot piece by piece. The robot will only be able to move if it has parts connecting to its location.\\nThe output will be the parts of the bridge that the robot has traversed over after placing the part."
                    },
                    {
                        "username": "abdumaliksobirov007",
                        "content": "Related to a person who writes the description:\\nPlease, write the description in a comprehensible way as the current one is so illegible.\\nThank you in advence!"
                    }
                ]
            },
            {
                "id": 1979926,
                "content": [
                    {
                        "username": "aakash_abhishek",
                        "content": "Unable to understand the question. Feeling better after reading the discussion comments."
                    },
                    {
                        "username": "java_run",
                        "content": "I have tried my best to explain this question in my solution ! \\nPlease go through it : \\n\\nhttps://leetcode.com/problems/design-an-ordered-stream/solutions/3542813/well-explained-solution-with-intuition/"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "The description may be better but the gif gives intuitive understanding what to do. Spent around 10 minutes to approach this problem. Not so bad problem IMHO as for the number of downvotes."
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Except the output is expecting something that\\'s entirely different than what the gif wants.\\n\\nI would have expected `[\\'aaaaa\\', \\'bbbbb\\', \\'ccccc\\', \\'ddddd\\', \\'eeeee\\']` to be the expected output based on the gif.\\n\\nNot `[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]` This makes no sense, genuinely. Why are b and c grouped? Why isn\\'t a in the first empty list?\\n\\nIt follows no pattern and has no reasonable solution to be that way."
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "C3T0",
                        "content": "The description of this question is remarkable. I\\'m still at the reading phase of the problem. Good for me!"
                    },
                    {
                        "username": "ganeshn12",
                        "content": "Instead of reading the whole description again and again, if you follow the video, you will easily understand the question "
                    },
                    {
                        "username": "camaro360degree",
                        "content": "Wtf? The question is inexplicably lame. Hard Pass."
                    },
                    {
                        "username": "Digiton",
                        "content": "To understand the problem save gif animation and then play it manually frame-by-frame, everything will become clear. It's about reconstruction IP packets in right order when they come in random order. Think about VoIP or video streaming - when all the packets needed to play the fragment are received, we can play it.\nOf course in real live streaming, we skipping fragments after some timeout if it not received."
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "This question\\'s description is not understandable/////"
                    },
                    {
                        "username": "rengatta10",
                        "content": "Just imagine you\\'re building a bridge for a robot piece by piece. The robot will only be able to move if it has parts connecting to its location.\\nThe output will be the parts of the bridge that the robot has traversed over after placing the part."
                    },
                    {
                        "username": "abdumaliksobirov007",
                        "content": "Related to a person who writes the description:\\nPlease, write the description in a comprehensible way as the current one is so illegible.\\nThank you in advence!"
                    }
                ]
            },
            {
                "id": 1970115,
                "content": [
                    {
                        "username": "aakash_abhishek",
                        "content": "Unable to understand the question. Feeling better after reading the discussion comments."
                    },
                    {
                        "username": "java_run",
                        "content": "I have tried my best to explain this question in my solution ! \\nPlease go through it : \\n\\nhttps://leetcode.com/problems/design-an-ordered-stream/solutions/3542813/well-explained-solution-with-intuition/"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "The description may be better but the gif gives intuitive understanding what to do. Spent around 10 minutes to approach this problem. Not so bad problem IMHO as for the number of downvotes."
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Except the output is expecting something that\\'s entirely different than what the gif wants.\\n\\nI would have expected `[\\'aaaaa\\', \\'bbbbb\\', \\'ccccc\\', \\'ddddd\\', \\'eeeee\\']` to be the expected output based on the gif.\\n\\nNot `[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]` This makes no sense, genuinely. Why are b and c grouped? Why isn\\'t a in the first empty list?\\n\\nIt follows no pattern and has no reasonable solution to be that way."
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "C3T0",
                        "content": "The description of this question is remarkable. I\\'m still at the reading phase of the problem. Good for me!"
                    },
                    {
                        "username": "ganeshn12",
                        "content": "Instead of reading the whole description again and again, if you follow the video, you will easily understand the question "
                    },
                    {
                        "username": "camaro360degree",
                        "content": "Wtf? The question is inexplicably lame. Hard Pass."
                    },
                    {
                        "username": "Digiton",
                        "content": "To understand the problem save gif animation and then play it manually frame-by-frame, everything will become clear. It's about reconstruction IP packets in right order when they come in random order. Think about VoIP or video streaming - when all the packets needed to play the fragment are received, we can play it.\nOf course in real live streaming, we skipping fragments after some timeout if it not received."
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "This question\\'s description is not understandable/////"
                    },
                    {
                        "username": "rengatta10",
                        "content": "Just imagine you\\'re building a bridge for a robot piece by piece. The robot will only be able to move if it has parts connecting to its location.\\nThe output will be the parts of the bridge that the robot has traversed over after placing the part."
                    },
                    {
                        "username": "abdumaliksobirov007",
                        "content": "Related to a person who writes the description:\\nPlease, write the description in a comprehensible way as the current one is so illegible.\\nThank you in advence!"
                    }
                ]
            },
            {
                "id": 1968205,
                "content": [
                    {
                        "username": "aakash_abhishek",
                        "content": "Unable to understand the question. Feeling better after reading the discussion comments."
                    },
                    {
                        "username": "java_run",
                        "content": "I have tried my best to explain this question in my solution ! \\nPlease go through it : \\n\\nhttps://leetcode.com/problems/design-an-ordered-stream/solutions/3542813/well-explained-solution-with-intuition/"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "The description may be better but the gif gives intuitive understanding what to do. Spent around 10 minutes to approach this problem. Not so bad problem IMHO as for the number of downvotes."
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Except the output is expecting something that\\'s entirely different than what the gif wants.\\n\\nI would have expected `[\\'aaaaa\\', \\'bbbbb\\', \\'ccccc\\', \\'ddddd\\', \\'eeeee\\']` to be the expected output based on the gif.\\n\\nNot `[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]` This makes no sense, genuinely. Why are b and c grouped? Why isn\\'t a in the first empty list?\\n\\nIt follows no pattern and has no reasonable solution to be that way."
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "C3T0",
                        "content": "The description of this question is remarkable. I\\'m still at the reading phase of the problem. Good for me!"
                    },
                    {
                        "username": "ganeshn12",
                        "content": "Instead of reading the whole description again and again, if you follow the video, you will easily understand the question "
                    },
                    {
                        "username": "camaro360degree",
                        "content": "Wtf? The question is inexplicably lame. Hard Pass."
                    },
                    {
                        "username": "Digiton",
                        "content": "To understand the problem save gif animation and then play it manually frame-by-frame, everything will become clear. It's about reconstruction IP packets in right order when they come in random order. Think about VoIP or video streaming - when all the packets needed to play the fragment are received, we can play it.\nOf course in real live streaming, we skipping fragments after some timeout if it not received."
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "This question\\'s description is not understandable/////"
                    },
                    {
                        "username": "rengatta10",
                        "content": "Just imagine you\\'re building a bridge for a robot piece by piece. The robot will only be able to move if it has parts connecting to its location.\\nThe output will be the parts of the bridge that the robot has traversed over after placing the part."
                    },
                    {
                        "username": "abdumaliksobirov007",
                        "content": "Related to a person who writes the description:\\nPlease, write the description in a comprehensible way as the current one is so illegible.\\nThank you in advence!"
                    }
                ]
            },
            {
                "id": 1957857,
                "content": [
                    {
                        "username": "aakash_abhishek",
                        "content": "Unable to understand the question. Feeling better after reading the discussion comments."
                    },
                    {
                        "username": "java_run",
                        "content": "I have tried my best to explain this question in my solution ! \\nPlease go through it : \\n\\nhttps://leetcode.com/problems/design-an-ordered-stream/solutions/3542813/well-explained-solution-with-intuition/"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "The description may be better but the gif gives intuitive understanding what to do. Spent around 10 minutes to approach this problem. Not so bad problem IMHO as for the number of downvotes."
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Except the output is expecting something that\\'s entirely different than what the gif wants.\\n\\nI would have expected `[\\'aaaaa\\', \\'bbbbb\\', \\'ccccc\\', \\'ddddd\\', \\'eeeee\\']` to be the expected output based on the gif.\\n\\nNot `[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]` This makes no sense, genuinely. Why are b and c grouped? Why isn\\'t a in the first empty list?\\n\\nIt follows no pattern and has no reasonable solution to be that way."
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "C3T0",
                        "content": "The description of this question is remarkable. I\\'m still at the reading phase of the problem. Good for me!"
                    },
                    {
                        "username": "ganeshn12",
                        "content": "Instead of reading the whole description again and again, if you follow the video, you will easily understand the question "
                    },
                    {
                        "username": "camaro360degree",
                        "content": "Wtf? The question is inexplicably lame. Hard Pass."
                    },
                    {
                        "username": "Digiton",
                        "content": "To understand the problem save gif animation and then play it manually frame-by-frame, everything will become clear. It's about reconstruction IP packets in right order when they come in random order. Think about VoIP or video streaming - when all the packets needed to play the fragment are received, we can play it.\nOf course in real live streaming, we skipping fragments after some timeout if it not received."
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "This question\\'s description is not understandable/////"
                    },
                    {
                        "username": "rengatta10",
                        "content": "Just imagine you\\'re building a bridge for a robot piece by piece. The robot will only be able to move if it has parts connecting to its location.\\nThe output will be the parts of the bridge that the robot has traversed over after placing the part."
                    },
                    {
                        "username": "abdumaliksobirov007",
                        "content": "Related to a person who writes the description:\\nPlease, write the description in a comprehensible way as the current one is so illegible.\\nThank you in advence!"
                    }
                ]
            },
            {
                "id": 1905905,
                "content": [
                    {
                        "username": "aakash_abhishek",
                        "content": "Unable to understand the question. Feeling better after reading the discussion comments."
                    },
                    {
                        "username": "java_run",
                        "content": "I have tried my best to explain this question in my solution ! \\nPlease go through it : \\n\\nhttps://leetcode.com/problems/design-an-ordered-stream/solutions/3542813/well-explained-solution-with-intuition/"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "The description may be better but the gif gives intuitive understanding what to do. Spent around 10 minutes to approach this problem. Not so bad problem IMHO as for the number of downvotes."
                    },
                    {
                        "username": "MinimumArmidillo1384",
                        "content": "Except the output is expecting something that\\'s entirely different than what the gif wants.\\n\\nI would have expected `[\\'aaaaa\\', \\'bbbbb\\', \\'ccccc\\', \\'ddddd\\', \\'eeeee\\']` to be the expected output based on the gif.\\n\\nNot `[null,[],[\"aaaaa\"],[\"bbbbb\",\"ccccc\"],[],[\"ddddd\",\"eeeee\"]]` This makes no sense, genuinely. Why are b and c grouped? Why isn\\'t a in the first empty list?\\n\\nIt follows no pattern and has no reasonable solution to be that way."
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "C3T0",
                        "content": "The description of this question is remarkable. I\\'m still at the reading phase of the problem. Good for me!"
                    },
                    {
                        "username": "ganeshn12",
                        "content": "Instead of reading the whole description again and again, if you follow the video, you will easily understand the question "
                    },
                    {
                        "username": "camaro360degree",
                        "content": "Wtf? The question is inexplicably lame. Hard Pass."
                    },
                    {
                        "username": "Digiton",
                        "content": "To understand the problem save gif animation and then play it manually frame-by-frame, everything will become clear. It's about reconstruction IP packets in right order when they come in random order. Think about VoIP or video streaming - when all the packets needed to play the fragment are received, we can play it.\nOf course in real live streaming, we skipping fragments after some timeout if it not received."
                    },
                    {
                        "username": "rahulforcoding4",
                        "content": "This question\\'s description is not understandable/////"
                    },
                    {
                        "username": "rengatta10",
                        "content": "Just imagine you\\'re building a bridge for a robot piece by piece. The robot will only be able to move if it has parts connecting to its location.\\nThe output will be the parts of the bridge that the robot has traversed over after placing the part."
                    },
                    {
                        "username": "abdumaliksobirov007",
                        "content": "Related to a person who writes the description:\\nPlease, write the description in a comprehensible way as the current one is so illegible.\\nThank you in advence!"
                    }
                ]
            },
            {
                "id": 1899268,
                "content": [
                    {
                        "username": "java_run",
                        "content": "TBH , this is really a good question .\\nDescription is hard to understand though ."
                    },
                    {
                        "username": "JangoBoogaloo",
                        "content": "I will quit this interview if I get this question. So, bye Bloomberg"
                    },
                    {
                        "username": "RinatMambetov",
                        "content": "In js solution just make class with function \\'insert\\' and constructor. Variable \\'n\\' not need..."
                    },
                    {
                        "username": "learncodewithpanda",
                        "content": "Question is confusing, but the diagram in the example gave the solution. I came up with solution, it was straight forward simulation of the example, but have no understanding of what is happening or why. "
                    },
                    {
                        "username": "jayanthasipalli2002",
                        "content": "This particular question description is so bad that yo can\\'t figure out what to be done even if you are given with enough time;"
                    },
                    {
                        "username": "Sim_Yeon",
                        "content": "i am not doing this.. whatever......"
                    },
                    {
                        "username": "mikasa_pals",
                        "content": "why does insert (1, \\'aaa\\') return [\\'aaa\\'] but insert (5, \\'eee\\') not return anything?"
                    },
                    {
                        "username": "pratyakshsingh11",
                        "content": "exactly! I don\\'t know what is happening in this problem."
                    },
                    {
                        "username": "mohak0",
                        "content": "What\\'s the point of adding such vague descriptions to problems? What are we supposed to do, read minds?"
                    },
                    {
                        "username": "AnnaBNana",
                        "content": "Even watching the video several times this remained confusing. Thanks to those who explained here in the discussion. \\n\\nIs anyone else bothered by (well, the whole thing) the fact that it\\'s apparently not 0-indexed? I hate that more than any other thing about this question. \\n\\nThat being said, I\\'ve been asked similarly hard-to-understand questions in interviews before, and as I understand it, they are attempting to ensure that the candidate does a good job of communicating and asking questions when confused, and I can\\'t even say I hate them for trying to determine how candidates behave in this situation. Have you ever had a coworker that just nods and smiles and asks no questions when scoping a ticket, spends weeks longer than initially estimated, does a poor job of communicating about progress, even when asked directly, and then delivers the wrong thing? It sucks.\\n\\nSo yeah, it\\'s reasonable to practice with these types of questions. Learn to explore, ask questions (here that\\'s harder, but the discussion has done well in this case), and spend time understanding before just reflexively starting to code."
                    },
                    {
                        "username": "patrickwl",
                        "content": "I think this question should be rewritten clearly as to what should be returned- and what is that ptr doing? "
                    }
                ]
            },
            {
                "id": 1897290,
                "content": [
                    {
                        "username": "java_run",
                        "content": "TBH , this is really a good question .\\nDescription is hard to understand though ."
                    },
                    {
                        "username": "JangoBoogaloo",
                        "content": "I will quit this interview if I get this question. So, bye Bloomberg"
                    },
                    {
                        "username": "RinatMambetov",
                        "content": "In js solution just make class with function \\'insert\\' and constructor. Variable \\'n\\' not need..."
                    },
                    {
                        "username": "learncodewithpanda",
                        "content": "Question is confusing, but the diagram in the example gave the solution. I came up with solution, it was straight forward simulation of the example, but have no understanding of what is happening or why. "
                    },
                    {
                        "username": "jayanthasipalli2002",
                        "content": "This particular question description is so bad that yo can\\'t figure out what to be done even if you are given with enough time;"
                    },
                    {
                        "username": "Sim_Yeon",
                        "content": "i am not doing this.. whatever......"
                    },
                    {
                        "username": "mikasa_pals",
                        "content": "why does insert (1, \\'aaa\\') return [\\'aaa\\'] but insert (5, \\'eee\\') not return anything?"
                    },
                    {
                        "username": "pratyakshsingh11",
                        "content": "exactly! I don\\'t know what is happening in this problem."
                    },
                    {
                        "username": "mohak0",
                        "content": "What\\'s the point of adding such vague descriptions to problems? What are we supposed to do, read minds?"
                    },
                    {
                        "username": "AnnaBNana",
                        "content": "Even watching the video several times this remained confusing. Thanks to those who explained here in the discussion. \\n\\nIs anyone else bothered by (well, the whole thing) the fact that it\\'s apparently not 0-indexed? I hate that more than any other thing about this question. \\n\\nThat being said, I\\'ve been asked similarly hard-to-understand questions in interviews before, and as I understand it, they are attempting to ensure that the candidate does a good job of communicating and asking questions when confused, and I can\\'t even say I hate them for trying to determine how candidates behave in this situation. Have you ever had a coworker that just nods and smiles and asks no questions when scoping a ticket, spends weeks longer than initially estimated, does a poor job of communicating about progress, even when asked directly, and then delivers the wrong thing? It sucks.\\n\\nSo yeah, it\\'s reasonable to practice with these types of questions. Learn to explore, ask questions (here that\\'s harder, but the discussion has done well in this case), and spend time understanding before just reflexively starting to code."
                    },
                    {
                        "username": "patrickwl",
                        "content": "I think this question should be rewritten clearly as to what should be returned- and what is that ptr doing? "
                    }
                ]
            },
            {
                "id": 1888364,
                "content": [
                    {
                        "username": "java_run",
                        "content": "TBH , this is really a good question .\\nDescription is hard to understand though ."
                    },
                    {
                        "username": "JangoBoogaloo",
                        "content": "I will quit this interview if I get this question. So, bye Bloomberg"
                    },
                    {
                        "username": "RinatMambetov",
                        "content": "In js solution just make class with function \\'insert\\' and constructor. Variable \\'n\\' not need..."
                    },
                    {
                        "username": "learncodewithpanda",
                        "content": "Question is confusing, but the diagram in the example gave the solution. I came up with solution, it was straight forward simulation of the example, but have no understanding of what is happening or why. "
                    },
                    {
                        "username": "jayanthasipalli2002",
                        "content": "This particular question description is so bad that yo can\\'t figure out what to be done even if you are given with enough time;"
                    },
                    {
                        "username": "Sim_Yeon",
                        "content": "i am not doing this.. whatever......"
                    },
                    {
                        "username": "mikasa_pals",
                        "content": "why does insert (1, \\'aaa\\') return [\\'aaa\\'] but insert (5, \\'eee\\') not return anything?"
                    },
                    {
                        "username": "pratyakshsingh11",
                        "content": "exactly! I don\\'t know what is happening in this problem."
                    },
                    {
                        "username": "mohak0",
                        "content": "What\\'s the point of adding such vague descriptions to problems? What are we supposed to do, read minds?"
                    },
                    {
                        "username": "AnnaBNana",
                        "content": "Even watching the video several times this remained confusing. Thanks to those who explained here in the discussion. \\n\\nIs anyone else bothered by (well, the whole thing) the fact that it\\'s apparently not 0-indexed? I hate that more than any other thing about this question. \\n\\nThat being said, I\\'ve been asked similarly hard-to-understand questions in interviews before, and as I understand it, they are attempting to ensure that the candidate does a good job of communicating and asking questions when confused, and I can\\'t even say I hate them for trying to determine how candidates behave in this situation. Have you ever had a coworker that just nods and smiles and asks no questions when scoping a ticket, spends weeks longer than initially estimated, does a poor job of communicating about progress, even when asked directly, and then delivers the wrong thing? It sucks.\\n\\nSo yeah, it\\'s reasonable to practice with these types of questions. Learn to explore, ask questions (here that\\'s harder, but the discussion has done well in this case), and spend time understanding before just reflexively starting to code."
                    },
                    {
                        "username": "patrickwl",
                        "content": "I think this question should be rewritten clearly as to what should be returned- and what is that ptr doing? "
                    }
                ]
            },
            {
                "id": 1881500,
                "content": [
                    {
                        "username": "java_run",
                        "content": "TBH , this is really a good question .\\nDescription is hard to understand though ."
                    },
                    {
                        "username": "JangoBoogaloo",
                        "content": "I will quit this interview if I get this question. So, bye Bloomberg"
                    },
                    {
                        "username": "RinatMambetov",
                        "content": "In js solution just make class with function \\'insert\\' and constructor. Variable \\'n\\' not need..."
                    },
                    {
                        "username": "learncodewithpanda",
                        "content": "Question is confusing, but the diagram in the example gave the solution. I came up with solution, it was straight forward simulation of the example, but have no understanding of what is happening or why. "
                    },
                    {
                        "username": "jayanthasipalli2002",
                        "content": "This particular question description is so bad that yo can\\'t figure out what to be done even if you are given with enough time;"
                    },
                    {
                        "username": "Sim_Yeon",
                        "content": "i am not doing this.. whatever......"
                    },
                    {
                        "username": "mikasa_pals",
                        "content": "why does insert (1, \\'aaa\\') return [\\'aaa\\'] but insert (5, \\'eee\\') not return anything?"
                    },
                    {
                        "username": "pratyakshsingh11",
                        "content": "exactly! I don\\'t know what is happening in this problem."
                    },
                    {
                        "username": "mohak0",
                        "content": "What\\'s the point of adding such vague descriptions to problems? What are we supposed to do, read minds?"
                    },
                    {
                        "username": "AnnaBNana",
                        "content": "Even watching the video several times this remained confusing. Thanks to those who explained here in the discussion. \\n\\nIs anyone else bothered by (well, the whole thing) the fact that it\\'s apparently not 0-indexed? I hate that more than any other thing about this question. \\n\\nThat being said, I\\'ve been asked similarly hard-to-understand questions in interviews before, and as I understand it, they are attempting to ensure that the candidate does a good job of communicating and asking questions when confused, and I can\\'t even say I hate them for trying to determine how candidates behave in this situation. Have you ever had a coworker that just nods and smiles and asks no questions when scoping a ticket, spends weeks longer than initially estimated, does a poor job of communicating about progress, even when asked directly, and then delivers the wrong thing? It sucks.\\n\\nSo yeah, it\\'s reasonable to practice with these types of questions. Learn to explore, ask questions (here that\\'s harder, but the discussion has done well in this case), and spend time understanding before just reflexively starting to code."
                    },
                    {
                        "username": "patrickwl",
                        "content": "I think this question should be rewritten clearly as to what should be returned- and what is that ptr doing? "
                    }
                ]
            },
            {
                "id": 1853226,
                "content": [
                    {
                        "username": "java_run",
                        "content": "TBH , this is really a good question .\\nDescription is hard to understand though ."
                    },
                    {
                        "username": "JangoBoogaloo",
                        "content": "I will quit this interview if I get this question. So, bye Bloomberg"
                    },
                    {
                        "username": "RinatMambetov",
                        "content": "In js solution just make class with function \\'insert\\' and constructor. Variable \\'n\\' not need..."
                    },
                    {
                        "username": "learncodewithpanda",
                        "content": "Question is confusing, but the diagram in the example gave the solution. I came up with solution, it was straight forward simulation of the example, but have no understanding of what is happening or why. "
                    },
                    {
                        "username": "jayanthasipalli2002",
                        "content": "This particular question description is so bad that yo can\\'t figure out what to be done even if you are given with enough time;"
                    },
                    {
                        "username": "Sim_Yeon",
                        "content": "i am not doing this.. whatever......"
                    },
                    {
                        "username": "mikasa_pals",
                        "content": "why does insert (1, \\'aaa\\') return [\\'aaa\\'] but insert (5, \\'eee\\') not return anything?"
                    },
                    {
                        "username": "pratyakshsingh11",
                        "content": "exactly! I don\\'t know what is happening in this problem."
                    },
                    {
                        "username": "mohak0",
                        "content": "What\\'s the point of adding such vague descriptions to problems? What are we supposed to do, read minds?"
                    },
                    {
                        "username": "AnnaBNana",
                        "content": "Even watching the video several times this remained confusing. Thanks to those who explained here in the discussion. \\n\\nIs anyone else bothered by (well, the whole thing) the fact that it\\'s apparently not 0-indexed? I hate that more than any other thing about this question. \\n\\nThat being said, I\\'ve been asked similarly hard-to-understand questions in interviews before, and as I understand it, they are attempting to ensure that the candidate does a good job of communicating and asking questions when confused, and I can\\'t even say I hate them for trying to determine how candidates behave in this situation. Have you ever had a coworker that just nods and smiles and asks no questions when scoping a ticket, spends weeks longer than initially estimated, does a poor job of communicating about progress, even when asked directly, and then delivers the wrong thing? It sucks.\\n\\nSo yeah, it\\'s reasonable to practice with these types of questions. Learn to explore, ask questions (here that\\'s harder, but the discussion has done well in this case), and spend time understanding before just reflexively starting to code."
                    },
                    {
                        "username": "patrickwl",
                        "content": "I think this question should be rewritten clearly as to what should be returned- and what is that ptr doing? "
                    }
                ]
            },
            {
                "id": 1851304,
                "content": [
                    {
                        "username": "java_run",
                        "content": "TBH , this is really a good question .\\nDescription is hard to understand though ."
                    },
                    {
                        "username": "JangoBoogaloo",
                        "content": "I will quit this interview if I get this question. So, bye Bloomberg"
                    },
                    {
                        "username": "RinatMambetov",
                        "content": "In js solution just make class with function \\'insert\\' and constructor. Variable \\'n\\' not need..."
                    },
                    {
                        "username": "learncodewithpanda",
                        "content": "Question is confusing, but the diagram in the example gave the solution. I came up with solution, it was straight forward simulation of the example, but have no understanding of what is happening or why. "
                    },
                    {
                        "username": "jayanthasipalli2002",
                        "content": "This particular question description is so bad that yo can\\'t figure out what to be done even if you are given with enough time;"
                    },
                    {
                        "username": "Sim_Yeon",
                        "content": "i am not doing this.. whatever......"
                    },
                    {
                        "username": "mikasa_pals",
                        "content": "why does insert (1, \\'aaa\\') return [\\'aaa\\'] but insert (5, \\'eee\\') not return anything?"
                    },
                    {
                        "username": "pratyakshsingh11",
                        "content": "exactly! I don\\'t know what is happening in this problem."
                    },
                    {
                        "username": "mohak0",
                        "content": "What\\'s the point of adding such vague descriptions to problems? What are we supposed to do, read minds?"
                    },
                    {
                        "username": "AnnaBNana",
                        "content": "Even watching the video several times this remained confusing. Thanks to those who explained here in the discussion. \\n\\nIs anyone else bothered by (well, the whole thing) the fact that it\\'s apparently not 0-indexed? I hate that more than any other thing about this question. \\n\\nThat being said, I\\'ve been asked similarly hard-to-understand questions in interviews before, and as I understand it, they are attempting to ensure that the candidate does a good job of communicating and asking questions when confused, and I can\\'t even say I hate them for trying to determine how candidates behave in this situation. Have you ever had a coworker that just nods and smiles and asks no questions when scoping a ticket, spends weeks longer than initially estimated, does a poor job of communicating about progress, even when asked directly, and then delivers the wrong thing? It sucks.\\n\\nSo yeah, it\\'s reasonable to practice with these types of questions. Learn to explore, ask questions (here that\\'s harder, but the discussion has done well in this case), and spend time understanding before just reflexively starting to code."
                    },
                    {
                        "username": "patrickwl",
                        "content": "I think this question should be rewritten clearly as to what should be returned- and what is that ptr doing? "
                    }
                ]
            },
            {
                "id": 1824378,
                "content": [
                    {
                        "username": "java_run",
                        "content": "TBH , this is really a good question .\\nDescription is hard to understand though ."
                    },
                    {
                        "username": "JangoBoogaloo",
                        "content": "I will quit this interview if I get this question. So, bye Bloomberg"
                    },
                    {
                        "username": "RinatMambetov",
                        "content": "In js solution just make class with function \\'insert\\' and constructor. Variable \\'n\\' not need..."
                    },
                    {
                        "username": "learncodewithpanda",
                        "content": "Question is confusing, but the diagram in the example gave the solution. I came up with solution, it was straight forward simulation of the example, but have no understanding of what is happening or why. "
                    },
                    {
                        "username": "jayanthasipalli2002",
                        "content": "This particular question description is so bad that yo can\\'t figure out what to be done even if you are given with enough time;"
                    },
                    {
                        "username": "Sim_Yeon",
                        "content": "i am not doing this.. whatever......"
                    },
                    {
                        "username": "mikasa_pals",
                        "content": "why does insert (1, \\'aaa\\') return [\\'aaa\\'] but insert (5, \\'eee\\') not return anything?"
                    },
                    {
                        "username": "pratyakshsingh11",
                        "content": "exactly! I don\\'t know what is happening in this problem."
                    },
                    {
                        "username": "mohak0",
                        "content": "What\\'s the point of adding such vague descriptions to problems? What are we supposed to do, read minds?"
                    },
                    {
                        "username": "AnnaBNana",
                        "content": "Even watching the video several times this remained confusing. Thanks to those who explained here in the discussion. \\n\\nIs anyone else bothered by (well, the whole thing) the fact that it\\'s apparently not 0-indexed? I hate that more than any other thing about this question. \\n\\nThat being said, I\\'ve been asked similarly hard-to-understand questions in interviews before, and as I understand it, they are attempting to ensure that the candidate does a good job of communicating and asking questions when confused, and I can\\'t even say I hate them for trying to determine how candidates behave in this situation. Have you ever had a coworker that just nods and smiles and asks no questions when scoping a ticket, spends weeks longer than initially estimated, does a poor job of communicating about progress, even when asked directly, and then delivers the wrong thing? It sucks.\\n\\nSo yeah, it\\'s reasonable to practice with these types of questions. Learn to explore, ask questions (here that\\'s harder, but the discussion has done well in this case), and spend time understanding before just reflexively starting to code."
                    },
                    {
                        "username": "patrickwl",
                        "content": "I think this question should be rewritten clearly as to what should be returned- and what is that ptr doing? "
                    }
                ]
            },
            {
                "id": 1821671,
                "content": [
                    {
                        "username": "java_run",
                        "content": "TBH , this is really a good question .\\nDescription is hard to understand though ."
                    },
                    {
                        "username": "JangoBoogaloo",
                        "content": "I will quit this interview if I get this question. So, bye Bloomberg"
                    },
                    {
                        "username": "RinatMambetov",
                        "content": "In js solution just make class with function \\'insert\\' and constructor. Variable \\'n\\' not need..."
                    },
                    {
                        "username": "learncodewithpanda",
                        "content": "Question is confusing, but the diagram in the example gave the solution. I came up with solution, it was straight forward simulation of the example, but have no understanding of what is happening or why. "
                    },
                    {
                        "username": "jayanthasipalli2002",
                        "content": "This particular question description is so bad that yo can\\'t figure out what to be done even if you are given with enough time;"
                    },
                    {
                        "username": "Sim_Yeon",
                        "content": "i am not doing this.. whatever......"
                    },
                    {
                        "username": "mikasa_pals",
                        "content": "why does insert (1, \\'aaa\\') return [\\'aaa\\'] but insert (5, \\'eee\\') not return anything?"
                    },
                    {
                        "username": "pratyakshsingh11",
                        "content": "exactly! I don\\'t know what is happening in this problem."
                    },
                    {
                        "username": "mohak0",
                        "content": "What\\'s the point of adding such vague descriptions to problems? What are we supposed to do, read minds?"
                    },
                    {
                        "username": "AnnaBNana",
                        "content": "Even watching the video several times this remained confusing. Thanks to those who explained here in the discussion. \\n\\nIs anyone else bothered by (well, the whole thing) the fact that it\\'s apparently not 0-indexed? I hate that more than any other thing about this question. \\n\\nThat being said, I\\'ve been asked similarly hard-to-understand questions in interviews before, and as I understand it, they are attempting to ensure that the candidate does a good job of communicating and asking questions when confused, and I can\\'t even say I hate them for trying to determine how candidates behave in this situation. Have you ever had a coworker that just nods and smiles and asks no questions when scoping a ticket, spends weeks longer than initially estimated, does a poor job of communicating about progress, even when asked directly, and then delivers the wrong thing? It sucks.\\n\\nSo yeah, it\\'s reasonable to practice with these types of questions. Learn to explore, ask questions (here that\\'s harder, but the discussion has done well in this case), and spend time understanding before just reflexively starting to code."
                    },
                    {
                        "username": "patrickwl",
                        "content": "I think this question should be rewritten clearly as to what should be returned- and what is that ptr doing? "
                    }
                ]
            },
            {
                "id": 1820985,
                "content": [
                    {
                        "username": "java_run",
                        "content": "TBH , this is really a good question .\\nDescription is hard to understand though ."
                    },
                    {
                        "username": "JangoBoogaloo",
                        "content": "I will quit this interview if I get this question. So, bye Bloomberg"
                    },
                    {
                        "username": "RinatMambetov",
                        "content": "In js solution just make class with function \\'insert\\' and constructor. Variable \\'n\\' not need..."
                    },
                    {
                        "username": "learncodewithpanda",
                        "content": "Question is confusing, but the diagram in the example gave the solution. I came up with solution, it was straight forward simulation of the example, but have no understanding of what is happening or why. "
                    },
                    {
                        "username": "jayanthasipalli2002",
                        "content": "This particular question description is so bad that yo can\\'t figure out what to be done even if you are given with enough time;"
                    },
                    {
                        "username": "Sim_Yeon",
                        "content": "i am not doing this.. whatever......"
                    },
                    {
                        "username": "mikasa_pals",
                        "content": "why does insert (1, \\'aaa\\') return [\\'aaa\\'] but insert (5, \\'eee\\') not return anything?"
                    },
                    {
                        "username": "pratyakshsingh11",
                        "content": "exactly! I don\\'t know what is happening in this problem."
                    },
                    {
                        "username": "mohak0",
                        "content": "What\\'s the point of adding such vague descriptions to problems? What are we supposed to do, read minds?"
                    },
                    {
                        "username": "AnnaBNana",
                        "content": "Even watching the video several times this remained confusing. Thanks to those who explained here in the discussion. \\n\\nIs anyone else bothered by (well, the whole thing) the fact that it\\'s apparently not 0-indexed? I hate that more than any other thing about this question. \\n\\nThat being said, I\\'ve been asked similarly hard-to-understand questions in interviews before, and as I understand it, they are attempting to ensure that the candidate does a good job of communicating and asking questions when confused, and I can\\'t even say I hate them for trying to determine how candidates behave in this situation. Have you ever had a coworker that just nods and smiles and asks no questions when scoping a ticket, spends weeks longer than initially estimated, does a poor job of communicating about progress, even when asked directly, and then delivers the wrong thing? It sucks.\\n\\nSo yeah, it\\'s reasonable to practice with these types of questions. Learn to explore, ask questions (here that\\'s harder, but the discussion has done well in this case), and spend time understanding before just reflexively starting to code."
                    },
                    {
                        "username": "patrickwl",
                        "content": "I think this question should be rewritten clearly as to what should be returned- and what is that ptr doing? "
                    }
                ]
            },
            {
                "id": 1820918,
                "content": [
                    {
                        "username": "java_run",
                        "content": "TBH , this is really a good question .\\nDescription is hard to understand though ."
                    },
                    {
                        "username": "JangoBoogaloo",
                        "content": "I will quit this interview if I get this question. So, bye Bloomberg"
                    },
                    {
                        "username": "RinatMambetov",
                        "content": "In js solution just make class with function \\'insert\\' and constructor. Variable \\'n\\' not need..."
                    },
                    {
                        "username": "learncodewithpanda",
                        "content": "Question is confusing, but the diagram in the example gave the solution. I came up with solution, it was straight forward simulation of the example, but have no understanding of what is happening or why. "
                    },
                    {
                        "username": "jayanthasipalli2002",
                        "content": "This particular question description is so bad that yo can\\'t figure out what to be done even if you are given with enough time;"
                    },
                    {
                        "username": "Sim_Yeon",
                        "content": "i am not doing this.. whatever......"
                    },
                    {
                        "username": "mikasa_pals",
                        "content": "why does insert (1, \\'aaa\\') return [\\'aaa\\'] but insert (5, \\'eee\\') not return anything?"
                    },
                    {
                        "username": "pratyakshsingh11",
                        "content": "exactly! I don\\'t know what is happening in this problem."
                    },
                    {
                        "username": "mohak0",
                        "content": "What\\'s the point of adding such vague descriptions to problems? What are we supposed to do, read minds?"
                    },
                    {
                        "username": "AnnaBNana",
                        "content": "Even watching the video several times this remained confusing. Thanks to those who explained here in the discussion. \\n\\nIs anyone else bothered by (well, the whole thing) the fact that it\\'s apparently not 0-indexed? I hate that more than any other thing about this question. \\n\\nThat being said, I\\'ve been asked similarly hard-to-understand questions in interviews before, and as I understand it, they are attempting to ensure that the candidate does a good job of communicating and asking questions when confused, and I can\\'t even say I hate them for trying to determine how candidates behave in this situation. Have you ever had a coworker that just nods and smiles and asks no questions when scoping a ticket, spends weeks longer than initially estimated, does a poor job of communicating about progress, even when asked directly, and then delivers the wrong thing? It sucks.\\n\\nSo yeah, it\\'s reasonable to practice with these types of questions. Learn to explore, ask questions (here that\\'s harder, but the discussion has done well in this case), and spend time understanding before just reflexively starting to code."
                    },
                    {
                        "username": "patrickwl",
                        "content": "I think this question should be rewritten clearly as to what should be returned- and what is that ptr doing? "
                    }
                ]
            }
        ]
    },
    {
        "title": "Determine if Two Strings Are Close",
        "question_content": "<p>Two strings are considered <strong>close</strong> if you can attain one from the other using the following operations:</p>\n\n<ul>\n\t<li>Operation 1: Swap any two <strong>existing</strong> characters.\n\n\t<ul>\n\t\t<li>For example, <code>a<u>b</u>cd<u>e</u> -&gt; a<u>e</u>cd<u>b</u></code></li>\n\t</ul>\n\t</li>\n\t<li>Operation 2: Transform <strong>every</strong> occurrence of one <strong>existing</strong> character into another <strong>existing</strong> character, and do the same with the other character.\n\t<ul>\n\t\t<li>For example, <code><u>aa</u>c<u>abb</u> -&gt; <u>bb</u>c<u>baa</u></code> (all <code>a</code>&#39;s turn into <code>b</code>&#39;s, and all <code>b</code>&#39;s turn into <code>a</code>&#39;s)</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>You can use the operations on either string as many times as necessary.</p>\n\n<p>Given two strings, <code>word1</code> and <code>word2</code>, return <code>true</code><em> if </em><code>word1</code><em> and </em><code>word2</code><em> are <strong>close</strong>, and </em><code>false</code><em> otherwise.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;abc&quot;, word2 = &quot;bca&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> You can attain word2 from word1 in 2 operations.\nApply Operation 1: &quot;a<u>bc</u>&quot; -&gt; &quot;a<u>cb</u>&quot;\nApply Operation 1: &quot;<u>a</u>c<u>b</u>&quot; -&gt; &quot;<u>b</u>c<u>a</u>&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;a&quot;, word2 = &quot;aa&quot;\n<strong>Output:</strong> false\n<strong>Explanation: </strong>It is impossible to attain word2 from word1, or vice versa, in any number of operations.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;cabbba&quot;, word2 = &quot;abbccc&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> You can attain word2 from word1 in 3 operations.\nApply Operation 1: &quot;ca<u>b</u>bb<u>a</u>&quot; -&gt; &quot;ca<u>a</u>bb<u>b</u>&quot;\n<code>Apply Operation 2: &quot;</code><u>c</u>aa<u>bbb</u>&quot; -&gt; &quot;<u>b</u>aa<u>ccc</u>&quot;\nApply Operation 2: &quot;<u>baa</u>ccc&quot; -&gt; &quot;<u>abb</u>ccc&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word1.length, word2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>word1</code> and <code>word2</code> contain only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 935920,
                "title": "c-short-and-simple-o-n-solution",
                "content": "**Idea :** Two thing\\'s Need to check \\n1. Frequency of Char need\\'s to be same there both of string as we can do **Transform every occurrence of one existing character into another existing character**\\n2. All the unique char which  there in String1 need\\'s to there as well In string2 \\n\\n**let\\'s See One example :** \\n```\\nString 1 = \"aabaacczp\"        String 2=\"bbzbbaacp\"\\nFrequency in string1 :                         Frequency in string2 :\\n\\t    a->4                                                b->4\\n\\t\\tb->1                                                a->2\\n\\t\\tc->2                                                z->1\\n\\t\\tz->1                                                c->1\\n\\t\\tp->1                                                p->1\\n\\t\\t\\nsee in String 1 count array ->   1, 1, 1, 2, 4 =>sorted order\\nand in String 2 count array ->   1, 1, 1, 2, 4 =>sorted order\\n\\nUnique all char   a,b,c,z,p  in string 1 is there as well in string2 so it\\'s a valid One just return True\\n\\n```\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        vector<int>w1(26,0),w2(26,0);\\n        set<char>s1,s2;\\n        for(char c:word1){\\n            w1[c-\\'a\\']++;\\n            s1.insert(c);\\n        }\\n        for(char c:word2){\\n            w2[c-\\'a\\']++;\\n            s2.insert(c);\\n        }\\n        sort(begin(w1),end(w1));\\n        sort(begin(w2),end(w2));\\n        return w1==w2&&s1==s2;\\n    }\\n};\\n```\\n**One Improvemnt :**\\nInsted of use set we can Use normal array to reduce time complexcity into **O(Nlog N) to O(N)**\\nFallowing the improve code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        vector<int>w1(26,0),w2(26,0),w3(26,0),w4(26,0);\\n        for(char c:word1)\\n            w1[c-\\'a\\']++,w3[c-\\'a\\'] = 1;\\n    \\n        for(char c:word2)\\n            w2[c-\\'a\\']++,w4[c-\\'a\\'] = 1;\\n        \\n        sort(begin(w1),end(w1));\\n        sort(begin(w2),end(w2));\\n        return w1==w2&&w3==w4;\\n    }\\n};\\n```\\nAny doubt ask There\\nFor help please **Upvote**\\n**Thank You :)**",
                "solutionTags": [],
                "code": "```\\nString 1 = \"aabaacczp\"        String 2=\"bbzbbaacp\"\\nFrequency in string1 :                         Frequency in string2 :\\n\\t    a->4                                                b->4\\n\\t\\tb->1                                                a->2\\n\\t\\tc->2                                                z->1\\n\\t\\tz->1                                                c->1\\n\\t\\tp->1                                                p->1\\n\\t\\t\\nsee in String 1 count array ->   1, 1, 1, 2, 4 =>sorted order\\nand in String 2 count array ->   1, 1, 1, 2, 4 =>sorted order\\n\\nUnique all char   a,b,c,z,p  in string 1 is there as well in string2 so it\\'s a valid One just return True\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        vector<int>w1(26,0),w2(26,0);\\n        set<char>s1,s2;\\n        for(char c:word1){\\n            w1[c-\\'a\\']++;\\n            s1.insert(c);\\n        }\\n        for(char c:word2){\\n            w2[c-\\'a\\']++;\\n            s2.insert(c);\\n        }\\n        sort(begin(w1),end(w1));\\n        sort(begin(w2),end(w2));\\n        return w1==w2&&s1==s2;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        vector<int>w1(26,0),w2(26,0),w3(26,0),w4(26,0);\\n        for(char c:word1)\\n            w1[c-\\'a\\']++,w3[c-\\'a\\'] = 1;\\n    \\n        for(char c:word2)\\n            w2[c-\\'a\\']++,w4[c-\\'a\\'] = 1;\\n        \\n        sort(begin(w1),end(w1));\\n        sort(begin(w2),end(w2));\\n        return w1==w2&&w3==w4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029064,
                "title": "python-oneliner-with-counter-explained",
                "content": "Let us look more carefully at this problem:\\n1. Operation 1 allows us to swap any two symbols, so what matters in the end not order of them, but how many of each symbol we have. Imagine we have `(6, 3, 3, 5, 6, 6)` frequencies of symbols, than we need to have the same frequencies for the second string as well. So, we need to check if we have the same elements, but in different order (that is one is anagramm of another), how we can efficiently check it? We can sort both of them and compare, or we can use Counter again to check if these two lists have the same elements! Yes, we use here Counter of Counter and to be honest I see it first time, but it is not that diffucult.\\n2. Operation 2 allows us to rename our letters, but we need to use the same letters: it means, that set of letters in first and second strings should be the same.\\n\\n**Complexity**: time complexity is `O(n)`: we create counters, and then again create counters. Space complexity is `O(m)`, where `m` is size of alphabet to keep our counters.\\n\\n```\\nclass Solution:\\n    def closeStrings(self, w1, w2):\\n        return set(w1) == set(w2) and Counter(Counter(w1).values()) == Counter(Counter(w2).values())\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, w1, w2):\\n        return set(w1) == set(w2) and Counter(Counter(w1).values()) == Counter(Counter(w2).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868278,
                "title": "c-easy-detailed-explaination-o-n",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Intuition:** We just have to check for size and frequency\\n\\n**Approach:**\\n* *condition1* : we need the size of both strings to be same\\n* *condition2* : we need freq of char in strings to be same, irrespective of the order\\n\\n If above 2 conditions are satisfied then just swapping will get us the word2 from word1\\n \\n ```\\n class Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        // condition1 : we need the size of both strings to be same\\n        // condition2 : we need freq of char in strings to be same, irrespective of the order\\n        // if above 2 conditions are satisfied then just swapping will get us the word2 from word1\\n        \\n        if(word1.size()!=word2.size())\\n            return false;\\n        \\n        set<char> s1, s2;\\n        vector<int> freq1(26,0), freq2(26,0);\\n        \\n        for(int i=0; i<word1.size(); i++)\\n        {\\n            s1.insert(word1[i]);\\n            s2.insert(word2[i]);\\n            \\n            freq1[word1[i] - \\'a\\']++;\\n            freq2[word2[i] - \\'a\\']++;\\n        }\\n        \\n        sort(freq1.begin(), freq1.end());\\n        sort(freq2.begin(), freq2.end());\\n        \\n        if(s1==s2 && freq1==freq2)\\n            return true;\\n        else\\n            return false;       \\n    }\\n};\\n ```\\n \\n**Time Complexity** :  `O(n)`\\n\\n![image](https://assets.leetcode.com/users/images/2cb9c099-85f4-48a7-94f8-a5fc6f3824aa_1669949522.6819484.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        // condition1 : we need the size of both strings to be same\\n        // condition2 : we need freq of char in strings to be same, irrespective of the order\\n        // if above 2 conditions are satisfied then just swapping will get us the word2 from word1\\n        \\n        if(word1.size()!=word2.size())\\n            return false;\\n        \\n        set<char> s1, s2;\\n        vector<int> freq1(26,0), freq2(26,0);\\n        \\n        for(int i=0; i<word1.size(); i++)\\n        {\\n            s1.insert(word1[i]);\\n            s2.insert(word2[i]);\\n            \\n            freq1[word1[i] - \\'a\\']++;\\n            freq2[word2[i] - \\'a\\']++;\\n        }\\n        \\n        sort(freq1.begin(), freq1.end());\\n        sort(freq2.begin(), freq2.end());\\n        \\n        if(s1==s2 && freq1==freq2)\\n            return true;\\n        else\\n            return false;       \\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 935917,
                "title": "java-o-n-solution",
                "content": "```java\\nclass Solution {\\n    private int N = 26;\\n    public boolean closeStrings(String word1, String word2) {\\n\\t\\t// count the English letters\\n        int[] arr1 = new int[N], arr2 = new int[N];\\n        for (char ch : word1.toCharArray())\\n            arr1[ch - \\'a\\']++;\\n        for (char ch : word2.toCharArray())\\n            arr2[ch - \\'a\\']++;\\n\\t\\t\\n\\t\\t// if one has a letter which another one doesn\\'t have, dont exist\\n        for (int i = 0; i < N; i++) {\\n            if (arr1[i] == arr2[i]) {\\n                continue;\\n            }\\n            if (arr1[i] == 0 || arr2[i] == 0) {\\n                return false;\\n            }\\n        }\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n        for (int i = 0; i < N; i++) {\\n            if (arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    private int N = 26;\\n    public boolean closeStrings(String word1, String word2) {\\n\\t\\t// count the English letters\\n        int[] arr1 = new int[N], arr2 = new int[N];\\n        for (char ch : word1.toCharArray())\\n            arr1[ch - \\'a\\']++;\\n        for (char ch : word2.toCharArray())\\n            arr2[ch - \\'a\\']++;\\n\\t\\t\\n\\t\\t// if one has a letter which another one doesn\\'t have, dont exist\\n        for (int i = 0; i < N; i++) {\\n            if (arr1[i] == arr2[i]) {\\n                continue;\\n            }\\n            if (arr1[i] == 0 || arr2[i] == 0) {\\n                return false;\\n            }\\n        }\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n        for (int i = 0; i < N; i++) {\\n            if (arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868036,
                "title": "python-c-o-n-one-liner-proof-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs counting of frequencies and comparison of unique characters in both strings. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n****\\n\\n**Comment.** The idea behind this solution consists in considering its invariants (i.e., properties that do not change after either of 2 operations was applied):\\n1. New (unique) characters can not appear, neither can old ones be completely eliminated.\\n2. Character frequencies can not be altered, they can only be arbitrarily redistributed (permuted) between existing characters.\\n\\nThis leads to a simple solution that consists in\\n1. Checking that unique characters in both strings coincide.\\n2. Checking that collections of character frequencies in both strings coincide.\\n\\n**Proof.** It is always possible to redistribute frequencies between two equal sets of characters due to a known theorem stating that *any permutation can be written as a product of transpositions (swaps)*. Thus, if for any two words the conditions that we check above are satisified then one word can always be attained from the other.\\n\\n**Python #1.** Comparison of sorted frequencies.\\n```\\nclass Solution:\\n    def closeStrings(self, w1: str, w2: str) -> bool:\\n        return sorted(Counter(w1).values()) == sorted(Counter(w2).values()) \\\\\\n               and set(w1) == set(w2)\\n```\\n\\n**Python #2.** Double-counting of frequencies.\\n```\\nclass Solution:\\n    def closeStrings(self, w1: str, w2: str) -> bool:\\n        return Counter(Counter(w1).values()) == Counter(Counter(w2).values()) \\\\\\n               and set(w1) == set(w2)\\n```\\n\\n**C++.** \\n```\\nclass Solution \\n{\\npublic:\\n    bool closeStrings(string w1, string w2) \\n    {\\n        vector<int> f1(26), f2(26);\\n        for (char c : w1) ++f1[c-\\'a\\'];\\n        for (char c : w2) ++f2[c-\\'a\\'];\\n        \\n        return multiset(f1.begin(),f1.end()) == multiset(f2.begin(),f2.end()) &&\\n               unordered_set(w1.begin(),w1.end()) == unordered_set(w2.begin(),w2.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, w1: str, w2: str) -> bool:\\n        return sorted(Counter(w1).values()) == sorted(Counter(w2).values()) \\\\\\n               and set(w1) == set(w2)\\n```\n```\\nclass Solution:\\n    def closeStrings(self, w1: str, w2: str) -> bool:\\n        return Counter(Counter(w1).values()) == Counter(Counter(w2).values()) \\\\\\n               and set(w1) == set(w2)\\n```\n```\\nclass Solution \\n{\\npublic:\\n    bool closeStrings(string w1, string w2) \\n    {\\n        vector<int> f1(26), f2(26);\\n        for (char c : w1) ++f1[c-\\'a\\'];\\n        for (char c : w2) ++f2[c-\\'a\\'];\\n        \\n        return multiset(f1.begin(),f1.end()) == multiset(f2.begin(),f2.end()) &&\\n               unordered_set(w1.begin(),w1.end()) == unordered_set(w2.begin(),w2.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936056,
                "title": "java-python3-1-line-python3-solution-beat-100-check-this-out",
                "content": "To solve this problem, we can find that if 2 strings have same unique characters and the value patterns are same, then we can return true. \\n\\n**Python3 more Efficient 1-line Solution (inspired by Chumicat):**\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        return set(word1) == set(word2) and Counter(Counter(word1).values()) == Counter(Counter(word2).values())\\n```\\n\\n**My Original Python 1-line Solution:**\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        return sorted(Counter(word1).values()) == sorted(Counter(word2).values()) and set(Counter(word1).keys()) == set(Counter(word2).keys())\\n```\\n\\n**Java Straightforward Solution:**\\n\\n```\\npublic boolean closeStrings(String word1, String word2) {\\n\\tif (word1.length() != word2.length()) {\\n\\t\\treturn false;\\n\\t}\\n\\tMap<Character, Integer> word1Map = new HashMap<>();\\n\\tMap<Character, Integer> word2Map = new HashMap<>();\\n\\tfor (char c : word1.toCharArray()) {\\n\\t\\tword1Map.put(c, word1Map.getOrDefault(c, 0) + 1);\\n\\t}\\n\\tfor (char c : word2.toCharArray()) {\\n\\t\\tword2Map.put(c, word2Map.getOrDefault(c, 0) + 1);\\n\\t}\\n\\tif (!word1Map.keySet().equals(word2Map.keySet())) {\\n\\t\\treturn false;\\n\\t}\\n\\tList<Integer> word1FrequencyList = new ArrayList<>(word1Map.values());\\n\\tList<Integer> word2FrequencyList = new ArrayList<>(word2Map.values());\\n\\tCollections.sort(word1FrequencyList);\\n\\tCollections.sort(word2FrequencyList);\\n\\treturn word1FrequencyList.equals(word2FrequencyList);\\n}\\n```\\n**Please do upvote if this is helpful and I will keep posting as best as I can!**",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        return set(word1) == set(word2) and Counter(Counter(word1).values()) == Counter(Counter(word2).values())\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        return sorted(Counter(word1).values()) == sorted(Counter(word2).values()) and set(Counter(word1).keys()) == set(Counter(word2).keys())\\n```\n```\\npublic boolean closeStrings(String word1, String word2) {\\n\\tif (word1.length() != word2.length()) {\\n\\t\\treturn false;\\n\\t}\\n\\tMap<Character, Integer> word1Map = new HashMap<>();\\n\\tMap<Character, Integer> word2Map = new HashMap<>();\\n\\tfor (char c : word1.toCharArray()) {\\n\\t\\tword1Map.put(c, word1Map.getOrDefault(c, 0) + 1);\\n\\t}\\n\\tfor (char c : word2.toCharArray()) {\\n\\t\\tword2Map.put(c, word2Map.getOrDefault(c, 0) + 1);\\n\\t}\\n\\tif (!word1Map.keySet().equals(word2Map.keySet())) {\\n\\t\\treturn false;\\n\\t}\\n\\tList<Integer> word1FrequencyList = new ArrayList<>(word1Map.values());\\n\\tList<Integer> word2FrequencyList = new ArrayList<>(word2Map.values());\\n\\tCollections.sort(word1FrequencyList);\\n\\tCollections.sort(word2FrequencyList);\\n\\treturn word1FrequencyList.equals(word2FrequencyList);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868374,
                "title": "java-easy-approach-detailed-explanation-closestring",
                "content": "*Two conditions required for satisfying a close string:*\\n*1. All UNIQUE characters present in String 1 should be available in String 2 & vice versa.(NOT CONSIDERING THEIR FREQUENCY).\\n2. If condition 1 is satisfied then a Sorted Frequency Arr of One String should be same as the Sorted Frequency Arr of Other. \\nIf both Conditions are true then its a closeString.*\\n\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int freq1[]=new int [26];\\n        int freq2[]=new int [26];\\n        for(int i=0;i<word1.length();i++){\\n            freq1[word1.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            freq2[word2.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if((freq1[i]==0&&freq2[i]!=0)||(freq1[i]!=0&&freq2[i]==0))return false;\\n        }\\n        Arrays.sort(freq1);Arrays.sort(freq2);\\n        for(int i=0;i<26;i++){\\n            if(freq1[i]!=freq2[i])return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int freq1[]=new int [26];\\n        int freq2[]=new int [26];\\n        for(int i=0;i<word1.length();i++){\\n            freq1[word1.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            freq2[word2.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if((freq1[i]==0&&freq2[i]!=0)||(freq1[i]!=0&&freq2[i]==0))return false;\\n        }\\n        Arrays.sort(freq1);Arrays.sort(freq2);\\n        for(int i=0;i<26;i++){\\n            if(freq1[i]!=freq2[i])return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935968,
                "title": "c-compare-frequencies",
                "content": "We can freely re-arrange charracters and their frequencies.\\n\\nSo, we need to check that;\\n1. Both string have the same set of charracters.\\n2. Both string have the same frequency of charracters.\\n\\n> E.g string \"abbccddd\" has [1, 2, 2, 3] char frequency, and so does \"bddccaaa\".\\n\\n```cpp\\nbool closeStrings(string w1, string w2) {\\n    if (w1.size() != w2.size())\\n        return false;\\n    vector<int> cnt1(26), cnt2(26);\\n    for (auto i = 0; i < w1.size(); ++i) {\\n        ++cnt1[w1[i] - \\'a\\'];\\n        ++cnt2[w2[i] - \\'a\\'];\\n    }\\n    if (!equal(begin(cnt1), end(cnt1), begin(cnt2), end(cnt2), [](int a, int b) { return (bool)a == bool(b); }))\\n        return false;\\n    sort(begin(cnt1), end(cnt1));\\n    sort(begin(cnt2), end(cnt2));\\n    return cnt1 == cnt2;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool closeStrings(string w1, string w2) {\\n    if (w1.size() != w2.size())\\n        return false;\\n    vector<int> cnt1(26), cnt2(26);\\n    for (auto i = 0; i < w1.size(); ++i) {\\n        ++cnt1[w1[i] - \\'a\\'];\\n        ++cnt2[w2[i] - \\'a\\'];\\n    }\\n    if (!equal(begin(cnt1), end(cnt1), begin(cnt2), end(cnt2), [](int a, int b) { return (bool)a == bool(b); }))\\n        return false;\\n    sort(begin(cnt1), end(cnt1));\\n    sort(begin(cnt2), end(cnt2));\\n    return cnt1 == cnt2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935916,
                "title": "c-o-nlogn-sort-hash-table-easy-to-understand",
                "content": "Algorithm:\\n    1.Find the frequency of every number\\n    2.Sort them and compare their freq, if the same return true\\n    3.Take care of the species of string (using unordered_set to check out), because we are only allow swap not create a new letter.\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size()!=word2.size())\\n            return false;\\n        int n = word1.size();\\n        vector<int>freq1(26,0);\\n        vector<int>freq2(26,0);\\n        for(int i= 0 ; i < n ; ++i){\\n            freq1[word1[i]-\\'a\\']++;\\n            freq2[word2[i]-\\'a\\']++;\\n        }\\n        sort(freq1.rbegin(),freq1.rend());\\n        sort(freq2.rbegin(),freq2.rend());\\n        if(set(word1.begin(),word1.end())!=set(word2.begin(),word2.end()))\\n            return false;\\n        for(int i= 0;i<26;++i){\\n            if(freq1[i]!=freq2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size()!=word2.size())\\n            return false;\\n        int n = word1.size();\\n        vector<int>freq1(26,0);\\n        vector<int>freq2(26,0);\\n        for(int i= 0 ; i < n ; ++i){\\n            freq1[word1[i]-\\'a\\']++;\\n            freq2[word2[i]-\\'a\\']++;\\n        }\\n        sort(freq1.rbegin(),freq1.rend());\\n        sort(freq2.rbegin(),freq2.rend());\\n        if(set(word1.begin(),word1.end())!=set(word2.begin(),word2.end()))\\n            return false;\\n        for(int i= 0;i<26;++i){\\n            if(freq1[i]!=freq2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029201,
                "title": "c-super-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        set<int> w1_letters, w2_letters, w1_freq, w2_freq;\\n        unordered_map<char, int> w1_m, w2_m;\\n        \\n        for (auto a : word1) {\\n            w1_letters.insert(a);\\n            w1_m[a]++;\\n        }\\n        \\n        for (auto a : word2) {\\n            w2_letters.insert(a);\\n            w2_m[a]++;\\n        }\\n        \\n        for (auto [k, v] : w1_m) w1_freq.insert(v);\\n        \\n        for (auto [k, v] : w2_m) w2_freq.insert(v);\\n\\n        return w1_letters == w2_letters && w1_freq == w2_freq;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        set<int> w1_letters, w2_letters, w1_freq, w2_freq;\\n        unordered_map<char, int> w1_m, w2_m;\\n        \\n        for (auto a : word1) {\\n            w1_letters.insert(a);\\n            w1_m[a]++;\\n        }\\n        \\n        for (auto a : word2) {\\n            w2_letters.insert(a);\\n            w2_m[a]++;\\n        }\\n        \\n        for (auto [k, v] : w1_m) w1_freq.insert(v);\\n        \\n        for (auto [k, v] : w2_m) w2_freq.insert(v);\\n\\n        return w1_letters == w2_letters && w1_freq == w2_freq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029212,
                "title": "determine-if-two-strings-are-close-python-counter",
                "content": "We come to two conclusions after analisys (hints are very helpful in this case):\\n1. We cannot introduce new characters\\n2. List of counts of characters will stay consistent\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        # Saves some time\\n        if len(word1) != len(word2):\\n            return False\\n        \\n        from collections import Counter\\n        counts1 = Counter(word1)\\n        counts2 = Counter(word2)\\n        \\n        # No new chars can appear with operations\\n        if counts1.keys() != counts2.keys():\\n            return False\\n        \\n        # Counts can be swapped, but they will stay consistent\\n        if sorted(counts1.values()) != sorted(counts2.values()):\\n            return False\\n        \\n        return True\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        # Saves some time\\n        if len(word1) != len(word2):\\n            return False\\n        \\n        from collections import Counter\\n        counts1 = Counter(word1)\\n        counts2 = Counter(word2)\\n        \\n        # No new chars can appear with operations\\n        if counts1.keys() != counts2.keys():\\n            return False\\n        \\n        # Counts can be swapped, but they will stay consistent\\n        if sorted(counts1.values()) != sorted(counts2.values()):\\n            return False\\n        \\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868028,
                "title": "c-sort-frequency-count-w-some-variants-fast-27ms-100",
                "content": "# Approach 1: frequency count letters and sort frequencies (32ms)\\n\\nSee inline comments below.\\n\\n```cpp\\n    static bool closeStrings(const string& word1, const string& word2) {\\n        // Short circuit different word lengths.\\n        if (size(word1) != size(word2)) return false;\\n\\n        return signature(word1) == signature(word2);\\n    }\\n    \\n    // Two observations:\\n    //   1. With operation 1 we can sort the word.\\n    //   2. With operation 2 we can assign freely assign the the\\n    //      letter frequencies of all the letters in the word.\\n    // With that we frequency count the letters and then assign\\n    // the frequencies in descending order amount to the present\\n    // letters.\\n    static array<int, 26> signature(const string& word) {\\n        array<int, 26> freq = {};\\n        for (char ch : word) ++freq[ch - \\'a\\'];\\n        array<int, 26> ans = freq;\\n        sort(begin(freq), end(freq), greater<>());\\n        for (int i = 0, j = 0; i < size(ans); ++i)\\n            if (ans[i]) ans[i] = freq[j++];\\n        return ans;\\n    }\\n```\\n\\n## Variant 1: \"seen\" bitset\\n\\nA variant of the signature function could be to use a bit set for the letters we see and just stick this into the signature after sorting the frequencies.\\n\\n```cpp\\n    static array<int, 27> signature(const string& word) {\\n        array<int, 27> ans = {};\\n        int seen = 0;\\n        for (char ch : word) {\\n            ch -= \\'a\\';\\n            ++ans[ch];\\n            seen |= 1 << ch;\\n        }\\n        sort(begin(ans), end(ans));\\n        ans[26] = seen;\\n        return ans;\\n    }\\n```\\n\\n## Variant 2: rearrage signature for earlier mismatch (27ms)\\n\\nHere we move the bit mask with which letters are present to the beginning and sort the frequencies descending so we have an ealier mismatch if the signatures are not the same instead of comparing a sequence of zeros at first.\\n\\n```cpp\\n    static array<int, 27> signature(const string& word) {\\n        array<int, 27> ans = {};\\n        int seen = 0;\\n        for (char ch : word) {\\n            ch -= \\'a\\' - 1;\\n            ++ans[ch];\\n            ans[0] |= 1 << ch;\\n        }\\n\\t\\t// sort ans[1] to ans[26], i.e. keep ans[0] in place.\\n        sort(next(begin(ans)), end(ans), greater<>());\\n        return ans;\\n    }\\n```\\n\\n## Variant 3: do less work when scanning the word (27ms)\\n\\nThis is inspired by a solution from @martin0327\\n\\n```cpp\\n    static array<int, 27> signature(const string& word) {\\n        array<int, 27> ans = {};\\n        for (char ch : word) ++ans[ch - \\'a\\' + 1];\\n        for (int i = 1; i < size(ans); ++i)\\n            if (ans[i]) ans[0] |= 1 << i;\\n\\t\\t// sort ans[1] to ans[26], i.e. keep ans[0] in place.\\n        sort(next(begin(ans)), end(ans), greater<>());\\n        return ans;\\n    }\\n```\\n\\n## Variant 4: exit early if the set of letters is not the same\\n\\nWith a bit more duplicate code, of which some could be factored out, we can exit early before sorting the letter frequencies.\\n\\n```cpp\\n    static bool closeStrings(const string& word1, const string& word2) {\\n        // Short circuit different word lengths.\\n        if (size(word1) != size(word2)) return false;\\n        \\n        array<int, 26> sig1 = {};\\n        int seen1 = 0;\\n        for (char ch : word1) {\\n            ch -= \\'a\\';\\n            ++sig1[ch];\\n            seen1 |= 1 << ch;\\n        }\\n\\n        array<int, 26> sig2 = {};\\n        int seen2 = 0;\\n        for (char ch : word2) {\\n            ch -= \\'a\\';\\n            ++sig2[ch];\\n            seen2 |= 1 << ch;\\n        }\\n        \\n        // Exit early if we are not seeing the same set of letters.\\n        if (seen1 != seen2) return false;\\n        \\n        sort(begin(sig1), end(sig1), greater<>());\\n        sort(begin(sig2), end(sig2), greater<>());\\n\\n        return sig1 == sig2;\\n    }\\n```\\n\\nLooking through some other posts, there are many more ways to solve this. Kinda nice, if there are many different ways to solve a problem.\\n\\n**Complexity Analysis**\\nLet $$n$$ the length of the words then\\n  * Time complexity is $$O(n)$$, because we need to scan over both words. Note that we are only sorting a fixed length arrays regardless of the length of the words, and hence this remains constant time. The\\n  * Space complexity is $$O(1)$$.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static bool closeStrings(const string& word1, const string& word2) {\\n        // Short circuit different word lengths.\\n        if (size(word1) != size(word2)) return false;\\n\\n        return signature(word1) == signature(word2);\\n    }\\n    \\n    // Two observations:\\n    //   1. With operation 1 we can sort the word.\\n    //   2. With operation 2 we can assign freely assign the the\\n    //      letter frequencies of all the letters in the word.\\n    // With that we frequency count the letters and then assign\\n    // the frequencies in descending order amount to the present\\n    // letters.\\n    static array<int, 26> signature(const string& word) {\\n        array<int, 26> freq = {};\\n        for (char ch : word) ++freq[ch - \\'a\\'];\\n        array<int, 26> ans = freq;\\n        sort(begin(freq), end(freq), greater<>());\\n        for (int i = 0, j = 0; i < size(ans); ++i)\\n            if (ans[i]) ans[i] = freq[j++];\\n        return ans;\\n    }\\n```\n```cpp\\n    static array<int, 27> signature(const string& word) {\\n        array<int, 27> ans = {};\\n        int seen = 0;\\n        for (char ch : word) {\\n            ch -= \\'a\\';\\n            ++ans[ch];\\n            seen |= 1 << ch;\\n        }\\n        sort(begin(ans), end(ans));\\n        ans[26] = seen;\\n        return ans;\\n    }\\n```\n```cpp\\n    static array<int, 27> signature(const string& word) {\\n        array<int, 27> ans = {};\\n        int seen = 0;\\n        for (char ch : word) {\\n            ch -= \\'a\\' - 1;\\n            ++ans[ch];\\n            ans[0] |= 1 << ch;\\n        }\\n\\t\\t// sort ans[1] to ans[26], i.e. keep ans[0] in place.\\n        sort(next(begin(ans)), end(ans), greater<>());\\n        return ans;\\n    }\\n```\n```cpp\\n    static array<int, 27> signature(const string& word) {\\n        array<int, 27> ans = {};\\n        for (char ch : word) ++ans[ch - \\'a\\' + 1];\\n        for (int i = 1; i < size(ans); ++i)\\n            if (ans[i]) ans[0] |= 1 << i;\\n\\t\\t// sort ans[1] to ans[26], i.e. keep ans[0] in place.\\n        sort(next(begin(ans)), end(ans), greater<>());\\n        return ans;\\n    }\\n```\n```cpp\\n    static bool closeStrings(const string& word1, const string& word2) {\\n        // Short circuit different word lengths.\\n        if (size(word1) != size(word2)) return false;\\n        \\n        array<int, 26> sig1 = {};\\n        int seen1 = 0;\\n        for (char ch : word1) {\\n            ch -= \\'a\\';\\n            ++sig1[ch];\\n            seen1 |= 1 << ch;\\n        }\\n\\n        array<int, 26> sig2 = {};\\n        int seen2 = 0;\\n        for (char ch : word2) {\\n            ch -= \\'a\\';\\n            ++sig2[ch];\\n            seen2 |= 1 << ch;\\n        }\\n        \\n        // Exit early if we are not seeing the same set of letters.\\n        if (seen1 != seen2) return false;\\n        \\n        sort(begin(sig1), end(sig1), greater<>());\\n        sort(begin(sig2), end(sig2), greater<>());\\n\\n        return sig1 == sig2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590058,
                "title": "simple-java-solution-o-n",
                "content": "class Solution {\\n   \\n\\t   \\n\\t   /*\\n\\t   Strings are close only if \\n\\t   1) both words have same set of characters \\n\\t   2) the frequency of any character in first word must be the frequency of any other character in the second word\\n\\t   */\\n\\t   public boolean closeStrings(String word1, String word2) {\\n\\t\\t\\tif(word1.length() != word2.length()) \\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\n\\t\\t\\t//create frequency map for corresponding words\\n\\t\\t\\tint[] freqMap1 = new int[26]; \\n\\t\\t\\tint[] freqMap2 = new int[26];\\n\\t\\t\\t\\n\\t\\t\\t//fill the maps with values\\n\\t\\t\\tword1.chars().forEach(i->freqMap1[i - 97]++);\\n\\t\\t\\tword2.chars().forEach(i->freqMap2[i - 97]++);\\n\\t\\t\\t\\n\\t\\t\\t//check if there exists a character that exisit in one word and does not exist in the other word\\n\\t\\t\\tfor(int i = 0 ; i < 26 ; i++)\\n\\t\\t\\t\\tif(freqMap1[i] != 0 || freqMap2[i] != 0)\\n\\t\\t\\t\\t\\tif(freqMap1[i] == 0 || freqMap2[i] == 0)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\n\\t\\t\\t//sort both maps to compare values\\n\\t\\t\\tArrays.sort(freqMap1);\\n\\t\\t\\tArrays.sort(freqMap2);\\n\\t\\t\\n\\t\\t\\t//check if any value is different\\n\\t\\t\\tfor(int i = 0 ; i < 26 ; i++)\\n\\t\\t\\t\\tif(freqMap1[i] != freqMap2[i]) \\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n   \\n\\t   \\n\\t   /*\\n\\t   Strings are close only if \\n\\t   1) both words have same set of characters \\n\\t   2) the frequency of any character in first word must be the frequency of any other character in the second word\\n\\t   */\\n\\t   public boolean closeStrings(String word1, String word2) {\\n\\t\\t\\tif(word1.length() != word2.length()) \\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\n\\t\\t\\t//create frequency map for corresponding words\\n\\t\\t\\tint[] freqMap1 = new int[26]; \\n\\t\\t\\tint[] freqMap2 = new int[26];\\n\\t\\t\\t\\n\\t\\t\\t//fill the maps with values\\n\\t\\t\\tword1.chars().forEach(i->freqMap1[i - 97]++);\\n\\t\\t\\tword2.chars().forEach(i->freqMap2[i - 97]++);\\n\\t\\t\\t\\n\\t\\t\\t//check if there exists a character that exisit in one word and does not exist in the other word\\n\\t\\t\\tfor(int i = 0 ; i < 26 ; i++)\\n\\t\\t\\t\\tif(freqMap1[i] != 0 || freqMap2[i] != 0)\\n\\t\\t\\t\\t\\tif(freqMap1[i] == 0 || freqMap2[i] == 0)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\n\\t\\t\\t//sort both maps to compare values\\n\\t\\t\\tArrays.sort(freqMap1);\\n\\t\\t\\tArrays.sort(freqMap2);\\n\\t\\t\\n\\t\\t\\t//check if any value is different\\n\\t\\t\\tfor(int i = 0 ; i < 26 ; i++)\\n\\t\\t\\t\\tif(freqMap1[i] != freqMap2[i]) \\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\treturn true;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2869382,
                "title": "javascript-simple-intuitive-solution",
                "content": "# Intuition\\nGiven the rules, the two words will be \"close\" if they:\\n- Have the same set of letters.\\n- Have the same multiset (or bag) of letter counts.\\n\\n# Complexity\\n- Time complexity: O(nLogn)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n\\nfunction getSortedItems(word) {\\n\\n    const group = {};\\n\\n    for (let c of word) {\\n        group[c] = (group[c] || 0) + 1;\\n    }\\n\\n    return {\\n        keys: Object.keys(group).sort(),\\n        counts: Object.values(group).sort((a, b) => a - b),\\n    };\\n\\n}\\n\\nvar closeStrings = function(word1, word2) {\\n\\n    if (word1.length !== word2.length) {\\n        return false;\\n    }\\n    \\n    const group1 = getSortedItems(word1);\\n    const group2 = getSortedItems(word2);\\n\\n    for (let i = 0; i < group1.keys.length; i++) {\\n        if (group1.keys[i] !== group2.keys[i] || group1.counts[i] !== group2.counts[i]) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nfunction getSortedItems(word) {\\n\\n    const group = {};\\n\\n    for (let c of word) {\\n        group[c] = (group[c] || 0) + 1;\\n    }\\n\\n    return {\\n        keys: Object.keys(group).sort(),\\n        counts: Object.values(group).sort((a, b) => a - b),\\n    };\\n\\n}\\n\\nvar closeStrings = function(word1, word2) {\\n\\n    if (word1.length !== word2.length) {\\n        return false;\\n    }\\n    \\n    const group1 = getSortedItems(word1);\\n    const group2 = getSortedItems(word2);\\n\\n    for (let i = 0; i < group1.keys.length; i++) {\\n        if (group1.keys[i] !== group2.keys[i] || group1.counts[i] !== group2.counts[i]) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868526,
                "title": "c-compare-frequency-approach-linear-time-complexity",
                "content": "**Basic Idea :** \\n\\nIf the two strings are close, then \\n* They must have the same set of characters.\\n* The frequency of each character in each string must be the same.\\n\\n\\n**C++ Solution**\\n```\\n\\tbool closeStrings(string word1, string word2) {\\n\\t\\tif(word1.size() != word2.size()) return false; // check if the two words are of equal length\\n\\t\\tvector<int> v1(26,0), v2(26,0); // initialise two vectors of size 26 with all entries as 0\\n\\t\\tfor(char ch: word1) v1[ch-\\'a\\']++; // count the number of each character in word1 and increment the corresponding index in v1\\n\\t\\tfor(char ch: word2) v2[ch-\\'a\\']++; // count the number of each character in word2 and increment the corresponding index in v2\\n\\t\\tfor(int i=0; i<26; i++){ // check if there is a character in word1 and not in word2 or vice versa\\n\\t\\t\\tif((v1[i] == 0 && v2[i] != 0) || (v1[i] != 0 && v2[i] == 0)) return false;\\n\\t\\t}\\n\\t\\tsort(v1.begin(), v1.end()); // sort the two vectors\\n\\t\\tsort(v2.begin(), v2.end());\\n\\t\\treturn v1 == v2; // check if the two vectors are equal\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tbool closeStrings(string word1, string word2) {\\n\\t\\tif(word1.size() != word2.size()) return false; // check if the two words are of equal length\\n\\t\\tvector<int> v1(26,0), v2(26,0); // initialise two vectors of size 26 with all entries as 0\\n\\t\\tfor(char ch: word1) v1[ch-\\'a\\']++; // count the number of each character in word1 and increment the corresponding index in v1\\n\\t\\tfor(char ch: word2) v2[ch-\\'a\\']++; // count the number of each character in word2 and increment the corresponding index in v2\\n\\t\\tfor(int i=0; i<26; i++){ // check if there is a character in word1 and not in word2 or vice versa\\n\\t\\t\\tif((v1[i] == 0 && v2[i] != 0) || (v1[i] != 0 && v2[i] == 0)) return false;\\n\\t\\t}\\n\\t\\tsort(v1.begin(), v1.end()); // sort the two vectors\\n\\t\\tsort(v2.begin(), v2.end());\\n\\t\\treturn v1 == v2; // check if the two vectors are equal\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1029303,
                "title": "easy-solution-in-c",
                "content": "Solution is based on counting like;\\n1-) If both the strings have same character same number of times and the another string is jumbled then definitely they will be same we dont even think about jumbling and all and try to make one string into another string.\\n\\n2) word1: count frequencies a=1,b=3,c=5,d=8; // sort: 1 3 5 8\\nword2: count freq a=5,b=1,c=8,d=3; // sort: 1 3 5 8\\n\\njust match each no is present or not by sorting.(alongwith check some extra conditions)\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        \\n        unordered_map<char,int> m;\\n        unordered_map<char,int> v;\\n        int i,j;\\n        int n=word1.length();\\n        int c=word2.length();\\n        \\n        if(n!=c)\\n            return false;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            m[word1[i]]++;\\n            v[word2[i]]++;\\n        }   \\n        if(m.size()!=v.size())\\n            return false;\\n        \\n        vector<int> w1;\\n        vector<int> w2;\\n        for(auto it: m)\\n        {\\n            if(v[it.first]==0)\\n                return false;\\n            \\n            w1.push_back(it.second);\\n            w2.push_back(v[it.first]);\\n        }\\n        sort(w1.begin(),w1.end());\\n        sort(w2.begin(),w2.end());\\n        \\n        for(i=0;i<w1.size();i++)\\n        {\\n            if(w1[i]!=w2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        \\n        unordered_map<char,int> m;\\n        unordered_map<char,int> v;\\n        int i,j;\\n        int n=word1.length();\\n        int c=word2.length();\\n        \\n        if(n!=c)\\n            return false;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            m[word1[i]]++;\\n            v[word2[i]]++;\\n        }   \\n        if(m.size()!=v.size())\\n            return false;\\n        \\n        vector<int> w1;\\n        vector<int> w2;\\n        for(auto it: m)\\n        {\\n            if(v[it.first]==0)\\n                return false;\\n            \\n            w1.push_back(it.second);\\n            w2.push_back(v[it.first]);\\n        }\\n        sort(w1.begin(),w1.end());\\n        sort(w2.begin(),w2.end());\\n        \\n        for(i=0;i<w1.size();i++)\\n        {\\n            if(w1[i]!=w2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936101,
                "title": "python-time-o-n-100-space-o-n-100-clean-oneline",
                "content": "\\n\\n## One line solution\\n```python\\n# Platform: leetcode.com\\n# No. 1657. Determine if Two Strings Are Close\\n# Link: https://leetcode.com/problems/determine-if-two-strings-are-close/\\n# Difficulty: Medium\\n# Dev: Chumicat\\n# Date: 2020/11/15\\n# Submission: https://leetcode.com/submissions/detail/420404393/\\n# (Time, Space) Complexity : O(n), O(n)\\n# 1. Check length for shortcut\\n# 2. Check set for consist of character\\n# 3. Check count count for consist of count\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        return len(word1) == len(word2) \\\\\\n            and set(word1) == set(word2) \\\\\\n            and Counter(Counter(word1).values()) == Counter(Counter(word2).values())\\n```\\n## You can reuse counter to accelerate\\n```python\\n# Platform: leetcode.com\\n# No. 1657. Determine if Two Strings Are Close\\n# Link: https://leetcode.com/problems/determine-if-two-strings-are-close/\\n# Difficulty: Medium\\n# Dev: Chumicat\\n# Date: 2020/11/15\\n# Submission: https://leetcode.com/submissions/detail/420421060/\\n# (Time, Space) Complexity : O(n), O(n)\\n# 1. Check length for shortcut\\n# 2. Check set for consist of character\\n# 3. Check count count for consist of count\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if len(word1) != len(word2): return False \\n        \\n        c1, c2 = Counter(word1), Counter(word2)   # Reuse of keys\\n        return c1.keys() == c2.keys() \\\\\\n            and Counter(c1.values()) == Counter(c2.values())\\n```\\n\\n## Even further\\nAnother things that I concerned is that str.count is muck more faster than Counter. I didn\\'t confirm which will be faster:\\n1. str.count check 26 times (or check set of string since we use it before)\\n2. Counter check 1 time",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n# Platform: leetcode.com\\n# No. 1657. Determine if Two Strings Are Close\\n# Link: https://leetcode.com/problems/determine-if-two-strings-are-close/\\n# Difficulty: Medium\\n# Dev: Chumicat\\n# Date: 2020/11/15\\n# Submission: https://leetcode.com/submissions/detail/420404393/\\n# (Time, Space) Complexity : O(n), O(n)\\n# 1. Check length for shortcut\\n# 2. Check set for consist of character\\n# 3. Check count count for consist of count\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        return len(word1) == len(word2) \\\\\\n            and set(word1) == set(word2) \\\\\\n            and Counter(Counter(word1).values()) == Counter(Counter(word2).values())\\n```\n```python\\n# Platform: leetcode.com\\n# No. 1657. Determine if Two Strings Are Close\\n# Link: https://leetcode.com/problems/determine-if-two-strings-are-close/\\n# Difficulty: Medium\\n# Dev: Chumicat\\n# Date: 2020/11/15\\n# Submission: https://leetcode.com/submissions/detail/420421060/\\n# (Time, Space) Complexity : O(n), O(n)\\n# 1. Check length for shortcut\\n# 2. Check set for consist of character\\n# 3. Check count count for consist of count\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if len(word1) != len(word2): return False \\n        \\n        c1, c2 = Counter(word1), Counter(word2)   # Reuse of keys\\n        return c1.keys() == c2.keys() \\\\\\n            and Counter(c1.values()) == Counter(c2.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935942,
                "title": "python-nlogn-solution",
                "content": "Time complexity: `O(nlogn)`:\\n\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        c1 = collections.Counter(word1)\\n        c2 = collections.Counter(word2)\\n        set1 = set(word1)\\n        set2 = set(word2)\\n        \\n        s1 = sorted(c1.values())\\n        s2 = sorted(c2.values())\\n        return s1 == s2 and set1 == set2:\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        c1 = collections.Counter(word1)\\n        c2 = collections.Counter(word2)\\n        set1 = set(word1)\\n        set2 = set(word2)\\n        \\n        s1 = sorted(c1.values())\\n        s2 = sorted(c2.values())\\n        return s1 == s2 and set1 == set2:\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871398,
                "title": "python3-step-by-step-hints-to-the-answer",
                "content": "Understanding each **Operation** in the problem is the key to solving this problem, then thinking about if there are any **corner cases**. \\nI made this post to hide everything first and let you open each hint and think through the problem to solve it yourself. (Code at the end)\\n\\n<details>\\n<summary><strong>Hint1: Operation 1</strong></summary>\\n<br/>\\n\"Operation 1: Swap any two existing characters as many times as necessary.\"\\n\\nThis means we can rearrange the word in any order.\\n\\nTry to rearrange \\'abcb\\' to \\'acdb\\' by swapping any two characters as many times as necessary.\\n\\n</details>\\n\\n<details>\\n<summary><strong>Hint2: Operation 2</strong></summary>\\n<br/>\\n\"Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\"\\n\\n<strong>This means the frequency of characters in each word needs to be the same.</strong>\\n\\n```w1 = \\'aaabb\\'``` is <strong>Close</strong> to ```w1 = \\'bbbaa\\'``` because we just need to change all ```\\'a\\'``` to ```\\'b\\'```, and all ```\\'b\\'``` to ```\\'a\\'```.\\n\\n</details>\\n\\n<details>\\n<summary><strong>Hint3: Corner case</strong></summary>\\n<br/>\\n\\nWhat if a character in ```w1``` is not in ```w2```?\\n\\n</details>\\n\\n<details>\\n<summary><strong>Algorithm</strong></summary>\\n<br/>\\nWe will check the following 4 conditions:\\n\\n(1) frequency of characters in each word is the same.\\n\\n(2) unique characters in ```w1``` and ```w2``` are the same.\\n\\n</details>\\n\\n<details>\\n<summary><strong>Code:</strong></summary>\\n<br/>\\n\\n```\\nclass Solution:\\n    def closeStrings(self, w1: str, w2: str) -> bool:\\n        f1 = Counter(w1)\\n        f2 = Counter(w2)\\n        return f1.keys()==f2.keys() and sorted(f1.values()) == sorted(f2.values())\\n```\\n\\n<strong>one-liner</strong>\\n```\\nclass Solution:\\n    def closeStrings(self, w1: str, w2: str) -> bool:\\n        return (f1:=Counter(w1)) and (f2:=Counter(w2)) and len(w1) == len(w2) and f1.keys() == f2.keys() and sorted(f1.values()) == sorted(f2.values())\\n```\\n\\n<strong>Another one-liner</strong>, easy to understand but went through w1, w2 twice.\\n```\\nclass Solution:\\n    def closeStrings(self, w1: str, w2: str) -> bool:\\n        return set(w1) == set(w2) and Counter(Counter(w1).values()) == Counter(Counter(w2).values())\\n```\\n</details>\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```w1 = \\'aaabb\\'```\n```w1 = \\'bbbaa\\'```\n```\\'a\\'```\n```\\'b\\'```\n```\\'b\\'```\n```\\'a\\'```\n```w1```\n```w2```\n```w1```\n```w2```\n```\\nclass Solution:\\n    def closeStrings(self, w1: str, w2: str) -> bool:\\n        f1 = Counter(w1)\\n        f2 = Counter(w2)\\n        return f1.keys()==f2.keys() and sorted(f1.values()) == sorted(f2.values())\\n```\n```\\nclass Solution:\\n    def closeStrings(self, w1: str, w2: str) -> bool:\\n        return (f1:=Counter(w1)) and (f2:=Counter(w2)) and len(w1) == len(w2) and f1.keys() == f2.keys() and sorted(f1.values()) == sorted(f2.values())\\n```\n```\\nclass Solution:\\n    def closeStrings(self, w1: str, w2: str) -> bool:\\n        return set(w1) == set(w2) and Counter(Counter(w1).values()) == Counter(Counter(w2).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868030,
                "title": "python3-using-counter",
                "content": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        \\n        # if they don\\'t have the same length then\\n        # we can immediately return False\\n        if len(word1) != len(word2):\\n            return False\\n        \\n        else:\\n            c1 = Counter(word1)\\n            c2 = Counter(word2)\\n            \\n            # for 2 strings to be close they have to:\\n            \\n            # 1. \\n            # have the same number of repetitions (values),\\n            # they don\\'t have to be the same character (key) necessarily\\n            \\n            # 2. \\n            # keys need to match because - task says: we can only \\n            # transform every occurrence of one existing character\\n           \\n            if (c1.keys() == (c2.keys())\\n            and sorted(c1.values()) == sorted(c2.values())):\\n                return True\\n\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        \\n        # if they don\\'t have the same length then\\n        # we can immediately return False\\n        if len(word1) != len(word2):\\n            return False\\n        \\n        else:\\n            c1 = Counter(word1)\\n            c2 = Counter(word2)\\n            \\n            # for 2 strings to be close they have to:\\n            \\n            # 1. \\n            # have the same number of repetitions (values),\\n            # they don\\'t have to be the same character (key) necessarily\\n            \\n            # 2. \\n            # keys need to match because - task says: we can only \\n            # transform every occurrence of one existing character\\n           \\n            if (c1.keys() == (c2.keys())\\n            and sorted(c1.values()) == sorted(c2.values())):\\n                return True\\n\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870651,
                "title": "python-3-1-9-lines-counters-and-sets-w-explanation-and-example-t-m-90-69",
                "content": "The problem is equivalent to showing that (a) word1 and word2 have the same set of distinct characters, and (b) the collection of counts for distinct characters for word1 and word2 are identical. (The counts for the same letter do not have to be equal, however.) We use Counters to determine (a) and sets to determine (b).\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:         #     Example: word1 = \"cabbba\" \\n                                                                    #              word2 = \"abbccc\"\\n\\n        c1 = Counter(word1)                                         #          c1 = {\\'a\\':2, \\'b\\':3, \\'c\\':1}\\n        c2 = Counter(word2)                                         #          c1 = {\\'a\\':2, \\'b\\':3, \\'c\\':1}\\n\\n        count1 = sorted(c1.values())                                #      count1 = [1, 2, 3]\\n        count2 = sorted(c2.values())                                #      count2 = [1, 2, 3]\\n\\n        set1 = set(word1)                                           #        set1 = {\\'c\\', \\'b\\', \\'a\\'}\\n        set2 = set(word2)                                           #        set2 = {\\'a\\', \\'c\\', \\'b\\'}\\n\\n        if count1 == count2 and set1 == set2:                       #      return True\\n            return True\\n\\n        return False\\n```\\nhttps://leetcode.com/submissions/detail/756739103/\\n\\nI might be wrong, but I think that time is O(N) and space is O(N) .\\n\\nAnd, if you must, here\\'s a one-liner:\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        \\n        return  sorted(Counter(word1).values()) == sorted(Counter(word2).values()) and set(word1) == set(word2)\\n",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:         #     Example: word1 = \"cabbba\" \\n                                                                    #              word2 = \"abbccc\"\\n\\n        c1 = Counter(word1)                                         #          c1 = {\\'a\\':2, \\'b\\':3, \\'c\\':1}\\n        c2 = Counter(word2)                                         #          c1 = {\\'a\\':2, \\'b\\':3, \\'c\\':1}\\n\\n        count1 = sorted(c1.values())                                #      count1 = [1, 2, 3]\\n        count2 = sorted(c2.values())                                #      count2 = [1, 2, 3]\\n\\n        set1 = set(word1)                                           #        set1 = {\\'c\\', \\'b\\', \\'a\\'}\\n        set2 = set(word2)                                           #        set2 = {\\'a\\', \\'c\\', \\'b\\'}\\n\\n        if count1 == count2 and set1 == set2:                       #      return True\\n            return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869624,
                "title": "fastest-and-easiest-solution-o-n-27-ms",
                "content": "**To determine that strings are close, we can distinguish three rules that `word1` and `word2` must satisfy:**\\n1. The lengths of `word1` and `word2` must be equal.\\n2. Both strings must consist of the same unique characters, because we cannot change a string character to another that is not in the string.\\n3. The frequency of characters in both strings must be the same. For example, if `word1` = `abbc` (character frequency: `a` = 1, `b` = 2, `c` = 1) and `word2` = `aabc` (character frequency: `a` = 2, `b` = 1, `c` = 1), sort the resulting frequencies and we have the same array `[1, 1, 2]`, which means that we can convert the existing characters to make the strings equal (in this example we must convert the character `a` to `b`).\\n\\nHow can we check the above rules?\\n1. **Just check if `word1.size()` and `word2.size()` are equal or not.**\\n2. The very first thing that comes to mind to test this rule is to use a set (hash set) or even better an array, since we have only 26 characters in the alphabet. **However, there is an even cooler idea - use a bitmask of unique characters for each string!** This is the best solution, because bitmasks are much faster and checking their equality is much easier and more efficient.\\n3. The third rule can be checked in different ways, also using hash tables or arrays as hash tables. I prefer arrays in this case because they are very small. **We can have an array as a hash table for each string, count the frequency of occurrence of each character, sort the resulting arrays, and simply compare them**.\\n\\nImplementation of the above solution in C++:\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n\\t    // just an optimization trick, if you want 100% you should use it\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        \\n        if (word1.size() != word2.size()) {\\n            return false;\\n        }\\n        \\n        int a[26] = {0}, b[26] = {0}, mask1 = 0, mask2 = 0;\\n        \\n        for (int i = 0; i < word1.size(); i++) {\\n            a[word1[i] - \\'a\\']++;\\n            b[word2[i] - \\'a\\']++;\\n            mask1 |= 1 << (word1[i] - \\'a\\');\\n            mask2 |= 1 << (word2[i] - \\'a\\');\\n        };\\n        \\n\\t\\t// you can also use here (mask1 ^ mask2) != 0, mask1 - mask2 != 0 and so on\\n        if (mask1 != mask2) {\\n            return false;\\n        }\\n        \\n        sort(begin(a), end(a));\\n        sort(begin(b), end(b));\\n        \\n        for (int i = 0; i < 26; i++) {\\n            if (a[i] != b[i]) return false;\\n        }\\n            \\n        return true;\\n    }\\n};\\n```\\n**Complexity:** O(n). **I got 27 ms the first time I submitted this solution.**",
                "solutionTags": [
                    "C",
                    "Array",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n\\t    // just an optimization trick, if you want 100% you should use it\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        \\n        if (word1.size() != word2.size()) {\\n            return false;\\n        }\\n        \\n        int a[26] = {0}, b[26] = {0}, mask1 = 0, mask2 = 0;\\n        \\n        for (int i = 0; i < word1.size(); i++) {\\n            a[word1[i] - \\'a\\']++;\\n            b[word2[i] - \\'a\\']++;\\n            mask1 |= 1 << (word1[i] - \\'a\\');\\n            mask2 |= 1 << (word2[i] - \\'a\\');\\n        };\\n        \\n\\t\\t// you can also use here (mask1 ^ mask2) != 0, mask1 - mask2 != 0 and so on\\n        if (mask1 != mask2) {\\n            return false;\\n        }\\n        \\n        sort(begin(a), end(a));\\n        sort(begin(b), end(b));\\n        \\n        for (int i = 0; i < 26; i++) {\\n            if (a[i] != b[i]) return false;\\n        }\\n            \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869422,
                "title": "java-5ms-100-xor-and-freq-of-freq-array-no-sort-no-hashmap-explanation",
                "content": "Steps in the code below:\\n\\n1) If both strings of different length, then they can never be converted to the same string.\\n2) If both strings are identical, then return true without any more work.  One test case has strings of length of more than 64_000 characters, with the two strings being identical.\\n3) Get the repeat count of each character (i.e. frequency of each character) in both strings.\\n4) Find the maximum repeat count of any character in both strings.\\n5) If a letter appears in one string, but is not in the other string, then the word strings can never be converted to the same string.  This test is done by testing if the frequency count of a letter is zero in one string, but is non-zero in the other string.  The implementation of this is by using XOR in the expression `(f1 == 0) ^ (f2 == 0)`.  The XOR (^ operator) is true if one of the counts is zero, but the other count is non-zero.\\n6) Make sure that the frequency counts from one string, have the exact same frequency counts as the other string, even though these counts may not be in the same order (i.e. the counts may be for different characters).  For example, if one string has frequency counts (2,5,3,5) for some arbitrary characters, and the other string has the frequency counts (5,5,3,2), then one string can be converted to the other string.  The important thing in this example is that both strings have the same counts, even though the order may be different.  Many people\\'s solutions to this leetcode problem will sort the arrays of these frequency counts to easily compare the counts.  But sorting can be an expensive process in runtime.  The code below avoids sorting by using the array `freqFreq[]`, to match each frequence count value.  In `freqFreq[]`, for a non-zero frequency count `f1` from the string `word1`, increment `freqFreq[f1]`.  For a non-zero frequency count `f2` from the string `word2`, decrement `freqFreq[f2]`.  After processing all letters \\'a\\' to \\'z\\', if one string can be converted into the other string, then all values in `freqFreq[]` should be zero.  Instead of scanning the entire array `freqFreq[]` to check for all zeroes, with a maximum array length of 100_000 values, we use the variable `count` to increment when a `freqFreq[]` values goes from zero to non-zero, and decrement `count` when a `freqFreq[]` value goes from non-zero to zero.  Therefore, when all letters have been scanned, the value in `count` should be zero if all values in `freqFreq[]` are zero, and therefore one string can be converted to the other string.\\n\\nSection 6 above is confusing, so the code for section 6:\\n```\\n        for (int i = \\'a\\'; i <= \\'z\\'; i++) {\\n            int f1 = freq1[i];\\n            int f2 = freq2[i];\\n            if ((f1 == 0) ^ (f2 == 0))  return false;   // If a char in one string, is not in the other string.\\n            if (f1 != 0) {\\n                int f1f = freqFreq[f1]++;\\n                int f2f = freqFreq[f2]--;\\n                if (f1f == 0)  count++;  else  if (f1f == -1)  count--;\\n                if (f2f == 0)  count++;  else  if (f2f ==  1)  count--;\\n            }\\n        }\\n```\\nis illustrated in the graphic below, without the graphic showing the `if...^...` statement covered in section 5 above.  The two words have been converted to frequency tables (green arrows), which are counts of how many times each character appears in each word.  The `for i` loop processes the frequency tables into the `freqFreq[]` array (blue and red arrows), which is used to test for every frequency value from the first word, having a matching frequency value from the second word, which is a requirement for the two words to be close.  Each time a `freqFreq[]` value goes from zero to non-zero, the `count` is incremented.  And each time a `freqFreq[]` value goes from non-zero back to zero, the `count` is decremented.  At the end, if the words are close, then `freqFreq[]` should be all zeroes, which also means that the `count` value will be zero.  If `count` is non-zero, then the words are not close.\\n\\n![image](https://assets.leetcode.com/users/images/b8d14d9b-faf6-4924-b429-e60c3de049d6_1670115448.817835.jpeg)\\n\\nThe following code runs as fast as 5ms, but sometimes as slow as 30ms, in December 2022.\\n\\nIf useful, please upvote.\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int n = word1.length();\\n        if (n != word2.length())  return false;    // Not same length strings.\\n        if (word1.equals(word2))  return true;     // Both strings identical.\\n\\n        // Get the count (frequency) of each character in each string.\\n        int[] freq1 = new int[\\'z\\' + 1];     // Count of each char in word1\\n        int[] freq2 = new int[\\'z\\' + 1];     // Count of each char in word2\\n        byte[] wordB = new byte[n];\\n        word1.getBytes(0, n, wordB, 0);     // Faster than String.toCharArray().\\n        for (byte c : wordB)  freq1[c]++;\\n        word2.getBytes(0, n, wordB, 0);\\n        for (byte c : wordB)  freq2[c]++;\\n        \\n        // Find highest count for any character.\\n        int maxFreq = 0;\\n        for (int i = \\'a\\'; i <= \\'z\\'; i++)\\n            maxFreq = Math.max(maxFreq, Math.max(freq1[i], freq2[i]));\\n\\n        // Make sure that each character in one string exists in the other string, even though \\n        // the counts of the character in each string is different.  For all the counts of \\n        // characters in each string, make sure there is the same count in the other string, \\n        // even though the counts may be for different characters.\\n        byte[] freqFreq = new byte[maxFreq + 1];    // Up/down counters for any frequency \\n        int count = 0;\\n        for (int i = \\'a\\'; i <= \\'z\\'; i++) {\\n            int f1 = freq1[i];\\n            int f2 = freq2[i];\\n            if ((f1 == 0) ^ (f2 == 0))  return false;   // If a char in one string, is not in the other string.\\n            if (f1 != 0) {\\n                int f1f = freqFreq[f1]++;\\n                int f2f = freqFreq[f2]--;\\n                if (f1f == 0)  count++;  else  if (f1f == -1)  count--;\\n                if (f2f == 0)  count++;  else  if (f2f ==  1)  count--;\\n            }\\n        }\\n        return count == 0;  // Return true only if the counts of characters are the same in \\n                            // both strings.\\n    }\\n}\\n```\\n--------------------------------------------\\nAnother version of code that runs equally fast at 5ms, is shown below.  I got the original code from user Vezzz, then modified Vezzz\\'s code to try to make it faster, but I could not reduce the code\\'s fastest runtime.  The code below is my modified version of the code.  It uses insertion sorts on the frequency count arrays, then compares the two arrays for being identical.  The Vezzz\\'s self-coded insertion sorts appear to be faster than the `Arrays.sort()` used my many other people\\'s solutions.  An improvement I also picked up from Vezzz\\'s code is the use of the `getBytes(int, int, array, int)` method, which seems much faster than the `String.toCharArray()` method I had been using, and reduced my original code\\'s runtime by nearly 50%.\\n```\\nclass Solution { // Vezzz\\n    public boolean closeStrings(String word1, String word2) {\\n        int n = word1.length();\\n        if (n != word2.length())  return false;\\n        if (word1.equals(word2))  return true;\\n\\n        // Get the counts of each letter in the two strings\\n        int freq1[] = new int[\\'z\\' + 1];\\n        int freq2[] = new int[\\'z\\' + 1];\\n        byte[] w = new byte[n];\\n        word1.getBytes(0, n, w, 0);\\n        for (byte c : w)  freq1[c]++;\\n        word2.getBytes(0, n, w, 0);\\n        for (byte c : w)  freq2[c]++;\\n\\n        // Make sure the same letters are used in both strings, \\n        // with the count of chars NOT being compared.\\n        for (int i = \\'a\\'; i <= \\'z\\'; i++)\\n            if (freq1[i] == 0 ^ freq2[i] == 0)\\n                return false;\\n\\n        // Insertion-sort the counts of letters from string #1.\\n        freq1[\\'a\\' - 1] = -1;\\n        for (int i, k = \\'a\\'; ++k <= \\'z\\';) {\\n            int f1i = freq1[i = k];\\n            while (f1i < freq1[--i])  freq1[i + 1] = freq1[i];\\n            freq1[i + 1] = f1i;\\n        }\\n\\n        // Insertion-sort the counts of letters from string #2.\\n        freq2[\\'a\\' - 1] = -1;\\n        for (int i, k = \\'a\\'; ++k <= \\'z\\';) {\\n            int f2i = freq2[i = k];\\n            while (f2i < freq2[--i])  freq2[i + 1] = freq2[i];\\n            freq2[i + 1] = f2i;\\n        }\\n\\n        // Make sure sorted counts are the same for both strings.\\n        for (int i = \\'a\\'; i <= \\'z\\'; i++)\\n            if (freq1[i] != freq2[i])\\n                return false;\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        for (int i = \\'a\\'; i <= \\'z\\'; i++) {\\n            int f1 = freq1[i];\\n            int f2 = freq2[i];\\n            if ((f1 == 0) ^ (f2 == 0))  return false;   // If a char in one string, is not in the other string.\\n            if (f1 != 0) {\\n                int f1f = freqFreq[f1]++;\\n                int f2f = freqFreq[f2]--;\\n                if (f1f == 0)  count++;  else  if (f1f == -1)  count--;\\n                if (f2f == 0)  count++;  else  if (f2f ==  1)  count--;\\n            }\\n        }\\n```\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int n = word1.length();\\n        if (n != word2.length())  return false;    // Not same length strings.\\n        if (word1.equals(word2))  return true;     // Both strings identical.\\n\\n        // Get the count (frequency) of each character in each string.\\n        int[] freq1 = new int[\\'z\\' + 1];     // Count of each char in word1\\n        int[] freq2 = new int[\\'z\\' + 1];     // Count of each char in word2\\n        byte[] wordB = new byte[n];\\n        word1.getBytes(0, n, wordB, 0);     // Faster than String.toCharArray().\\n        for (byte c : wordB)  freq1[c]++;\\n        word2.getBytes(0, n, wordB, 0);\\n        for (byte c : wordB)  freq2[c]++;\\n        \\n        // Find highest count for any character.\\n        int maxFreq = 0;\\n        for (int i = \\'a\\'; i <= \\'z\\'; i++)\\n            maxFreq = Math.max(maxFreq, Math.max(freq1[i], freq2[i]));\\n\\n        // Make sure that each character in one string exists in the other string, even though \\n        // the counts of the character in each string is different.  For all the counts of \\n        // characters in each string, make sure there is the same count in the other string, \\n        // even though the counts may be for different characters.\\n        byte[] freqFreq = new byte[maxFreq + 1];    // Up/down counters for any frequency \\n        int count = 0;\\n        for (int i = \\'a\\'; i <= \\'z\\'; i++) {\\n            int f1 = freq1[i];\\n            int f2 = freq2[i];\\n            if ((f1 == 0) ^ (f2 == 0))  return false;   // If a char in one string, is not in the other string.\\n            if (f1 != 0) {\\n                int f1f = freqFreq[f1]++;\\n                int f2f = freqFreq[f2]--;\\n                if (f1f == 0)  count++;  else  if (f1f == -1)  count--;\\n                if (f2f == 0)  count++;  else  if (f2f ==  1)  count--;\\n            }\\n        }\\n        return count == 0;  // Return true only if the counts of characters are the same in \\n                            // both strings.\\n    }\\n}\\n```\n```\\nclass Solution { // Vezzz\\n    public boolean closeStrings(String word1, String word2) {\\n        int n = word1.length();\\n        if (n != word2.length())  return false;\\n        if (word1.equals(word2))  return true;\\n\\n        // Get the counts of each letter in the two strings\\n        int freq1[] = new int[\\'z\\' + 1];\\n        int freq2[] = new int[\\'z\\' + 1];\\n        byte[] w = new byte[n];\\n        word1.getBytes(0, n, w, 0);\\n        for (byte c : w)  freq1[c]++;\\n        word2.getBytes(0, n, w, 0);\\n        for (byte c : w)  freq2[c]++;\\n\\n        // Make sure the same letters are used in both strings, \\n        // with the count of chars NOT being compared.\\n        for (int i = \\'a\\'; i <= \\'z\\'; i++)\\n            if (freq1[i] == 0 ^ freq2[i] == 0)\\n                return false;\\n\\n        // Insertion-sort the counts of letters from string #1.\\n        freq1[\\'a\\' - 1] = -1;\\n        for (int i, k = \\'a\\'; ++k <= \\'z\\';) {\\n            int f1i = freq1[i = k];\\n            while (f1i < freq1[--i])  freq1[i + 1] = freq1[i];\\n            freq1[i + 1] = f1i;\\n        }\\n\\n        // Insertion-sort the counts of letters from string #2.\\n        freq2[\\'a\\' - 1] = -1;\\n        for (int i, k = \\'a\\'; ++k <= \\'z\\';) {\\n            int f2i = freq2[i = k];\\n            while (f2i < freq2[--i])  freq2[i + 1] = freq2[i];\\n            freq2[i + 1] = f2i;\\n        }\\n\\n        // Make sure sorted counts are the same for both strings.\\n        for (int i = \\'a\\'; i <= \\'z\\'; i++)\\n            if (freq1[i] != freq2[i])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869249,
                "title": "c-o-n-easiest-beginner-friendly",
                "content": "**Intuition :**  Store char and count of chars of each char of both the strings into 2 \\n\\t\\t\\t\\t\\t\\tdifferent maps. \\n\\t\\t\\t\\t\\t\\tSince map store value in ascending order.\\n\\t\\t\\t\\t\\t\\tAfter storing values in maps check if map1->first == map2->first\\n\\t\\t\\t\\t\\t\\tthis will help us in checking wether char are equal or not .\\n\\t\\t\\t\\t        After that push the count of the of each char in vector \\n\\t\\t\\t\\t\\t\\tthen sort the vector and check they are equal or not.\\n\\n\\n\\n```\\nclass Solution\\n{\\n    public:\\n        bool closeStrings(string word1, string word2)\\n        {\\n            int n = word1.size();       //to store the size of word1\\n            int m = word2.size();       //to store the size of word2\\n            \\n            vector<int> v1;\\n            vector<int> v2;\\n\\n            map<char, int> mp1, mp2;\\n            \\n            \\n            if (n != m)                 // checking wether 2 strings have same size or not\\n                return false;\\n            \\n            for (int i = 0; i < n; i++)    //storing char and count of each char\\n            {\\n                mp1[word1[i]]++;\\n            }\\n            for (int i = 0; i < m; i++)\\n            {\\n                mp2[word2[i]]++;\\n            }\\n\\n            if (mp1.size() != mp2.size())   \\n                return false;\\n\\n            map<char, int>::iterator it1 = mp1.begin();\\n            map<char, int>::iterator it2 = mp2.begin();\\n\\n            while (it1 != mp1.end())\\n            {\\n                if (it1->first == it2->first)\\n                    it1++, it2++;\\n                else\\n                    return false;\\n            }\\n\\n            for (auto i: mp1)\\n            {\\n                v1.push_back(i.second);\\n            }\\n            for (auto i: mp2)\\n            {\\n                v2.push_back(i.second);\\n            }\\n\\n            sort(v1.begin(), v1.end());\\n            sort(v2.begin(), v2.end());\\n\\n            if (v1 == v2)\\n                return true;\\n            return false;\\n        }\\n};\\n\\n//This approach is beginner friendly so a newbie can also understand.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t:)",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution\\n{\\n    public:\\n        bool closeStrings(string word1, string word2)\\n        {\\n            int n = word1.size();       //to store the size of word1\\n            int m = word2.size();       //to store the size of word2\\n            \\n            vector<int> v1;\\n            vector<int> v2;\\n\\n            map<char, int> mp1, mp2;\\n            \\n            \\n            if (n != m)                 // checking wether 2 strings have same size or not\\n                return false;\\n            \\n            for (int i = 0; i < n; i++)    //storing char and count of each char\\n            {\\n                mp1[word1[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2868862,
                "title": "easy-approach-c-hashing-sorting",
                "content": "# Intuition\\nSince we can swap any character any number of times we could sort. And we can swap the characters in the given string for freq match so we just have to match freq. \\n\\n# Approach\\nSimple Approach :\\n- Base case : if words size doesn\\'t match we directly return false\\n- Base case 2 : If words themselves don\\'t match we can return false\\n- We\\'ll make a freq map or freq count and then well just check wheather the freq are same or not.\\n\\n# Complexity\\n- Time complexity: O(NLogN) since we are sorting\\n\\n- Space complexity: O(N) extra space for frq count\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size() != word2.size()) return false;\\n        vector<int> v(26 , 0) , v1(26 , 0);\\n        for(auto it : word1){\\n            v[it - \\'a\\']++;\\n        }\\n        for(auto it : word2){\\n            v1[it - \\'a\\']++;\\n        }\\n        sort(v.begin() , v.end());\\n        sort(v1.begin() , v1.end());\\n        reverse(v.begin() , v.end());\\n        reverse(v1.begin() , v1.end());\\n        if(set(word1.begin(),word1.end())!=\\n           set(word2.begin(),word2.end()))\\n            return false;\\n        for(int i = 0 ; i< 26 ; i++){\\n            if(v[i] != v1[i])return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size() != word2.size()) return false;\\n        vector<int> v(26 , 0) , v1(26 , 0);\\n        for(auto it : word1){\\n            v[it - \\'a\\']++;\\n        }\\n        for(auto it : word2){\\n            v1[it - \\'a\\']++;\\n        }\\n        sort(v.begin() , v.end());\\n        sort(v1.begin() , v1.end());\\n        reverse(v.begin() , v.end());\\n        reverse(v1.begin() , v1.end());\\n        if(set(word1.begin(),word1.end())!=\\n           set(word2.begin(),word2.end()))\\n            return false;\\n        for(int i = 0 ; i< 26 ; i++){\\n            if(v[i] != v1[i])return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868297,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        lst1=[0]*26\\n        lst2=[0]*26\\n        for i in word1:\\n            lst1[ord(i)-97]+=1\\n        for i in word2:\\n            lst2[ord(i)-97]+=1\\n        for i in range(26):\\n            if (lst1[i]>0 and lst2[i]==0) or (lst1[i]==0 and lst2[i]>0):\\n                return False\\n        lst1.sort()\\n        lst2.sort()\\n        if lst1[:]==lst2[:]:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        lst1=[0]*26\\n        lst2=[0]*26\\n        for i in word1:\\n            lst1[ord(i)-97]+=1\\n        for i in word2:\\n            lst2[ord(i)-97]+=1\\n        for i in range(26):\\n            if (lst1[i]>0 and lst2[i]==0) or (lst1[i]==0 and lst2[i]>0):\\n                return False\\n        lst1.sort()\\n        lst2.sort()\\n        if lst1[:]==lst2[:]:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314139,
                "title": "swift-determine-if-two-strings-are-close-test-cases",
                "content": "```swift\\nclass Solution {\\n    func closeStrings(_ word1: String, _ word2: String) -> Bool {\\n        typealias US = UnicodeScalar\\n        let az = ((US(\"a\").value...US(\"z\").value).map{US($0)})\\n        let array = Array(repeating: 0, count: az.count)\\n        var c1 = array, c2 = array\\n        word1.forEach{c1[Int($0.asciiValue!) - 97] += 1}\\n        word2.forEach{c2[Int($0.asciiValue!) - 97] += 1}\\n        for i in az.indices {\\n            if c1[i] > 0 && c2[i] == 0 { return false }\\n            if c2[i] > 0 && c1[i] == 0 { return false }\\n        }\\n        c1.sort()\\n        c2.sort()\\n        return c1 == c2\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n//      Executed 4 tests, with 0 failures (0 unexpected) in 0.186 (0.188) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let result = s.closeStrings(\"abc\", \"bca\")\\n        XCTAssertEqual(result, true)\\n    }\\n    func test2() {\\n        let result = s.closeStrings(\"a\", \"aa\")\\n        XCTAssertEqual(result, false)\\n    }\\n    func test3() {\\n        let result = s.closeStrings(\"cabbba\", \"abbccc\")\\n        XCTAssertEqual(result, true)\\n    }\\n    func test4() {\\n        let result = s.closeStrings(\"cabbba\", \"aabbss\")\\n        XCTAssertEqual(result, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func closeStrings(_ word1: String, _ word2: String) -> Bool {\\n        typealias US = UnicodeScalar\\n        let az = ((US(\"a\").value...US(\"z\").value).map{US($0)})\\n        let array = Array(repeating: 0, count: az.count)\\n        var c1 = array, c2 = array\\n        word1.forEach{c1[Int($0.asciiValue!) - 97] += 1}\\n        word2.forEach{c2[Int($0.asciiValue!) - 97] += 1}\\n        for i in az.indices {\\n            if c1[i] > 0 && c2[i] == 0 { return false }\\n            if c2[i] > 0 && c1[i] == 0 { return false }\\n        }\\n        c1.sort()\\n        c2.sort()\\n        return c1 == c2\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n//      Executed 4 tests, with 0 failures (0 unexpected) in 0.186 (0.188) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let result = s.closeStrings(\"abc\", \"bca\")\\n        XCTAssertEqual(result, true)\\n    }\\n    func test2() {\\n        let result = s.closeStrings(\"a\", \"aa\")\\n        XCTAssertEqual(result, false)\\n    }\\n    func test3() {\\n        let result = s.closeStrings(\"cabbba\", \"abbccc\")\\n        XCTAssertEqual(result, true)\\n    }\\n    func test4() {\\n        let result = s.closeStrings(\"cabbba\", \"aabbss\")\\n        XCTAssertEqual(result, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034439,
                "title": "c-microsoft-simple-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int len=word1.length();\\n        if(word2.length()!=len)\\n            return false;\\n        \\n        vector<int> count1(26,0);\\n        vector<int> count2(26,0);\\n        for(int i=0;i<len;i++){\\n            count1[word1[i]-\\'a\\']++;\\n            count2[word2[i]-\\'a\\']++;\\n        }\\n        //Checking if same characters exist\\n        for(int i=0;i<26;i++){\\n            if((count1[i]>0 && count2[i]==0) || (count1[i]==0 && count2[i]>0))\\n                return false;\\n        }\\n        sort(begin(count1),end(count1));\\n        sort(begin(count2),end(count2));\\n        for(int i=0;i<26;i++){\\n            if(count1[i]!=count2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int len=word1.length();\\n        if(word2.length()!=len)\\n            return false;\\n        \\n        vector<int> count1(26,0);\\n        vector<int> count2(26,0);\\n        for(int i=0;i<len;i++){\\n            count1[word1[i]-\\'a\\']++;\\n            count2[word2[i]-\\'a\\']++;\\n        }\\n        //Checking if same characters exist\\n        for(int i=0;i<26;i++){\\n            if((count1[i]>0 && count2[i]==0) || (count1[i]==0 && count2[i]>0))\\n                return false;\\n        }\\n        sort(begin(count1),end(count1));\\n        sort(begin(count2),end(count2));\\n        for(int i=0;i<26;i++){\\n            if(count1[i]!=count2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940989,
                "title": "simple-cpp-solution-beats-98",
                "content": "i have created two hash function to count the number of occurance of all char in word1 and word2\\noccording to 1st rule : we can swap any two char at any number of time so if the cnt of all char in string word1 and word2 is same then string will be accepted .(there must not present any new char in word2 that is not present in word1)\\non aplying 2nd rule : we can change the we can convert one char into other . so if any two charcter frequncy is difference then if possible then convert them .\\n\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.length()!=word2.length())\\n            return false;\\n        vector<int> hash1(26,0);\\n        vector<int> hash2(26,0);\\n        for(int i=0;i<word1.length();i++){\\n            hash1[word1[i] - \\'a\\']++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            if(hash1[word2[i]-\\'a\\']==0) //cheking for new char present in word2  (new char means that is not present in word1)\\n                return false;\\n            hash2[word2[i]-\\'a\\']++;\\n        }\\n        sort(hash1.begin(), hash1.end()); // for 2nd rule matching\\n        sort(hash2.begin(), hash2.end());\\n        for(int i=0;i<26;i++){\\n            if(hash1[i]!=hash2[i]) // condition where we can\\'t convert char\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.length()!=word2.length())\\n            return false;\\n        vector<int> hash1(26,0);\\n        vector<int> hash2(26,0);\\n        for(int i=0;i<word1.length();i++){\\n            hash1[word1[i] - \\'a\\']++;\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            if(hash1[word2[i]-\\'a\\']==0) //cheking for new char present in word2  (new char means that is not present in word1)\\n                return false;\\n            hash2[word2[i]-\\'a\\']++;\\n        }\\n        sort(hash1.begin(), hash1.end()); // for 2nd rule matching\\n        sort(hash2.begin(), hash2.end());\\n        for(int i=0;i<26;i++){\\n            if(hash1[i]!=hash2[i]) // condition where we can\\'t convert char\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868606,
                "title": "c-99-faster-counting-commented-soln",
                "content": "![image.png](https://assets.leetcode.com/users/images/37e5adc0-5a63-4b1b-af18-5cccf50e6291_1672731082.601879.png)\\n\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.length() != word2.length()) return false;\\n        int count1[26] = {0};\\n        int count2[26] = {0};\\n        for(int i = 0;i<word1.length();i++) //counting freq of word1 chars\\n        {\\n            count1[word1[i]-\\'a\\']++;\\n        }\\n        \\n        for(int i = 0;i<word2.length();i++) //counting freq of word2 chars\\n        {\\n            count2[word2[i]-\\'a\\']++;\\n        }\\n        \\n        for(int i = 0;i<26;i++) //checking if atleast 1 same chars are present in both string\\n        {\\n            if(count1[i] && count2[i] == 0) return false;\\n        }\\n        \\n        sort(count1,count1+26);\\n        sort(count2,count2+26);\\n        \\n        for(int i = 0;i<26;i++) //checking whether the frequencies present in word1 matches with word2, no matter which char freq it is\\n        {\\n            if(count1[i] != count2[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nPls Upvote\\n\\uD83D\\uDC4D\\uD83D\\uDE43",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.length() != word2.length()) return false;\\n        int count1[26] = {0};\\n        int count2[26] = {0};\\n        for(int i = 0;i<word1.length();i++) //counting freq of word1 chars\\n        {\\n            count1[word1[i]-\\'a\\']++;\\n        }\\n        \\n        for(int i = 0;i<word2.length();i++) //counting freq of word2 chars\\n        {\\n            count2[word2[i]-\\'a\\']++;\\n        }\\n        \\n        for(int i = 0;i<26;i++) //checking if atleast 1 same chars are present in both string\\n        {\\n            if(count1[i] && count2[i] == 0) return false;\\n        }\\n        \\n        sort(count1,count1+26);\\n        sort(count2,count2+26);\\n        \\n        for(int i = 0;i<26;i++) //checking whether the frequencies present in word1 matches with word2, no matter which char freq it is\\n        {\\n            if(count1[i] != count2[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868154,
                "title": "golang-array",
                "content": "```go\\nfunc closeStrings(word1 string, word2 string) bool {\\n\\tcounter := func(word string) (keys, vals [26]int) {\\n\\t\\tfor i := range word {\\n\\t\\t\\tkeys[word[i]-\\'a\\'] = 1\\n\\t\\t\\tvals[word[i]-\\'a\\'] += 1\\n\\t\\t}\\n\\t\\tsort.Ints(vals[:])\\n\\t\\treturn keys, vals\\n\\t}\\n\\tkeys1, vals1 := counter(word1)\\n\\tkeys2, vals2 := counter(word2)\\n\\treturn keys1 == keys2 && vals1 == vals2\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc closeStrings(word1 string, word2 string) bool {\\n\\tcounter := func(word string) (keys, vals [26]int) {\\n\\t\\tfor i := range word {\\n\\t\\t\\tkeys[word[i]-\\'a\\'] = 1\\n\\t\\t\\tvals[word[i]-\\'a\\'] += 1\\n\\t\\t}\\n\\t\\tsort.Ints(vals[:])\\n\\t\\treturn keys, vals\\n\\t}\\n\\tkeys1, vals1 := counter(word1)\\n\\tkeys2, vals2 := counter(word2)\\n\\treturn keys1 == keys2 && vals1 == vals2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868146,
                "title": "easy-explain-optimized-o-n-cpp-array",
                "content": "# Approach\\nIdea : Two thing\\'s Need to check \\n\\nUse normal array to reduce time complexcity into O(Nlog N) to O(N)\\n\\n- Frequency of Char need\\'s to be same there both of string as we can do Transform every occurrence of one existing character into another existing character\\n- All the unique char which there in String1 need\\'s to there as well In string2\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# CPP Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        vector<int>w1(26,0),w2(26,0),w3(26,0),w4(26,0);\\n        for(char c:word1)\\n            w1[c-\\'a\\']++,w3[c-\\'a\\'] = 1;\\n    \\n        for(char c:word2)\\n            w2[c-\\'a\\']++,w4[c-\\'a\\'] = 1;\\n        \\n        sort(begin(w1),end(w1));\\n        sort(begin(w2),end(w2));\\n        return w1==w2&&w3==w4;\\n    }\\n};\\n```\\n#Upvote\\nThank You :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        vector<int>w1(26,0),w2(26,0),w3(26,0),w4(26,0);\\n        for(char c:word1)\\n            w1[c-\\'a\\']++,w3[c-\\'a\\'] = 1;\\n    \\n        for(char c:word2)\\n            w2[c-\\'a\\']++,w4[c-\\'a\\'] = 1;\\n        \\n        sort(begin(w1),end(w1));\\n        sort(begin(w2),end(w2));\\n        return w1==w2&&w3==w4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868003,
                "title": "daily-leetcoding-challenge-december-day-2",
                "content": "This problem is the Daily LeetCoding Challenge for December, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/determine-if-two-strings-are-close/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using HashMap\n\n  \n**Approach 2:** Using Frequency Array Map\n\n  \n**Approach 3:** Using Bitwise Operation and Frequency Array Map\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/determine-if-two-strings-are-close/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 950494,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size() != word2.size()) return false;\\n        vector<int> f1(26, 0), f2(26, 0);\\n        for(auto &c : word1) f1[c - \\'a\\']++;\\n        for(auto &c : word2) f2[c - \\'a\\']++;\\n        for(int i = 0; i < 26; i++) if(f1[i] > 0 != f2[i] > 0) return false;\\n        sort(f1.begin(), f1.end());\\n        sort(f2.begin(), f2.end());       \\n        for(int i = 0; i < 26; i++) if(f1[i] != f2[i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size() != word2.size()) return false;\\n        vector<int> f1(26, 0), f2(26, 0);\\n        for(auto &c : word1) f1[c - \\'a\\']++;\\n        for(auto &c : word2) f2[c - \\'a\\']++;\\n        for(int i = 0; i < 26; i++) if(f1[i] > 0 != f2[i] > 0) return false;\\n        sort(f1.begin(), f1.end());\\n        sort(f2.begin(), f2.end());       \\n        for(int i = 0; i < 26; i++) if(f1[i] != f2[i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869300,
                "title": "python-straight-forward-o-n-solution",
                "content": "# Important testcase\\nMost of you would probably overlook this edge case:\\nword1 = uau & word2 = ssx\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if len(word1) != len(word2):\\n            return False\\n\\n        count1, count2 = {}, {}\\n        for i in range(len(word1)):\\n            count1[word1[i]] = count1.get(word1[i], 0) + 1\\n            count2[word2[i]] = count2.get(word2[i], 0) + 1\\n\\n        return sorted(count1.values()) == sorted(count2.values()) and set(word1) == set(word2)\\n```\\n# Please upvote if you find this helpful.",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if len(word1) != len(word2):\\n            return False\\n\\n        count1, count2 = {}, {}\\n        for i in range(len(word1)):\\n            count1[word1[i]] = count1.get(word1[i], 0) + 1\\n            count2[word2[i]] = count2.get(word2[i], 0) + 1\\n\\n        return sorted(count1.values()) == sorted(count2.values()) and set(word1) == set(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869068,
                "title": "easy-explained-in-detailed",
                "content": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        unordered_map<char,int> mp1; //A map to get the frequency of string 1\\n        unordered_map<char,int> mp2; //A map to get the frequency of string 2\\n        vector<int> v1;\\n        vector<int> v2;\\n        if(word1.size()==word2.size()) //It is possible only if both string have same length\\n        {\\n            for(auto it:word1)\\n            {\\n                mp1[it]++; \\n            }\\n             for(auto it:word2)\\n            {\\n                mp2[it]++;\\n            }\\n            for(int i=0;i<word2.size();i++)\\n            {\\n             if (word2.find(word1[i]) != std::string::npos)  //To check whether the element exist in the string 2 or not\\n             {\\n                 v1.push_back(mp1[word1[i]]);//if it exist just addedits frequency to a new vector\\n             }\\n            else\\n                {\\n                    return false;//If it doesnot exist then return false.\\n                }\\n                 if (word1.find(word2[i]) != std::string::npos) //same for string 2 elements in string 1\\n             {\\n                 v2.push_back(mp2[word2[i]]);\\n             }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            sort(v1.begin(),v1.end()); //sorted the vectors \\n            sort(v2.begin(),v2.end());\\n            if(v1==v2)  //compared them so that if the occurences are matching then return true else false\\n                return true;\\n            else\\n                return false;\\n        }\\n        else\\n            return false;\\n    }\\n};\\n//Suggestions and feedbacks are welcomed. Happy Coding!!\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        unordered_map<char,int> mp1; //A map to get the frequency of string 1\\n        unordered_map<char,int> mp2; //A map to get the frequency of string 2\\n        vector<int> v1;\\n        vector<int> v2;\\n        if(word1.size()==word2.size()) //It is possible only if both string have same length\\n        {\\n            for(auto it:word1)\\n            {\\n                mp1[it]++; \\n            }\\n             for(auto it:word2)\\n            {\\n                mp2[it]++;\\n            }\\n            for(int i=0;i<word2.size();i++)\\n            {\\n             if (word2.find(word1[i]) != std::string::npos)  //To check whether the element exist in the string 2 or not\\n             {\\n                 v1.push_back(mp1[word1[i]]);//if it exist just addedits frequency to a new vector\\n             }\\n            else\\n                {\\n                    return false;//If it doesnot exist then return false.\\n                }\\n                 if (word1.find(word2[i]) != std::string::npos) //same for string 2 elements in string 1\\n             {\\n                 v2.push_back(mp2[word2[i]]);\\n             }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            sort(v1.begin(),v1.end()); //sorted the vectors \\n            sort(v2.begin(),v2.end());\\n            if(v1==v2)  //compared them so that if the occurences are matching then return true else false\\n                return true;\\n            else\\n                return false;\\n        }\\n        else\\n            return false;\\n    }\\n};\\n//Suggestions and feedbacks are welcomed. Happy Coding!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869055,
                "title": "c-o-1-time-o-n-space-clean-and-concise-code",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26 + 26) = O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        vector<int> f1(26) , f2(26);\\n        for(auto &it : word1) ++f1[it-\\'a\\'];\\n        for(auto &it : word2)\\n        {\\n            if(f1[it-\\'a\\']==0) return false; //If we dont have this letter in word1\\n            ++f2[it-\\'a\\'];\\n        } \\n        sort(f1.begin(),f1.end());\\n        sort(f2.begin(),f2.end());\\n        return f1==f2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        vector<int> f1(26) , f2(26);\\n        for(auto &it : word1) ++f1[it-\\'a\\'];\\n        for(auto &it : word2)\\n        {\\n            if(f1[it-\\'a\\']==0) return false; //If we dont have this letter in word1\\n            ++f2[it-\\'a\\'];\\n        } \\n        sort(f1.begin(),f1.end());\\n        sort(f2.begin(),f2.end());\\n        return f1==f2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868909,
                "title": "c-hashmap-simple-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing HashMap and Vector\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size()!=word2.size())\\n        {\\n            return false;\\n        }\\n        \\n        map<char,int>mp1;\\n        map<char,int>mp2;\\n        string a1=\"\",a2=\"\";\\n        for(int i=0;i<word1.size();i++)\\n        {\\n           mp1[word1[i]]++;\\n           mp2[word2[i]]++;\\n\\n        }\\n        vector<int>p1,p2;\\n        for(auto it1:mp1)\\n        {\\n            a1+=it1.first;\\n            p1.push_back(it1.second);\\n        }       \\n        \\n        for(auto it2:mp2)\\n        {\\n            a2+=it2.first;\\n            p2.push_back(it2.second)   ;       \\n        }   \\n        \\n        sort(p1.begin(),p1.end());\\n        sort(p2.begin(),p2.end());\\n\\n        for(int i=0;i<p1.size();i++)\\n        {\\n            if(p1[i]!=p2[i])\\n            {\\n                return false;\\n            }\\n        }\\n\\n        if( a1!=a2)\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size()!=word2.size())\\n        {\\n            return false;\\n        }\\n        \\n        map<char,int>mp1;\\n        map<char,int>mp2;\\n        string a1=\"\",a2=\"\";\\n        for(int i=0;i<word1.size();i++)\\n        {\\n           mp1[word1[i]]++;\\n           mp2[word2[i]]++;\\n\\n        }\\n        vector<int>p1,p2;\\n        for(auto it1:mp1)\\n        {\\n            a1+=it1.first;\\n            p1.push_back(it1.second);\\n        }       \\n        \\n        for(auto it2:mp2)\\n        {\\n            a2+=it2.first;\\n            p2.push_back(it2.second)   ;       \\n        }   \\n        \\n        sort(p1.begin(),p1.end());\\n        sort(p2.begin(),p2.end());\\n\\n        for(int i=0;i<p1.size();i++)\\n        {\\n            if(p1[i]!=p2[i])\\n            {\\n                return false;\\n            }\\n        }\\n\\n        if( a1!=a2)\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868872,
                "title": "c-easy-sol-faster-than-97-1-tc-o-n-space-o-1",
                "content": "# Complexity\\n- Time complexity : O(n) , where n is word length\\n\\n- Space complexity : O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        \\n        if(word1.length() != word2.length())\\n        return false ;\\n\\n        vector<int> f1(26 , 0) , f2(26 , 0);\\n        \\n        //Store The Count of Each Letter from both words separately \\n        for(int i = 0 ; i<word1.length() ; i++)\\n        {\\n            f1[word1[i]-\\'a\\']++;\\n            f2[word2[i]-\\'a\\']++;\\n        }\\n\\n        //Check For wheather a letter is present in one word and absent in \\n        // another word , then return false\\n        // Because we can\\'t interchange that letter with any other word\\n        // ex : abcdef abcde will always return false\\n\\n        for(int i = 0 ; i<26 ; i++)\\n        {\\n            if (f1[i] == 0 ^ f2[i] == 0)\\n                return false;\\n        }\\n        \\n        // Now Sort The frequencies \\n        sort(f1.begin() , f1.end());\\n        sort(f2.begin() , f2.end());\\n        \\n        // If they don\\'t match return false\\n        for(int i = 0 ; i<26 ; i++)\\n        {\\n            if(f1[i] != f2[i])\\n                return false;\\n        }\\n        \\n        return true;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        \\n        if(word1.length() != word2.length())\\n        return false ;\\n\\n        vector<int> f1(26 , 0) , f2(26 , 0);\\n        \\n        //Store The Count of Each Letter from both words separately \\n        for(int i = 0 ; i<word1.length() ; i++)\\n        {\\n            f1[word1[i]-\\'a\\']++;\\n            f2[word2[i]-\\'a\\']++;\\n        }\\n\\n        //Check For wheather a letter is present in one word and absent in \\n        // another word , then return false\\n        // Because we can\\'t interchange that letter with any other word\\n        // ex : abcdef abcde will always return false\\n\\n        for(int i = 0 ; i<26 ; i++)\\n        {\\n            if (f1[i] == 0 ^ f2[i] == 0)\\n                return false;\\n        }\\n        \\n        // Now Sort The frequencies \\n        sort(f1.begin() , f1.end());\\n        sort(f2.begin() , f2.end());\\n        \\n        // If they don\\'t match return false\\n        for(int i = 0 ; i<26 ; i++)\\n        {\\n            if(f1[i] != f2[i])\\n                return false;\\n        }\\n        \\n        return true;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868175,
                "title": "clear-and-concise-cpp-code-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        vector<int>m(26,0),m1(26,0);\\n        for(auto i:word1)m[i-\\'a\\']++;\\n        for(auto i:word2)m1[i-\\'a\\']++;\\n        for(int i=0;i<26;i++){\\n            if((m[i]&&!m1[i])||(!m[i]&&m[i]))return false; // if a character exist only in one string then return false..\\n        }\\n        sort(m.begin(),m.end());\\n        sort(m1.begin(),m1.end());\\n        return m==m1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        vector<int>m(26,0),m1(26,0);\\n        for(auto i:word1)m[i-\\'a\\']++;\\n        for(auto i:word2)m1[i-\\'a\\']++;\\n        for(int i=0;i<26;i++){\\n            if((m[i]&&!m1[i])||(!m[i]&&m[i]))return false; // if a character exist only in one string then return false..\\n        }\\n        sort(m.begin(),m.end());\\n        sort(m1.begin(),m1.end());\\n        return m==m1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030361,
                "title": "detailed-java-o-n-solution-bit-manipulation-explained",
                "content": "The part where we have to count the frequency of characters is simple.\\n\\nThe real problem was finding  a way to check if a given frequency in the frequency array of second string occurs anywhere in the frequency array of the first string. HashSets can be used for that but where is the fun in that.\\n\\nTo solve this problem I used xor operation. Now, the xor gives 1 only if number of 1s in the input are 1. So if the xor operation ever encounter a condition when the number of 1s is odd, it will stay 1 until it is cancelled out in future by another same number.\\n\\nSuppose you encounter a frequency 5 in frequency array 1, it can only be cancelled out by another frequency 5 only. You can take 2 separate variables to calculate xor of all the frequencies in two strings separately and perform an xor of both the variables at last. But this will be same as having a single variable.\\n\\nA base case is if frequency of a character is zero in one string but not in another, then of course answer is false.\\n\\nPlease do not forget to upvote.\\n\\nHere is my solution: \\n\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length()!=word2.length())\\n            return false;\\n        \\n        int []d1=new int[26];\\n        int []d2=new int[26];\\n        \\n\\t\\t// getting freq of each character\\n        for(int i=0;i<word1.length();i++) {\\n            char c=word1.charAt(i);\\n            d1[c-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<word2.length();i++) {\\n            char c=word2.charAt(i);\\n            d2[c-\\'a\\']++;\\n        }\\n        \\n        int res=0;\\n        \\n\\t\\t// performing xor operation\\n        for(int i=0;i<26;i++) {\\n            if((d1[i]==0 && d2[i]!=0) || (d2[i]==0 && d1[i]!=0))\\n                return false;\\n            res^=d1[i];\\n            res^=d2[i];\\n        }\\n        return res==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length()!=word2.length())\\n            return false;\\n        \\n        int []d1=new int[26];\\n        int []d2=new int[26];\\n        \\n\\t\\t// getting freq of each character\\n        for(int i=0;i<word1.length();i++) {\\n            char c=word1.charAt(i);\\n            d1[c-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<word2.length();i++) {\\n            char c=word2.charAt(i);\\n            d2[c-\\'a\\']++;\\n        }\\n        \\n        int res=0;\\n        \\n\\t\\t// performing xor operation\\n        for(int i=0;i<26;i++) {\\n            if((d1[i]==0 && d2[i]!=0) || (d2[i]==0 && d1[i]!=0))\\n                return false;\\n            res^=d1[i];\\n            res^=d2[i];\\n        }\\n        return res==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029186,
                "title": "python-simplest-approach-in-one-line-easy-short-faster-than-90",
                "content": "**So Simple - Faster than 90%**\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        w1 = Counter(word1)\\n        w2 = Counter(word2)\\n        \\n        letters1 = [x for x in w1.keys()]\\n        letters2 = [x for x in w2.keys()]\\n        \\n        freq1 = [x for x in w1.values()]\\n        freq2 = [x for x in w2.values()]\\n\\n        return sorted(letters1) == sorted(letters2) and sorted(freq1) == sorted(freq2)\\n```\\n**Same idea in one line - a bit slower**\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        return sorted([x for x in Counter(word1).keys()]) == sorted([x for x in Counter(word2).keys()]) and sorted([x for x in Counter(word1).values()]) == sorted([x for x in Counter(word2).values()])\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        w1 = Counter(word1)\\n        w2 = Counter(word2)\\n        \\n        letters1 = [x for x in w1.keys()]\\n        letters2 = [x for x in w2.keys()]\\n        \\n        freq1 = [x for x in w1.values()]\\n        freq2 = [x for x in w2.values()]\\n\\n        return sorted(letters1) == sorted(letters2) and sorted(freq1) == sorted(freq2)\\n```\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        return sorted([x for x in Counter(word1).keys()]) == sorted([x for x in Counter(word2).keys()]) and sorted([x for x in Counter(word1).values()]) == sorted([x for x in Counter(word2).values()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936109,
                "title": "c-simple-counting-o-n",
                "content": "```\\npublic class Solution {\\n    public bool CloseStrings(string word1, string word2) {\\n        if(word1.Length != word2.Length) return false;\\n        int[] a = new int[26];\\n        int[] b = new int[26];\\n        int maxLen = 0;\\n        for(int i = 0; i < word1.Length; i++)\\n        {\\n            maxLen = Math.Max(maxLen, ++a[word1[i] - \\'a\\']);\\n            maxLen = Math.Max(maxLen, ++b[word2[i] - \\'a\\']);\\n        }\\n        int[] len = new int[maxLen+1];\\n        for(int i = 0; i < a.Length; i++)\\n        {\\n            if (a[i] > 0 && b[i] == 0) return false;\\n            if (b[i] > 0 && a[i] == 0) return false;\\n            len[a[i]]++;\\n            len[b[i]]--;\\n        }\\n        \\n        return len.All(x => x == 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CloseStrings(string word1, string word2) {\\n        if(word1.Length != word2.Length) return false;\\n        int[] a = new int[26];\\n        int[] b = new int[26];\\n        int maxLen = 0;\\n        for(int i = 0; i < word1.Length; i++)\\n        {\\n            maxLen = Math.Max(maxLen, ++a[word1[i] - \\'a\\']);\\n            maxLen = Math.Max(maxLen, ++b[word2[i] - \\'a\\']);\\n        }\\n        int[] len = new int[maxLen+1];\\n        for(int i = 0; i < a.Length; i++)\\n        {\\n            if (a[i] > 0 && b[i] == 0) return false;\\n            if (b[i] > 0 && a[i] == 0) return false;\\n            len[a[i]]++;\\n            len[b[i]]--;\\n        }\\n        \\n        return len.All(x => x == 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935954,
                "title": "javascript-hashmap",
                "content": "Check whether two chars counting number hashMaps are same.\\nEx1: `abb` vs `baa`\\n->`{a:1, b: 2}` vs `{a:2, b:1}`\\n-> `{1:1, 2:1}` vs `{1:1, 2:1}` -> true\\n\\nEx2: `cabbba` vs `abbccc`\\n-> `{a:2, b:3, c:1}` vs `{a:1, b:2, c:3}`\\n-> `{1:1, 2:1, 3:1}` vs `{1:1, 2:1, 3:1}` -> true\\n\\n```\\nvar closeStrings = function(word1, word2) {\\n    if (word1.length !== word2.length)  return false;\\n    \\n    const chars = new Array(26).fill(0),\\n          used = new Array(26).fill(false),\\n          a = \\'a\\'.charCodeAt(0);\\n    \\n    for (let i = 0; i < word1.length; i++) {\\n        chars[word1.charCodeAt(i)-a]++;\\n        used[word1.charCodeAt(i)-a] = true;\\n    }\\n    \\n    let countMap = {};\\n    \\n    for (let n of chars) {\\n        if (countMap[n] === undefined)\\n            countMap[n] = 0;\\n        countMap[n]++;\\n    }\\n    \\n    chars.fill(0);\\n    for (let i = 0; i < word2.length; i++) {\\n        if (!used[word2.charCodeAt(i)-a])  // if there is new char not used in word1, return false\\n            return false;\\n        chars[word2.charCodeAt(i)-a]++;\\n    }\\n    \\n    for (let n of chars) {\\n        if (countMap[n] === undefined)   // if one char has the frequency unused in word1, return false\\n            return false;\\n        countMap[n]--;\\n        if (countMap[n] < 0)\\n            return false;\\n    }\\n    \\n    return true;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Check whether two chars counting number hashMaps are same.\\nEx1: `abb` vs `baa`\\n->`{a:1, b: 2}` vs `{a:2, b:1}`\\n-> `{1:1, 2:1}` vs `{1:1, 2:1}` -> true\\n\\nEx2: `cabbba` vs `abbccc`\\n-> `{a:2, b:3, c:1}` vs `{a:1, b:2, c:3}`\\n-> `{1:1, 2:1, 3:1}` vs `{1:1, 2:1, 3:1}` -> true\\n\\n```\\nvar closeStrings = function(word1, word2) {\\n    if (word1.length !== word2.length)  return false;\\n    \\n    const chars = new Array(26).fill(0),\\n          used = new Array(26).fill(false),\\n          a = \\'a\\'.charCodeAt(0);\\n    \\n    for (let i = 0; i < word1.length; i++) {\\n        chars[word1.charCodeAt(i)-a]++;\\n        used[word1.charCodeAt(i)-a] = true;\\n    }\\n    \\n    let countMap = {};\\n    \\n    for (let n of chars) {\\n        if (countMap[n] === undefined)\\n            countMap[n] = 0;\\n        countMap[n]++;\\n    }\\n    \\n    chars.fill(0);\\n    for (let i = 0; i < word2.length; i++) {\\n        if (!used[word2.charCodeAt(i)-a])  // if there is new char not used in word1, return false\\n            return false;\\n        chars[word2.charCodeAt(i)-a]++;\\n    }\\n    \\n    for (let n of chars) {\\n        if (countMap[n] === undefined)   // if one char has the frequency unused in word1, return false\\n            return false;\\n        countMap[n]--;\\n        if (countMap[n] < 0)\\n            return false;\\n    }\\n    \\n    return true;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 935937,
                "title": "java-20-lines-o-n-solution",
                "content": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        int freq1[] = new int[26];\\n        int freq2[] = new int[26];\\n        int []visited1 = new int[26];\\n        int []visited2 = new int[26];\\n        \\n        for(char ch : word1.toCharArray()){\\n            freq1[ch-\\'a\\']++;\\n            visited1[ch-\\'a\\'] = 1;\\n        }\\n        \\n        for(char ch : word2.toCharArray()){\\n            freq2[ch-\\'a\\']++;\\n            visited2[ch-\\'a\\'] = 1;\\n        }\\n        Arrays.sort(freq1);\\n        Arrays.sort(freq2);\\n        return Arrays.equals(visited1, visited2) && Arrays.equals(freq1, freq2);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        int freq1[] = new int[26];\\n        int freq2[] = new int[26];\\n        int []visited1 = new int[26];\\n        int []visited2 = new int[26];\\n        \\n        for(char ch : word1.toCharArray()){\\n            freq1[ch-\\'a\\']++;\\n            visited1[ch-\\'a\\'] = 1;\\n        }\\n        \\n        for(char ch : word2.toCharArray()){\\n            freq2[ch-\\'a\\']++;\\n            visited2[ch-\\'a\\'] = 1;\\n        }\\n        Arrays.sort(freq1);\\n        Arrays.sort(freq2);\\n        return Arrays.equals(visited1, visited2) && Arrays.equals(freq1, freq2);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813946,
                "title": "simple-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int[] arr1 = new int[26];\\n        int[] arr2 = new int[26];\\n\\n        for(char ch : word1.toCharArray())\\n            arr1[ch - \\'a\\']++;\\n        for(char ch : word2.toCharArray())\\n            arr2[ch - \\'a\\']++;\\n\\n        for(int i=0;i<26;i++) {\\n            if (arr1[i] == arr2[i]) {\\n                continue;\\n            }\\n            if(arr1[i] == 0 || arr2[i] == 0) {\\n                return false;\\n            }\\n        }\\n\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n\\n        for(int i=0;i<26;i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int[] arr1 = new int[26];\\n        int[] arr2 = new int[26];\\n\\n        for(char ch : word1.toCharArray())\\n            arr1[ch - \\'a\\']++;\\n        for(char ch : word2.toCharArray())\\n            arr2[ch - \\'a\\']++;\\n\\n        for(int i=0;i<26;i++) {\\n            if (arr1[i] == arr2[i]) {\\n                continue;\\n            }\\n            if(arr1[i] == 0 || arr2[i] == 0) {\\n                return false;\\n            }\\n        }\\n\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n\\n        for(int i=0;i<26;i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655295,
                "title": "easy-intuitive-solution-in-java-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo from the 2 steps it is clear that the 2 words should have same set of letters and the frequency should also be same like aabc and bbac frequency of a = frency of b and all other leters are present once, we need to find if the 2 words fit in this criteria\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.define 2 arrays to track frequencies, sort the arrays and see if they match.\\n2.track each unique characters in the strings and compare if the set of unique characters match.\\n\\n# Complexity\\n- Time complexity:\\no(nlogn)\\n\\n- Space complexity:\\nconstant extra space \\n\\n# Code\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n\\n        int word1freq[] = new int[26];\\n        int word2freq[] = new int[26];\\n        int w1[] = new int[26];\\n        int w2[] = new int[26];\\n    \\n\\n        for (char c : word1.toCharArray()) {\\n            word1freq[c - \\'a\\']++;\\n            w1[c -\\'a\\'] = 1;\\n        }\\n        for(char c : word2.toCharArray()) {\\n\\n            word2freq[c - \\'a\\']++;\\n            w2[c - \\'a\\'] = 1;\\n\\n        }\\n\\n        Arrays.sort(word1freq);\\n        Arrays.sort(word2freq);\\n        return Arrays.equals(w1,w2) && Arrays.equals(word1freq,word2freq);\\n\\n\\n\\nPlease give a thumbs up if you like the solution.\\n\\n        \\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n\\n        int word1freq[] = new int[26];\\n        int word2freq[] = new int[26];\\n        int w1[] = new int[26];\\n        int w2[] = new int[26];\\n    \\n\\n        for (char c : word1.toCharArray()) {\\n            word1freq[c - \\'a\\']++;\\n            w1[c -\\'a\\'] = 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3601018,
                "title": "closestrings-best-solution-with-explanation-intuition-approach-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven two possible operations and by overall description, we can conclude that `length` of given words `word1` and `word2` should be equal, otherwise the strings can not be close.\\n\\nAlso, based on the given operations the strings can be `closeStrings` only if the frequencies of/and characters in both strings are same.\\n(Frequencies irrespective of the characters)\\n\\n*For better understanding go through Approach and Code*\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf `word1.size() != word2.size()` return `false`\\nUsing \\n`map` for storing the `{char:frequency}` of each char of both strings\\n`multiset` for storing just the frequencys of chars of both strings\\n`set` for checking the characters in both strings\\n\\nNote: Multiset is used for storing frequencies as it can store duplicate values.\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**Please upvote if you find it helpful ;)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size()!=word2.size()) return false;\\n        unordered_map<char, int> m1,m2;\\n        multiset<int> s1,s2;\\n        set<char> ch;\\n        for(char c: word1) {m1[c]++; ch.insert(c); }\\n        for(char c: word2) {m2[c]++; ch.erase(c); }\\n        for(auto [k,value] : m1) s1.insert(value);\\n        for(auto [k,value] : m2) s2.insert(value);\\n        return (ch.empty() && s1==s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size()!=word2.size()) return false;\\n        unordered_map<char, int> m1,m2;\\n        multiset<int> s1,s2;\\n        set<char> ch;\\n        for(char c: word1) {m1[c]++; ch.insert(c); }\\n        for(char c: word2) {m2[c]++; ch.erase(c); }\\n        for(auto [k,value] : m1) s1.insert(value);\\n        for(auto [k,value] : m2) s2.insert(value);\\n        return (ch.empty() && s1==s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448815,
                "title": "python-simple-clean-code-using-counter",
                "content": "# Code\\n```\\nclass Solution:\\n    def closeStrings(self, s1: str, s2: str) -> bool:\\n        return set(s1) == set(s2) and Counter(Counter(s1).values()) == Counter(Counter(s2).values())\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, s1: str, s2: str) -> bool:\\n        return set(s1) == set(s2) and Counter(Counter(s1).values()) == Counter(Counter(s2).values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939011,
                "title": "very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIn order to be close , the length of word1 , word2 should be equal.\\nif this condition dont match simply return false.\\n\\nOperation 1 allows you to freely reorder the string.\\nSo we will store the characters present in word1 , word2 . \\nif any character present in  word1 is not present in word2 or vice versa we would simply return false . \\n\\nif operation1 satisfies , we would move to operation 2\\n\\n\\nOperation 2 allows you to freely reassign the letters frequencies.\\nSo we will store the frequencies of chars .   Since we can resassign letter frequencies , we now simply need to check if all the frequencies of  word1 matches with frequencies of word2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. if length of word1 is not equal to word 2 return false \\n2.  Use a vector of size 26 say m1  and store the frequency of the   character in vector m1 for word1 .\\n\\npoition of a -> 0 b-1   ... z -> 25\\n\\n3. Now iterate through word2 , and check if  character  of word2 exists in m1 . If not return false ;and  update m2 vector for storing frequencies of characters of word2 .\\n\\n4. Now sort vector v1 and v2 ;\\n\\n5. iterate and check frequencies if they dont match return false ;\\n\\nwe will understand it using example now .\\n\\nword1 = nibbbi\\n\\nword2 = niibbi\\n\\nchars in word1 -> n , i  , b \\n\\nchars in word2 -> n , i , b \\n\\nsince all the characters of word1 and word2 match , \\n\\nwe will check frequencies \\n\\nword1 = n -> 1 , i-> 2 , b-> 3 \\nword2 = n-> 1 , i -> 3 , b -> 2 \\n\\nsince frequencies are stored in vectors and vectors are sorted . we will match frequencies. if frequencies dont match , simply return false \\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: 0(nlogn) n is 26 here \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: 0(26) ~ 0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n\\n        if(word1.length() != word2.length())\\n        return false ; \\n\\n        vector<int> m1(26) , m2(26) ; \\n\\n        for(char ch : word1)\\n        m1[ch - \\'a\\']++;\\n\\n        for(char ch : word2)\\n        {\\n            int val = m1[ch - \\'a\\'];\\n             \\n            if(val == 0)\\n            return false ;\\n\\n            m2[ch - \\'a\\']++;\\n\\n        }\\n\\n        sort(m1.begin() , m1.end());\\n        sort(m2.begin() , m2.end());\\n\\n        for(int i = 0 ; i < 26 ; i++)\\n        {\\n            if(m1[i] != m2[i] )\\n            return false ;\\n        }\\n     return true ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n\\n        if(word1.length() != word2.length())\\n        return false ; \\n\\n        vector<int> m1(26) , m2(26) ; \\n\\n        for(char ch : word1)\\n        m1[ch - \\'a\\']++;\\n\\n        for(char ch : word2)\\n        {\\n            int val = m1[ch - \\'a\\'];\\n             \\n            if(val == 0)\\n            return false ;\\n\\n            m2[ch - \\'a\\']++;\\n\\n        }\\n\\n        sort(m1.begin() , m1.end());\\n        sort(m2.begin() , m2.end());\\n\\n        for(int i = 0 ; i < 26 ; i++)\\n        {\\n            if(m1[i] != m2[i] )\\n            return false ;\\n        }\\n     return true ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870575,
                "title": "precise-1-for-loop-solution-very-very-easy-understanding",
                "content": "class Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.length()!=word2.length())  return false;\\n        unordered_set<int> s1,s2;\\n        vector<int> v1(26,0),v2(26,0);\\n        for(int i=0;i<word1.size();i++){\\n              s1.insert(word1[i]);\\n            v1[word1[i]-\\'a\\']++;\\n            s2.insert(word2[i]);\\n            v2[word2[i]-\\'a\\']++;\\n        }\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n       if(s1!=s2 || v1!=v2) return false;\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.length()!=word2.length())  return false;\\n        unordered_set<int> s1,s2;\\n        vector<int> v1(26,0),v2(26,0);\\n        for(int i=0;i<word1.size();i++){\\n              s1.insert(word1[i]);\\n            v1[word1[i]-\\'a\\']++;\\n            s2.insert(word2[i]);\\n            v2[word2[i]-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2870217,
                "title": "java-most-simplest-solution",
                "content": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int[]str1 = new int[26];\\n        int[]str2 = new int[26];\\n        for(char c: word1.toCharArray())\\n            str1[c - \\'a\\']++;\\n        for(char c: word2.toCharArray()){\\n            str2[c - \\'a\\']++;\\n        if(str1[c -\\'a\\']==0)\\n            return false;\\n        }\\n        Arrays.sort(str1);\\n        Arrays.sort(str2);\\n        for(int i=0; i<26; i++){\\n            if (str1[i]!= str2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int[]str1 = new int[26];\\n        int[]str2 = new int[26];\\n        for(char c: word1.toCharArray())\\n            str1[c - \\'a\\']++;\\n        for(char c: word2.toCharArray()){\\n            str2[c - \\'a\\']++;\\n        if(str1[c -\\'a\\']==0)\\n            return false;\\n        }\\n        Arrays.sort(str1);\\n        Arrays.sort(str2);\\n        for(int i=0; i<26; i++){\\n            if (str1[i]!= str2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870199,
                "title": "easy-to-understand-not-short-but-easy-explnantion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nist store all the word1 and word2 in the map\\nex=> word1 = \"cabbba\"\\nfre  c=1 ,a=2,b=3  \\n, word2 = \"abbccc\"\\nc=3,a=1,c=2;\\n2nd store all the frequancy of the word1 and word2 in the vector\\nsort the vector \\ncompare the vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int n=word1.size();\\n        int m=word2.size();\\n        if(n!=m)return false;\\n\\n         unordered_map<char,int>mp1;\\n         for(int i=0;i<m;i++)\\n         {\\n\\n             mp1[word2[i]]++;\\n         }\\n          \\n        unordered_map<char,int>mp;\\n         for(int i=0;i<n;i++)\\n         {\\n             if(mp1.find(word1[i])==mp.end())// for when the element not present in the word2  case =>uau ,ssx this type case handle .\\n             return false;\\n             mp[word1[i]]++;\\n         }\\n          vector<int>v;\\n          for(auto it:mp)\\n              {\\n                  int p=it.second;\\n                  v.push_back(p);\\n              }\\n\\n             vector<int>v1;\\n              for(auto it:mp1)\\n              {\\n                  int p=it.second;\\n                  v1.push_back(p);\\n              }\\n          sort(v.begin(),v.end());\\n          sort(v1.begin(),v1.end());\\n\\n            for(int i=0;i<v.size();i++)\\n            {\\n                if(v[i]!=v1[i])\\n                return false;\\n            }\\n              return true;\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int n=word1.size();\\n        int m=word2.size();\\n        if(n!=m)return false;\\n\\n         unordered_map<char,int>mp1;\\n         for(int i=0;i<m;i++)\\n         {\\n\\n             mp1[word2[i]]++;\\n         }\\n          \\n        unordered_map<char,int>mp;\\n         for(int i=0;i<n;i++)\\n         {\\n             if(mp1.find(word1[i])==mp.end())// for when the element not present in the word2  case =>uau ,ssx this type case handle .\\n             return false;\\n             mp[word1[i]]++;\\n         }\\n          vector<int>v;\\n          for(auto it:mp)\\n              {\\n                  int p=it.second;\\n                  v.push_back(p);\\n              }\\n\\n             vector<int>v1;\\n              for(auto it:mp1)\\n              {\\n                  int p=it.second;\\n                  v1.push_back(p);\\n              }\\n          sort(v.begin(),v.end());\\n          sort(v1.begin(),v1.end());\\n\\n            for(int i=0;i<v.size();i++)\\n            {\\n                if(v[i]!=v1[i])\\n                return false;\\n            }\\n              return true;\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870073,
                "title": "constant-space-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nif the count of each character of A must matches with count of any character in string B and that character of A must present in string B then return True\\n else return false \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1) constant space O(26)  \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string w1, string w2) {\\n        int l1=w1.size(),l2=w2.size();\\n        if(l1!=l2) return 0;\\n        int a[26]={0},b[26]={0},c[26]={0};\\n        for(int i=0;i<;i++)  \\n        {\\n          a[w1[i]-\\'a\\']++;\\n          b[w2[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++) c[i]=b[i];\\n\\n        for(int i=0;i<26;i++)\\n        {\\n            bool check=0;\\n            for(int j=0;j<26;j++)\\n            {\\n                if(a[i]==b[j] && c[i]!=0) \\n                { \\n                    b[j]=-1; break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<26;i++) if(b[i]>0) return 0;\\n         return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string w1, string w2) {\\n        int l1=w1.size(),l2=w2.size();\\n        if(l1!=l2) return 0;\\n        int a[26]={0},b[26]={0},c[26]={0};\\n        for(int i=0;i<;i++)  \\n        {\\n          a[w1[i]-\\'a\\']++;\\n          b[w2[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++) c[i]=b[i];\\n\\n        for(int i=0;i<26;i++)\\n        {\\n            bool check=0;\\n            for(int j=0;j<26;j++)\\n            {\\n                if(a[i]==b[j] && c[i]!=0) \\n                { \\n                    b[j]=-1; break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<26;i++) if(b[i]>0) return 0;\\n         return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869685,
                "title": "huh-100-faster-simple-java-solution-i-bet-for-the-best-easy-to-understand",
                "content": "**Upvote if you liked the solution**\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length()!=word2.length()) return false;\\n        \\n        \\n        //for operation 2. i can check for the occurences as aacabb -> bbcbaa\\n        //here a=3 and b=2 at first then it changes to a=2 and b=3. so swapping is done\\n        //and for operation 1 it is always possivle\\n        //determine the frequency\\n        //sort the array and check the equality,\\n        \\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        \\n        for(int i=0;i<word1.length();i++)\\n        {\\n            a[word1.charAt(i)-\\'a\\']++;\\n            b[word2.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            if((a[i]==0 && b[i]!=0 )||(a[i]!=0 && b[i]==0))\\n                return false;\\n        }\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        \\n        return Arrays.equals(a,b);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length()!=word2.length()) return false;\\n        \\n        \\n        //for operation 2. i can check for the occurences as aacabb -> bbcbaa\\n        //here a=3 and b=2 at first then it changes to a=2 and b=3. so swapping is done\\n        //and for operation 1 it is always possivle\\n        //determine the frequency\\n        //sort the array and check the equality,\\n        \\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        \\n        for(int i=0;i<word1.length();i++)\\n        {\\n            a[word1.charAt(i)-\\'a\\']++;\\n            b[word2.charAt(i)-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2869620,
                "title": "o-n-time-o-1-memory-c-solution",
                "content": "2 Strings are close if every character in the first string has at least one occurence in the other string, and there should be a one to one mapping of frequencies.\\n\\nfor example:\\n\\n\\n```accd``` and ```ddca``` through a series of swaps you can reach the state ```addc``` where you can replace ```c```\\'s with ```d```\\'s\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        unordered_map<int, int> seen1, seen2;\\n        vector<int> freq1(26, 0), freq2(26, 0);\\n        if (word1.size() != word2.size()) return false;\\n        for (auto c : word1) ++freq1[c - \\'a\\'];\\n        for (auto c : word2) ++freq2[c - \\'a\\'];\\n        for (int i = 0; i < 26; ++i)\\n            if ((freq1[i] and !freq2[i]) or \\n                (!freq1[i] and freq2[i])) return false;\\n        for (auto n : freq1) seen1[n]++;\\n        for (auto n : freq2) seen2[n]++;\\n        \\n        return seen1 == seen2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```accd```\n```ddca```\n```addc```\n```c```\n```d```\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        unordered_map<int, int> seen1, seen2;\\n        vector<int> freq1(26, 0), freq2(26, 0);\\n        if (word1.size() != word2.size()) return false;\\n        for (auto c : word1) ++freq1[c - \\'a\\'];\\n        for (auto c : word2) ++freq2[c - \\'a\\'];\\n        for (int i = 0; i < 26; ++i)\\n            if ((freq1[i] and !freq2[i]) or \\n                (!freq1[i] and freq2[i])) return false;\\n        for (auto n : freq1) seen1[n]++;\\n        for (auto n : freq2) seen2[n]++;\\n        \\n        return seen1 == seen2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869536,
                "title": "rust-super-concise-o-n",
                "content": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn close_strings(word1: String, word2: String) -> bool {\\n        // create mappings from characters to their\\n        // frequencies in word1 and word2\\n        let (mut map1, mut map2) = ([0; 26], [0; 26]);\\n        for c in word1.chars() { map1[c as usize - 0x61] += 1; };\\n        for c in word2.chars() { map2[c as usize - 0x61] += 1; };\\n        \\n        // if there is character that one word contains\\n        // but the other doesn\\'t, then they can\\'t be \\'close\\'\\n        for i in 0..26 {\\n            if (map1[i] == 0 && map2[i] != 0) || (map1[i] != 0 && map2[i] == 0) {\\n                return false;\\n            }\\n        }\\n        \\n        // sort the maps such that we can make sure the amount of characters\\n        // with a given frequency match\\n\\t\\t//\\n\\t\\t// since maps are of size 26, this would be 2*O(26log26) === O(1)\\n        map1.sort();\\n        map2.sort();\\n        \\n        map1 == map2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sorting"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn close_strings(word1: String, word2: String) -> bool {\\n        // create mappings from characters to their\\n        // frequencies in word1 and word2\\n        let (mut map1, mut map2) = ([0; 26], [0; 26]);\\n        for c in word1.chars() { map1[c as usize - 0x61] += 1; };\\n        for c in word2.chars() { map2[c as usize - 0x61] += 1; };\\n        \\n        // if there is character that one word contains\\n        // but the other doesn\\'t, then they can\\'t be \\'close\\'\\n        for i in 0..26 {\\n            if (map1[i] == 0 && map2[i] != 0) || (map1[i] != 0 && map2[i] == 0) {\\n                return false;\\n            }\\n        }\\n        \\n        // sort the maps such that we can make sure the amount of characters\\n        // with a given frequency match\\n\\t\\t//\\n\\t\\t// since maps are of size 26, this would be 2*O(26log26) === O(1)\\n        map1.sort();\\n        map2.sort();\\n        \\n        map1 == map2\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2869395,
                "title": "java-100-solution-determine-if-two-strings-are-close",
                "content": "**Time Complexitiy: O(n)\\nSpace Complexitiy: O(1)**\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length()!=word2.length())\\n            return false;\\n        \\n        int arr1[] = new int[26];\\n        int arr2[] = new int[26];\\n        \\n        for(int i=0;i<word1.length();i++)\\n            arr1[word1.charAt(i)-\\'a\\']++;\\n        \\n        for(int i=0;i<word2.length();i++)\\n            arr2[word2.charAt(i)-\\'a\\']++;\\n        \\n        for(int i=0;i<26;i++)\\n            if((arr1[i]==0 && arr2[i]!=0) || (arr1[i]!=0 && arr2[i]==0))\\n                return false;\\n        \\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n        \\n        for(int i=0;i<26;i++)\\n            if(arr1[i]!=arr2[i])\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length()!=word2.length())\\n            return false;\\n        \\n        int arr1[] = new int[26];\\n        int arr2[] = new int[26];\\n        \\n        for(int i=0;i<word1.length();i++)\\n            arr1[word1.charAt(i)-\\'a\\']++;\\n        \\n        for(int i=0;i<word2.length();i++)\\n            arr2[word2.charAt(i)-\\'a\\']++;\\n        \\n        for(int i=0;i<26;i++)\\n            if((arr1[i]==0 && arr2[i]!=0) || (arr1[i]!=0 && arr2[i]==0))\\n                return false;\\n        \\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n        \\n        for(int i=0;i<26;i++)\\n            if(arr1[i]!=arr2[i])\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868962,
                "title": "java-easy-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy converting the string into character Array we can easily do this\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  1. if the size of both the string is not equal  then return false\\n  2. store the strings in array\\n  3. check the frequency of occurrence \\n  4. sorting the array\\n  5. if both are equals return true\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(N), e.g. $$O(n)$$ -->\\n  T->  O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  S-> O(1)\\n# Code\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n\\n      //if the size of the strings return false\\n\\n      if(word1.length()!=word2.length()) return false;\\n\\n      //creating array for storing char of strings\\n\\n      int []w1=new int[26];\\n      int []w2=new int[26];\\n\\n      // storing the integer value of all characters of string\\n\\n      for(char c : word1.toCharArray())\\n       { w1[c-\\'a\\']++;\\n       }\\n      for(char c: word2.toCharArray())\\n      {   w2[c-\\'a\\']++;\\n      }\\n\\n      //Now we are checking the frequency of characters in strings \\n\\n      for(int i=0;i<26;i++){\\n        if((w1[i]==0 && w2[i]!=0)||(w1[i]!=0 && w2[i]==0)){\\n          return false;\\n        }\\n      }\\n\\n       Arrays.sort(w1);\\n       Arrays.sort(w2);  \\n      \\n    // If both the array are equal return true\\n      \\n      return Arrays.equals(w1,w2);\\n}\\n}\\n// PLESE UPVOAT IF YOU LIKE IT :]\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n\\n      //if the size of the strings return false\\n\\n      if(word1.length()!=word2.length()) return false;\\n\\n      //creating array for storing char of strings\\n\\n      int []w1=new int[26];\\n      int []w2=new int[26];\\n\\n      // storing the integer value of all characters of string\\n\\n      for(char c : word1.toCharArray())\\n       { w1[c-\\'a\\']++;\\n       }\\n      for(char c: word2.toCharArray())\\n      {   w2[c-\\'a\\']++;\\n      }\\n\\n      //Now we are checking the frequency of characters in strings \\n\\n      for(int i=0;i<26;i++){\\n        if((w1[i]==0 && w2[i]!=0)||(w1[i]!=0 && w2[i]==0)){\\n          return false;\\n        }\\n      }\\n\\n       Arrays.sort(w1);\\n       Arrays.sort(w2);  \\n      \\n    // If both the array are equal return true\\n      \\n      return Arrays.equals(w1,w2);\\n}\\n}\\n// PLESE UPVOAT IF YOU LIKE IT :]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868881,
                "title": "easiest-method-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust need to check both strings must have same elements and the frequencies of those must be same as frequency in other word. It need not be the same element frequency but what matters the numbers.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust need to check both strings must have same elements and the frequencies of those must be same as frequency in other word. It need not be the same element frequency but what matters the numbers.\\nExample:\\nword1=\"aaabbc\"\\nword2=\"cccbba\"\\nword1_______word2\\na->3________a->1\\nb->2________b->2\\nc->1________c->3\\nword1_______word2\\n{a,b,c}_________{a,b,c}\\n{3,2,1}________{1,2,3}->{3,2,1}\\nsince the elements are same and frequency numbers are same return true else false.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(NLogN)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        map<int, int> arr1, arr2;\\n        set<char> w1,w2;\\n        if(word1.size()!=word2.size()){\\n            return false;\\n        }\\n        for(auto x:word1){\\n            arr1[x]++;\\n            w1.insert(x);\\n        }\\n        for(auto x:word2){\\n            arr2[x]++;\\n            w2.insert(x);\\n        }\\n        vector<int> a1,a2;\\n        for(auto x:arr1){\\n            a1.push_back(x.second);\\n        }\\n        for(auto x:arr2){\\n            a2.push_back(x.second);\\n        }\\n        sort(a2.begin(), a2.end());\\n        sort(a1.begin(), a1.end());\\n        if(a1==a2 and w1==w2){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        map<int, int> arr1, arr2;\\n        set<char> w1,w2;\\n        if(word1.size()!=word2.size()){\\n            return false;\\n        }\\n        for(auto x:word1){\\n            arr1[x]++;\\n            w1.insert(x);\\n        }\\n        for(auto x:word2){\\n            arr2[x]++;\\n            w2.insert(x);\\n        }\\n        vector<int> a1,a2;\\n        for(auto x:arr1){\\n            a1.push_back(x.second);\\n        }\\n        for(auto x:arr2){\\n            a2.push_back(x.second);\\n        }\\n        sort(a2.begin(), a2.end());\\n        sort(a1.begin(), a1.end());\\n        if(a1==a2 and w1==w2){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868829,
                "title": "c-using-unordered-map",
                "content": "The main idea behind the solution is that , \\n1. The lengths of both the strings need to be same.\\n2. Both the strings should contain same no.of distinct characters for exampe \"cabbba\" , \"abbccc\" here the no.of distinct characters are 3 ( a,b,c) and \\n3. Also the distinct characters need to be same --> string1(a,bc) and string2(a,b,c).\\n4. The frequencies of the characters need to be same --> string1(1,2,3) and string2(1,2,3)\\n\\nUpvote if you find it helpfull.\\n\\n\\tbool closeStrings(string word1, string word2) {\\n        \\n        if(word1.size() != word2.size()) // the length of words need to be same\\n\\t\\t\\treturn false;\\n        unordered_map<char,int> ump1, ump2, check;\\n        \\n        for(char ch:word1) ump1[ch]++;  // getting the frequecies of each in character in word1\\n        for(char ch: word2) ump2[ch]++; // getting the frequecies of each in character in word2\\n        \\n        if(ump1.size() != ump2.size()) return false; // both strings should contain same no.of distinct words\\n        unordered_map<int,int> num; // to match the frequencies of characters in both the strings\\n        for(auto ele: ump1) \\n        {\\n            check[ele.first]++;\\n            num[ele.second]++;\\n        }\\n        for(auto ele : ump2)\\n        {\\n            check[ele.first]--;\\n            if(check[ele.first]==0) check.erase(ele.first);\\n            num[ele.second]--;\\n            if(num[ele.second] == 0) num.erase(ele.second);\\n        }\\n       \\n        return num.size()==0 && check.size()==0;\\n        \\n    }",
                "solutionTags": [],
                "code": "The main idea behind the solution is that , \\n1. The lengths of both the strings need to be same.\\n2. Both the strings should contain same no.of distinct characters for exampe \"cabbba\" , \"abbccc\" here the no.of distinct characters are 3 ( a,b,c) and \\n3. Also the distinct characters need to be same --> string1(a,bc) and string2(a,b,c).\\n4. The frequencies of the characters need to be same --> string1(1,2,3) and string2(1,2,3)\\n\\nUpvote if you find it helpfull.\\n\\n\\tbool closeStrings(string word1, string word2) {\\n        \\n        if(word1.size() != word2.size()) // the length of words need to be same\\n\\t\\t\\treturn false;\\n        unordered_map<char,int> ump1, ump2, check;\\n        \\n        for(char ch:word1) ump1[ch]++;  // getting the frequecies of each in character in word1\\n        for(char ch: word2) ump2[ch]++; // getting the frequecies of each in character in word2\\n        \\n        if(ump1.size() != ump2.size()) return false; // both strings should contain same no.of distinct words\\n        unordered_map<int,int> num; // to match the frequencies of characters in both the strings\\n        for(auto ele: ump1) \\n        {\\n            check[ele.first]++;\\n            num[ele.second]++;\\n        }\\n        for(auto ele : ump2)\\n        {\\n            check[ele.first]--;\\n            if(check[ele.first]==0) check.erase(ele.first);\\n            num[ele.second]--;\\n            if(num[ele.second] == 0) num.erase(ele.second);\\n        }\\n       \\n        return num.size()==0 && check.size()==0;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2868826,
                "title": "c-easy-to-understand-intutive-o-n-video-solution",
                "content": "**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/aaUSD0fJWA0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n\\n//for storing frequency  and presence of character.\\n        vector<int>freqW1(26,0),freqW2(26,0);\\n\\u2003\\u2003vector<int>IspresentW1(26,0),IspresentW2(26,0);\\n\\n        for(char c:word1){\\n              freqW1[c-\\'a\\']++;\\n              IspresentW1[c-\\'a\\'] = 1;\\n        }\\n\\n\\n        for(char c:word2)\\n        {\\n            freqW2[c-\\'a\\']++;\\n            IspresentW2[c-\\'a\\'] = 1;\\n        }\\n\\n\\n        sort(freqW1.begin(),freqW1.end());\\n        sort(freqW2.begin(),freqW2.end());\\n\\n//         if both condition statify return true.\\n        return freqW1==freqW2 && IspresentW1==IspresentW2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n\\n//for storing frequency  and presence of character.\\n        vector<int>freqW1(26,0),freqW2(26,0);\\n\\u2003\\u2003vector<int>IspresentW1(26,0),IspresentW2(26,0);\\n\\n        for(char c:word1){\\n              freqW1[c-\\'a\\']++;\\n              IspresentW1[c-\\'a\\'] = 1;\\n        }\\n\\n\\n        for(char c:word2)\\n        {\\n            freqW2[c-\\'a\\']++;\\n            IspresentW2[c-\\'a\\'] = 1;\\n        }\\n\\n\\n        sort(freqW1.begin(),freqW1.end());\\n        sort(freqW2.begin(),freqW2.end());\\n\\n//         if both condition statify return true.\\n        return freqW1==freqW2 && IspresentW1==IspresentW2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868744,
                "title": "c-solution-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size()!=word2.size())\\n            return false;\\n        unordered_map<char,int> temp1;\\n        unordered_map<int,string> w1;\\n        for(int i=0;i<word1.length();i++)\\n            temp1[word1[i]]++;\\n        for(auto it : temp1){\\n            w1[it.second].push_back(it.first);\\n        }\\n        unordered_map<char,int> temp2;\\n        unordered_map<int,string> w2;\\n        for(int i=0;i<word2.length();i++)\\n            temp2[word2[i]]++;\\n        for(auto it : temp2){\\n            w2[it.second].push_back(it.first);\\n        }\\n        if(w1.size() != w2.size())\\n            return false;\\n        string m,n;\\n        for(auto it : temp1){\\n            // cout << it.first;\\n            m += it.first;\\n        }\\n        for(auto it : temp2){\\n            n += it.first;\\n        }\\n        sort(m.begin(),m.end());\\n        sort(n.begin(),n.end());\\n        // cout << m << n << endl;\\n        if(m!=n)\\n        return false;\\n        for(auto it : w1){\\n            if(w2[it.first].size()!=it.second.size())\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size()!=word2.size())\\n            return false;\\n        unordered_map<char,int> temp1;\\n        unordered_map<int,string> w1;\\n        for(int i=0;i<word1.length();i++)\\n            temp1[word1[i]]++;\\n        for(auto it : temp1){\\n            w1[it.second].push_back(it.first);\\n        }\\n        unordered_map<char,int> temp2;\\n        unordered_map<int,string> w2;\\n        for(int i=0;i<word2.length();i++)\\n            temp2[word2[i]]++;\\n        for(auto it : temp2){\\n            w2[it.second].push_back(it.first);\\n        }\\n        if(w1.size() != w2.size())\\n            return false;\\n        string m,n;\\n        for(auto it : temp1){\\n            // cout << it.first;\\n            m += it.first;\\n        }\\n        for(auto it : temp2){\\n            n += it.first;\\n        }\\n        sort(m.begin(),m.end());\\n        sort(n.begin(),n.end());\\n        // cout << m << n << endl;\\n        if(m!=n)\\n        return false;\\n        for(auto it : w1){\\n            if(w2[it.first].size()!=it.second.size())\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2868664,
                "title": "java-solution-beats-100-i-used-xor-too",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean closeStrings(String w1, String w2) {\\n        int l1, l2;\\n        if ((l1 = w1.length()) != (l2 = w2.length()))\\n            return false;\\n        byte[] b1 = w1.getBytes(), b2 = w2.getBytes();\\n        int[] c1 = new int[26], c2 = new int[26];\\n        method(b1, c1, l1);\\n        method(b2, c2, l2);\\n        for (int i = 0; i < 26; i++)\\n            if (c1[i] > 0 ^ c2[i] > 0)\\n                return false;\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n        return Arrays.equals(c1, c2);\\n    }\\n\\n    void method(byte[] b, int[] c, int l) {\\n        while (l-- > 0)\\n            c[b[l] - 97]++;\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String w1, String w2) {\\n        int l1, l2;\\n        if ((l1 = w1.length()) != (l2 = w2.length()))\\n            return false;\\n        byte[] b1 = w1.getBytes(), b2 = w2.getBytes();\\n        int[] c1 = new int[26], c2 = new int[26];\\n        method(b1, c1, l1);\\n        method(b2, c2, l2);\\n        for (int i = 0; i < 26; i++)\\n            if (c1[i] > 0 ^ c2[i] > 0)\\n                return false;\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n        return Arrays.equals(c1, c2);\\n    }\\n\\n    void method(byte[] b, int[] c, int l) {\\n        while (l-- > 0)\\n            c[b[l] - 97]++;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868518,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "Solution:\\n```\\nclass Solution {\\n    func closeStrings(_ word1: String, _ word2: String) -> Bool {\\n        \\n        if word1.count != word2.count {return false}\\n        \\n        let w1 = Array(word1), w2 = Array(word2)\\n        var dic1 = [Character:Int](), dic2 = [Character:Int]()\\n        \\n        for i in 0..<word1.count{\\n            dic1[w1[i], default:0] += 1\\n            dic2[w2[i], default:0] += 1\\n        }\\n        \\n        if dic1.keys != dic2.keys \\n        || dic1.values.sorted() != dic2.values.sorted(){\\n            return false\\n        }\\n        \\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func closeStrings(_ word1: String, _ word2: String) -> Bool {\\n        \\n        if word1.count != word2.count {return false}\\n        \\n        let w1 = Array(word1), w2 = Array(word2)\\n        var dic1 = [Character:Int](), dic2 = [Character:Int]()\\n        \\n        for i in 0..<word1.count{\\n            dic1[w1[i], default:0] += 1\\n            dic2[w2[i], default:0] += 1\\n        }\\n        \\n        if dic1.keys != dic2.keys \\n        || dic1.values.sorted() != dic2.values.sorted(){\\n            return false\\n        }\\n        \\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868508,
                "title": "concise-solution-in-java-easy-logic",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int arr[] = new int[26], brr[] = new int[26];\\n        HashSet<Character> hs = new HashSet<>();\\n        for(char ch:word1.toCharArray()) { \\n            arr[ch-\\'a\\']++; \\n            hs.add(ch);\\n        }\\n        for(char ch:word2.toCharArray()) {\\n            brr[ch-\\'a\\']++;\\n            hs.remove(ch);\\n        }\\n        Arrays.sort(arr); Arrays.sort(brr);\\n        return Arrays.toString(arr).equals(Arrays.toString(brr)) && hs.size()==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int arr[] = new int[26], brr[] = new int[26];\\n        HashSet<Character> hs = new HashSet<>();\\n        for(char ch:word1.toCharArray()) { \\n            arr[ch-\\'a\\']++; \\n            hs.add(ch);\\n        }\\n        for(char ch:word2.toCharArray()) {\\n            brr[ch-\\'a\\']++;\\n            hs.remove(ch);\\n        }\\n        Arrays.sort(arr); Arrays.sort(brr);\\n        return Arrays.toString(arr).equals(Arrays.toString(brr)) && hs.size()==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868504,
                "title": "java-easy-solution-o-nlogn",
                "content": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length()!=word2.length()){\\n            return false;\\n        }\\n        if(word1.length()==1){\\n                return word1.equals(word2);\\n        }\\n       char w1[]=word1.toCharArray();\\n       char w2[]=word2.toCharArray();\\n        Arrays.sort(w1);\\n        Arrays.sort(w2);\\n        int count=1;\\n        ArrayList<Integer> list1=new ArrayList<>();\\n        ArrayList<Integer> list2=new ArrayList<>();\\n        for(int i=0;i<w1.length-1;i++){\\n            if(!word2.contains(\"\"+w1[i])){\\n                return false;\\n            }\\n            if(w1[i]==w1[i+1]){\\n                count++;\\n            }\\n            else{\\n                list1.add(count);\\n                count=1;\\n            }\\n        }\\n        list1.add(count);\\n        count=1;\\n        \\n        for(int i=0;i<w2.length-1;i++){\\n            if(w2[i]==w2[i+1]){\\n                count++;\\n            }\\n            else{\\n                list2.add(count);\\n                count=1;\\n            }\\n        }\\n        list2.add(count);\\n        \\n        for(int i=0;i<list1.size();i++){\\n            if(list2.contains(list1.get(i))){\\n                list2.remove(list1.get(i));\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length()!=word2.length()){\\n            return false;\\n        }\\n        if(word1.length()==1){\\n                return word1.equals(word2);\\n        }\\n       char w1[]=word1.toCharArray();\\n       char w2[]=word2.toCharArray();\\n        Arrays.sort(w1);\\n        Arrays.sort(w2);\\n        int count=1;\\n        ArrayList<Integer> list1=new ArrayList<>();\\n        ArrayList<Integer> list2=new ArrayList<>();\\n        for(int i=0;i<w1.length-1;i++){\\n            if(!word2.contains(\"\"+w1[i])){\\n                return false;\\n            }\\n            if(w1[i]==w1[i+1]){\\n                count++;\\n            }\\n            else{\\n                list1.add(count);\\n                count=1;\\n            }\\n        }\\n        list1.add(count);\\n        count=1;\\n        \\n        for(int i=0;i<w2.length-1;i++){\\n            if(w2[i]==w2[i+1]){\\n                count++;\\n            }\\n            else{\\n                list2.add(count);\\n                count=1;\\n            }\\n        }\\n        list2.add(count);\\n        \\n        for(int i=0;i<list1.size();i++){\\n            if(list2.contains(list1.get(i))){\\n                list2.remove(list1.get(i));\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868395,
                "title": "python-2-liner-counter-counter-values-and-set-counter-keys",
                "content": "https://leetcode.com/submissions/detail/853191858/\\n```\\nRuntime: 183 ms, faster than 86.40% of Python3 online submissions for Determine if Two Strings Are Close.\\nMemory Usage: 15.3 MB, less than 43.60% of Python3 online submissions for Determine if Two Strings Are Close.\\n```\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        c1, c2 = Counter(word1), Counter(word2)\\n        return Counter(c1.values())==Counter(c2.values()) and set(c1.keys())==set(c2.keys())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nRuntime: 183 ms, faster than 86.40% of Python3 online submissions for Determine if Two Strings Are Close.\\nMemory Usage: 15.3 MB, less than 43.60% of Python3 online submissions for Determine if Two Strings Are Close.\\n```\n```\\nfrom collections import Counter\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        c1, c2 = Counter(word1), Counter(word2)\\n        return Counter(c1.values())==Counter(c2.values()) and set(c1.keys())==set(c2.keys())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868304,
                "title": "80-javascript-really-easy-to-understand-solution",
                "content": "Visit my youtube! Thank you!\\nhttps://www.youtube.com/channel/UCkhEaNAOO8tig5NHqqxXIeg\\n\\n```\\nvar closeStrings = function(word1, word2) {\\n    if(word1.length != word2.length) return false;\\n    \\n    let oneMap = {}\\n    let twoMap = {}\\n    \\n    for(let i= 0; i<word1.length;i++){\\n        oneMap[word1[i]] = oneMap[word1[i]] ? oneMap[word1[i]]+1 :1;\\n        twoMap[word2[i]] = twoMap[word2[i]] ? twoMap[word2[i]]+1 :1;\\n    }\\n    let arr =Object.values(twoMap);\\n    for(let i in oneMap){\\n        if(!twoMap[i]) return false;\\n        let index = arr.indexOf(oneMap[i])\\n        if(index ==-1) return false;\\n        arr.splice(index,1)\\n    }\\n\\n    return arr.length == 0\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar closeStrings = function(word1, word2) {\\n    if(word1.length != word2.length) return false;\\n    \\n    let oneMap = {}\\n    let twoMap = {}\\n    \\n    for(let i= 0; i<word1.length;i++){\\n        oneMap[word1[i]] = oneMap[word1[i]] ? oneMap[word1[i]]+1 :1;\\n        twoMap[word2[i]] = twoMap[word2[i]] ? twoMap[word2[i]]+1 :1;\\n    }\\n    let arr =Object.values(twoMap);\\n    for(let i in oneMap){\\n        if(!twoMap[i]) return false;\\n        let index = arr.indexOf(oneMap[i])\\n        if(index ==-1) return false;\\n        arr.splice(index,1)\\n    }\\n\\n    return arr.length == 0\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868132,
                "title": "go-easy",
                "content": "Runtime: 55 ms, faster than 50.00% of Go online submissions for Determine if Two Strings Are Close.\\nMemory Usage: 7 MB, less than 100.00% of Go online submissions for Determine if Two Strings Are Close.\\n\\n```\\nfunc closeStrings(word1 string, word2 string) bool {\\n    if len(word1) != len(word2) {\\n        return false\\n    }\\n    countW1, countW2 := make([]int,26),make([]int,26) \\n    existW1, existW2 := [26]bool{},[26]bool{}\\n    \\n    for i := range word1 {\\n        countW1[word1[i] - \\'a\\']++\\n        countW2[word2[i] - \\'a\\']++\\n        existW1[word1[i] - \\'a\\'] = true\\n        existW2[word2[i] - \\'a\\'] = true\\n    }\\n    \\n    sort.Ints(countW1)\\n    sort.Ints(countW2)\\n    w1 := [26]int{}\\n    w2 := [26]int{}\\n    copy(w1[:],countW1)\\n    copy(w2[:],countW2)\\n    return w1 == w2 && existW1 == existW2    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc closeStrings(word1 string, word2 string) bool {\\n    if len(word1) != len(word2) {\\n        return false\\n    }\\n    countW1, countW2 := make([]int,26),make([]int,26) \\n    existW1, existW2 := [26]bool{},[26]bool{}\\n    \\n    for i := range word1 {\\n        countW1[word1[i] - \\'a\\']++\\n        countW2[word2[i] - \\'a\\']++\\n        existW1[word1[i] - \\'a\\'] = true\\n        existW2[word2[i] - \\'a\\'] = true\\n    }\\n    \\n    sort.Ints(countW1)\\n    sort.Ints(countW2)\\n    w1 := [26]int{}\\n    w2 := [26]int{}\\n    copy(w1[:],countW1)\\n    copy(w2[:],countW2)\\n    return w1 == w2 && existW1 == existW2    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868110,
                "title": "o-n-solution",
                "content": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        count1 = Counter(word1)\\n        count2 = Counter(word2)\\n\\n        return set(count1.keys()) == set(count2.keys()) and Counter(count1.values()) == Counter(count2.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        count1 = Counter(word1)\\n        count2 = Counter(word2)\\n\\n        return set(count1.keys()) == set(count2.keys()) and Counter(count1.values()) == Counter(count2.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284333,
                "title": "need-only-map-for-optimization-as-well-as-for-easy-understanding",
                "content": "```\\nclass Solution {\\n\\tpublic boolean closeStrings(String word1, String word2) {\\n\\t\\tHashMap<Character, Integer> map1 = new HashMap<>();\\n\\t\\tfor (int i = 0; i < word1.length(); i++) {\\n\\t\\t\\tmap1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0) + 1);\\n\\t\\t}\\n\\n\\t\\tHashMap<Character, Integer> map2 = new HashMap<>();\\n\\t\\tfor (int i = 0; i < word2.length(); i++) {\\n\\t\\t\\tmap2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0) + 1);\\n\\t\\t}\\n\\t\\tif (!map1.keySet().equals(map2.keySet())) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tArrayList<Integer> list1 = new ArrayList<>();\\n\\t\\tlist1.addAll(map1.values());\\n\\n\\t\\tArrayList<Integer> list2 = new ArrayList<>();\\n\\t\\tlist2.addAll(map2.values());\\n\\n\\t\\tCollections.sort(list1);\\n\\t\\tCollections.sort(list2);\\n\\n\\n\\t\\tif (list1.size() != list2.size()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint i = 0;\\n\\t\\tint j = 0;\\n\\t\\twhile (i < list1.size() && j < list2.size()) {\\n\\t\\t\\tif (list1.get(i) !=list2.get(j)) {\\n                // System.out.println(list1.get(i)+\" \"+list2.get(i));\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic boolean closeStrings(String word1, String word2) {\\n\\t\\tHashMap<Character, Integer> map1 = new HashMap<>();\\n\\t\\tfor (int i = 0; i < word1.length(); i++) {\\n\\t\\t\\tmap1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0) + 1);\\n\\t\\t}\\n\\n\\t\\tHashMap<Character, Integer> map2 = new HashMap<>();\\n\\t\\tfor (int i = 0; i < word2.length(); i++) {\\n\\t\\t\\tmap2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0) + 1);\\n\\t\\t}\\n\\t\\tif (!map1.keySet().equals(map2.keySet())) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tArrayList<Integer> list1 = new ArrayList<>();\\n\\t\\tlist1.addAll(map1.values());\\n\\n\\t\\tArrayList<Integer> list2 = new ArrayList<>();\\n\\t\\tlist2.addAll(map2.values());\\n\\n\\t\\tCollections.sort(list1);\\n\\t\\tCollections.sort(list2);\\n\\n\\n\\t\\tif (list1.size() != list2.size()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint i = 0;\\n\\t\\tint j = 0;\\n\\t\\twhile (i < list1.size() && j < list2.size()) {\\n\\t\\t\\tif (list1.get(i) !=list2.get(j)) {\\n                // System.out.println(list1.get(i)+\" \"+list2.get(i));\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479101,
                "title": "c-easy-to-understand",
                "content": "```\\n    bool closeStrings(string word1, string word2) {\\n        vector<int>a(26),b(26);\\n        for(char c : word1)\\n            a[c-\\'a\\']++;\\n        for(char c : word2)\\n            b[c-\\'a\\']++;\\n        \\n        set<char> s1(word1.begin(),word1.end()), s2(word2.begin(),word2.end());\\n        if(s1!=s2) return false;\\n        \\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        \\n        if(a!=b) return false;\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool closeStrings(string word1, string word2) {\\n        vector<int>a(26),b(26);\\n        for(char c : word1)\\n            a[c-\\'a\\']++;\\n        for(char c : word2)\\n            b[c-\\'a\\']++;\\n        \\n        set<char> s1(word1.begin(),word1.end()), s2(word2.begin(),word2.end());\\n        if(s1!=s2) return false;\\n        \\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        \\n        if(a!=b) return false;\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1401259,
                "title": "easily-understandable-java-solution",
                "content": "\\n   \\n         class Solution {\\n        public boolean closeStrings(String word1, String word2) {    \\n\\t\\t\\n        if(word1.length()!=word2.length())return false;   \\n\\t\\t\\n        //initialize two arrays with 26 spots ,each index representing each letter of the alphabet.\\n        // Default: value present on each index is 0 ,representing the occurence of each letter\\n\\t\\t\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        \\n        //we will loop throgh each letter int word1 and add one to it\\'s corresponding index.\\n        //If the letter is \\'c\\', then char will be 99-97=2,and we add 1 to arr[2]\\n\\t\\t\\n        for(Character ch:word1.toCharArray())a[ch-\\'a\\']++;\\n        for(Character ch:word2.toCharArray())b[ch-\\'a\\']++;\\n        \\n        /**here we will loop  through each index in both arrays and if one array has no occurences of a \\n        letter and the other array does have this letter, then we can return false because there would \\n        be no way to perform the given operation and get the correct result.\\n        word1=\\'ab\\' , word2=\\'ac\\', there is no way for these two strings to become \\'close\\' since operation 2 two \\n        only swaps existing letters .We can never turn \\'ab\\' into \\'ac\\'**/\\n        \\n        for(int i=0;i<26;i++)\\n        if((a[i]>=1 && b[i]==0) || (a[i]==0 && b[i]>=1))return false;\\n            \\n          \\n        //If we passed above ,then now we just need to check the relative occurences of each letter.\\n        //We sort our letter\\n\\t\\t\\n            Arrays.sort(a);\\n            Arrays.sort(b);\\n        \\n        //then we loop through each index and if the relative counts are not equal then the words are not \\'close\\'.\\n\\t\\t\\n        for(int i=0;i<26;i++) if(a[i]!=b[i])return false;\\n        \\n        //if we pass all our tests above we return true, the words are \\'close\\'\\n\\t\\t\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean closeStrings(String word1, String word2) {    \\n\\t\\t\\n        if(word1.length()!=word2.length())return false;   \\n\\t\\t\\n        //initialize two arrays with 26 spots ,each index representing each letter of the alphabet.\\n        // Default: value present on each index is 0 ,representing the occurence of each letter\\n\\t\\t\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        \\n        //we will loop throgh each letter int word1 and add one to it\\'s corresponding index.\\n        //If the letter is \\'c\\', then char will be 99-97=2,and we add 1 to arr[2]\\n\\t\\t\\n        for(Character ch:word1.toCharArray())a[ch-\\'a\\']++;\\n        for(Character ch:word2.toCharArray())b[ch-\\'a\\']++;\\n        \\n        /**here we will loop  through each index in both arrays and if one array has no occurences of a \\n        letter and the other array does have this letter, then we can return false because there would \\n        be no way to perform the given operation and get the correct result.\\n        word1=\\'ab\\' , word2=\\'ac\\', there is no way for these two strings to become \\'close\\' since operation 2 two \\n        only swaps existing letters .We can never turn \\'ab\\' into \\'ac\\'**/\\n        \\n        for(int i=0;i<26;i++)\\n        if((a[i]>=1 && b[i]==0) || (a[i]==0 && b[i]>=1))return false;\\n            \\n          \\n        //If we passed above ,then now we just need to check the relative occurences of each letter.\\n        //We sort our letter\\n\\t\\t\\n            Arrays.sort(a);\\n            Arrays.sort(b);\\n        \\n        //then we loop through each index and if the relative counts are not equal then the words are not \\'close\\'.\\n\\t\\t\\n        for(int i=0;i<26;i++) if(a[i]!=b[i])return false;\\n        \\n        //if we pass all our tests above we return true, the words are \\'close\\'\\n\\t\\t\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1250401,
                "title": "easy-c-solution-commented-fully-and-clearly",
                "content": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        \\n        //we dont care about the word2 after rearranging,since there can be many ways ,many operations to get word2 from word1\\n        //all we care about is frequencies of characters\\n        //look at operation 1\\n        //if two characters are swapped then their freq are not gonna change anyway\\n        //look at the operation 2\\n        //if two char are replaced in the entire string then there frequencies are gonna interchange right ? :) \\n        //from the above we can conclude that when we arrange the frequencies of all char in word1 and word2 in sorted order they must be same\\n        //and also no new character should be introduced in the word2\\n        //let\\'s code\\n        \\n        if(word1.length()!=word2.length())\\n        {\\n            //impossible to attain\\n            return false;\\n        }\\n        vector<int> freq1(26,0); //char freq of word1\\n        vector<int> freq2(26,0); //char freq of word2\\n        \\n        for(int i=0;i<word1.length();++i)\\n        {\\n            freq1[word1[i]-\\'a\\']++; \\n        }\\n        \\n        for(int i=0;i<word2.length();++i)\\n        {\\n            //if it does not exists in word1 return false\\n            if(freq1[word2[i]-\\'a\\']==0)\\n                return false;\\n            freq2[word2[i]-\\'a\\']++; \\n        }\\n        \\n        sort(freq1.begin(),freq1.end());\\n        sort(freq2.begin(),freq2.end());\\n        \\n        return freq1==freq2;\\n        \\n    }\\n};\\n```\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        \\n        //we dont care about the word2 after rearranging,since there can be many ways ,many operations to get word2 from word1\\n        //all we care about is frequencies of characters\\n        //look at operation 1\\n        //if two characters are swapped then their freq are not gonna change anyway\\n        //look at the operation 2\\n        //if two char are replaced in the entire string then there frequencies are gonna interchange right ? :) \\n        //from the above we can conclude that when we arrange the frequencies of all char in word1 and word2 in sorted order they must be same\\n        //and also no new character should be introduced in the word2\\n        //let\\'s code\\n        \\n        if(word1.length()!=word2.length())\\n        {\\n            //impossible to attain\\n            return false;\\n        }\\n        vector<int> freq1(26,0); //char freq of word1\\n        vector<int> freq2(26,0); //char freq of word2\\n        \\n        for(int i=0;i<word1.length();++i)\\n        {\\n            freq1[word1[i]-\\'a\\']++; \\n        }\\n        \\n        for(int i=0;i<word2.length();++i)\\n        {\\n            //if it does not exists in word1 return false\\n            if(freq1[word2[i]-\\'a\\']==0)\\n                return false;\\n            freq2[word2[i]-\\'a\\']++; \\n        }\\n        \\n        sort(freq1.begin(),freq1.end());\\n        sort(freq2.begin(),freq2.end());\\n        \\n        return freq1==freq2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029713,
                "title": "java-determine-if-two-strings-are-close-full-explanation",
                "content": "Key Takeaways from Question\\n* Rule 1 allows reordering of string - so order does not matter\\n* Rule 2 allows changing the frequency of a character to the frequency of another character in the string\\n* No rule allows changing the length of the string\\n* No rule allows changing the set of characters in the string\\n\\nThe fully annotated code below shows how these takeaways were applied to create a solution using  frequency arrays.\\nOverall solution is O(1) space and O(N) time.\\n\\nIf this was useful please remember to upvote.\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        // Not possible to change length of array so check same length\\n        // O(1) time\\n        if (word1.length() != word2.length())\\n            return false;\\n        \\n        // Order of characters doesn\\'t matter because rule 1 allows reordering\\n        // so don\\'t need to preserve order.\\n        // Only lowercase English characters - so can track at character level\\n        // Can store character frequency in fixed size array\\n        // O(26) = O(1) space O(N) time\\n        int[] cc1 = new int[26];\\n        int[] cc2 = new int[26];\\n        for (int i=0; i<word1.length(); i++) {\\n            cc1[word1.charAt(i)-\\'a\\']++;\\n            cc2[word2.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        // Same set of characters must be in both strings as no rule introduces\\n        // new characters into a string,\\n        // rule two only allows changing frequency of characters.\\n        // So check same characters are in each string\\n        // O(26) = O(1) time\\n        for (int i=0; i<26; i++)\\n            if ((cc1[i]==0) != (cc2[i]==0))\\n                return false;\\n        \\n        // We can swap characters to change frequencies of a character\\n        // to the frequency of another character.\\n        // But we can\\'tchange the mix of frequencies.\\n        // So we can sort and then ensure that frequencies match.\\n        // O(26 log 26) = O(1) time to sort\\n        // O(26) = O(1) time to match frequencies\\n        Arrays.sort(cc1);\\n        Arrays.sort(cc2);\\n        for (int i=0; i<26; i++)\\n            if (cc1[i] != cc2[i])\\n                return false;\\n        \\n        // Every check passed so they are close\\n        // Overall Time Complexity O(N) and Space Complexity O(1)\\n        return true;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        // Not possible to change length of array so check same length\\n        // O(1) time\\n        if (word1.length() != word2.length())\\n            return false;\\n        \\n        // Order of characters doesn\\'t matter because rule 1 allows reordering\\n        // so don\\'t need to preserve order.\\n        // Only lowercase English characters - so can track at character level\\n        // Can store character frequency in fixed size array\\n        // O(26) = O(1) space O(N) time\\n        int[] cc1 = new int[26];\\n        int[] cc2 = new int[26];\\n        for (int i=0; i<word1.length(); i++) {\\n            cc1[word1.charAt(i)-\\'a\\']++;\\n            cc2[word2.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        // Same set of characters must be in both strings as no rule introduces\\n        // new characters into a string,\\n        // rule two only allows changing frequency of characters.\\n        // So check same characters are in each string\\n        // O(26) = O(1) time\\n        for (int i=0; i<26; i++)\\n            if ((cc1[i]==0) != (cc2[i]==0))\\n                return false;\\n        \\n        // We can swap characters to change frequencies of a character\\n        // to the frequency of another character.\\n        // But we can\\'tchange the mix of frequencies.\\n        // So we can sort and then ensure that frequencies match.\\n        // O(26 log 26) = O(1) time to sort\\n        // O(26) = O(1) time to match frequencies\\n        Arrays.sort(cc1);\\n        Arrays.sort(cc2);\\n        for (int i=0; i<26; i++)\\n            if (cc1[i] != cc2[i])\\n                return false;\\n        \\n        // Every check passed so they are close\\n        // Overall Time Complexity O(N) and Space Complexity O(1)\\n        return true;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029294,
                "title": "swift-solution-beats-100-runtime-memory",
                "content": "Swift solution beats 100% runtime & memory\\n```\\nclass Solution {\\n    func helper1(_ a: String) -> [Int] {\\n        return a.reduce(into: [Int](repeating: 0, count: 26), { $0[Int($1.asciiValue ?? 97) - 97] += 1 }).sorted()\\n    }\\n    func helper2(_ a: String) -> [Bool] {\\n        return a.reduce(into: [Bool](repeating: false, count: 26), { $0[Int($1.asciiValue ?? 97) - 97] = true })\\n    }\\n    func closeStrings(_ word1: String, _ word2: String) -> Bool {\\n        return helper1(word1) == helper1(word2) && helper2(word1) == helper2(word2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func helper1(_ a: String) -> [Int] {\\n        return a.reduce(into: [Int](repeating: 0, count: 26), { $0[Int($1.asciiValue ?? 97) - 97] += 1 }).sorted()\\n    }\\n    func helper2(_ a: String) -> [Bool] {\\n        return a.reduce(into: [Bool](repeating: false, count: 26), { $0[Int($1.asciiValue ?? 97) - 97] = true })\\n    }\\n    func closeStrings(_ word1: String, _ word2: String) -> Bool {\\n        return helper1(word1) == helper1(word2) && helper2(word1) == helper2(word2)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029289,
                "title": "javascript-simple-solution",
                "content": "```javascript\\nvar closeStrings = function(word1, word2) {\\n    if(word1.length !== word2.length) return false;\\n    \\n    const ws1 = [...new Set(word1)].sort().join(\\'\\')\\n    const ws2 = [...new Set(word2)].sort().join(\\'\\')\\n    if(ws1 !== ws2) return false;\\n    \\n    const freq1 = Array(26).fill(0);\\n    const freq2 = Array(26).fill(0);\\n    \\n    for(let i = 0; i < word1.length; i++) {\\n        const idx1 = word1[i].charCodeAt() - \\'a\\'.charCodeAt();\\n        const idx2 = word2[i].charCodeAt() - \\'a\\'.charCodeAt();\\n        freq1[idx1]++;\\n        freq2[idx2]++;\\n    }\\n    const str1 = freq1.filter(x => x).sort().join()\\n    const str2 = freq2.filter(x => x).sort().join()\\n    return str1 === str2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar closeStrings = function(word1, word2) {\\n    if(word1.length !== word2.length) return false;\\n    \\n    const ws1 = [...new Set(word1)].sort().join(\\'\\')\\n    const ws2 = [...new Set(word2)].sort().join(\\'\\')\\n    if(ws1 !== ws2) return false;\\n    \\n    const freq1 = Array(26).fill(0);\\n    const freq2 = Array(26).fill(0);\\n    \\n    for(let i = 0; i < word1.length; i++) {\\n        const idx1 = word1[i].charCodeAt() - \\'a\\'.charCodeAt();\\n        const idx2 = word2[i].charCodeAt() - \\'a\\'.charCodeAt();\\n        freq1[idx1]++;\\n        freq2[idx2]++;\\n    }\\n    const str1 = freq1.filter(x => x).sort().join()\\n    const str2 = freq2.filter(x => x).sort().join()\\n    return str1 === str2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1029179,
                "title": "c-easy-solution-using-sets",
                "content": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        if(m!=n) \\n            return 0;\\n        set<char> s1,s2;\\n        vector<int> freq1(26,0),freq2(26,0);\\n        \\n        for(char c: word1) {\\n            s1.insert(c);\\n            freq1[c-\\'a\\']++;\\n        }\\n        for(char c: word2) {\\n            s2.insert(c);\\n            freq2[c-\\'a\\']++;\\n        }\\n        \\n        sort(begin(freq1),end(freq1));\\n        sort(begin(freq2),end(freq2));\\n        \\n        return s1==s2 && freq1==freq2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        if(m!=n) \\n            return 0;\\n        set<char> s1,s2;\\n        vector<int> freq1(26,0),freq2(26,0);\\n        \\n        for(char c: word1) {\\n            s1.insert(c);\\n            freq1[c-\\'a\\']++;\\n        }\\n        for(char c: word2) {\\n            s2.insert(c);\\n            freq2[c-\\'a\\']++;\\n        }\\n        \\n        sort(begin(freq1),end(freq1));\\n        sort(begin(freq2),end(freq2));\\n        \\n        return s1==s2 && freq1==freq2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944066,
                "title": "java-clean-code-2-implementations",
                "content": "### Method 1\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length() != word2.length()) \\n            return false;\\n        \\n        HashMap<Character, Integer> a = new HashMap<>();\\n        HashMap<Character, Integer> b = new HashMap<>();\\n        \\n        for(Character ch : word1.toCharArray()) a.put(ch, a.getOrDefault(ch,0)+1);\\n        for(Character ch : word2.toCharArray()) b.put(ch, b.getOrDefault(ch,0)+1);\\n        \\n        if(!a.keySet().equals(b.keySet())) return false;\\n        \\n        List<Integer> aValues = new ArrayList<>(a.values());\\n        List<Integer> bValues = new ArrayList<>(b.values());\\n        Collections.sort(aValues);\\n        Collections.sort(bValues);\\n        \\n        return aValues.equals(bValues);\\n    }\\n}\\n```\\n### Method2\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length() != word2.length()) \\n            return false;\\n        \\n        int a[] = new int[26];\\n        int b[] = new int[26];\\n        for(Character ch : word1.toCharArray()) a[ch-\\'a\\']++;\\n        for(Character ch : word2.toCharArray()) b[ch-\\'a\\']++;\\n        \\n        for(int i=0; i<26; i++) \\n            if((a[i]>=1 && b[i] == 0) || (a[i] ==0 && b[i] >= 1)) return false;\\n\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        \\n        for(int i=0; i<26; i++) if(a[i] != b[i]) return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length() != word2.length()) \\n            return false;\\n        \\n        HashMap<Character, Integer> a = new HashMap<>();\\n        HashMap<Character, Integer> b = new HashMap<>();\\n        \\n        for(Character ch : word1.toCharArray()) a.put(ch, a.getOrDefault(ch,0)+1);\\n        for(Character ch : word2.toCharArray()) b.put(ch, b.getOrDefault(ch,0)+1);\\n        \\n        if(!a.keySet().equals(b.keySet())) return false;\\n        \\n        List<Integer> aValues = new ArrayList<>(a.values());\\n        List<Integer> bValues = new ArrayList<>(b.values());\\n        Collections.sort(aValues);\\n        Collections.sort(bValues);\\n        \\n        return aValues.equals(bValues);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length() != word2.length()) \\n            return false;\\n        \\n        int a[] = new int[26];\\n        int b[] = new int[26];\\n        for(Character ch : word1.toCharArray()) a[ch-\\'a\\']++;\\n        for(Character ch : word2.toCharArray()) b[ch-\\'a\\']++;\\n        \\n        for(int i=0; i<26; i++) \\n            if((a[i]>=1 && b[i] == 0) || (a[i] ==0 && b[i] >= 1)) return false;\\n\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        \\n        for(int i=0; i<26; i++) if(a[i] != b[i]) return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936163,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        return sorted(set(word1))==sorted(set(word2)) and sorted(Counter(word1).values())==sorted(Counter(word2).values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        return sorted(set(word1))==sorted(set(word2)) and sorted(Counter(word1).values())==sorted(Counter(word2).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935978,
                "title": "python-o-n-one-line",
                "content": "The first rule tells us that we don\\'t have to worry about the order of the\\ncharacters in the strings.\\n\\nThe second rule tells us that we dont have to worry about which characters have\\na certain count; only that there is a character with that count.\\n\\n```python\\ndef closeStrings(self, a, b):\\n\\treturn set(a) == set(b) and Counter(Counter(a).values()) == Counter(Counter(b).values())\\n```\\n\\nIf `n` is the max length of `a` or `b`, then building and checking equality of\\nthe sets runs in O(n) time. Building the first layer of the counts runs in O(n)\\ntime, and takes O(n) space (If every character in the string is unique).\\nBuilding the second layer of the counts also runs in O(n) time, but only takes\\nO(sqrt(n)) space, since the worst case is that every chracter in the string has\\na different count. Therefore checking equality of the counts runs in O(sqrt(n))\\ntime.\\n\\nThis brings our total runtime complexity to O(n) + O(n) + O(n) + O(sqrt(n)),\\nwhich is just O(n), and our total space complexity to O(n) + O(n) + O(sqrt(n))\\nwhich is also O(n).\\n",
                "solutionTags": [],
                "code": "```python\\ndef closeStrings(self, a, b):\\n\\treturn set(a) == set(b) and Counter(Counter(a).values()) == Counter(Counter(b).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935972,
                "title": "python-nlogn-fast-easy",
                "content": "```\\nclass Solution(object):\\n    def closeStrings(self, word1, word2):\\n        count1 = dict()\\n        count2 = dict()\\n        \\n        for char in word1:\\n            count1[char] = count1.get(char, 0) + 1\\n        \\n        for char in word2:\\n            count2[char] = count2.get(char,0) + 1\\n        \\n        \\n        return sorted(count1.values()) == sorted(count2.values()) and set(word1)== set(word2)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def closeStrings(self, word1, word2):\\n        count1 = dict()\\n        count2 = dict()\\n        \\n        for char in word1:\\n            count1[char] = count1.get(char, 0) + 1\\n        \\n        for char in word2:\\n            count2[char] = count2.get(char,0) + 1\\n        \\n        \\n        return sorted(count1.values()) == sorted(count2.values()) and set(word1)== set(word2)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 935962,
                "title": "python3-2-line-via-counter",
                "content": "Algo \\nThe condition for two words to be similar is that \\n1) they have the same set of characters (since characters can only swap and they cannot appear or disappear)\\n2) they have the same frequency spectrum (not necessarily the same occurrence for the same character but same frequency must appear in both spectrum). \\n\\nImplementation via `Counter`\\n\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        cnt1, cnt2 = Counter(word1), Counter(word2)\\n        return cnt1.keys() == cnt2.keys() and sorted(cnt1.values()) == sorted(cnt2.values())\\n```\\n\\nAnalysis\\nTime complexity `O(N)` since you at most sort 26 numbers/strings\\nSpace complexity `O(N)`\\n\\nEdited on 11/15/2020\\nNot utilizing `Counter`\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        \\n        def fn(word):\\n            \"\"\"Return freq table of word.\"\"\"\\n            freq = {}\\n            for c in word: freq[c] = 1 + freq.get(c, 0)\\n            return freq\\n        \\n        freq1, freq2 = fn(word1), fn(word2)\\n        return freq1.keys() == freq2.keys() and sorted(freq1.values()) == sorted(freq2.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        cnt1, cnt2 = Counter(word1), Counter(word2)\\n        return cnt1.keys() == cnt2.keys() and sorted(cnt1.values()) == sorted(cnt2.values())\\n```\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        \\n        def fn(word):\\n            \"\"\"Return freq table of word.\"\"\"\\n            freq = {}\\n            for c in word: freq[c] = 1 + freq.get(c, 0)\\n            return freq\\n        \\n        freq1, freq2 = fn(word1), fn(word2)\\n        return freq1.keys() == freq2.keys() and sorted(freq1.values()) == sorted(freq2.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935918,
                "title": "java-greedy-100",
                "content": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        //strategy: Greedy\\n        //different lengths are automatically false\\n        if (word1.length() != word2.length()) {\\n            return false;\\n        }\\n        //Operation 1 allows us to move all characters freely\\n        //Opereration 2 allows us to reassign the characters\\n        //keep a frequency char of both word1 and word2\\n        int[] one = new int[26];\\n        int[] two = new int[26];\\n        for (int i = 0; i < word1.length(); i++) {\\n            one[word1.charAt(i) - \\'a\\']++;\\n            two[word2.charAt(i) - \\'a\\']++;\\n        }\\n        //make sure the characters are the same in order to reassign letters\\n        for (int i = 0; i < 26; i++) {\\n            if ((one[i] > 0 && two[i] == 0) || (one[i] == 0 && two[i] > 0)) {\\n                return false;\\n            }\\n        }\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        //see if there are frequencies that match up in both words\\n        for (int i = 0; i < 26; i++) {\\n            if (one[i] != 0) {\\n                map.put(one[i], map.getOrDefault(one[i], 0) + 1);\\n            }\\n            if (two[i] != 0) {\\n                map.put(two[i], map.getOrDefault(two[i], 0) - 1);\\n            }\\n        }\\n        //all frequences should be 0 so that means we can reassign the frequencies\\n        for (int key : map.keySet()) {\\n            if (map.get(key) != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        //strategy: Greedy\\n        //different lengths are automatically false\\n        if (word1.length() != word2.length()) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4009390,
                "title": "go-solution-easy-explanation-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks whether two strings, word1 and word2, can be considered \"close\" based on two operations: swapping any two existing characters and transforming every occurrence of one existing character into another existing character. To determine if two strings are \"close,\" we need to check if they have the same set of characters, and for each character, the frequency of occurrences in both strings is the same.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the lengths of word1 and word2 are equal. If they are not, return false since strings of different lengths cannot be made \"close.\"\\n\\n2. Create two slices, freq1 and freq2, each of length 26 (to accommodate lowercase English letters). These slices will be used to store the frequency of characters in word1 and word2.\\n\\n3. Populate freq1 and freq2 by iterating through the characters in word1 and word2, respectively. Use the offset \\'a\\' to map characters to their corresponding indices in the slices.\\n\\n4. Check if the sets of characters (keys) in both freq1 and freq2 are the same. If they are not, return false.\\n\\n5. Sort the slices freq1 and freq2 in ascending order.\\n\\n6. Compare the sorted slices to check if the frequencies match for each character. If they match for all characters, return true; otherwise, return false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe overall time complexity is O(N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe overall space complexity is O(1).\\n\\n# Code\\n```\\nfunc closeStrings(word1 string, word2 string) bool {\\n    // Check if the lengths of both words are equal\\n    if len(word1) != len(word2) {\\n        return false\\n    }\\n\\n    // Create slices to store the frequency of characters for both words\\n    freq1 := make([]int, 26)\\n    freq2 := make([]int, 26)\\n\\n    // Populate the frequency slices for word1\\n    for _, char := range word1 {\\n        freq1[char-\\'a\\']++\\n    }\\n\\n    // Populate the frequency slices for word2\\n    for _, char := range word2 {\\n        freq2[char-\\'a\\']++\\n    }\\n\\n    // Check if the sets of characters (keys) in both words are the same\\n    for i := 0; i < 26; i++ {\\n        if (freq1[i] > 0 && freq2[i] == 0) || (freq1[i] == 0 && freq2[i] > 0) {\\n            return false\\n        }\\n    }\\n\\n    // Sort the frequency slices in ascending order\\n    sort.Ints(freq1)\\n    sort.Ints(freq2)\\n\\n    // Compare the sorted frequency slices\\n    for i := 0; i < 26; i++ {\\n        if freq1[i] != freq2[i] {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc closeStrings(word1 string, word2 string) bool {\\n    // Check if the lengths of both words are equal\\n    if len(word1) != len(word2) {\\n        return false\\n    }\\n\\n    // Create slices to store the frequency of characters for both words\\n    freq1 := make([]int, 26)\\n    freq2 := make([]int, 26)\\n\\n    // Populate the frequency slices for word1\\n    for _, char := range word1 {\\n        freq1[char-\\'a\\']++\\n    }\\n\\n    // Populate the frequency slices for word2\\n    for _, char := range word2 {\\n        freq2[char-\\'a\\']++\\n    }\\n\\n    // Check if the sets of characters (keys) in both words are the same\\n    for i := 0; i < 26; i++ {\\n        if (freq1[i] > 0 && freq2[i] == 0) || (freq1[i] == 0 && freq2[i] > 0) {\\n            return false\\n        }\\n    }\\n\\n    // Sort the frequency slices in ascending order\\n    sort.Ints(freq1)\\n    sort.Ints(freq2)\\n\\n    // Compare the sorted frequency slices\\n    for i := 0; i < 26; i++ {\\n        if freq1[i] != freq2[i] {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919206,
                "title": "beginner-friendly-solution-well-explained-code-easy-to-understand",
                "content": "# Intuition\\n\\nThe goal is to determine if two strings can be transformed into each other by satisfying size and character frequency conditions.\\n\\n# Approach\\n\\n1) If the sizes of word1 and word2 are different, return false.\\n2) Create sets charSet1 and charSet2 to hold unique characters from word1 and word2.\\n3) Create arrays charFreq1 and charFreq2 to store character frequencies (26 slots for each letter.\\n4) Iterate through characters of word1 and word2:\\n5) Add characters to corresponding sets.\\n6) Update character frequency arrays.\\n7) Sort charFreq1 and charFreq2 arrays.\\n8) Compare charSet1 and charSet2, and charFreq1 and charFreq2.\\n9) If sets and sorted frequency arrays match, return true; else, return false.\\n\\n# Complexity\\n- Time complexity:  O(n) \\n\\n- Space complexity:  O(n) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        // Check if the sizes of the two strings are different, return false if they are\\n        if (word1.size() != word2.size())\\n            return false;\\n\\n        // Create sets to store the unique characters in both words\\n        unordered_set<char> charSet1, charSet2;\\n        \\n        // Create arrays to store the frequency of each character in both words\\n        vector<int> charFreq1(26, 0), charFreq2(26, 0);\\n\\n        // Iterate through the characters of word1 and word2\\n        for (int i = 0; i < word1.size(); i++) {\\n            // Insert characters into their respective sets\\n            charSet1.insert(word1[i]);\\n            charSet2.insert(word2[i]);\\n            \\n            // Update the frequency arrays for the corresponding characters\\n            charFreq1[word1[i] - \\'a\\']++;\\n            charFreq2[word2[i] - \\'a\\']++;\\n        }\\n\\n        // Sort the frequency arrays for both words\\n        sort(charFreq1.begin(), charFreq1.end());\\n        sort(charFreq2.begin(), charFreq2.end());\\n\\n        // Compare the sets and sorted frequency arrays\\n        if (charSet1 == charSet2 && charFreq1 == charFreq2)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n\\n```\\n/*   Plz Upvote Solution if You like */\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        // Check if the sizes of the two strings are different, return false if they are\\n        if (word1.size() != word2.size())\\n            return false;\\n\\n        // Create sets to store the unique characters in both words\\n        unordered_set<char> charSet1, charSet2;\\n        \\n        // Create arrays to store the frequency of each character in both words\\n        vector<int> charFreq1(26, 0), charFreq2(26, 0);\\n\\n        // Iterate through the characters of word1 and word2\\n        for (int i = 0; i < word1.size(); i++) {\\n            // Insert characters into their respective sets\\n            charSet1.insert(word1[i]);\\n            charSet2.insert(word2[i]);\\n            \\n            // Update the frequency arrays for the corresponding characters\\n            charFreq1[word1[i] - \\'a\\']++;\\n            charFreq2[word2[i] - \\'a\\']++;\\n        }\\n\\n        // Sort the frequency arrays for both words\\n        sort(charFreq1.begin(), charFreq1.end());\\n        sort(charFreq2.begin(), charFreq2.end());\\n\\n        // Compare the sets and sorted frequency arrays\\n        if (charSet1 == charSet2 && charFreq1 == charFreq2)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734590,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool CloseStrings(string word1, string word2) {\\n        if(word1.Length != word2.Length)\\n            return false;\\n\\n        var freq1 = GetFrequency(word1);\\n        var freq2 = GetFrequency(word2);\\n\\n        if(!IsAnagram(freq1, freq2))\\n            return false;\\n\\n        Array.Sort(freq1);\\n        Array.Sort(freq2);\\n\\n        for(int idx = 0; idx < 26; idx++)\\n            if(freq1[idx] != freq2[idx])\\n                return false;\\n\\n        return true;\\n    }\\n\\n    private bool IsAnagram(int[] freq1, int[] freq2) {\\n        for(int idx = 0; idx < 26; idx++)\\n            if((freq1[idx] == 0 && freq2[idx] != 0) || (freq1[idx] != 0 && freq2[idx] == 0))\\n                return false;\\n\\n        return true;\\n    }\\n\\n    private int[] GetFrequency(string str) {\\n        var freq = new int[26];\\n        foreach(var chr in str)\\n            freq[chr - \\'a\\']++;\\n\\n        return freq;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CloseStrings(string word1, string word2) {\\n        if(word1.Length != word2.Length)\\n            return false;\\n\\n        var freq1 = GetFrequency(word1);\\n        var freq2 = GetFrequency(word2);\\n\\n        if(!IsAnagram(freq1, freq2))\\n            return false;\\n\\n        Array.Sort(freq1);\\n        Array.Sort(freq2);\\n\\n        for(int idx = 0; idx < 26; idx++)\\n            if(freq1[idx] != freq2[idx])\\n                return false;\\n\\n        return true;\\n    }\\n\\n    private bool IsAnagram(int[] freq1, int[] freq2) {\\n        for(int idx = 0; idx < 26; idx++)\\n            if((freq1[idx] == 0 && freq2[idx] != 0) || (freq1[idx] != 0 && freq2[idx] == 0))\\n                return false;\\n\\n        return true;\\n    }\\n\\n    private int[] GetFrequency(string str) {\\n        var freq = new int[26];\\n        foreach(var chr in str)\\n            freq[chr - \\'a\\']++;\\n\\n        return freq;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727356,
                "title": "java-simple-solution-using-hashset-linear-time-complexity-constant-space-complexity",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length() != word2.length()) \\n            return false;\\n\\n        int arr1[] = new int[26], arr2[] = new int[26];\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for(char c : word1.toCharArray()) {\\n            arr1[c-\\'a\\'] ++;\\n            set.add(c-\\'a\\');\\n        }\\n\\n        for(char c : word2.toCharArray()) \\n            if(set.contains(c-\\'a\\')) arr2[c-\\'a\\'] ++;\\n\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n        return Arrays.equals(arr1, arr2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length() != word2.length()) \\n            return false;\\n\\n        int arr1[] = new int[26], arr2[] = new int[26];\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for(char c : word1.toCharArray()) {\\n            arr1[c-\\'a\\'] ++;\\n            set.add(c-\\'a\\');\\n        }\\n\\n        for(char c : word2.toCharArray()) \\n            if(set.contains(c-\\'a\\')) arr2[c-\\'a\\'] ++;\\n\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n        return Arrays.equals(arr1, arr2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711653,
                "title": "counting-sorting-c-beats-90",
                "content": "# if it helps You. Please Upvote Me....\\uD83E\\uDDE1\\uD83E\\uDD0D\\uD83D\\uDC9A\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the frequency of each element, just return false if a character is not present in both the strings. Sort the frequency vectors and check whether they are equal or not.\\n\\n**Note:-**\\n**don\\'t care about the first operations, check that frequency of the characters is swapped or not.**\\n**for Ex:-  w1 = \\'abbccc\\'   w2 = \\'bbaaac\\',  here the frequency of \\'a\\' and \\'c\\' is swapped.**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string w1, string w2) {\\n      int n = w1.size(),m = w2.size();\\n      vector<int> v1(26,0),v2(26,0);\\n\\n      if(n!=m) return false;\\n      for(int i = 0;i<n;i++)\\n      {\\n        v1[w1[i]-\\'a\\']++;\\n        v2[w2[i]-\\'a\\']++;\\n      }\\n\\n      for(int i = 0;i<26;i++)\\n      if(v1[i]!=0 && v2[i]==0 || v2[i]!=0 && v1[i]==0) return false;\\n      \\n      sort(v1.begin(),v1.end());\\n      sort(v2.begin(),v2.end());\\n      for(int i = 0;i<26;i++)\\n      if(v1[i]!=v2[i]) return false;\\n\\n      return true;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/cce5037f-0e9e-4cc9-88f9-337e615dd52c_1688369687.772068.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string w1, string w2) {\\n      int n = w1.size(),m = w2.size();\\n      vector<int> v1(26,0),v2(26,0);\\n\\n      if(n!=m) return false;\\n      for(int i = 0;i<n;i++)\\n      {\\n        v1[w1[i]-\\'a\\']++;\\n        v2[w2[i]-\\'a\\']++;\\n      }\\n\\n      for(int i = 0;i<26;i++)\\n      if(v1[i]!=0 && v2[i]==0 || v2[i]!=0 && v1[i]==0) return false;\\n      \\n      sort(v1.begin(),v1.end());\\n      sort(v2.begin(),v2.end());\\n      for(int i = 0;i<26;i++)\\n      if(v1[i]!=v2[i]) return false;\\n\\n      return true;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706887,
                "title": "easy-solution-in-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size()!=word2.size())return 0;\\n        unordered_map<char,int>mapp1;\\n        unordered_map<char,int>mapp2;\\n        for(auto i:word1) mapp1[i]++;\\n        for(auto i:word2) mapp2[i]++;\\n        string W1=\"\",W2=\"\";\\n        for(auto i:mapp1)W1+=to_string(i.first)+to_string(i.second);\\n        for(auto i:mapp2)W2+=to_string(i.first)+to_string(i.second);\\n        sort(W1.begin(),W1.end());\\n        sort(W2.begin(),W2.end());\\n        return W1==W2;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size()!=word2.size())return 0;\\n        unordered_map<char,int>mapp1;\\n        unordered_map<char,int>mapp2;\\n        for(auto i:word1) mapp1[i]++;\\n        for(auto i:word2) mapp2[i]++;\\n        string W1=\"\",W2=\"\";\\n        for(auto i:mapp1)W1+=to_string(i.first)+to_string(i.second);\\n        for(auto i:mapp2)W2+=to_string(i.first)+to_string(i.second);\\n        sort(W1.begin(),W1.end());\\n        sort(W2.begin(),W2.end());\\n        return W1==W2;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295270,
                "title": "simple-python-97",
                "content": "\\n# Complexity\\n- Time complexity: O(n) - Further, we sort the character keys and frequency values of each hashmap. The maximum size of hashmap would be 26, as we store each character a-z only once. In the worst case, all the sort operations would take OO(26log26) time to sort those frequency values. This gives us total time complexity as O(n).\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) - max length of hashmaps is 26 characters\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if len(word1) != len(word2):\\n            return False\\n            \\n        count1 = Counter(word1)\\n        count2 = Counter(word2)\\n\\n        condition1 = sorted(count1.keys()) == sorted(count2.keys())\\n        condition2 = sorted(count1.values()) == sorted(count2.values())\\n\\n        return condition1 and condition2\\n\\n# We can see that: \\n# - (Condition 1) The strings word1 and word2 must have the same characters (keys)\\n# - (Condition 2) The occurrence or frequency of characters in word1 and word2 must be the same. .\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if len(word1) != len(word2):\\n            return False\\n            \\n        count1 = Counter(word1)\\n        count2 = Counter(word2)\\n\\n        condition1 = sorted(count1.keys()) == sorted(count2.keys())\\n        condition2 = sorted(count1.values()) == sorted(count2.values())\\n\\n        return condition1 and condition2\\n\\n# We can see that: \\n# - (Condition 1) The strings word1 and word2 must have the same characters (keys)\\n# - (Condition 2) The occurrence or frequency of characters in word1 and word2 must be the same. .\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045468,
                "title": "easy-cpp-solution-using-sets-maps-and-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        set<char> s1;\\n        set<char> s2;\\n        for(char x:word1){\\n            s1.insert(x);\\n        }\\n        for(char x:word2){\\n            s2.insert(x);\\n        }\\n        vector<char> ve1,ve2;\\n        for(auto it:s1){\\n            ve1.push_back(it);\\n        }\\n        for(auto it:s2){\\n            ve2.push_back(it);\\n        }\\n        if(ve1.size()!=ve2.size()){\\n            return false;\\n        }\\n        for(int i=0;i<ve1.size();i++){\\n            if(ve1[i]!=ve2[i]){\\n                return false;\\n            }\\n        }\\n        map<char,int> m1;\\n        map<char,int> m2;\\n        for(auto x:word1){\\n            m1[x]++;\\n        }\\n        for(auto x:word2){\\n            m2[x]++;\\n        }\\n        vector<int> v1,v2;\\n        for(auto it:m1){\\n            v1.push_back(it.second);\\n        }\\n        for(auto it:m2){\\n            v2.push_back(it.second);\\n        }\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        for(int i=0;i<v1.size();i++){\\n            if(v1[i]!=v2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        set<char> s1;\\n        set<char> s2;\\n        for(char x:word1){\\n            s1.insert(x);\\n        }\\n        for(char x:word2){\\n            s2.insert(x);\\n        }\\n        vector<char> ve1,ve2;\\n        for(auto it:s1){\\n            ve1.push_back(it);\\n        }\\n        for(auto it:s2){\\n            ve2.push_back(it);\\n        }\\n        if(ve1.size()!=ve2.size()){\\n            return false;\\n        }\\n        for(int i=0;i<ve1.size();i++){\\n            if(ve1[i]!=ve2[i]){\\n                return false;\\n            }\\n        }\\n        map<char,int> m1;\\n        map<char,int> m2;\\n        for(auto x:word1){\\n            m1[x]++;\\n        }\\n        for(auto x:word2){\\n            m2[x]++;\\n        }\\n        vector<int> v1,v2;\\n        for(auto it:m1){\\n            v1.push_back(it.second);\\n        }\\n        for(auto it:m2){\\n            v2.push_back(it.second);\\n        }\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        for(int i=0;i<v1.size();i++){\\n            if(v1[i]!=v2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967400,
                "title": "c-easy-solution",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.Length of word1 and word2 should be same.\\n2.Same characters should present in both words.\\n3.Occurences should be same (not characterwise). Eg- If \\'a\\' is occuring 3 times in word1 then there should be a chacater in word2 which is present in word1 and has occurence 3.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.If length of both words is not same, return false.\\n2.Use two unordered maps to store chacaters and their count.\\n3.Use two min heaps to store values of both maps. (Can use max heap too)\\n4.Iterate over first map and check \\n (i) key(character of word1) is present in word2, if no return false.If yes, (ii) compare top of both heaps,if not equal, return false,if yes pop top of both heaps and continue..\\n5.If these 2 conditions satisfies for single traversal of map,return true\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n-Overall traversal will take length of word complexity and for searching in map will take o(1) assuming average case. So overall complexity is o(3 * len(word1)) + o(2 * len(word2))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n-Used 2 maps and 2 heaps so complexity is o(2 * len(word1)) + o(2 * len(word2))\\n\\nThank you for reading till here. If you found useful, please upvote.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n\\n        if(word1.length()!=word2.length()){\\n            return false;\\n        }\\n\\n        unordered_map<char,int> m1;\\n        unordered_map<char,int> m2;\\n\\n        priority_queue<int,vector<int>,greater<int>> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n\\n        for(auto c:word1){\\n            m1[c]++;\\n        }\\n  \\n        for(auto val:m1){\\n            pq1.push(val.second);\\n        }\\n\\n        for(auto c:word2){\\n            m2[c]++;\\n        }\\n\\n        for(auto val:m2){\\n            pq2.push(val.second);\\n        }\\n\\n        for(auto key:m1){\\n            if(m2.find(key.first)!=m2.end()){\\n                int top1=pq1.top();\\n                int top2=pq2.top();\\n                if(top1!=top2){\\n                    return false;\\n                }\\n                pq1.pop();\\n                pq2.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n\\n        if(word1.length()!=word2.length()){\\n            return false;\\n        }\\n\\n        unordered_map<char,int> m1;\\n        unordered_map<char,int> m2;\\n\\n        priority_queue<int,vector<int>,greater<int>> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n\\n        for(auto c:word1){\\n            m1[c]++;\\n        }\\n  \\n        for(auto val:m1){\\n            pq1.push(val.second);\\n        }\\n\\n        for(auto c:word2){\\n            m2[c]++;\\n        }\\n\\n        for(auto val:m2){\\n            pq2.push(val.second);\\n        }\\n\\n        for(auto key:m1){\\n            if(m2.find(key.first)!=m2.end()){\\n                int top1=pq1.top();\\n                int top2=pq2.top();\\n                if(top1!=top2){\\n                    return false;\\n                }\\n                pq1.pop();\\n                pq2.pop();\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911387,
                "title": "java-o-n-no-sorting-easy",
                "content": "\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length() != word2.length()) {\\n            return false;\\n        }\\n\\n        int[] charFreq1 = new int[26];\\n        int[] charFreq2 = new int[26];        \\n        for(int idx = 0; idx<word1.length(); idx++) {\\n            charFreq1[word1.charAt(idx) - \\'a\\']++;\\n        } for(int idx = 0; idx<word2.length(); idx++) {\\n            charFreq2[word2.charAt(idx) - \\'a\\']++;\\n        }\\n\\n        Map<Integer, Integer> freqToCount = new HashMap<>();\\n        for(int idx = 0; idx<26; idx++) {\\n            int freq1 = charFreq1[idx];\\n            int freq2 = charFreq2[idx];\\n\\n            if((freq1==0 && freq2!=0) || (freq1!=0 && freq2==0) ) {\\n                return false;\\n            }\\n\\n            freqToCount.put(freq1, freqToCount.getOrDefault(freq1, 0) + 1);\\n            freqToCount.put(freq2, freqToCount.getOrDefault(freq2, 0) - 1);\\n        }\\n\\n        for(int value : freqToCount.values()) {\\n            if(value != 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length() != word2.length()) {\\n            return false;\\n        }\\n\\n        int[] charFreq1 = new int[26];\\n        int[] charFreq2 = new int[26];        \\n        for(int idx = 0; idx<word1.length(); idx++) {\\n            charFreq1[word1.charAt(idx) - \\'a\\']++;\\n        } for(int idx = 0; idx<word2.length(); idx++) {\\n            charFreq2[word2.charAt(idx) - \\'a\\']++;\\n        }\\n\\n        Map<Integer, Integer> freqToCount = new HashMap<>();\\n        for(int idx = 0; idx<26; idx++) {\\n            int freq1 = charFreq1[idx];\\n            int freq2 = charFreq2[idx];\\n\\n            if((freq1==0 && freq2!=0) || (freq1!=0 && freq2==0) ) {\\n                return false;\\n            }\\n\\n            freqToCount.put(freq1, freqToCount.getOrDefault(freq1, 0) + 1);\\n            freqToCount.put(freq2, freqToCount.getOrDefault(freq2, 0) - 1);\\n        }\\n\\n        for(int value : freqToCount.values()) {\\n            if(value != 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877349,
                "title": "java-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length()!=word2.length()){\\n            return false;\\n        }\\n        \\n        HashMap<Character,Integer>map1=new HashMap<>();\\n        HashMap<Character,Integer>map2=new HashMap<>();\\n        \\n        for(int i=0;i<word1.length();i++){\\n            if(map1.containsKey(word1.charAt(i))){\\n                map1.put(word1.charAt(i),map1.get(word1.charAt(i))+1);\\n            }\\n            else{\\n                map1.put(word1.charAt(i),1);\\n            }\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            if(map2.containsKey(word2.charAt(i))){\\n                map2.put(word2.charAt(i),map2.get(word2.charAt(i))+1);\\n            }\\n            else{\\n                map2.put(word2.charAt(i),1);\\n            }\\n        }\\n        if(!map1.keySet().equals(map2.keySet())){\\n            return false;\\n        }\\n        \\n        ArrayList<Integer>l1=new ArrayList<>(map1.values());\\n        ArrayList<Integer>l2=new ArrayList<>(map2.values());\\n        \\n        if(l1.size()!=l2.size()){\\n            return false;\\n        }\\n        \\n        Collections.sort(l1);\\n        Collections.sort(l2);\\n        \\n        return l1.equals(l2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length()!=word2.length()){\\n            return false;\\n        }\\n        \\n        HashMap<Character,Integer>map1=new HashMap<>();\\n        HashMap<Character,Integer>map2=new HashMap<>();\\n        \\n        for(int i=0;i<word1.length();i++){\\n            if(map1.containsKey(word1.charAt(i))){\\n                map1.put(word1.charAt(i),map1.get(word1.charAt(i))+1);\\n            }\\n            else{\\n                map1.put(word1.charAt(i),1);\\n            }\\n        }\\n        for(int i=0;i<word2.length();i++){\\n            if(map2.containsKey(word2.charAt(i))){\\n                map2.put(word2.charAt(i),map2.get(word2.charAt(i))+1);\\n            }\\n            else{\\n                map2.put(word2.charAt(i),1);\\n            }\\n        }\\n        if(!map1.keySet().equals(map2.keySet())){\\n            return false;\\n        }\\n        \\n        ArrayList<Integer>l1=new ArrayList<>(map1.values());\\n        ArrayList<Integer>l2=new ArrayList<>(map2.values());\\n        \\n        if(l1.size()!=l2.size()){\\n            return false;\\n        }\\n        \\n        Collections.sort(l1);\\n        Collections.sort(l2);\\n        \\n        return l1.equals(l2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870816,
                "title": "explained-solution-beginner-friendly",
                "content": "``` \\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        c1 = Counter(word1) #counts the occurrence of letters in word1\\n        c2 = Counter(word2) #counts the occurrence of letters in word2\\n        if set(word1)==set(word2) and sorted(list(c1.values())) == sorted(list(c2.values())): \\n\\t\\t#if letters are the same in both words (we don\\'t care about the order since operation 1 allows us to reorder the string) \\n\\t\\t#and occurrences are the same (we don\\'t care which occurrence is asssociated to which letters since operation 2 allows us \\n\\t\\t#to exchange them)\\n            return True \\n        else: #if the words don\\'t meet the previous conditions, they\\'re not close\\n            return False\\n```\\nUpvote if it helps ! :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` \\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        c1 = Counter(word1) #counts the occurrence of letters in word1\\n        c2 = Counter(word2) #counts the occurrence of letters in word2\\n        if set(word1)==set(word2) and sorted(list(c1.values())) == sorted(list(c2.values())): \\n\\t\\t#if letters are the same in both words (we don\\'t care about the order since operation 1 allows us to reorder the string) \\n\\t\\t#and occurrences are the same (we don\\'t care which occurrence is asssociated to which letters since operation 2 allows us \\n\\t\\t#to exchange them)\\n            return True \\n        else: #if the words don\\'t meet the previous conditions, they\\'re not close\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870661,
                "title": "2-js-solution-using-objects-and-set-filter",
                "content": "Option 1. I\\'m using 2 objects and then compare they keys and values\\n```\\nvar closeStrings = function(word1, word2) {\\n\\tif (word1.length !== word2.length) return false;\\n\\tconst obj1 = {};\\n\\tconst obj2 = {};\\n\\n\\tfor (let i = 0; i < word1.length; i++) {\\n\\t\\tobj1[word1[i]] = obj1[word1[i]] ? obj1[word1[i]] + 1 : 1;\\n\\t\\tobj2[word2[i]] = obj2[word2[i]] ? obj2[word2[i]] + 1 : 1;\\n\\t}\\n\\n\\tconst letters = Object.keys(obj1).sort().join(\"\") === Object.keys(obj2).sort().join(\"\");\\n\\tconst values = Object.values(obj1).sort().join(\"\") === Object.values(obj2).sort().join(\"\");\\n\\n\\treturn letters && values;\\n};\\n```\\nOption 2.\\n```\\nvar closeStrings = function(word1, word2) {\\n    if (word1.length !== word2.length) return false;\\n  \\n    const arr1 = [];\\n    const arr2 = [];\\n    const uniqLetters = [...new Set(word1)]; // get unique letters from the first word to make the loop shorter\\n  \\n    for(let i = 0; i < uniqLetters.length; i++) {\\n\\t  // collect sum of every letter in the word\\n      arr1.push([...word1].filter(letter => letter === uniqLetters[i])?.length);\\n      arr2.push([...word2].filter(letter => letter === uniqLetters[i])?.length);\\n    }\\n  \\n    if (arr2.includes(0)) return false;  // if there is a 0 in the 2nd array it means letters in both words not the same\\n  \\n    return arr1.sort().join(\\'\\') == arr2.sort().join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar closeStrings = function(word1, word2) {\\n\\tif (word1.length !== word2.length) return false;\\n\\tconst obj1 = {};\\n\\tconst obj2 = {};\\n\\n\\tfor (let i = 0; i < word1.length; i++) {\\n\\t\\tobj1[word1[i]] = obj1[word1[i]] ? obj1[word1[i]] + 1 : 1;\\n\\t\\tobj2[word2[i]] = obj2[word2[i]] ? obj2[word2[i]] + 1 : 1;\\n\\t}\\n\\n\\tconst letters = Object.keys(obj1).sort().join(\"\") === Object.keys(obj2).sort().join(\"\");\\n\\tconst values = Object.values(obj1).sort().join(\"\") === Object.values(obj2).sort().join(\"\");\\n\\n\\treturn letters && values;\\n};\\n```\n```\\nvar closeStrings = function(word1, word2) {\\n    if (word1.length !== word2.length) return false;\\n  \\n    const arr1 = [];\\n    const arr2 = [];\\n    const uniqLetters = [...new Set(word1)]; // get unique letters from the first word to make the loop shorter\\n  \\n    for(let i = 0; i < uniqLetters.length; i++) {\\n\\t  // collect sum of every letter in the word\\n      arr1.push([...word1].filter(letter => letter === uniqLetters[i])?.length);\\n      arr2.push([...word2].filter(letter => letter === uniqLetters[i])?.length);\\n    }\\n  \\n    if (arr2.includes(0)) return false;  // if there is a 0 in the 2nd array it means letters in both words not the same\\n  \\n    return arr1.sort().join(\\'\\') == arr2.sort().join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2870471,
                "title": "python-1-liner-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeywords: existing letters, swappable\\nFrom the first statement, as letters are swappable, we can conclude that position does **NOT** matter, and thus the idea to use a counter list was formed.\\nIdea further reinforced by \"existing letters\", meaning that keys have to be compared.\\n\\nMy aim was to annoy people intuitively\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. For lazy peeps, use the Counter function in collections to find the count of each letter\\n2. As the letters must be substitued by **existing** letters, we compare the keys of the dictionaries (Unnecessary if we can use any letter to substitute)\\n3. As existing characters are **swappable**, ensure that list of frequency of letters are the same (done by sorting the list of values)\\n4. Annoy people by putting it in one line\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(max(word1, word2))\\n\\n- Space complexity:\\nO(word1 + word2)\\n\\n# Code\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        return sorted(collections.Counter(word1).values()) == sorted(collections.Counter(word2).values()) and collections.Counter(word1).keys() == collections.Counter(word2).keys() \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        return sorted(collections.Counter(word1).values()) == sorted(collections.Counter(word2).values()) and collections.Counter(word1).keys() == collections.Counter(word2).keys() \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870424,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n// Two condition which we have take care of :-\\n// 1- characters must be same in both words.\\n// 2- frequency set must be same of both words( NOTE :- By saying frequency set same it doesn\\'t mean frequency of each character in both words must be equal)\\n```\\nclass Solution {\\npublic:\\n\\n    bool closeStrings(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n\\n        if(n!=m) return false;\\n\\n        vector<int> s1(26 , 0) , s2(26 , 0) , s3(26 , 0) , s4(26 , 0);\\n\\n        for(int i=0 ; i<m ; i++){\\n            s1[word1[i]-\\'a\\']++;\\n            s3[word1[i]-\\'a\\'] = 1;\\n\\n            s2[word2[i]-\\'a\\']++;\\n            s4[word2[i]-\\'a\\'] = 1;\\n        }\\n\\n        sort(s1.begin() , s1.end());\\n        sort(s2.begin() , s2.end());\\n\\n        return (s1 == s2 && s3 == s4);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool closeStrings(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n\\n        if(n!=m) return false;\\n\\n        vector<int> s1(26 , 0) , s2(26 , 0) , s3(26 , 0) , s4(26 , 0);\\n\\n        for(int i=0 ; i<m ; i++){\\n            s1[word1[i]-\\'a\\']++;\\n            s3[word1[i]-\\'a\\'] = 1;\\n\\n            s2[word2[i]-\\'a\\']++;\\n            s4[word2[i]-\\'a\\'] = 1;\\n        }\\n\\n        sort(s1.begin() , s1.end());\\n        sort(s2.begin() , s2.end());\\n\\n        return (s1 == s2 && s3 == s4);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870402,
                "title": "python-5-lines-easy-explantation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- From operations: \\n    - Swap any two existing characters. \\n    - Transform every occurrence of one existing character into another existing character, and do the same with the other character. \\n    \\n===> **Word1 number of each character of word1 seem word2**\\n\\n- Solution:\\n    - Count number of each character in 2 word\\n    - Sort it\\n    - Compare it, if equal return True else return False.\\n    - \\n# Complexity\\n\\n![Screen Shot 2022-12-02 at 23.37.20.png](https://assets.leetcode.com/users/images/6ff84a34-9941-444d-9e9b-f2347a4202c8_1669999061.233352.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if len(word1) != len(word2) or set(word1) != set(word2): return False\\n        else:\\n            if sorted([word1.count(i) for i in set(word1)])== sorted([word2.count(i) for i in set(word2)]):\\n                return True\\n            else: return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if len(word1) != len(word2) or set(word1) != set(word2): return False\\n        else:\\n            if sorted([word1.count(i) for i in set(word1)])== sorted([word2.count(i) for i in set(word2)]):\\n                return True\\n            else: return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870365,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        vector<int> v1(26), v2(26);\\n        set<int> st1, st2;\\n        for(auto x: word1) v1[x-\\'a\\']++, st1.insert(x-\\'a\\');\\n        for(auto x: word2) v2[x-\\'a\\']++, st2.insert(x-\\'a\\');\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end());\\n        if(v1 == v2 and st1 == st2) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        vector<int> v1(26), v2(26);\\n        set<int> st1, st2;\\n        for(auto x: word1) v1[x-\\'a\\']++, st1.insert(x-\\'a\\');\\n        for(auto x: word2) v2[x-\\'a\\']++, st2.insert(x-\\'a\\');\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end());\\n        if(v1 == v2 and st1 == st2) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870341,
                "title": "daily-leetcode-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string A, string B) {\\n        // if their length is not equal they can\\'t be close\\n\\n        if(A.length() != B.length()) return false;\\n\\n        // calculate the occurance of every element\\n\\n        int a[26]={},b[26]={};\\n        for(auto it : A){\\n            a[it-\\'a\\']++;\\n        }\\n        for(auto it : B){\\n            b[it-\\'a\\']++;\\n        }\\n\\n        // check for element present in only one string\\n\\n        for(int i = 0;i < 26;i++){\\n            if((a[i] == 0 && b[i] != 0) || (a[i] != 0 && b[i] == 0)){\\n                return false;\\n            }\\n        }\\n\\n        // check if total frequency can be mapped\\n\\n        map<int,int>m;\\n        for(int i = 0;i < 26;i++){\\n            m[a[i]]++;\\n        }\\n        for(int i = 0;i < 26;i++){\\n            m[b[i]]--;\\n        }\\n\\n        // if the frequency is mapped perfectly then the value for each key will be utilized\\n\\n        for(auto it : m){\\n            if(it.second != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string A, string B) {\\n        // if their length is not equal they can\\'t be close\\n\\n        if(A.length() != B.length()) return false;\\n\\n        // calculate the occurance of every element\\n\\n        int a[26]={},b[26]={};\\n        for(auto it : A){\\n            a[it-\\'a\\']++;\\n        }\\n        for(auto it : B){\\n            b[it-\\'a\\']++;\\n        }\\n\\n        // check for element present in only one string\\n\\n        for(int i = 0;i < 26;i++){\\n            if((a[i] == 0 && b[i] != 0) || (a[i] != 0 && b[i] == 0)){\\n                return false;\\n            }\\n        }\\n\\n        // check if total frequency can be mapped\\n\\n        map<int,int>m;\\n        for(int i = 0;i < 26;i++){\\n            m[a[i]]++;\\n        }\\n        for(int i = 0;i < 26;i++){\\n            m[b[i]]--;\\n        }\\n\\n        // if the frequency is mapped perfectly then the value for each key will be utilized\\n\\n        for(auto it : m){\\n            if(it.second != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870337,
                "title": "simple-c-solution-tc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        \\n        //w1 and w2 will store the frequency of word1 and word2 respectively\\n        //w3 and w4 will mark 1 at charcter\\'s position \\n        vector<int> w1(26,0) , w2(26,0) , w3(26,0) , w4(26,0);\\n        \\n        //storing the frequency of characters in w1 and\\n\\t\\t//marking 1 at character\\'s position in w3\\n        for(char c:word1){\\n            w1[c-\\'a\\']++;\\n            w3[c-\\'a\\']=1;\\n        }  \\n        \\n        //storing the frequency of characters in w2 and\\n\\t\\t//marking 1 at character\\'s position in w4\\n        for(char c:word2){\\n            w2[c-\\'a\\']++;\\n            w4[c-\\'a\\']=1;\\n        } \\n        \\n        sort(w1.begin(),w1.end());\\n        sort(w2.begin(),w2.end());\\n        \\n        return w1==w2 && w3==w4;\\n    }\\n};\\n\\n```\\n\\n\\n**Time Complexity = O(n)\\nSpace Complexity = O(n)**\\n\\n\\n\\nTwo thing\\'s Need to check\\n\\n1) Frequency of Char need\\'s to be same there both of string as we can do Transform every occurrence of one existing character into another existing character\\n2) All the unique char which there in String1 need\\'s to there as well In string2\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        \\n        //w1 and w2 will store the frequency of word1 and word2 respectively\\n        //w3 and w4 will mark 1 at charcter\\'s position \\n        vector<int> w1(26,0) , w2(26,0) , w3(26,0) , w4(26,0);\\n        \\n        //storing the frequency of characters in w1 and\\n\\t\\t//marking 1 at character\\'s position in w3\\n        for(char c:word1){\\n            w1[c-\\'a\\']++;\\n            w3[c-\\'a\\']=1;\\n        }  \\n        \\n        //storing the frequency of characters in w2 and\\n\\t\\t//marking 1 at character\\'s position in w4\\n        for(char c:word2){\\n            w2[c-\\'a\\']++;\\n            w4[c-\\'a\\']=1;\\n        } \\n        \\n        sort(w1.begin(),w1.end());\\n        sort(w2.begin(),w2.end());\\n        \\n        return w1==w2 && w3==w4;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870262,
                "title": "easy-c-o-n-time-constant-space",
                "content": "Please Upvote.\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int A[26] = {0}, B[26] = {0};\\n        for(auto i: word1) A[i-97]++;\\n        for(auto i: word2) B[i-97]++;\\n        for(int i=0;i<26;i++){\\n            if((A[i]==0 && B[i]) || (B[i]==0 && A[i])) return false;\\n        }\\n        sort(A, A+26);\\n        sort(B, B+26);\\n        for(int i=0;i<26;i++){\\n            if(A[i] != B[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int A[26] = {0}, B[26] = {0};\\n        for(auto i: word1) A[i-97]++;\\n        for(auto i: word2) B[i-97]++;\\n        for(int i=0;i<26;i++){\\n            if((A[i]==0 && B[i]) || (B[i]==0 && A[i])) return false;\\n        }\\n        sort(A, A+26);\\n        sort(B, B+26);\\n        for(int i=0;i<26;i++){\\n            if(A[i] != B[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870256,
                "title": "c-short-and-simple-o-n-solution",
                "content": "# Hint\\nOnly operation 2nd is useful.\\n\\n# Approach\\nWe have to consider the hint that if we reach to any condition where only operation 1 we have to perform then answer is always true. \\nBecause we can convert any string as we want using swap operation.\\n\\nNow after that one think come into your mind that we have to just check the occurances of the character and match them with string b character(Mere dimag me toh aayi ye baat).\\nYeah you are in right direction but adding few conditon\\n1) if string \"a\" occurance of any character is not matching with string \"b\" then using brute force we can check where the occurrences are same and apply 2nd operation\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        vector<int> v1(26), v2(26);\\n        for(int i = 0; i< word1.size(); i++)\\n        {\\n            v1[word1[i] - \\'a\\']++;\\n        }\\n        for(int i = 0; i<word2.size(); i++)\\n        {\\n            v2[word2[i] - \\'a\\']++;\\n        }\\n        for(int i = 0; i< 26; i++)\\n        {\\n            if((v1[i] == 0 and v2[i]!=0) or (v1[i] != 0 and v2[i] == 0))\\n            {\\n                return false;\\n            }\\n            if(v1[i] == v2[i])\\n            {\\n                continue;\\n            }\\n            else{\\n                bool status = false;\\n                // brute force for 1st condition\\n                for(int j = i+1; j<26; j++)\\n                {\\n                    if(v2[i] == v1[j])\\n                    {\\n                        status = true;\\n                       swap(v1[i], v1[j]);\\n                        break;\\n                    }\\n                }\\n                if(!status)\\n                {\\n                    cout<<i<<endl;\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        vector<int> v1(26), v2(26);\\n        for(int i = 0; i< word1.size(); i++)\\n        {\\n            v1[word1[i] - \\'a\\']++;\\n        }\\n        for(int i = 0; i<word2.size(); i++)\\n        {\\n            v2[word2[i] - \\'a\\']++;\\n        }\\n        for(int i = 0; i< 26; i++)\\n        {\\n            if((v1[i] == 0 and v2[i]!=0) or (v1[i] != 0 and v2[i] == 0))\\n            {\\n                return false;\\n            }\\n            if(v1[i] == v2[i])\\n            {\\n                continue;\\n            }\\n            else{\\n                bool status = false;\\n                // brute force for 1st condition\\n                for(int j = i+1; j<26; j++)\\n                {\\n                    if(v2[i] == v1[j])\\n                    {\\n                        status = true;\\n                       swap(v1[i], v1[j]);\\n                        break;\\n                    }\\n                }\\n                if(!status)\\n                {\\n                    cout<<i<<endl;\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2870146,
                "title": "c-easy-o-n-lon-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        sort(word1.begin(), word1.end());\\n        sort(word2.begin(), word2.end());\\n        if(word1 == word2)return true;\\n        map<char, int>mp;\\n        for(auto it : word1){\\n            mp[it]++;\\n        }\\n        vector<int>v1, v2, c1, c2;\\n        for(auto it : mp){\\n            v1.push_back(it.second);\\n            c1.push_back(it.first);\\n        }\\n        mp.clear();\\n        for(auto it : word2){\\n            mp[it]++;\\n        }\\n        for(auto it : mp){\\n            v2.push_back(it.second);\\n            c2.push_back(it.first);\\n        }\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end());\\n        sort(c1.begin(), c1.end());\\n        sort(c2.begin(), c2.end());\\n        return ((v1 == v2) and (c1 == c2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        sort(word1.begin(), word1.end());\\n        sort(word2.begin(), word2.end());\\n        if(word1 == word2)return true;\\n        map<char, int>mp;\\n        for(auto it : word1){\\n            mp[it]++;\\n        }\\n        vector<int>v1, v2, c1, c2;\\n        for(auto it : mp){\\n            v1.push_back(it.second);\\n            c1.push_back(it.first);\\n        }\\n        mp.clear();\\n        for(auto it : word2){\\n            mp[it]++;\\n        }\\n        for(auto it : mp){\\n            v2.push_back(it.second);\\n            c2.push_back(it.first);\\n        }\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end());\\n        sort(c1.begin(), c1.end());\\n        sort(c2.begin(), c2.end());\\n        return ((v1 == v2) and (c1 == c2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870112,
                "title": "c-o-n-easy-to-understand-with-explanation",
                "content": "#### Table of Contents\\n\\n- [TL;DR](#tldr)\\n  - [Code](#code)\\n  - [Complexity](#complexity)\\n- [In Depth Analysis](#in-depth-analysis)\\n  - [Intuition](#intuition)\\n  - [Approach](#approach)\\n  - [Example](#example)\\n\\n# TL;DR\\n\\n* If the words aren\\'t the same size, return `false`\\n* Find the frequency of the characters in each string\\n* If one string has a character that the other doesn\\'t, return `false`\\n* Find the frequencies of all of the frequencies\\n* Return whether the frequencies of frequencies are the same\\n\\n## Code\\n\\n```c++\\n#define LETTER_INDEX(c) (c - \\'a\\')\\n\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if (word1.size() != word2.size()) return false;\\n        const int len = word1.size();\\n\\n        vector<int> word1_char_freq (26, 0), \\n                    word2_char_freq(26, 0);\\n        for (int i = 0; i < len; i++) {\\n            word1_char_freq[LETTER_INDEX(word1[i])]++;\\n            word2_char_freq[LETTER_INDEX(word2[i])]++;\\n        }\\n\\n        unordered_map<int,int> word1_freq_freq, word2_freq_freq;\\n        for (int i = 0; i < 26; i++) {\\n            if ((bool)word1_char_freq[i] ^ (bool)word2_char_freq[i] == 1) return false;\\n            word1_freq_freq[word1_char_freq[i]]++;\\n            word2_freq_freq[word2_char_freq[i]]++;\\n        }\\n\\n        return word1_freq_freq == word2_freq_freq;\\n    }\\n};\\n```\\n\\n## Complexity\\n\\n**Time Complexity:** $$O(N)$$\\n**Space Complexity:** $$O(N)$$\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**\\n\\n---\\n\\n# In Depth Analysis\\n\\n## Intuition\\n\\nWe need to make a couple of observations about the solution; we know that any 2 strings are close if:\\n\\n1. **They both have the same length** --> Since the two operations are swapping and transforming (which is essentially replacing), there is no way to add more characters. Therefore, they must be the same length\\n2. **They have the same characters** --> If they don\\'t have the same characters, then you cannot use the transform operation to make the strings close.\\n\\n   For example, lets say `word1 = \"x\"` and `word2 = \"y\"`. Then there is no operation that can be performed to change the y into an x since by definition, we must \"transform every occurance of one existing character into another **existing** character\". Therefore, they must have the same characters in order to be close.\\n3. **They have the same frequencies** --> In order to use the transform operation effectively, both strings must have the frequency of characters in a string to be the same.\\n\\n   For example, the last test case has `word1 = \"cabbba\"` and `word2 = \"abbccc\"`, we know that there is a characters with frequency of 1, 2, and 3. Since they both have the same frequencies of characters AND the same characters, we know that we can use the second operation to transform characters of one frequency to another character with the same frequency. In this case:\\n   * c can be transformed to be a; \"c\" $$\\\\rightarrow$$ \"a\"\\n   * a can be transformed to be b; \"aa\" $$\\\\rightarrow$$ \"bb\"\\n   * b can be transformed to be c; \"bbb\" $$\\\\rightarrow$$ \"ccc\"\\n\\n## Approach \\n\\nFirst, I want to check if the strings have the same length by comparing their sizes. (Line 6)\\n\\nThen, I want to get the frequencies of each of the characters to be able to check condition 2 and 3 from the intuition. (Line 9-14)\\n\\nOnce we have the frequencies of each character, we need to check that every character in `word1` exists in `word2`. This can be achieved by checking if the frequency of a character in `word1` has a nonzero value in `word2`. This can be accomplished by using the xor operator on booleans (look at the table below) (Line 18)\\n\\n![xor boolean table](https://www.baeldung.com/wp-content/uploads/2019/08/xor_operator_table-1.png)\\n\\nFinally, we need to compare the frequencies from `word1` and `word2` to ensure that condition 3 holds. This can be done with an hash table (`unordered_map`) and just counting the frequencies. Once we count all the frequencies, the two hash tables should be the same in order for the strings to be close (Line 16 - 24)\\n\\n## Example\\n\\nLet\\'s use the third example, where `word1 = \"cabbba\"` and `word2 = \"abbccc\"`\\n\\nThey are the same length, so we can continue\\n\\n* Character Frequency\\n\\nI will not go over this directly, but here is what they would look like:\\n`word1 = [{c: 1, a: 2, b: 3}]`\\n`word2 = [{a: 1, b: 2, c: 3}]`\\n\\n* Frequency of Frequencies\\n\\nThen we want to determine the number of times a certain frequency appears. Here is what that would look like:\\n`word1 = [{1: 1, 2: 2, 3: 3}]`\\n`word2 = [{1: 1, 2: 2, 3: 3}]`\\n\\nSince they are the same, we would return `true` which is the correct answer\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\n#define LETTER_INDEX(c) (c - \\'a\\')\\n\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if (word1.size() != word2.size()) return false;\\n        const int len = word1.size();\\n\\n        vector<int> word1_char_freq (26, 0), \\n                    word2_char_freq(26, 0);\\n        for (int i = 0; i < len; i++) {\\n            word1_char_freq[LETTER_INDEX(word1[i])]++;\\n            word2_char_freq[LETTER_INDEX(word2[i])]++;\\n        }\\n\\n        unordered_map<int,int> word1_freq_freq, word2_freq_freq;\\n        for (int i = 0; i < 26; i++) {\\n            if ((bool)word1_char_freq[i] ^ (bool)word2_char_freq[i] == 1) return false;\\n            word1_freq_freq[word1_char_freq[i]]++;\\n            word2_freq_freq[word2_char_freq[i]]++;\\n        }\\n\\n        return word1_freq_freq == word2_freq_freq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869842,
                "title": "my-ugly-java-code",
                "content": "```\\n//since we can swap two elements ,any permutation can be made if both strings has same letters\\n//and also we can swap freq of any two elements so if we have all required letters and\\n//also the desired freq then by swapping any word1 can be converted to word2 and vice versa\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n     if(word1.length()!=word2.length())\\n         return false;\\n     HashMap<Character,Integer> hm1=new HashMap<>();\\n     for(char ch:word1.toCharArray())\\n     {\\n         hm1.put(ch,hm1.getOrDefault(ch,0)+1);\\n     }\\n     HashMap<Character,Integer> hm2=new HashMap<>();\\n     for(char ch:word2.toCharArray())\\n     {\\n         hm2.put(ch,hm2.getOrDefault(ch,0)+1);\\n     }\\n     //both has same characters\\n     for(char ch:word1.toCharArray())\\n     {\\n         if(hm2.containsKey(ch)==false)\\n             return false;\\n     }\\n     for(char ch:word2.toCharArray())\\n     {\\n         if(hm1.containsKey(ch)==false)\\n             return false;\\n     }\\n     HashMap<Integer,Integer> hm3=new HashMap<>();  \\n     for(char ch:hm1.keySet())\\n     {\\n         int freq=hm1.get(ch);\\n         hm3.put(freq,hm3.getOrDefault(freq,0)+1);\\n     }\\n     HashMap<Integer,Integer> hm4=new HashMap<>();  \\n     for(char ch:hm2.keySet())\\n     {\\n         int freq=hm2.get(ch);\\n         hm4.put(freq,hm4.getOrDefault(freq,0)+1);\\n     }\\n     //both has same frequencies\\n     for(int ch:hm3.keySet())\\n     {\\n         if(hm4.containsKey(ch)==false)\\n             return false;\\n         if(hm3.get(ch)!=hm4.get(ch))\\n             return false;\\n     }\\n     for(int ch:hm4.keySet())\\n     {\\n         if(hm3.containsKey(ch)==false)\\n             return false;\\n         if(hm3.get(ch)!=hm4.get(ch))\\n             return false;\\n     }\\n     return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//since we can swap two elements ,any permutation can be made if both strings has same letters\\n//and also we can swap freq of any two elements so if we have all required letters and\\n//also the desired freq then by swapping any word1 can be converted to word2 and vice versa\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n     if(word1.length()!=word2.length())\\n         return false;\\n     HashMap<Character,Integer> hm1=new HashMap<>();\\n     for(char ch:word1.toCharArray())\\n     {\\n         hm1.put(ch,hm1.getOrDefault(ch,0)+1);\\n     }\\n     HashMap<Character,Integer> hm2=new HashMap<>();\\n     for(char ch:word2.toCharArray())\\n     {\\n         hm2.put(ch,hm2.getOrDefault(ch,0)+1);\\n     }\\n     //both has same characters\\n     for(char ch:word1.toCharArray())\\n     {\\n         if(hm2.containsKey(ch)==false)\\n             return false;\\n     }\\n     for(char ch:word2.toCharArray())\\n     {\\n         if(hm1.containsKey(ch)==false)\\n             return false;\\n     }\\n     HashMap<Integer,Integer> hm3=new HashMap<>();  \\n     for(char ch:hm1.keySet())\\n     {\\n         int freq=hm1.get(ch);\\n         hm3.put(freq,hm3.getOrDefault(freq,0)+1);\\n     }\\n     HashMap<Integer,Integer> hm4=new HashMap<>();  \\n     for(char ch:hm2.keySet())\\n     {\\n         int freq=hm2.get(ch);\\n         hm4.put(freq,hm4.getOrDefault(freq,0)+1);\\n     }\\n     //both has same frequencies\\n     for(int ch:hm3.keySet())\\n     {\\n         if(hm4.containsKey(ch)==false)\\n             return false;\\n         if(hm3.get(ch)!=hm4.get(ch))\\n             return false;\\n     }\\n     for(int ch:hm4.keySet())\\n     {\\n         if(hm3.containsKey(ch)==false)\\n             return false;\\n         if(hm3.get(ch)!=hm4.get(ch))\\n             return false;\\n     }\\n     return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869747,
                "title": "typescript-using-map-set-array-and-sort-o-nlogn-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInstead of thinking how to swap the characters, which is kind of really hard or impossible in my opinion, since combinations of n characters are $$n!$$, you should think of another way, think in what kind of conditions, that can be true or false. For example when the strings are of different length, it should return false.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing logic, we list out all the possible logical ways this can either be true or false.\\n1. Length of two strings must be equal\\n2. They should not contain different characters, they must have the same characters, the number of occurences or the count of each character does not matter.\\n3. The two arrays `arr1` and `arr2` of character occurence\\'s count, when sorted, should be equal.\\n# Complexity\\n- Time complexity:$$O(nlogn)$$ since we have a sorting, all the other operations are of $$O(n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction closeStrings(word1: string, word2: string): boolean {\\n    if (word1.length !== word2.length) return false;\\n\\n    const length = word1.length;\\n    const map1 = new Map<string, number>();\\n    const map2 = new Map<string, number>();\\n    const set1 = new Set<string>(word1.split(\\'\\'));\\n    for (let i = 0; i < length; i++) {\\n        map1.set(\\n            word1[i], \\n            map1.has(word1[i]) ? map1.get(word1[i]) + 1: 1\\n        ) \\n        map2.set(\\n            word2[i], \\n            map2.has(word2[i]) ? map2.get(word2[i]) + 1: 1\\n        )\\n        if (!set1.has(word2[i])) return false;\\n    }\\n\\n    const arr1 = Array.from(map1.values()).sort();\\n    const arr2 = Array.from(map2.values()).sort();\\n    for (let i = 0; i < arr1.length; i++) {\\n        if (arr1[i] !== arr2[i]) return false;\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction closeStrings(word1: string, word2: string): boolean {\\n    if (word1.length !== word2.length) return false;\\n\\n    const length = word1.length;\\n    const map1 = new Map<string, number>();\\n    const map2 = new Map<string, number>();\\n    const set1 = new Set<string>(word1.split(\\'\\'));\\n    for (let i = 0; i < length; i++) {\\n        map1.set(\\n            word1[i], \\n            map1.has(word1[i]) ? map1.get(word1[i]) + 1: 1\\n        ) \\n        map2.set(\\n            word2[i], \\n            map2.has(word2[i]) ? map2.get(word2[i]) + 1: 1\\n        )\\n        if (!set1.has(word2[i])) return false;\\n    }\\n\\n    const arr1 = Array.from(map1.values()).sort();\\n    const arr2 = Array.from(map2.values()).sort();\\n    for (let i = 0; i < arr1.length; i++) {\\n        if (arr1[i] !== arr2[i]) return false;\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2869627,
                "title": "python-solution-using-set",
                "content": "# Code\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        def fun(word):\\n            return sorted(collections.Counter(word).values())\\n        return fun(word1) == fun(word2) and set(word1)==set(word2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        def fun(word):\\n            return sorted(collections.Counter(word).values())\\n        return fun(word1) == fun(word2) and set(word1)==set(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869604,
                "title": "java-easy-treemap",
                "content": "\\t public boolean closeStrings(String word1, String word2) {\\n\\t\\t\\tif(word1.length()!=word2.length())return false;\\n\\t\\t\\tTreeMap<Character,Integer> map = new TreeMap<>();\\n\\t\\t\\tTreeMap<Character,Integer> map2 = new TreeMap<>();\\n\\t\\t\\tfor(int i=0;i<word1.length();i++){\\n\\t\\t\\t\\tmap.put(word1.charAt(i),map.getOrDefault(word1.charAt(i),0)+1);\\n\\t\\t\\t\\tmap2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i),0)+1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tList<Integer> list1 = new ArrayList<>(map.values());\\n\\t\\t\\tList<Integer> list2 = new ArrayList<>(map2.values());\\n\\t\\t\\tCollections.sort(list1);\\n\\t\\t\\tCollections.sort(list2);\\n\\t\\t\\tif(list1.equals(list2) && map.keySet().equals(map2.keySet()))return true;\\n\\n\\t\\t\\treturn false;\\n\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\t public boolean closeStrings(String word1, String word2) {\\n\\t\\t\\tif(word1.length()!=word2.length())return false;\\n\\t\\t\\tTreeMap<Character,Integer> map = new TreeMap<>();\\n\\t\\t\\tTreeMap<Character,Integer> map2 = new TreeMap<>();\\n\\t\\t\\tfor(int i=0;i<word1.length();i++){\\n\\t\\t\\t\\tmap.put(word1.charAt(i),map.getOrDefault(word1.charAt(i),0)+1);\\n\\t\\t\\t\\tmap2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i),0)+1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tList<Integer> list1 = new ArrayList<>(map.values());\\n\\t\\t\\tList<Integer> list2 = new ArrayList<>(map2.values());\\n\\t\\t\\tCollections.sort(list1);\\n\\t\\t\\tCollections.sort(list2);\\n\\t\\t\\tif(list1.equals(list2) && map.keySet().equals(map2.keySet()))return true;\\n\\n\\t\\t\\treturn false;\\n\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2869601,
                "title": "java-simple-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean closeStrings(String w1, String w2) {\\n        if(w1.length()!=w2. length()) return false;\\n        \\n        int[] s1=new int[26];\\n        int[] s2=new int[26];\\n        int[] c1=new int[26];\\n        int[] c2=new int[26];\\n        \\n        for(int i=0;i<w1.length();i++){\\n          char ch=w1.charAt(i);\\n          s1[ch-\\'a\\']++;\\n          c1[ch-\\'a\\']=1;\\n        }\\n        for(int i=0;i<w2.length();i++){\\n          char ch=w2.charAt(i);\\n          s2[ch-\\'a\\']++;\\n          c2[ch-\\'a\\']=1;\\n        }\\n        Arrays.sort(s1);\\n        Arrays.sort(s2);\\n        return Arrays.equals(s1,s2) && Arrays.equals(c1,c2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String w1, String w2) {\\n        if(w1.length()!=w2. length()) return false;\\n        \\n        int[] s1=new int[26];\\n        int[] s2=new int[26];\\n        int[] c1=new int[26];\\n        int[] c2=new int[26];\\n        \\n        for(int i=0;i<w1.length();i++){\\n          char ch=w1.charAt(i);\\n          s1[ch-\\'a\\']++;\\n          c1[ch-\\'a\\']=1;\\n        }\\n        for(int i=0;i<w2.length();i++){\\n          char ch=w2.charAt(i);\\n          s2[ch-\\'a\\']++;\\n          c2[ch-\\'a\\']=1;\\n        }\\n        Arrays.sort(s1);\\n        Arrays.sort(s2);\\n        return Arrays.equals(s1,s2) && Arrays.equals(c1,c2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869559,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n     if(word1.length()!=word2.length()) return false;\\n     Map<Character,Integer> word1Frequency=new HashMap<>();\\n     Map<Character,Integer> word2Frequency=new HashMap<>();\\n      // frequency of word1  \\n     for(char c:word1.toCharArray()){\\n       word1Frequency.put(c,word1Frequency.getOrDefault(c,0)+1);\\n     }\\n      // frequency of word 2  \\n     for(char c:word2.toCharArray()){\\n       word2Frequency.put(c,word2Frequency.getOrDefault(c,0)+1);\\n     }\\n      \\n     if(!word1Frequency.keySet().equals(word2Frequency.keySet())){\\n         return false;\\n     }\\n     // convert map values to arraylist\\n     List<Integer> word1FrequencyList=new ArrayList<>(word1Frequency.values()) ;\\n     List<Integer> word2FrequencyList=new ArrayList<>(word2Frequency.values()) ;\\n        \\n      Collections.sort(word1FrequencyList);\\n      Collections.sort(word2FrequencyList);\\n        \\n        return word1FrequencyList.equals(word2FrequencyList);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n     if(word1.length()!=word2.length()) return false;\\n     Map<Character,Integer> word1Frequency=new HashMap<>();\\n     Map<Character,Integer> word2Frequency=new HashMap<>();\\n      // frequency of word1  \\n     for(char c:word1.toCharArray()){\\n       word1Frequency.put(c,word1Frequency.getOrDefault(c,0)+1);\\n     }\\n      // frequency of word 2  \\n     for(char c:word2.toCharArray()){\\n       word2Frequency.put(c,word2Frequency.getOrDefault(c,0)+1);\\n     }\\n      \\n     if(!word1Frequency.keySet().equals(word2Frequency.keySet())){\\n         return false;\\n     }\\n     // convert map values to arraylist\\n     List<Integer> word1FrequencyList=new ArrayList<>(word1Frequency.values()) ;\\n     List<Integer> word2FrequencyList=new ArrayList<>(word2Frequency.values()) ;\\n        \\n      Collections.sort(word1FrequencyList);\\n      Collections.sort(word2FrequencyList);\\n        \\n        return word1FrequencyList.equals(word2FrequencyList);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869384,
                "title": "python-o-n-simple-solution",
                "content": "# Intuition\\nTo solve this problem we need to figure out whether we can derive one string from another. To do that according to the rules (swap and substitution) there are two pieces requred:\\n1. the same set of letters (we cannot introduce new letters)\\n2. the same number of appearance among all charaters (so we can swap them)\\n\\n# Approach\\n1. build a has map to count characters `char:num_of_occurrences`\\n2. compare the keys (characters are the same in both strings)\\n3. compare the values (the same numbers are presented in both strings)\\n\\n**see the example:**\\n\\n`word1 = \"cabbba\", word2 = \"abbccc\"`\\n\\n| character (word1)  | number of occurrences (word1) | character (word2)  | number of occurrences (word2) |\\n|---|---|---|---|\\n| c | 1 | a | 1 |\\n| a | 2 | b | 2 |\\n| b | 3 | c | 3 |\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n\\n        cnt1 = Counter(word1)\\n        cnt2 = Counter(word2)\\n\\n        v1 = list(cnt1.values())\\n        v1.sort()\\n        v2 = list(cnt2.values())\\n        v2.sort()\\n\\n        if v1 != v2:\\n            return False\\n\\n        v1 = list(cnt1.keys())\\n        v1.sort()\\n        v2 = list(cnt2.keys())\\n        v2.sort()\\n\\n        return  v1 == v2\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n\\n        cnt1 = Counter(word1)\\n        cnt2 = Counter(word2)\\n\\n        v1 = list(cnt1.values())\\n        v1.sort()\\n        v2 = list(cnt2.values())\\n        v2.sort()\\n\\n        if v1 != v2:\\n            return False\\n\\n        v1 = list(cnt1.keys())\\n        v1.sort()\\n        v2 = list(cnt2.keys())\\n        v2.sort()\\n\\n        return  v1 == v2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869266,
                "title": "simple-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int le1=word1.length();\\n        int le2=word2.length();\\n        if(le1!=le2){\\n            System.out.println(\"ERR1\");\\n            return false;\\n        }\\n        else{\\n            ArrayList<pair> li1=fre(word1);\\n            ArrayList<pair> li2=fre(word2);\\n            System.out.println(li1.size()+\" \"+li2.size());\\n            if(li1.size()!=li2.size()){\\n                System.out.println(\"ERR2\");\\n                return false;\\n            }\\n            else{\\n                int[] fre1=sortfre(li1);\\n                int[] fre2=sortfre(li2);\\n                for(int i=0;i<fre1.length;i++){\\n                    if(fre1[i]!=fre2[i]){\\n                        System.out.println(\"ERR3\");\\n                        return false;\\n                    }\\n                }\\n                int[] data1=sortdata(li1);\\n                int[] data2=sortdata(li2);\\n                for(int i=0;i<data1.length;i++){\\n                    if(data1[i]!=data2[i]){\\n                        System.out.println(\"ERR4\");\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public int[] sortfre(ArrayList<pair> lis){\\n        int[] arr=new int[lis.size()];\\n        for(int i=0;i<lis.size();i++){\\n            arr[i]=lis.get(i).fre;\\n        }\\n        Arrays.sort(arr);\\n        return arr;\\n    }\\n     public int[] sortdata(ArrayList<pair> lis){\\n        int[] arr=new int[lis.size()];\\n        for(int i=0;i<lis.size();i++){\\n            arr[i]=lis.get(i).data;\\n        }\\n        Arrays.sort(arr);\\n        return arr;\\n    }\\n    public ArrayList<pair> fre(String Word1){\\n        ArrayList<pair> out=new ArrayList<>();\\n        for(int i=0;i<Word1.length();i++){\\n            int el=Word1.charAt(i)-\\'a\\';\\n            int fl=0;\\n            for(int j=0;j<out.size();j++){\\n                pair temp=out.get(j);\\n                int val=temp.data;\\n                if(val==el){\\n                    out.get(j).fre++;\\n                    fl=1;\\n                    break;\\n                }\\n            }\\n            if(fl==0){\\n                pair ad=new pair(el,1);\\n                out.add(ad);\\n            }\\n        }\\n        return out;\\n    }\\n\\n}\\nclass pair{\\n    int data;\\n    int fre;\\n    pair(int data,int fre){\\n        this.data=data;\\n        this.fre=fre;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int le1=word1.length();\\n        int le2=word2.length();\\n        if(le1!=le2){\\n            System.out.println(\"ERR1\");\\n            return false;\\n        }\\n        else{\\n            ArrayList<pair> li1=fre(word1);\\n            ArrayList<pair> li2=fre(word2);\\n            System.out.println(li1.size()+\" \"+li2.size());\\n            if(li1.size()!=li2.size()){\\n                System.out.println(\"ERR2\");\\n                return false;\\n            }\\n            else{\\n                int[] fre1=sortfre(li1);\\n                int[] fre2=sortfre(li2);\\n                for(int i=0;i<fre1.length;i++){\\n                    if(fre1[i]!=fre2[i]){\\n                        System.out.println(\"ERR3\");\\n                        return false;\\n                    }\\n                }\\n                int[] data1=sortdata(li1);\\n                int[] data2=sortdata(li2);\\n                for(int i=0;i<data1.length;i++){\\n                    if(data1[i]!=data2[i]){\\n                        System.out.println(\"ERR4\");\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public int[] sortfre(ArrayList<pair> lis){\\n        int[] arr=new int[lis.size()];\\n        for(int i=0;i<lis.size();i++){\\n            arr[i]=lis.get(i).fre;\\n        }\\n        Arrays.sort(arr);\\n        return arr;\\n    }\\n     public int[] sortdata(ArrayList<pair> lis){\\n        int[] arr=new int[lis.size()];\\n        for(int i=0;i<lis.size();i++){\\n            arr[i]=lis.get(i).data;\\n        }\\n        Arrays.sort(arr);\\n        return arr;\\n    }\\n    public ArrayList<pair> fre(String Word1){\\n        ArrayList<pair> out=new ArrayList<>();\\n        for(int i=0;i<Word1.length();i++){\\n            int el=Word1.charAt(i)-\\'a\\';\\n            int fl=0;\\n            for(int j=0;j<out.size();j++){\\n                pair temp=out.get(j);\\n                int val=temp.data;\\n                if(val==el){\\n                    out.get(j).fre++;\\n                    fl=1;\\n                    break;\\n                }\\n            }\\n            if(fl==0){\\n                pair ad=new pair(el,1);\\n                out.add(ad);\\n            }\\n        }\\n        return out;\\n    }\\n\\n}\\nclass pair{\\n    int data;\\n    int fre;\\n    pair(int data,int fre){\\n        this.data=data;\\n        this.fre=fre;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869238,
                "title": "python-beat-99-easy-to-understand",
                "content": "### 1. If two words have the same letters\\n* \\te.g. `word1 = \"abcd\", word2 = \"dcba\"`\\n* \\t\\u27A1\\uFE0F `set(word1) == set(word2)`\\n### 2. And the amount of each letter is the same\\n* e.g. `word1 = \"aaabbc\", word2 = \"abbccc\"`\\n* \\u27A1\\uFE0F`Counter(word1).values() = [3,2,1]` \\n* \\u27A1\\uFE0F`Counter(word2).values() = [1,2,3]`\\n\\nIf we sort [3,2,1] and [1,2,3], we can know they are equivalent.\\n### \\uD83D\\uDC3F\\uFE0F Conclusion:\\nIf and only if the **two condition is fulfilled**, \\n\\twe can *transfer word1 into word2* eventuallty. \\u0669(\\u02CAU\\u02CB*)\\u0B68\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if set(word1) != set(word2): return False\\n        \\n        C1 = Counter(word1)\\n        C2 = Counter(word2)\\n        \\n        L1 = C1.values()\\n        L2 = C2.values()\\n        \\n        return sorted(L1) == sorted(L2)\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if set(word1) != set(word2): return False\\n        \\n        C1 = Counter(word1)\\n        C2 = Counter(word2)\\n        \\n        L1 = C1.values()\\n        L2 = C2.values()\\n        \\n        return sorted(L1) == sorted(L2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869126,
                "title": "javascript-simple-clean-o-n-easy-to-follow-faster-than-99",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {string} word1\\n * @param {string} word2\\n * @return {boolean}\\n */\\nvar closeStrings = function(w1, w2) {\\n    if(w1.length!==w2.length){return false}\\n    const tem1 = Array(26).fill(0)\\n    const tem2 = Array(26).fill(0)\\n    for(let i = 0; i<w1.length;i++){\\n        tem1[w1[i].charCodeAt(0)-97]=(tem1[w1[i].charCodeAt(0)-97] || 0) +1\\n        tem2[w2[i].charCodeAt(0)-97]=(tem2[w2[i].charCodeAt(0)-97] || 0) +1\\n    }\\n    for(let i=0;i<tem1.length;i++){\\n        if((tem1[i]>0 && tem2[i]===0)||(tem2[i]>0 && tem1[i]===0)){\\n            return false\\n        }\\n    }\\n    return tem1.sort((a,b)=>a-b).join(\\'\\')===tem2.sort((a,b)=>a-b).join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} word1\\n * @param {string} word2\\n * @return {boolean}\\n */\\nvar closeStrings = function(w1, w2) {\\n    if(w1.length!==w2.length){return false}\\n    const tem1 = Array(26).fill(0)\\n    const tem2 = Array(26).fill(0)\\n    for(let i = 0; i<w1.length;i++){\\n        tem1[w1[i].charCodeAt(0)-97]=(tem1[w1[i].charCodeAt(0)-97] || 0) +1\\n        tem2[w2[i].charCodeAt(0)-97]=(tem2[w2[i].charCodeAt(0)-97] || 0) +1\\n    }\\n    for(let i=0;i<tem1.length;i++){\\n        if((tem1[i]>0 && tem2[i]===0)||(tem2[i]>0 && tem1[i]===0)){\\n            return false\\n        }\\n    }\\n    return tem1.sort((a,b)=>a-b).join(\\'\\')===tem2.sort((a,b)=>a-b).join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2869101,
                "title": "c-frequency-table-approach-b",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPhysically changing the input array using the operation seems tedious so I use a frequency table.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the no. of occurrence of each alphabets in the input string in a frequency table for alphabets --> find out if the two input strings have the\\nsame letters --> if they do find the no. of occurrence of the numbers in the \"frequency table for alphabets\" and store them in the frequency table for NUMBERS\\nif the two frequency tables for NUMBERS are the same, then two strings are close.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: no idea what this means juz started learning C 4 months ago\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <string.h>\\n#define LONGMAX 999999\\nbool check_letters(long freqTable1[27], long freqTable2[27]) {\\nlong i = 0;\\nbool check = false;\\nwhile (i < 27) {\\n    if ((freqTable1[i] > 0) && (freqTable2[i] > 0)) {\\n        check = true;\\n    }\\n    else if (((freqTable1[i] > 0) && (freqTable2[i] == 0)) || ((freqTable1[i] == 0) && (freqTable2[i] > 0))) {\\n        check = false;\\n        return check;\\n    }\\n    i += 1;\\n}\\nreturn check;\\n}\\n\\nbool closeStrings(char * word1, char * word2) {\\n    long freqTable1[27] = {0};\\n    long freqTable2[27] = {0};\\n    if (strlen(word1) != strlen(word2)) {\\n    return false;\\n    }\\n    long i = 0;\\n    while (i < strlen(word1)) {\\n        long num1 = word1[i] - 97;\\n        long num2 = word2[i] - 97;\\n        freqTable1[num1] += 1;\\n        freqTable2[num2] += 1;\\n        i += 1;\\n    }\\n    long j = 0;\\n    long numfreqTable1[LONGMAX] = {0};\\n    long numfreqTable2[LONGMAX] = {0};\\n    if (check_letters(freqTable1, freqTable2) == true) {\\n    while (j < 27) {\\n        numfreqTable1[freqTable1[j]] += 1;\\n        numfreqTable2[freqTable2[j]] += 1;\\n        j += 1;\\n    }\\n    long k = 0;\\n    bool check = false;\\n    while (k < LONGMAX) {\\n        if (numfreqTable1[k] == numfreqTable2[k]) {\\n            k += 1;\\n            check = true;\\n        }\\n        else {\\n            check = false;\\n            return check;\\n        }\\n    }\\n    return check;\\n    }\\n    else {\\n        return false;\\n    }\\n    \\n}\\n  \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <string.h>\\n#define LONGMAX 999999\\nbool check_letters(long freqTable1[27], long freqTable2[27]) {\\nlong i = 0;\\nbool check = false;\\nwhile (i < 27) {\\n    if ((freqTable1[i] > 0) && (freqTable2[i] > 0)) {\\n        check = true;\\n    }\\n    else if (((freqTable1[i] > 0) && (freqTable2[i] == 0)) || ((freqTable1[i] == 0) && (freqTable2[i] > 0))) {\\n        check = false;\\n        return check;\\n    }\\n    i += 1;\\n}\\nreturn check;\\n}\\n\\nbool closeStrings(char * word1, char * word2) {\\n    long freqTable1[27] = {0};\\n    long freqTable2[27] = {0};\\n    if (strlen(word1) != strlen(word2)) {\\n    return false;\\n    }\\n    long i = 0;\\n    while (i < strlen(word1)) {\\n        long num1 = word1[i] - 97;\\n        long num2 = word2[i] - 97;\\n        freqTable1[num1] += 1;\\n        freqTable2[num2] += 1;\\n        i += 1;\\n    }\\n    long j = 0;\\n    long numfreqTable1[LONGMAX] = {0};\\n    long numfreqTable2[LONGMAX] = {0};\\n    if (check_letters(freqTable1, freqTable2) == true) {\\n    while (j < 27) {\\n        numfreqTable1[freqTable1[j]] += 1;\\n        numfreqTable2[freqTable2[j]] += 1;\\n        j += 1;\\n    }\\n    long k = 0;\\n    bool check = false;\\n    while (k < LONGMAX) {\\n        if (numfreqTable1[k] == numfreqTable2[k]) {\\n            k += 1;\\n            check = true;\\n        }\\n        else {\\n            check = false;\\n            return check;\\n        }\\n    }\\n    return check;\\n    }\\n    else {\\n        return false;\\n    }\\n    \\n}\\n  \\n```",
                "codeTag": "C++"
            },
            {
                "id": 2869045,
                "title": "c-easy-and-readable-solution-time-o-n-space-26-26",
                "content": "```\\nclass Solution {\\npublic:\\n    const int sizeOfAlphabet=26;\\n    bool closeStrings(string word1, string word2) {\\n        int sizeOfWord1 = word1.size();\\n        int sizeOfWord2 = word2.size();\\n        int seen1=0,seen2=0;\\n        vector<int> charFrequenciesOfWord1(sizeOfAlphabet, 0);\\n        vector<int> charFrequenciesOfWord2(sizeOfAlphabet, 0);\\n        \\n        if(sizeOfWord1 != sizeOfWord2)\\n        {\\n            return false;\\n        }\\n\\n        for(int i = 0; i < sizeOfWord1; i++)\\n        {\\n            charFrequenciesOfWord1[word1[i]-97]++;\\n            charFrequenciesOfWord2[word2[i]-97]++;\\n            seen1|=(1 << word1[i] - 97);\\n            seen2|=(1 << word2[i] - 97);          \\n        }\\n\\n        sort(begin(charFrequenciesOfWord1),end(charFrequenciesOfWord1));\\n        sort(begin(charFrequenciesOfWord2),end(charFrequenciesOfWord2));\\n        \\n        return charFrequenciesOfWord1==charFrequenciesOfWord2 && seen1==seen2;\\n    }\\n};\\n```\\nif u like the sol pls UPVOTE",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int sizeOfAlphabet=26;\\n    bool closeStrings(string word1, string word2) {\\n        int sizeOfWord1 = word1.size();\\n        int sizeOfWord2 = word2.size();\\n        int seen1=0,seen2=0;\\n        vector<int> charFrequenciesOfWord1(sizeOfAlphabet, 0);\\n        vector<int> charFrequenciesOfWord2(sizeOfAlphabet, 0);\\n        \\n        if(sizeOfWord1 != sizeOfWord2)\\n        {\\n            return false;\\n        }\\n\\n        for(int i = 0; i < sizeOfWord1; i++)\\n        {\\n            charFrequenciesOfWord1[word1[i]-97]++;\\n            charFrequenciesOfWord2[word2[i]-97]++;\\n            seen1|=(1 << word1[i] - 97);\\n            seen2|=(1 << word2[i] - 97);          \\n        }\\n\\n        sort(begin(charFrequenciesOfWord1),end(charFrequenciesOfWord1));\\n        sort(begin(charFrequenciesOfWord2),end(charFrequenciesOfWord2));\\n        \\n        return charFrequenciesOfWord1==charFrequenciesOfWord2 && seen1==seen2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868981,
                "title": "java-solution-beats-97-78",
                "content": "**If you found it easy to understand, Please do upvote :)\\nThankyou!!**\\n**---------------------------------------------------------------------------------------------------------------**\\n![image](https://assets.leetcode.com/users/images/f62357b9-df3e-467a-a5e0-cb7e7808c265_1669964344.2036004.jpeg)\\n\\n**---------------------------------------------------------------------------------------------------------------**\\n```\\nclass Solution \\n{\\n    public boolean closeStrings(String word1, String word2) \\n    {\\n        if(word1.length() != word2.length()) return false;\\n        \\n        char[] chArray1 = word1.toCharArray();\\n        char[] chArray2 = word2.toCharArray();\\n        \\n        int[] freq1 = new int[26];\\n        int[] freq2 = new int[26];\\n        \\n        calculateFrequency(chArray1, freq1);\\n        calculateFrequency(chArray2, freq2);\\n        \\n        if(validateForOperation1(freq1, freq2)) return true;\\n        \\n\\t\\t//Below is the validation for Operation-2\\n\\t\\t\\n\\t\\t//Operation 2 allows you to freely reassign the letters\\' frequencies.\\n\\t\\t\\n        for(int i=0; i<26; i++)\\n        {\\n            if((freq1[i]!=0 && freq2[i]==0) || (freq2[i]==0 && freq2[i]!=0))\\n                return false;            \\n        }\\n        \\n        Arrays.sort(freq1);\\n        Arrays.sort(freq2);\\n        \\n        for(int i=0; i<26; i++)\\n        {\\n            if(freq1[i] != freq2[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean validateForOperation1(int[] freq1, int[] freq2)\\n    {\\n\\t\\t//Operation 1 allows you to freely reorder the string.\\n\\t\\t//Hence, after Re-Order, the frequency must be same.\\n        for(int i=0; i<26; i++)\\n        {\\n            if(freq1[i] != freq2[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public void calculateFrequency(char[] chArray, int[] freq)\\n    {\\n        for(int i=0; i<chArray.length; i++)\\n        {\\n            int IndexFromAlphabet = chArray[i]-\\'a\\';\\n            freq[IndexFromAlphabet]++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean closeStrings(String word1, String word2) \\n    {\\n        if(word1.length() != word2.length()) return false;\\n        \\n        char[] chArray1 = word1.toCharArray();\\n        char[] chArray2 = word2.toCharArray();\\n        \\n        int[] freq1 = new int[26];\\n        int[] freq2 = new int[26];\\n        \\n        calculateFrequency(chArray1, freq1);\\n        calculateFrequency(chArray2, freq2);\\n        \\n        if(validateForOperation1(freq1, freq2)) return true;\\n        \\n\\t\\t//Below is the validation for Operation-2\\n\\t\\t\\n\\t\\t//Operation 2 allows you to freely reassign the letters\\' frequencies.\\n\\t\\t\\n        for(int i=0; i<26; i++)\\n        {\\n            if((freq1[i]!=0 && freq2[i]==0) || (freq2[i]==0 && freq2[i]!=0))\\n                return false;            \\n        }\\n        \\n        Arrays.sort(freq1);\\n        Arrays.sort(freq2);\\n        \\n        for(int i=0; i<26; i++)\\n        {\\n            if(freq1[i] != freq2[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean validateForOperation1(int[] freq1, int[] freq2)\\n    {\\n\\t\\t//Operation 1 allows you to freely reorder the string.\\n\\t\\t//Hence, after Re-Order, the frequency must be same.\\n        for(int i=0; i<26; i++)\\n        {\\n            if(freq1[i] != freq2[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public void calculateFrequency(char[] chArray, int[] freq)\\n    {\\n        for(int i=0; i<chArray.length; i++)\\n        {\\n            int IndexFromAlphabet = chArray[i]-\\'a\\';\\n            freq[IndexFromAlphabet]++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868916,
                "title": "java-o-nlogn-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(N\\xB7log(N))\\n\\n- Space complexity:\\nO(2N) + O(2N) = O(4N) ------> { 2 Hashmap + 2 arrayList }\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int len1 = word1.length();\\n        int len2 = word2.length();\\n        if (len1 != len2) return false;\\n        Map<Character, Integer> hm1 = new HashMap();\\n        Map<Character, Integer> hm2 = new HashMap();\\n        ArrayList<Integer> a = new ArrayList();\\n        ArrayList<Integer> b = new ArrayList();\\n\\n        for(int i = 0; i < len1; i++) {\\n            hm1.put(word1.charAt(i), 1+hm1.getOrDefault(word1.charAt(i), 0));\\n        }\\n        \\n        for(int i  = 0; i < len1; i++) {\\n            if(hm1.containsKey(word2.charAt(i))) {\\n                hm2.put(word2.charAt(i), 1+hm2.getOrDefault(word2.charAt(i), 0));\\n            } else {\\n                return false;\\n            }\\n        }\\n\\n        // add frequency(values) from maps to arrays \\n        a = new ArrayList(hm1.values());\\n        b = new ArrayList(hm2.values());\\n\\n        Collections.sort(a);\\n        Collections.sort(b);\\n\\n        return a.equals(b);\\n    }\\n}\\n```\\n\\nthanks to @kaushambi2612 for pointing \\n```\\n// add frequency(values) from maps to arrays \\na = new ArrayList(hm1.values());\\nb = new ArrayList(hm2.values());\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int len1 = word1.length();\\n        int len2 = word2.length();\\n        if (len1 != len2) return false;\\n        Map<Character, Integer> hm1 = new HashMap();\\n        Map<Character, Integer> hm2 = new HashMap();\\n        ArrayList<Integer> a = new ArrayList();\\n        ArrayList<Integer> b = new ArrayList();\\n\\n        for(int i = 0; i < len1; i++) {\\n            hm1.put(word1.charAt(i), 1+hm1.getOrDefault(word1.charAt(i), 0));\\n        }\\n        \\n        for(int i  = 0; i < len1; i++) {\\n            if(hm1.containsKey(word2.charAt(i))) {\\n                hm2.put(word2.charAt(i), 1+hm2.getOrDefault(word2.charAt(i), 0));\\n            } else {\\n                return false;\\n            }\\n        }\\n\\n        // add frequency(values) from maps to arrays \\n        a = new ArrayList(hm1.values());\\n        b = new ArrayList(hm2.values());\\n\\n        Collections.sort(a);\\n        Collections.sort(b);\\n\\n        return a.equals(b);\\n    }\\n}\\n```\n```\\n// add frequency(values) from maps to arrays \\na = new ArrayList(hm1.values());\\nb = new ArrayList(hm2.values());\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868868,
                "title": "easy-solution-using-hints-with-explanation-c",
                "content": "### Solution according to hints given by LeetCode: \\uD83D\\uDE80\\n\\n#### Hint 1: \\u2728\\n**Operation 1 allows you to freely reorder the string.** (means if frequency of each charactor is same in both strings then we can reorder the string1 so that it converts to string2)\\n    \\n\\n```\\nexample1:\\n    word1 = xyxz (x=2, y=1, z=1)\\n    word2 = xxzy (x=2, y=1, z=1)\\n\\n\\t-> As we can see in above example frequency of each character is same (both strings conatains 2 x\\'s, 1 y\\'s and 1 z\\'s) \\n\\t-> by reordering of characters we can convert string1 into string2\\n\\n   Answer = TRUE\\n```\\n\\n#### Hint 2: \\u2728\\n**Operation 2 allows you to freely reassign the letters\\' frequencies.**(if the frequency array is same for both strings then by reassigning the frequency we can convert string1 into string2. but both strings should contain same letters)\\n\\n```\\nexample1:(same frequency array)\\n\\tword1 = aacabb (a=3, c=1, b=2)\\n\\tword2 = bbcbaa (a=2, c=1, b=3)\\n\\t\\n\\t-> In above example frequency array is same (1,2,3) and unique charecters are also same (both strings contains a, b and c)\\n\\t-> In word1 if we reassign freq of a=2 and b=3, word1 will be bbcbaa which equals to word2\\n\\t-> So by operation 2 we can convert string1 into string2 \\n\\t\\n\\tAnswer = TRUE\\n```\\n\\n```\\nexample2: (same freq array but not same unique characters)\\n    word1 = uau (u=2, a=1)\\n    word2 = ssx (s=2, x=1)\\n\\t\\n    -> As we can see in above example freq array is same (1,2) but unique characters in both strings are not same (word1 contains u & a, word2 contains s & x)\\n    -> for this example we can\\'t convert string1 to string2 by reassigning the freq.\\n\\t\\n    Answer = FALSE\\n```\\n\\n##### Code: \\uD83E\\uDD29\\n\\n    bool closeStrings(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        \\n        //edge case if size is not same\\n        if(n != m){\\n            return false;\\n        } \\n        \\n        \\n        unordered_map<char, int> mp1;\\n        unordered_map<char, int> mp2;\\n        for(int i=0; i<n; i++){\\n            mp1[word1[i]]++; \\n            mp2[word2[i]]++;\\n        }\\n        \\n\\n        //checking if we can convert string1 to string2 by operation1 (for details see above explanation about Hint1)\\n         if (mp1.size() == mp2.size() && std::equal(mp1.begin(), mp1.end(), mp2.begin())){\\n            return true;\\n        }\\n        \\n        \\n        //checking if we can convert string1 to string2 by operation2 (for details see above explanation about Hint2)\\n        \\n        //before checking for operation2 check if unique characters are same in both strings (Why? see the example2 of Hint2)\\n        for(int i=0; i<n; i++){\\n            if(mp1[word2[i]] == 0)\\n                return false;\\n            if(mp2[word1[i]] == 0)\\n                return false;\\n        }\\n        \\n        //checking frequency array of both strings with same unique characters \\n        unordered_map<int,int> freq1;\\n        for(auto x : mp1){\\n            freq1[x.second]++;\\n        }\\n        \\n        for(auto y : mp2){\\n            if(freq1.find(y.second) == freq1.end()){\\n                return false;\\n            }else{\\n                freq1[y.second]--;\\n                if(freq1[y.second] <= 0)\\n                    freq1.erase(y.second);\\n            }\\n        }\\n        \\n        \\n        \\n        return true;\\n        \\n        \\n    }\\n\\t\\n\\t\\n**Time Complexity: O(N)\\nSpace Complexity: O(N)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nexample1:\\n    word1 = xyxz (x=2, y=1, z=1)\\n    word2 = xxzy (x=2, y=1, z=1)\\n\\n\\t-> As we can see in above example frequency of each character is same (both strings conatains 2 x\\'s, 1 y\\'s and 1 z\\'s) \\n\\t-> by reordering of characters we can convert string1 into string2\\n\\n   Answer = TRUE\\n```\n```\\nexample1:(same frequency array)\\n\\tword1 = aacabb (a=3, c=1, b=2)\\n\\tword2 = bbcbaa (a=2, c=1, b=3)\\n\\t\\n\\t-> In above example frequency array is same (1,2,3) and unique charecters are also same (both strings contains a, b and c)\\n\\t-> In word1 if we reassign freq of a=2 and b=3, word1 will be bbcbaa which equals to word2\\n\\t-> So by operation 2 we can convert string1 into string2 \\n\\t\\n\\tAnswer = TRUE\\n```\n```\\nexample2: (same freq array but not same unique characters)\\n    word1 = uau (u=2, a=1)\\n    word2 = ssx (s=2, x=1)\\n\\t\\n    -> As we can see in above example freq array is same (1,2) but unique characters in both strings are not same (word1 contains u & a, word2 contains s & x)\\n    -> for this example we can\\'t convert string1 to string2 by reassigning the freq.\\n\\t\\n    Answer = FALSE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868815,
                "title": "java-solution-sorting-hashtable",
                "content": "# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length() != word2.length())\\n            return false;\\n\\n        HashMap<Character, Integer> hm1 = new HashMap<>();\\n        HashMap<Character, Integer> hm2 = new HashMap<>();\\n\\n        for(int i = 0 ; i < word1.length(); i++){\\n            hm1.put(word1.charAt(i), hm1.getOrDefault(word1.charAt(i), 0)+1);\\n            hm2.put(word2.charAt(i), hm2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n\\n        int[] arr1 = new int[hm1.size()];\\n        int[] arr2 = new int[hm2.size()];\\n        char[] ch1 = new char[hm1.size()];\\n        char[] ch2 = new char[hm2.size()];\\n        int k = 0;\\n\\n        for(Integer value : hm1.values()){\\n            arr1[k] = value;\\n            k++;\\n        }\\n\\n        k = 0;\\n\\n        for(Character value : hm1.keySet()){\\n            ch1[k] = value;\\n            k++;\\n        }\\n\\n        k = 0;\\n\\n        for(Integer value : hm2.values()){\\n            arr2[k] = value;\\n            k++;\\n        }\\n\\n        k = 0;\\n\\n        for(Character value : hm2.keySet()){\\n            ch2[k] = value;\\n            k++;\\n        }\\n\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n        Arrays.sort(ch1);\\n        Arrays.sort(ch2);\\n\\n        for(int i = 0 ; i < arr1.length; i++)\\n            if(arr1[i] != arr2[i] || ch1[i] != ch2[i])\\n                return false;\\n\\n        return true;\\n    }\\n}\\n// *** UP-VOTE IF HELPFUL ***\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length() != word2.length())\\n            return false;\\n\\n        HashMap<Character, Integer> hm1 = new HashMap<>();\\n        HashMap<Character, Integer> hm2 = new HashMap<>();\\n\\n        for(int i = 0 ; i < word1.length(); i++){\\n            hm1.put(word1.charAt(i), hm1.getOrDefault(word1.charAt(i), 0)+1);\\n            hm2.put(word2.charAt(i), hm2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n\\n        int[] arr1 = new int[hm1.size()];\\n        int[] arr2 = new int[hm2.size()];\\n        char[] ch1 = new char[hm1.size()];\\n        char[] ch2 = new char[hm2.size()];\\n        int k = 0;\\n\\n        for(Integer value : hm1.values()){\\n            arr1[k] = value;\\n            k++;\\n        }\\n\\n        k = 0;\\n\\n        for(Character value : hm1.keySet()){\\n            ch1[k] = value;\\n            k++;\\n        }\\n\\n        k = 0;\\n\\n        for(Integer value : hm2.values()){\\n            arr2[k] = value;\\n            k++;\\n        }\\n\\n        k = 0;\\n\\n        for(Character value : hm2.keySet()){\\n            ch2[k] = value;\\n            k++;\\n        }\\n\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n        Arrays.sort(ch1);\\n        Arrays.sort(ch2);\\n\\n        for(int i = 0 ; i < arr1.length; i++)\\n            if(arr1[i] != arr2[i] || ch1[i] != ch2[i])\\n                return false;\\n\\n        return true;\\n    }\\n}\\n// *** UP-VOTE IF HELPFUL ***\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868605,
                "title": "easy-to-understand-using-maps-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int n1=word1.size();\\n        int n2=word2.size();\\n        if(n1!=n2) return false;\\n        map<int,int>mp1,mp2;\\n        for(auto i:word1)\\n        {\\n            mp1[i]++;\\n        }\\n        for(auto i:word2 )\\n        {\\n            mp2[i]++;\\n        }\\n\\n        for(auto i:word1)\\n        {\\n            if(!mp2[i])return false;\\n        }\\n\\n        vector<int>v1,v2;\\n        for(auto i:mp1)\\n        {\\n            v1.push_back(i.second);\\n\\n        }\\n        for(auto i:mp2)\\n        {\\n            v2.push_back(i.second);\\n        }\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        if(v1==v2) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int n1=word1.size();\\n        int n2=word2.size();\\n        if(n1!=n2) return false;\\n        map<int,int>mp1,mp2;\\n        for(auto i:word1)\\n        {\\n            mp1[i]++;\\n        }\\n        for(auto i:word2 )\\n        {\\n            mp2[i]++;\\n        }\\n\\n        for(auto i:word1)\\n        {\\n            if(!mp2[i])return false;\\n        }\\n\\n        vector<int>v1,v2;\\n        for(auto i:mp1)\\n        {\\n            v1.push_back(i.second);\\n\\n        }\\n        for(auto i:mp2)\\n        {\\n            v2.push_back(i.second);\\n        }\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        if(v1==v2) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868588,
                "title": "java-simple-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int n1=word1.length();\\n        int n2=word2.length();\\n        if(n1!=n2){\\n            return false;\\n        }\\n        int[] arr1=new int[26];\\n        int[] arr2=new int[26];\\n        for(int i=0;i<n1;i++){\\n            arr1[word1.charAt(i)-\\'a\\']++;\\n            arr2[word2.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(arr2[i]>0&&arr1[i]==0)\\n                return false;\\n        }\\n        // The arrays are using constant space so sort function will  have O(1) time complexity\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n        for(int i=0;i<26;i++){\\n            if(arr1[i]!=arr2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int n1=word1.length();\\n        int n2=word2.length();\\n        if(n1!=n2){\\n            return false;\\n        }\\n        int[] arr1=new int[26];\\n        int[] arr2=new int[26];\\n        for(int i=0;i<n1;i++){\\n            arr1[word1.charAt(i)-\\'a\\']++;\\n            arr2[word2.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(arr2[i]>0&&arr1[i]==0)\\n                return false;\\n        }\\n        // The arrays are using constant space so sort function will  have O(1) time complexity\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n        for(int i=0;i<26;i++){\\n            if(arr1[i]!=arr2[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868082,
                "title": "js-frequency-mapping-explanation-o-n-o-1",
                "content": "## Intuition\\nRule 1 means that the ordering of the letters is irrelevant.\\nRule 2 means that the overall population of occurences has to be the same, but doesn\\'t have to map to the same letters.\\n\\nFor example `latter` has 4 letters (aler) occuring 1 time, and 1 (t) occuring 2 times.  `taller` also has 4 letters (taer) occuring 1 time and 1 (l) occuring 4 times.  These 2 strings are close.\\n\\nJust be sure that all the letters from the first word occur at least once in the second word, and vice versa.\\n\\n## Approach\\n\\n- Frequency map both strings (we\\'re interested in counts of letters here).\\n- Verify that no letter occurs in just 1 string.\\n- Sort the frequency mappings.\\n- Verify that the mappings are the same.\\n\\n## Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(1)$\\n\\nKeep in mind that this involves sorting, but the arrays sorted are a fixed length of 26.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\n/**\\n * @param {string} word1\\n * @param {string} word2\\n * @return {boolean}\\n */\\nvar closeStrings = function(word1, word2) \\n{\\n    const A = \\'a\\'.charCodeAt(0);\\n    let map1 = Array(26).fill(0), map2 = Array(26).fill(0);\\n\\n    for(let i=0; i<word1.length; i++)\\n        map1[word1.charCodeAt(i)-A]++;\\n    for(let i=0; i<word2.length; i++)\\n        map2[word2.charCodeAt(i)-A]++;\\n\\n    for(let i=0; i<26; i++)\\n        if((map1[i] === 0 && map2[i] !== 0) || (map2[i] === 0 && map1[i] !== 0))\\n            return false;\\n\\n    map1.sort((a,b)=>b-a);\\n    map2.sort((a,b)=>b-a);\\n\\n    for(let i=0; i<26; i++)\\n    {\\n        if(map1[i] !== map2[i])\\n            return false;\\n        if(map1[i] === 0)\\n            break;\\n    }\\n\\n    return true;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} word1\\n * @param {string} word2\\n * @return {boolean}\\n */\\nvar closeStrings = function(word1, word2) \\n{\\n    const A = \\'a\\'.charCodeAt(0);\\n    let map1 = Array(26).fill(0), map2 = Array(26).fill(0);\\n\\n    for(let i=0; i<word1.length; i++)\\n        map1[word1.charCodeAt(i)-A]++;\\n    for(let i=0; i<word2.length; i++)\\n        map2[word2.charCodeAt(i)-A]++;\\n\\n    for(let i=0; i<26; i++)\\n        if((map1[i] === 0 && map2[i] !== 0) || (map2[i] === 0 && map1[i] !== 0))\\n            return false;\\n\\n    map1.sort((a,b)=>b-a);\\n    map2.sort((a,b)=>b-a);\\n\\n    for(let i=0; i<26; i++)\\n    {\\n        if(map1[i] !== map2[i])\\n            return false;\\n        if(map1[i] === 0)\\n            break;\\n    }\\n\\n    return true;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868006,
                "title": "python3-simple-method-using-counter",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        cnt1, cnt2 = Counter(word1), Counter(word2)\\n        return cnt1.keys() == cnt2.keys() and sorted(cnt1.values()) == sorted(cnt2.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        cnt1, cnt2 = Counter(word1), Counter(word2)\\n        return cnt1.keys() == cnt2.keys() and sorted(cnt1.values()) == sorted(cnt2.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789840,
                "title": "java-simple-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int l1 = word1.length(), l2 = word2.length();\\n        if(l1!=l2) return false;\\n        int[] w1 = new int[26];\\n        int[] w2 = new int[26];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0;i<l1;i++)\\n            w1[word1.charAt(i)-\\'a\\']++;\\n        for(int i=0;i<26;i++)\\n            map.put(w1[i], map.getOrDefault(w1[i], 0)+1);\\n        for(int i=0;i<l2;i++) {\\n            if(w1[word2.charAt(i)-\\'a\\'] == 0) return false;\\n            w2[word2.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++) {\\n            if(map.getOrDefault(w2[i],0)==0) return false;\\n            map.put(w2[i], map.get(w2[i])-1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        int l1 = word1.length(), l2 = word2.length();\\n        if(l1!=l2) return false;\\n        int[] w1 = new int[26];\\n        int[] w2 = new int[26];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0;i<l1;i++)\\n            w1[word1.charAt(i)-\\'a\\']++;\\n        for(int i=0;i<26;i++)\\n            map.put(w1[i], map.getOrDefault(w1[i], 0)+1);\\n        for(int i=0;i<l2;i++) {\\n            if(w1[word2.charAt(i)-\\'a\\'] == 0) return false;\\n            w2[word2.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++) {\\n            if(map.getOrDefault(w2[i],0)==0) return false;\\n            map.put(w2[i], map.get(w2[i])-1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491826,
                "title": "python3-counter",
                "content": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        c1 = Counter(word1)\\n        c2 = Counter(word2)\\n        return sorted(c1.keys())==sorted(c2.keys()) and sorted(c1.values())==sorted(c2.values())\\n```\\nSince we can swap frequency of characters and position hence we just need to make sure that there are same unqiue characters and same frequencies in both the strings",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        c1 = Counter(word1)\\n        c2 = Counter(word2)\\n        return sorted(c1.keys())==sorted(c2.keys()) and sorted(c1.values())==sorted(c2.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410397,
                "title": "java-o-n-solution-no-sorting-frequency-array",
                "content": "Intuition is to make frequency maps of both strings.\\nKeeping word1 as the target.\\nSince Condition 1 allows swaps , hence both arrays can reach a sorted position(therefore no need to actually sort) .\\nOnce in sorted form all we need to do is check frequency of each character in both words.\\nIf they equal nothing to do move forward\\nIf one of them is 0 and other is non zero answer will always be false as this means character is missing from one of the words.\\nIf they are different. We iterate over the freq2 map in search whther there is another character with freq same as that of word1 character.If found we swap and then move forward.\\nNow if they were \\' close \\' freq of each character would be same.\\n\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length() != word2.length())    return false;\\n        \\n        int[] freq1 = new int[26];\\n        int[] freq2 = new int[26];\\n        for(int i=0;i<word1.length();i++){\\n            freq1[word1.charAt(i)-\\'a\\']++;\\n            freq2[word2.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            if(freq1[i] == freq2[i])    continue;\\n            if(freq1[i] == 0 || freq2[i] == 0) return false;\\n            \\n            for(int j=i+1;j<26;j++){\\n                if(freq2[i] != freq2[j] && freq2[j]  == freq1[i]){\\n                    int temp = freq2[i];\\n                    freq2[i] = freq2[j];\\n                    freq2[j] = temp;\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<26;i++)\\n            if(freq1[i] != freq2[i])    return false;\\n        return true;\\n        \\n        \\n       \\n    }\\n}\\n```\\n\\nComplexity:\\nTime O(n) + O(1) + O(n) ===> O(n)\\nSpace O(2n)                   ====> O(n)",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if(word1.length() != word2.length())    return false;\\n        \\n        int[] freq1 = new int[26];\\n        int[] freq2 = new int[26];\\n        for(int i=0;i<word1.length();i++){\\n            freq1[word1.charAt(i)-\\'a\\']++;\\n            freq2[word2.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            if(freq1[i] == freq2[i])    continue;\\n            if(freq1[i] == 0 || freq2[i] == 0) return false;\\n            \\n            for(int j=i+1;j<26;j++){\\n                if(freq2[i] != freq2[j] && freq2[j]  == freq1[i]){\\n                    int temp = freq2[i];\\n                    freq2[i] = freq2[j];\\n                    freq2[j] = temp;\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<26;i++)\\n            if(freq1[i] != freq2[i])    return false;\\n        return true;\\n        \\n        \\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335196,
                "title": "determine-if-two-strings-are-close-using-hash-map-c",
                "content": "\\n        \\n        unordered_map<char,int> mp1;\\n        unordered_map<char,int> mp2;\\n        for(char c:word1){\\n            mp1[c]++;\\n        }\\n        for(char c:word2){\\n            mp2[c]++;\\n        }\\n        for(auto it=mp1.begin(); it!=mp1.end(); it++){\\n            if(mp2.find(it->first)==mp2.end()) return false;\\n        }\\n        vector<int> v1,v2;\\n        for(auto c:mp1){\\n            v1.push_back(c.second);\\n        }\\n        for(auto c:mp2){\\n            v2.push_back(c.second);\\n        }\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        for(int i=0; i<max(v1.size(),v2.size()); i++){\\n            if(v1[i]!=v2[i]) return false;\\n        }\\n        return true;\\n    \\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "\\n        \\n        unordered_map<char,int> mp1;\\n        unordered_map<char,int> mp2;\\n        for(char c:word1){\\n            mp1[c]++;\\n        }\\n        for(char c:word2){\\n            mp2[c]++;\\n        }\\n        for(auto it=mp1.begin(); it!=mp1.end(); it++){\\n            if(mp2.find(it->first)==mp2.end()) return false;\\n        }\\n        vector<int> v1,v2;\\n        for(auto c:mp1){\\n            v1.push_back(c.second);\\n        }\\n        for(auto c:mp2){\\n            v2.push_back(c.second);\\n        }\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        for(int i=0; i<max(v1.size(),v2.size()); i++){\\n            if(v1[i]!=v2[i]) return false;\\n        }\\n        return true;\\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1991173,
                "title": "python-very-easy-with-comment-explaining",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        c1 = collections.Counter(word1)\\n        c2 = collections.Counter(word2)\\n        if set(word1) != set(word2) or len(word1) != len(word2):\\n            return False\\n        #If both strings have same letters and same number of frequencies \\n        #eg: aaab , bbba  both have (a,b) and both have 3 frequencies of certain letter and 1 frequency of another letter\\n        if c1 == c2 or collections.Counter(c1.values()) == collections.Counter(c2.values()):\\n            return True\\n        \\n        \\n        \\n        \\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        c1 = collections.Counter(word1)\\n        c2 = collections.Counter(word2)\\n        if set(word1) != set(word2) or len(word1) != len(word2):\\n            return False\\n        #If both strings have same letters and same number of frequencies \\n        #eg: aaab , bbba  both have (a,b) and both have 3 frequencies of certain letter and 1 frequency of another letter\\n        if c1 == c2 or collections.Counter(c1.values()) == collections.Counter(c2.values()):\\n            return True\\n        \\n        \\n        \\n        \\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619255,
                "title": "python-explained-counter-of-counter",
                "content": "Conditions:\\n1. `word1` length must equal `word2` length\\n2.  `word1` set of characters must equal `word2`\\'s.\\n3. `word1` ordered list of occurence for each character in set must equal `word2`\\'s.  Iff this is true, operation 2 makes `word1` and `word2` two strings with same characters placed in different order. And then operation 1 reorder the two subsequences to make them equal.\\n\\t- consider the following counter example:\\n\\t\\t- `word1`: `abbb`, counter: `a: 1, b: 3`\\n\\t\\t- `word2`: `abbb`, counter: `a: 2, b: 2`\\n\\t\\t- no matter how you do operations,  you can\\'t make them equal cause Condition 3 does not stand.\\n\\n##### implementation\\nsince set of characters is limited in testing, `sorted(counter)` is still considered constant operations, AC average run time of these two is similar. however when this set is large, need to use the second one.\\n\\n```python\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if len(word1) != len(word2):\\n            return False\\n    \\n        C1, C2 = Counter(word1), Counter(word2)\\n        return C1.keys() == C2.keys() and sorted(C1.values()) == sorted(C2.values())\\n```\\n\\n```python\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if len(word1) != len(word2):\\n            return False\\n        \\n        C1, C2 = Counter(word1), Counter(word2)\\n        return C1.keys() == C2.keys() and Counter(C1.values()) == Counter(C2.values())\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if len(word1) != len(word2):\\n            return False\\n    \\n        C1, C2 = Counter(word1), Counter(word2)\\n        return C1.keys() == C2.keys() and sorted(C1.values()) == sorted(C2.values())\\n```\n```python\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if len(word1) != len(word2):\\n            return False\\n        \\n        C1, C2 = Counter(word1), Counter(word2)\\n        return C1.keys() == C2.keys() and Counter(C1.values()) == Counter(C2.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376841,
                "title": "1657-same-chars-must-exist-then-just-the-counts-must-be-same",
                "content": "---\\n\\nA bit of confusion in the question\\'s conditions, on first time read.\\n\\n---\\n\\n**Algo**\\n- For the two conditions come down to below:\\n  - Overall count of each string must be same\\n  - Same chars must exists - for interchange & vice versa to work, when unequal char for any char\\n  - Same number of counts must exist - for equal to work when interchange on unequal char for any char\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar closeStrings = function (w1, w2) {\\n    if (w1.length != w2.length) return false; // overall count must be same\\n    const aCharCode = \"a\".charCodeAt();\\n\\n    let counts1 = new Array(26).fill(0); // char vs its counts, for every char, of w1\\n    let counts2 = new Array(26).fill(0);\\n    for (let i = 0; i < w1.length; i++) {\\n        counts1[w1[i].charCodeAt() - aCharCode]++;\\n        counts2[w2[i].charCodeAt() - aCharCode]++;\\n    }\\n\\n    for (let i = 0; i < 26; i++)\\n        if ((counts1[i] && !counts2[i]) || (!counts1[i] && counts2[i])) {\\n            return false; // same char, does not exist in both\\n        }\\n\\n    // just counts in order, of w1 & w2 - do they match?\\n    return counts1.sort((a, b) => a - b).toString() === counts2.sort((a, b) => a - b).toString();\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/120d6859-cd9a-427f-9bee-30749800e353_1627832200.0298874.png)\\n\\n---\\n\\n```\\nvar closeStrings = function (w1, w2) {\\n    const aCharCode = \"a\".charCodeAt();\\n\\n    let counts1 = new Array(26).fill(0); // char vs its counts, for every char, of w1\\n    let counts2 = new Array(26).fill(0);\\n    for (let i = 0; i < w1.length; i++) counts1[w1[i].charCodeAt() - aCharCode]++;\\n    for (let i = 0; i < w2.length; i++) counts2[w2[i].charCodeAt() - aCharCode]++;\\n\\n    for (let i = 0; i < 26; i++)\\n        if ((counts1[i] && !counts2[i]) || (!counts1[i] && counts2[i])) {\\n            return false; // same char, does not exist in both\\n        }\\n\\n    // just counts in order, of w1 & w2 - do they match?\\n    return counts1.sort((a, b) => a - b).toString() === counts2.sort((a, b) => a - b).toString();\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6e24dd89-2a99-47b8-a18d-f3164c314c0a_1627832951.9804516.png)\\n\\n---\\n\\n```\\nvar closeStrings = function (w1, w2) {\\n    const aCharCode = \"a\".charCodeAt();\\n    // get counts of w1 & w2\\n    counts1 = w1.split(\"\").reduce((arr, c) => (arr[c.charCodeAt() - aCharCode]++, arr), new Array(26).fill(0));\\n    counts2 = w2.split(\"\").reduce((arr, c) => (arr[c.charCodeAt() - aCharCode]++, arr), new Array(26).fill(0));\\n\\n    // same char, does not exist in both w1 & w2 - fail\\n    if (counts1.some((_, i) => (counts1[i] && !counts2[i]) || (!counts1[i] && counts2[i]))) return false;\\n\\n    // just the counts, in order, of w1 & w2 - do they match?\\n    return counts1.sort((a, b) => a - b).toString() === counts2.sort((a, b) => a - b).toString();\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/9db6a3fd-8a9e-4d1a-a9fe-348b8d25b97a_1627833445.3904092.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar closeStrings = function (w1, w2) {\\n    if (w1.length != w2.length) return false; // overall count must be same\\n    const aCharCode = \"a\".charCodeAt();\\n\\n    let counts1 = new Array(26).fill(0); // char vs its counts, for every char, of w1\\n    let counts2 = new Array(26).fill(0);\\n    for (let i = 0; i < w1.length; i++) {\\n        counts1[w1[i].charCodeAt() - aCharCode]++;\\n        counts2[w2[i].charCodeAt() - aCharCode]++;\\n    }\\n\\n    for (let i = 0; i < 26; i++)\\n        if ((counts1[i] && !counts2[i]) || (!counts1[i] && counts2[i])) {\\n            return false; // same char, does not exist in both\\n        }\\n\\n    // just counts in order, of w1 & w2 - do they match?\\n    return counts1.sort((a, b) => a - b).toString() === counts2.sort((a, b) => a - b).toString();\\n};\\n```\n```\\nvar closeStrings = function (w1, w2) {\\n    const aCharCode = \"a\".charCodeAt();\\n\\n    let counts1 = new Array(26).fill(0); // char vs its counts, for every char, of w1\\n    let counts2 = new Array(26).fill(0);\\n    for (let i = 0; i < w1.length; i++) counts1[w1[i].charCodeAt() - aCharCode]++;\\n    for (let i = 0; i < w2.length; i++) counts2[w2[i].charCodeAt() - aCharCode]++;\\n\\n    for (let i = 0; i < 26; i++)\\n        if ((counts1[i] && !counts2[i]) || (!counts1[i] && counts2[i])) {\\n            return false; // same char, does not exist in both\\n        }\\n\\n    // just counts in order, of w1 & w2 - do they match?\\n    return counts1.sort((a, b) => a - b).toString() === counts2.sort((a, b) => a - b).toString();\\n};\\n```\n```\\nvar closeStrings = function (w1, w2) {\\n    const aCharCode = \"a\".charCodeAt();\\n    // get counts of w1 & w2\\n    counts1 = w1.split(\"\").reduce((arr, c) => (arr[c.charCodeAt() - aCharCode]++, arr), new Array(26).fill(0));\\n    counts2 = w2.split(\"\").reduce((arr, c) => (arr[c.charCodeAt() - aCharCode]++, arr), new Array(26).fill(0));\\n\\n    // same char, does not exist in both w1 & w2 - fail\\n    if (counts1.some((_, i) => (counts1[i] && !counts2[i]) || (!counts1[i] && counts2[i]))) return false;\\n\\n    // just the counts, in order, of w1 & w2 - do they match?\\n    return counts1.sort((a, b) => a - b).toString() === counts2.sort((a, b) => a - b).toString();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1333709,
                "title": "easy-short-c-solution-o-n-o-26-log-26-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int W1[26]={0},W2[26]={0};\\n        for(char x : word1) W1[x-\\'a\\']++;\\n        for(char x : word2) {\\n             if(W1[x-\\'a\\']) W2[x-\\'a\\']++;  // char in word2 must be present in word1\\n        }\\n        sort(W1,W1+26);  // sort freq of chars in both strings\\n        sort(W2,W2+26);\\n        for(int i=0; i<26; i++) {\\n              if(W1[i]!=W2[i]) return false;  \\n        }\\n        return true;  // if the arrays are same then its always possible \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int W1[26]={0},W2[26]={0};\\n        for(char x : word1) W1[x-\\'a\\']++;\\n        for(char x : word2) {\\n             if(W1[x-\\'a\\']) W2[x-\\'a\\']++;  // char in word2 must be present in word1\\n        }\\n        sort(W1,W1+26);  // sort freq of chars in both strings\\n        sort(W2,W2+26);\\n        for(int i=0; i<26; i++) {\\n              if(W1[i]!=W2[i]) return false;  \\n        }\\n        return true;  // if the arrays are same then its always possible \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030587,
                "title": "c-easy-solution-o-n-time-o-1-space",
                "content": "### T = O(N) & S = O(1)\\n```\\n bool closeStrings(string w1, string w2) {\\n         if(w1.length() != w2.length()) return false; // If length not same then not possible to reform\\n       // create vector for 26 letters\\n        vector<int> f1(26, 0); // place 0 initially for all positions\\n        vector<int> f2(26, 0);\\n        vector<bool> v1(26, false); // place false for all positions\\n        vector<bool> v2(26, false);\\n        \\n        for(int i = 0; i < w1.length(); i++) {\\n            f1[w1[i]-\\'a\\']++; // place count values for current character\\n            f2[w2[i]-\\'a\\']++;\\n            v1[w1[i]-\\'a\\'] = true; // place true for current character\\n            v2[w2[i]-\\'a\\'] = true;\\n        }\\n        sort(f1.begin(), f1.end());\\n        sort(f2.begin(), f2.end());\\n        \\n        return f1==f2 && v1 == v2;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n bool closeStrings(string w1, string w2) {\\n         if(w1.length() != w2.length()) return false; // If length not same then not possible to reform\\n       // create vector for 26 letters\\n        vector<int> f1(26, 0); // place 0 initially for all positions\\n        vector<int> f2(26, 0);\\n        vector<bool> v1(26, false); // place false for all positions\\n        vector<bool> v2(26, false);\\n        \\n        for(int i = 0; i < w1.length(); i++) {\\n            f1[w1[i]-\\'a\\']++; // place count values for current character\\n            f2[w2[i]-\\'a\\']++;\\n            v1[w1[i]-\\'a\\'] = true; // place true for current character\\n            v2[w2[i]-\\'a\\'] = true;\\n        }\\n        sort(f1.begin(), f1.end());\\n        sort(f2.begin(), f2.end());\\n        \\n        return f1==f2 && v1 == v2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1030542,
                "title": "c-python-using-frequency-hashmap-implemented-with-array",
                "content": "Approach 1:Using frequency hashmap(implemented with Array)\\n```\\nclass Solution { // Using frequency hashmap(implemented with Array)\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size() != word2.size()) return false;\\n        vector<int> f1(26,0), f2(26,0); // tracking char freq in each word\\n        for(auto c: word1) f1[c-\\'a\\']++;\\n        for(auto c: word2) f2[c-\\'a\\']++;\\n        \\n        for(int i = 0; i < 26; i++)\\n            if( f1[i] == 0 && f2[i] >0   ||   f2[i] == 0 && f1[i] >0 ) return false;\\n        \\n        sort(begin(f1), end(f1));\\n        sort(begin(f2), end(f2));\\n        return f1 == f2;\\n    }\\n};\\n// Reference: [1] https://leetcode.com/problems/determine-if-two-strings-are-close/solution/\\n```\\n\\nApproach2: Python Hashmap\\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        cnt1, cnt2 = Counter(word1), Counter(word2)\\n        return set(cnt1.keys()) == set(cnt2.keys()) and sorted(cnt1.values()) == sorted(cnt2.values())\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution { // Using frequency hashmap(implemented with Array)\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        if(word1.size() != word2.size()) return false;\\n        vector<int> f1(26,0), f2(26,0); // tracking char freq in each word\\n        for(auto c: word1) f1[c-\\'a\\']++;\\n        for(auto c: word2) f2[c-\\'a\\']++;\\n        \\n        for(int i = 0; i < 26; i++)\\n            if( f1[i] == 0 && f2[i] >0   ||   f2[i] == 0 && f1[i] >0 ) return false;\\n        \\n        sort(begin(f1), end(f1));\\n        sort(begin(f2), end(f2));\\n        return f1 == f2;\\n    }\\n};\\n// Reference: [1] https://leetcode.com/problems/determine-if-two-strings-are-close/solution/\\n```\n```\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        cnt1, cnt2 = Counter(word1), Counter(word2)\\n        return set(cnt1.keys()) == set(cnt2.keys()) and sorted(cnt1.values()) == sorted(cnt2.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030268,
                "title": "java-o-n-very-clean-and-easy-to-understand-with-comments",
                "content": "```\\npublic boolean closeStrings(String word1, String word2) {\\n        int n1= word1.length();\\n        int n2= word2.length();\\n        if(n1!=n2) return false;\\n        \\n        int [] freqArr1 = new int[26];              // Arrays to store the frequency of a particular character in the Strings. \\n        int [] freqArr2 = new int[26];\\n        \\n        Set<Character> set1 = new HashSet<>();       // To check wheather the two strings contains same character or not, without having same characters two strings can\\'t be close. \\n        \\n        for(char ch : word1.toCharArray()){\\n            set1.add(ch);\\n        }\\n        for(char ch : word2.toCharArray()){\\n            if(!set1.contains(ch)) return false;\\n        }\\n        \\n        Map<Integer,Integer> freqMap1 = new HashMap<>();        // This is to keep track of the count of the frequency of the characters. \\n        Map<Integer,Integer> freqMap2 = new HashMap<>();\\n        \\n        for(int i=0;i<n1;i++){\\n            freqArr1[word1.charAt(i) - \\'a\\']++;        // calculating frequency of each character in both the Strings.\\n            freqArr2[word2.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            freqMap1.put(freqArr1[i], freqMap1.getOrDefault(freqArr1[i],0)+1);     //counting the frequncy of the characters. \\n            freqMap2.put(freqArr2[i], freqMap2.getOrDefault(freqArr2[i],0)+1);\\n        }\\n        \\n        if(freqMap2.equals(freqMap1)) return true;     \\n        return false;\\n    }\\n```\\n\\n\\nI hope my comments were helpful and clear : )",
                "solutionTags": [],
                "code": "```\\npublic boolean closeStrings(String word1, String word2) {\\n        int n1= word1.length();\\n        int n2= word2.length();\\n        if(n1!=n2) return false;\\n        \\n        int [] freqArr1 = new int[26];              // Arrays to store the frequency of a particular character in the Strings. \\n        int [] freqArr2 = new int[26];\\n        \\n        Set<Character> set1 = new HashSet<>();       // To check wheather the two strings contains same character or not, without having same characters two strings can\\'t be close. \\n        \\n        for(char ch : word1.toCharArray()){\\n            set1.add(ch);\\n        }\\n        for(char ch : word2.toCharArray()){\\n            if(!set1.contains(ch)) return false;\\n        }\\n        \\n        Map<Integer,Integer> freqMap1 = new HashMap<>();        // This is to keep track of the count of the frequency of the characters. \\n        Map<Integer,Integer> freqMap2 = new HashMap<>();\\n        \\n        for(int i=0;i<n1;i++){\\n            freqArr1[word1.charAt(i) - \\'a\\']++;        // calculating frequency of each character in both the Strings.\\n            freqArr2[word2.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            freqMap1.put(freqArr1[i], freqMap1.getOrDefault(freqArr1[i],0)+1);     //counting the frequncy of the characters. \\n            freqMap2.put(freqArr2[i], freqMap2.getOrDefault(freqArr2[i],0)+1);\\n        }\\n        \\n        if(freqMap2.equals(freqMap1)) return true;     \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1030266,
                "title": "go-golang-clean-solution",
                "content": "```go\\nfunc closeStrings(word1 string, word2 string) bool {\\n    if len(word1) != len(word2) { return false }\\n    a, b := make([]int, 26), make([]int, 26)\\n    c, d := [26]int{}, [26]int{}\\n    for i := range word1 {\\n        a[word1[i] - \\'a\\']++; b[word2[i] - \\'a\\']++\\n        c[word1[i] - \\'a\\'] = 1; d[word2[i] - \\'a\\'] = 1\\n    }\\n    sort.Ints(a)\\n    sort.Ints(b)\\n    for i := range a { if a[i] != b[i] { return false } }\\n    return c == d\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc closeStrings(word1 string, word2 string) bool {\\n    if len(word1) != len(word2) { return false }\\n    a, b := make([]int, 26), make([]int, 26)\\n    c, d := [26]int{}, [26]int{}\\n    for i := range word1 {\\n        a[word1[i] - \\'a\\']++; b[word2[i] - \\'a\\']++\\n        c[word1[i] - \\'a\\'] = 1; d[word2[i] - \\'a\\'] = 1\\n    }\\n    sort.Ints(a)\\n    sort.Ints(b)\\n    for i := range a { if a[i] != b[i] { return false } }\\n    return c == d\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1030198,
                "title": "c-linear-time-solution-explained-100-time-95-space",
                "content": "The trick of this problem is NOT to modify the strings in any way, and instead focus on the frequency of each characters: given the 2 operations, you can basically derive any other string with the same different frequency of characters one from the other - assuming all the characters of one appear at least once in the othere.\\n\\nNow, to verify this, we will first of all clear the table of a simple edge case: strings of different length will never have the same frequencies, so we can remove them.\\n\\nWe will then declare 3 support variables:\\n* `freqs1` and `freq2` are 2 arrays initialised with all their values set to `0` and that will collect all the necessary information - notive the say up to `123` elements, since we will have to hold up to `\\'z\\'`, whose ASCII code is `122`; you can alternatively create them with only `26` elements, but will then have to subtract `97` at each access - rather expensive, given the numbers involved here;\\n* `w1Freqs` is a multiset that will store all the computed frequencies of `w1` for ease of access (and removal).\\n\\nWe will then:\\n* populate `freqs1` going through each character of `w1`;\\n* populate `w1Freqs` going through all the non-`0` values in the range of `freqs1` which is of interest to use (`97 - 122`);\\n* populate `freqs2` going through each character of `w2` and check if the same character was found at least once in `w1` (if not, we just `return false`);\\n* go through all the non-`0` values in the range of `freqs2` which is of interest to use (again, `97 - 122`) and for each value:\\n\\t* find a pointer to said value in `w1Freqs`, meaning checking whether or not there is another character with the same frequency in `w1`;\\n\\t* if not, we can just `return false`;\\n\\t* if it is there, we delete it.\\n\\nIf we exit the last loop, we can just return `true` is `w1Freqs` is empty, meaning we found a match for each character.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool closeStrings(string w1, string w2) {\\n        // edge case\\n        if (w1.size() != w2.size()) return false;\\n        // support variables\\n        int freqs1[123] = {},  freqs2[123] = {};\\n        multiset<int> w1Freqs;\\n        // parsing w1\\n        for (char c: w1) freqs1[c]++;\\n        // storing the collected info\\n        for (int i = 97; i < 123; i++) {\\n            if (freqs1[i]) {\\n                // updating w1Freqs\\n                w1Freqs.insert(freqs1[i]);\\n            }\\n        }\\n        // parsing w2\\n        for (char c: w2) {\\n            if (!freqs1[c]) return false;\\n            freqs2[c]++;\\n        }\\n        // comparing frequencies\\n        for (int i = 97; i < 123; i++) {\\n            if (freqs2[i]) {\\n                auto match = w1Freqs.find(freqs2[i]);\\n                if (match != end(w1Freqs)) w1Freqs.erase(match);\\n                else return false;\\n            }\\n        }\\n        return !w1Freqs.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool closeStrings(string w1, string w2) {\\n        // edge case\\n        if (w1.size() != w2.size()) return false;\\n        // support variables\\n        int freqs1[123] = {},  freqs2[123] = {};\\n        multiset<int> w1Freqs;\\n        // parsing w1\\n        for (char c: w1) freqs1[c]++;\\n        // storing the collected info\\n        for (int i = 97; i < 123; i++) {\\n            if (freqs1[i]) {\\n                // updating w1Freqs\\n                w1Freqs.insert(freqs1[i]);\\n            }\\n        }\\n        // parsing w2\\n        for (char c: w2) {\\n            if (!freqs1[c]) return false;\\n            freqs2[c]++;\\n        }\\n        // comparing frequencies\\n        for (int i = 97; i < 123; i++) {\\n            if (freqs2[i]) {\\n                auto match = w1Freqs.find(freqs2[i]);\\n                if (match != end(w1Freqs)) w1Freqs.erase(match);\\n                else return false;\\n            }\\n        }\\n        return !w1Freqs.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029870,
                "title": "why-false-is-expected-for-this-test-case",
                "content": "HI, \\nCan somebody help me to figure out why the expected output for this test case is false?\\n\\n```\\n\"abcd\"\\n\"efgh\"\\n```\\n\\nIt my point of view we can map every character to anotherone by using operation2, like \\n```\\na -> e\\nb -> f\\nc -> g\\nd -> h\\n````\\n\\nBut if you run this test case the expected output is false.",
                "solutionTags": [],
                "code": "```\\n\"abcd\"\\n\"efgh\"\\n```\n```\\na -> e\\nb -> f\\nc -> g\\nd -> h\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1029758,
                "title": "c-o-n-hash-table-simple-solution",
                "content": "Understanding the approach\\n1) If size is different then return false.\\n2) check both the string and if they don\\'t have same charachter then return false\\n3) Now, we will try to convert string a to string b, traverse the freq table of string and use a map to know which freq occurs how many times, for example: aaabbb in this freq 3 occurs 2 times. That\\'s why we use map.\\n4) Now, for converting a to b, we check if both charachter have different freq, then we want some a charachter with freq of same as charachter of string b, we find in map. If there is freq that exist, we will decreaase it by 1, and if we don\\'t found then we return false.\\n5) At end return true.\\n(We used unordered map because it has O(1) on an average)\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool closeStrings(string a, string b) {\\n        if(a.size()!=b.size()) return false;\\n        int m1[26]={0},m2[26]={0};\\n       \\n        for(auto it:a)\\n        {\\n            m1[it-\\'a\\']++;\\n            \\n        }\\n        for(auto it:b)\\n        {\\n            m2[it-\\'a\\']++;\\n        }\\n        unordered_map<int,int>m;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(m1[i]==0 && m2[i]!=0) return false;\\n            if(m2[i]==0 && m1[i]!=0) return false;\\n            if(m1[i]!=0 && m2[i]!=0) m[m1[i]]++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(m1[i]!=0 && m2[i]!=0 && m1[i]!=m2[i])\\n            {\\n                int want=m2[i];\\n                if(m.find(want)!=m.end())\\n                {\\n                    if(m[want]>0)\\n                    {\\n                        m[want]--;\\n                        \\n                    }\\n                    else \\n                    {  \\n                        return false;\\n                    }\\n                }\\n                else\\n                        return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\'\\'\\'\\nHappy Coding :)\\nPlease upvote if you found it useful.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool closeStrings(string a, string b) {\\n        if(a.size()!=b.size()) return false;\\n        int m1[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1029251,
                "title": "java-o-n-time-with-explaination-constant-space",
                "content": "In the question it is asked to check that both Strings should be constructed from same characters. and the frequencies also must be same in both Strings. it might be possible that count of one character matches with another character count.\\n1. so approach is to take two maps to store frequency. ( here we have taken array of 26 size each to be used as a map). \\n2. now iterate each word character by character and note down frequency in equivalent maps.\\n3. after that check first that both arrays should have same characters. for that just iterate from 0 to 26 and check is there exists an entry in both arrays whose values i.e. counts are different and one of them value is 0(which indicates that a particular character is missing in one of the array). if yes return false.\\n4. once above loop finishes it is clear that characters are same. now we want to check same frequencies. for that just sort both the arrays. now just compare each element and return false if values doesnot matched.\\n\\npreparing two arrays take o(n) time and we are mostly running loop from 0 to 26 it\\'s take constant time. similarly sort also take 26log(26) time which is also constant and array size itself is 26. hence constant memory\\n```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if (word1.length() != word2.length()) {\\n\\t\\t    return false;\\n        }\\n        int[] word1Map =new int[26];\\n        int[] word2Map =new int[26];\\n        for (int i=0;i<word1.length();i++) {\\n            word1Map[word1.charAt(i)-\\'a\\']++;\\n            word2Map[word2.charAt(i)-\\'a\\']++;\\n        }\\n        //check same characters\\n        for(int i=0;i<26;i++) {\\n            if(word1Map[i]!=word2Map[i] && (word1Map[i]==0||word2Map[i]==0)) {\\n                return false;\\n            }\\n        }\\n        //now to check frequencies sort array\\n        Arrays.sort(word1Map);\\n        Arrays.sort(word2Map);\\n        for(int i=0;i<26;i++) {\\n            if(word1Map[i]!=word2Map[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if (word1.length() != word2.length()) {\\n\\t\\t    return false;\\n        }\\n        int[] word1Map =new int[26];\\n        int[] word2Map =new int[26];\\n        for (int i=0;i<word1.length();i++) {\\n            word1Map[word1.charAt(i)-\\'a\\']++;\\n            word2Map[word2.charAt(i)-\\'a\\']++;\\n        }\\n        //check same characters\\n        for(int i=0;i<26;i++) {\\n            if(word1Map[i]!=word2Map[i] && (word1Map[i]==0||word2Map[i]==0)) {\\n                return false;\\n            }\\n        }\\n        //now to check frequencies sort array\\n        Arrays.sort(word1Map);\\n        Arrays.sort(word2Map);\\n        for(int i=0;i<26;i++) {\\n            if(word1Map[i]!=word2Map[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029117,
                "title": "c-short-and-simple-7-line-o-n-solution",
                "content": "Two things are required for strings to be close.\\n1. characters in both the strings should be same. E.g. s1 = \"abcs\" s2 = \"sbac\" are close but s1 = \"abcd\" s2 = \"abcs\" are not close because we can\\'t convert \"d\" into \"s\" or vice versa.\\n\\n2. frequencies of all the characters in string 1 should be equal to frequencies of all the characters in string 2. E.g. s1 = \"aabbcccc\" s2 = \"aaaabbcc\" are close.\\n\\n```\\nbool closeStrings(string word1, string word2) {\\n\\tvector<int> a(26, 0), b(26, 0);\\n    for(int i = 0; i < word1.length(); i++) a[word1[i] - \\'a\\']++;\\n    for(int i = 0; i < word2.length(); i++) b[word2[i] - \\'a\\']++;\\n    for(int i = 0; i < 26; i++) {\\n        if(a[i] == 0 && b[i] != 0) return false;\\n        if(b[i] == 0 && a[i] != 0) return false;\\n    }\\n    return word1.length() == word2.length();\\n}\\n```\\n\\nTime Complexity = O(N) , N = length of the string.\\nSpace Complexity = O(1)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool closeStrings(string word1, string word2) {\\n\\tvector<int> a(26, 0), b(26, 0);\\n    for(int i = 0; i < word1.length(); i++) a[word1[i] - \\'a\\']++;\\n    for(int i = 0; i < word2.length(); i++) b[word2[i] - \\'a\\']++;\\n    for(int i = 0; i < 26; i++) {\\n        if(a[i] == 0 && b[i] != 0) return false;\\n        if(b[i] == 0 && a[i] != 0) return false;\\n    }\\n    return word1.length() == word2.length();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1029088,
                "title": "determine-if-two-strings-are-close-python3-hashmap-explained",
                "content": "The first time you take a glance at the problem, you might be confused by the operations provided. \\nThe fact that there are two operations available and can be done any times in any order indicates that **we shouldn\\'t focus on what those operations can change, but on what those operations couldn\\'t change**.\\nIn this problem, here are what these operations couldn\\'t change:\\n1. the length of a string. (obviously)\\n2. character set in a string. (obviously)\\n3. the quantity structure of each character in a string.\\n\\nFor example, if we have a string like ```aaabbc```, no matter what operation we act on it, we\\'ll always have 1 character which has the quantity of 3, 1 of quantity 2 and 1 of quantity 1.\\n\\nGiven above, we can say that if we have two strings have **the same length, the same character set and the same quantity structure**, then there must be some combination of operations we can act on one string to transform it into another.\\nCodes here:\\n```python\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if len(word1) != len(word2) or set(word1) != set(word2):\\n            return False\\n        \\n        counter1, counter2 = defaultdict(int), defaultdict(int)\\n        for c in word1:\\n            counter1[c] += 1\\n        for c in word2:\\n            counter2[c] += 1\\n        rdic1, rdic2 = defaultdict(set), defaultdict(set)\\n        for c, count in counter1.items():\\n            rdic1[count].add(c)\\n        for c, count in counter2.items():\\n            rdic2[count].add(c)\\n        \\n        for count, characters in rdic1.items():\\n            if count not in rdic2:\\n                return False\\n            if len(rdic2[count]) != len(characters):\\n                return False\\n            del rdic2[count]\\n        return not rdic2\\n```",
                "solutionTags": [],
                "code": "```aaabbc```\n```python\\nclass Solution:\\n    def closeStrings(self, word1: str, word2: str) -> bool:\\n        if len(word1) != len(word2) or set(word1) != set(word2):\\n            return False\\n        \\n        counter1, counter2 = defaultdict(int), defaultdict(int)\\n        for c in word1:\\n            counter1[c] += 1\\n        for c in word2:\\n            counter2[c] += 1\\n        rdic1, rdic2 = defaultdict(set), defaultdict(set)\\n        for c, count in counter1.items():\\n            rdic1[count].add(c)\\n        for c, count in counter2.items():\\n            rdic2[count].add(c)\\n        \\n        for count, characters in rdic1.items():\\n            if count not in rdic2:\\n                return False\\n            if len(rdic2[count]) != len(characters):\\n                return False\\n            del rdic2[count]\\n        return not rdic2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939022,
                "title": "my-java-solution-using-frequency-with-thought-process",
                "content": "```\\n/*\\nMy thought process:\\nHere I found the frequency of each of the character from word1 and word2\\nThen I go through each of the count from the count arrays say count1 and count2 and we continue only if both count1[i] and count2[i]\\nis 0.\\nIf only count1[i] or count2[i] = 0 means there is a letter that is present in one of the word but not in the other\\nFor example : word1 = aab word2 = aac\\nNow our count array will be count1 = [2, 1, 0, ...] and count2 = [2, 0, 1, ..]. \\nSo if we look at it, we can understand that count of b = 1 in count1 but = 0, in count2. So when this case arises, we can make the string close\\n\\nNow we sort the two count arrays and its complexity will be 26log(26) = constant\\nNow we check for each of the index, the values of the count arrays are equal. If there is any particular position where it is not equal, then we return false\\nOther wise return true;\\n\\n*/\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if (word1.length() != word2.length())\\n            return false;\\n        int length = word1.length();\\n        int [] count1 = new int [26];\\n        int [] count2 = new int [26];\\n        for (char ch : word1.toCharArray())\\n            count1[ch-\\'a\\'] += 1;\\n        for (char ch: word2.toCharArray())\\n            count2[ch-\\'a\\'] += 1;\\n        // check if there is any discrepancy in the minimum and the maximum vakue\\n        for (int i=0; i<26; i++) {\\n            if (count1[i] == count2[i])\\n                continue;\\n            if (count1[i] == 0 || count2[i] == 0)\\n               return false;\\n        }\\n        Arrays.sort(count1); // since the array size is 26 and it will not change, here the sorting is 26log26\\n        Arrays.sort(count2);\\n        for (int i=0; i<26; i++)\\n            if (count1[i] != count2[i])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\n/*\\nMy thought process:\\nHere I found the frequency of each of the character from word1 and word2\\nThen I go through each of the count from the count arrays say count1 and count2 and we continue only if both count1[i] and count2[i]\\nis 0.\\nIf only count1[i] or count2[i] = 0 means there is a letter that is present in one of the word but not in the other\\nFor example : word1 = aab word2 = aac\\nNow our count array will be count1 = [2, 1, 0, ...] and count2 = [2, 0, 1, ..]. \\nSo if we look at it, we can understand that count of b = 1 in count1 but = 0, in count2. So when this case arises, we can make the string close\\n\\nNow we sort the two count arrays and its complexity will be 26log(26) = constant\\nNow we check for each of the index, the values of the count arrays are equal. If there is any particular position where it is not equal, then we return false\\nOther wise return true;\\n\\n*/\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        if (word1.length() != word2.length())\\n            return false;\\n        int length = word1.length();\\n        int [] count1 = new int [26];\\n        int [] count2 = new int [26];\\n        for (char ch : word1.toCharArray())\\n            count1[ch-\\'a\\'] += 1;\\n        for (char ch: word2.toCharArray())\\n            count2[ch-\\'a\\'] += 1;\\n        // check if there is any discrepancy in the minimum and the maximum vakue\\n        for (int i=0; i<26; i++) {\\n            if (count1[i] == count2[i])\\n                continue;\\n            if (count1[i] == 0 || count2[i] == 0)\\n               return false;\\n        }\\n        Arrays.sort(count1); // since the array size is 26 and it will not change, here the sorting is 26log26\\n        Arrays.sort(count2);\\n        for (int i=0; i<26; i++)\\n            if (count1[i] != count2[i])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938772,
                "title": "c-using-map-simple",
                "content": "**If find helpful do upvote\\nThanks.**\\n\\n```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int n1=word1.size(), n2=word2.size();\\n        if(n1!=n2) return false;\\n        map <char, int> mp1, mp2;\\n        for(auto x:word1) mp1[x]++;\\n        for(auto x:word2) mp2[x]++;\\n        for(auto x:word1)\\n            if(!mp2[x])\\n                return false;\\n        for(auto x:word2)\\n            if(!mp1[x])\\n                return false;\\n        \\n        vector <int> a,b;\\n        for(auto i:mp1)\\n            a.push_back(i.second);\\n        for(auto i:mp2)\\n            b.push_back(i.second);\\n        sort(a.begin(), a.end());\\n        sort(b.begin(), b.end());\\n        \\n        if(a==b) \\n            return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int n1=word1.size(), n2=word2.size();\\n        if(n1!=n2) return false;\\n        map <char, int> mp1, mp2;\\n        for(auto x:word1) mp1[x]++;\\n        for(auto x:word2) mp2[x]++;\\n        for(auto x:word1)\\n            if(!mp2[x])\\n                return false;\\n        for(auto x:word2)\\n            if(!mp1[x])\\n                return false;\\n        \\n        vector <int> a,b;\\n        for(auto i:mp1)\\n            a.push_back(i.second);\\n        for(auto i:mp2)\\n            b.push_back(i.second);\\n        sort(a.begin(), a.end());\\n        sort(b.begin(), b.end());\\n        \\n        if(a==b) \\n            return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936036,
                "title": "c-simple-char-count-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int i,j;\\n        vector<int>c1(26,0),c2(26,0);\\n        \\n        for(char c:word1)\\n            c1[c-\\'a\\']++;\\n        \\n        for(char c:word2)\\n            c2[c-\\'a\\']++;\\n        \\n\\t\\t// make sure no different char are in the strings cause we cant create a new char. we can only change\\n        for(i=0;i<26;i++){\\n            if(c1[i]==0 && c2[i]==0)\\n                continue;\\n            \\n            if(c1[i]==0 || c2[i]==0)\\n                return false;       //indicates that (\\'a\\'+i) char is only in one string \\n        }\\n        \\n        sort(c1.begin(), c1.end());\\n        sort(c2.begin(), c2.end());\\n\\t\\t\\n        //count of char must be same, we dont care which one as it is always possible to trnsfrom one into another\\n        for(i=0;i<26;i++)\\n            if(c1[i]!=c2[i])\\n                return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool closeStrings(string word1, string word2) {\\n        int i,j;\\n        vector<int>c1(26,0),c2(26,0);\\n        \\n        for(char c:word1)\\n            c1[c-\\'a\\']++;\\n        \\n        for(char c:word2)\\n            c2[c-\\'a\\']++;\\n        \\n\\t\\t// make sure no different char are in the strings cause we cant create a new char. we can only change\\n        for(i=0;i<26;i++){\\n            if(c1[i]==0 && c2[i]==0)\\n                continue;\\n            \\n            if(c1[i]==0 || c2[i]==0)\\n                return false;       //indicates that (\\'a\\'+i) char is only in one string \\n        }\\n        \\n        sort(c1.begin(), c1.end());\\n        sort(c2.begin(), c2.end());\\n\\t\\t\\n        //count of char must be same, we dont care which one as it is always possible to trnsfrom one into another\\n        for(i=0;i<26;i++)\\n            if(c1[i]!=c2[i])\\n                return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935988,
                "title": "python3-concise-solution",
                "content": "```python\\ndef closeStrings(self, word1: str, word2: str) -> bool:\\n\\tif len(word1) != len(word2):\\n\\t\\treturn False\\n\\tc1, c2 = Counter(word1), Counter(word2)\\n\\treturn c1.keys() == c2.keys() and sorted(c1.values()) == sorted(c2.values())\\n```",
                "solutionTags": [],
                "code": "```python\\ndef closeStrings(self, word1: str, word2: str) -> bool:\\n\\tif len(word1) != len(word2):\\n\\t\\treturn False\\n\\tc1, c2 = Counter(word1), Counter(word2)\\n\\treturn c1.keys() == c2.keys() and sorted(c1.values()) == sorted(c2.values())\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1702556,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1702752,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1574609,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1702598,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1777407,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1702764,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1703182,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1570261,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1702888,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1931120,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1702556,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1702752,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1574609,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1702598,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1777407,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1702764,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1703182,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1570261,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1702888,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1931120,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "This is probably my favorite problem yet. The whole thing is basically a trick. The two operations are almost meaningless, and you do not have to perform them at all to determine the answer, just think about what they really mean: Using these options to their fullest extent, what can you do with the strings? "
                    },
                    {
                        "username": "95tuanle",
                        "content": "thank you!"
                    },
                    {
                        "username": "martinezfu07",
                        "content": "my friend, you are absolutely right ; it is just one trick. "
                    },
                    {
                        "username": "holywatersheep",
                        "content": "are u from heaven?"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "That\\'s what I discover after creating the 2 operation fuctions :facepalm:"
                    },
                    {
                        "username": "pranavMenon833",
                        "content": "Great hint, thanks man!"
                    },
                    {
                        "username": "dev_Dynamic",
                        "content": "you are so awesome bro I like you"
                    },
                    {
                        "username": "aryan1113",
                        "content": "My approach =>\\n1. Check if both words are of same length, if not return False\\n2. Check if both words have same alphabets (by comparing set(word1) and set(word2)\\n3.  Make two lists having count of all alphabets one for word1 and one for word2, sort the lists, check if the lists are equal, if yes return True, else return False "
                    },
                    {
                        "username": "95tuanle",
                        "content": "great approach"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@Rishil96](/Rishil96) I used dictionaries and My solution wasn\\'t the Best but Beats more than 50% of others solutions "
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@yin78105](/yin78105) That sent me a wrong answer in My first try, because I compare the sum,  in that moment I realize that a have to compare frequency."
                    },
                    {
                        "username": "yin78105",
                        "content": "[@dapilk101](/dapilk101) it is the counting of all individual alphabets(counting for a, b, c, z individually) not the counting for all alphabets(length of words). I suppose.\\nin word1, there are, 2\"a\", 2\"b\", 1\"c\", 3\"z\". {2,2,1,2}\\nin word2, there are, 1\"a\", 2\"b\", 1\"c\", 3\"z\". {1,2,1,3}\\nSo even though the length are the same it is not gonna work by swapping. May I know why your \"word1 len: 7\" appear twice? "
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Thanks! It worked nicely. I was thinking the same way but was not able to come up with 3rd condition."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I\\'m curious how we ended up with the same exact solution. I guess it\\'s logical"
                    },
                    {
                        "username": "Rishil96",
                        "content": "Hey, thanks i was using dictionary comprehension to achieve the same but it was slow so my code was not accepted due to going overtime but looking at your approach helped, using set was much faster."
                    },
                    {
                        "username": "m-slashe",
                        "content": "[@dapilk101](/dapilk101) the count of the word freq that you put is wrong it would be \\n\\nlist1 [2, 2, 2, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\nlist2 [2, 3, 1, 1] for  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}\\n\\nso comparing the count of the words really works"
                    },
                    {
                        "username": "dapilk101",
                        "content": "Smart idea but I am not sure if this idea works on all testcases. \\nword1 =  \"abbzzca\"\\nword2 = \"babzzcz\"\\n\\nlist1:  [1, 1, 1, 1]     # unique word freq\\nlist2: [1, 1, 1, 1]\\n\\nword1 vals: {\\'b\\', \\'z\\', \\'a\\', \\'c\\'}    # unique letters\\nword2 vals:  {\\'b\\', \\'z\\', \\'a\\', \\'c\\'} \\n\\nword1 len: 7    # length\\nword1 len: 7 \\n\\nAll conditions are True but it expected False. Perhaps an error in logic or Leetcode. 131/152 testcases passed so I am guessing the logic."
                    },
                    {
                        "username": "deepika8",
                        "content": "s.closeStrings(\"uau\", \"ssx\") should be False \\nCan\\'t I exchange the last au, resulting in uua and then convert both u to s and single a to x .. \\n"
                    },
                    {
                        "username": "Starwind0",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) it doesn\\'t state that is the issue. "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "It simply means every letter in 1st string should be present in 2nd string"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "you only can exchange the letter that is in the string, which means word1 doesn\\'t have \\'s\\' and \\'x\\' so you can\\'t do that"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can\\'t use word2\\'s characters to in operation2"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Here the 2 operations need to be understood first.\\nBy the first operation, it says that the position of characters does not matter because we can swap any character with any other character.\\nBy the second operation, it says that the characters in given string must be the same set of characters in the target string.\\n\\nFor example(operation 1 skipped for both examples),\\ni) str=\"dddea\" ; target=\"cccsx\"  -> it will return FALSE, because we cannot transform any character to any different character which is not even present in the given string.\\n\\nii) str=\"dddea\" ; target=\"eeead\" -> it will return TRUE, because the transformation of characters is possible, and the characters in target are same as characters in given string."
                    },
                    {
                        "username": "oleksiik123",
                        "content": "What\\'s not clear is why those two conclusions is enough"
                    },
                    {
                        "username": "Parneet_Kaur",
                        "content": "very good insights \\n"
                    },
                    {
                        "username": "Harshdev625",
                        "content": "Testcase 131 \\nword1=\\n\"uau\"\\nword2=\\n\"ssx\"\\nWill give \\'true\\' as first we swap \\'a\\' and \\'u\\' in \\'word1\\', and then we transform \\'u\\' to \\'s\\' and \\'a\\' to \\'x\\', but according to Leetcode, it should return \\'false\\'. Am I wrong?\\n"
                    },
                    {
                        "username": "kanishk82",
                        "content": " Because we can only transform an existing character to another existing character"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Given Rules:\\nOperation 1:  Swap any two existing characters.\\nOperation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.\\nTwo strings are considered close if you can attain one from the other using the above operations.\\n\\nDerived rules:\\n1. Length of both words must be same.\\n2. Each alphabet that appears in word1, must appear in word2 and vice versa\\n3. (Hint to get solution) It is possible to form a one-one mathematical mapping from alphabet that occur in word1 to alphabets that occur in word2. f : x -> y, such that if x occurs c times in word1, then y occurs c times in word2"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m stuck at the second last testcase. Why is it false?\\n\\nTestcase\\n```\\nword1 = \"aaabbbbccddeeeeefffff\"\\nword2 = \"aaaaabbcccdddeeeeffff\"\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@Ankur Goswami](/ankurgoswami718) [@dkashi](/dkashi) [@vlrd](/vlrd) Thankyou guys! I was comparing the characters and their overall count, my bad!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "frequency of each character ( a, b, c, d, e, f ) in -\nword1 :  3 4 2 2 5 5   -> after sorting :  2 2 3 4 5 5\nword2 :  5 2 3 3 4 4   -> after sorting :  2 3 3 4 4 5\n\nas you can see that frequency array is different for both, it will be false."
                    },
                    {
                        "username": "dkashi",
                        "content": "word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\nCounter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2} => values are [5, 5, 4, 3, 2, 2]\\nCounter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\nif the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "basically word 1 goes like a-3 b-4 c-2 d-2 e-5 f-5\\nand word 2 goes like a-5 b-2 c-3 d-3 e-4 f-4\\nso the chars are same but counts are not \\nfor the logic to work with the rules given its imp that chars and counts both match then only you can apply those 2 operations to make 1 string into another"
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I know counting frequency is intuitive. However, could anyone please provide a solid math proof?"
                    },
                    {
                        "username": "DuelZergling",
                        "content": "every permutation can be built from a string of swap referring from group theory"
                    },
                    {
                        "username": "cswartzell",
                        "content": "The first rule allows you to swap any two letters. Given that you can do this any number of times, it is obvious that you can rearrange the string into any order. Basically, the first operation is meaningless: any string can be rearranged to become any permutation of itself. We can merely check the two strings are of the same length and then ignore \"Operation 1\".\\n\\nThe second operation allows you to swap letters, but the SIZE of the letter grouping stays the same: if you have 5 \"A\" and 3 \"B\" you are free to swap them, but you will still have one group of 5 and one of 3. Because you are wholly swapping groups, you can never affect the size of a group. Effectively you are just swapping the \"label\" of the group. We now can break the swapping operation into two questions: Do the two words have the exact same letters in common? If one has a letter the other doesnt, we can never get rid of it. Similarly, if one word is missing a letter we cannot generate it. If we have confirmed they have the same letters (by comparing keys in a counting method), then we are actually done with the letters themselves. We know we have the right letters, and can maybe swap them so we have the right amounts of each. We now just compare the sizes of groupings. If both words have 5 letters of one kind, 3 letters of second, and 2 of a third, of course we could perform swaps so these would be groupings of the RIGHT letter. We know know we have the right group sizes, which can become groups of the right letters, then rearranged into any string, namely the correct one. \\n\\nWe dont have to perform any swaps. Just check the len, keys, and frequency groupings of the two words"
                    },
                    {
                        "username": "macrokigol",
                        "content": "Operation 1 means that frequencies(the value) can be exchanged, Operation 2 means the frequencies(the key) can be exchanged.\\nSince the keys and values of the frequency can be exchanged independently, so sorting and comparing works."
                    },
                    {
                        "username": "reshmithaa",
                        "content": "thats a tricky question but once u get the logic its damn easy \\nall u need to find is \\nfrequency of each chars and store in dictionary {f1 -> word1,f2 -> word2}\\nlist of keys of 1st dictionary should be equal to 2nd  and \\nlist of values of 1st dictionary should be equal to second \\nthats it ... damn easy if u understood the logic"
                    },
                    {
                        "username": "akash-bisariya",
                        "content": "how this will work with second operation?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Imagine facing this problem for the first time in an interview."
                    },
                    {
                        "username": "malikrohail525",
                        "content": "lmao true"
                    }
                ]
            },
            {
                "id": 1702627,
                "content": [
                    {
                        "username": "Ashish_2002",
                        "content": "Is there any one who is also getting issue with testcase 101. In java language"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly. it should be easy problem. "
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s the approach:\\n\\n1. If values are not equal to each other - return false\\n2. Create Sets/hashMaps for word1 and word2\\n3. Check if both of them have the same alphabet\\n4. Create arrays from both sets and sort them\\n5. In for loop check if they have the same value at each index. if not, return false\\n6. return true"
                    },
                    {
                        "username": "Atchutagowtham",
                        "content": "Why \"uau\" and \"ssx\" is false?\\ncan\\'t i do the following operation\\'s?\\n1) s->u and x->a:    ssx->uua\\n2)swap u and a at indeces 1 and 2 :  uua->uau (equals to word1)\\nWhy the expected result is false, can anyone explain? Thanks in advance:)\\n"
                    },
                    {
                        "username": "zymbolic",
                        "content": "This is an awesome problem"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "i hate it, i hate my life"
                    },
                    {
                        "username": "seleznevgi",
                        "content": "why is this incorrect?\n`\nif (word1.size() != word2.size()) return false;\n        \nset<char> words_1{word1.begin(), word1.end()};\n        \nset<char> words_2{word2.begin(), word2.end()};\n        \nreturn equal(words_1.begin(), words_1.end(), words_2.begin(), words_2.end()) && ;\n `\n\nfails on 132 testcase:\n`word1 =\n\"abbzzca\"\nword2 =\n\"babzzcz\"`\nexpected false, but:\n\nin the word2: a zz -> z aa\n\nthen get word1 from word2 with just swapping characters"
                    },
                    {
                        "username": "user1034wH",
                        "content": "Found out looking at other solutions that the problem does not require the strings to be of equal length. So you could attain a smaller string from a substring of a larger string."
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "[@Adnan_Saif](/Adnan_Saif) UPDATE: my answer got submitted successfully. what I did was simply write ((int)list1.get(i) != (int)list2.get(i)) instead. This solves the problem. But still I could not understand why the previous one did not work."
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Yes I am also stuck on the same testcase. The Line \\n\"if(list1.get(i) != list2.get(i))\" keeps returning true, and I cannot understand how is that possible because both list equals to [826]. Can anybody please help."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Initially it felt hard to do it manually, forget the algorithm :-)"
                    }
                ]
            },
            {
                "id": 1765401,
                "content": [
                    {
                        "username": "Ashish_2002",
                        "content": "Is there any one who is also getting issue with testcase 101. In java language"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly. it should be easy problem. "
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s the approach:\\n\\n1. If values are not equal to each other - return false\\n2. Create Sets/hashMaps for word1 and word2\\n3. Check if both of them have the same alphabet\\n4. Create arrays from both sets and sort them\\n5. In for loop check if they have the same value at each index. if not, return false\\n6. return true"
                    },
                    {
                        "username": "Atchutagowtham",
                        "content": "Why \"uau\" and \"ssx\" is false?\\ncan\\'t i do the following operation\\'s?\\n1) s->u and x->a:    ssx->uua\\n2)swap u and a at indeces 1 and 2 :  uua->uau (equals to word1)\\nWhy the expected result is false, can anyone explain? Thanks in advance:)\\n"
                    },
                    {
                        "username": "zymbolic",
                        "content": "This is an awesome problem"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "i hate it, i hate my life"
                    },
                    {
                        "username": "seleznevgi",
                        "content": "why is this incorrect?\n`\nif (word1.size() != word2.size()) return false;\n        \nset<char> words_1{word1.begin(), word1.end()};\n        \nset<char> words_2{word2.begin(), word2.end()};\n        \nreturn equal(words_1.begin(), words_1.end(), words_2.begin(), words_2.end()) && ;\n `\n\nfails on 132 testcase:\n`word1 =\n\"abbzzca\"\nword2 =\n\"babzzcz\"`\nexpected false, but:\n\nin the word2: a zz -> z aa\n\nthen get word1 from word2 with just swapping characters"
                    },
                    {
                        "username": "user1034wH",
                        "content": "Found out looking at other solutions that the problem does not require the strings to be of equal length. So you could attain a smaller string from a substring of a larger string."
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "[@Adnan_Saif](/Adnan_Saif) UPDATE: my answer got submitted successfully. what I did was simply write ((int)list1.get(i) != (int)list2.get(i)) instead. This solves the problem. But still I could not understand why the previous one did not work."
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Yes I am also stuck on the same testcase. The Line \\n\"if(list1.get(i) != list2.get(i))\" keeps returning true, and I cannot understand how is that possible because both list equals to [826]. Can anybody please help."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Initially it felt hard to do it manually, forget the algorithm :-)"
                    }
                ]
            },
            {
                "id": 2043908,
                "content": [
                    {
                        "username": "Ashish_2002",
                        "content": "Is there any one who is also getting issue with testcase 101. In java language"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly. it should be easy problem. "
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s the approach:\\n\\n1. If values are not equal to each other - return false\\n2. Create Sets/hashMaps for word1 and word2\\n3. Check if both of them have the same alphabet\\n4. Create arrays from both sets and sort them\\n5. In for loop check if they have the same value at each index. if not, return false\\n6. return true"
                    },
                    {
                        "username": "Atchutagowtham",
                        "content": "Why \"uau\" and \"ssx\" is false?\\ncan\\'t i do the following operation\\'s?\\n1) s->u and x->a:    ssx->uua\\n2)swap u and a at indeces 1 and 2 :  uua->uau (equals to word1)\\nWhy the expected result is false, can anyone explain? Thanks in advance:)\\n"
                    },
                    {
                        "username": "zymbolic",
                        "content": "This is an awesome problem"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "i hate it, i hate my life"
                    },
                    {
                        "username": "seleznevgi",
                        "content": "why is this incorrect?\n`\nif (word1.size() != word2.size()) return false;\n        \nset<char> words_1{word1.begin(), word1.end()};\n        \nset<char> words_2{word2.begin(), word2.end()};\n        \nreturn equal(words_1.begin(), words_1.end(), words_2.begin(), words_2.end()) && ;\n `\n\nfails on 132 testcase:\n`word1 =\n\"abbzzca\"\nword2 =\n\"babzzcz\"`\nexpected false, but:\n\nin the word2: a zz -> z aa\n\nthen get word1 from word2 with just swapping characters"
                    },
                    {
                        "username": "user1034wH",
                        "content": "Found out looking at other solutions that the problem does not require the strings to be of equal length. So you could attain a smaller string from a substring of a larger string."
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "[@Adnan_Saif](/Adnan_Saif) UPDATE: my answer got submitted successfully. what I did was simply write ((int)list1.get(i) != (int)list2.get(i)) instead. This solves the problem. But still I could not understand why the previous one did not work."
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Yes I am also stuck on the same testcase. The Line \\n\"if(list1.get(i) != list2.get(i))\" keeps returning true, and I cannot understand how is that possible because both list equals to [826]. Can anybody please help."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Initially it felt hard to do it manually, forget the algorithm :-)"
                    }
                ]
            },
            {
                "id": 2026412,
                "content": [
                    {
                        "username": "Ashish_2002",
                        "content": "Is there any one who is also getting issue with testcase 101. In java language"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly. it should be easy problem. "
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s the approach:\\n\\n1. If values are not equal to each other - return false\\n2. Create Sets/hashMaps for word1 and word2\\n3. Check if both of them have the same alphabet\\n4. Create arrays from both sets and sort them\\n5. In for loop check if they have the same value at each index. if not, return false\\n6. return true"
                    },
                    {
                        "username": "Atchutagowtham",
                        "content": "Why \"uau\" and \"ssx\" is false?\\ncan\\'t i do the following operation\\'s?\\n1) s->u and x->a:    ssx->uua\\n2)swap u and a at indeces 1 and 2 :  uua->uau (equals to word1)\\nWhy the expected result is false, can anyone explain? Thanks in advance:)\\n"
                    },
                    {
                        "username": "zymbolic",
                        "content": "This is an awesome problem"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "i hate it, i hate my life"
                    },
                    {
                        "username": "seleznevgi",
                        "content": "why is this incorrect?\n`\nif (word1.size() != word2.size()) return false;\n        \nset<char> words_1{word1.begin(), word1.end()};\n        \nset<char> words_2{word2.begin(), word2.end()};\n        \nreturn equal(words_1.begin(), words_1.end(), words_2.begin(), words_2.end()) && ;\n `\n\nfails on 132 testcase:\n`word1 =\n\"abbzzca\"\nword2 =\n\"babzzcz\"`\nexpected false, but:\n\nin the word2: a zz -> z aa\n\nthen get word1 from word2 with just swapping characters"
                    },
                    {
                        "username": "user1034wH",
                        "content": "Found out looking at other solutions that the problem does not require the strings to be of equal length. So you could attain a smaller string from a substring of a larger string."
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "[@Adnan_Saif](/Adnan_Saif) UPDATE: my answer got submitted successfully. what I did was simply write ((int)list1.get(i) != (int)list2.get(i)) instead. This solves the problem. But still I could not understand why the previous one did not work."
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Yes I am also stuck on the same testcase. The Line \\n\"if(list1.get(i) != list2.get(i))\" keeps returning true, and I cannot understand how is that possible because both list equals to [826]. Can anybody please help."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Initially it felt hard to do it manually, forget the algorithm :-)"
                    }
                ]
            },
            {
                "id": 2018417,
                "content": [
                    {
                        "username": "Ashish_2002",
                        "content": "Is there any one who is also getting issue with testcase 101. In java language"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly. it should be easy problem. "
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s the approach:\\n\\n1. If values are not equal to each other - return false\\n2. Create Sets/hashMaps for word1 and word2\\n3. Check if both of them have the same alphabet\\n4. Create arrays from both sets and sort them\\n5. In for loop check if they have the same value at each index. if not, return false\\n6. return true"
                    },
                    {
                        "username": "Atchutagowtham",
                        "content": "Why \"uau\" and \"ssx\" is false?\\ncan\\'t i do the following operation\\'s?\\n1) s->u and x->a:    ssx->uua\\n2)swap u and a at indeces 1 and 2 :  uua->uau (equals to word1)\\nWhy the expected result is false, can anyone explain? Thanks in advance:)\\n"
                    },
                    {
                        "username": "zymbolic",
                        "content": "This is an awesome problem"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "i hate it, i hate my life"
                    },
                    {
                        "username": "seleznevgi",
                        "content": "why is this incorrect?\n`\nif (word1.size() != word2.size()) return false;\n        \nset<char> words_1{word1.begin(), word1.end()};\n        \nset<char> words_2{word2.begin(), word2.end()};\n        \nreturn equal(words_1.begin(), words_1.end(), words_2.begin(), words_2.end()) && ;\n `\n\nfails on 132 testcase:\n`word1 =\n\"abbzzca\"\nword2 =\n\"babzzcz\"`\nexpected false, but:\n\nin the word2: a zz -> z aa\n\nthen get word1 from word2 with just swapping characters"
                    },
                    {
                        "username": "user1034wH",
                        "content": "Found out looking at other solutions that the problem does not require the strings to be of equal length. So you could attain a smaller string from a substring of a larger string."
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "[@Adnan_Saif](/Adnan_Saif) UPDATE: my answer got submitted successfully. what I did was simply write ((int)list1.get(i) != (int)list2.get(i)) instead. This solves the problem. But still I could not understand why the previous one did not work."
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Yes I am also stuck on the same testcase. The Line \\n\"if(list1.get(i) != list2.get(i))\" keeps returning true, and I cannot understand how is that possible because both list equals to [826]. Can anybody please help."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Initially it felt hard to do it manually, forget the algorithm :-)"
                    }
                ]
            },
            {
                "id": 2018319,
                "content": [
                    {
                        "username": "Ashish_2002",
                        "content": "Is there any one who is also getting issue with testcase 101. In java language"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly. it should be easy problem. "
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s the approach:\\n\\n1. If values are not equal to each other - return false\\n2. Create Sets/hashMaps for word1 and word2\\n3. Check if both of them have the same alphabet\\n4. Create arrays from both sets and sort them\\n5. In for loop check if they have the same value at each index. if not, return false\\n6. return true"
                    },
                    {
                        "username": "Atchutagowtham",
                        "content": "Why \"uau\" and \"ssx\" is false?\\ncan\\'t i do the following operation\\'s?\\n1) s->u and x->a:    ssx->uua\\n2)swap u and a at indeces 1 and 2 :  uua->uau (equals to word1)\\nWhy the expected result is false, can anyone explain? Thanks in advance:)\\n"
                    },
                    {
                        "username": "zymbolic",
                        "content": "This is an awesome problem"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "i hate it, i hate my life"
                    },
                    {
                        "username": "seleznevgi",
                        "content": "why is this incorrect?\n`\nif (word1.size() != word2.size()) return false;\n        \nset<char> words_1{word1.begin(), word1.end()};\n        \nset<char> words_2{word2.begin(), word2.end()};\n        \nreturn equal(words_1.begin(), words_1.end(), words_2.begin(), words_2.end()) && ;\n `\n\nfails on 132 testcase:\n`word1 =\n\"abbzzca\"\nword2 =\n\"babzzcz\"`\nexpected false, but:\n\nin the word2: a zz -> z aa\n\nthen get word1 from word2 with just swapping characters"
                    },
                    {
                        "username": "user1034wH",
                        "content": "Found out looking at other solutions that the problem does not require the strings to be of equal length. So you could attain a smaller string from a substring of a larger string."
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "[@Adnan_Saif](/Adnan_Saif) UPDATE: my answer got submitted successfully. what I did was simply write ((int)list1.get(i) != (int)list2.get(i)) instead. This solves the problem. But still I could not understand why the previous one did not work."
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Yes I am also stuck on the same testcase. The Line \\n\"if(list1.get(i) != list2.get(i))\" keeps returning true, and I cannot understand how is that possible because both list equals to [826]. Can anybody please help."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Initially it felt hard to do it manually, forget the algorithm :-)"
                    }
                ]
            },
            {
                "id": 2008144,
                "content": [
                    {
                        "username": "Ashish_2002",
                        "content": "Is there any one who is also getting issue with testcase 101. In java language"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly. it should be easy problem. "
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s the approach:\\n\\n1. If values are not equal to each other - return false\\n2. Create Sets/hashMaps for word1 and word2\\n3. Check if both of them have the same alphabet\\n4. Create arrays from both sets and sort them\\n5. In for loop check if they have the same value at each index. if not, return false\\n6. return true"
                    },
                    {
                        "username": "Atchutagowtham",
                        "content": "Why \"uau\" and \"ssx\" is false?\\ncan\\'t i do the following operation\\'s?\\n1) s->u and x->a:    ssx->uua\\n2)swap u and a at indeces 1 and 2 :  uua->uau (equals to word1)\\nWhy the expected result is false, can anyone explain? Thanks in advance:)\\n"
                    },
                    {
                        "username": "zymbolic",
                        "content": "This is an awesome problem"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "i hate it, i hate my life"
                    },
                    {
                        "username": "seleznevgi",
                        "content": "why is this incorrect?\n`\nif (word1.size() != word2.size()) return false;\n        \nset<char> words_1{word1.begin(), word1.end()};\n        \nset<char> words_2{word2.begin(), word2.end()};\n        \nreturn equal(words_1.begin(), words_1.end(), words_2.begin(), words_2.end()) && ;\n `\n\nfails on 132 testcase:\n`word1 =\n\"abbzzca\"\nword2 =\n\"babzzcz\"`\nexpected false, but:\n\nin the word2: a zz -> z aa\n\nthen get word1 from word2 with just swapping characters"
                    },
                    {
                        "username": "user1034wH",
                        "content": "Found out looking at other solutions that the problem does not require the strings to be of equal length. So you could attain a smaller string from a substring of a larger string."
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "[@Adnan_Saif](/Adnan_Saif) UPDATE: my answer got submitted successfully. what I did was simply write ((int)list1.get(i) != (int)list2.get(i)) instead. This solves the problem. But still I could not understand why the previous one did not work."
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Yes I am also stuck on the same testcase. The Line \\n\"if(list1.get(i) != list2.get(i))\" keeps returning true, and I cannot understand how is that possible because both list equals to [826]. Can anybody please help."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Initially it felt hard to do it manually, forget the algorithm :-)"
                    }
                ]
            },
            {
                "id": 1974515,
                "content": [
                    {
                        "username": "Ashish_2002",
                        "content": "Is there any one who is also getting issue with testcase 101. In java language"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly. it should be easy problem. "
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s the approach:\\n\\n1. If values are not equal to each other - return false\\n2. Create Sets/hashMaps for word1 and word2\\n3. Check if both of them have the same alphabet\\n4. Create arrays from both sets and sort them\\n5. In for loop check if they have the same value at each index. if not, return false\\n6. return true"
                    },
                    {
                        "username": "Atchutagowtham",
                        "content": "Why \"uau\" and \"ssx\" is false?\\ncan\\'t i do the following operation\\'s?\\n1) s->u and x->a:    ssx->uua\\n2)swap u and a at indeces 1 and 2 :  uua->uau (equals to word1)\\nWhy the expected result is false, can anyone explain? Thanks in advance:)\\n"
                    },
                    {
                        "username": "zymbolic",
                        "content": "This is an awesome problem"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "i hate it, i hate my life"
                    },
                    {
                        "username": "seleznevgi",
                        "content": "why is this incorrect?\n`\nif (word1.size() != word2.size()) return false;\n        \nset<char> words_1{word1.begin(), word1.end()};\n        \nset<char> words_2{word2.begin(), word2.end()};\n        \nreturn equal(words_1.begin(), words_1.end(), words_2.begin(), words_2.end()) && ;\n `\n\nfails on 132 testcase:\n`word1 =\n\"abbzzca\"\nword2 =\n\"babzzcz\"`\nexpected false, but:\n\nin the word2: a zz -> z aa\n\nthen get word1 from word2 with just swapping characters"
                    },
                    {
                        "username": "user1034wH",
                        "content": "Found out looking at other solutions that the problem does not require the strings to be of equal length. So you could attain a smaller string from a substring of a larger string."
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "[@Adnan_Saif](/Adnan_Saif) UPDATE: my answer got submitted successfully. what I did was simply write ((int)list1.get(i) != (int)list2.get(i)) instead. This solves the problem. But still I could not understand why the previous one did not work."
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Yes I am also stuck on the same testcase. The Line \\n\"if(list1.get(i) != list2.get(i))\" keeps returning true, and I cannot understand how is that possible because both list equals to [826]. Can anybody please help."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Initially it felt hard to do it manually, forget the algorithm :-)"
                    }
                ]
            },
            {
                "id": 1970529,
                "content": [
                    {
                        "username": "Ashish_2002",
                        "content": "Is there any one who is also getting issue with testcase 101. In java language"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly. it should be easy problem. "
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s the approach:\\n\\n1. If values are not equal to each other - return false\\n2. Create Sets/hashMaps for word1 and word2\\n3. Check if both of them have the same alphabet\\n4. Create arrays from both sets and sort them\\n5. In for loop check if they have the same value at each index. if not, return false\\n6. return true"
                    },
                    {
                        "username": "Atchutagowtham",
                        "content": "Why \"uau\" and \"ssx\" is false?\\ncan\\'t i do the following operation\\'s?\\n1) s->u and x->a:    ssx->uua\\n2)swap u and a at indeces 1 and 2 :  uua->uau (equals to word1)\\nWhy the expected result is false, can anyone explain? Thanks in advance:)\\n"
                    },
                    {
                        "username": "zymbolic",
                        "content": "This is an awesome problem"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "i hate it, i hate my life"
                    },
                    {
                        "username": "seleznevgi",
                        "content": "why is this incorrect?\n`\nif (word1.size() != word2.size()) return false;\n        \nset<char> words_1{word1.begin(), word1.end()};\n        \nset<char> words_2{word2.begin(), word2.end()};\n        \nreturn equal(words_1.begin(), words_1.end(), words_2.begin(), words_2.end()) && ;\n `\n\nfails on 132 testcase:\n`word1 =\n\"abbzzca\"\nword2 =\n\"babzzcz\"`\nexpected false, but:\n\nin the word2: a zz -> z aa\n\nthen get word1 from word2 with just swapping characters"
                    },
                    {
                        "username": "user1034wH",
                        "content": "Found out looking at other solutions that the problem does not require the strings to be of equal length. So you could attain a smaller string from a substring of a larger string."
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "[@Adnan_Saif](/Adnan_Saif) UPDATE: my answer got submitted successfully. what I did was simply write ((int)list1.get(i) != (int)list2.get(i)) instead. This solves the problem. But still I could not understand why the previous one did not work."
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Yes I am also stuck on the same testcase. The Line \\n\"if(list1.get(i) != list2.get(i))\" keeps returning true, and I cannot understand how is that possible because both list equals to [826]. Can anybody please help."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Initially it felt hard to do it manually, forget the algorithm :-)"
                    }
                ]
            },
            {
                "id": 1905840,
                "content": [
                    {
                        "username": "Ashish_2002",
                        "content": "Is there any one who is also getting issue with testcase 101. In java language"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly. it should be easy problem. "
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s the approach:\\n\\n1. If values are not equal to each other - return false\\n2. Create Sets/hashMaps for word1 and word2\\n3. Check if both of them have the same alphabet\\n4. Create arrays from both sets and sort them\\n5. In for loop check if they have the same value at each index. if not, return false\\n6. return true"
                    },
                    {
                        "username": "Atchutagowtham",
                        "content": "Why \"uau\" and \"ssx\" is false?\\ncan\\'t i do the following operation\\'s?\\n1) s->u and x->a:    ssx->uua\\n2)swap u and a at indeces 1 and 2 :  uua->uau (equals to word1)\\nWhy the expected result is false, can anyone explain? Thanks in advance:)\\n"
                    },
                    {
                        "username": "zymbolic",
                        "content": "This is an awesome problem"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "i hate it, i hate my life"
                    },
                    {
                        "username": "seleznevgi",
                        "content": "why is this incorrect?\n`\nif (word1.size() != word2.size()) return false;\n        \nset<char> words_1{word1.begin(), word1.end()};\n        \nset<char> words_2{word2.begin(), word2.end()};\n        \nreturn equal(words_1.begin(), words_1.end(), words_2.begin(), words_2.end()) && ;\n `\n\nfails on 132 testcase:\n`word1 =\n\"abbzzca\"\nword2 =\n\"babzzcz\"`\nexpected false, but:\n\nin the word2: a zz -> z aa\n\nthen get word1 from word2 with just swapping characters"
                    },
                    {
                        "username": "user1034wH",
                        "content": "Found out looking at other solutions that the problem does not require the strings to be of equal length. So you could attain a smaller string from a substring of a larger string."
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Failing for me for testcase 102 where word1 and word2 are \"iiii....\" 826 i\\'s.\\n\\nclass Solution {\\n    public boolean closeStrings(String word1, String word2) {\\n        \\n        if(word1.length() != word2.length()) return false;\\n\\n        HashMap<Character, Integer> map1 = new HashMap<>();\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n\\n        for(int i= 0; i<word1.length(); i++){\\n            map1.put(word1.charAt(i), map1.getOrDefault(word1.charAt(i), 0)+1);\\n            map2.put(word2.charAt(i), map2.getOrDefault(word2.charAt(i), 0)+1);\\n        }\\n        for(Character c: map1.keySet()){\\n\\n            if(!map2.containsKey(c)) return false;\\n        }\\n        \\n        ArrayList<Integer> list1 = new ArrayList<>(map1.values());\\n        Collections.sort(list1);\\n        ArrayList<Integer> list2 = new ArrayList<>(map2.values());\\n        Collections.sort(list2);\\n        if(list2.size() != list1.size()) return false;\\n\\n        for(int i=0; i<list1.size(); i++){\\n            if(list1.get(i) != list2.get(i)) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "[@Adnan_Saif](/Adnan_Saif) UPDATE: my answer got submitted successfully. what I did was simply write ((int)list1.get(i) != (int)list2.get(i)) instead. This solves the problem. But still I could not understand why the previous one did not work."
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Yes I am also stuck on the same testcase. The Line \\n\"if(list1.get(i) != list2.get(i))\" keeps returning true, and I cannot understand how is that possible because both list equals to [826]. Can anybody please help."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Initially it felt hard to do it manually, forget the algorithm :-)"
                    }
                ]
            },
            {
                "id": 1720401,
                "content": [
                    {
                        "username": "Raja_7321",
                        "content": "bool closeStrings(string word1, string word2) {\\n        if(word1.size()==word2.size()){\\n           vector<int>freq1(26,0);\\n           vector<int>freq2(26,0);\\n           for(int i=0;i<word1.size();i++){\\n               freq1[word1[i]-\\'a\\']++;\\n               freq2[word2[i]-\\'a\\']++;\\n           }\\n           for(int i=0;i<26;i++){\\n               if(freq1[i]==0 && freq2[i]!=0){\\n                       return false;\\n               }\\n               else if(freq1[i]!=0 && freq2[i]==0){\\n                   return false;\\n               }\\n           }\\n           for(int i=0;i<26;i++){\\n              bool flag=true;\\n              for(int j=0;j<26;j++){\\n                  if(freq1[i]==freq2[j]){\\n                      flag=false;\\n                      freq2[j]=0;\\n                      break;\\n                  }\\n              }\\n              if(flag){\\n                  return false;\\n              }\\n           }\\n           return true;\\n           \\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "What is the best time complexity we can achieve for this problem??"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "Is it O(NlogN) \\nas we have to use sort at least once in this.\\n"
                    },
                    {
                        "username": "monapriya",
                        "content": " `\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        pq1.add(2);\\n        pq1.add(1);\\n        pq1.add(3);\\n\\n        pq2.add(3);\\n        pq2.add(2);\\n        pq2.add(1);\\n\\n        System.out.println(pq1.equals(pq2));\\n}`\\nCan anyone please help me understand, what output this code gives and why?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This code creates two priority queues and add some elements in both of them. I'm suspecting that you want to compare if both queues have the same elements but the default implementation of equals here will return false.\n\nOne way to check if your queues are equal is something like this:\n```\nfor (Object element : pq1){\n    System.out.println(pq2.contains(element) ? true : false);\n   }\n```"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "I have tested 6 cases (added the failed cases after submitting the solution implemented in golang) and sill stuck with one testcase always failing irrespective of the input satisfies all the criteria :\n\nInput :\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\nOutput :\n  `true`\n\nExpected :\n  `false`\n\ndebug print :\n`k1: map[a:2 b:2 c:1 z:2] || k2: map[a:1 b:2 c:1 z:3]` \n`matching a, true || matching b, true || matching z, true || matching c, true || `\n\nAm i missing some thing here or the expected testcase result is incorrect ?\nThanks in advance."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) you should sort the 2 maps, and then compare indexes.\n\nif (map1[0] === map2[0] && map1[1] === map2[1] ... ) {\n  return true;\n} else {\n  return false;\n}\n\nIn this case, [ 1, 2, 2, 2 ],   [  1, 1, 2, 3 ], map1[1] is different from map2[1] so I'd return false because of that.\n\nIn my case I didn't found a way to sort the maps based on their values, so I converted them into arrays from the maps."
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@fsdevelop](/fsdevelop) I have two such different testcases :\n\nTestCase 1: -> this WORKS FINE even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 =  \"cabbba\"`\n  `word2 = \"abbccc\"`\n\n`Output: true`\n\n`Expected: true`\n\nDebug Print:\n`map[a:2 b:3 c:1] map[a:1 b:2 c:3]`\n`matching c, true || matching a, true || matching b, true || `  (matching only the keys)\n\n========================================\n\nTestCase 2: -> this DOESN'T WORKS even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\n`Output: true`\n\n`Expected: false`\n\nDebug Print:\n`map[a:2 b:2 c:1 z:2] map[a:1 b:2 c:1 z:3]`\n`matching a, true || matching b, true || matching z, true || matching c, true || ` (matching only the keys)\n\nIf i am validating the equality of sorted arrays, it breaks the first case.\nTherefore, I am still doubting that the two testcases are similar but produces two different results where either testcae1 or testcase2 expected result is invalid.\n"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) You need the two arrays I mentioned to be identical after sorted.\\n\\n[1, 2, 3] == [3, 1, 2] => true\\n[2, 3, 4] != [1, 3, 4]  => false"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@Federico Sosa](/fsdevelop) Thanks a lot for the explanation... I'll fix the code and try again."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I faced the same problem here. The key to solve this challenge is also to check how many times each letter appear in each word.\\n\\nFor example in \"abbzzca\":\\n- \"a\" appears 2 times\\n- \"b\" appears 2 times\\n- \"z\" appears 2 times\\n- \"c\" appears 1 time.\\n\\nAnd then, in \"babzzcz\":\\n- \"a\" appears 1 time\\n- \"b\" appears 2 times\\n- \"z\" appears 3 times\\n- \"c\" appears 1 time\\n\\nIf you compare these arrays [2, 2, 2, 1], [1, 2, 3, 1] they don\\'t match in numbers, so even if you make any of the 2 operations it won\\'t be possible to match each word."
                    },
                    {
                        "username": "aerosync",
                        "content": "can someone explain to me what word1[c-\\'a\\']++ is doing in everyones c++ code. i dont understand the -\\'a\\' syntax or what its doing"
                    },
                    {
                        "username": "wyldbill",
                        "content": "c - \\'a\\' provides a 0 based index to the letter. 0->a, 1->b, 2->c, etc. useful for indexing based on letters into an alphabet sized array."
                    },
                    {
                        "username": "dkashi",
                        "content": "two strings are close if following conditions are met:\\n    1. len(word1) == len(word2)\\n    2. counter(word1).keys() == counter(word2).keys()\\n        e.g. word1 = \"cabbba\", word2 = \"abbccc\"\\n        counter(word1) = {\\'c\\': 1, \\'a\\': 2, \\'b\\': 3}\\n        counter(word2) = {\\'a\\': 1, \\'b\\':2, \\'c\\':3}\\n        so {\\'a\\', \\'b\\', \\'c\\'} should occur in both words and no extra letters should exist\\n    3. Count of different values in counter should be same.\\n        e.g. word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\n        Counter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2}   => values are [5, 5, 4, 3, 2, 2]\\n        Counter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\n        if the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "This code works perfectly fine for 1657. Determine if Two Strings Are Close ... looking for how i can optimize this solution. Current time complexity goes O(4n). Looking for suggestions on how can i make it to O(n)\n \n    public boolean closeStrings(String word1, String word2) {\n        Map<Character, Integer> char_count_of_word1 = new HashMap<>();\n        Map<Character, Integer> char_count_of_word2 = new HashMap<>();\n\n        for(int i=0; i<word1.length(); i++){\n            if(char_count_of_word1.containsKey(word1.charAt(i))){\n                int current_count = char_count_of_word1.get(word1.charAt(i));\n                char_count_of_word1.put(word1.charAt(i), ++current_count);\n            } else {\n                char_count_of_word1.put(word1.charAt(i), 1);\n            }\n        }\n        for(int i=0; i<word2.length(); i++){\n            if(char_count_of_word2.containsKey(word2.charAt(i))){\n                int current_count = char_count_of_word2.get(word2.charAt(i));\n                char_count_of_word2.put(word2.charAt(i), ++current_count);\n            } else {\n                char_count_of_word2.put(word2.charAt(i), 1);\n            }\n        }\n\n        ArrayList<Character> list1_char = new ArrayList<>();\n        ArrayList<Integer> list1_count = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word1.entrySet()){\n            list1_count.add(entry.getValue());\n            list1_char.add(entry.getKey());\n        }\n\n        ArrayList<Integer> list2_count = new ArrayList<>();\n        ArrayList<Character> list2_char = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word2.entrySet()){\n            list2_count.add(entry.getValue());\n            list2_char.add(entry.getKey());\n        }\n\n        Collections.sort(list1_count);\n        Collections.sort(list1_char);\n        Collections.sort(list2_count);\n        Collections.sort(list2_char);\n        \n        if (list1_count.equals(list2_count) && list1_char.equals(list2_char)){\n            return true;\n        }\n        return false;\n    }\n"
                    },
                    {
                        "username": "DDKK64",
                        "content": "Just an IQ test problem. No much knowledge in it.  :("
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "1. We can not insert or delete any character from strings, so length of both strings should be equal.\\n2. Also, From point 1, both strings should have same set of characters, example: string1=\"abc\" , string2=\"abd\", because we cannot convert \\'c\\' to \\'d\\'.\\n3. Now we can convert any string s1 to string s2, if they have same set of frequencies for the characters.\\nExample:\\nstring s1=\"abbbcdc\"\\nfreq: a=1, b=3, c=2, d=1\\nstring s2=\"aabcdac\"\\nfreq: a=3, b=1, c=2, d=1\\nset of freq for s1 are (in sorted order): 1,1,2,3\\nset of freq for s2 are (in sorted order): 1,1,2,3\\n\\nboth are same. so we can make s1 equals to s2.\\nOther wise we cannot convert s1 to s2."
                    },
                    {
                        "username": "subodhr2001",
                        "content": "Input:\n\"aaabbbbccddeeeeefffff\"\n\"aaaaabbcccdddeeeeffff\"\n\nWhy is the result true for this test case 147? How can these two strings be called close? For example here is only one character with frequency = 5 in word2 whereas 2 characters with frequency = 5 in word 1.  How can we apply the second operation properly here using one-to-one mapping?"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Its result will be false, not true.\\nI have tested these input and its also expecting false only."
                    }
                ]
            },
            {
                "id": 1704181,
                "content": [
                    {
                        "username": "Raja_7321",
                        "content": "bool closeStrings(string word1, string word2) {\\n        if(word1.size()==word2.size()){\\n           vector<int>freq1(26,0);\\n           vector<int>freq2(26,0);\\n           for(int i=0;i<word1.size();i++){\\n               freq1[word1[i]-\\'a\\']++;\\n               freq2[word2[i]-\\'a\\']++;\\n           }\\n           for(int i=0;i<26;i++){\\n               if(freq1[i]==0 && freq2[i]!=0){\\n                       return false;\\n               }\\n               else if(freq1[i]!=0 && freq2[i]==0){\\n                   return false;\\n               }\\n           }\\n           for(int i=0;i<26;i++){\\n              bool flag=true;\\n              for(int j=0;j<26;j++){\\n                  if(freq1[i]==freq2[j]){\\n                      flag=false;\\n                      freq2[j]=0;\\n                      break;\\n                  }\\n              }\\n              if(flag){\\n                  return false;\\n              }\\n           }\\n           return true;\\n           \\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "What is the best time complexity we can achieve for this problem??"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "Is it O(NlogN) \\nas we have to use sort at least once in this.\\n"
                    },
                    {
                        "username": "monapriya",
                        "content": " `\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        pq1.add(2);\\n        pq1.add(1);\\n        pq1.add(3);\\n\\n        pq2.add(3);\\n        pq2.add(2);\\n        pq2.add(1);\\n\\n        System.out.println(pq1.equals(pq2));\\n}`\\nCan anyone please help me understand, what output this code gives and why?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This code creates two priority queues and add some elements in both of them. I'm suspecting that you want to compare if both queues have the same elements but the default implementation of equals here will return false.\n\nOne way to check if your queues are equal is something like this:\n```\nfor (Object element : pq1){\n    System.out.println(pq2.contains(element) ? true : false);\n   }\n```"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "I have tested 6 cases (added the failed cases after submitting the solution implemented in golang) and sill stuck with one testcase always failing irrespective of the input satisfies all the criteria :\n\nInput :\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\nOutput :\n  `true`\n\nExpected :\n  `false`\n\ndebug print :\n`k1: map[a:2 b:2 c:1 z:2] || k2: map[a:1 b:2 c:1 z:3]` \n`matching a, true || matching b, true || matching z, true || matching c, true || `\n\nAm i missing some thing here or the expected testcase result is incorrect ?\nThanks in advance."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) you should sort the 2 maps, and then compare indexes.\n\nif (map1[0] === map2[0] && map1[1] === map2[1] ... ) {\n  return true;\n} else {\n  return false;\n}\n\nIn this case, [ 1, 2, 2, 2 ],   [  1, 1, 2, 3 ], map1[1] is different from map2[1] so I'd return false because of that.\n\nIn my case I didn't found a way to sort the maps based on their values, so I converted them into arrays from the maps."
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@fsdevelop](/fsdevelop) I have two such different testcases :\n\nTestCase 1: -> this WORKS FINE even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 =  \"cabbba\"`\n  `word2 = \"abbccc\"`\n\n`Output: true`\n\n`Expected: true`\n\nDebug Print:\n`map[a:2 b:3 c:1] map[a:1 b:2 c:3]`\n`matching c, true || matching a, true || matching b, true || `  (matching only the keys)\n\n========================================\n\nTestCase 2: -> this DOESN'T WORKS even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\n`Output: true`\n\n`Expected: false`\n\nDebug Print:\n`map[a:2 b:2 c:1 z:2] map[a:1 b:2 c:1 z:3]`\n`matching a, true || matching b, true || matching z, true || matching c, true || ` (matching only the keys)\n\nIf i am validating the equality of sorted arrays, it breaks the first case.\nTherefore, I am still doubting that the two testcases are similar but produces two different results where either testcae1 or testcase2 expected result is invalid.\n"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) You need the two arrays I mentioned to be identical after sorted.\\n\\n[1, 2, 3] == [3, 1, 2] => true\\n[2, 3, 4] != [1, 3, 4]  => false"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@Federico Sosa](/fsdevelop) Thanks a lot for the explanation... I'll fix the code and try again."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I faced the same problem here. The key to solve this challenge is also to check how many times each letter appear in each word.\\n\\nFor example in \"abbzzca\":\\n- \"a\" appears 2 times\\n- \"b\" appears 2 times\\n- \"z\" appears 2 times\\n- \"c\" appears 1 time.\\n\\nAnd then, in \"babzzcz\":\\n- \"a\" appears 1 time\\n- \"b\" appears 2 times\\n- \"z\" appears 3 times\\n- \"c\" appears 1 time\\n\\nIf you compare these arrays [2, 2, 2, 1], [1, 2, 3, 1] they don\\'t match in numbers, so even if you make any of the 2 operations it won\\'t be possible to match each word."
                    },
                    {
                        "username": "aerosync",
                        "content": "can someone explain to me what word1[c-\\'a\\']++ is doing in everyones c++ code. i dont understand the -\\'a\\' syntax or what its doing"
                    },
                    {
                        "username": "wyldbill",
                        "content": "c - \\'a\\' provides a 0 based index to the letter. 0->a, 1->b, 2->c, etc. useful for indexing based on letters into an alphabet sized array."
                    },
                    {
                        "username": "dkashi",
                        "content": "two strings are close if following conditions are met:\\n    1. len(word1) == len(word2)\\n    2. counter(word1).keys() == counter(word2).keys()\\n        e.g. word1 = \"cabbba\", word2 = \"abbccc\"\\n        counter(word1) = {\\'c\\': 1, \\'a\\': 2, \\'b\\': 3}\\n        counter(word2) = {\\'a\\': 1, \\'b\\':2, \\'c\\':3}\\n        so {\\'a\\', \\'b\\', \\'c\\'} should occur in both words and no extra letters should exist\\n    3. Count of different values in counter should be same.\\n        e.g. word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\n        Counter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2}   => values are [5, 5, 4, 3, 2, 2]\\n        Counter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\n        if the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "This code works perfectly fine for 1657. Determine if Two Strings Are Close ... looking for how i can optimize this solution. Current time complexity goes O(4n). Looking for suggestions on how can i make it to O(n)\n \n    public boolean closeStrings(String word1, String word2) {\n        Map<Character, Integer> char_count_of_word1 = new HashMap<>();\n        Map<Character, Integer> char_count_of_word2 = new HashMap<>();\n\n        for(int i=0; i<word1.length(); i++){\n            if(char_count_of_word1.containsKey(word1.charAt(i))){\n                int current_count = char_count_of_word1.get(word1.charAt(i));\n                char_count_of_word1.put(word1.charAt(i), ++current_count);\n            } else {\n                char_count_of_word1.put(word1.charAt(i), 1);\n            }\n        }\n        for(int i=0; i<word2.length(); i++){\n            if(char_count_of_word2.containsKey(word2.charAt(i))){\n                int current_count = char_count_of_word2.get(word2.charAt(i));\n                char_count_of_word2.put(word2.charAt(i), ++current_count);\n            } else {\n                char_count_of_word2.put(word2.charAt(i), 1);\n            }\n        }\n\n        ArrayList<Character> list1_char = new ArrayList<>();\n        ArrayList<Integer> list1_count = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word1.entrySet()){\n            list1_count.add(entry.getValue());\n            list1_char.add(entry.getKey());\n        }\n\n        ArrayList<Integer> list2_count = new ArrayList<>();\n        ArrayList<Character> list2_char = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word2.entrySet()){\n            list2_count.add(entry.getValue());\n            list2_char.add(entry.getKey());\n        }\n\n        Collections.sort(list1_count);\n        Collections.sort(list1_char);\n        Collections.sort(list2_count);\n        Collections.sort(list2_char);\n        \n        if (list1_count.equals(list2_count) && list1_char.equals(list2_char)){\n            return true;\n        }\n        return false;\n    }\n"
                    },
                    {
                        "username": "DDKK64",
                        "content": "Just an IQ test problem. No much knowledge in it.  :("
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "1. We can not insert or delete any character from strings, so length of both strings should be equal.\\n2. Also, From point 1, both strings should have same set of characters, example: string1=\"abc\" , string2=\"abd\", because we cannot convert \\'c\\' to \\'d\\'.\\n3. Now we can convert any string s1 to string s2, if they have same set of frequencies for the characters.\\nExample:\\nstring s1=\"abbbcdc\"\\nfreq: a=1, b=3, c=2, d=1\\nstring s2=\"aabcdac\"\\nfreq: a=3, b=1, c=2, d=1\\nset of freq for s1 are (in sorted order): 1,1,2,3\\nset of freq for s2 are (in sorted order): 1,1,2,3\\n\\nboth are same. so we can make s1 equals to s2.\\nOther wise we cannot convert s1 to s2."
                    },
                    {
                        "username": "subodhr2001",
                        "content": "Input:\n\"aaabbbbccddeeeeefffff\"\n\"aaaaabbcccdddeeeeffff\"\n\nWhy is the result true for this test case 147? How can these two strings be called close? For example here is only one character with frequency = 5 in word2 whereas 2 characters with frequency = 5 in word 1.  How can we apply the second operation properly here using one-to-one mapping?"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Its result will be false, not true.\\nI have tested these input and its also expecting false only."
                    }
                ]
            },
            {
                "id": 1703565,
                "content": [
                    {
                        "username": "Raja_7321",
                        "content": "bool closeStrings(string word1, string word2) {\\n        if(word1.size()==word2.size()){\\n           vector<int>freq1(26,0);\\n           vector<int>freq2(26,0);\\n           for(int i=0;i<word1.size();i++){\\n               freq1[word1[i]-\\'a\\']++;\\n               freq2[word2[i]-\\'a\\']++;\\n           }\\n           for(int i=0;i<26;i++){\\n               if(freq1[i]==0 && freq2[i]!=0){\\n                       return false;\\n               }\\n               else if(freq1[i]!=0 && freq2[i]==0){\\n                   return false;\\n               }\\n           }\\n           for(int i=0;i<26;i++){\\n              bool flag=true;\\n              for(int j=0;j<26;j++){\\n                  if(freq1[i]==freq2[j]){\\n                      flag=false;\\n                      freq2[j]=0;\\n                      break;\\n                  }\\n              }\\n              if(flag){\\n                  return false;\\n              }\\n           }\\n           return true;\\n           \\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "What is the best time complexity we can achieve for this problem??"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "Is it O(NlogN) \\nas we have to use sort at least once in this.\\n"
                    },
                    {
                        "username": "monapriya",
                        "content": " `\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        pq1.add(2);\\n        pq1.add(1);\\n        pq1.add(3);\\n\\n        pq2.add(3);\\n        pq2.add(2);\\n        pq2.add(1);\\n\\n        System.out.println(pq1.equals(pq2));\\n}`\\nCan anyone please help me understand, what output this code gives and why?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This code creates two priority queues and add some elements in both of them. I'm suspecting that you want to compare if both queues have the same elements but the default implementation of equals here will return false.\n\nOne way to check if your queues are equal is something like this:\n```\nfor (Object element : pq1){\n    System.out.println(pq2.contains(element) ? true : false);\n   }\n```"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "I have tested 6 cases (added the failed cases after submitting the solution implemented in golang) and sill stuck with one testcase always failing irrespective of the input satisfies all the criteria :\n\nInput :\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\nOutput :\n  `true`\n\nExpected :\n  `false`\n\ndebug print :\n`k1: map[a:2 b:2 c:1 z:2] || k2: map[a:1 b:2 c:1 z:3]` \n`matching a, true || matching b, true || matching z, true || matching c, true || `\n\nAm i missing some thing here or the expected testcase result is incorrect ?\nThanks in advance."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) you should sort the 2 maps, and then compare indexes.\n\nif (map1[0] === map2[0] && map1[1] === map2[1] ... ) {\n  return true;\n} else {\n  return false;\n}\n\nIn this case, [ 1, 2, 2, 2 ],   [  1, 1, 2, 3 ], map1[1] is different from map2[1] so I'd return false because of that.\n\nIn my case I didn't found a way to sort the maps based on their values, so I converted them into arrays from the maps."
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@fsdevelop](/fsdevelop) I have two such different testcases :\n\nTestCase 1: -> this WORKS FINE even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 =  \"cabbba\"`\n  `word2 = \"abbccc\"`\n\n`Output: true`\n\n`Expected: true`\n\nDebug Print:\n`map[a:2 b:3 c:1] map[a:1 b:2 c:3]`\n`matching c, true || matching a, true || matching b, true || `  (matching only the keys)\n\n========================================\n\nTestCase 2: -> this DOESN'T WORKS even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\n`Output: true`\n\n`Expected: false`\n\nDebug Print:\n`map[a:2 b:2 c:1 z:2] map[a:1 b:2 c:1 z:3]`\n`matching a, true || matching b, true || matching z, true || matching c, true || ` (matching only the keys)\n\nIf i am validating the equality of sorted arrays, it breaks the first case.\nTherefore, I am still doubting that the two testcases are similar but produces two different results where either testcae1 or testcase2 expected result is invalid.\n"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) You need the two arrays I mentioned to be identical after sorted.\\n\\n[1, 2, 3] == [3, 1, 2] => true\\n[2, 3, 4] != [1, 3, 4]  => false"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@Federico Sosa](/fsdevelop) Thanks a lot for the explanation... I'll fix the code and try again."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I faced the same problem here. The key to solve this challenge is also to check how many times each letter appear in each word.\\n\\nFor example in \"abbzzca\":\\n- \"a\" appears 2 times\\n- \"b\" appears 2 times\\n- \"z\" appears 2 times\\n- \"c\" appears 1 time.\\n\\nAnd then, in \"babzzcz\":\\n- \"a\" appears 1 time\\n- \"b\" appears 2 times\\n- \"z\" appears 3 times\\n- \"c\" appears 1 time\\n\\nIf you compare these arrays [2, 2, 2, 1], [1, 2, 3, 1] they don\\'t match in numbers, so even if you make any of the 2 operations it won\\'t be possible to match each word."
                    },
                    {
                        "username": "aerosync",
                        "content": "can someone explain to me what word1[c-\\'a\\']++ is doing in everyones c++ code. i dont understand the -\\'a\\' syntax or what its doing"
                    },
                    {
                        "username": "wyldbill",
                        "content": "c - \\'a\\' provides a 0 based index to the letter. 0->a, 1->b, 2->c, etc. useful for indexing based on letters into an alphabet sized array."
                    },
                    {
                        "username": "dkashi",
                        "content": "two strings are close if following conditions are met:\\n    1. len(word1) == len(word2)\\n    2. counter(word1).keys() == counter(word2).keys()\\n        e.g. word1 = \"cabbba\", word2 = \"abbccc\"\\n        counter(word1) = {\\'c\\': 1, \\'a\\': 2, \\'b\\': 3}\\n        counter(word2) = {\\'a\\': 1, \\'b\\':2, \\'c\\':3}\\n        so {\\'a\\', \\'b\\', \\'c\\'} should occur in both words and no extra letters should exist\\n    3. Count of different values in counter should be same.\\n        e.g. word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\n        Counter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2}   => values are [5, 5, 4, 3, 2, 2]\\n        Counter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\n        if the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "This code works perfectly fine for 1657. Determine if Two Strings Are Close ... looking for how i can optimize this solution. Current time complexity goes O(4n). Looking for suggestions on how can i make it to O(n)\n \n    public boolean closeStrings(String word1, String word2) {\n        Map<Character, Integer> char_count_of_word1 = new HashMap<>();\n        Map<Character, Integer> char_count_of_word2 = new HashMap<>();\n\n        for(int i=0; i<word1.length(); i++){\n            if(char_count_of_word1.containsKey(word1.charAt(i))){\n                int current_count = char_count_of_word1.get(word1.charAt(i));\n                char_count_of_word1.put(word1.charAt(i), ++current_count);\n            } else {\n                char_count_of_word1.put(word1.charAt(i), 1);\n            }\n        }\n        for(int i=0; i<word2.length(); i++){\n            if(char_count_of_word2.containsKey(word2.charAt(i))){\n                int current_count = char_count_of_word2.get(word2.charAt(i));\n                char_count_of_word2.put(word2.charAt(i), ++current_count);\n            } else {\n                char_count_of_word2.put(word2.charAt(i), 1);\n            }\n        }\n\n        ArrayList<Character> list1_char = new ArrayList<>();\n        ArrayList<Integer> list1_count = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word1.entrySet()){\n            list1_count.add(entry.getValue());\n            list1_char.add(entry.getKey());\n        }\n\n        ArrayList<Integer> list2_count = new ArrayList<>();\n        ArrayList<Character> list2_char = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word2.entrySet()){\n            list2_count.add(entry.getValue());\n            list2_char.add(entry.getKey());\n        }\n\n        Collections.sort(list1_count);\n        Collections.sort(list1_char);\n        Collections.sort(list2_count);\n        Collections.sort(list2_char);\n        \n        if (list1_count.equals(list2_count) && list1_char.equals(list2_char)){\n            return true;\n        }\n        return false;\n    }\n"
                    },
                    {
                        "username": "DDKK64",
                        "content": "Just an IQ test problem. No much knowledge in it.  :("
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "1. We can not insert or delete any character from strings, so length of both strings should be equal.\\n2. Also, From point 1, both strings should have same set of characters, example: string1=\"abc\" , string2=\"abd\", because we cannot convert \\'c\\' to \\'d\\'.\\n3. Now we can convert any string s1 to string s2, if they have same set of frequencies for the characters.\\nExample:\\nstring s1=\"abbbcdc\"\\nfreq: a=1, b=3, c=2, d=1\\nstring s2=\"aabcdac\"\\nfreq: a=3, b=1, c=2, d=1\\nset of freq for s1 are (in sorted order): 1,1,2,3\\nset of freq for s2 are (in sorted order): 1,1,2,3\\n\\nboth are same. so we can make s1 equals to s2.\\nOther wise we cannot convert s1 to s2."
                    },
                    {
                        "username": "subodhr2001",
                        "content": "Input:\n\"aaabbbbccddeeeeefffff\"\n\"aaaaabbcccdddeeeeffff\"\n\nWhy is the result true for this test case 147? How can these two strings be called close? For example here is only one character with frequency = 5 in word2 whereas 2 characters with frequency = 5 in word 1.  How can we apply the second operation properly here using one-to-one mapping?"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Its result will be false, not true.\\nI have tested these input and its also expecting false only."
                    }
                ]
            },
            {
                "id": 1703456,
                "content": [
                    {
                        "username": "Raja_7321",
                        "content": "bool closeStrings(string word1, string word2) {\\n        if(word1.size()==word2.size()){\\n           vector<int>freq1(26,0);\\n           vector<int>freq2(26,0);\\n           for(int i=0;i<word1.size();i++){\\n               freq1[word1[i]-\\'a\\']++;\\n               freq2[word2[i]-\\'a\\']++;\\n           }\\n           for(int i=0;i<26;i++){\\n               if(freq1[i]==0 && freq2[i]!=0){\\n                       return false;\\n               }\\n               else if(freq1[i]!=0 && freq2[i]==0){\\n                   return false;\\n               }\\n           }\\n           for(int i=0;i<26;i++){\\n              bool flag=true;\\n              for(int j=0;j<26;j++){\\n                  if(freq1[i]==freq2[j]){\\n                      flag=false;\\n                      freq2[j]=0;\\n                      break;\\n                  }\\n              }\\n              if(flag){\\n                  return false;\\n              }\\n           }\\n           return true;\\n           \\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "What is the best time complexity we can achieve for this problem??"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "Is it O(NlogN) \\nas we have to use sort at least once in this.\\n"
                    },
                    {
                        "username": "monapriya",
                        "content": " `\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        pq1.add(2);\\n        pq1.add(1);\\n        pq1.add(3);\\n\\n        pq2.add(3);\\n        pq2.add(2);\\n        pq2.add(1);\\n\\n        System.out.println(pq1.equals(pq2));\\n}`\\nCan anyone please help me understand, what output this code gives and why?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This code creates two priority queues and add some elements in both of them. I'm suspecting that you want to compare if both queues have the same elements but the default implementation of equals here will return false.\n\nOne way to check if your queues are equal is something like this:\n```\nfor (Object element : pq1){\n    System.out.println(pq2.contains(element) ? true : false);\n   }\n```"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "I have tested 6 cases (added the failed cases after submitting the solution implemented in golang) and sill stuck with one testcase always failing irrespective of the input satisfies all the criteria :\n\nInput :\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\nOutput :\n  `true`\n\nExpected :\n  `false`\n\ndebug print :\n`k1: map[a:2 b:2 c:1 z:2] || k2: map[a:1 b:2 c:1 z:3]` \n`matching a, true || matching b, true || matching z, true || matching c, true || `\n\nAm i missing some thing here or the expected testcase result is incorrect ?\nThanks in advance."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) you should sort the 2 maps, and then compare indexes.\n\nif (map1[0] === map2[0] && map1[1] === map2[1] ... ) {\n  return true;\n} else {\n  return false;\n}\n\nIn this case, [ 1, 2, 2, 2 ],   [  1, 1, 2, 3 ], map1[1] is different from map2[1] so I'd return false because of that.\n\nIn my case I didn't found a way to sort the maps based on their values, so I converted them into arrays from the maps."
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@fsdevelop](/fsdevelop) I have two such different testcases :\n\nTestCase 1: -> this WORKS FINE even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 =  \"cabbba\"`\n  `word2 = \"abbccc\"`\n\n`Output: true`\n\n`Expected: true`\n\nDebug Print:\n`map[a:2 b:3 c:1] map[a:1 b:2 c:3]`\n`matching c, true || matching a, true || matching b, true || `  (matching only the keys)\n\n========================================\n\nTestCase 2: -> this DOESN'T WORKS even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\n`Output: true`\n\n`Expected: false`\n\nDebug Print:\n`map[a:2 b:2 c:1 z:2] map[a:1 b:2 c:1 z:3]`\n`matching a, true || matching b, true || matching z, true || matching c, true || ` (matching only the keys)\n\nIf i am validating the equality of sorted arrays, it breaks the first case.\nTherefore, I am still doubting that the two testcases are similar but produces two different results where either testcae1 or testcase2 expected result is invalid.\n"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) You need the two arrays I mentioned to be identical after sorted.\\n\\n[1, 2, 3] == [3, 1, 2] => true\\n[2, 3, 4] != [1, 3, 4]  => false"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@Federico Sosa](/fsdevelop) Thanks a lot for the explanation... I'll fix the code and try again."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I faced the same problem here. The key to solve this challenge is also to check how many times each letter appear in each word.\\n\\nFor example in \"abbzzca\":\\n- \"a\" appears 2 times\\n- \"b\" appears 2 times\\n- \"z\" appears 2 times\\n- \"c\" appears 1 time.\\n\\nAnd then, in \"babzzcz\":\\n- \"a\" appears 1 time\\n- \"b\" appears 2 times\\n- \"z\" appears 3 times\\n- \"c\" appears 1 time\\n\\nIf you compare these arrays [2, 2, 2, 1], [1, 2, 3, 1] they don\\'t match in numbers, so even if you make any of the 2 operations it won\\'t be possible to match each word."
                    },
                    {
                        "username": "aerosync",
                        "content": "can someone explain to me what word1[c-\\'a\\']++ is doing in everyones c++ code. i dont understand the -\\'a\\' syntax or what its doing"
                    },
                    {
                        "username": "wyldbill",
                        "content": "c - \\'a\\' provides a 0 based index to the letter. 0->a, 1->b, 2->c, etc. useful for indexing based on letters into an alphabet sized array."
                    },
                    {
                        "username": "dkashi",
                        "content": "two strings are close if following conditions are met:\\n    1. len(word1) == len(word2)\\n    2. counter(word1).keys() == counter(word2).keys()\\n        e.g. word1 = \"cabbba\", word2 = \"abbccc\"\\n        counter(word1) = {\\'c\\': 1, \\'a\\': 2, \\'b\\': 3}\\n        counter(word2) = {\\'a\\': 1, \\'b\\':2, \\'c\\':3}\\n        so {\\'a\\', \\'b\\', \\'c\\'} should occur in both words and no extra letters should exist\\n    3. Count of different values in counter should be same.\\n        e.g. word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\n        Counter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2}   => values are [5, 5, 4, 3, 2, 2]\\n        Counter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\n        if the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "This code works perfectly fine for 1657. Determine if Two Strings Are Close ... looking for how i can optimize this solution. Current time complexity goes O(4n). Looking for suggestions on how can i make it to O(n)\n \n    public boolean closeStrings(String word1, String word2) {\n        Map<Character, Integer> char_count_of_word1 = new HashMap<>();\n        Map<Character, Integer> char_count_of_word2 = new HashMap<>();\n\n        for(int i=0; i<word1.length(); i++){\n            if(char_count_of_word1.containsKey(word1.charAt(i))){\n                int current_count = char_count_of_word1.get(word1.charAt(i));\n                char_count_of_word1.put(word1.charAt(i), ++current_count);\n            } else {\n                char_count_of_word1.put(word1.charAt(i), 1);\n            }\n        }\n        for(int i=0; i<word2.length(); i++){\n            if(char_count_of_word2.containsKey(word2.charAt(i))){\n                int current_count = char_count_of_word2.get(word2.charAt(i));\n                char_count_of_word2.put(word2.charAt(i), ++current_count);\n            } else {\n                char_count_of_word2.put(word2.charAt(i), 1);\n            }\n        }\n\n        ArrayList<Character> list1_char = new ArrayList<>();\n        ArrayList<Integer> list1_count = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word1.entrySet()){\n            list1_count.add(entry.getValue());\n            list1_char.add(entry.getKey());\n        }\n\n        ArrayList<Integer> list2_count = new ArrayList<>();\n        ArrayList<Character> list2_char = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word2.entrySet()){\n            list2_count.add(entry.getValue());\n            list2_char.add(entry.getKey());\n        }\n\n        Collections.sort(list1_count);\n        Collections.sort(list1_char);\n        Collections.sort(list2_count);\n        Collections.sort(list2_char);\n        \n        if (list1_count.equals(list2_count) && list1_char.equals(list2_char)){\n            return true;\n        }\n        return false;\n    }\n"
                    },
                    {
                        "username": "DDKK64",
                        "content": "Just an IQ test problem. No much knowledge in it.  :("
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "1. We can not insert or delete any character from strings, so length of both strings should be equal.\\n2. Also, From point 1, both strings should have same set of characters, example: string1=\"abc\" , string2=\"abd\", because we cannot convert \\'c\\' to \\'d\\'.\\n3. Now we can convert any string s1 to string s2, if they have same set of frequencies for the characters.\\nExample:\\nstring s1=\"abbbcdc\"\\nfreq: a=1, b=3, c=2, d=1\\nstring s2=\"aabcdac\"\\nfreq: a=3, b=1, c=2, d=1\\nset of freq for s1 are (in sorted order): 1,1,2,3\\nset of freq for s2 are (in sorted order): 1,1,2,3\\n\\nboth are same. so we can make s1 equals to s2.\\nOther wise we cannot convert s1 to s2."
                    },
                    {
                        "username": "subodhr2001",
                        "content": "Input:\n\"aaabbbbccddeeeeefffff\"\n\"aaaaabbcccdddeeeeffff\"\n\nWhy is the result true for this test case 147? How can these two strings be called close? For example here is only one character with frequency = 5 in word2 whereas 2 characters with frequency = 5 in word 1.  How can we apply the second operation properly here using one-to-one mapping?"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Its result will be false, not true.\\nI have tested these input and its also expecting false only."
                    }
                ]
            },
            {
                "id": 1703385,
                "content": [
                    {
                        "username": "Raja_7321",
                        "content": "bool closeStrings(string word1, string word2) {\\n        if(word1.size()==word2.size()){\\n           vector<int>freq1(26,0);\\n           vector<int>freq2(26,0);\\n           for(int i=0;i<word1.size();i++){\\n               freq1[word1[i]-\\'a\\']++;\\n               freq2[word2[i]-\\'a\\']++;\\n           }\\n           for(int i=0;i<26;i++){\\n               if(freq1[i]==0 && freq2[i]!=0){\\n                       return false;\\n               }\\n               else if(freq1[i]!=0 && freq2[i]==0){\\n                   return false;\\n               }\\n           }\\n           for(int i=0;i<26;i++){\\n              bool flag=true;\\n              for(int j=0;j<26;j++){\\n                  if(freq1[i]==freq2[j]){\\n                      flag=false;\\n                      freq2[j]=0;\\n                      break;\\n                  }\\n              }\\n              if(flag){\\n                  return false;\\n              }\\n           }\\n           return true;\\n           \\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "What is the best time complexity we can achieve for this problem??"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "Is it O(NlogN) \\nas we have to use sort at least once in this.\\n"
                    },
                    {
                        "username": "monapriya",
                        "content": " `\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        pq1.add(2);\\n        pq1.add(1);\\n        pq1.add(3);\\n\\n        pq2.add(3);\\n        pq2.add(2);\\n        pq2.add(1);\\n\\n        System.out.println(pq1.equals(pq2));\\n}`\\nCan anyone please help me understand, what output this code gives and why?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This code creates two priority queues and add some elements in both of them. I'm suspecting that you want to compare if both queues have the same elements but the default implementation of equals here will return false.\n\nOne way to check if your queues are equal is something like this:\n```\nfor (Object element : pq1){\n    System.out.println(pq2.contains(element) ? true : false);\n   }\n```"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "I have tested 6 cases (added the failed cases after submitting the solution implemented in golang) and sill stuck with one testcase always failing irrespective of the input satisfies all the criteria :\n\nInput :\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\nOutput :\n  `true`\n\nExpected :\n  `false`\n\ndebug print :\n`k1: map[a:2 b:2 c:1 z:2] || k2: map[a:1 b:2 c:1 z:3]` \n`matching a, true || matching b, true || matching z, true || matching c, true || `\n\nAm i missing some thing here or the expected testcase result is incorrect ?\nThanks in advance."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) you should sort the 2 maps, and then compare indexes.\n\nif (map1[0] === map2[0] && map1[1] === map2[1] ... ) {\n  return true;\n} else {\n  return false;\n}\n\nIn this case, [ 1, 2, 2, 2 ],   [  1, 1, 2, 3 ], map1[1] is different from map2[1] so I'd return false because of that.\n\nIn my case I didn't found a way to sort the maps based on their values, so I converted them into arrays from the maps."
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@fsdevelop](/fsdevelop) I have two such different testcases :\n\nTestCase 1: -> this WORKS FINE even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 =  \"cabbba\"`\n  `word2 = \"abbccc\"`\n\n`Output: true`\n\n`Expected: true`\n\nDebug Print:\n`map[a:2 b:3 c:1] map[a:1 b:2 c:3]`\n`matching c, true || matching a, true || matching b, true || `  (matching only the keys)\n\n========================================\n\nTestCase 2: -> this DOESN'T WORKS even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\n`Output: true`\n\n`Expected: false`\n\nDebug Print:\n`map[a:2 b:2 c:1 z:2] map[a:1 b:2 c:1 z:3]`\n`matching a, true || matching b, true || matching z, true || matching c, true || ` (matching only the keys)\n\nIf i am validating the equality of sorted arrays, it breaks the first case.\nTherefore, I am still doubting that the two testcases are similar but produces two different results where either testcae1 or testcase2 expected result is invalid.\n"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) You need the two arrays I mentioned to be identical after sorted.\\n\\n[1, 2, 3] == [3, 1, 2] => true\\n[2, 3, 4] != [1, 3, 4]  => false"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@Federico Sosa](/fsdevelop) Thanks a lot for the explanation... I'll fix the code and try again."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I faced the same problem here. The key to solve this challenge is also to check how many times each letter appear in each word.\\n\\nFor example in \"abbzzca\":\\n- \"a\" appears 2 times\\n- \"b\" appears 2 times\\n- \"z\" appears 2 times\\n- \"c\" appears 1 time.\\n\\nAnd then, in \"babzzcz\":\\n- \"a\" appears 1 time\\n- \"b\" appears 2 times\\n- \"z\" appears 3 times\\n- \"c\" appears 1 time\\n\\nIf you compare these arrays [2, 2, 2, 1], [1, 2, 3, 1] they don\\'t match in numbers, so even if you make any of the 2 operations it won\\'t be possible to match each word."
                    },
                    {
                        "username": "aerosync",
                        "content": "can someone explain to me what word1[c-\\'a\\']++ is doing in everyones c++ code. i dont understand the -\\'a\\' syntax or what its doing"
                    },
                    {
                        "username": "wyldbill",
                        "content": "c - \\'a\\' provides a 0 based index to the letter. 0->a, 1->b, 2->c, etc. useful for indexing based on letters into an alphabet sized array."
                    },
                    {
                        "username": "dkashi",
                        "content": "two strings are close if following conditions are met:\\n    1. len(word1) == len(word2)\\n    2. counter(word1).keys() == counter(word2).keys()\\n        e.g. word1 = \"cabbba\", word2 = \"abbccc\"\\n        counter(word1) = {\\'c\\': 1, \\'a\\': 2, \\'b\\': 3}\\n        counter(word2) = {\\'a\\': 1, \\'b\\':2, \\'c\\':3}\\n        so {\\'a\\', \\'b\\', \\'c\\'} should occur in both words and no extra letters should exist\\n    3. Count of different values in counter should be same.\\n        e.g. word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\n        Counter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2}   => values are [5, 5, 4, 3, 2, 2]\\n        Counter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\n        if the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "This code works perfectly fine for 1657. Determine if Two Strings Are Close ... looking for how i can optimize this solution. Current time complexity goes O(4n). Looking for suggestions on how can i make it to O(n)\n \n    public boolean closeStrings(String word1, String word2) {\n        Map<Character, Integer> char_count_of_word1 = new HashMap<>();\n        Map<Character, Integer> char_count_of_word2 = new HashMap<>();\n\n        for(int i=0; i<word1.length(); i++){\n            if(char_count_of_word1.containsKey(word1.charAt(i))){\n                int current_count = char_count_of_word1.get(word1.charAt(i));\n                char_count_of_word1.put(word1.charAt(i), ++current_count);\n            } else {\n                char_count_of_word1.put(word1.charAt(i), 1);\n            }\n        }\n        for(int i=0; i<word2.length(); i++){\n            if(char_count_of_word2.containsKey(word2.charAt(i))){\n                int current_count = char_count_of_word2.get(word2.charAt(i));\n                char_count_of_word2.put(word2.charAt(i), ++current_count);\n            } else {\n                char_count_of_word2.put(word2.charAt(i), 1);\n            }\n        }\n\n        ArrayList<Character> list1_char = new ArrayList<>();\n        ArrayList<Integer> list1_count = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word1.entrySet()){\n            list1_count.add(entry.getValue());\n            list1_char.add(entry.getKey());\n        }\n\n        ArrayList<Integer> list2_count = new ArrayList<>();\n        ArrayList<Character> list2_char = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word2.entrySet()){\n            list2_count.add(entry.getValue());\n            list2_char.add(entry.getKey());\n        }\n\n        Collections.sort(list1_count);\n        Collections.sort(list1_char);\n        Collections.sort(list2_count);\n        Collections.sort(list2_char);\n        \n        if (list1_count.equals(list2_count) && list1_char.equals(list2_char)){\n            return true;\n        }\n        return false;\n    }\n"
                    },
                    {
                        "username": "DDKK64",
                        "content": "Just an IQ test problem. No much knowledge in it.  :("
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "1. We can not insert or delete any character from strings, so length of both strings should be equal.\\n2. Also, From point 1, both strings should have same set of characters, example: string1=\"abc\" , string2=\"abd\", because we cannot convert \\'c\\' to \\'d\\'.\\n3. Now we can convert any string s1 to string s2, if they have same set of frequencies for the characters.\\nExample:\\nstring s1=\"abbbcdc\"\\nfreq: a=1, b=3, c=2, d=1\\nstring s2=\"aabcdac\"\\nfreq: a=3, b=1, c=2, d=1\\nset of freq for s1 are (in sorted order): 1,1,2,3\\nset of freq for s2 are (in sorted order): 1,1,2,3\\n\\nboth are same. so we can make s1 equals to s2.\\nOther wise we cannot convert s1 to s2."
                    },
                    {
                        "username": "subodhr2001",
                        "content": "Input:\n\"aaabbbbccddeeeeefffff\"\n\"aaaaabbcccdddeeeeffff\"\n\nWhy is the result true for this test case 147? How can these two strings be called close? For example here is only one character with frequency = 5 in word2 whereas 2 characters with frequency = 5 in word 1.  How can we apply the second operation properly here using one-to-one mapping?"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Its result will be false, not true.\\nI have tested these input and its also expecting false only."
                    }
                ]
            },
            {
                "id": 1703354,
                "content": [
                    {
                        "username": "Raja_7321",
                        "content": "bool closeStrings(string word1, string word2) {\\n        if(word1.size()==word2.size()){\\n           vector<int>freq1(26,0);\\n           vector<int>freq2(26,0);\\n           for(int i=0;i<word1.size();i++){\\n               freq1[word1[i]-\\'a\\']++;\\n               freq2[word2[i]-\\'a\\']++;\\n           }\\n           for(int i=0;i<26;i++){\\n               if(freq1[i]==0 && freq2[i]!=0){\\n                       return false;\\n               }\\n               else if(freq1[i]!=0 && freq2[i]==0){\\n                   return false;\\n               }\\n           }\\n           for(int i=0;i<26;i++){\\n              bool flag=true;\\n              for(int j=0;j<26;j++){\\n                  if(freq1[i]==freq2[j]){\\n                      flag=false;\\n                      freq2[j]=0;\\n                      break;\\n                  }\\n              }\\n              if(flag){\\n                  return false;\\n              }\\n           }\\n           return true;\\n           \\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "What is the best time complexity we can achieve for this problem??"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "Is it O(NlogN) \\nas we have to use sort at least once in this.\\n"
                    },
                    {
                        "username": "monapriya",
                        "content": " `\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        pq1.add(2);\\n        pq1.add(1);\\n        pq1.add(3);\\n\\n        pq2.add(3);\\n        pq2.add(2);\\n        pq2.add(1);\\n\\n        System.out.println(pq1.equals(pq2));\\n}`\\nCan anyone please help me understand, what output this code gives and why?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This code creates two priority queues and add some elements in both of them. I'm suspecting that you want to compare if both queues have the same elements but the default implementation of equals here will return false.\n\nOne way to check if your queues are equal is something like this:\n```\nfor (Object element : pq1){\n    System.out.println(pq2.contains(element) ? true : false);\n   }\n```"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "I have tested 6 cases (added the failed cases after submitting the solution implemented in golang) and sill stuck with one testcase always failing irrespective of the input satisfies all the criteria :\n\nInput :\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\nOutput :\n  `true`\n\nExpected :\n  `false`\n\ndebug print :\n`k1: map[a:2 b:2 c:1 z:2] || k2: map[a:1 b:2 c:1 z:3]` \n`matching a, true || matching b, true || matching z, true || matching c, true || `\n\nAm i missing some thing here or the expected testcase result is incorrect ?\nThanks in advance."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) you should sort the 2 maps, and then compare indexes.\n\nif (map1[0] === map2[0] && map1[1] === map2[1] ... ) {\n  return true;\n} else {\n  return false;\n}\n\nIn this case, [ 1, 2, 2, 2 ],   [  1, 1, 2, 3 ], map1[1] is different from map2[1] so I'd return false because of that.\n\nIn my case I didn't found a way to sort the maps based on their values, so I converted them into arrays from the maps."
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@fsdevelop](/fsdevelop) I have two such different testcases :\n\nTestCase 1: -> this WORKS FINE even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 =  \"cabbba\"`\n  `word2 = \"abbccc\"`\n\n`Output: true`\n\n`Expected: true`\n\nDebug Print:\n`map[a:2 b:3 c:1] map[a:1 b:2 c:3]`\n`matching c, true || matching a, true || matching b, true || `  (matching only the keys)\n\n========================================\n\nTestCase 2: -> this DOESN'T WORKS even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\n`Output: true`\n\n`Expected: false`\n\nDebug Print:\n`map[a:2 b:2 c:1 z:2] map[a:1 b:2 c:1 z:3]`\n`matching a, true || matching b, true || matching z, true || matching c, true || ` (matching only the keys)\n\nIf i am validating the equality of sorted arrays, it breaks the first case.\nTherefore, I am still doubting that the two testcases are similar but produces two different results where either testcae1 or testcase2 expected result is invalid.\n"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) You need the two arrays I mentioned to be identical after sorted.\\n\\n[1, 2, 3] == [3, 1, 2] => true\\n[2, 3, 4] != [1, 3, 4]  => false"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@Federico Sosa](/fsdevelop) Thanks a lot for the explanation... I'll fix the code and try again."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I faced the same problem here. The key to solve this challenge is also to check how many times each letter appear in each word.\\n\\nFor example in \"abbzzca\":\\n- \"a\" appears 2 times\\n- \"b\" appears 2 times\\n- \"z\" appears 2 times\\n- \"c\" appears 1 time.\\n\\nAnd then, in \"babzzcz\":\\n- \"a\" appears 1 time\\n- \"b\" appears 2 times\\n- \"z\" appears 3 times\\n- \"c\" appears 1 time\\n\\nIf you compare these arrays [2, 2, 2, 1], [1, 2, 3, 1] they don\\'t match in numbers, so even if you make any of the 2 operations it won\\'t be possible to match each word."
                    },
                    {
                        "username": "aerosync",
                        "content": "can someone explain to me what word1[c-\\'a\\']++ is doing in everyones c++ code. i dont understand the -\\'a\\' syntax or what its doing"
                    },
                    {
                        "username": "wyldbill",
                        "content": "c - \\'a\\' provides a 0 based index to the letter. 0->a, 1->b, 2->c, etc. useful for indexing based on letters into an alphabet sized array."
                    },
                    {
                        "username": "dkashi",
                        "content": "two strings are close if following conditions are met:\\n    1. len(word1) == len(word2)\\n    2. counter(word1).keys() == counter(word2).keys()\\n        e.g. word1 = \"cabbba\", word2 = \"abbccc\"\\n        counter(word1) = {\\'c\\': 1, \\'a\\': 2, \\'b\\': 3}\\n        counter(word2) = {\\'a\\': 1, \\'b\\':2, \\'c\\':3}\\n        so {\\'a\\', \\'b\\', \\'c\\'} should occur in both words and no extra letters should exist\\n    3. Count of different values in counter should be same.\\n        e.g. word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\n        Counter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2}   => values are [5, 5, 4, 3, 2, 2]\\n        Counter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\n        if the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "This code works perfectly fine for 1657. Determine if Two Strings Are Close ... looking for how i can optimize this solution. Current time complexity goes O(4n). Looking for suggestions on how can i make it to O(n)\n \n    public boolean closeStrings(String word1, String word2) {\n        Map<Character, Integer> char_count_of_word1 = new HashMap<>();\n        Map<Character, Integer> char_count_of_word2 = new HashMap<>();\n\n        for(int i=0; i<word1.length(); i++){\n            if(char_count_of_word1.containsKey(word1.charAt(i))){\n                int current_count = char_count_of_word1.get(word1.charAt(i));\n                char_count_of_word1.put(word1.charAt(i), ++current_count);\n            } else {\n                char_count_of_word1.put(word1.charAt(i), 1);\n            }\n        }\n        for(int i=0; i<word2.length(); i++){\n            if(char_count_of_word2.containsKey(word2.charAt(i))){\n                int current_count = char_count_of_word2.get(word2.charAt(i));\n                char_count_of_word2.put(word2.charAt(i), ++current_count);\n            } else {\n                char_count_of_word2.put(word2.charAt(i), 1);\n            }\n        }\n\n        ArrayList<Character> list1_char = new ArrayList<>();\n        ArrayList<Integer> list1_count = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word1.entrySet()){\n            list1_count.add(entry.getValue());\n            list1_char.add(entry.getKey());\n        }\n\n        ArrayList<Integer> list2_count = new ArrayList<>();\n        ArrayList<Character> list2_char = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word2.entrySet()){\n            list2_count.add(entry.getValue());\n            list2_char.add(entry.getKey());\n        }\n\n        Collections.sort(list1_count);\n        Collections.sort(list1_char);\n        Collections.sort(list2_count);\n        Collections.sort(list2_char);\n        \n        if (list1_count.equals(list2_count) && list1_char.equals(list2_char)){\n            return true;\n        }\n        return false;\n    }\n"
                    },
                    {
                        "username": "DDKK64",
                        "content": "Just an IQ test problem. No much knowledge in it.  :("
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "1. We can not insert or delete any character from strings, so length of both strings should be equal.\\n2. Also, From point 1, both strings should have same set of characters, example: string1=\"abc\" , string2=\"abd\", because we cannot convert \\'c\\' to \\'d\\'.\\n3. Now we can convert any string s1 to string s2, if they have same set of frequencies for the characters.\\nExample:\\nstring s1=\"abbbcdc\"\\nfreq: a=1, b=3, c=2, d=1\\nstring s2=\"aabcdac\"\\nfreq: a=3, b=1, c=2, d=1\\nset of freq for s1 are (in sorted order): 1,1,2,3\\nset of freq for s2 are (in sorted order): 1,1,2,3\\n\\nboth are same. so we can make s1 equals to s2.\\nOther wise we cannot convert s1 to s2."
                    },
                    {
                        "username": "subodhr2001",
                        "content": "Input:\n\"aaabbbbccddeeeeefffff\"\n\"aaaaabbcccdddeeeeffff\"\n\nWhy is the result true for this test case 147? How can these two strings be called close? For example here is only one character with frequency = 5 in word2 whereas 2 characters with frequency = 5 in word 1.  How can we apply the second operation properly here using one-to-one mapping?"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Its result will be false, not true.\\nI have tested these input and its also expecting false only."
                    }
                ]
            },
            {
                "id": 1703331,
                "content": [
                    {
                        "username": "Raja_7321",
                        "content": "bool closeStrings(string word1, string word2) {\\n        if(word1.size()==word2.size()){\\n           vector<int>freq1(26,0);\\n           vector<int>freq2(26,0);\\n           for(int i=0;i<word1.size();i++){\\n               freq1[word1[i]-\\'a\\']++;\\n               freq2[word2[i]-\\'a\\']++;\\n           }\\n           for(int i=0;i<26;i++){\\n               if(freq1[i]==0 && freq2[i]!=0){\\n                       return false;\\n               }\\n               else if(freq1[i]!=0 && freq2[i]==0){\\n                   return false;\\n               }\\n           }\\n           for(int i=0;i<26;i++){\\n              bool flag=true;\\n              for(int j=0;j<26;j++){\\n                  if(freq1[i]==freq2[j]){\\n                      flag=false;\\n                      freq2[j]=0;\\n                      break;\\n                  }\\n              }\\n              if(flag){\\n                  return false;\\n              }\\n           }\\n           return true;\\n           \\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "What is the best time complexity we can achieve for this problem??"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "Is it O(NlogN) \\nas we have to use sort at least once in this.\\n"
                    },
                    {
                        "username": "monapriya",
                        "content": " `\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        pq1.add(2);\\n        pq1.add(1);\\n        pq1.add(3);\\n\\n        pq2.add(3);\\n        pq2.add(2);\\n        pq2.add(1);\\n\\n        System.out.println(pq1.equals(pq2));\\n}`\\nCan anyone please help me understand, what output this code gives and why?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This code creates two priority queues and add some elements in both of them. I'm suspecting that you want to compare if both queues have the same elements but the default implementation of equals here will return false.\n\nOne way to check if your queues are equal is something like this:\n```\nfor (Object element : pq1){\n    System.out.println(pq2.contains(element) ? true : false);\n   }\n```"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "I have tested 6 cases (added the failed cases after submitting the solution implemented in golang) and sill stuck with one testcase always failing irrespective of the input satisfies all the criteria :\n\nInput :\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\nOutput :\n  `true`\n\nExpected :\n  `false`\n\ndebug print :\n`k1: map[a:2 b:2 c:1 z:2] || k2: map[a:1 b:2 c:1 z:3]` \n`matching a, true || matching b, true || matching z, true || matching c, true || `\n\nAm i missing some thing here or the expected testcase result is incorrect ?\nThanks in advance."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) you should sort the 2 maps, and then compare indexes.\n\nif (map1[0] === map2[0] && map1[1] === map2[1] ... ) {\n  return true;\n} else {\n  return false;\n}\n\nIn this case, [ 1, 2, 2, 2 ],   [  1, 1, 2, 3 ], map1[1] is different from map2[1] so I'd return false because of that.\n\nIn my case I didn't found a way to sort the maps based on their values, so I converted them into arrays from the maps."
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@fsdevelop](/fsdevelop) I have two such different testcases :\n\nTestCase 1: -> this WORKS FINE even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 =  \"cabbba\"`\n  `word2 = \"abbccc\"`\n\n`Output: true`\n\n`Expected: true`\n\nDebug Print:\n`map[a:2 b:3 c:1] map[a:1 b:2 c:3]`\n`matching c, true || matching a, true || matching b, true || `  (matching only the keys)\n\n========================================\n\nTestCase 2: -> this DOESN'T WORKS even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\n`Output: true`\n\n`Expected: false`\n\nDebug Print:\n`map[a:2 b:2 c:1 z:2] map[a:1 b:2 c:1 z:3]`\n`matching a, true || matching b, true || matching z, true || matching c, true || ` (matching only the keys)\n\nIf i am validating the equality of sorted arrays, it breaks the first case.\nTherefore, I am still doubting that the two testcases are similar but produces two different results where either testcae1 or testcase2 expected result is invalid.\n"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) You need the two arrays I mentioned to be identical after sorted.\\n\\n[1, 2, 3] == [3, 1, 2] => true\\n[2, 3, 4] != [1, 3, 4]  => false"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@Federico Sosa](/fsdevelop) Thanks a lot for the explanation... I'll fix the code and try again."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I faced the same problem here. The key to solve this challenge is also to check how many times each letter appear in each word.\\n\\nFor example in \"abbzzca\":\\n- \"a\" appears 2 times\\n- \"b\" appears 2 times\\n- \"z\" appears 2 times\\n- \"c\" appears 1 time.\\n\\nAnd then, in \"babzzcz\":\\n- \"a\" appears 1 time\\n- \"b\" appears 2 times\\n- \"z\" appears 3 times\\n- \"c\" appears 1 time\\n\\nIf you compare these arrays [2, 2, 2, 1], [1, 2, 3, 1] they don\\'t match in numbers, so even if you make any of the 2 operations it won\\'t be possible to match each word."
                    },
                    {
                        "username": "aerosync",
                        "content": "can someone explain to me what word1[c-\\'a\\']++ is doing in everyones c++ code. i dont understand the -\\'a\\' syntax or what its doing"
                    },
                    {
                        "username": "wyldbill",
                        "content": "c - \\'a\\' provides a 0 based index to the letter. 0->a, 1->b, 2->c, etc. useful for indexing based on letters into an alphabet sized array."
                    },
                    {
                        "username": "dkashi",
                        "content": "two strings are close if following conditions are met:\\n    1. len(word1) == len(word2)\\n    2. counter(word1).keys() == counter(word2).keys()\\n        e.g. word1 = \"cabbba\", word2 = \"abbccc\"\\n        counter(word1) = {\\'c\\': 1, \\'a\\': 2, \\'b\\': 3}\\n        counter(word2) = {\\'a\\': 1, \\'b\\':2, \\'c\\':3}\\n        so {\\'a\\', \\'b\\', \\'c\\'} should occur in both words and no extra letters should exist\\n    3. Count of different values in counter should be same.\\n        e.g. word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\n        Counter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2}   => values are [5, 5, 4, 3, 2, 2]\\n        Counter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\n        if the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "This code works perfectly fine for 1657. Determine if Two Strings Are Close ... looking for how i can optimize this solution. Current time complexity goes O(4n). Looking for suggestions on how can i make it to O(n)\n \n    public boolean closeStrings(String word1, String word2) {\n        Map<Character, Integer> char_count_of_word1 = new HashMap<>();\n        Map<Character, Integer> char_count_of_word2 = new HashMap<>();\n\n        for(int i=0; i<word1.length(); i++){\n            if(char_count_of_word1.containsKey(word1.charAt(i))){\n                int current_count = char_count_of_word1.get(word1.charAt(i));\n                char_count_of_word1.put(word1.charAt(i), ++current_count);\n            } else {\n                char_count_of_word1.put(word1.charAt(i), 1);\n            }\n        }\n        for(int i=0; i<word2.length(); i++){\n            if(char_count_of_word2.containsKey(word2.charAt(i))){\n                int current_count = char_count_of_word2.get(word2.charAt(i));\n                char_count_of_word2.put(word2.charAt(i), ++current_count);\n            } else {\n                char_count_of_word2.put(word2.charAt(i), 1);\n            }\n        }\n\n        ArrayList<Character> list1_char = new ArrayList<>();\n        ArrayList<Integer> list1_count = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word1.entrySet()){\n            list1_count.add(entry.getValue());\n            list1_char.add(entry.getKey());\n        }\n\n        ArrayList<Integer> list2_count = new ArrayList<>();\n        ArrayList<Character> list2_char = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word2.entrySet()){\n            list2_count.add(entry.getValue());\n            list2_char.add(entry.getKey());\n        }\n\n        Collections.sort(list1_count);\n        Collections.sort(list1_char);\n        Collections.sort(list2_count);\n        Collections.sort(list2_char);\n        \n        if (list1_count.equals(list2_count) && list1_char.equals(list2_char)){\n            return true;\n        }\n        return false;\n    }\n"
                    },
                    {
                        "username": "DDKK64",
                        "content": "Just an IQ test problem. No much knowledge in it.  :("
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "1. We can not insert or delete any character from strings, so length of both strings should be equal.\\n2. Also, From point 1, both strings should have same set of characters, example: string1=\"abc\" , string2=\"abd\", because we cannot convert \\'c\\' to \\'d\\'.\\n3. Now we can convert any string s1 to string s2, if they have same set of frequencies for the characters.\\nExample:\\nstring s1=\"abbbcdc\"\\nfreq: a=1, b=3, c=2, d=1\\nstring s2=\"aabcdac\"\\nfreq: a=3, b=1, c=2, d=1\\nset of freq for s1 are (in sorted order): 1,1,2,3\\nset of freq for s2 are (in sorted order): 1,1,2,3\\n\\nboth are same. so we can make s1 equals to s2.\\nOther wise we cannot convert s1 to s2."
                    },
                    {
                        "username": "subodhr2001",
                        "content": "Input:\n\"aaabbbbccddeeeeefffff\"\n\"aaaaabbcccdddeeeeffff\"\n\nWhy is the result true for this test case 147? How can these two strings be called close? For example here is only one character with frequency = 5 in word2 whereas 2 characters with frequency = 5 in word 1.  How can we apply the second operation properly here using one-to-one mapping?"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Its result will be false, not true.\\nI have tested these input and its also expecting false only."
                    }
                ]
            },
            {
                "id": 1703101,
                "content": [
                    {
                        "username": "Raja_7321",
                        "content": "bool closeStrings(string word1, string word2) {\\n        if(word1.size()==word2.size()){\\n           vector<int>freq1(26,0);\\n           vector<int>freq2(26,0);\\n           for(int i=0;i<word1.size();i++){\\n               freq1[word1[i]-\\'a\\']++;\\n               freq2[word2[i]-\\'a\\']++;\\n           }\\n           for(int i=0;i<26;i++){\\n               if(freq1[i]==0 && freq2[i]!=0){\\n                       return false;\\n               }\\n               else if(freq1[i]!=0 && freq2[i]==0){\\n                   return false;\\n               }\\n           }\\n           for(int i=0;i<26;i++){\\n              bool flag=true;\\n              for(int j=0;j<26;j++){\\n                  if(freq1[i]==freq2[j]){\\n                      flag=false;\\n                      freq2[j]=0;\\n                      break;\\n                  }\\n              }\\n              if(flag){\\n                  return false;\\n              }\\n           }\\n           return true;\\n           \\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "What is the best time complexity we can achieve for this problem??"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "Is it O(NlogN) \\nas we have to use sort at least once in this.\\n"
                    },
                    {
                        "username": "monapriya",
                        "content": " `\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        pq1.add(2);\\n        pq1.add(1);\\n        pq1.add(3);\\n\\n        pq2.add(3);\\n        pq2.add(2);\\n        pq2.add(1);\\n\\n        System.out.println(pq1.equals(pq2));\\n}`\\nCan anyone please help me understand, what output this code gives and why?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This code creates two priority queues and add some elements in both of them. I'm suspecting that you want to compare if both queues have the same elements but the default implementation of equals here will return false.\n\nOne way to check if your queues are equal is something like this:\n```\nfor (Object element : pq1){\n    System.out.println(pq2.contains(element) ? true : false);\n   }\n```"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "I have tested 6 cases (added the failed cases after submitting the solution implemented in golang) and sill stuck with one testcase always failing irrespective of the input satisfies all the criteria :\n\nInput :\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\nOutput :\n  `true`\n\nExpected :\n  `false`\n\ndebug print :\n`k1: map[a:2 b:2 c:1 z:2] || k2: map[a:1 b:2 c:1 z:3]` \n`matching a, true || matching b, true || matching z, true || matching c, true || `\n\nAm i missing some thing here or the expected testcase result is incorrect ?\nThanks in advance."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) you should sort the 2 maps, and then compare indexes.\n\nif (map1[0] === map2[0] && map1[1] === map2[1] ... ) {\n  return true;\n} else {\n  return false;\n}\n\nIn this case, [ 1, 2, 2, 2 ],   [  1, 1, 2, 3 ], map1[1] is different from map2[1] so I'd return false because of that.\n\nIn my case I didn't found a way to sort the maps based on their values, so I converted them into arrays from the maps."
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@fsdevelop](/fsdevelop) I have two such different testcases :\n\nTestCase 1: -> this WORKS FINE even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 =  \"cabbba\"`\n  `word2 = \"abbccc\"`\n\n`Output: true`\n\n`Expected: true`\n\nDebug Print:\n`map[a:2 b:3 c:1] map[a:1 b:2 c:3]`\n`matching c, true || matching a, true || matching b, true || `  (matching only the keys)\n\n========================================\n\nTestCase 2: -> this DOESN'T WORKS even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\n`Output: true`\n\n`Expected: false`\n\nDebug Print:\n`map[a:2 b:2 c:1 z:2] map[a:1 b:2 c:1 z:3]`\n`matching a, true || matching b, true || matching z, true || matching c, true || ` (matching only the keys)\n\nIf i am validating the equality of sorted arrays, it breaks the first case.\nTherefore, I am still doubting that the two testcases are similar but produces two different results where either testcae1 or testcase2 expected result is invalid.\n"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) You need the two arrays I mentioned to be identical after sorted.\\n\\n[1, 2, 3] == [3, 1, 2] => true\\n[2, 3, 4] != [1, 3, 4]  => false"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@Federico Sosa](/fsdevelop) Thanks a lot for the explanation... I'll fix the code and try again."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I faced the same problem here. The key to solve this challenge is also to check how many times each letter appear in each word.\\n\\nFor example in \"abbzzca\":\\n- \"a\" appears 2 times\\n- \"b\" appears 2 times\\n- \"z\" appears 2 times\\n- \"c\" appears 1 time.\\n\\nAnd then, in \"babzzcz\":\\n- \"a\" appears 1 time\\n- \"b\" appears 2 times\\n- \"z\" appears 3 times\\n- \"c\" appears 1 time\\n\\nIf you compare these arrays [2, 2, 2, 1], [1, 2, 3, 1] they don\\'t match in numbers, so even if you make any of the 2 operations it won\\'t be possible to match each word."
                    },
                    {
                        "username": "aerosync",
                        "content": "can someone explain to me what word1[c-\\'a\\']++ is doing in everyones c++ code. i dont understand the -\\'a\\' syntax or what its doing"
                    },
                    {
                        "username": "wyldbill",
                        "content": "c - \\'a\\' provides a 0 based index to the letter. 0->a, 1->b, 2->c, etc. useful for indexing based on letters into an alphabet sized array."
                    },
                    {
                        "username": "dkashi",
                        "content": "two strings are close if following conditions are met:\\n    1. len(word1) == len(word2)\\n    2. counter(word1).keys() == counter(word2).keys()\\n        e.g. word1 = \"cabbba\", word2 = \"abbccc\"\\n        counter(word1) = {\\'c\\': 1, \\'a\\': 2, \\'b\\': 3}\\n        counter(word2) = {\\'a\\': 1, \\'b\\':2, \\'c\\':3}\\n        so {\\'a\\', \\'b\\', \\'c\\'} should occur in both words and no extra letters should exist\\n    3. Count of different values in counter should be same.\\n        e.g. word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\n        Counter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2}   => values are [5, 5, 4, 3, 2, 2]\\n        Counter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\n        if the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "This code works perfectly fine for 1657. Determine if Two Strings Are Close ... looking for how i can optimize this solution. Current time complexity goes O(4n). Looking for suggestions on how can i make it to O(n)\n \n    public boolean closeStrings(String word1, String word2) {\n        Map<Character, Integer> char_count_of_word1 = new HashMap<>();\n        Map<Character, Integer> char_count_of_word2 = new HashMap<>();\n\n        for(int i=0; i<word1.length(); i++){\n            if(char_count_of_word1.containsKey(word1.charAt(i))){\n                int current_count = char_count_of_word1.get(word1.charAt(i));\n                char_count_of_word1.put(word1.charAt(i), ++current_count);\n            } else {\n                char_count_of_word1.put(word1.charAt(i), 1);\n            }\n        }\n        for(int i=0; i<word2.length(); i++){\n            if(char_count_of_word2.containsKey(word2.charAt(i))){\n                int current_count = char_count_of_word2.get(word2.charAt(i));\n                char_count_of_word2.put(word2.charAt(i), ++current_count);\n            } else {\n                char_count_of_word2.put(word2.charAt(i), 1);\n            }\n        }\n\n        ArrayList<Character> list1_char = new ArrayList<>();\n        ArrayList<Integer> list1_count = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word1.entrySet()){\n            list1_count.add(entry.getValue());\n            list1_char.add(entry.getKey());\n        }\n\n        ArrayList<Integer> list2_count = new ArrayList<>();\n        ArrayList<Character> list2_char = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word2.entrySet()){\n            list2_count.add(entry.getValue());\n            list2_char.add(entry.getKey());\n        }\n\n        Collections.sort(list1_count);\n        Collections.sort(list1_char);\n        Collections.sort(list2_count);\n        Collections.sort(list2_char);\n        \n        if (list1_count.equals(list2_count) && list1_char.equals(list2_char)){\n            return true;\n        }\n        return false;\n    }\n"
                    },
                    {
                        "username": "DDKK64",
                        "content": "Just an IQ test problem. No much knowledge in it.  :("
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "1. We can not insert or delete any character from strings, so length of both strings should be equal.\\n2. Also, From point 1, both strings should have same set of characters, example: string1=\"abc\" , string2=\"abd\", because we cannot convert \\'c\\' to \\'d\\'.\\n3. Now we can convert any string s1 to string s2, if they have same set of frequencies for the characters.\\nExample:\\nstring s1=\"abbbcdc\"\\nfreq: a=1, b=3, c=2, d=1\\nstring s2=\"aabcdac\"\\nfreq: a=3, b=1, c=2, d=1\\nset of freq for s1 are (in sorted order): 1,1,2,3\\nset of freq for s2 are (in sorted order): 1,1,2,3\\n\\nboth are same. so we can make s1 equals to s2.\\nOther wise we cannot convert s1 to s2."
                    },
                    {
                        "username": "subodhr2001",
                        "content": "Input:\n\"aaabbbbccddeeeeefffff\"\n\"aaaaabbcccdddeeeeffff\"\n\nWhy is the result true for this test case 147? How can these two strings be called close? For example here is only one character with frequency = 5 in word2 whereas 2 characters with frequency = 5 in word 1.  How can we apply the second operation properly here using one-to-one mapping?"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Its result will be false, not true.\\nI have tested these input and its also expecting false only."
                    }
                ]
            },
            {
                "id": 1703016,
                "content": [
                    {
                        "username": "Raja_7321",
                        "content": "bool closeStrings(string word1, string word2) {\\n        if(word1.size()==word2.size()){\\n           vector<int>freq1(26,0);\\n           vector<int>freq2(26,0);\\n           for(int i=0;i<word1.size();i++){\\n               freq1[word1[i]-\\'a\\']++;\\n               freq2[word2[i]-\\'a\\']++;\\n           }\\n           for(int i=0;i<26;i++){\\n               if(freq1[i]==0 && freq2[i]!=0){\\n                       return false;\\n               }\\n               else if(freq1[i]!=0 && freq2[i]==0){\\n                   return false;\\n               }\\n           }\\n           for(int i=0;i<26;i++){\\n              bool flag=true;\\n              for(int j=0;j<26;j++){\\n                  if(freq1[i]==freq2[j]){\\n                      flag=false;\\n                      freq2[j]=0;\\n                      break;\\n                  }\\n              }\\n              if(flag){\\n                  return false;\\n              }\\n           }\\n           return true;\\n           \\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "What is the best time complexity we can achieve for this problem??"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "Is it O(NlogN) \\nas we have to use sort at least once in this.\\n"
                    },
                    {
                        "username": "monapriya",
                        "content": " `\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        pq1.add(2);\\n        pq1.add(1);\\n        pq1.add(3);\\n\\n        pq2.add(3);\\n        pq2.add(2);\\n        pq2.add(1);\\n\\n        System.out.println(pq1.equals(pq2));\\n}`\\nCan anyone please help me understand, what output this code gives and why?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This code creates two priority queues and add some elements in both of them. I'm suspecting that you want to compare if both queues have the same elements but the default implementation of equals here will return false.\n\nOne way to check if your queues are equal is something like this:\n```\nfor (Object element : pq1){\n    System.out.println(pq2.contains(element) ? true : false);\n   }\n```"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "I have tested 6 cases (added the failed cases after submitting the solution implemented in golang) and sill stuck with one testcase always failing irrespective of the input satisfies all the criteria :\n\nInput :\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\nOutput :\n  `true`\n\nExpected :\n  `false`\n\ndebug print :\n`k1: map[a:2 b:2 c:1 z:2] || k2: map[a:1 b:2 c:1 z:3]` \n`matching a, true || matching b, true || matching z, true || matching c, true || `\n\nAm i missing some thing here or the expected testcase result is incorrect ?\nThanks in advance."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) you should sort the 2 maps, and then compare indexes.\n\nif (map1[0] === map2[0] && map1[1] === map2[1] ... ) {\n  return true;\n} else {\n  return false;\n}\n\nIn this case, [ 1, 2, 2, 2 ],   [  1, 1, 2, 3 ], map1[1] is different from map2[1] so I'd return false because of that.\n\nIn my case I didn't found a way to sort the maps based on their values, so I converted them into arrays from the maps."
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@fsdevelop](/fsdevelop) I have two such different testcases :\n\nTestCase 1: -> this WORKS FINE even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 =  \"cabbba\"`\n  `word2 = \"abbccc\"`\n\n`Output: true`\n\n`Expected: true`\n\nDebug Print:\n`map[a:2 b:3 c:1] map[a:1 b:2 c:3]`\n`matching c, true || matching a, true || matching b, true || `  (matching only the keys)\n\n========================================\n\nTestCase 2: -> this DOESN'T WORKS even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\n`Output: true`\n\n`Expected: false`\n\nDebug Print:\n`map[a:2 b:2 c:1 z:2] map[a:1 b:2 c:1 z:3]`\n`matching a, true || matching b, true || matching z, true || matching c, true || ` (matching only the keys)\n\nIf i am validating the equality of sorted arrays, it breaks the first case.\nTherefore, I am still doubting that the two testcases are similar but produces two different results where either testcae1 or testcase2 expected result is invalid.\n"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) You need the two arrays I mentioned to be identical after sorted.\\n\\n[1, 2, 3] == [3, 1, 2] => true\\n[2, 3, 4] != [1, 3, 4]  => false"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@Federico Sosa](/fsdevelop) Thanks a lot for the explanation... I'll fix the code and try again."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I faced the same problem here. The key to solve this challenge is also to check how many times each letter appear in each word.\\n\\nFor example in \"abbzzca\":\\n- \"a\" appears 2 times\\n- \"b\" appears 2 times\\n- \"z\" appears 2 times\\n- \"c\" appears 1 time.\\n\\nAnd then, in \"babzzcz\":\\n- \"a\" appears 1 time\\n- \"b\" appears 2 times\\n- \"z\" appears 3 times\\n- \"c\" appears 1 time\\n\\nIf you compare these arrays [2, 2, 2, 1], [1, 2, 3, 1] they don\\'t match in numbers, so even if you make any of the 2 operations it won\\'t be possible to match each word."
                    },
                    {
                        "username": "aerosync",
                        "content": "can someone explain to me what word1[c-\\'a\\']++ is doing in everyones c++ code. i dont understand the -\\'a\\' syntax or what its doing"
                    },
                    {
                        "username": "wyldbill",
                        "content": "c - \\'a\\' provides a 0 based index to the letter. 0->a, 1->b, 2->c, etc. useful for indexing based on letters into an alphabet sized array."
                    },
                    {
                        "username": "dkashi",
                        "content": "two strings are close if following conditions are met:\\n    1. len(word1) == len(word2)\\n    2. counter(word1).keys() == counter(word2).keys()\\n        e.g. word1 = \"cabbba\", word2 = \"abbccc\"\\n        counter(word1) = {\\'c\\': 1, \\'a\\': 2, \\'b\\': 3}\\n        counter(word2) = {\\'a\\': 1, \\'b\\':2, \\'c\\':3}\\n        so {\\'a\\', \\'b\\', \\'c\\'} should occur in both words and no extra letters should exist\\n    3. Count of different values in counter should be same.\\n        e.g. word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\n        Counter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2}   => values are [5, 5, 4, 3, 2, 2]\\n        Counter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\n        if the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "This code works perfectly fine for 1657. Determine if Two Strings Are Close ... looking for how i can optimize this solution. Current time complexity goes O(4n). Looking for suggestions on how can i make it to O(n)\n \n    public boolean closeStrings(String word1, String word2) {\n        Map<Character, Integer> char_count_of_word1 = new HashMap<>();\n        Map<Character, Integer> char_count_of_word2 = new HashMap<>();\n\n        for(int i=0; i<word1.length(); i++){\n            if(char_count_of_word1.containsKey(word1.charAt(i))){\n                int current_count = char_count_of_word1.get(word1.charAt(i));\n                char_count_of_word1.put(word1.charAt(i), ++current_count);\n            } else {\n                char_count_of_word1.put(word1.charAt(i), 1);\n            }\n        }\n        for(int i=0; i<word2.length(); i++){\n            if(char_count_of_word2.containsKey(word2.charAt(i))){\n                int current_count = char_count_of_word2.get(word2.charAt(i));\n                char_count_of_word2.put(word2.charAt(i), ++current_count);\n            } else {\n                char_count_of_word2.put(word2.charAt(i), 1);\n            }\n        }\n\n        ArrayList<Character> list1_char = new ArrayList<>();\n        ArrayList<Integer> list1_count = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word1.entrySet()){\n            list1_count.add(entry.getValue());\n            list1_char.add(entry.getKey());\n        }\n\n        ArrayList<Integer> list2_count = new ArrayList<>();\n        ArrayList<Character> list2_char = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word2.entrySet()){\n            list2_count.add(entry.getValue());\n            list2_char.add(entry.getKey());\n        }\n\n        Collections.sort(list1_count);\n        Collections.sort(list1_char);\n        Collections.sort(list2_count);\n        Collections.sort(list2_char);\n        \n        if (list1_count.equals(list2_count) && list1_char.equals(list2_char)){\n            return true;\n        }\n        return false;\n    }\n"
                    },
                    {
                        "username": "DDKK64",
                        "content": "Just an IQ test problem. No much knowledge in it.  :("
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "1. We can not insert or delete any character from strings, so length of both strings should be equal.\\n2. Also, From point 1, both strings should have same set of characters, example: string1=\"abc\" , string2=\"abd\", because we cannot convert \\'c\\' to \\'d\\'.\\n3. Now we can convert any string s1 to string s2, if they have same set of frequencies for the characters.\\nExample:\\nstring s1=\"abbbcdc\"\\nfreq: a=1, b=3, c=2, d=1\\nstring s2=\"aabcdac\"\\nfreq: a=3, b=1, c=2, d=1\\nset of freq for s1 are (in sorted order): 1,1,2,3\\nset of freq for s2 are (in sorted order): 1,1,2,3\\n\\nboth are same. so we can make s1 equals to s2.\\nOther wise we cannot convert s1 to s2."
                    },
                    {
                        "username": "subodhr2001",
                        "content": "Input:\n\"aaabbbbccddeeeeefffff\"\n\"aaaaabbcccdddeeeeffff\"\n\nWhy is the result true for this test case 147? How can these two strings be called close? For example here is only one character with frequency = 5 in word2 whereas 2 characters with frequency = 5 in word 1.  How can we apply the second operation properly here using one-to-one mapping?"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Its result will be false, not true.\\nI have tested these input and its also expecting false only."
                    }
                ]
            },
            {
                "id": 1702944,
                "content": [
                    {
                        "username": "Raja_7321",
                        "content": "bool closeStrings(string word1, string word2) {\\n        if(word1.size()==word2.size()){\\n           vector<int>freq1(26,0);\\n           vector<int>freq2(26,0);\\n           for(int i=0;i<word1.size();i++){\\n               freq1[word1[i]-\\'a\\']++;\\n               freq2[word2[i]-\\'a\\']++;\\n           }\\n           for(int i=0;i<26;i++){\\n               if(freq1[i]==0 && freq2[i]!=0){\\n                       return false;\\n               }\\n               else if(freq1[i]!=0 && freq2[i]==0){\\n                   return false;\\n               }\\n           }\\n           for(int i=0;i<26;i++){\\n              bool flag=true;\\n              for(int j=0;j<26;j++){\\n                  if(freq1[i]==freq2[j]){\\n                      flag=false;\\n                      freq2[j]=0;\\n                      break;\\n                  }\\n              }\\n              if(flag){\\n                  return false;\\n              }\\n           }\\n           return true;\\n           \\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "What is the best time complexity we can achieve for this problem??"
                    },
                    {
                        "username": "pranavtiwari96",
                        "content": "Is it O(NlogN) \\nas we have to use sort at least once in this.\\n"
                    },
                    {
                        "username": "monapriya",
                        "content": " `\\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>();\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>();\\n\\n        pq1.add(2);\\n        pq1.add(1);\\n        pq1.add(3);\\n\\n        pq2.add(3);\\n        pq2.add(2);\\n        pq2.add(1);\\n\\n        System.out.println(pq1.equals(pq2));\\n}`\\nCan anyone please help me understand, what output this code gives and why?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This code creates two priority queues and add some elements in both of them. I'm suspecting that you want to compare if both queues have the same elements but the default implementation of equals here will return false.\n\nOne way to check if your queues are equal is something like this:\n```\nfor (Object element : pq1){\n    System.out.println(pq2.contains(element) ? true : false);\n   }\n```"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "I have tested 6 cases (added the failed cases after submitting the solution implemented in golang) and sill stuck with one testcase always failing irrespective of the input satisfies all the criteria :\n\nInput :\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\nOutput :\n  `true`\n\nExpected :\n  `false`\n\ndebug print :\n`k1: map[a:2 b:2 c:1 z:2] || k2: map[a:1 b:2 c:1 z:3]` \n`matching a, true || matching b, true || matching z, true || matching c, true || `\n\nAm i missing some thing here or the expected testcase result is incorrect ?\nThanks in advance."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) you should sort the 2 maps, and then compare indexes.\n\nif (map1[0] === map2[0] && map1[1] === map2[1] ... ) {\n  return true;\n} else {\n  return false;\n}\n\nIn this case, [ 1, 2, 2, 2 ],   [  1, 1, 2, 3 ], map1[1] is different from map2[1] so I'd return false because of that.\n\nIn my case I didn't found a way to sort the maps based on their values, so I converted them into arrays from the maps."
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@fsdevelop](/fsdevelop) I have two such different testcases :\n\nTestCase 1: -> this WORKS FINE even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 =  \"cabbba\"`\n  `word2 = \"abbccc\"`\n\n`Output: true`\n\n`Expected: true`\n\nDebug Print:\n`map[a:2 b:3 c:1] map[a:1 b:2 c:3]`\n`matching c, true || matching a, true || matching b, true || `  (matching only the keys)\n\n========================================\n\nTestCase 2: -> this DOESN'T WORKS even the occurrence of each letter are different in two dicts.\nInput:\n  `word1 = \"abbzzca\"`\n  `word2 = \"babzzcz\"`\n\n`Output: true`\n\n`Expected: false`\n\nDebug Print:\n`map[a:2 b:2 c:1 z:2] map[a:1 b:2 c:1 z:3]`\n`matching a, true || matching b, true || matching z, true || matching c, true || ` (matching only the keys)\n\nIf i am validating the equality of sorted arrays, it breaks the first case.\nTherefore, I am still doubting that the two testcases are similar but produces two different results where either testcae1 or testcase2 expected result is invalid.\n"
                    },
                    {
                        "username": "fsdevelop",
                        "content": "[@skvenkat07](/skvenkat07) You need the two arrays I mentioned to be identical after sorted.\\n\\n[1, 2, 3] == [3, 1, 2] => true\\n[2, 3, 4] != [1, 3, 4]  => false"
                    },
                    {
                        "username": "skvenkat07",
                        "content": "[@Federico Sosa](/fsdevelop) Thanks a lot for the explanation... I'll fix the code and try again."
                    },
                    {
                        "username": "fsdevelop",
                        "content": "I faced the same problem here. The key to solve this challenge is also to check how many times each letter appear in each word.\\n\\nFor example in \"abbzzca\":\\n- \"a\" appears 2 times\\n- \"b\" appears 2 times\\n- \"z\" appears 2 times\\n- \"c\" appears 1 time.\\n\\nAnd then, in \"babzzcz\":\\n- \"a\" appears 1 time\\n- \"b\" appears 2 times\\n- \"z\" appears 3 times\\n- \"c\" appears 1 time\\n\\nIf you compare these arrays [2, 2, 2, 1], [1, 2, 3, 1] they don\\'t match in numbers, so even if you make any of the 2 operations it won\\'t be possible to match each word."
                    },
                    {
                        "username": "aerosync",
                        "content": "can someone explain to me what word1[c-\\'a\\']++ is doing in everyones c++ code. i dont understand the -\\'a\\' syntax or what its doing"
                    },
                    {
                        "username": "wyldbill",
                        "content": "c - \\'a\\' provides a 0 based index to the letter. 0->a, 1->b, 2->c, etc. useful for indexing based on letters into an alphabet sized array."
                    },
                    {
                        "username": "dkashi",
                        "content": "two strings are close if following conditions are met:\\n    1. len(word1) == len(word2)\\n    2. counter(word1).keys() == counter(word2).keys()\\n        e.g. word1 = \"cabbba\", word2 = \"abbccc\"\\n        counter(word1) = {\\'c\\': 1, \\'a\\': 2, \\'b\\': 3}\\n        counter(word2) = {\\'a\\': 1, \\'b\\':2, \\'c\\':3}\\n        so {\\'a\\', \\'b\\', \\'c\\'} should occur in both words and no extra letters should exist\\n    3. Count of different values in counter should be same.\\n        e.g. word1 = \"aaabbbbccddeeeeefffff\", word2 = \"aaaaabbcccdddeeeeffff\"\\n        Counter(word1)= {\\'e\\': 5, \\'f\\': 5, \\'b\\': 4, \\'a\\': 3, \\'c\\': 2, \\'d\\': 2}   => values are [5, 5, 4, 3, 2, 2]\\n        Counter(word2) = {\\'a\\': 5, \\'e\\': 4, \\'f\\': 4, \\'c\\': 3, \\'d\\': 3, \\'b\\': 2}) => values are [5, 4, 4, 3, 3, 2]\\n        if the count of values are equal means we can easily swap all occurrences of a character to another character. For this case, answer should be False since value counts are not equal."
                    },
                    {
                        "username": "vlrd",
                        "content": "This code works perfectly fine for 1657. Determine if Two Strings Are Close ... looking for how i can optimize this solution. Current time complexity goes O(4n). Looking for suggestions on how can i make it to O(n)\n \n    public boolean closeStrings(String word1, String word2) {\n        Map<Character, Integer> char_count_of_word1 = new HashMap<>();\n        Map<Character, Integer> char_count_of_word2 = new HashMap<>();\n\n        for(int i=0; i<word1.length(); i++){\n            if(char_count_of_word1.containsKey(word1.charAt(i))){\n                int current_count = char_count_of_word1.get(word1.charAt(i));\n                char_count_of_word1.put(word1.charAt(i), ++current_count);\n            } else {\n                char_count_of_word1.put(word1.charAt(i), 1);\n            }\n        }\n        for(int i=0; i<word2.length(); i++){\n            if(char_count_of_word2.containsKey(word2.charAt(i))){\n                int current_count = char_count_of_word2.get(word2.charAt(i));\n                char_count_of_word2.put(word2.charAt(i), ++current_count);\n            } else {\n                char_count_of_word2.put(word2.charAt(i), 1);\n            }\n        }\n\n        ArrayList<Character> list1_char = new ArrayList<>();\n        ArrayList<Integer> list1_count = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word1.entrySet()){\n            list1_count.add(entry.getValue());\n            list1_char.add(entry.getKey());\n        }\n\n        ArrayList<Integer> list2_count = new ArrayList<>();\n        ArrayList<Character> list2_char = new ArrayList<>();\n\n        for(Map.Entry<Character, Integer> entry:char_count_of_word2.entrySet()){\n            list2_count.add(entry.getValue());\n            list2_char.add(entry.getKey());\n        }\n\n        Collections.sort(list1_count);\n        Collections.sort(list1_char);\n        Collections.sort(list2_count);\n        Collections.sort(list2_char);\n        \n        if (list1_count.equals(list2_count) && list1_char.equals(list2_char)){\n            return true;\n        }\n        return false;\n    }\n"
                    },
                    {
                        "username": "DDKK64",
                        "content": "Just an IQ test problem. No much knowledge in it.  :("
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "1. We can not insert or delete any character from strings, so length of both strings should be equal.\\n2. Also, From point 1, both strings should have same set of characters, example: string1=\"abc\" , string2=\"abd\", because we cannot convert \\'c\\' to \\'d\\'.\\n3. Now we can convert any string s1 to string s2, if they have same set of frequencies for the characters.\\nExample:\\nstring s1=\"abbbcdc\"\\nfreq: a=1, b=3, c=2, d=1\\nstring s2=\"aabcdac\"\\nfreq: a=3, b=1, c=2, d=1\\nset of freq for s1 are (in sorted order): 1,1,2,3\\nset of freq for s2 are (in sorted order): 1,1,2,3\\n\\nboth are same. so we can make s1 equals to s2.\\nOther wise we cannot convert s1 to s2."
                    },
                    {
                        "username": "subodhr2001",
                        "content": "Input:\n\"aaabbbbccddeeeeefffff\"\n\"aaaaabbcccdddeeeeffff\"\n\nWhy is the result true for this test case 147? How can these two strings be called close? For example here is only one character with frequency = 5 in word2 whereas 2 characters with frequency = 5 in word 1.  How can we apply the second operation properly here using one-to-one mapping?"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Its result will be false, not true.\\nI have tested these input and its also expecting false only."
                    }
                ]
            }
        ]
    }
]