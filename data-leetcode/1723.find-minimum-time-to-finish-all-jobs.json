[
    {
        "title": "Sort an Array",
        "question_content": "Given an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.\n&nbsp;\nExample 1:\n\nInput: nums = [5,2,3,1]\nOutput: [1,2,3,5]\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).\n\nExample 2:\n\nInput: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\nExplanation: Note that the values of nums are not necessairly unique.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 5 * 104\n\t-5 * 104 <= nums[i] <= 5 * 104",
        "solutions": [
            {
                "id": 1401412,
                "title": "c-clean-code-solution-fastest-all-15-sorting-methods-detailed",
                "content": "### Table of Content:\\n* STL\\n\\t* Method1: Standard \\n\\t* Method2: Stable\\n* Insertion Sort\\n\\t* Method1: Iterative\\n\\t* Method2: Recursive\\n* Selection Sort\\n\\t* Method1: Standard\\n\\t* Method2: Standard using inbuilt\\n* Bubble Sort\\n* Quick Sort\\n\\t* Method1: Standard\\n\\t* Method2: Randomised\\n* Merge Sort\\n\\t* Method1: Outplace Merging\\n\\t* Method2: Inplace Merging\\n* Generalised Radix Sort\\n\\t* Method1: Using MinVal\\n\\t* Method2: Using Partitioning\\n* Generalised Counting Sort\\n* Heap Sort\\n* Bucket Sort\\n\\n##### STL\\n\\n1. Method1: Standard (Accepted) [T(n) = O(n * lgn)]\\n\\n```\\nvoid stlSort(vector<int>& nums) {\\n\\tsort(nums.begin(), nums.end());\\n}\\n```\\n\\n2. Method2: Stable (Accepted) [T(n) = O(n * lgn)]\\n```\\nvoid stableStlSort(vector<int>& nums) {\\n\\tstable_sort(nums.begin(), nums.end());\\n}\\n```\\n\\n##### Insertion Sort\\n\\n1. Method1: Iterative (TLE) [T(n) = O(n^2)]\\n\\n```\\nvoid insertionSort(vector<int> &nums) {\\n\\tint sortedInd, unsortedInd, key, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (unsortedInd = 1; unsortedInd < size; unsortedInd++) {\\n\\t\\tkey = nums[unsortedInd], sortedInd = unsortedInd;\\n\\t\\twhile (--sortedInd >= 0 and key < nums[sortedInd])\\n\\t\\t\\tnums[sortedInd + 1] = nums[sortedInd];\\n\\t\\tnums[sortedInd + 1] = key;\\n\\t}\\n}\\n```\\n\\n2. Method2: Recursive (TLE) [T(n) = O(n^2)]\\n\\n```\\nvoid recInsert(vector<int> &nums, int val) {\\n\\tif (!nums.size() or nums.back() <= val)\\n\\t\\treturn nums.push_back(val);\\n\\tint last = nums.back();\\n\\tnums.pop_back();\\n\\trecInsert(nums, val);\\n\\tnums.push_back(last);\\n}\\n\\t\\nvoid recInsertionSort(vector<int> &nums) {\\n\\tif (nums.size() <= 1) return;\\n\\tint last = nums.back();\\n\\tnums.pop_back();\\n\\trecInsertionSort(nums);\\n\\trecInsert(nums, last);\\n}\\n```\\n\\n##### Selection Sort\\n\\n1. Method1: Standard (TLE) [T(n) = Theta(n^2)]\\n\\n```\\nvoid selectionSort(vector<int> &nums) {\\n\\tint minInd, startInd, currInd, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (startInd = 0; startInd < size - 1; startInd++) {\\n\\t\\tfor (currInd = startInd + 1, minInd = startInd; currInd < size; currInd++)\\n\\t\\t\\tif (nums[minInd] > nums[currInd])\\n\\t\\t\\t\\tminInd = currInd;\\n\\t\\tif (minInd != startInd)\\n\\t\\t\\tswap(nums[startInd], nums[minInd]);\\n\\t}\\n}\\n```\\n\\n2. Method2: Standard using inbuilt (TLE) [T(n) = Theta(n^2)]\\n\\n```\\nvoid selectionSort(vector<int> &nums) {\\n\\tint minInd, startInd, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (startInd = 0; startInd < size - 1; startInd++) {\\n\\t\\tminInd = min_element(nums.begin() + startInd, nums.end()) - nums.begin();\\n\\t\\tif (minInd != startInd)\\n\\t\\t\\tswap(nums[startInd], nums[minInd]);\\n\\t}\\n}\\n```\\n\\n##### Bubble Sort (TLE)  [T(n) = Theta(n^2)]\\n\\n```\\nvoid bubbleSort(vector<int> &nums) {\\n\\tint endInd, currInd, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (endInd = size - 1; endInd; endInd--)\\n\\t\\tfor (currInd = 0; currInd < endInd; currInd++)\\n\\t\\t\\tif (nums[currInd] > nums[currInd + 1])\\n\\t\\t\\t\\tswap(nums[currInd], nums[currInd + 1]);\\n}\\n```\\n\\n##### Quick Sort\\n\\n1. Method1: Standard (TLE)  [T(n) = O(n^2)]\\n\\n```\\nint partitionArray(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return -1;\\n\\tint pivot = low, l = pivot + 1, r = high;\\n\\twhile (l <= r)\\n\\t\\tif (nums[l] < nums[pivot]) l++;\\n\\t\\telse if (nums[r] >= nums[pivot]) r--;\\n\\t\\telse swap(nums[l], nums[r]);\\n\\tswap(nums[pivot], nums[r]);\\n\\treturn r;\\n}\\n\\t\\nvoid quickSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tint pivot = partitionArray(nums, low, high);\\n\\tquickSort(nums, low, pivot);\\n\\tquickSort(nums, pivot + 1, high);\\n}\\n```\\n\\n2. Method2: Randomised (TLE)  [T(n) = O(n * lgn) on avg. but O(n^2) in worst case]\\n\\n```\\nint partitionArray(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return -1;\\n\\tint pivot = low, l = pivot + 1, r = high;\\n\\twhile (l <= r)\\n\\t\\tif (nums[l] < nums[pivot]) l++;\\n\\t\\telse if (nums[r] >= nums[pivot]) r--;\\n\\t\\telse swap(nums[l], nums[r]);\\n\\tswap(nums[pivot], nums[r]);\\n\\treturn r;\\n}\\n\\nvoid quickSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tswap(nums[low + rand() % (high - low + 1)], nums[low]);\\n\\tint pivot = partitionArray(nums, low, high);\\n\\tquickSort(nums, low, pivot);\\n\\tquickSort(nums, pivot + 1, high);\\n}\\n```\\n\\n##### Merge Sort\\n\\n1. Method1: Outplace Merging (Accepted) [T(n) = O(n * lgn)]\\n\\n```\\nvoid outPlaceMerge(vector<int> &nums, int low, int mid, int high) {\\n\\tif (low >= high) return;\\n\\tint l = low, r = mid + 1, k = 0, size = high - low + 1;\\n\\tvector<int> sorted(size, 0);\\n\\twhile (l <= mid and r <= high)\\n\\t\\tsorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\\n\\twhile (l <= mid) \\n\\t\\tsorted[k++] = nums[l++];\\n\\twhile (r <= high) \\n\\t\\tsorted[k++] = nums[r++];\\n\\tfor (k = 0; k < size; k++)\\n\\t\\tnums[k + low] = sorted[k];\\n}\\n\\nvoid mergeSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tint mid = (high - low) / 2 + low;\\n\\tmergeSort(nums, low, mid);\\n\\tmergeSort(nums, mid + 1, high);\\n\\toutPlaceMerge(nums, low, mid, high);\\n}\\n```\\n\\n2. Method2: Inplace Merging (TLE) [T(n) = O(n^2)]\\n\\n```\\nvoid inPlaceMerge(vector<int> &nums, int low, int mid, int high) {\\n\\tif (low >= high) return;\\n\\tint l = low, r = mid + 1, size = high - low + 1;\\n\\twhile (l <= mid and r <= high) {\\n\\t\\tif (nums[l] <= nums[r]) l++;\\n\\t\\telse {\\n\\t\\t\\tint val = nums[r];\\n\\t\\t\\tfor (int k = r++; k > l; k--)\\n\\t\\t\\t\\tnums[k] = nums[k - 1];\\n\\t\\t\\tnums[l++] = val;\\n\\t\\t\\tmid++;\\n\\t\\t}\\n\\t}\\n}\\n\\nvoid mergeSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tint mid = (high - low) / 2 + low;\\n\\tmergeSort(nums, low, mid);\\n\\tmergeSort(nums, mid + 1, high);\\n\\tinPlaceMerge(nums, low, mid, high);\\n}\\n```\\n\\n##### Generalised Couting Sort (Accepted) [T(n) = Theta(max(n, m)) where m = max(Arr)]\\n\\n```\\nvoid countingSort(vector<int> &nums, bool isAscending=true) {\\n\\tint minVal = *min_element(nums.begin(), nums.end());\\n\\tint maxVal = *max_element(nums.begin(), nums.end());\\n\\t// int freqSize = maxVal - minVal + 1 is enough i.e its also correct\\n\\tint freqSize = maxVal - minVal + 1 + 1, size = nums.size();\\n\\tvector<int> freq(freqSize, 0), sorted(size, 0);\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tfreq[nums[ind] - minVal]++;\\n\\tif (isAscending)\\n\\t\\tfor (int ind = 1; ind < freqSize; ind++)\\n\\t\\t\\tfreq[ind] += freq[ind - 1];\\n\\telse\\n\\t\\tfor (int ind = freqSize - 2; ind >= 0; ind--)\\n\\t\\t\\tfreq[ind] += freq[ind + 1];\\n\\t// for stable sorting start ind from end and decrement till 0\\n\\tfor (int ind = size - 1; ind >= 0; ind--)\\n\\t\\tsorted[freq[nums[ind] - minVal]-- - 1] = nums[ind];\\n\\tnums = sorted;\\n}\\n```\\n\\n##### Generalised Radix Sort \\n\\n1. Method1: Using MinVal (Accepted)  [T(n) = Theta(n)]\\n\\n```\\nint getDigit(int num, int factor) {\\n\\treturn (abs(num) / abs(factor)) % 10;\\n}\\n\\nvoid radixCountingSort(vector<int> &nums, int factor) {\\n\\tint freqSize = 10, size = nums.size();\\n\\tvector<int> freq(freqSize, 0), sorted(size, 0);\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tfreq[getDigit(nums[ind], factor)]++;\\n\\tfor (int ind = 1; ind < freqSize; ind++)\\n\\t\\tfreq[ind] += freq[ind - 1];\\n\\t// for stable sorting start ind from end and decrement till 0\\n\\tfor (int ind = size - 1; ind >= 0; ind--)\\n\\t\\tsorted[freq[getDigit(nums[ind], factor)]-- - 1] = nums[ind];\\n\\tnums = sorted;\\n}\\n\\nvoid radixSort(vector<int> &nums) {\\n\\tint minVal = *min_element(nums.begin(), nums.end());\\n\\tfor (auto &num : nums) num -= minVal;\\n\\tint factor = 1, maxVal = *max_element(nums.begin(), nums.end());\\n\\twhile (maxVal / factor) {\\n\\t\\tradixCountingSort(nums, factor);\\n\\t\\tfactor *= 10;\\n\\t}\\n\\tfor (auto &num : nums) num += minVal;\\n}\\n```\\n\\n2. Method2: Using Partitioning (Accepted)  [T(n) = Theta(n)]\\n\\n\\tIdea is to partition the Array with pivot as mininum Positive Element and thus, left half array is of -ve no.s (if any) and right half array is of +ve no.s (if any). Finally we apply Radix Sort on both the parts.\\n\\tNote that to sort -ve no.s only with Radix Sort, we need to reverse sort the -ve no.s (eg: [-5,-4,-3] and [3,4,5])\\n\\n```\\nint partitionArray(vector<int> &nums, int low=0, int high=-1) {\\n\\thigh = high < 0 ? nums.size() - 1 : high;\\n\\tif (low >= high) return -1;\\n\\tint pivot = low, l = pivot + 1, r = high;\\n\\twhile (l <= r)\\n\\t\\tif (nums[l] < nums[pivot]) l++;\\n\\t\\telse if (nums[r] >= nums[pivot]) r--;\\n\\t\\telse swap(nums[l], nums[r]);\\n\\tswap(nums[pivot], nums[r]);\\n\\treturn r;\\n}\\n\\nint getDigit(int num, int factor) {\\n\\treturn (abs(num) / abs(factor)) % 10;\\n}\\n\\npair<int, int> getMinAndNonNegMinInd(vector<int> &nums) {\\n\\tint minInd = nums.size(), minVal = INT_MAX;\\n\\tint nonNegMinInd = nums.size(), minNonNegVal = INT_MAX;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tif (nums[i] >= 0 and nums[i] < minNonNegVal)\\n\\t\\t\\tnonNegMinInd = i, minNonNegVal = nums[i];\\n\\t\\tif (nums[i] < minVal)\\n\\t\\t\\tminInd = i, minVal = nums[i];\\n\\t}\\n\\treturn {minInd, nonNegMinInd};\\n}\\n\\nint radixSortPartionArray(vector<int> &nums) {\\n\\tauto [minInd, nonNegMinInd] = getMinAndNonNegMinInd(nums);\\n\\tif (nonNegMinInd < nums.size()) {\\n\\t\\tif (nonNegMinInd) swap(nums[0], nums[nonNegMinInd]);\\n\\t\\tif (nums[minInd] >= 0) nonNegMinInd = 0;\\n\\t\\telse nonNegMinInd = partitionArray(nums);\\n\\t}\\n\\treturn nonNegMinInd;\\n}\\n\\nvoid radixCountingSort(vector<int> &nums, int factor, int low, int high, bool isAscending=true) {\\n\\tif (low >= high) return;\\n\\tint freqSize = 10, size = high - low + 1;\\n\\tvector<int> freq(freqSize, 0), sorted(size, 0);\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tfreq[getDigit(nums[ind + low], factor)]++;\\n\\tif (isAscending)\\n\\t\\t// reference: http://analgorithmaday.blogspot.com/2011/03/counting-sortlinear-time.html\\n\\t\\tfor (int ind = 1; ind < freqSize; ind++)\\n\\t\\t\\tfreq[ind] += freq[ind - 1];\\n\\telse\\n\\t\\tfor (int ind = freqSize - 2; ind >= 0; ind--)\\n\\t\\t\\tfreq[ind] += freq[ind + 1];\\n\\t// for stable sorting start ind from end and decrement till 0\\n\\tfor (int ind = size - 1; ind >= 0; ind--)\\n\\t\\tsorted[freq[getDigit(nums[ind + low], factor)]-- - 1] = nums[ind + low];\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tnums[ind + low] = sorted[ind];\\n}\\n\\nvoid radixSortHelper(vector<int> &nums, int low, int high, bool isAscending=true) {\\n\\tif (low >= high) return;\\n\\tint maxVal = *max_element(nums.begin() + low, nums.begin() + high + 1, [] (int &a, int &b) {\\n\\t\\treturn abs(a) < abs(b);\\n\\t});\\n\\tint factor = 1;\\n\\twhile (maxVal / factor) {\\n\\t\\tradixCountingSort(nums, factor, low, high, isAscending);\\n\\t\\tfactor *= 10;\\n\\t}\\n}\\n\\nvoid radixSort(vector<int> &nums) {\\n\\tint nonNegMinInd = radixSortPartionArray(nums);\\n\\tif (nonNegMinInd <= 1)\\n\\t\\tradixSortHelper(nums, nonNegMinInd + 1, nums.size() - 1);\\n\\telse {\\n\\t\\tradixSortHelper(nums, 0, nonNegMinInd - 1, false);\\n\\t\\tradixSortHelper(nums, nonNegMinInd + 1, nums.size() - 1);\\n\\t}\\n}\\n```\\n\\n##### Heap Sort (Accepted) [T(n) = O(n * lgn)]\\n\\n```\\nvoid heapifyDown(vector<int> &nums, int size, int rootInd, bool isMin=false) {\\n\\tif (size <= 1 or rootInd < 0 or rootInd >= size - 1) return;\\n\\tint keyInd = rootInd, leftChildInd = 2 * rootInd + 1, rightChildInd = 2 * rootInd + 2;\\n\\tif (leftChildInd < size and (isMin ? nums[leftChildInd] < nums[keyInd] : nums[leftChildInd] > nums[keyInd]))\\n\\t\\tkeyInd = leftChildInd;\\n\\tif (rightChildInd < size and (isMin ? nums[rightChildInd] < nums[keyInd] : nums[rightChildInd] > nums[keyInd]))\\n\\t\\tkeyInd = rightChildInd;\\n\\tif (nums[keyInd] != nums[rootInd]) {\\n\\t\\tswap(nums[rootInd], nums[keyInd]);\\n\\t\\theapifyDown(nums, size, keyInd, isMin);\\n\\t}\\n}\\n\\nvoid heapifyArray(vector<int> &nums, bool isMin=false) {\\n\\tint size = nums.size();\\n\\tif (size <= 1) return;\\n\\tint tailRootInd = (size >> 1) - 1;\\n\\tfor (int rootInd = tailRootInd; rootInd >= 0; rootInd--)\\n\\t\\theapifyDown(nums, size, rootInd, isMin);\\n}\\n\\nvoid heapSort(vector<int> &nums) {\\n\\tif (nums.size() <= 1) return;\\n\\theapifyArray(nums);\\n\\tfor (int size = nums.size() - 1; size; size--) {\\n\\t\\tswap(nums[size], nums[0]);\\n\\t\\theapifyDown(nums, size, 0);\\n\\t}\\n}\\n```\\n\\n##### Bucket Sort\\n\\nBucket sort\\'s performance depends upon the uniformity (distribution) of the input data. Hence, I am not discussing it here (I have not submitted it as well for given constraints). For more info on this Algo, you can google it.\\n\\n##### Among above, Counting Sort was fastest in Leetcode OJ.\\n\\n**IMP:** You can also bookmark/ subscribe to this post so as to revise above Sorting Algorithms whenvever you need to. \\n\\n**NOTE:** \\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written posts on Kadane\\'s Algorithm and Follow up Questions [C++] in a cleaner way [here](https://leetcode.com/problems/maximum-subarray/discuss/1470547/C++-Easy-and-Clean-Solution-or-Fastest:-0ms-or-All-Methods-or-Follow-Ups-or-Detailed-Explanation) on leetcode.\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*\\n\\n",
                "solutionTags": [
                    "C++",
                    "Merge Sort",
                    "Bucket Sort",
                    "Radix Sort",
                    "Counting Sort"
                ],
                "code": "```\\nvoid stlSort(vector<int>& nums) {\\n\\tsort(nums.begin(), nums.end());\\n}\\n```\n```\\nvoid stableStlSort(vector<int>& nums) {\\n\\tstable_sort(nums.begin(), nums.end());\\n}\\n```\n```\\nvoid insertionSort(vector<int> &nums) {\\n\\tint sortedInd, unsortedInd, key, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (unsortedInd = 1; unsortedInd < size; unsortedInd++) {\\n\\t\\tkey = nums[unsortedInd], sortedInd = unsortedInd;\\n\\t\\twhile (--sortedInd >= 0 and key < nums[sortedInd])\\n\\t\\t\\tnums[sortedInd + 1] = nums[sortedInd];\\n\\t\\tnums[sortedInd + 1] = key;\\n\\t}\\n}\\n```\n```\\nvoid recInsert(vector<int> &nums, int val) {\\n\\tif (!nums.size() or nums.back() <= val)\\n\\t\\treturn nums.push_back(val);\\n\\tint last = nums.back();\\n\\tnums.pop_back();\\n\\trecInsert(nums, val);\\n\\tnums.push_back(last);\\n}\\n\\t\\nvoid recInsertionSort(vector<int> &nums) {\\n\\tif (nums.size() <= 1) return;\\n\\tint last = nums.back();\\n\\tnums.pop_back();\\n\\trecInsertionSort(nums);\\n\\trecInsert(nums, last);\\n}\\n```\n```\\nvoid selectionSort(vector<int> &nums) {\\n\\tint minInd, startInd, currInd, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (startInd = 0; startInd < size - 1; startInd++) {\\n\\t\\tfor (currInd = startInd + 1, minInd = startInd; currInd < size; currInd++)\\n\\t\\t\\tif (nums[minInd] > nums[currInd])\\n\\t\\t\\t\\tminInd = currInd;\\n\\t\\tif (minInd != startInd)\\n\\t\\t\\tswap(nums[startInd], nums[minInd]);\\n\\t}\\n}\\n```\n```\\nvoid selectionSort(vector<int> &nums) {\\n\\tint minInd, startInd, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (startInd = 0; startInd < size - 1; startInd++) {\\n\\t\\tminInd = min_element(nums.begin() + startInd, nums.end()) - nums.begin();\\n\\t\\tif (minInd != startInd)\\n\\t\\t\\tswap(nums[startInd], nums[minInd]);\\n\\t}\\n}\\n```\n```\\nvoid bubbleSort(vector<int> &nums) {\\n\\tint endInd, currInd, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (endInd = size - 1; endInd; endInd--)\\n\\t\\tfor (currInd = 0; currInd < endInd; currInd++)\\n\\t\\t\\tif (nums[currInd] > nums[currInd + 1])\\n\\t\\t\\t\\tswap(nums[currInd], nums[currInd + 1]);\\n}\\n```\n```\\nint partitionArray(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return -1;\\n\\tint pivot = low, l = pivot + 1, r = high;\\n\\twhile (l <= r)\\n\\t\\tif (nums[l] < nums[pivot]) l++;\\n\\t\\telse if (nums[r] >= nums[pivot]) r--;\\n\\t\\telse swap(nums[l], nums[r]);\\n\\tswap(nums[pivot], nums[r]);\\n\\treturn r;\\n}\\n\\t\\nvoid quickSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tint pivot = partitionArray(nums, low, high);\\n\\tquickSort(nums, low, pivot);\\n\\tquickSort(nums, pivot + 1, high);\\n}\\n```\n```\\nint partitionArray(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return -1;\\n\\tint pivot = low, l = pivot + 1, r = high;\\n\\twhile (l <= r)\\n\\t\\tif (nums[l] < nums[pivot]) l++;\\n\\t\\telse if (nums[r] >= nums[pivot]) r--;\\n\\t\\telse swap(nums[l], nums[r]);\\n\\tswap(nums[pivot], nums[r]);\\n\\treturn r;\\n}\\n\\nvoid quickSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tswap(nums[low + rand() % (high - low + 1)], nums[low]);\\n\\tint pivot = partitionArray(nums, low, high);\\n\\tquickSort(nums, low, pivot);\\n\\tquickSort(nums, pivot + 1, high);\\n}\\n```\n```\\nvoid outPlaceMerge(vector<int> &nums, int low, int mid, int high) {\\n\\tif (low >= high) return;\\n\\tint l = low, r = mid + 1, k = 0, size = high - low + 1;\\n\\tvector<int> sorted(size, 0);\\n\\twhile (l <= mid and r <= high)\\n\\t\\tsorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\\n\\twhile (l <= mid) \\n\\t\\tsorted[k++] = nums[l++];\\n\\twhile (r <= high) \\n\\t\\tsorted[k++] = nums[r++];\\n\\tfor (k = 0; k < size; k++)\\n\\t\\tnums[k + low] = sorted[k];\\n}\\n\\nvoid mergeSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tint mid = (high - low) / 2 + low;\\n\\tmergeSort(nums, low, mid);\\n\\tmergeSort(nums, mid + 1, high);\\n\\toutPlaceMerge(nums, low, mid, high);\\n}\\n```\n```\\nvoid inPlaceMerge(vector<int> &nums, int low, int mid, int high) {\\n\\tif (low >= high) return;\\n\\tint l = low, r = mid + 1, size = high - low + 1;\\n\\twhile (l <= mid and r <= high) {\\n\\t\\tif (nums[l] <= nums[r]) l++;\\n\\t\\telse {\\n\\t\\t\\tint val = nums[r];\\n\\t\\t\\tfor (int k = r++; k > l; k--)\\n\\t\\t\\t\\tnums[k] = nums[k - 1];\\n\\t\\t\\tnums[l++] = val;\\n\\t\\t\\tmid++;\\n\\t\\t}\\n\\t}\\n}\\n\\nvoid mergeSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tint mid = (high - low) / 2 + low;\\n\\tmergeSort(nums, low, mid);\\n\\tmergeSort(nums, mid + 1, high);\\n\\tinPlaceMerge(nums, low, mid, high);\\n}\\n```\n```\\nvoid countingSort(vector<int> &nums, bool isAscending=true) {\\n\\tint minVal = *min_element(nums.begin(), nums.end());\\n\\tint maxVal = *max_element(nums.begin(), nums.end());\\n\\t// int freqSize = maxVal - minVal + 1 is enough i.e its also correct\\n\\tint freqSize = maxVal - minVal + 1 + 1, size = nums.size();\\n\\tvector<int> freq(freqSize, 0), sorted(size, 0);\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tfreq[nums[ind] - minVal]++;\\n\\tif (isAscending)\\n\\t\\tfor (int ind = 1; ind < freqSize; ind++)\\n\\t\\t\\tfreq[ind] += freq[ind - 1];\\n\\telse\\n\\t\\tfor (int ind = freqSize - 2; ind >= 0; ind--)\\n\\t\\t\\tfreq[ind] += freq[ind + 1];\\n\\t// for stable sorting start ind from end and decrement till 0\\n\\tfor (int ind = size - 1; ind >= 0; ind--)\\n\\t\\tsorted[freq[nums[ind] - minVal]-- - 1] = nums[ind];\\n\\tnums = sorted;\\n}\\n```\n```\\nint getDigit(int num, int factor) {\\n\\treturn (abs(num) / abs(factor)) % 10;\\n}\\n\\nvoid radixCountingSort(vector<int> &nums, int factor) {\\n\\tint freqSize = 10, size = nums.size();\\n\\tvector<int> freq(freqSize, 0), sorted(size, 0);\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tfreq[getDigit(nums[ind], factor)]++;\\n\\tfor (int ind = 1; ind < freqSize; ind++)\\n\\t\\tfreq[ind] += freq[ind - 1];\\n\\t// for stable sorting start ind from end and decrement till 0\\n\\tfor (int ind = size - 1; ind >= 0; ind--)\\n\\t\\tsorted[freq[getDigit(nums[ind], factor)]-- - 1] = nums[ind];\\n\\tnums = sorted;\\n}\\n\\nvoid radixSort(vector<int> &nums) {\\n\\tint minVal = *min_element(nums.begin(), nums.end());\\n\\tfor (auto &num : nums) num -= minVal;\\n\\tint factor = 1, maxVal = *max_element(nums.begin(), nums.end());\\n\\twhile (maxVal / factor) {\\n\\t\\tradixCountingSort(nums, factor);\\n\\t\\tfactor *= 10;\\n\\t}\\n\\tfor (auto &num : nums) num += minVal;\\n}\\n```\n```\\nint partitionArray(vector<int> &nums, int low=0, int high=-1) {\\n\\thigh = high < 0 ? nums.size() - 1 : high;\\n\\tif (low >= high) return -1;\\n\\tint pivot = low, l = pivot + 1, r = high;\\n\\twhile (l <= r)\\n\\t\\tif (nums[l] < nums[pivot]) l++;\\n\\t\\telse if (nums[r] >= nums[pivot]) r--;\\n\\t\\telse swap(nums[l], nums[r]);\\n\\tswap(nums[pivot], nums[r]);\\n\\treturn r;\\n}\\n\\nint getDigit(int num, int factor) {\\n\\treturn (abs(num) / abs(factor)) % 10;\\n}\\n\\npair<int, int> getMinAndNonNegMinInd(vector<int> &nums) {\\n\\tint minInd = nums.size(), minVal = INT_MAX;\\n\\tint nonNegMinInd = nums.size(), minNonNegVal = INT_MAX;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tif (nums[i] >= 0 and nums[i] < minNonNegVal)\\n\\t\\t\\tnonNegMinInd = i, minNonNegVal = nums[i];\\n\\t\\tif (nums[i] < minVal)\\n\\t\\t\\tminInd = i, minVal = nums[i];\\n\\t}\\n\\treturn {minInd, nonNegMinInd};\\n}\\n\\nint radixSortPartionArray(vector<int> &nums) {\\n\\tauto [minInd, nonNegMinInd] = getMinAndNonNegMinInd(nums);\\n\\tif (nonNegMinInd < nums.size()) {\\n\\t\\tif (nonNegMinInd) swap(nums[0], nums[nonNegMinInd]);\\n\\t\\tif (nums[minInd] >= 0) nonNegMinInd = 0;\\n\\t\\telse nonNegMinInd = partitionArray(nums);\\n\\t}\\n\\treturn nonNegMinInd;\\n}\\n\\nvoid radixCountingSort(vector<int> &nums, int factor, int low, int high, bool isAscending=true) {\\n\\tif (low >= high) return;\\n\\tint freqSize = 10, size = high - low + 1;\\n\\tvector<int> freq(freqSize, 0), sorted(size, 0);\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tfreq[getDigit(nums[ind + low], factor)]++;\\n\\tif (isAscending)\\n\\t\\t// reference: http://analgorithmaday.blogspot.com/2011/03/counting-sortlinear-time.html\\n\\t\\tfor (int ind = 1; ind < freqSize; ind++)\\n\\t\\t\\tfreq[ind] += freq[ind - 1];\\n\\telse\\n\\t\\tfor (int ind = freqSize - 2; ind >= 0; ind--)\\n\\t\\t\\tfreq[ind] += freq[ind + 1];\\n\\t// for stable sorting start ind from end and decrement till 0\\n\\tfor (int ind = size - 1; ind >= 0; ind--)\\n\\t\\tsorted[freq[getDigit(nums[ind + low], factor)]-- - 1] = nums[ind + low];\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tnums[ind + low] = sorted[ind];\\n}\\n\\nvoid radixSortHelper(vector<int> &nums, int low, int high, bool isAscending=true) {\\n\\tif (low >= high) return;\\n\\tint maxVal = *max_element(nums.begin() + low, nums.begin() + high + 1, [] (int &a, int &b) {\\n\\t\\treturn abs(a) < abs(b);\\n\\t});\\n\\tint factor = 1;\\n\\twhile (maxVal / factor) {\\n\\t\\tradixCountingSort(nums, factor, low, high, isAscending);\\n\\t\\tfactor *= 10;\\n\\t}\\n}\\n\\nvoid radixSort(vector<int> &nums) {\\n\\tint nonNegMinInd = radixSortPartionArray(nums);\\n\\tif (nonNegMinInd <= 1)\\n\\t\\tradixSortHelper(nums, nonNegMinInd + 1, nums.size() - 1);\\n\\telse {\\n\\t\\tradixSortHelper(nums, 0, nonNegMinInd - 1, false);\\n\\t\\tradixSortHelper(nums, nonNegMinInd + 1, nums.size() - 1);\\n\\t}\\n}\\n```\n```\\nvoid heapifyDown(vector<int> &nums, int size, int rootInd, bool isMin=false) {\\n\\tif (size <= 1 or rootInd < 0 or rootInd >= size - 1) return;\\n\\tint keyInd = rootInd, leftChildInd = 2 * rootInd + 1, rightChildInd = 2 * rootInd + 2;\\n\\tif (leftChildInd < size and (isMin ? nums[leftChildInd] < nums[keyInd] : nums[leftChildInd] > nums[keyInd]))\\n\\t\\tkeyInd = leftChildInd;\\n\\tif (rightChildInd < size and (isMin ? nums[rightChildInd] < nums[keyInd] : nums[rightChildInd] > nums[keyInd]))\\n\\t\\tkeyInd = rightChildInd;\\n\\tif (nums[keyInd] != nums[rootInd]) {\\n\\t\\tswap(nums[rootInd], nums[keyInd]);\\n\\t\\theapifyDown(nums, size, keyInd, isMin);\\n\\t}\\n}\\n\\nvoid heapifyArray(vector<int> &nums, bool isMin=false) {\\n\\tint size = nums.size();\\n\\tif (size <= 1) return;\\n\\tint tailRootInd = (size >> 1) - 1;\\n\\tfor (int rootInd = tailRootInd; rootInd >= 0; rootInd--)\\n\\t\\theapifyDown(nums, size, rootInd, isMin);\\n}\\n\\nvoid heapSort(vector<int> &nums) {\\n\\tif (nums.size() <= 1) return;\\n\\theapifyArray(nums);\\n\\tfor (int size = nums.size() - 1; size; size--) {\\n\\t\\tswap(nums[size], nums[0]);\\n\\t\\theapifyDown(nums, size, 0);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 276916,
                "title": "python-bubble-insertion-selection-quick-merge-heap",
                "content": "in real life, we use\\n```\\n    def sortArray(self, nums):\\n        return sorted(nums)\\n```\\n\\nbut we are playing leetcode right now...\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        # self.quickSort(nums)\\n        # self.mergeSort(nums)\\n        # self.bubbleSort(nums)\\n        # self.insertionSort(nums)\\n\\t\\t# self.selectionSort(nums)\\n        self.heapSort(nums)\\n        return nums\\n    \\n\\t# @bubbleSort, TLE\\n    def bubbleSort(self, nums):\\n        n = len(nums)\\n        for i in range(n):\\n            for j in range(0, n - i - 1):\\n                if nums[j] > nums[j + 1]:\\n                    nums[j], nums[j + 1] = nums[j + 1], nums[j]\\n                    \\n\\t# @insertionSort, TLE\\n    def insertionSort(self, nums): \\n        for i in range(1, len(nums)): \\n            key = nums[i]\\n            j = i-1\\n            while j >= 0 and key < nums[j] : \\n                    nums[j + 1] = nums[j] \\n                    j -= 1\\n            nums[j + 1] = key\\n\\t\\t\\n\\t# @selectionSort, TLE\\n\\tdef selectionSort(self, nums):\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t_min = min(nums[i:])\\n\\t\\t\\tmin_index = nums[i:].index(_min)\\n\\t\\t\\tnums[i + min_index] = nums[i]\\n\\t\\t\\tnums[i] = _min\\n\\t\\treturn nums\\n    \\n\\t# @quickSort\\n    def quickSort(self, nums):\\n        def helper(head, tail):\\n            if head >= tail: return \\n            l, r = head, tail\\n            m = (r - l) // 2 + l\\n            pivot = nums[m]\\n            while r >= l:\\n                while r >= l and nums[l] < pivot: l += 1\\n                while r >= l and nums[r] > pivot: r -= 1\\n                if r >= l:\\n                    nums[l], nums[r] = nums[r], nums[l]\\n                    l += 1\\n                    r -= 1\\n            helper(head, r)\\n            helper(l, tail)\\n\\n        helper(0, len(nums)-1)\\n        return nums\\n     \\n\\t# @mergeSort\\n    def mergeSort(self, nums): \\n        if len(nums) > 1: \\n            mid = len(nums)//2\\n            L = nums[:mid] \\n            R = nums[mid:] \\n\\n            self.mergeSort(L)\\n            self.mergeSort(R)\\n\\n            i = j = k = 0\\n\\n            while i < len(L) and j < len(R): \\n                if L[i] < R[j]: \\n                    nums[k] = L[i] \\n                    i+=1\\n                else: \\n                    nums[k] = R[j] \\n                    j+=1\\n                k+=1\\n \\n            while i < len(L): \\n                nums[k] = L[i] \\n                i+=1\\n                k+=1\\n\\n            while j < len(R): \\n                nums[k] = R[j] \\n                j+=1\\n                k+=1\\n   \\n   # @heapSort\\n    def heapSort(self, nums):\\n        def heapify(nums, n, i): \\n            l = 2 * i + 1\\n            r = 2 * i + 2\\n\\t\\t\\t\\n            largest = i\\n            if l < n and nums[largest] < nums[l]: \\n                largest = l \\n\\n            if r < n and nums[largest] < nums[r]: \\n                largest = r \\n\\n            if largest != i: \\n                nums[i], nums[largest] = nums[largest], nums[i]\\n                \\n                heapify(nums, n, largest)\\n                \\n        n = len(nums) \\n\\n        for i in range(n//2+1)[::-1]: \\n            heapify(nums, n, i) \\n\\n        for i in range(n)[::-1]: \\n            nums[i], nums[0] = nums[0], nums[i]\\n            heapify(nums, i, 0) \\n```\\n\\n---\\nSort Objects:\\n\\n[Pyhon] \\n```python\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n\\n    def __cmp__(self, other):\\n        if self.val < other.val:\\n            return -1\\n        elif self.val > other.val:\\n            return 1\\n        else:\\n\\t\\t\\treturn 0\\n\\nclass Solution(object):\\n    def sortArray(self, nums):\\n        nodes = [Node(n) for n in nums]\\n        return [node.val for node in sorted(nodes)]\\n```\\n\\n[Pyhon3] notice, in python3, we don\\'t have `__cmp__(self, other)` any more\\n```python\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n\\t\\n\\t# lt means less than, le means less or equal than etc.\\n    def __lt__(self, other):\\n        return self.val < other.val\\n    # incase you need more logic\\n    # def __le__(self, other):\\n    #     return self.val <= other.val\\n    # def __eq__(self, other):\\n    #     return self.val == other.val\\n    # def __ne__(self, other):\\n    #     return self.val != other.val\\n    # def __gt__(self, other):\\n    #     return self.val > other.val\\n    # def __ge__(self, other):\\n    #     return self.val >= other.val\\n\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        nodes = [Node(n) for n in nums]\\n        return [node.val for node in sorted(nodes)]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def sortArray(self, nums):\\n        return sorted(nums)\\n```\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        # self.quickSort(nums)\\n        # self.mergeSort(nums)\\n        # self.bubbleSort(nums)\\n        # self.insertionSort(nums)\\n\\t\\t# self.selectionSort(nums)\\n        self.heapSort(nums)\\n        return nums\\n    \\n\\t# @bubbleSort, TLE\\n    def bubbleSort(self, nums):\\n        n = len(nums)\\n        for i in range(n):\\n            for j in range(0, n - i - 1):\\n                if nums[j] > nums[j + 1]:\\n                    nums[j], nums[j + 1] = nums[j + 1], nums[j]\\n                    \\n\\t# @insertionSort, TLE\\n    def insertionSort(self, nums): \\n        for i in range(1, len(nums)): \\n            key = nums[i]\\n            j = i-1\\n            while j >= 0 and key < nums[j] : \\n                    nums[j + 1] = nums[j] \\n                    j -= 1\\n            nums[j + 1] = key\\n\\t\\t\\n\\t# @selectionSort, TLE\\n\\tdef selectionSort(self, nums):\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t_min = min(nums[i:])\\n\\t\\t\\tmin_index = nums[i:].index(_min)\\n\\t\\t\\tnums[i + min_index] = nums[i]\\n\\t\\t\\tnums[i] = _min\\n\\t\\treturn nums\\n    \\n\\t# @quickSort\\n    def quickSort(self, nums):\\n        def helper(head, tail):\\n            if head >= tail: return \\n            l, r = head, tail\\n            m = (r - l) // 2 + l\\n            pivot = nums[m]\\n            while r >= l:\\n                while r >= l and nums[l] < pivot: l += 1\\n                while r >= l and nums[r] > pivot: r -= 1\\n                if r >= l:\\n                    nums[l], nums[r] = nums[r], nums[l]\\n                    l += 1\\n                    r -= 1\\n            helper(head, r)\\n            helper(l, tail)\\n\\n        helper(0, len(nums)-1)\\n        return nums\\n     \\n\\t# @mergeSort\\n    def mergeSort(self, nums): \\n        if len(nums) > 1: \\n            mid = len(nums)//2\\n            L = nums[:mid] \\n            R = nums[mid:] \\n\\n            self.mergeSort(L)\\n            self.mergeSort(R)\\n\\n            i = j = k = 0\\n\\n            while i < len(L) and j < len(R): \\n                if L[i] < R[j]: \\n                    nums[k] = L[i] \\n                    i+=1\\n                else: \\n                    nums[k] = R[j] \\n                    j+=1\\n                k+=1\\n \\n            while i < len(L): \\n                nums[k] = L[i] \\n                i+=1\\n                k+=1\\n\\n            while j < len(R): \\n                nums[k] = R[j] \\n                j+=1\\n                k+=1\\n   \\n   # @heapSort\\n    def heapSort(self, nums):\\n        def heapify(nums, n, i): \\n            l = 2 * i + 1\\n            r = 2 * i + 2\\n\\t\\t\\t\\n            largest = i\\n            if l < n and nums[largest] < nums[l]: \\n                largest = l \\n\\n            if r < n and nums[largest] < nums[r]: \\n                largest = r \\n\\n            if largest != i: \\n                nums[i], nums[largest] = nums[largest], nums[i]\\n                \\n                heapify(nums, n, largest)\\n                \\n        n = len(nums) \\n\\n        for i in range(n//2+1)[::-1]: \\n            heapify(nums, n, i) \\n\\n        for i in range(n)[::-1]: \\n            nums[i], nums[0] = nums[0], nums[i]\\n            heapify(nums, i, 0) \\n```\n```python\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n\\n    def __cmp__(self, other):\\n        if self.val < other.val:\\n            return -1\\n        elif self.val > other.val:\\n            return 1\\n        else:\\n\\t\\t\\treturn 0\\n\\nclass Solution(object):\\n    def sortArray(self, nums):\\n        nodes = [Node(n) for n in nums]\\n        return [node.val for node in sorted(nodes)]\\n```\n```python\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n\\t\\n\\t# lt means less than, le means less or equal than etc.\\n    def __lt__(self, other):\\n        return self.val < other.val\\n    # incase you need more logic\\n    # def __le__(self, other):\\n    #     return self.val <= other.val\\n    # def __eq__(self, other):\\n    #     return self.val == other.val\\n    # def __ne__(self, other):\\n    #     return self.val != other.val\\n    # def __gt__(self, other):\\n    #     return self.val > other.val\\n    # def __ge__(self, other):\\n    #     return self.val >= other.val\\n\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        nodes = [Node(n) for n in nums]\\n        return [node.val for node in sorted(nodes)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492042,
                "title": "7-sorting-algorithms-quick-sort-top-down-bottom-up-merge-sort-heap-sort-etc",
                "content": "7 Sorting Algorithms:\\n1. quick sort\\n2. top-down merge sort\\n3. bottom-up merge sort\\n4. heap sort\\n5. selection sort\\n6. insertion sort\\n7. bubble sort (TLE)\\n\\nThe implementations are as below:\\n1. quick sort\\n```java\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return res;\\n        quickSort(nums, 0, nums.length - 1);\\n        for (int i : nums) res.add(i);\\n        return res;\\n    }\\n    private void quickSort(int[] nums, int l, int r) {\\n        if (l >= r) return;\\n        int mid = partition(nums, l, r);\\n        quickSort(nums, l, mid);\\n        quickSort(nums, mid + 1, r);\\n    }\\n    private int partition(int[] nums, int l, int r) {\\n        int pivot = nums[l];\\n        while (l < r) {\\n            while (l < r && nums[r] >= pivot) r--;\\n            nums[l] = nums[r];\\n            while (l < r && nums[l] <= pivot) l++;\\n            nums[r] = nums[l];\\n        }\\n        nums[l] = pivot;\\n        return l;\\n    }\\n}\\n```\\n\\n2. top-down merge sort\\n```java\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return res;\\n        mergeSort(nums, 0, nums.length - 1);\\n        for (int i : nums) res.add(i);\\n        return res;\\n    }\\n    private void mergeSort(int[] nums, int l, int r) {\\n        if (l >= r) return;\\n        int mid = l + (r - l) / 2;\\n        mergeSort(nums, l, mid);\\n        mergeSort(nums, mid + 1, r);\\n        merge(nums, l, r);\\n    }\\n    private void merge(int[] nums, int l, int r) {\\n        int mid = l + (r - l) / 2;\\n        int[] tmp = new int[r - l + 1];\\n        int i = l, j = mid + 1, k = 0;\\n        while (i <= mid || j <= r) {\\n            if (i > mid || j <= r && nums[i] > nums[j]) {\\n                tmp[k++] = nums[j++];\\n            } else {\\n                tmp[k++] = nums[i++];\\n            }\\n        }\\n        System.arraycopy(tmp, 0, nums, l, r - l + 1);\\n    }\\n}\\n```\\n\\n3. bottom-up merge sort\\n```java\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return res;\\n        mergeSort2(nums);\\n        for (int i : nums) res.add(i);\\n        return res;\\n    }\\n    private void mergeSort2(int[] nums) {\\n        for (int size = 1; size < nums.length; size *= 2) {\\n            for (int i = 0; i < nums.length - size; i += 2 * size) {\\n                int mid = i + size - 1;\\n                int end = Math.min(i + 2 * size - 1, nums.length - 1);\\n                merge2(nums, i, mid, end);\\n            }\\n        }\\n    }\\n    private void merge2(int[] nums, int l, int mid, int r) {\\n        int[] tmp = new int[r - l + 1];\\n        int i = l, j = mid + 1, k = 0;\\n        while (i <= mid || j <= r) {\\n            if (i > mid || j <= r && nums[i] > nums[j]) {\\n                tmp[k++] = nums[j++];\\n            } else {\\n                tmp[k++] = nums[i++];\\n            }\\n        }\\n        System.arraycopy(tmp, 0, nums, l, r - l + 1);\\n    }\\n}\\n```\\n\\n4. heap sort\\n```java\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return res;\\n        heapSort(nums);\\n        for (int i : nums) res.add(i);\\n        return res;\\n    }\\n    private void heapSort(int[] nums) {\\n        for (int i = nums.length / 2 - 1; i >= 0; i--) {\\n            heapify(nums, i, nums.length - 1);\\n        }\\n        for (int i = nums.length - 1; i >= 1; i--) {\\n            swap(nums, 0, i);\\n            heapify(nums, 0, i - 1);\\n        }\\n    }\\n    private void heapify(int[] nums, int i, int end) {\\n        while (i <= end) {\\n            int l = 2 * i + 1, r = 2 * i + 2;\\n            int maxIndex = i;\\n            if (l <= end && nums[l] > nums[maxIndex]) maxIndex = l;\\n            if (r <= end && nums[r] > nums[maxIndex]) maxIndex = r;\\n            if (maxIndex == i) break;\\n            swap(nums, i, maxIndex);\\n            i = maxIndex;\\n        }\\n    }\\n    private void swap(int[] nums, int i, int j) {\\n        int tmp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = tmp;\\n    }\\n}\\n```\\n\\n5. selection sort\\n```java\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return res;\\n        selectionSort(nums);\\n        for (int i : nums) res.add(i);\\n        return res;\\n    }\\n    private void selectionSort(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            int minIndex = i;\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[j] < nums[minIndex]) minIndex = j;\\n            }\\n            if (minIndex != i) swap(nums, i, minIndex);\\n        }\\n    }\\n    private void swap(int[] nums, int i, int j) {\\n        nums[i] = nums[i] ^ nums[j];\\n        nums[j] = nums[i] ^ nums[j];\\n        nums[i] = nums[i] ^ nums[j];\\n    }\\n}\\n```\\n\\n6. insertion sort\\n```java\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return res;\\n        insertionSort(nums);\\n        for (int i : nums) res.add(i);\\n        return res;\\n    }\\n    private void insertionSort(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = i; j >= 1; j--) {\\n                if (nums[j] >= nums[j - 1]) break;\\n                swap(nums, j, j - 1);\\n            }\\n        }\\n    }\\n    private void swap(int[] nums, int i, int j) {\\n        nums[i] = nums[i] ^ nums[j];\\n        nums[j] = nums[i] ^ nums[j];\\n        nums[i] = nums[i] ^ nums[j];\\n    }\\n}\\n```\\n\\n7. bubble sort (TLE)\\n```java\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return res;\\n        bubbleSort(nums);\\n        for (int i : nums) res.add(i);\\n        return res;\\n    }\\n    private void bubbleSort(int[] nums) {\\n        for (int k = nums.length - 1; k >= 1; k--) {\\n            for (int i = 0; i < k; i++) {\\n                if (nums[i] > nums[i + 1]) swap(nums, i, i + 1);\\n            }\\n        }\\n    }\\n    private void swap(int[] nums, int i, int j) {\\n        nums[i] = nums[i] ^ nums[j];\\n        nums[j] = nums[i] ^ nums[j];\\n        nums[i] = nums[i] ^ nums[j];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```java\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return res;\\n        quickSort(nums, 0, nums.length - 1);\\n        for (int i : nums) res.add(i);\\n        return res;\\n    }\\n    private void quickSort(int[] nums, int l, int r) {\\n        if (l >= r) return;\\n        int mid = partition(nums, l, r);\\n        quickSort(nums, l, mid);\\n        quickSort(nums, mid + 1, r);\\n    }\\n    private int partition(int[] nums, int l, int r) {\\n        int pivot = nums[l];\\n        while (l < r) {\\n            while (l < r && nums[r] >= pivot) r--;\\n            nums[l] = nums[r];\\n            while (l < r && nums[l] <= pivot) l++;\\n            nums[r] = nums[l];\\n        }\\n        nums[l] = pivot;\\n        return l;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return res;\\n        mergeSort(nums, 0, nums.length - 1);\\n        for (int i : nums) res.add(i);\\n        return res;\\n    }\\n    private void mergeSort(int[] nums, int l, int r) {\\n        if (l >= r) return;\\n        int mid = l + (r - l) / 2;\\n        mergeSort(nums, l, mid);\\n        mergeSort(nums, mid + 1, r);\\n        merge(nums, l, r);\\n    }\\n    private void merge(int[] nums, int l, int r) {\\n        int mid = l + (r - l) / 2;\\n        int[] tmp = new int[r - l + 1];\\n        int i = l, j = mid + 1, k = 0;\\n        while (i <= mid || j <= r) {\\n            if (i > mid || j <= r && nums[i] > nums[j]) {\\n                tmp[k++] = nums[j++];\\n            } else {\\n                tmp[k++] = nums[i++];\\n            }\\n        }\\n        System.arraycopy(tmp, 0, nums, l, r - l + 1);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return res;\\n        mergeSort2(nums);\\n        for (int i : nums) res.add(i);\\n        return res;\\n    }\\n    private void mergeSort2(int[] nums) {\\n        for (int size = 1; size < nums.length; size *= 2) {\\n            for (int i = 0; i < nums.length - size; i += 2 * size) {\\n                int mid = i + size - 1;\\n                int end = Math.min(i + 2 * size - 1, nums.length - 1);\\n                merge2(nums, i, mid, end);\\n            }\\n        }\\n    }\\n    private void merge2(int[] nums, int l, int mid, int r) {\\n        int[] tmp = new int[r - l + 1];\\n        int i = l, j = mid + 1, k = 0;\\n        while (i <= mid || j <= r) {\\n            if (i > mid || j <= r && nums[i] > nums[j]) {\\n                tmp[k++] = nums[j++];\\n            } else {\\n                tmp[k++] = nums[i++];\\n            }\\n        }\\n        System.arraycopy(tmp, 0, nums, l, r - l + 1);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return res;\\n        heapSort(nums);\\n        for (int i : nums) res.add(i);\\n        return res;\\n    }\\n    private void heapSort(int[] nums) {\\n        for (int i = nums.length / 2 - 1; i >= 0; i--) {\\n            heapify(nums, i, nums.length - 1);\\n        }\\n        for (int i = nums.length - 1; i >= 1; i--) {\\n            swap(nums, 0, i);\\n            heapify(nums, 0, i - 1);\\n        }\\n    }\\n    private void heapify(int[] nums, int i, int end) {\\n        while (i <= end) {\\n            int l = 2 * i + 1, r = 2 * i + 2;\\n            int maxIndex = i;\\n            if (l <= end && nums[l] > nums[maxIndex]) maxIndex = l;\\n            if (r <= end && nums[r] > nums[maxIndex]) maxIndex = r;\\n            if (maxIndex == i) break;\\n            swap(nums, i, maxIndex);\\n            i = maxIndex;\\n        }\\n    }\\n    private void swap(int[] nums, int i, int j) {\\n        int tmp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = tmp;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return res;\\n        selectionSort(nums);\\n        for (int i : nums) res.add(i);\\n        return res;\\n    }\\n    private void selectionSort(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            int minIndex = i;\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[j] < nums[minIndex]) minIndex = j;\\n            }\\n            if (minIndex != i) swap(nums, i, minIndex);\\n        }\\n    }\\n    private void swap(int[] nums, int i, int j) {\\n        nums[i] = nums[i] ^ nums[j];\\n        nums[j] = nums[i] ^ nums[j];\\n        nums[i] = nums[i] ^ nums[j];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return res;\\n        insertionSort(nums);\\n        for (int i : nums) res.add(i);\\n        return res;\\n    }\\n    private void insertionSort(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = i; j >= 1; j--) {\\n                if (nums[j] >= nums[j - 1]) break;\\n                swap(nums, j, j - 1);\\n            }\\n        }\\n    }\\n    private void swap(int[] nums, int i, int j) {\\n        nums[i] = nums[i] ^ nums[j];\\n        nums[j] = nums[i] ^ nums[j];\\n        nums[i] = nums[i] ^ nums[j];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return res;\\n        bubbleSort(nums);\\n        for (int i : nums) res.add(i);\\n        return res;\\n    }\\n    private void bubbleSort(int[] nums) {\\n        for (int k = nums.length - 1; k >= 1; k--) {\\n            for (int i = 0; i < k; i++) {\\n                if (nums[i] > nums[i + 1]) swap(nums, i, i + 1);\\n            }\\n        }\\n    }\\n    private void swap(int[] nums, int i, int j) {\\n        nums[i] = nums[i] ^ nums[j];\\n        nums[j] = nums[i] ^ nums[j];\\n        nums[i] = nums[i] ^ nums[j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 277127,
                "title": "7-line-quicksort-to-write-in-interviews-python",
                "content": "This is my go-to solution when asked this question in interviews. It\\'s short, simple to write, very bug free, and looks very clean and pythonic. Writing this version of quicksort is very effective in communicating your understanding of the algorithm and its concepts to the interviewer.\\n\\nThe only tradeoff in the code is it uses a bit of extra space. You can always write the messier in-place solution as a followup.\\n```\\ndef quicksort(self, nums):\\n    if len(nums) <= 1:\\n        return nums\\n\\n    pivot = random.choice(nums)\\n    lt = [v for v in nums if v < pivot]\\n    eq = [v for v in nums if v == pivot]\\n    gt = [v for v in nums if v > pivot]\\n\\n    return self.quicksort(lt) + eq + self.quicksort(gt)\\n```\\nRuntime: O(nlogn) expected, O(n^2) worst case.\\nWith a proper choice of pivot (using the median of medians algorithm), the runtime can be reduced to strict O(nlogn).\\nSpace: O(n) expected, O(n^2) worst case",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\ndef quicksort(self, nums):\\n    if len(nums) <= 1:\\n        return nums\\n\\n    pivot = random.choice(nums)\\n    lt = [v for v in nums if v < pivot]\\n    eq = [v for v in nums if v == pivot]\\n    gt = [v for v in nums if v > pivot]\\n\\n    return self.quicksort(lt) + eq + self.quicksort(gt)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 461394,
                "title": "python-3-eight-sorting-algorithms-with-explanation",
                "content": "_Sorting Algorithms:_\\n1. Selection Sort\\n2. Bubble Sort\\n3. Insertion Sort\\n4. Binary Insertion Sort\\n5. Counting Sort\\n6. QuickSort\\n7. Merge Sort\\n8. Bucket Sort\\n____________________________________________\\n\\n1) _Selection Sort:_\\nThis program sorts the list by finding the minimum of the list, removing it from the original list, and appending it onto the output list. As it finds the minumum during each iteration, the length of the original list gets shorter by one and the length of the output list gets longer by one. This program uses the min function with a lambda function to find the index of the minimum value in the unsorted list. The output list is created using a list comprehension. This algorithm is O(n\\xB2). It is able to sort 8 out of 10 test cases but exceeds the time limit on the ninth test case.\\n\\n```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        L = len(N)\\n        return [N.pop(min(range(L-i), key = lambda x: N[x])) for i in range(L)]\\n\\t\\t\\n\\t\\t\\n```\\n2) _Bubble Sort:_\\nThis program sorts the list by looping through the original list and finding any adjacent pairs of numbers that are out of order. If it finds such a pair, it switches their locations. It continues to check for adjacent pairs that are out of order until it has completed the pass through the list. If it finds a pair, it will set B = 1 which tells the program to pass through the list again and continue switching adjacent values that are out of order. If it can make it through the list without finding any adjacent pairs that are out of order, we can conclude that the list is sorted. The value of B will stay 0 and the outer while loop will end. This algorithm is O(n\\xB2). It is able to sort 8 out of 10 test cases but exceeds the time limit on the ninth test case.\\n\\n```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        L, B = len(N), 1\\n        while B:\\n            B = 0\\n            for i in range(L-1):\\n                if N[i] > N[i+1]: N[i], N[i+1], B = N[i+1], N[i], 1\\n        return N\\n\\t\\t\\n\\t\\t\\n```\\n3) _Insertion Sort:_\\nThis program sorts the list by sequentially inserting each element into the proper location within the sorted front portion of the original list. It starts by inserting the second number into the proper location within the first two numbers. It then inserts the third number into the proper location within the first three numbers. After each iteration, the front portion of the list (i.e. the sorted portion) will grow in length by 1. A number is removed from the back portion of the list (i.e. the unsorted portion) and placed into the appropriate location in the sorted portion of the list. Once we place the last number into the correct location within the sorted numbers, the entire list will have become sorted. This algorithm is O(n\\xB2). It is able to sort 9 out of 10 test cases but exceeds the time limit on the last test case.\\n\\n```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        L = len(N)\\n        for i in range(1,L):\\n            for j in range(0,i):\\n                if N[i] < N[j]:\\n                    N.insert(j, N.pop(i))\\n                    break\\n        return N\\t\\t\\n\\t\\t\\n\\t\\t\\n```\\n4) _Binary Insertion Sort:_ (944 ms) (beats ~6%)\\nThis program sorts the list by sequentially inserting each element into the proper location within the sorted front portion of the original list. It starts by inserting the second number into the proper location within the first two numbers. It then inserts the third number into the proper location within the first three numbers. After each iteration, the front portion of the list (i.e. the sorted portion) will grow in length by 1. A number is removed from the back portion of the list (i.e. the unsorted portion) and placed into the appropriate location in the sorted portion of the list. Once we place the last number into the correct location within the sorted numbers, the entire list will have become sorted. This algorithm is still O(n\\xB2). It is not O(n log n) despite using a binary search because the insertion step is time consuming. The advantage of the binary insertion sort versus the generic insertion sort is that this one does a binary search which is O(log i) (for the ith iteration) while the generic one does a linear search which is O(i) (for the ith iteration). Because of this improvement, this program is able to sort all 10 cases although it is not a very fast approach compared to some of the other algorithms.\\n```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        L = len(N)\\n        for i in range(1,L): bisect.insort_left(N, N.pop(i), 0, i)\\n        return N\\n\\t\\t\\n\\t\\t\\n```\\n5) _Counting Sort:_ (136 ms) (beats ~97%)\\nThis program starts by creating a dictionary of key-value pairs that records the total count of each element of the original list. The minimum and maximum value of the list is also found. The program then loops through every integer between the min and max value (in order) and appends that number to the output list based on its count within the original list. For example, if the number 3 occurs 4 times in the original list, then the output list will be extended by [3,3,3,3]. The output will be the sorted form of the original list as it consists of an ordered list of the numbers in the original list. This approach is a linear time sorting algorithm that sorts in O(n+k) time, where n is the number of elements and k is the statistical range of the dataset (i.e. max(N) - min(N)). It is able to sort all test cases in only 136 ms.\\n\\n```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        C, m, M, S = collections.Counter(N), min(N), max(N), []\\n        for n in range(m,M+1): S.extend([n]*C[n])\\n        return S\\n\\t\\t\\n\\t\\t\\n```\\n6) _QuickSort:_ (316 ms) (beats ~54%)\\nThis program uses a recursive Divide and Conquer approach to sort the original list. The recursive function ```quicksort``` is called on the original list. A ```partition``` subroutine then takes the input and pivots around the median position\\'s value (pivot value). Specifically, it uses swaps to place numbers less than the pivot value to the left of the pivot index and numbers greater than the pivot value to the right of the pivot index. At the end of the ```partition``` subroutine, we are left with the situation that the value at the pivot index is located at what will be its final position in the sorted output. We then do a quicksort on these left and right halves and continue this rescursively until we get a list of length 1 which is already sorted. Once all of the quicksort subroutines are completed, the entire list is in sorted order and the initial quicksort call completes and we can return the sorted list. In the average case, this method is O(n log n). In the worst case, however, it is O(n\\xB2). It is able to sort all test cases in 316 ms.\\n\\n```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        def quicksort(A, I, J):\\n            if J - I <= 1: return\\n            p = partition(A, I, J)\\n            quicksort(A, I, p), quicksort(A, p + 1, J)\\n        \\n        def partition(A, I, J):\\n            A[J-1], A[(I + J - 1)//2], i = A[(I + J - 1)//2], A[J-1], I\\n            for j in range(I,J):\\n                if A[j] < A[J-1]: A[i], A[j], i = A[j], A[i], i + 1\\n            A[J-1], A[i] = A[i], A[J-1]\\n            return i\\n        \\n        quicksort(N,0,len(N))\\n        return N\\n\\t\\t\\n\\t\\t\\n```\\n7) _Merge Sort:_ (324 ms) (beats ~51%)\\nThis program uses a recursive Divide and Conquer approach to sort the original list. The recursive function ```mergesort``` is called on the original list. The function divides the list into two halves (a left half and a right half) and calls the mergesort routine recursively on each of them. Once each half is sorted, the ```merge``` subroutine merges the two lists into one list by appending the lower number from the front of each half into the output list S. If one list is exhausted before the other, the remaining list is appended onto S before S is returned. The ```mergesort``` function recursively calls on lists that are half the size of the previous list until their length is 1. Such a list is trivially sorted and that list can be returned for ```merge``` to join with another list. Eventually all the small lists are merged back into larger lists until the final sorted version of the original list is formed. This method is O(n log n). It is able to sort all test cases in 324 ms.\\n\\n```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        def mergesort(A):\\n            LA = len(A)\\n            if LA == 1: return A\\n            LH, RH = mergesort(A[:LA//2]), mergesort(A[LA//2:])\\n            return merge(LH,RH)\\n\\n        def merge(LH, RH):\\n            LLH, LRH = len(LH), len(RH)\\n            S, i, j = [], 0, 0\\n            while i < LLH and j < LRH:\\n                if LH[i] <= RH[j]: i, _ = i + 1, S.append(LH[i])\\n                else: j, _ = j + 1, S.append(RH[j])\\n            return S + (RH[j:] if i == LLH else LH[i:])\\n        \\n        return mergesort(N)\\t\\t\\n\\t\\t\\n\\t\\t\\n```\\n8) _Bucket Sort:_ (196 ms) (beats ~78%)\\nThis program sorts the original list by dividing the numbers in the list into 1000 non-overlapping adjacent buckets. The ```bucketsort``` function finds the statistical range of the numbers in the original list (i.e. R = max(N) - min(N)) to help map each number into the appropriate bucket. The ```insertion_sort``` subroutine is then used to sort the numbers in each of these buckets. The sorted adjacent buckets are then appended onto the output list S which is the sorted version of the original list. This method is O(n\\xB2) in the worst case and O(n) on average. The large number of buckets (1000 buckets) was chosen to decrease the time needed to sort the final test case. If too few buckets are used, the time limit gets exceeded for the final test case. It is able to sort all test cases in 196 s.\\n\\n```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        def insertion_sort(A):\\n            for i in range(1,len(A)):\\n                for j in range(0,i):\\n                    if A[i] < A[j]:\\n                        A.insert(j, A.pop(i))\\n                        break\\n            return A\\n        \\n        def bucketsort(A):\\n            buckets, m, S = [[] for _ in range(1000)], min(A), []\\n            R = max(A) - m\\n            if R == 0: return A\\n            for a in A: buckets[999*(a-m)//R]\\n            for b in buckets: S.extend(insertion_sort(b))\\n            return S\\n    \\n        return bucketsort(N)\\n        \\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        L = len(N)\\n        return [N.pop(min(range(L-i), key = lambda x: N[x])) for i in range(L)]\\n\\t\\t\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        L, B = len(N), 1\\n        while B:\\n            B = 0\\n            for i in range(L-1):\\n                if N[i] > N[i+1]: N[i], N[i+1], B = N[i+1], N[i], 1\\n        return N\\n\\t\\t\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        L = len(N)\\n        for i in range(1,L):\\n            for j in range(0,i):\\n                if N[i] < N[j]:\\n                    N.insert(j, N.pop(i))\\n                    break\\n        return N\\t\\t\\n\\t\\t\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        L = len(N)\\n        for i in range(1,L): bisect.insort_left(N, N.pop(i), 0, i)\\n        return N\\n\\t\\t\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        C, m, M, S = collections.Counter(N), min(N), max(N), []\\n        for n in range(m,M+1): S.extend([n]*C[n])\\n        return S\\n\\t\\t\\n\\t\\t\\n```\n```quicksort```\n```partition```\n```partition```\n```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        def quicksort(A, I, J):\\n            if J - I <= 1: return\\n            p = partition(A, I, J)\\n            quicksort(A, I, p), quicksort(A, p + 1, J)\\n        \\n        def partition(A, I, J):\\n            A[J-1], A[(I + J - 1)//2], i = A[(I + J - 1)//2], A[J-1], I\\n            for j in range(I,J):\\n                if A[j] < A[J-1]: A[i], A[j], i = A[j], A[i], i + 1\\n            A[J-1], A[i] = A[i], A[J-1]\\n            return i\\n        \\n        quicksort(N,0,len(N))\\n        return N\\n\\t\\t\\n\\t\\t\\n```\n```mergesort```\n```merge```\n```mergesort```\n```merge```\n```\\nclass Solution:\\n    def sortArray(self, N: List[int]) -> List[int]:\\n        def mergesort(A):\\n            LA = len(A)\\n            if LA == 1: return A\\n            LH, RH = mergesort(A[:LA//2]), mergesort(A[LA//2:])\\n            return merge(LH,RH)\\n\\n        def merge(LH, RH):\\n            LLH, LRH = len(LH), len(RH)\\n            S, i, j = [], 0, 0\\n            while i < LLH and j < LRH:\\n                if LH[i] <= RH[j]: i, _ = i + 1, S.append(LH[i])\\n                else: j, _ = j + 1, S.append(RH[j])\\n            return S + (RH[j:] if i == LLH else LH[i:])\\n        \\n        return mergesort(N)\\t\\t\\n\\t\\t\\n\\t\\t\\n```\n```bucketsort```\n```insertion_sort```",
                "codeTag": "Java"
            },
            {
                "id": 3241753,
                "title": "java-merge-sort-easy",
                "content": "**Merge Sort Time Complexity -> Best :- O(N log N)\\tAverage :- O(N log N)\\tWorst :- O(N log N)\\t\\nSpace Complexity :- O(N)\\nStable and not in-place\\nExplanation :- [Link](https://youtu.be/ogjf7ORKfd8)**\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        mergeSort(nums,0,nums.length-1);\\n        return nums;\\n    }\\n    public static void mergeFun(int[] arr, int l, int m, int r) {\\n        int n1 = m + 1 - l;\\n        int n2 = r - m;\\n        int[] left = new int[n1];\\n        for (int i = 0; i < n1; i++) {\\n            left[i] = arr[l + i];\\n        }\\n        int[] right = new int[n2];\\n        for (int i = 0; i < n2; i++) {\\n            right[i] = arr[m + 1 + i];\\n        }\\n        int i = 0, j = 0, k = l;\\n        while (i < n1 || j < n2) {\\n            if (j == n2 || i < n1 && left[i] < right[j])\\n                arr[k++] = left[i++];\\n            else\\n                arr[k++] = right[j++];\\n        }\\n    }\\n\\n    public static void mergeSort(int[] arr, int low, int high) {\\n        if (low < high) {\\n            int middle = (high - low) / 2 + low;\\n            mergeSort(arr, low, middle);\\n            mergeSort(arr, middle + 1, high);\\n            mergeFun(arr, low, middle, high);\\n        }\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/c663feb7-65b9-4d58-9ce4-1168250b9e99_1677630567.3774197.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        mergeSort(nums,0,nums.length-1);\\n        return nums;\\n    }\\n    public static void mergeFun(int[] arr, int l, int m, int r) {\\n        int n1 = m + 1 - l;\\n        int n2 = r - m;\\n        int[] left = new int[n1];\\n        for (int i = 0; i < n1; i++) {\\n            left[i] = arr[l + i];\\n        }\\n        int[] right = new int[n2];\\n        for (int i = 0; i < n2; i++) {\\n            right[i] = arr[m + 1 + i];\\n        }\\n        int i = 0, j = 0, k = l;\\n        while (i < n1 || j < n2) {\\n            if (j == n2 || i < n1 && left[i] < right[j])\\n                arr[k++] = left[i++];\\n            else\\n                arr[k++] = right[j++];\\n        }\\n    }\\n\\n    public static void mergeSort(int[] arr, int low, int high) {\\n        if (low < high) {\\n            int middle = (high - low) / 2 + low;\\n            mergeSort(arr, low, middle);\\n            mergeSort(arr, middle + 1, high);\\n            mergeFun(arr, low, middle, high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448903,
                "title": "c-merge-insertion-bubble-quick-heap",
                "content": "Bubble sort\\n```\\n\\t// bubbleSort(nums);\\n\\tvoid bubbleSort(vector<int>& nums){\\n        for(int i = nums.size() - 1; i >= 0; i--)\\n            for(int j = 0; j < i; j++)\\n                if(nums[j] > nums[j + 1]) \\n                    swap(nums[j], nums[j + 1]);\\n    }\\n```\\n\\n*********************************************************\\n\\nInsertion sort\\n```\\n\\t// insertionSort(nums);\\n\\tvoid insertionSort(vector<int>& nums){\\n        if(nums.size() == 0 || nums.size() == 1) return;\\n        for(int i = 1; i < nums.size(); i++){\\n            int tmp = nums[i];\\n            int j = i - 1;\\n            while(j >= 0 && nums[j] > tmp){\\n                nums[j + 1] = nums[j];\\n                j--;\\n            }\\n            nums[j + 1] = tmp;\\n        }\\n    }\\n```\\n*********************************************************\\n\\nHeap sort\\n\\nIn terms of `heapify` stage:\\n* Bottom up approach (beginning from bottom + sift down) `O(n)`\\n* Top down approach (beginning from top + sift up) `O(nlogn)`\\n* Beginning from top + sift down `not working` \\n\\nIn fact, \"sift down\" of a certain node `x` works properly only if both of its left subtree and right subtree (if any) already satisfy the heap property.\\n\\n\\nFor zero-based arrays, for a certain node `x`:\\n* its parent `floor( (x - 1) / 2 )`\\n* its left child `2x + 1`\\n* its right child `2x + 2`\\n\\nThe index of the last non-leaf node of a `n`-sized heap is `floor( n / 2 ) - 1`.\\n```\\n\\tvoid siftDown(vector<int>& nums, int n, int i){\\n        int biggest = i;\\n        int l = 2 * i + 1;\\n        int r = 2 * i + 2;\\n        if(l < n && nums[biggest] < nums[l])\\n            biggest = l;\\n        if(r < n && nums[biggest] < nums[r])\\n            biggest = r;\\n        if(biggest != i){\\n            swap(nums[i], nums[biggest]);\\n            siftDown(nums, n, biggest);\\n        }\\n    }\\n    \\n\\t// heapSort(nums);\\n    void heapSort(vector<int>& nums){\\n        // heapify stage (bottom up approach)\\n        for(int i = nums.size() / 2 - 1; i >= 0; i--)\\n            siftDown(nums, nums.size(), i);\\n        // sorting stage\\n        for(int i = nums.size() - 1; i > 0; i--){\\n            swap(nums[0], nums[i]);\\n            siftDown(nums, i, 0);\\n        }\\n    }\\n```\\n\\n*********************************************************\\nMerge sort (recursive version)\\n```\\n\\tvoid merge(vector<int>& nums, int l, int m, int r){\\n        vector<int> tmp(r - l + 1);\\n        int i = l; // index for left subarray\\n        int j = m + 1; // index for right subarray\\n        int k = 0; // index for temporary array\\n        while(i <= m && j <= r){\\n            if(nums[i] <= nums[j]) tmp[k++] = nums[i++]; \\n            else tmp[k++] = nums[j++];\\n        }\\n        while(i <= m) tmp[k++] = nums[i++];\\n        while(j <= r) tmp[k++] = nums[j++]; \\n        for(i = 0; i < k; i++) nums[l + i] = tmp[i];\\n    }\\n\\t\\n\\t// mergeSort(nums, 0, nums.size() - 1);\\n    void mergeSort(vector<int>& nums, int l, int r){\\n        if(l >= r) return;\\n        int m = l + (r - l) / 2; //middle index, same as (l+r)/2\\n        mergeSort(nums, l, m);\\n        mergeSort(nums, m + 1, r);\\n        merge(nums, l, m, r);\\n    }\\n```\\n\\n*********************************************************\\nQuick sort (recursive version)\\n```\\n\\t// quickSort(nums, 0, nums.size() - 1);\\n    void quickSort(vector<int>& nums, int l, int r){\\n        if(l >= r) return;\\n        int i = l; // cursor for final pivot location \\n        for(int j = l; j <= r - 1; j++){ // nums[r] is chosen as the pivot\\n            if(nums[j] <= nums[r]){\\n                swap(nums[i], nums[j]);\\n                i++; // smaller or equal elements go to the left of i \\n            }\\n        }\\n        swap(nums[i], nums[r]); // after swap, the pivot is nums[i]\\n        quickSort(nums, l, i - 1);\\n        quickSort(nums, i + 1, r);\\n    }\\n```\\n\\n\\n*********************************************************\\nThe utility function `swap` is defined as follows\\n```\\n\\tvoid swap(int& a, int& b){\\n        int tmp = a;\\n        a = b;\\n        b = tmp;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```\\n\\t// bubbleSort(nums);\\n\\tvoid bubbleSort(vector<int>& nums){\\n        for(int i = nums.size() - 1; i >= 0; i--)\\n            for(int j = 0; j < i; j++)\\n                if(nums[j] > nums[j + 1]) \\n                    swap(nums[j], nums[j + 1]);\\n    }\\n```\n```\\n\\t// insertionSort(nums);\\n\\tvoid insertionSort(vector<int>& nums){\\n        if(nums.size() == 0 || nums.size() == 1) return;\\n        for(int i = 1; i < nums.size(); i++){\\n            int tmp = nums[i];\\n            int j = i - 1;\\n            while(j >= 0 && nums[j] > tmp){\\n                nums[j + 1] = nums[j];\\n                j--;\\n            }\\n            nums[j + 1] = tmp;\\n        }\\n    }\\n```\n```\\n\\tvoid siftDown(vector<int>& nums, int n, int i){\\n        int biggest = i;\\n        int l = 2 * i + 1;\\n        int r = 2 * i + 2;\\n        if(l < n && nums[biggest] < nums[l])\\n            biggest = l;\\n        if(r < n && nums[biggest] < nums[r])\\n            biggest = r;\\n        if(biggest != i){\\n            swap(nums[i], nums[biggest]);\\n            siftDown(nums, n, biggest);\\n        }\\n    }\\n    \\n\\t// heapSort(nums);\\n    void heapSort(vector<int>& nums){\\n        // heapify stage (bottom up approach)\\n        for(int i = nums.size() / 2 - 1; i >= 0; i--)\\n            siftDown(nums, nums.size(), i);\\n        // sorting stage\\n        for(int i = nums.size() - 1; i > 0; i--){\\n            swap(nums[0], nums[i]);\\n            siftDown(nums, i, 0);\\n        }\\n    }\\n```\n```\\n\\tvoid merge(vector<int>& nums, int l, int m, int r){\\n        vector<int> tmp(r - l + 1);\\n        int i = l; // index for left subarray\\n        int j = m + 1; // index for right subarray\\n        int k = 0; // index for temporary array\\n        while(i <= m && j <= r){\\n            if(nums[i] <= nums[j]) tmp[k++] = nums[i++]; \\n            else tmp[k++] = nums[j++];\\n        }\\n        while(i <= m) tmp[k++] = nums[i++];\\n        while(j <= r) tmp[k++] = nums[j++]; \\n        for(i = 0; i < k; i++) nums[l + i] = tmp[i];\\n    }\\n\\t\\n\\t// mergeSort(nums, 0, nums.size() - 1);\\n    void mergeSort(vector<int>& nums, int l, int r){\\n        if(l >= r) return;\\n        int m = l + (r - l) / 2; //middle index, same as (l+r)/2\\n        mergeSort(nums, l, m);\\n        mergeSort(nums, m + 1, r);\\n        merge(nums, l, m, r);\\n    }\\n```\n```\\n\\t// quickSort(nums, 0, nums.size() - 1);\\n    void quickSort(vector<int>& nums, int l, int r){\\n        if(l >= r) return;\\n        int i = l; // cursor for final pivot location \\n        for(int j = l; j <= r - 1; j++){ // nums[r] is chosen as the pivot\\n            if(nums[j] <= nums[r]){\\n                swap(nums[i], nums[j]);\\n                i++; // smaller or equal elements go to the left of i \\n            }\\n        }\\n        swap(nums[i], nums[r]); // after swap, the pivot is nums[i]\\n        quickSort(nums, l, i - 1);\\n        quickSort(nums, i + 1, r);\\n    }\\n```\n```\\n\\tvoid swap(int& a, int& b){\\n        int tmp = a;\\n        a = b;\\n        b = tmp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3241851,
                "title": "simplest-solution-3-approaches-heap-sort-merge-sort-priority-queue-c",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Heap Sort**\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    void maxHeapify(vector<int>& nums, int n, int i){\\n        int largest = i;\\n        int left = (2 * i) + 1, right = (2 * i) + 2;\\n        if(left < n && nums[left] > nums[largest])\\n            largest = left;\\n        if(right < n && nums[right] > nums[largest])\\n            largest = right;\\n        if(largest != i){\\n            swap(nums[largest], nums[i]);\\n            maxHeapify(nums, n, largest);\\n        }\\n    }\\n\\n    void heapSort(vector<int>& nums, int n){\\n        for(int i = n/2-1; i >= 0; i--)\\n            maxHeapify(nums, n, i);\\n        for(int i = n-1; i >= 0; i--){\\n            swap(nums[0], nums[i]);\\n            maxHeapify(nums, i, 0);\\n        }\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        heapSort(nums, nums.size());\\n        return nums;\\n    }\\n};\\n```\\n\\n**Merge Sort**\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\npublic:\\n    void merge(int low, int mid, int high, vector<int> &nums) {\\n        if (low >= high) return;\\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\\n        vector<int> sorted(size, 0);\\n        while (l <= mid and r <= high)\\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\\n        while (l <= mid) \\n            sorted[k++] = nums[l++];\\n        while (r <= high) \\n            sorted[k++] = nums[r++];\\n        for (k = 0; k < size; k++)\\n            nums[k + low] = sorted[k];\\n    }\\n\\n    void mergeSort(vector<int>& nums, int start, int end){\\n        if(start < end){\\n            int mid = start + (end - start) / 2;\\n            mergeSort(nums, start, mid);\\n            mergeSort(nums, mid + 1, end);\\n            merge(start, mid, end, nums);\\n        }\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n};\\n```\\n**Priority Queue**\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i : nums)\\n            pq.push(i);\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] = pq.top();\\n            pq.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```\\n```\\n                       `Give a \\uD83D\\uDC4D. It motivates me alot`\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```\\nclass Solution {\\npublic:\\n    void maxHeapify(vector<int>& nums, int n, int i){\\n        int largest = i;\\n        int left = (2 * i) + 1, right = (2 * i) + 2;\\n        if(left < n && nums[left] > nums[largest])\\n            largest = left;\\n        if(right < n && nums[right] > nums[largest])\\n            largest = right;\\n        if(largest != i){\\n            swap(nums[largest], nums[i]);\\n            maxHeapify(nums, n, largest);\\n        }\\n    }\\n\\n    void heapSort(vector<int>& nums, int n){\\n        for(int i = n/2-1; i >= 0; i--)\\n            maxHeapify(nums, n, i);\\n        for(int i = n-1; i >= 0; i--){\\n            swap(nums[0], nums[i]);\\n            maxHeapify(nums, i, 0);\\n        }\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        heapSort(nums, nums.size());\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void merge(int low, int mid, int high, vector<int> &nums) {\\n        if (low >= high) return;\\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\\n        vector<int> sorted(size, 0);\\n        while (l <= mid and r <= high)\\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\\n        while (l <= mid) \\n            sorted[k++] = nums[l++];\\n        while (r <= high) \\n            sorted[k++] = nums[r++];\\n        for (k = 0; k < size; k++)\\n            nums[k + low] = sorted[k];\\n    }\\n\\n    void mergeSort(vector<int>& nums, int start, int end){\\n        if(start < end){\\n            int mid = start + (end - start) / 2;\\n            mergeSort(nums, start, mid);\\n            mergeSort(nums, mid + 1, end);\\n            merge(start, mid, end, nums);\\n        }\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i : nums)\\n            pq.push(i);\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] = pq.top();\\n            pq.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\n                       `Give a \\uD83D\\uDC4D. It motivates me alot`\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329672,
                "title": "merge-sort",
                "content": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        int N = nums.length;\\n        mergeSort(nums, 0, N-1);\\n        return nums;\\n    }\\n    \\n    \\n    void mergeSort(int[] nums, int start, int end){\\n        if (end - start+1 <= 1) return; //Already sorted.\\n        int mi = start + (end - start)/ 2;\\n        mergeSort(nums, start, mi);\\n        mergeSort(nums, mi+1, end);\\n        merge(nums, start,mi, end);\\n    }\\n    \\n    void merge(int[] nums, int start, int mi, int end){\\n        int lp = start;\\n        int rp = mi + 1;\\n        int[] buffer = new int[end-start+1];\\n        int t = 0; //buffer pointer\\n        \\n        while (lp <= mi && rp <= end){\\n            if (nums[lp] < nums[rp]){\\n                buffer[t++] = nums[lp++];\\n            }else{\\n                buffer[t++] = nums[rp++];\\n            }\\n        }\\n        \\n        while (lp <= mi) buffer[t++] = nums[lp++];\\n        while (rp <= end) buffer[t++] = nums[rp++];\\n        //Now copy sorted buffer into original array\\n        for (int i = start; i <= end; i++){\\n            nums[i] = buffer[i-start];\\n        }\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        int N = nums.length;\\n        mergeSort(nums, 0, N-1);\\n        return nums;\\n    }\\n    \\n    \\n    void mergeSort(int[] nums, int start, int end){\\n        if (end - start+1 <= 1) return; //Already sorted.\\n        int mi = start + (end - start)/ 2;\\n        mergeSort(nums, start, mi);\\n        mergeSort(nums, mi+1, end);\\n        merge(nums, start,mi, end);\\n    }\\n    \\n    void merge(int[] nums, int start, int mi, int end){\\n        int lp = start;\\n        int rp = mi + 1;\\n        int[] buffer = new int[end-start+1];\\n        int t = 0; //buffer pointer\\n        \\n        while (lp <= mi && rp <= end){\\n            if (nums[lp] < nums[rp]){\\n                buffer[t++] = nums[lp++];\\n            }else{\\n                buffer[t++] = nums[rp++];\\n            }\\n        }\\n        \\n        while (lp <= mi) buffer[t++] = nums[lp++];\\n        while (rp <= end) buffer[t++] = nums[rp++];\\n        //Now copy sorted buffer into original array\\n        for (int i = start; i <= end; i++){\\n            nums[i] = buffer[i-start];\\n        }\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849077,
                "title": "912-sort-an-array-sorting-algorithms",
                "content": "**Few Sorting Algorithms**:\\n1. Selection Sort \\n1. Bubble Sort\\n1. Insertion Sort\\n1. QuickSort\\n1. Merge Sort\\n\\n**Selection Sort - O(n^2)**\\n\\n```\\nvar selectionSort = function(nums) {\\n    var n = nums.length;\\n    for (var i = 0; i <n-1; i++) {\\n        var min = i;\\n        for (var j = i+1; j < n; j++ ) {\\n            if (nums[j] < nums[min]) {\\n                min = j;    \\n            }\\n        }\\n        var temp = nums[i];\\n        nums[i] = nums[min];\\n        nums[min] = temp;\\n    }\\n    return nums;\\n}\\n```\\n**Bubble Sort** -  **Best Case : O (n)**, **Average Case : O (n^2)**,**Worst Case : O (n^ 2)**\\n```\\nvar bubbleSort = function(nums) {\\n    for (var k = nums.length - 1; k >= 1; k--) {\\n            for (var i = 0; i < k; i++) {\\n                if (nums[i] > nums[i + 1]) {\\n                    swap(i, i + 1);\\n                } \\n            }\\n        }\\n    function swap(i,j) {\\n        var temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    return nums;\\n}\\n```\\n**Insertion Sort**-**Best Case : O (n)**, **Average Case : O (n^2)**,**Worst Case : O (n^ 2)**\\n\\n```\\nvar insertionSort = function(nums) {\\n    for (var i = 1; i < nums.length; i++) {\\n        var value = nums[i];\\n        var hole = i;\\n        while(hole > 0 && nums[hole-1] > value) {\\n            nums[hole] = nums[hole-1];\\n            hole = hole-1\\n        }\\n         nums[hole] = value;\\n    }\\n    return nums;\\n}\\n```\\n\\n**Merge Sort** -  **Best Case : O(n log n)**, **Average Case :O(n log n)**, **Worst Case : O(n log n)**\\n\\n```\\nvar mergeSort = function(nums) {\\n    if (nums.length < 2) return nums;\\n    var mid   = Math.floor(nums.length/2);\\n    var left  = nums.slice(0,mid);\\n    var right = nums.slice(mid);\\n    \\n    function merge(left,right) {\\n        var result = [],lLen = left.length, rLen = right.length, l = 0, r = 0;\\n        while(l < lLen && r < rLen){\\n            if(left[l] < right[r]){\\n                result.push(left[l++]);\\n            }\\n            else{\\n                result.push(right[r++]);\\n            }\\n        }  \\n        return result.concat(left.slice(l)).concat(right.slice(r));\\n    }\\n\\n   return merge(mergeSort(left),mergeSort(right));\\n}\\n```\\n\\n**Quick Sort** -  **Best Case : O(n log n)**, **Average Case :O(n log n)**, **Worst Case : O(n^2)**\\n```\\nvar quickSort = function(nums) {\\n    \\n    function quickSortHelper(nums, start, end) {\\n        if (start >= end) return nums\\n    \\n        var pivotValue = nums[start]\\n        var smaller = start\\n        for (var i = start + 1; i <= end; i++) {\\n            var bigger = i\\n            if (nums[bigger] < pivotValue) {\\n                smaller++\\n                var smallerValue = nums[bigger]\\n                nums[bigger] = nums[smaller]\\n                nums[smaller] = smallerValue\\n            }\\n        }\\n        var smallerCache = nums[smaller]\\n        nums[smaller] = nums[start]\\n        nums[start] = smallerCache\\n        \\n        quickSortHelper(nums, start, smaller - 1)\\n        quickSortHelper(nums, smaller + 1, end)\\n        return nums\\n    }\\n    \\n    return quickSortHelper(nums, 0, nums.length - 1)\\n};\\n```\\n\\nBut we use real time\\n```\\nvar sortArray = function(nums) {\\n    return nums.sort((a,b)=>a-b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar selectionSort = function(nums) {\\n    var n = nums.length;\\n    for (var i = 0; i <n-1; i++) {\\n        var min = i;\\n        for (var j = i+1; j < n; j++ ) {\\n            if (nums[j] < nums[min]) {\\n                min = j;    \\n            }\\n        }\\n        var temp = nums[i];\\n        nums[i] = nums[min];\\n        nums[min] = temp;\\n    }\\n    return nums;\\n}\\n```\n```\\nvar bubbleSort = function(nums) {\\n    for (var k = nums.length - 1; k >= 1; k--) {\\n            for (var i = 0; i < k; i++) {\\n                if (nums[i] > nums[i + 1]) {\\n                    swap(i, i + 1);\\n                } \\n            }\\n        }\\n    function swap(i,j) {\\n        var temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    return nums;\\n}\\n```\n```\\nvar insertionSort = function(nums) {\\n    for (var i = 1; i < nums.length; i++) {\\n        var value = nums[i];\\n        var hole = i;\\n        while(hole > 0 && nums[hole-1] > value) {\\n            nums[hole] = nums[hole-1];\\n            hole = hole-1\\n        }\\n         nums[hole] = value;\\n    }\\n    return nums;\\n}\\n```\n```\\nvar mergeSort = function(nums) {\\n    if (nums.length < 2) return nums;\\n    var mid   = Math.floor(nums.length/2);\\n    var left  = nums.slice(0,mid);\\n    var right = nums.slice(mid);\\n    \\n    function merge(left,right) {\\n        var result = [],lLen = left.length, rLen = right.length, l = 0, r = 0;\\n        while(l < lLen && r < rLen){\\n            if(left[l] < right[r]){\\n                result.push(left[l++]);\\n            }\\n            else{\\n                result.push(right[r++]);\\n            }\\n        }  \\n        return result.concat(left.slice(l)).concat(right.slice(r));\\n    }\\n\\n   return merge(mergeSort(left),mergeSort(right));\\n}\\n```\n```\\nvar quickSort = function(nums) {\\n    \\n    function quickSortHelper(nums, start, end) {\\n        if (start >= end) return nums\\n    \\n        var pivotValue = nums[start]\\n        var smaller = start\\n        for (var i = start + 1; i <= end; i++) {\\n            var bigger = i\\n            if (nums[bigger] < pivotValue) {\\n                smaller++\\n                var smallerValue = nums[bigger]\\n                nums[bigger] = nums[smaller]\\n                nums[smaller] = smallerValue\\n            }\\n        }\\n        var smallerCache = nums[smaller]\\n        nums[smaller] = nums[start]\\n        nums[start] = smallerCache\\n        \\n        quickSortHelper(nums, start, smaller - 1)\\n        quickSortHelper(nums, smaller + 1, end)\\n        return nums\\n    }\\n    \\n    return quickSortHelper(nums, 0, nums.length - 1)\\n};\\n```\n```\\nvar sortArray = function(nums) {\\n    return nums.sort((a,b)=>a-b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 276463,
                "title": "java-quicksort-selectionsort-mergesort-summary",
                "content": "https://leetcode.com/submissions/detail/222979198/\\n```\\nclass Solution {\\n    \\n    private static final int QUICKSORTSHOLD = 50;\\n    private static final int MERGESORTSHOLD = 300;\\n    \\n    public int[] sortArray(int[] nums) {\\n        if (nums == null || nums.length < 2){\\n            return nums;\\n        }\\n        \\n        if (nums.length < QUICKSORTSHOLD){\\n            selectionSort(nums);   \\n        }else if (nums.length < MERGESORTSHOLD) {\\n            quickSort(nums);\\n        }else{\\n            mergeSort(nums);\\n        }\\n        return nums;\\n    }\\n    \\n    private void selectionSort(int[] nums){\\n        for (int i = 0; i < nums.length; i++){\\n            int minIndex = i;\\n            for (int j = i + 1; j < nums.length; j++){\\n                if (nums[j] < nums[minIndex]){\\n                    minIndex = j;\\n                }\\n            }\\n            exch(nums, i, minIndex);\\n        }\\n    }\\n    \\n    private void quickSort(int[] nums){\\n        quickSort(nums, 0, nums.length - 1);\\n    }\\n    \\n    private void quickSort(int[] nums, int lo, int hi){\\n        if (lo >= hi)\\n            return ;\\n        int pivot = partition(nums, lo, hi);\\n        quickSort(nums, lo, pivot - 1);\\n        quickSort(nums, pivot + 1, hi);\\n    }\\n    \\n    private int partition(int[] nums, int lo, int hi){\\n        int q = lo + (int)(Math.random() * (hi - lo + 1));\\n        exch(nums, lo, q);\\n        \\n        int index = lo + 1;\\n        for (int i = lo + 1; i <= hi; i++){\\n                if (nums[i] < nums[lo]){\\n                    exch(nums, i, index++);\\n                }\\n        }\\n        exch (nums, lo, --index);\\n        return index;\\n    }\\n    \\n    private void mergeSort(int[] nums){\\n        mergeSort(nums, 0, nums.length - 1);\\n    }\\n    \\n    private void mergeSort(int[] nums, int lo, int hi){\\n        if (lo >= hi)\\n            return ;\\n        int mid = (lo + hi) >>> 1;\\n        mergeSort(nums, lo, mid);\\n        mergeSort(nums, mid + 1, hi);\\n        merge(nums, lo, mid, mid + 1, hi);\\n    }\\n    \\n    private void merge(int[] nums, int preLo, int preHi, int endLo, int endHi){\\n        if (preLo == endHi)\\n            return;\\n        int lo = preLo;\\n        int hi = endHi;\\n        \\n        int[] newArr = new int[preHi - preLo + 1 + endHi - endLo + 1];\\n        int index = 0;\\n        while (preLo <= preHi && endLo <= endHi){\\n            newArr[index++] = (nums[preLo] < nums[endLo]) ? nums[preLo++] : nums[endLo++];\\n        }\\n        while (preLo <= preHi){\\n            newArr[index++] = nums[preLo++];\\n        }\\n        while (endLo <= endHi){\\n            newArr[index++] = nums[endLo++];\\n        }\\n        \\n        index = 0;\\n        while (lo <= hi){\\n            nums[lo++] = newArr[index++];\\n        }\\n    }\\n    \\n    private void exch(int[] nums, int i, int j){\\n        if (i == j)\\n            return;\\n        nums[i] ^= nums[j];\\n        nums[j] ^= nums[i];\\n        nums[i] ^= nums[j];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private static final int QUICKSORTSHOLD = 50;\\n    private static final int MERGESORTSHOLD = 300;\\n    \\n    public int[] sortArray(int[] nums) {\\n        if (nums == null || nums.length < 2){\\n            return nums;\\n        }\\n        \\n        if (nums.length < QUICKSORTSHOLD){\\n            selectionSort(nums);   \\n        }else if (nums.length < MERGESORTSHOLD) {\\n            quickSort(nums);\\n        }else{\\n            mergeSort(nums);\\n        }\\n        return nums;\\n    }\\n    \\n    private void selectionSort(int[] nums){\\n        for (int i = 0; i < nums.length; i++){\\n            int minIndex = i;\\n            for (int j = i + 1; j < nums.length; j++){\\n                if (nums[j] < nums[minIndex]){\\n                    minIndex = j;\\n                }\\n            }\\n            exch(nums, i, minIndex);\\n        }\\n    }\\n    \\n    private void quickSort(int[] nums){\\n        quickSort(nums, 0, nums.length - 1);\\n    }\\n    \\n    private void quickSort(int[] nums, int lo, int hi){\\n        if (lo >= hi)\\n            return ;\\n        int pivot = partition(nums, lo, hi);\\n        quickSort(nums, lo, pivot - 1);\\n        quickSort(nums, pivot + 1, hi);\\n    }\\n    \\n    private int partition(int[] nums, int lo, int hi){\\n        int q = lo + (int)(Math.random() * (hi - lo + 1));\\n        exch(nums, lo, q);\\n        \\n        int index = lo + 1;\\n        for (int i = lo + 1; i <= hi; i++){\\n                if (nums[i] < nums[lo]){\\n                    exch(nums, i, index++);\\n                }\\n        }\\n        exch (nums, lo, --index);\\n        return index;\\n    }\\n    \\n    private void mergeSort(int[] nums){\\n        mergeSort(nums, 0, nums.length - 1);\\n    }\\n    \\n    private void mergeSort(int[] nums, int lo, int hi){\\n        if (lo >= hi)\\n            return ;\\n        int mid = (lo + hi) >>> 1;\\n        mergeSort(nums, lo, mid);\\n        mergeSort(nums, mid + 1, hi);\\n        merge(nums, lo, mid, mid + 1, hi);\\n    }\\n    \\n    private void merge(int[] nums, int preLo, int preHi, int endLo, int endHi){\\n        if (preLo == endHi)\\n            return;\\n        int lo = preLo;\\n        int hi = endHi;\\n        \\n        int[] newArr = new int[preHi - preLo + 1 + endHi - endLo + 1];\\n        int index = 0;\\n        while (preLo <= preHi && endLo <= endHi){\\n            newArr[index++] = (nums[preLo] < nums[endLo]) ? nums[preLo++] : nums[endLo++];\\n        }\\n        while (preLo <= preHi){\\n            newArr[index++] = nums[preLo++];\\n        }\\n        while (endLo <= endHi){\\n            newArr[index++] = nums[endLo++];\\n        }\\n        \\n        index = 0;\\n        while (lo <= hi){\\n            nums[lo++] = newArr[index++];\\n        }\\n    }\\n    \\n    private void exch(int[] nums, int i, int j){\\n        if (i == j)\\n            return;\\n        nums[i] ^= nums[j];\\n        nums[j] ^= nums[i];\\n        nums[i] ^= nums[j];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242479,
                "title": "very-easy-100-easiest-logic-ever-fully-explained-step-by-step-c-javascript-java",
                "content": "# Intuition\\nIf you wanna to solve this problem then you have a good grip on Recusrion because you have to solve this problem in O(nlogn) which is only possible by using Merge sort or Quick Sort. but here in my solution I am using Merge Sort Algorithm\\n\\n# Approach\\nHere\\'s how the algorithm works step by step:\\n\\n**Divide the array in half**. The first step in this code is to divide the input array into two halves. This is done by finding the middle index of the array and creating two new arrays: one containing the elements from the start of the array up to the middle index, and one containing the elements from the middle index to the end of the array.\\n\\n**Recursively sort each half.** Once we have divided the input array into two halves, we recursively sort each half using the same algorithm. We repeat this process until each half contains only one element, at which point we consider them to be sorted.\\n\\n**Merge the sorted halves.** After both halves are sorted, we merge them back together into a single, sorted array. We do this by comparing the first element of each half and adding the smaller element to a new array. We then move the index of the array from which we took the smaller element by one and repeat the process until we have added all elements from both halves to the new array.\\n\\nReturn the sorted array. Finally, we return the merged array.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code by using Merge Sort Algorithm\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArray = function(nums) {\\n    if(nums.length < 2) return nums\\n    let mid = Math.floor(nums.length/2);\\n    let left = nums.slice(0, mid);\\n    let right = nums.slice(mid);\\n    return merge(sortArray(left), sortArray(right));\\n};\\n\\nvar merge = function(left, right) {\\n    let sortedArray = [];\\n    while(left.length && right.length){\\n        if(left[0] <= right[0]){\\n            sortedArray.push(left.shift())\\n        }else {\\n            sortedArray.push(right.shift())\\n        }\\n    }\\n\\n    return [...sortedArray, ...left, ...right]\\n}\\n```\\n# Code by using Binary Sort Algorithm\\n```\\n// Time Complexity Big-O = O(n^2)\\n\\nvar sortArray = function (nums) {\\n  let sorted;\\n  do {\\n    sorted = false;\\n    for (let i = 0; i <= nums.length; i++) {\\n      if (nums[i] > nums[i + 1]) {\\n        let temp = nums[i + 1];\\n        nums[i + 1] = nums[i];\\n        nums[i] = temp;\\n        sorted = true;\\n      }\\n    }\\n  } while (sorted);\\n  return nums;\\n};\\n```\\n\\nI am working hard for you guys...\\nPlease upvote if you found any help with this code...",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArray = function(nums) {\\n    if(nums.length < 2) return nums\\n    let mid = Math.floor(nums.length/2);\\n    let left = nums.slice(0, mid);\\n    let right = nums.slice(mid);\\n    return merge(sortArray(left), sortArray(right));\\n};\\n\\nvar merge = function(left, right) {\\n    let sortedArray = [];\\n    while(left.length && right.length){\\n        if(left[0] <= right[0]){\\n            sortedArray.push(left.shift())\\n        }else {\\n            sortedArray.push(right.shift())\\n        }\\n    }\\n\\n    return [...sortedArray, ...left, ...right]\\n}\\n```\n```\\n// Time Complexity Big-O = O(n^2)\\n\\nvar sortArray = function (nums) {\\n  let sorted;\\n  do {\\n    sorted = false;\\n    for (let i = 0; i <= nums.length; i++) {\\n      if (nums[i] > nums[i + 1]) {\\n        let temp = nums[i + 1];\\n        nums[i + 1] = nums[i];\\n        nums[i] = temp;\\n        sorted = true;\\n      }\\n    }\\n  } while (sorted);\\n  return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3242173,
                "title": "java-easy-to-understand-5-lines",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : PriorityQueue\\n- **Step 1** : Take one ```ans``` array to store the sorted array and PriorityQueue ```pq```. Default PriorityQueue is Min Heap , It store all elements in ascending order.\\n- **Step 2** : Add all elements in PriorityQueue.\\n- **Step 3** : Now add elements of ```pq``` to the ```ans``` array.\\n- **Step 4** : Return ```ans``` array.\\n \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n\\n        int i=0;\\n        int[] ans = new int[nums.length];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num : nums) pq.offer(num);\\n        while(!pq.isEmpty()) ans[i++] = pq.poll();\\n        return ans;\\n    }\\n}\\n```\\n```\\nIf you like Please UpVote solution\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```ans```\n```pq```\n```pq```\n```ans```\n```ans```\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n\\n        int i=0;\\n        int[] ans = new int[nums.length];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num : nums) pq.offer(num);\\n        while(!pq.isEmpty()) ans[i++] = pq.poll();\\n        return ans;\\n    }\\n}\\n```\n```\\nIf you like Please UpVote solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964921,
                "title": "merge-sort-for-interviews-short-and-pythonic",
                "content": "```\\ndef sortArray(self, nums: List[int]) -> List[int]:\\n        def mergeTwoSortedArrays(a, b , res):\\n            i, j, k = 0, 0, 0\\n            while i<len(a) and j<len(b):\\n                if a[i]<b[j]:\\n                    res[k] = a[i]\\n                    i+=1\\n                else:\\n                    res[k] = b[j]\\n                    j+=1\\n                k+=1\\n            \\n            res[k:] = a[i:] if i<len(a) else b[j:]\\n               \\n        def mergesort(nums):\\n            if len(nums) == 1: return\\n            mid = len(nums)//2\\n            L = nums[:mid]\\n            R = nums[mid:]\\n            \\n            mergesort(L)\\n            mergesort(R)\\n            \\n            mergeTwoSortedArrays(L, R, nums)\\n        \\n        mergesort(nums)\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Merge Sort"
                ],
                "code": "```\\ndef sortArray(self, nums: List[int]) -> List[int]:\\n        def mergeTwoSortedArrays(a, b , res):\\n            i, j, k = 0, 0, 0\\n            while i<len(a) and j<len(b):\\n                if a[i]<b[j]:\\n                    res[k] = a[i]\\n                    i+=1\\n                else:\\n                    res[k] = b[j]\\n                    j+=1\\n                k+=1\\n            \\n            res[k:] = a[i:] if i<len(a) else b[j:]\\n               \\n        def mergesort(nums):\\n            if len(nums) == 1: return\\n            mid = len(nums)//2\\n            L = nums[:mid]\\n            R = nums[mid:]\\n            \\n            mergesort(L)\\n            mergesort(R)\\n            \\n            mergeTwoSortedArrays(L, R, nums)\\n        \\n        mergesort(nums)\\n        return nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1686594,
                "title": "all-15-sorting-methods-solution-is-here",
                "content": "```\\nTable of Content:\\nSTL\\nMethod1: Standard\\nMethod2: Stable\\nInsertion Sort\\nMethod1: Iterative\\nMethod2: Recursive\\nSelection Sort\\nMethod1: Standard\\nMethod2: Standard using inbuilt\\nBubble Sort\\nQuick Sort\\nMethod1: Standard\\nMethod2: Randomised\\nMerge Sort\\nMethod1: Outplace Merging\\nMethod2: Inplace Merging\\nGeneralised Radix Sort\\nMethod1: Using MinVal\\nMethod2: Using Partitioning\\nGeneralised Counting Sort\\nHeap Sort\\nBucket Sort\\nSTL\\nMethod1: Standard (Accepted) [T(n) = O(n * lgn)]\\nvoid stlSort(vector<int>& nums) {\\n\\tsort(nums.begin(), nums.end());\\n}\\nMethod2: Stable (Accepted) [T(n) = O(n * lgn)]\\nvoid stableStlSort(vector<int>& nums) {\\n\\tstable_sort(nums.begin(), nums.end());\\n}\\nInsertion Sort\\nMethod1: Iterative (TLE) [T(n) = O(n^2)]\\nvoid insertionSort(vector<int> &nums) {\\n\\tint sortedInd, unsortedInd, key, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (unsortedInd = 1; unsortedInd < size; unsortedInd++) {\\n\\t\\tkey = nums[unsortedInd], sortedInd = unsortedInd;\\n\\t\\twhile (--sortedInd >= 0 and key < nums[sortedInd])\\n\\t\\t\\tnums[sortedInd + 1] = nums[sortedInd];\\n\\t\\tnums[sortedInd + 1] = key;\\n\\t}\\n}\\nMethod2: Recursive (TLE) [T(n) = O(n^2)]\\nvoid recInsert(vector<int> &nums, int val) {\\n\\tif (!nums.size() or nums.back() <= val)\\n\\t\\treturn nums.push_back(val);\\n\\tint last = nums.back();\\n\\tnums.pop_back();\\n\\trecInsert(nums, val);\\n\\tnums.push_back(last);\\n}\\n\\t\\nvoid recInsertionSort(vector<int> &nums) {\\n\\tif (nums.size() <= 1) return;\\n\\tint last = nums.back();\\n\\tnums.pop_back();\\n\\trecInsertionSort(nums);\\n\\trecInsert(nums, last);\\n}\\nSelection Sort\\nMethod1: Standard (TLE) [T(n) = Theta(n^2)]\\nvoid selectionSort(vector<int> &nums) {\\n\\tint minInd, startInd, currInd, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (startInd = 0; startInd < size - 1; startInd++) {\\n\\t\\tfor (currInd = startInd + 1, minInd = startInd; currInd < size; currInd++)\\n\\t\\t\\tif (nums[minInd] > nums[currInd])\\n\\t\\t\\t\\tminInd = currInd;\\n\\t\\tif (minInd != startInd)\\n\\t\\t\\tswap(nums[startInd], nums[minInd]);\\n\\t}\\n}\\nMethod2: Standard using inbuilt (TLE) [T(n) = Theta(n^2)]\\nvoid selectionSort(vector<int> &nums) {\\n\\tint minInd, startInd, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (startInd = 0; startInd < size - 1; startInd++) {\\n\\t\\tminInd = min_element(nums.begin() + startInd, nums.end()) - nums.begin();\\n\\t\\tif (minInd != startInd)\\n\\t\\t\\tswap(nums[startInd], nums[minInd]);\\n\\t}\\n}\\nBubble Sort (TLE) [T(n) = Theta(n^2)]\\nvoid bubbleSort(vector<int> &nums) {\\n\\tint endInd, currInd, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (endInd = size - 1; endInd; endInd--)\\n\\t\\tfor (currInd = 0; currInd < endInd; currInd++)\\n\\t\\t\\tif (nums[currInd] > nums[currInd + 1])\\n\\t\\t\\t\\tswap(nums[currInd], nums[currInd + 1]);\\n}\\nQuick Sort\\nMethod1: Standard (TLE) [T(n) = O(n^2)]\\nint partitionArray(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return -1;\\n\\tint pivot = low, l = pivot + 1, r = high;\\n\\twhile (l <= r)\\n\\t\\tif (nums[l] < nums[pivot]) l++;\\n\\t\\telse if (nums[r] >= nums[pivot]) r--;\\n\\t\\telse swap(nums[l], nums[r]);\\n\\tswap(nums[pivot], nums[r]);\\n\\treturn r;\\n}\\n\\t\\nvoid quickSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tint pivot = partitionArray(nums, low, high);\\n\\tquickSort(nums, low, pivot);\\n\\tquickSort(nums, pivot + 1, high);\\n}\\nMethod2: Randomised (Accepted) [T(n) = O(n * lgn)]\\nint partitionArray(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return -1;\\n\\tint pivot = low, l = pivot + 1, r = high;\\n\\twhile (l <= r)\\n\\t\\tif (nums[l] < nums[pivot]) l++;\\n\\t\\telse if (nums[r] >= nums[pivot]) r--;\\n\\t\\telse swap(nums[l], nums[r]);\\n\\tswap(nums[pivot], nums[r]);\\n\\treturn r;\\n}\\n\\nvoid quickSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tswap(nums[low + rand() % (high - low + 1)], nums[low]);\\n\\tint pivot = partitionArray(nums, low, high);\\n\\tquickSort(nums, low, pivot);\\n\\tquickSort(nums, pivot + 1, high);\\n}\\nMerge Sort\\nMethod1: Outplace Merging (Accepted) [T(n) = O(n * lgn)]\\nvoid outPlaceMerge(vector<int> &nums, int low, int mid, int high) {\\n\\tif (low >= high) return;\\n\\tint l = low, r = mid + 1, k = 0, size = high - low + 1;\\n\\tvector<int> sorted(size, 0);\\n\\twhile (l <= mid and r <= high)\\n\\t\\tsorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\\n\\twhile (l <= mid) \\n\\t\\tsorted[k++] = nums[l++];\\n\\twhile (r <= high) \\n\\t\\tsorted[k++] = nums[r++];\\n\\tfor (k = 0; k < size; k++)\\n\\t\\tnums[k + low] = sorted[k];\\n}\\n\\nvoid mergeSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tint mid = (high - low) / 2 + low;\\n\\tmergeSort(nums, low, mid);\\n\\tmergeSort(nums, mid + 1, high);\\n\\toutPlaceMerge(nums, low, mid, high);\\n}\\nMethod2: Inplace Merging (TLE) [T(n) = O(n^2)]\\nvoid inPlaceMerge(vector<int> &nums, int low, int mid, int high) {\\n\\tif (low >= high) return;\\n\\tint l = low, r = mid + 1, size = high - low + 1;\\n\\twhile (l <= mid and r <= high) {\\n\\t\\tif (nums[l] <= nums[r]) l++;\\n\\t\\telse {\\n\\t\\t\\tint val = nums[r];\\n\\t\\t\\tfor (int k = r++; k > l; k--)\\n\\t\\t\\t\\tnums[k] = nums[k - 1];\\n\\t\\t\\tnums[l++] = val;\\n\\t\\t\\tmid++;\\n\\t\\t}\\n\\t}\\n}\\n\\nvoid mergeSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tint mid = (high - low) / 2 + low;\\n\\tmergeSort(nums, low, mid);\\n\\tmergeSort(nums, mid + 1, high);\\n\\tinPlaceMerge(nums, low, mid, high);\\n}\\nGeneralised Couting Sort (Accepted) [T(n) = Theta(max(n, m)) where m = max(Arr)]\\nvoid countingSort(vector<int> &nums, bool isAscending=true) {\\n\\tint minVal = *min_element(nums.begin(), nums.end());\\n\\tint maxVal = *max_element(nums.begin(), nums.end());\\n\\tint freqSize = maxVal - minVal + 1 + 1, size = nums.size();\\n\\tvector<int> freq(freqSize, 0), sorted(size, 0);\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tfreq[nums[ind] - minVal]++;\\n\\tif (isAscending)\\n\\t\\tfor (int ind = 1; ind < freqSize; ind++)\\n\\t\\t\\tfreq[ind] += freq[ind - 1];\\n\\telse\\n\\t\\tfor (int ind = freqSize - 2; ind >= 0; ind--)\\n\\t\\t\\tfreq[ind] += freq[ind + 1];\\n\\t// for stable sorting start ind from end and decrement till 0\\n\\tfor (int ind = size - 1; ind >= 0; ind--)\\n\\t\\tsorted[freq[nums[ind] - minVal]-- - 1] = nums[ind];\\n\\tnums = sorted;\\n}\\nGeneralised Radix Sort\\nMethod1: Using MinVal (Accepted) [T(n) = Theta(n)]\\nint getDigit(int num, int factor) {\\n\\treturn (abs(num) / abs(factor)) % 10;\\n}\\n\\nvoid radixCountingSort(vector<int> &nums, int factor) {\\n\\tint freqSize = 10, size = nums.size();\\n\\tvector<int> freq(freqSize, 0), sorted(size, 0);\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tfreq[getDigit(nums[ind], factor)]++;\\n\\tfor (int ind = 1; ind < freqSize; ind++)\\n\\t\\tfreq[ind] += freq[ind - 1];\\n\\t// for stable sorting start ind from end and decrement till 0\\n\\tfor (int ind = size - 1; ind >= 0; ind--)\\n\\t\\tsorted[freq[getDigit(nums[ind], factor)]-- - 1] = nums[ind];\\n\\tnums = sorted;\\n}\\n\\nvoid radixSort(vector<int> &nums) {\\n\\tint minVal = *min_element(nums.begin(), nums.end());\\n\\tfor (auto &num : nums) num -= minVal;\\n\\tint factor = 1, maxVal = *max_element(nums.begin(), nums.end());\\n\\twhile (maxVal / factor) {\\n\\t\\tradixCountingSort(nums, factor);\\n\\t\\tfactor *= 10;\\n\\t}\\n\\tfor (auto &num : nums) num += minVal;\\n}\\nMethod2: Using Partitioning (Accepted) [T(n) = Theta(n)]\\n\\nIdea is to partition the Array with pivot as mininum Positive Element and thus, left half array is of -ve no.s (if any) and right half array is of +ve no.s (if any). Finally we apply Radix Sort on both the parts.\\nNote that to sort -ve no.s only with Radix Sort, we need to reverse sort the -ve no.s (eg: [-5,-4,-3] and [3,4,5])\\n\\nint partitionArray(vector<int> &nums, int low=0, int high=-1) {\\n\\thigh = high < 0 ? nums.size() - 1 : high;\\n\\tif (low >= high) return -1;\\n\\tint pivot = low, l = pivot + 1, r = high;\\n\\twhile (l <= r)\\n\\t\\tif (nums[l] < nums[pivot]) l++;\\n\\t\\telse if (nums[r] >= nums[pivot]) r--;\\n\\t\\telse swap(nums[l], nums[r]);\\n\\tswap(nums[pivot], nums[r]);\\n\\treturn r;\\n}\\n\\nint getDigit(int num, int factor) {\\n\\treturn (abs(num) / abs(factor)) % 10;\\n}\\n\\npair<int, int> getMinAndNonNegMinInd(vector<int> &nums) {\\n\\tint minInd = nums.size(), minVal = INT_MAX;\\n\\tint nonNegMinInd = nums.size(), minNonNegVal = INT_MAX;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tif (nums[i] >= 0 and nums[i] < minNonNegVal)\\n\\t\\t\\tnonNegMinInd = i, minNonNegVal = nums[i];\\n\\t\\tif (nums[i] < minVal)\\n\\t\\t\\tminInd = i, minVal = nums[i];\\n\\t}\\n\\treturn {minInd, nonNegMinInd};\\n}\\n\\nint radixSortPartionArray(vector<int> &nums) {\\n\\tauto [minInd, nonNegMinInd] = getMinAndNonNegMinInd(nums);\\n\\tif (nonNegMinInd < nums.size()) {\\n\\t\\tif (nonNegMinInd) swap(nums[0], nums[nonNegMinInd]);\\n\\t\\tif (nums[minInd] >= 0) nonNegMinInd = 0;\\n\\t\\telse nonNegMinInd = partitionArray(nums);\\n\\t}\\n\\treturn nonNegMinInd;\\n}\\n\\nvoid radixCountingSort(vector<int> &nums, int factor, int low, int high, bool isAscending=true) {\\n\\tif (low >= high) return;\\n\\tint freqSize = 10, size = high - low + 1;\\n\\tvector<int> freq(freqSize, 0), sorted(size, 0);\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tfreq[getDigit(nums[ind + low], factor)]++;\\n\\tif (isAscending)\\n\\t\\t// reference: http://analgorithmaday.blogspot.com/2011/03/counting-sortlinear-time.html\\n\\t\\tfor (int ind = 1; ind < freqSize; ind++)\\n\\t\\t\\tfreq[ind] += freq[ind - 1];\\n\\telse\\n\\t\\tfor (int ind = freqSize - 2; ind >= 0; ind--)\\n\\t\\t\\tfreq[ind] += freq[ind + 1];\\n\\t// for stable sorting start ind from end and decrement till 0\\n\\tfor (int ind = size - 1; ind >= 0; ind--)\\n\\t\\tsorted[freq[getDigit(nums[ind + low], factor)]-- - 1] = nums[ind + low];\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tnums[ind + low] = sorted[ind];\\n}\\n\\nvoid radixSortHelper(vector<int> &nums, int low, int high, bool isAscending=true) {\\n\\tif (low >= high) return;\\n\\tint maxVal = *max_element(nums.begin() + low, nums.begin() + high + 1, [] (int &a, int &b) {\\n\\t\\treturn abs(a) < abs(b);\\n\\t});\\n\\tint factor = 1;\\n\\twhile (maxVal / factor) {\\n\\t\\tradixCountingSort(nums, factor, low, high, isAscending);\\n\\t\\tfactor *= 10;\\n\\t}\\n}\\n\\nvoid radixSort(vector<int> &nums) {\\n\\tint nonNegMinInd = radixSortPartionArray(nums);\\n\\tif (nonNegMinInd <= 1)\\n\\t\\tradixSortHelper(nums, nonNegMinInd + 1, nums.size() - 1);\\n\\telse {\\n\\t\\tradixSortHelper(nums, 0, nonNegMinInd - 1, false);\\n\\t\\tradixSortHelper(nums, nonNegMinInd + 1, nums.size() - 1);\\n\\t}\\n}\\nHeap Sort (Accepted) [T(n) = O(n * lgn)]\\nvoid heapifyDown(vector<int> &nums, int size, int rootInd, bool isMin=false) {\\n\\tif (size <= 1 or rootInd < 0 or rootInd >= size - 1) return;\\n\\tint keyInd = rootInd, leftChildInd = 2 * rootInd + 1, rightChildInd = 2 * rootInd + 2;\\n\\tif (leftChildInd < size and (isMin ? nums[leftChildInd] < nums[keyInd] : nums[leftChildInd] > nums[keyInd]))\\n\\t\\tkeyInd = leftChildInd;\\n\\tif (rightChildInd < size and (isMin ? nums[rightChildInd] < nums[keyInd] : nums[rightChildInd] > nums[keyInd]))\\n\\t\\tkeyInd = rightChildInd;\\n\\tif (nums[keyInd] != nums[rootInd]) {\\n\\t\\tswap(nums[rootInd], nums[keyInd]);\\n\\t\\theapifyDown(nums, size, keyInd, isMin);\\n\\t}\\n}\\n\\nvoid heapifyArray(vector<int> &nums, bool isMin=false) {\\n\\tint size = nums.size();\\n\\tif (size <= 1) return;\\n\\tint tailRootInd = (size >> 1) - 1;\\n\\tfor (int rootInd = tailRootInd; rootInd >= 0; rootInd--)\\n\\t\\theapifyDown(nums, size, rootInd, isMin);\\n}\\n\\nvoid heapSort(vector<int> &nums) {\\n\\tif (nums.size() <= 1) return;\\n\\theapifyArray(nums);\\n\\tfor (int size = nums.size() - 1; size; size--) {\\n\\t\\tswap(nums[size], nums[0]);\\n\\t\\theapifyDown(nums, size, 0);\\n\\t}\\n}\\nBucket Sort\\nBucket sort\\'s performance depends upon the uniformity (distribution) of the input data. Hence, I am not discussing it here (I have not submitted it as well for given constraints). For more info on this Algo, you can google it.\\n\\nAmong above, Counting Sort was fastest in Leetcode OJ.\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Merge Sort",
                    "Iterator"
                ],
                "code": "```\\nTable of Content:\\nSTL\\nMethod1: Standard\\nMethod2: Stable\\nInsertion Sort\\nMethod1: Iterative\\nMethod2: Recursive\\nSelection Sort\\nMethod1: Standard\\nMethod2: Standard using inbuilt\\nBubble Sort\\nQuick Sort\\nMethod1: Standard\\nMethod2: Randomised\\nMerge Sort\\nMethod1: Outplace Merging\\nMethod2: Inplace Merging\\nGeneralised Radix Sort\\nMethod1: Using MinVal\\nMethod2: Using Partitioning\\nGeneralised Counting Sort\\nHeap Sort\\nBucket Sort\\nSTL\\nMethod1: Standard (Accepted) [T(n) = O(n * lgn)]\\nvoid stlSort(vector<int>& nums) {\\n\\tsort(nums.begin(), nums.end());\\n}\\nMethod2: Stable (Accepted) [T(n) = O(n * lgn)]\\nvoid stableStlSort(vector<int>& nums) {\\n\\tstable_sort(nums.begin(), nums.end());\\n}\\nInsertion Sort\\nMethod1: Iterative (TLE) [T(n) = O(n^2)]\\nvoid insertionSort(vector<int> &nums) {\\n\\tint sortedInd, unsortedInd, key, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (unsortedInd = 1; unsortedInd < size; unsortedInd++) {\\n\\t\\tkey = nums[unsortedInd], sortedInd = unsortedInd;\\n\\t\\twhile (--sortedInd >= 0 and key < nums[sortedInd])\\n\\t\\t\\tnums[sortedInd + 1] = nums[sortedInd];\\n\\t\\tnums[sortedInd + 1] = key;\\n\\t}\\n}\\nMethod2: Recursive (TLE) [T(n) = O(n^2)]\\nvoid recInsert(vector<int> &nums, int val) {\\n\\tif (!nums.size() or nums.back() <= val)\\n\\t\\treturn nums.push_back(val);\\n\\tint last = nums.back();\\n\\tnums.pop_back();\\n\\trecInsert(nums, val);\\n\\tnums.push_back(last);\\n}\\n\\t\\nvoid recInsertionSort(vector<int> &nums) {\\n\\tif (nums.size() <= 1) return;\\n\\tint last = nums.back();\\n\\tnums.pop_back();\\n\\trecInsertionSort(nums);\\n\\trecInsert(nums, last);\\n}\\nSelection Sort\\nMethod1: Standard (TLE) [T(n) = Theta(n^2)]\\nvoid selectionSort(vector<int> &nums) {\\n\\tint minInd, startInd, currInd, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (startInd = 0; startInd < size - 1; startInd++) {\\n\\t\\tfor (currInd = startInd + 1, minInd = startInd; currInd < size; currInd++)\\n\\t\\t\\tif (nums[minInd] > nums[currInd])\\n\\t\\t\\t\\tminInd = currInd;\\n\\t\\tif (minInd != startInd)\\n\\t\\t\\tswap(nums[startInd], nums[minInd]);\\n\\t}\\n}\\nMethod2: Standard using inbuilt (TLE) [T(n) = Theta(n^2)]\\nvoid selectionSort(vector<int> &nums) {\\n\\tint minInd, startInd, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (startInd = 0; startInd < size - 1; startInd++) {\\n\\t\\tminInd = min_element(nums.begin() + startInd, nums.end()) - nums.begin();\\n\\t\\tif (minInd != startInd)\\n\\t\\t\\tswap(nums[startInd], nums[minInd]);\\n\\t}\\n}\\nBubble Sort (TLE) [T(n) = Theta(n^2)]\\nvoid bubbleSort(vector<int> &nums) {\\n\\tint endInd, currInd, size = nums.size();\\n\\tif (size <= 1) return;\\n\\tfor (endInd = size - 1; endInd; endInd--)\\n\\t\\tfor (currInd = 0; currInd < endInd; currInd++)\\n\\t\\t\\tif (nums[currInd] > nums[currInd + 1])\\n\\t\\t\\t\\tswap(nums[currInd], nums[currInd + 1]);\\n}\\nQuick Sort\\nMethod1: Standard (TLE) [T(n) = O(n^2)]\\nint partitionArray(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return -1;\\n\\tint pivot = low, l = pivot + 1, r = high;\\n\\twhile (l <= r)\\n\\t\\tif (nums[l] < nums[pivot]) l++;\\n\\t\\telse if (nums[r] >= nums[pivot]) r--;\\n\\t\\telse swap(nums[l], nums[r]);\\n\\tswap(nums[pivot], nums[r]);\\n\\treturn r;\\n}\\n\\t\\nvoid quickSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tint pivot = partitionArray(nums, low, high);\\n\\tquickSort(nums, low, pivot);\\n\\tquickSort(nums, pivot + 1, high);\\n}\\nMethod2: Randomised (Accepted) [T(n) = O(n * lgn)]\\nint partitionArray(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return -1;\\n\\tint pivot = low, l = pivot + 1, r = high;\\n\\twhile (l <= r)\\n\\t\\tif (nums[l] < nums[pivot]) l++;\\n\\t\\telse if (nums[r] >= nums[pivot]) r--;\\n\\t\\telse swap(nums[l], nums[r]);\\n\\tswap(nums[pivot], nums[r]);\\n\\treturn r;\\n}\\n\\nvoid quickSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tswap(nums[low + rand() % (high - low + 1)], nums[low]);\\n\\tint pivot = partitionArray(nums, low, high);\\n\\tquickSort(nums, low, pivot);\\n\\tquickSort(nums, pivot + 1, high);\\n}\\nMerge Sort\\nMethod1: Outplace Merging (Accepted) [T(n) = O(n * lgn)]\\nvoid outPlaceMerge(vector<int> &nums, int low, int mid, int high) {\\n\\tif (low >= high) return;\\n\\tint l = low, r = mid + 1, k = 0, size = high - low + 1;\\n\\tvector<int> sorted(size, 0);\\n\\twhile (l <= mid and r <= high)\\n\\t\\tsorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\\n\\twhile (l <= mid) \\n\\t\\tsorted[k++] = nums[l++];\\n\\twhile (r <= high) \\n\\t\\tsorted[k++] = nums[r++];\\n\\tfor (k = 0; k < size; k++)\\n\\t\\tnums[k + low] = sorted[k];\\n}\\n\\nvoid mergeSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tint mid = (high - low) / 2 + low;\\n\\tmergeSort(nums, low, mid);\\n\\tmergeSort(nums, mid + 1, high);\\n\\toutPlaceMerge(nums, low, mid, high);\\n}\\nMethod2: Inplace Merging (TLE) [T(n) = O(n^2)]\\nvoid inPlaceMerge(vector<int> &nums, int low, int mid, int high) {\\n\\tif (low >= high) return;\\n\\tint l = low, r = mid + 1, size = high - low + 1;\\n\\twhile (l <= mid and r <= high) {\\n\\t\\tif (nums[l] <= nums[r]) l++;\\n\\t\\telse {\\n\\t\\t\\tint val = nums[r];\\n\\t\\t\\tfor (int k = r++; k > l; k--)\\n\\t\\t\\t\\tnums[k] = nums[k - 1];\\n\\t\\t\\tnums[l++] = val;\\n\\t\\t\\tmid++;\\n\\t\\t}\\n\\t}\\n}\\n\\nvoid mergeSort(vector<int> &nums, int low, int high) {\\n\\tif (low >= high) return;\\n\\tint mid = (high - low) / 2 + low;\\n\\tmergeSort(nums, low, mid);\\n\\tmergeSort(nums, mid + 1, high);\\n\\tinPlaceMerge(nums, low, mid, high);\\n}\\nGeneralised Couting Sort (Accepted) [T(n) = Theta(max(n, m)) where m = max(Arr)]\\nvoid countingSort(vector<int> &nums, bool isAscending=true) {\\n\\tint minVal = *min_element(nums.begin(), nums.end());\\n\\tint maxVal = *max_element(nums.begin(), nums.end());\\n\\tint freqSize = maxVal - minVal + 1 + 1, size = nums.size();\\n\\tvector<int> freq(freqSize, 0), sorted(size, 0);\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tfreq[nums[ind] - minVal]++;\\n\\tif (isAscending)\\n\\t\\tfor (int ind = 1; ind < freqSize; ind++)\\n\\t\\t\\tfreq[ind] += freq[ind - 1];\\n\\telse\\n\\t\\tfor (int ind = freqSize - 2; ind >= 0; ind--)\\n\\t\\t\\tfreq[ind] += freq[ind + 1];\\n\\t// for stable sorting start ind from end and decrement till 0\\n\\tfor (int ind = size - 1; ind >= 0; ind--)\\n\\t\\tsorted[freq[nums[ind] - minVal]-- - 1] = nums[ind];\\n\\tnums = sorted;\\n}\\nGeneralised Radix Sort\\nMethod1: Using MinVal (Accepted) [T(n) = Theta(n)]\\nint getDigit(int num, int factor) {\\n\\treturn (abs(num) / abs(factor)) % 10;\\n}\\n\\nvoid radixCountingSort(vector<int> &nums, int factor) {\\n\\tint freqSize = 10, size = nums.size();\\n\\tvector<int> freq(freqSize, 0), sorted(size, 0);\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tfreq[getDigit(nums[ind], factor)]++;\\n\\tfor (int ind = 1; ind < freqSize; ind++)\\n\\t\\tfreq[ind] += freq[ind - 1];\\n\\t// for stable sorting start ind from end and decrement till 0\\n\\tfor (int ind = size - 1; ind >= 0; ind--)\\n\\t\\tsorted[freq[getDigit(nums[ind], factor)]-- - 1] = nums[ind];\\n\\tnums = sorted;\\n}\\n\\nvoid radixSort(vector<int> &nums) {\\n\\tint minVal = *min_element(nums.begin(), nums.end());\\n\\tfor (auto &num : nums) num -= minVal;\\n\\tint factor = 1, maxVal = *max_element(nums.begin(), nums.end());\\n\\twhile (maxVal / factor) {\\n\\t\\tradixCountingSort(nums, factor);\\n\\t\\tfactor *= 10;\\n\\t}\\n\\tfor (auto &num : nums) num += minVal;\\n}\\nMethod2: Using Partitioning (Accepted) [T(n) = Theta(n)]\\n\\nIdea is to partition the Array with pivot as mininum Positive Element and thus, left half array is of -ve no.s (if any) and right half array is of +ve no.s (if any). Finally we apply Radix Sort on both the parts.\\nNote that to sort -ve no.s only with Radix Sort, we need to reverse sort the -ve no.s (eg: [-5,-4,-3] and [3,4,5])\\n\\nint partitionArray(vector<int> &nums, int low=0, int high=-1) {\\n\\thigh = high < 0 ? nums.size() - 1 : high;\\n\\tif (low >= high) return -1;\\n\\tint pivot = low, l = pivot + 1, r = high;\\n\\twhile (l <= r)\\n\\t\\tif (nums[l] < nums[pivot]) l++;\\n\\t\\telse if (nums[r] >= nums[pivot]) r--;\\n\\t\\telse swap(nums[l], nums[r]);\\n\\tswap(nums[pivot], nums[r]);\\n\\treturn r;\\n}\\n\\nint getDigit(int num, int factor) {\\n\\treturn (abs(num) / abs(factor)) % 10;\\n}\\n\\npair<int, int> getMinAndNonNegMinInd(vector<int> &nums) {\\n\\tint minInd = nums.size(), minVal = INT_MAX;\\n\\tint nonNegMinInd = nums.size(), minNonNegVal = INT_MAX;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tif (nums[i] >= 0 and nums[i] < minNonNegVal)\\n\\t\\t\\tnonNegMinInd = i, minNonNegVal = nums[i];\\n\\t\\tif (nums[i] < minVal)\\n\\t\\t\\tminInd = i, minVal = nums[i];\\n\\t}\\n\\treturn {minInd, nonNegMinInd};\\n}\\n\\nint radixSortPartionArray(vector<int> &nums) {\\n\\tauto [minInd, nonNegMinInd] = getMinAndNonNegMinInd(nums);\\n\\tif (nonNegMinInd < nums.size()) {\\n\\t\\tif (nonNegMinInd) swap(nums[0], nums[nonNegMinInd]);\\n\\t\\tif (nums[minInd] >= 0) nonNegMinInd = 0;\\n\\t\\telse nonNegMinInd = partitionArray(nums);\\n\\t}\\n\\treturn nonNegMinInd;\\n}\\n\\nvoid radixCountingSort(vector<int> &nums, int factor, int low, int high, bool isAscending=true) {\\n\\tif (low >= high) return;\\n\\tint freqSize = 10, size = high - low + 1;\\n\\tvector<int> freq(freqSize, 0), sorted(size, 0);\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tfreq[getDigit(nums[ind + low], factor)]++;\\n\\tif (isAscending)\\n\\t\\t// reference: http://analgorithmaday.blogspot.com/2011/03/counting-sortlinear-time.html\\n\\t\\tfor (int ind = 1; ind < freqSize; ind++)\\n\\t\\t\\tfreq[ind] += freq[ind - 1];\\n\\telse\\n\\t\\tfor (int ind = freqSize - 2; ind >= 0; ind--)\\n\\t\\t\\tfreq[ind] += freq[ind + 1];\\n\\t// for stable sorting start ind from end and decrement till 0\\n\\tfor (int ind = size - 1; ind >= 0; ind--)\\n\\t\\tsorted[freq[getDigit(nums[ind + low], factor)]-- - 1] = nums[ind + low];\\n\\tfor (int ind = 0; ind < size; ind++)\\n\\t\\tnums[ind + low] = sorted[ind];\\n}\\n\\nvoid radixSortHelper(vector<int> &nums, int low, int high, bool isAscending=true) {\\n\\tif (low >= high) return;\\n\\tint maxVal = *max_element(nums.begin() + low, nums.begin() + high + 1, [] (int &a, int &b) {\\n\\t\\treturn abs(a) < abs(b);\\n\\t});\\n\\tint factor = 1;\\n\\twhile (maxVal / factor) {\\n\\t\\tradixCountingSort(nums, factor, low, high, isAscending);\\n\\t\\tfactor *= 10;\\n\\t}\\n}\\n\\nvoid radixSort(vector<int> &nums) {\\n\\tint nonNegMinInd = radixSortPartionArray(nums);\\n\\tif (nonNegMinInd <= 1)\\n\\t\\tradixSortHelper(nums, nonNegMinInd + 1, nums.size() - 1);\\n\\telse {\\n\\t\\tradixSortHelper(nums, 0, nonNegMinInd - 1, false);\\n\\t\\tradixSortHelper(nums, nonNegMinInd + 1, nums.size() - 1);\\n\\t}\\n}\\nHeap Sort (Accepted) [T(n) = O(n * lgn)]\\nvoid heapifyDown(vector<int> &nums, int size, int rootInd, bool isMin=false) {\\n\\tif (size <= 1 or rootInd < 0 or rootInd >= size - 1) return;\\n\\tint keyInd = rootInd, leftChildInd = 2 * rootInd + 1, rightChildInd = 2 * rootInd + 2;\\n\\tif (leftChildInd < size and (isMin ? nums[leftChildInd] < nums[keyInd] : nums[leftChildInd] > nums[keyInd]))\\n\\t\\tkeyInd = leftChildInd;\\n\\tif (rightChildInd < size and (isMin ? nums[rightChildInd] < nums[keyInd] : nums[rightChildInd] > nums[keyInd]))\\n\\t\\tkeyInd = rightChildInd;\\n\\tif (nums[keyInd] != nums[rootInd]) {\\n\\t\\tswap(nums[rootInd], nums[keyInd]);\\n\\t\\theapifyDown(nums, size, keyInd, isMin);\\n\\t}\\n}\\n\\nvoid heapifyArray(vector<int> &nums, bool isMin=false) {\\n\\tint size = nums.size();\\n\\tif (size <= 1) return;\\n\\tint tailRootInd = (size >> 1) - 1;\\n\\tfor (int rootInd = tailRootInd; rootInd >= 0; rootInd--)\\n\\t\\theapifyDown(nums, size, rootInd, isMin);\\n}\\n\\nvoid heapSort(vector<int> &nums) {\\n\\tif (nums.size() <= 1) return;\\n\\theapifyArray(nums);\\n\\tfor (int size = nums.size() - 1; size; size--) {\\n\\t\\tswap(nums[size], nums[0]);\\n\\t\\theapifyDown(nums, size, 0);\\n\\t}\\n}\\nBucket Sort\\nBucket sort\\'s performance depends upon the uniformity (distribution) of the input data. Hence, I am not discussing it here (I have not submitted it as well for given constraints). For more info on this Algo, you can google it.\\n\\nAmong above, Counting Sort was fastest in Leetcode OJ.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 429639,
                "title": "python-clean-quicksort",
                "content": "```\\nclass Solution(object):\\n    def sortArray(self, nums):\\n        self.quickSort(nums, 0, len(nums)-1)\\n        return nums\\n\\n    def quickSort(self, nums, start, end):\\n        if end <= start:\\n            return\\n        mid = (start + end) // 2\\n        nums[start], nums[mid] = nums[mid], nums[start]\\n        i = start + 1\\n        j = end\\n        while i <= j:\\n            while i <= j and nums[i] <= nums[start]:\\n                i += 1\\n            while i <= j and nums[j] >= nums[start]:\\n                j -= 1\\n            if i < j:\\n                nums[i], nums[j] = nums[j], nums[i]        \\n        nums[start], nums[j] = nums[j], nums[start]\\n        self.quickSort(nums, start, j-1)\\n        self.quickSort(nums, j+1, end)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def sortArray(self, nums):\\n        self.quickSort(nums, 0, len(nums)-1)\\n        return nums\\n\\n    def quickSort(self, nums, start, end):\\n        if end <= start:\\n            return\\n        mid = (start + end) // 2\\n        nums[start], nums[mid] = nums[mid], nums[start]\\n        i = start + 1\\n        j = end\\n        while i <= j:\\n            while i <= j and nums[i] <= nums[start]:\\n                i += 1\\n            while i <= j and nums[j] >= nums[start]:\\n                j -= 1\\n            if i < j:\\n                nums[i], nums[j] = nums[j], nums[i]        \\n        nums[start], nums[j] = nums[j], nums[start]\\n        self.quickSort(nums, start, j-1)\\n        self.quickSort(nums, j+1, end)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480382,
                "title": "java-solution-explained-3-methods-hybrid-sorting-insertion-quick-merge-sort-fast",
                "content": "**Explanation:**\\n* OOH the question is asking us to sort an array, so simple right? use Arrays.sort(nums) and be  done with life, but stop let\\'s try not to be lazy today? we are going to solve this using top three basic sorting algorithms -- Insertion sort, Quick sort and Merge sort depending on the size of array.\\n1.  *Insertion sort* - stable sort and in-place, T: O(N^2) and S: O(1), good for lower size arrays.\\n2. *Quick sort* - unstable and in-place, T: O(Nlogn) - average case and S: O(1) (ignorign recursion call stack memory), divide and conquer algorithm. The key part is partioning(Naive, Lomuto and Hoare\\'s partition algorithm).\\n3. *Merge Sort* - stable sort and not in-place(arguable) , T: O(NlogN) S: O(N) , used in external sorting - for massive data. The key part is mergeFunction - I used two pointer approach.\\n\\n**Code:**\\n\\n       public int[] sortArray(int[] nums) {\\n\\t// we can check if our array is sorted or not by O(N) time.\\n        if (nums.length < 25) {\\n            insertionSort(nums);\\n        } else if (nums.length > 25 && nums.length < 1000 ) {\\n           quickSort(nums, 0, nums.length - 1);\\n        } else {\\n\\t\\t    mergeSort(nums, 0, nums.length - 1);\\n        }\\n        return nums;\\n    }\\n     static void mergeFun(int[] arr, int l, int m, int r) {\\n        int n1 = m + 1 - l;\\n        int n2 = r - m;\\n        int[] left = new int[n1];\\n        for (int i = 0; i < n1; i++) {\\n            left[i] = arr[l + i];\\n        }\\n        int[] right = new int[n2];\\n        for (int i = 0; i < n2; i++) {\\n            right[i] = arr[m + 1 + i];\\n        }\\n        int i = 0, j = 0, k = l;\\n        while (i < n1 || j < n2) {\\n            if (j == n2 || i < n1 && left[i] < right[j])\\n                arr[k++] = left[i++];\\n            else\\n                arr[k++] = right[j++];\\n        }\\n    }\\n\\n    static void mergeSort(int[] arr, int low, int high) {\\n        if (low < high) {\\n            int middle = (high - low) / 2 + low;\\n            mergeSort(arr, low, middle);\\n            mergeSort(arr, middle + 1, high);\\n            mergeFun(arr, low, middle, high);\\n        }\\n    }\\n\\n    static int partitionUsingHoare(int[] arr, int l, int h) {\\n        int pivot = arr[l];\\n        int i = l - 1;\\n        int j = h + 1;\\n        while (true) {\\n            do {\\n                i++;\\n            } while (arr[i] < pivot);\\n            do {\\n                j--;\\n            } while (arr[j] > pivot);\\n            if (i >= j) return j;\\n            swap(arr, i, j);\\n        }\\n    }\\n\\n    static void swap(int[] arr, int i, int j) {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n\\n    static void quickSort(int[] arr, int low, int high) {\\n        if (low < high) {\\n            int p = partitionUsingHoare(arr, low, high);\\n            quickSort(arr, low, p);\\n            quickSort(arr, p + 1, high);\\n        }\\n    }\\n\\n    static void insertionSort(int[] nums) { \\n        for (int i = 0; i < nums.length; i++) {\\n            int key = nums[i];\\n            int j = i - 1;\\n            while (j >= 0 && nums[j] > key) {\\n                nums[j + 1] = nums[j];\\n                j--;\\n            }\\n            nums[j + 1] = key;\\n        }\\n    }\\n\\n\\n**IMP**: You can also bookmark/ subscribe to this post so as to revise above Sorting Algorithms whenvever you need to.\\n\\n**NOTE:**\\nIf you find this post helpful then *please upvote*. It keeps me motivated to post such helpful solutions. Thanks!",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "**Explanation:**\\n* OOH the question is asking us to sort an array, so simple right? use Arrays.sort(nums) and be  done with life, but stop let\\'s try not to be lazy today? we are going to solve this using top three basic sorting algorithms -- Insertion sort, Quick sort and Merge sort depending on the size of array.\\n1.  *Insertion sort* - stable sort and in-place, T: O(N^2) and S: O(1), good for lower size arrays.\\n2. *Quick sort* - unstable and in-place, T: O(Nlogn) - average case and S: O(1) (ignorign recursion call stack memory), divide and conquer algorithm. The key part is partioning(Naive, Lomuto and Hoare\\'s partition algorithm).\\n3. *Merge Sort* - stable sort and not in-place(arguable) , T: O(NlogN) S: O(N) , used in external sorting - for massive data. The key part is mergeFunction - I used two pointer approach.\\n\\n**Code:**\\n\\n       public int[] sortArray(int[] nums) {\\n\\t// we can check if our array is sorted or not by O(N) time.\\n        if (nums.length < 25) {\\n            insertionSort(nums);\\n        } else if (nums.length > 25 && nums.length < 1000 ) {\\n           quickSort(nums, 0, nums.length - 1);\\n        } else {\\n\\t\\t    mergeSort(nums, 0, nums.length - 1);\\n        }\\n        return nums;\\n    }\\n     static void mergeFun(int[] arr, int l, int m, int r) {\\n        int n1 = m + 1 - l;\\n        int n2 = r - m;\\n        int[] left = new int[n1];\\n        for (int i = 0; i < n1; i++) {\\n            left[i] = arr[l + i];\\n        }\\n        int[] right = new int[n2];\\n        for (int i = 0; i < n2; i++) {\\n            right[i] = arr[m + 1 + i];\\n        }\\n        int i = 0, j = 0, k = l;\\n        while (i < n1 || j < n2) {\\n            if (j == n2 || i < n1 && left[i] < right[j])\\n                arr[k++] = left[i++];\\n            else\\n                arr[k++] = right[j++];\\n        }\\n    }\\n\\n    static void mergeSort(int[] arr, int low, int high) {\\n        if (low < high) {\\n            int middle = (high - low) / 2 + low;\\n            mergeSort(arr, low, middle);\\n            mergeSort(arr, middle + 1, high);\\n            mergeFun(arr, low, middle, high);\\n        }\\n    }\\n\\n    static int partitionUsingHoare(int[] arr, int l, int h) {\\n        int pivot = arr[l];\\n        int i = l - 1;\\n        int j = h + 1;\\n        while (true) {\\n            do {\\n                i++;\\n            } while (arr[i] < pivot);\\n            do {\\n                j--;\\n            } while (arr[j] > pivot);\\n            if (i >= j) return j;\\n            swap(arr, i, j);\\n        }\\n    }\\n\\n    static void swap(int[] arr, int i, int j) {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n\\n    static void quickSort(int[] arr, int low, int high) {\\n        if (low < high) {\\n            int p = partitionUsingHoare(arr, low, high);\\n            quickSort(arr, low, p);\\n            quickSort(arr, p + 1, high);\\n        }\\n    }\\n\\n    static void insertionSort(int[] nums) { \\n        for (int i = 0; i < nums.length; i++) {\\n            int key = nums[i];\\n            int j = i - 1;\\n            while (j >= 0 && nums[j] > key) {\\n                nums[j + 1] = nums[j];\\n                j--;\\n            }\\n            nums[j + 1] = key;\\n        }\\n    }\\n\\n\\n**IMP**: You can also bookmark/ subscribe to this post so as to revise above Sorting Algorithms whenvever you need to.\\n\\n**NOTE:**\\nIf you find this post helpful then *please upvote*. It keeps me motivated to post such helpful solutions. Thanks!",
                "codeTag": "Unknown"
            },
            {
                "id": 632176,
                "title": "i-will-never-ever-forget-merge-sort-again",
                "content": "i learned merge\\'s sort from : https://www.youtube.com/watch?v=mB5HXBb_HY8\\ncopy paste on youtube if link doesn\\'t works\\n**he explained really well** , i really appreciate his beirf explanation, watch this and then **come back here if you were not able to code**.\\n\\n**assuming you still needs help in coding part ( yeah I too needed ), here is the implementation**\\n```\\nvoid merge(vector<int> &a , int l , int mid , int h)     // make sure you passed be reference else changes wont reflect \\n    {\\n        vector<int> x(a.begin()+l, a.begin()+mid+1);         // making temp array for 1st segment \\n        vector<int> y(a.begin()+mid+1, a.begin()+h+1);  // making temp array for  2nd segment\\n        \\n        int n = x.size();\\n        int m = y.size();\\n        int i,j,k;  i=j=0;  k=l;\\n        \\n        while(i<n and j<m)                                  // standard merging algo as explained in video\\n            a[k++] = (x[i]<y[j]) ? x[i++] : y[j++];\\n        while(i<n)\\n            a[k++] = x[i++];\\n        while(j<m)\\n            a[k++] = y[j++];         \\n\\t}        \\n    void mergeSort(vector<int> &a , int l , int h)     // this function recursively calls itself until segment is greater than 1 length\\n    {\\n        if(l<h)\\n        {\\n            int mid = l+(h-l)/2;\\n            mergeSort(a,l,mid);\\n            mergeSort(a,mid+1,h);\\n            merge(a,l,mid,h);\\n        }\\n    }    \\n    vector<int> sortArray(vector<int>& nums) {        \\n        int n = nums.size();\\n        mergeSort(nums,0,n-1);\\n        return nums;\\n    }\\n```\\nThanks for reading, please upvote if this was helpful",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nvoid merge(vector<int> &a , int l , int mid , int h)     // make sure you passed be reference else changes wont reflect \\n    {\\n        vector<int> x(a.begin()+l, a.begin()+mid+1);         // making temp array for 1st segment \\n        vector<int> y(a.begin()+mid+1, a.begin()+h+1);  // making temp array for  2nd segment\\n        \\n        int n = x.size();\\n        int m = y.size();\\n        int i,j,k;  i=j=0;  k=l;\\n        \\n        while(i<n and j<m)                                  // standard merging algo as explained in video\\n            a[k++] = (x[i]<y[j]) ? x[i++] : y[j++];\\n        while(i<n)\\n            a[k++] = x[i++];\\n        while(j<m)\\n            a[k++] = y[j++];         \\n\\t}        \\n    void mergeSort(vector<int> &a , int l , int h)     // this function recursively calls itself until segment is greater than 1 length\\n    {\\n        if(l<h)\\n        {\\n            int mid = l+(h-l)/2;\\n            mergeSort(a,l,mid);\\n            mergeSort(a,mid+1,h);\\n            merge(a,l,mid,h);\\n        }\\n    }    \\n    vector<int> sortArray(vector<int>& nums) {        \\n        int n = nums.size();\\n        mergeSort(nums,0,n-1);\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3242062,
                "title": "c-solution-with-explanation-let-s-code-it",
                "content": "# Upvote if you found this solution helpful\\uD83D\\uDD25\\n\\n# Approach\\nBasically the question is asking us to implement the merge sort algorithm to sort the array in ascending order.\\nIn Merge sort we divide the given array into two parts, sort the parts individually and then merge those parts to get a sorted array.\\nTo sort the parts we again apply merge sort on them and in this way we recurssively solve the question.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        int n = nums.size();\\n        mergeSort(nums, n);\\n        return nums;\\n    }\\n\\n    //helper function\\n    void mergeSort(vector<int> &A, int n)\\n    {\\n        //if the size of array is less than two, it means it contains only a single element so there is no need of sorting -> simply return\\n        if (n < 2)\\n            return;\\n        //calculate the middle position\\n        int mid = n / 2;\\n\\n        //initialize two array left and right to store the two parts of array\\n        vector<int> L;\\n        vector<int> R;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n        //if the value of pointer is less than middle position push the element in left subarray\\n            if (i < mid)\\n            {\\n                L.push_back(A[i]);\\n            }\\n        //else push the element in right subarray\\n            else\\n                R.push_back(A[i]);\\n        }\\n\\n        //sort both left and right subarray individually\\n        mergeSort(L, L.size());\\n        mergeSort(R, R.size());\\n\\n        //merge left and right subarray after sorting them\\n        mergeArrays(A, L, R);\\n    }\\n\\n    void mergeArrays(vector<int> &A, vector<int> &L, vector<int> &R)\\n    {\\n\\n        int sizeL = L.size();\\n        int sizeR = R.size();\\n        //initialize pointers for each array -> left, right and final\\n        int i = 0, j = 0, k = 0;\\n\\n        while (i < sizeL && j < sizeR)\\n        {\\n            //if element at position i of left array is less than or equal to element at position j of right -> update the position k of final array with left[i]\\n            if (L[i] <= R[j])\\n            {\\n                A[k] = L[i];\\n                i++;\\n            }\\n            //similarlly is element of right is less than element of left -> update the position of final array with element of right\\n            else\\n            {\\n                A[k] = R[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n\\n        //if still there are remaining element in an array , simply append them into the final array\\n        while (i < sizeL)\\n        {\\n            A[k] = L[i];\\n            i++;\\n            k++;\\n        }\\n        while (j < sizeR)\\n        {\\n            A[k] = R[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        int n = nums.size();\\n        mergeSort(nums, n);\\n        return nums;\\n    }\\n\\n    //helper function\\n    void mergeSort(vector<int> &A, int n)\\n    {\\n        //if the size of array is less than two, it means it contains only a single element so there is no need of sorting -> simply return\\n        if (n < 2)\\n            return;\\n        //calculate the middle position\\n        int mid = n / 2;\\n\\n        //initialize two array left and right to store the two parts of array\\n        vector<int> L;\\n        vector<int> R;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n        //if the value of pointer is less than middle position push the element in left subarray\\n            if (i < mid)\\n            {\\n                L.push_back(A[i]);\\n            }\\n        //else push the element in right subarray\\n            else\\n                R.push_back(A[i]);\\n        }\\n\\n        //sort both left and right subarray individually\\n        mergeSort(L, L.size());\\n        mergeSort(R, R.size());\\n\\n        //merge left and right subarray after sorting them\\n        mergeArrays(A, L, R);\\n    }\\n\\n    void mergeArrays(vector<int> &A, vector<int> &L, vector<int> &R)\\n    {\\n\\n        int sizeL = L.size();\\n        int sizeR = R.size();\\n        //initialize pointers for each array -> left, right and final\\n        int i = 0, j = 0, k = 0;\\n\\n        while (i < sizeL && j < sizeR)\\n        {\\n            //if element at position i of left array is less than or equal to element at position j of right -> update the position k of final array with left[i]\\n            if (L[i] <= R[j])\\n            {\\n                A[k] = L[i];\\n                i++;\\n            }\\n            //similarlly is element of right is less than element of left -> update the position of final array with element of right\\n            else\\n            {\\n                A[k] = R[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n\\n        //if still there are remaining element in an array , simply append them into the final array\\n        while (i < sizeL)\\n        {\\n            A[k] = L[i];\\n            i++;\\n            k++;\\n        }\\n        while (j < sizeR)\\n        {\\n            A[k] = R[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354037,
                "title": "python-quicksort",
                "content": "\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        self.quicksort(nums, 0, len(nums) - 1)\\n        return nums\\n    \\n    def quicksort(self, nums, lower, upper):\\n        if lower < upper:\\n            pivot = self.partition(nums, lower, upper)\\n            self.quicksort(nums, lower, pivot - 1)\\n            self.quicksort(nums, pivot + 1, upper)\\n        else:\\n            return\\n        \\n    def partition(self, nums, lower, upper):\\n        \\n        pivot = nums[upper]\\n        \\n        i = lower\\n        \\n        for j in range(lower, upper):\\n            if nums[j] < pivot:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n                \\n        nums[i], nums[upper] = nums[upper], nums[i]\\n        \\n        return i\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        self.quicksort(nums, 0, len(nums) - 1)\\n        return nums\\n    \\n    def quicksort(self, nums, lower, upper):\\n        if lower < upper:\\n            pivot = self.partition(nums, lower, upper)\\n            self.quicksort(nums, lower, pivot - 1)\\n            self.quicksort(nums, pivot + 1, upper)\\n        else:\\n            return\\n        \\n    def partition(self, nums, lower, upper):\\n        \\n        pivot = nums[upper]\\n        \\n        i = lower\\n        \\n        for j in range(lower, upper):\\n            if nums[j] < pivot:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n                \\n        nums[i], nums[upper] = nums[upper], nums[i]\\n        \\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243522,
                "title": "merge-sort-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        def merge(nums):\\n            if len(nums)>1:\\n                mid=len(nums)//2\\n                left_list=nums[:mid]\\n                right_list=nums[mid:]\\n                merge(left_list)\\n                merge(right_list)\\n                a,b,c=0,0,0\\n                while a<len(left_list) and b<len(right_list):\\n                    if left_list[a]<right_list[b]:\\n                        nums[c]=left_list[a]\\n                        a+=1\\n                        c+=1\\n                    else:\\n                        nums[c]=right_list[b]\\n                        b+=1\\n                        c+=1\\n                while a<len(left_list):\\n                    nums[c]=left_list[a]\\n                    a+=1\\n                    c+=1\\n                while b<len(right_list):\\n                    nums[c]=right_list[b]\\n                    b+=1\\n                    c+=1\\n        merge(nums)\\n        return nums\\n        #----->kindly upvote me if it\\'s helpful \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        def merge(nums):\\n            if len(nums)>1:\\n                mid=len(nums)//2\\n                left_list=nums[:mid]\\n                right_list=nums[mid:]\\n                merge(left_list)\\n                merge(right_list)\\n                a,b,c=0,0,0\\n                while a<len(left_list) and b<len(right_list):\\n                    if left_list[a]<right_list[b]:\\n                        nums[c]=left_list[a]\\n                        a+=1\\n                        c+=1\\n                    else:\\n                        nums[c]=right_list[b]\\n                        b+=1\\n                        c+=1\\n                while a<len(left_list):\\n                    nums[c]=left_list[a]\\n                    a+=1\\n                    c+=1\\n                while b<len(right_list):\\n                    nums[c]=right_list[b]\\n                    b+=1\\n                    c+=1\\n        merge(nums)\\n        return nums\\n        #----->kindly upvote me if it\\'s helpful \\n```",
                "codeTag": "Java"
            },
            {
                "id": 905913,
                "title": "mergesort-in-python3",
                "content": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        #mergesort\\n        if len(nums) <= 1:\\n            return nums\\n        middle = len(nums) // 2\\n        left = self.sortArray(nums[:middle])\\n        right = self.sortArray(nums[middle:])\\n        merged = []\\n        while left and right:\\n            if left[0] <= right [0]:\\n                merged.append(left.pop(0))\\n            else:\\n                merged.append(right.pop(0))\\n        merged.extend(right if right else left)\\n        return merged\\n```",
                "solutionTags": [
                    "Python3",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        #mergesort\\n        if len(nums) <= 1:\\n            return nums\\n        middle = len(nums) // 2\\n        left = self.sortArray(nums[:middle])\\n        right = self.sortArray(nums[middle:])\\n        merged = []\\n        while left and right:\\n            if left[0] <= right [0]:\\n                merged.append(left.pop(0))\\n            else:\\n                merged.append(right.pop(0))\\n        merged.extend(right if right else left)\\n        return merged\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660426,
                "title": "javascript-mergesort-solution",
                "content": "```\\nconst sortArray = nums => {\\n    if(nums.length <= 1) return nums\\n    \\n    const middle = Math.floor(nums.length / 2)\\n    const left = nums.slice(0, middle)\\n    const right = nums.slice(middle)\\n    \\n    return merge(sortArray(left), sortArray(right))\\n};\\n\\nconst merge = (left, right) => {\\n    const result = []\\n    \\n    while (left.length && right.length) {\\n        if(left[0] <= right[0]) {\\n            result.push(left.shift())\\n        } else {\\n            result.push(right.shift())\\n        }\\n    }\\n    \\n    return [...result, ...left, ...right]\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Merge Sort"
                ],
                "code": "```\\nconst sortArray = nums => {\\n    if(nums.length <= 1) return nums\\n    \\n    const middle = Math.floor(nums.length / 2)\\n    const left = nums.slice(0, middle)\\n    const right = nums.slice(middle)\\n    \\n    return merge(sortArray(left), sortArray(right))\\n};\\n\\nconst merge = (left, right) => {\\n    const result = []\\n    \\n    while (left.length && right.length) {\\n        if(left[0] <= right[0]) {\\n            result.push(left.shift())\\n        } else {\\n            result.push(right.shift())\\n        }\\n    }\\n    \\n    return [...result, ...left, ...right]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783623,
                "title": "quick-sort-merge-sort-in-python-easy-to-understand-standard-template",
                "content": "**Two Methods:**\\n**1. Quick Sort**\\n**2. Merge Sort**\\n\\n**1. Standard Quick Sort Tempate**,\\n\\nIn the while loop, the reason we use \"**nums[left] < pivot**\" instead of \"nums[left] <= pivot\" is to **avoid falling into forever loop**.\\n**For example:**\\nnums = [1, 1, 1], pivot will be 1.\\nIf we use \"nums[left] <= pivot\",\\nending right index will be 2, ending left index will be 3,\\nin the next round, we still have to go through [1, 1, 1], meaning that we fall in to forever loop.\\n\\n**Time:** on average O(nlgn), worst case O(n^2)\\n**Space:** O(lgn), on average the recursion stack\\n\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return nums\\n        self.quickSort(0, len(nums) - 1, nums)\\n        return nums\\n    \\n    def quickSort(self, start, end, nums):\\n        if start >= end:\\n            return\\n        \\n        left, right = start, end\\n        pivot = nums[(left + right) // 2]\\n        \\n        while left <= right:\\n            while left <= right and nums[left] < pivot:\\n                left += 1\\n            while left <= right and nums[right] > pivot:\\n                right -= 1\\n            if left <= right:\\n                nums[left], nums[right] = nums[right], nums[left]\\n                left += 1\\n                right -= 1\\n\\n        self.quickSort(start, right, nums)\\n        self.quickSort(left, end, nums)\\n```\\n\\n**2. Standard Merge Sort Template**\\n\\nFor merge sort, I will provide **two methods:**\\nthe first one with space complexity O(nlgn),\\nthe second one with space complexity optimized to O(n).\\n\\n**Method 2.1: space complexity O(nlgn)**\\n\\n**Time:** O(nlgn)\\n**Space:** O(nlgn)\\n\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return nums\\n        self.mergeSort(0, len(nums) - 1, nums)\\n        return nums\\n    \\n    def mergeSort(self, start, end, nums):\\n        if start >= end:\\n            return \\n        \\n        middle = (start + end) // 2\\n        \\n        self.mergeSort(start, middle, nums)\\n        self.mergeSort(middle + 1, end, nums)\\n        self.merge(start, end, nums)\\n    \\n    def merge(self, start, end, nums):\\n        tmp = [0] * (end - start + 1)\\n        \\n        middle = (start + end) // 2\\n        left = start\\n        right = middle + 1\\n        index = 0\\n        \\n        while left <= middle and right <= end:\\n            if nums[left] <= nums[right]:\\n                tmp[index] = nums[left]\\n                left += 1\\n                index += 1\\n            else:\\n                tmp[index] = nums[right]\\n                right += 1\\n                index += 1\\n        \\n        while left <= middle:\\n            tmp[index] = nums[left]\\n            left += 1\\n            index += 1\\n        \\n        while right <= end:\\n            tmp[index] = nums[right]\\n            right += 1\\n            index += 1\\n        \\n        for i in range(end - start + 1):\\n            nums[i + start] = tmp[i]\\n```\\n\\n**Method 2.2: space complexity O(n)**\\n\\n**Time:** O(nlgn)\\n**Space:** O(n)\\n\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return nums\\n        tmp = [0] * len(nums)\\n        self.mergeSort(0, len(nums) - 1, nums, tmp)\\n        return nums\\n    \\n    def mergeSort(self, start, end, nums, tmp):\\n        if start >= end:\\n            return \\n        \\n        middle = (start + end) // 2\\n        \\n        self.mergeSort(start, middle, nums, tmp)\\n        self.mergeSort(middle + 1, end, nums, tmp)\\n        self.merge(start, end, nums, tmp)\\n    \\n    def merge(self, start, end, nums, tmp):\\n        \\n        middle = (start + end) // 2\\n        left = start\\n        right = middle + 1\\n        index = start\\n        \\n        while left <= middle and right <= end:\\n            if nums[left] <= nums[right]:\\n                tmp[index] = nums[left]\\n                left += 1\\n                index += 1\\n            else:\\n                tmp[index] = nums[right]\\n                right += 1\\n                index += 1\\n        \\n        while left <= middle:\\n            tmp[index] = nums[left]\\n            left += 1\\n            index += 1\\n        \\n        while right <= end:\\n            tmp[index] = nums[right]\\n            right += 1\\n            index += 1\\n        \\n        for i in range(start, end + 1):\\n            nums[i] = tmp[i]\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return nums\\n        self.quickSort(0, len(nums) - 1, nums)\\n        return nums\\n    \\n    def quickSort(self, start, end, nums):\\n        if start >= end:\\n            return\\n        \\n        left, right = start, end\\n        pivot = nums[(left + right) // 2]\\n        \\n        while left <= right:\\n            while left <= right and nums[left] < pivot:\\n                left += 1\\n            while left <= right and nums[right] > pivot:\\n                right -= 1\\n            if left <= right:\\n                nums[left], nums[right] = nums[right], nums[left]\\n                left += 1\\n                right -= 1\\n\\n        self.quickSort(start, right, nums)\\n        self.quickSort(left, end, nums)\\n```\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return nums\\n        self.mergeSort(0, len(nums) - 1, nums)\\n        return nums\\n    \\n    def mergeSort(self, start, end, nums):\\n        if start >= end:\\n            return \\n        \\n        middle = (start + end) // 2\\n        \\n        self.mergeSort(start, middle, nums)\\n        self.mergeSort(middle + 1, end, nums)\\n        self.merge(start, end, nums)\\n    \\n    def merge(self, start, end, nums):\\n        tmp = [0] * (end - start + 1)\\n        \\n        middle = (start + end) // 2\\n        left = start\\n        right = middle + 1\\n        index = 0\\n        \\n        while left <= middle and right <= end:\\n            if nums[left] <= nums[right]:\\n                tmp[index] = nums[left]\\n                left += 1\\n                index += 1\\n            else:\\n                tmp[index] = nums[right]\\n                right += 1\\n                index += 1\\n        \\n        while left <= middle:\\n            tmp[index] = nums[left]\\n            left += 1\\n            index += 1\\n        \\n        while right <= end:\\n            tmp[index] = nums[right]\\n            right += 1\\n            index += 1\\n        \\n        for i in range(end - start + 1):\\n            nums[i + start] = tmp[i]\\n```\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return nums\\n        tmp = [0] * len(nums)\\n        self.mergeSort(0, len(nums) - 1, nums, tmp)\\n        return nums\\n    \\n    def mergeSort(self, start, end, nums, tmp):\\n        if start >= end:\\n            return \\n        \\n        middle = (start + end) // 2\\n        \\n        self.mergeSort(start, middle, nums, tmp)\\n        self.mergeSort(middle + 1, end, nums, tmp)\\n        self.merge(start, end, nums, tmp)\\n    \\n    def merge(self, start, end, nums, tmp):\\n        \\n        middle = (start + end) // 2\\n        left = start\\n        right = middle + 1\\n        index = start\\n        \\n        while left <= middle and right <= end:\\n            if nums[left] <= nums[right]:\\n                tmp[index] = nums[left]\\n                left += 1\\n                index += 1\\n            else:\\n                tmp[index] = nums[right]\\n                right += 1\\n                index += 1\\n        \\n        while left <= middle:\\n            tmp[index] = nums[left]\\n            left += 1\\n            index += 1\\n        \\n        while right <= end:\\n            tmp[index] = nums[right]\\n            right += 1\\n            index += 1\\n        \\n        for i in range(start, end + 1):\\n            nums[i] = tmp[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153533,
                "title": "merge-sort-java",
                "content": "```\\n    public int[] sortArray(int[] nums) {\\n     mergesort(nums, 0, nums.length-1);\\n     return nums;\\n    }\\n\\t\\n    public void mergesort(int[] nums, int start, int end){\\n        if(start < end){\\n            int mid = (start + end) / 2;\\n            mergesort(nums, start, mid);\\n            mergesort(nums, mid+1, end);\\n            merge(nums, start, mid, end);\\n        }\\n    }\\n    \\n    public void merge(int[] nums, int start, int mid, int end){\\n    int i= start,  j= mid+1, k=0;\\n    int[] temp = new int[end-start+1];\\n    while( i <= mid && j<= end)\\n    {\\n        if (nums[i] < nums[j])\\n            temp[k++] = nums[i++];\\n        else\\n            temp[k++] = nums[j++];\\n    }\\n    while (i <= mid) { temp[k++] = nums[i++]; } //copy remaining elements\\n    while (j <= end) { temp[k++] = nums[j++]; } //copy remaining elements\\n    for (int pointer = start; pointer <= end; pointer++){\\n        nums[pointer] = temp[pointer-start];\\n    }\\n  }",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\n    public int[] sortArray(int[] nums) {\\n     mergesort(nums, 0, nums.length-1);\\n     return nums;\\n    }\\n\\t\\n    public void mergesort(int[] nums, int start, int end){\\n        if(start < end){\\n            int mid = (start + end) / 2;\\n            mergesort(nums, start, mid);\\n            mergesort(nums, mid+1, end);\\n            merge(nums, start, mid, end);\\n        }\\n    }\\n    \\n    public void merge(int[] nums, int start, int mid, int end){\\n    int i= start,  j= mid+1, k=0;\\n    int[] temp = new int[end-start+1];\\n    while( i <= mid && j<= end)\\n    {\\n        if (nums[i] < nums[j])\\n            temp[k++] = nums[i++];\\n        else\\n            temp[k++] = nums[j++];\\n    }\\n    while (i <= mid) { temp[k++] = nums[i++]; } //copy remaining elements\\n    while (j <= end) { temp[k++] = nums[j++]; } //copy remaining elements\\n    for (int pointer = start; pointer <= end; pointer++){\\n        nums[pointer] = temp[pointer-start];\\n    }\\n  }",
                "codeTag": "Unknown"
            },
            {
                "id": 670909,
                "title": "javascript-quick-sort-faster-than-95",
                "content": "\\tvar sortArray = function(nums) {\\n\\t\\tlet len = nums.length;\\n\\t\\tif(len < 2) return nums;\\n\\n\\t\\tquickSort(nums, 0, len-1)\\n\\t\\treturn nums\\n\\t};\\n\\n\\tvar quickSort = function(nums, start, end){\\n\\t\\tif(start >= end) return\\n\\t\\tlet left = start, right = end;\\n\\t\\tlet pivot = nums[Math.floor((start+end) / 2)];\\n\\t\\twhile(left <= right) {\\n\\t\\t\\twhile(left <= right && nums[left] < pivot){\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t}\\n\\t\\t\\twhile(left <= right && nums[right] > pivot){\\n\\t\\t\\t\\tright--\\n\\t\\t\\t}\\n\\t\\t\\tif(left <= right){\\n\\t\\t\\t\\tlet temp = nums[left]\\n\\t\\t\\t\\tnums[left] = nums[right]\\n\\t\\t\\t\\tnums[right] = temp\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t\\tright--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tquickSort(nums, start, right)\\n\\t\\tquickSort(nums, left, end)\\n\\t}",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "\\tvar sortArray = function(nums) {\\n\\t\\tlet len = nums.length;\\n\\t\\tif(len < 2) return nums;\\n\\n\\t\\tquickSort(nums, 0, len-1)\\n\\t\\treturn nums\\n\\t};\\n\\n\\tvar quickSort = function(nums, start, end){\\n\\t\\tif(start >= end) return\\n\\t\\tlet left = start, right = end;\\n\\t\\tlet pivot = nums[Math.floor((start+end) / 2)];\\n\\t\\twhile(left <= right) {\\n\\t\\t\\twhile(left <= right && nums[left] < pivot){\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t}\\n\\t\\t\\twhile(left <= right && nums[right] > pivot){\\n\\t\\t\\t\\tright--\\n\\t\\t\\t}\\n\\t\\t\\tif(left <= right){\\n\\t\\t\\t\\tlet temp = nums[left]\\n\\t\\t\\t\\tnums[left] = nums[right]\\n\\t\\t\\t\\tnums[right] = temp\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t\\tright--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tquickSort(nums, start, right)\\n\\t\\tquickSort(nums, left, end)\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 556873,
                "title": "java-quick-sort",
                "content": "```\\n    public int[] sortArray(int[] nums) {\\n    \\tQuickSort(nums, 0, nums.length - 1);\\n    \\tint result[] = new int[nums.length]; \\n        for (int i = 0; i < nums.length; i++) {\\n        \\tresult[i] = nums[i];\\n        }\\n        return result;\\n    }\\n    \\n    public static void QuickSort(int nums[], int lhs, int rhs) {\\n    \\tif(lhs >= rhs) return; \\n\\t\\tint mid = Partition(nums, lhs, rhs);\\n\\t\\tQuickSort(nums, lhs, mid);\\n\\t\\tQuickSort(nums, mid + 1, rhs);\\n    }\\n    \\n    public static void Swap(int[] nums, int lhs, int rhs) {\\n    \\tint temp = nums[lhs];\\n    \\tnums[lhs] = nums[rhs]; \\n    \\tnums[rhs] = temp;\\n    }\\n    \\n    public static int Partition(int[] nums, int lhs, int rhs) {\\n    \\tint pivot = nums[lhs];\\n    \\twhile(lhs < rhs) {\\n            while (lhs < rhs && nums[rhs] >= pivot) rhs--;\\n            Swap(nums, lhs, rhs);\\n            while (lhs < rhs && nums[lhs] <= pivot) lhs++;\\n            Swap(nums, rhs, lhs);\\n    \\t}\\n    \\tnums[lhs] = pivot;\\n    \\treturn lhs;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] sortArray(int[] nums) {\\n    \\tQuickSort(nums, 0, nums.length - 1);\\n    \\tint result[] = new int[nums.length]; \\n        for (int i = 0; i < nums.length; i++) {\\n        \\tresult[i] = nums[i];\\n        }\\n        return result;\\n    }\\n    \\n    public static void QuickSort(int nums[], int lhs, int rhs) {\\n    \\tif(lhs >= rhs) return; \\n\\t\\tint mid = Partition(nums, lhs, rhs);\\n\\t\\tQuickSort(nums, lhs, mid);\\n\\t\\tQuickSort(nums, mid + 1, rhs);\\n    }\\n    \\n    public static void Swap(int[] nums, int lhs, int rhs) {\\n    \\tint temp = nums[lhs];\\n    \\tnums[lhs] = nums[rhs]; \\n    \\tnums[rhs] = temp;\\n    }\\n    \\n    public static int Partition(int[] nums, int lhs, int rhs) {\\n    \\tint pivot = nums[lhs];\\n    \\twhile(lhs < rhs) {\\n            while (lhs < rhs && nums[rhs] >= pivot) rhs--;\\n            Swap(nums, lhs, rhs);\\n            while (lhs < rhs && nums[lhs] <= pivot) lhs++;\\n            Swap(nums, rhs, lhs);\\n    \\t}\\n    \\tnums[lhs] = pivot;\\n    \\treturn lhs;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 456182,
                "title": "bottom-up-iterative-merge-sort-in-python",
                "content": "```\\nclass Solution(object):\\n    def sortArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        prev = [[n] for n in nums]\\n        while len(prev) > 1:\\n            cur = []\\n            for i in range(0, len(prev), 2):\\n                cur.append(self.merge(prev[i], prev[i+1] if i+1<len(prev) else []))   \\n            prev = cur\\n        return prev[0]\\n    \\n            \\n    def merge(self, l1, l2):\\n        merged = []\\n        i1 = i2 = 0\\n        while i1 < len(l1) and i2 < len(l2):\\n            if l1[i1] < l2[i2]:\\n                merged.append(l1[i1])\\n                i1 += 1\\n            else:\\n                merged.append(l2[i2])\\n                i2 += 1\\n        merged.extend(l1[i1:])\\n        merged.extend(l2[i2:])\\n        return merged\\n```",
                "solutionTags": [
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def sortArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        prev = [[n] for n in nums]\\n        while len(prev) > 1:\\n            cur = []\\n            for i in range(0, len(prev), 2):\\n                cur.append(self.merge(prev[i], prev[i+1] if i+1<len(prev) else []))   \\n            prev = cur\\n        return prev[0]\\n    \\n            \\n    def merge(self, l1, l2):\\n        merged = []\\n        i1 = i2 = 0\\n        while i1 < len(l1) and i2 < len(l2):\\n            if l1[i1] < l2[i2]:\\n                merged.append(l1[i1])\\n                i1 += 1\\n            else:\\n                merged.append(l2[i2])\\n                i2 += 1\\n        merged.extend(l1[i1:])\\n        merged.extend(l2[i2:])\\n        return merged\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281685,
                "title": "quicksort-java",
                "content": "```java\\nint[] A;\\nint[] sortArray(int[] A) {\\n\\tthis.A = A;\\n\\tsort(0, A.length - 1);\\n\\treturn A;\\n}\\nvoid sort(int l, int r) {\\n\\tif (l >= r) return;\\n\\tint p = part(l, r);\\n\\tsort(l, p - 1);\\n\\tsort(p + 1, r);\\n}\\nint part(int l, int r) {\\n\\tint p = A[r];\\n\\tint i = l - 1;\\n\\tfor (int j = i + 1; j < r; ++j)\\n\\t\\tif (A[j] < p)\\n\\t\\t\\tswap(++i, j);\\n\\tswap(i + 1, r);\\n\\treturn i + 1;\\n}\\nvoid swap(int i, int j) {\\n\\tint t = A[i];\\n\\tA[i] = A[j];\\n\\tA[j] = t;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nint[] A;\\nint[] sortArray(int[] A) {\\n\\tthis.A = A;\\n\\tsort(0, A.length - 1);\\n\\treturn A;\\n}\\nvoid sort(int l, int r) {\\n\\tif (l >= r) return;\\n\\tint p = part(l, r);\\n\\tsort(l, p - 1);\\n\\tsort(p + 1, r);\\n}\\nint part(int l, int r) {\\n\\tint p = A[r];\\n\\tint i = l - 1;\\n\\tfor (int j = i + 1; j < r; ++j)\\n\\t\\tif (A[j] < p)\\n\\t\\t\\tswap(++i, j);\\n\\tswap(i + 1, r);\\n\\treturn i + 1;\\n}\\nvoid swap(int i, int j) {\\n\\tint t = A[i];\\n\\tA[i] = A[j];\\n\\tA[j] = t;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1160938,
                "title": "c-easy-merge-sort",
                "content": "\\n    \\n    void merge(vector<int>& nums, int l, int m, int r)\\n    {\\n        int n1 = m - l + 1;\\n        int n2 = r - m;\\n        int A[n1], B[n2];\\n        \\n        for(int i = 0; i < n1; i++)\\n            A[i] = nums[l + i];\\n        \\n        for(int i = 0; i < n2; i++)\\n            B[i] = nums[m + 1 + i];\\n        \\n        int i = 0, j = 0;\\n        int k = l;\\n        \\n        while(i < n1 && j < n2)\\n        {\\n            if(A[i] <= B[j])\\n                nums[k++] = A[i++];\\n            else\\n                nums[k++] = B[j++];\\n        }\\n        \\n        while(i < n1)\\n            nums[k++] = A[i++];\\n        while(j < n2)\\n            nums[k++] = B[j++];\\n    }\\n    \\n    void mergeSort(vector<int>& nums, int l, int r)\\n    {\\n        if(l >= r)  //remember to put the equal to sign\\n            return;\\n        \\n        int m = l + (r - l)/2;\\n        mergeSort(nums, l, m);\\n        mergeSort(nums, m + 1, r);\\n        merge(nums, l, m, r);\\n    }\\n    \\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n        mergeSort(nums, 0, nums.size() - 1);\\n        return nums;\\n    }  \\n    \\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Merge Sort"
                ],
                "code": "\\n    \\n    void merge(vector<int>& nums, int l, int m, int r)\\n    {\\n        int n1 = m - l + 1;\\n        int n2 = r - m;\\n        int A[n1], B[n2];\\n        \\n        for(int i = 0; i < n1; i++)\\n            A[i] = nums[l + i];\\n        \\n        for(int i = 0; i < n2; i++)\\n            B[i] = nums[m + 1 + i];\\n        \\n        int i = 0, j = 0;\\n        int k = l;\\n        \\n        while(i < n1 && j < n2)\\n        {\\n            if(A[i] <= B[j])\\n                nums[k++] = A[i++];\\n            else\\n                nums[k++] = B[j++];\\n        }\\n        \\n        while(i < n1)\\n            nums[k++] = A[i++];\\n        while(j < n2)\\n            nums[k++] = B[j++];\\n    }\\n    \\n    void mergeSort(vector<int>& nums, int l, int r)\\n    {\\n        if(l >= r)  //remember to put the equal to sign\\n            return;\\n        \\n        int m = l + (r - l)/2;\\n        mergeSort(nums, l, m);\\n        mergeSort(nums, m + 1, r);\\n        merge(nums, l, m, r);\\n    }\\n    \\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n        mergeSort(nums, 0, nums.size() - 1);\\n        return nums;\\n    }  \\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3263829,
                "title": "sorting-using-merge-sort-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nin the Given Problem , We have to sort an array.\\nTo Sort an array these are the most common algorithms : \\n\\n(1) Bubble Sort\\n--------------------------------------------------------------\\n- Approach : switches neighbouring parts frequently if the wrong order is given. The fundamental principle of Bubble Sort is to iteratively scan the array, compare nearby members, and swap out any that are out of order. Up till the full array is sorted, this procedure is repeated.\\n- Time Complexity : O(n^2).\\n- Space Complexty : O(1).\\n\\n(2) Selection Sort \\n---------------------------------------------------------------\\n- Approach : finding the minimum element from the unsorted part of the array and putting it at the beginning of the sorted part.\\n- Time Complexity : O(n^2).\\n- Space Complexity : O(1).\\n\\n(3) Quick Sort \\n--------------------------------------------------------------------\\n- Approach : divide-and-conquer approach to sort an array. The basic idea of Quick Sort is to divide the array into two smaller sub-arrays around a pivot element, and recursively sort these sub-arrays until the entire array is sorted.\\n- Time Complexity :\\n(i) Best and Average Case : O(nlogn).\\n(ii) Worst Case : O(n^2).\\n(iii) Space Complexty : O(n).\\n\\nThese are the most common sorting algorithms; however, we may also sort an array whose time complexity is \"O(nlogn)\" directly using the C++ STL \"sort()\" function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the Given Problems , I use Merge Sort Algorithm to Sort an array which uses Divide and Conquer Approach :) \\n\\nMerge Sort : This algorithms works by dividing an array into smaller subarray , sorting each subarray and then merging the sorted subarray back together to form the final sorted array.\\n\\n- Pseudo Code\\n(1) Declaring the variables \"low\" and \"high,\" which serve as the array\\'s beginning and ending points where low=0 and high=len(array)-1.\\n(2) Calculate mid using \"(low+high)/2\" or \"low+(high-low)/2\".\\n(3) Call the \"MergeSort()\" function on the part (low,mid) and (mid+1,high).\\n(4) The above Call will continue till \"low<high\" is satisfied.\\n(5) Finally Call \"Merge\" function to merge thse two halves.\\n\\n# Complexity\\n- Time complexity: O(nlogn) { Best , Average and Worst Case }.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void Merge(vector<int>& arr,int left,int mid,int right){\\n\\n        if(left>=right){\\n            return;\\n        }\\n\\n        int len=right-left+1;\\n        vector<int> temp(len,0);\\n        int i=left;\\n        int j=mid+1;\\n        int k=0;\\n\\n        while(i<=mid && j<=right){\\n\\n            if(arr[i]<arr[j]){\\n                temp[k++]=arr[i++];\\n            }\\n\\n            else{\\n                temp[k++]=arr[j++];\\n            }\\n        }\\n\\n        while(i<=mid){\\n            temp[k++]=arr[i++];\\n        }\\n\\n        while(j<=right){\\n            temp[k++]=arr[j++];\\n        }\\n\\n        for(k=0;k<len;k++){\\n            arr[k+left]=temp[k];\\n        }\\n\\n    }\\n\\n    void MergeSort(vector<int>& arr,int left,int right){\\n\\n        if(left>=right){\\n            return;\\n        }\\n\\n        int mid=(left+(right-left)/2);\\n        MergeSort(arr,left,mid);\\n        MergeSort(arr,mid+1,right);\\n        Merge(arr,left,mid,right);\\n\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        // Using Merge Sort to Sort the array \\n        // Time Complexity --> O(nlogn) \\n        // Space Complexity --> O(n)\\n        int left=0;\\n        int right=nums.size()-1;\\n        MergeSort(nums,left,right);\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void Merge(vector<int>& arr,int left,int mid,int right){\\n\\n        if(left>=right){\\n            return;\\n        }\\n\\n        int len=right-left+1;\\n        vector<int> temp(len,0);\\n        int i=left;\\n        int j=mid+1;\\n        int k=0;\\n\\n        while(i<=mid && j<=right){\\n\\n            if(arr[i]<arr[j]){\\n                temp[k++]=arr[i++];\\n            }\\n\\n            else{\\n                temp[k++]=arr[j++];\\n            }\\n        }\\n\\n        while(i<=mid){\\n            temp[k++]=arr[i++];\\n        }\\n\\n        while(j<=right){\\n            temp[k++]=arr[j++];\\n        }\\n\\n        for(k=0;k<len;k++){\\n            arr[k+left]=temp[k];\\n        }\\n\\n    }\\n\\n    void MergeSort(vector<int>& arr,int left,int right){\\n\\n        if(left>=right){\\n            return;\\n        }\\n\\n        int mid=(left+(right-left)/2);\\n        MergeSort(arr,left,mid);\\n        MergeSort(arr,mid+1,right);\\n        Merge(arr,left,mid,right);\\n\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        // Using Merge Sort to Sort the array \\n        // Time Complexity --> O(nlogn) \\n        // Space Complexity --> O(n)\\n        int left=0;\\n        int right=nums.size()-1;\\n        MergeSort(nums,left,right);\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449667,
                "title": "c-quick-sort-merge-sort-visual-explanation",
                "content": "**Quick sort**\\nThis works just like how a preorder tree  traversal does. Here I use Lomuto partition scheme.\\n1. For each recursion call, get one element sorted as pivot. \\n2. Recurse on the left part and the right part\\n\\n![image](https://assets.leetcode.com/users/images/9acbc10c-aa20-43f3-987e-9d99f0b202dd_1660923159.2145824.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/d5986c92-ae7c-4db3-ba91-f5aecefb1d2b_1660923159.3761039.jpeg)\\n\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        QuicksortHelper(nums, 0, size(nums) - 1);\\n        return nums;\\n    }\\nprivate:\\n    int Partition(vector<int>& nums, int left, int right) {\\n\\t    // To avoid TLE, take the element in the middle as the pivot\\n\\t\\t// Would be even better to use a random element\\n        int mid = left + (right - left) / 2;\\n        swap(nums[mid], nums[right]);\\n\\t\\t\\n        int pivot = nums[right];\\n        int j = left;\\n        for (int i = left; i < right; ++i) {\\n            if (nums[i] < pivot) {\\n                std::swap(nums[i], nums[j]);\\n                ++j;\\n            }\\n        }\\n        std::swap(nums[j], nums[right]);\\n        return j;\\n    }\\n    \\n    void QuicksortHelper(vector<int>& nums, int left, int right) {\\n        if (left >= right) {\\n            return;\\n        }\\n        int pivot_index = Partition(nums, left, right);\\n        QuicksortHelper(nums, left, pivot_index - 1);\\n        QuicksortHelper(nums, pivot_index + 1, right);\\n    }\\n};\\n```\\n\\n\\n\\n**Merge sort**\\nThis works like a postorder tree traversal.\\n1. Keep dividing the array in half until only a single element is left.\\n2. Start merging pairs of sorted arrays.\\n\\n![image](https://assets.leetcode.com/users/images/1bf92d85-869a-45bd-9741-86302337096f_1660923170.3856132.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/abdf53ac-7e9b-4144-a751-fc16b7272d34_1660923170.0152829.jpeg)\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        MergesortHelper(nums, 0, size(nums) - 1);\\n        return nums;\\n    }\\nprivate:\\n    void MergeTwoSortedArray(vector<int>& nums, int left, int mid, int right) {\\n        vector<int> sorted;\\n        sorted.reserve(right - left + 1);\\n        \\n        int k = 0;\\n        int i = left;\\n        int j = mid + 1;\\n        \\n        while (i <= mid && j <= right) {\\n            if (nums[i] < nums[j]) {\\n                sorted[k++] = nums[i++];\\n            } else {\\n                sorted[k++] = nums[j++];\\n            }\\n        }\\n        \\n        while (i <= mid) {\\n            sorted[k++] = nums[i++];\\n        }\\n        \\n        while (j <= right) {\\n            sorted[k++] = nums[j++];\\n        }\\n        \\n        while (--k >= 0) {\\n            nums[right--] = sorted[k];\\n        }\\n    }\\n    \\n    void MergesortHelper(vector<int>& nums, int left, int right) {\\n        if (left == right) {\\n            return;\\n        }\\n        int mid = left + (right - left) / 2;\\n        MergesortHelper(nums, left, mid);\\n        MergesortHelper(nums, mid + 1, right);\\n        MergeTwoSortedArray(nums, left, mid, right);\\n    }\\n};\\n```\\n\\nPlease let me know if anything could be improved. Happy coding!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        QuicksortHelper(nums, 0, size(nums) - 1);\\n        return nums;\\n    }\\nprivate:\\n    int Partition(vector<int>& nums, int left, int right) {\\n\\t    // To avoid TLE, take the element in the middle as the pivot\\n\\t\\t// Would be even better to use a random element\\n        int mid = left + (right - left) / 2;\\n        swap(nums[mid], nums[right]);\\n\\t\\t\\n        int pivot = nums[right];\\n        int j = left;\\n        for (int i = left; i < right; ++i) {\\n            if (nums[i] < pivot) {\\n                std::swap(nums[i], nums[j]);\\n                ++j;\\n            }\\n        }\\n        std::swap(nums[j], nums[right]);\\n        return j;\\n    }\\n    \\n    void QuicksortHelper(vector<int>& nums, int left, int right) {\\n        if (left >= right) {\\n            return;\\n        }\\n        int pivot_index = Partition(nums, left, right);\\n        QuicksortHelper(nums, left, pivot_index - 1);\\n        QuicksortHelper(nums, pivot_index + 1, right);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        MergesortHelper(nums, 0, size(nums) - 1);\\n        return nums;\\n    }\\nprivate:\\n    void MergeTwoSortedArray(vector<int>& nums, int left, int mid, int right) {\\n        vector<int> sorted;\\n        sorted.reserve(right - left + 1);\\n        \\n        int k = 0;\\n        int i = left;\\n        int j = mid + 1;\\n        \\n        while (i <= mid && j <= right) {\\n            if (nums[i] < nums[j]) {\\n                sorted[k++] = nums[i++];\\n            } else {\\n                sorted[k++] = nums[j++];\\n            }\\n        }\\n        \\n        while (i <= mid) {\\n            sorted[k++] = nums[i++];\\n        }\\n        \\n        while (j <= right) {\\n            sorted[k++] = nums[j++];\\n        }\\n        \\n        while (--k >= 0) {\\n            nums[right--] = sorted[k];\\n        }\\n    }\\n    \\n    void MergesortHelper(vector<int>& nums, int left, int right) {\\n        if (left == right) {\\n            return;\\n        }\\n        int mid = left + (right - left) / 2;\\n        MergesortHelper(nums, left, mid);\\n        MergesortHelper(nums, mid + 1, right);\\n        MergeTwoSortedArray(nums, left, mid, right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909420,
                "title": "accepted-python-quick-sort-solution-beats-93",
                "content": "Have to compromise with space to knock off the leetcode acceptance. \\nTime: O(NlogN)\\nSpace: O(N^2)\\n\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        def quicksort(nums):\\n            if len(nums) <= 1: return nums\\n            \\n            #picking a random pivot\\n            pivot = random.choice(nums)\\n            less_than, equal_to, greater_than = [], [], []\\n            \\n            for val in nums:\\n                if val < pivot: less_than.append(val)\\n                elif val > pivot: greater_than.append(val)\\n                else: equal_to.append(val)\\n            return quicksort(less_than) + equal_to + quicksort(greater_than)\\n        return quicksort(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        def quicksort(nums):\\n            if len(nums) <= 1: return nums\\n            \\n            #picking a random pivot\\n            pivot = random.choice(nums)\\n            less_than, equal_to, greater_than = [], [], []\\n            \\n            for val in nums:\\n                if val < pivot: less_than.append(val)\\n                elif val > pivot: greater_than.append(val)\\n                else: equal_to.append(val)\\n            return quicksort(less_than) + equal_to + quicksort(greater_than)\\n        return quicksort(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425266,
                "title": "just-using-simple-recursion-to-sort-the-array",
                "content": "Although this will not pass all test cases but still this is the most fundamental way to sort the array using recursion\\n```\\n    vector<int> insertAT(vector<int> &V, int val) {\\n      int len = V.size(); \\n      if((len == 0) || (V[len-1] <= val)) {\\n        V.push_back(val); return V;\\n      }\\n\\n      int last = V[len-1]; \\n      V.pop_back(); \\n      insertAT(V, val);\\n      V.push_back(last);\\n      return V;\\n    }\\n\\n    vector<int> sortArray(vector<int> &V) {\\n      if(V.size() == 1) return V;\\n\\n      int last = V[V.size() - 1];\\n      V.pop_back();\\n      vector<int> temp = sortArray(V);\\n      vector<int> sorted = insertAT(temp, last);\\n      return sorted;\\n    }\\n```",
                "solutionTags": [
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\n    vector<int> insertAT(vector<int> &V, int val) {\\n      int len = V.size(); \\n      if((len == 0) || (V[len-1] <= val)) {\\n        V.push_back(val); return V;\\n      }\\n\\n      int last = V[len-1]; \\n      V.pop_back(); \\n      insertAT(V, val);\\n      V.push_back(last);\\n      return V;\\n    }\\n\\n    vector<int> sortArray(vector<int> &V) {\\n      if(V.size() == 1) return V;\\n\\n      int last = V[V.size() - 1];\\n      V.pop_back();\\n      vector<int> temp = sortArray(V);\\n      vector<int> sorted = insertAT(temp, last);\\n      return sorted;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488388,
                "title": "classical-sorting-algorithms-java-some-with-detailed-explanations",
                "content": "**1. Quick Sort**\\n```\\n\\tclass Solution {\\n\\n\\t\\tpublic int[] sortArray(int[] nums) {\\n\\t\\t\\tquickSort(nums, 0, nums.length - 1);\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\n\\t\\tpublic void quickSort(int[] nums, int start, int end) {\\n\\t\\t\\t// if the start index is larger or equal to the end index, the sort of the subarray is finished\\n\\t\\t\\tif (start >= end) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tint pivot = partition(nums, start, end);\\n\\t\\t\\t// recursively sort the subarray\\n\\t\\t\\tquickSort(nums, start, pivot - 1);\\n\\t\\t\\tquickSort(nums, pivot + 1, end);\\n\\t\\t}\\n\\n\\t\\t/** \\n\\t\\t *  This function takes last element as pivot, places the pivot element at its correct position in sorted array,\\n\\t\\t *  and places all smaller (smaller than pivot) to left of pivot and all greater elements to right of pivot \\n\\t\\t **/\\n\\t\\tpublic int partition(int[] nums, int start, int end) {\\n\\t\\t\\t// choose the number in the middle as the base and swap it with the first number in the subarray\\n\\t\\t\\tswap(nums, start, start + (end - start) / 2);\\n\\t\\t\\tint base = nums[start];\\n\\t\\t\\t// swap every number that is less than the base to the front of the subarray\\n\\t\\t\\tint i = start + 1;\\n\\t\\t\\tint j = i;\\n\\t\\t\\twhile (i <= end) {\\n\\t\\t\\t\\tif (nums[i] < base) {\\n\\t\\t\\t\\t\\tswap(nums, i, j++);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\t// after the iteration the numbers from index start+1 to index j-1 are less than the base\\n\\t\\t\\t// swap the number on index j-1 with the base\\n\\t\\t\\t// the first j-2 numbers are less than the base\\n\\t\\t\\t// the number on index j-1 is the base\\n\\t\\t\\t// numbers after index j-1 are larger or equal to the base\\n\\t\\t\\tswap(nums, j - 1, start);\\n\\t\\t\\treturn j - 1;\\n\\t\\t}\\n\\n\\t\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\t\\tint temp = nums[i];\\n\\t\\t\\tnums[i] = nums[j];\\n\\t\\t\\tnums[j] = temp;\\n\\t\\t}\\n\\n\\t}\\n```\\n\\n**2. Merge Sort**\\n```\\n\\tclass Solution {\\n\\n\\t\\tpublic int[] sortArray(int[] nums) {\\n\\t\\t\\tmergeSort(nums, 0, nums.length - 1);\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\n\\t\\tpublic void mergeSort(int[] nums, int start, int end) {\\n\\t\\t\\t// if the start index is larger or equal to the end index, the sort of the subarray is finished\\n\\t\\t\\tif (start >= end) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tint mid = start + (end - start) / 2;\\n\\t\\t\\tmergeSort(nums, start, mid);\\n\\t\\t\\tmergeSort(nums, mid + 1, end);\\n\\t\\t\\tmerge(nums, start, end);\\n\\t\\t}\\n\\n\\t\\tpublic void merge(int[] nums, int start, int end) {\\n\\t\\t\\tint mid = start + (end - start) / 2;\\n\\t\\t\\tint[] temp = new int[end - start + 1];\\n\\t\\t\\tint leftStart = start;\\n\\t\\t\\tint leftEnd = mid;\\n\\t\\t\\tint rightStart = mid + 1;\\n\\t\\t\\tint rightEnd = end;\\n\\t\\t\\tint i = 0;\\n\\t\\t\\twhile (leftStart <= leftEnd && rightStart <= rightEnd) {\\n\\t\\t\\t\\tif (nums[leftStart] <= nums[rightStart]) {\\n\\t\\t\\t\\t\\ttemp[i] = nums[leftStart];\\n\\t\\t\\t\\t\\tleftStart++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttemp[i] = nums[rightStart];\\n\\t\\t\\t\\t\\trightStart++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\twhile (leftStart <= leftEnd) {\\n\\t\\t\\t\\ttemp[i] = nums[leftStart];\\n\\t\\t\\t\\tleftStart++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\twhile (rightStart <= rightEnd) {\\n\\t\\t\\t\\ttemp[i] = nums[rightStart];\\n\\t\\t\\t\\trightStart++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tnums[start + j] = temp[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\t\\tint temp = nums[i];\\n\\t\\t\\tnums[i] = nums[j];\\n\\t\\t\\tnums[j] = temp;\\n\\t\\t}\\n\\n\\t}\\n```\\n\\n**3. Bubble Sort [Time Limit Exceeded]**\\n```\\n\\tclass Solution {\\n\\n\\t\\tpublic int[] sortArray(int[] nums) {\\n\\t\\t\\tfor (int i = 0; i < nums.length - 1; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < nums.length - i - 1; j++) {\\n\\t\\t\\t\\t\\tif (nums[j + 1] < nums[j]) {\\n\\t\\t\\t\\t\\t\\tswap(nums, j, j + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\n\\t\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\t\\tnums[i] = nums[i] ^ nums[j];\\n\\t\\t\\tnums[j] = nums[i] ^ nums[j];\\n\\t\\t\\tnums[i] = nums[i] ^ nums[j];\\n\\t\\t}\\n\\n\\t}\\n```\\n\\n**4. Selection Sort [Time Limit Exceeded]**\\n```\\n\\tpublic class Solution {\\n\\n\\t\\tpublic int[] sortArray(int[] nums) {\\n\\t\\t\\tif (nums.length <= 1) {\\n\\t\\t\\t\\treturn nums;\\n\\t\\t\\t}\\n\\t\\t\\tint[] res = new int[nums.length];\\n\\t\\t\\tInteger size = 0;\\n\\t\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\t\\tint min = nums[size];\\n\\t\\t\\t\\tint minIndex = size;\\n\\t\\t\\t\\tfor (int j = nums.length - 1; j > size; j--) {\\n\\t\\t\\t\\t\\tif (nums[j] < min) {\\n\\t\\t\\t\\t\\t\\tmin = nums[j];\\n\\t\\t\\t\\t\\t\\tminIndex = j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres[size] = min;\\n\\t\\t\\t\\tswap(nums, minIndex, size);\\n\\t\\t\\t\\tsize++;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\t\\tnums[i] = nums[i] ^ nums[j];\\n\\t\\t\\tnums[j] = nums[i] ^ nums[j];\\n\\t\\t\\tnums[i] = nums[i] ^ nums[j];\\n\\t\\t}\\n\\n\\t}\\n```\\n\\n**5. Heap Sort**\\n```\\n\\tclass Solution {\\n\\t\\tpublic int[] sortArray(int[] nums) {\\n\\t\\t\\tif (nums == null || nums.length < 2) {\\n\\t\\t\\t\\treturn nums;\\n\\t\\t\\t}\\n\\t\\t\\theapSort(nums);\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\n\\t\\tprivate void heapSort(int[] nums) {\\n\\t\\t\\tfor (int i = nums.length / 2; i >= 0; i--) {\\n\\t\\t\\t\\theapify(nums, i, nums.length - 1);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\t\\tswap(nums, 0, nums.length - 1 - i);\\n\\t\\t\\t\\theapify(nums, 0, nums.length - 2 - i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate void heapify(int[] nums, int start, int end) {\\n\\t\\t\\twhile (start <= end) {\\n\\t\\t\\t\\tint l = 2 * start + 1;\\n\\t\\t\\t\\tint r = 2 * start + 2;\\n\\t\\t\\t\\tint maxIndex = start;\\n\\t\\t\\t\\tif (l <= end && nums[l] > nums[maxIndex]) {\\n\\t\\t\\t\\t\\tmaxIndex = l;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (r <= end && nums[r] > nums[maxIndex]) {\\n\\t\\t\\t\\t\\tmaxIndex = r;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (maxIndex == start) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tswap(nums, start, maxIndex);\\n\\t\\t\\t\\tstart = maxIndex;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\t\\tint tmp = nums[i];\\n\\t\\t\\tnums[i] = nums[j];\\n\\t\\t\\tnums[j] = tmp;\\n\\t\\t}\\n\\t}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```\\n\\tclass Solution {\\n\\n\\t\\tpublic int[] sortArray(int[] nums) {\\n\\t\\t\\tquickSort(nums, 0, nums.length - 1);\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\n\\t\\tpublic void quickSort(int[] nums, int start, int end) {\\n\\t\\t\\t// if the start index is larger or equal to the end index, the sort of the subarray is finished\\n\\t\\t\\tif (start >= end) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tint pivot = partition(nums, start, end);\\n\\t\\t\\t// recursively sort the subarray\\n\\t\\t\\tquickSort(nums, start, pivot - 1);\\n\\t\\t\\tquickSort(nums, pivot + 1, end);\\n\\t\\t}\\n\\n\\t\\t/** \\n\\t\\t *  This function takes last element as pivot, places the pivot element at its correct position in sorted array,\\n\\t\\t *  and places all smaller (smaller than pivot) to left of pivot and all greater elements to right of pivot \\n\\t\\t **/\\n\\t\\tpublic int partition(int[] nums, int start, int end) {\\n\\t\\t\\t// choose the number in the middle as the base and swap it with the first number in the subarray\\n\\t\\t\\tswap(nums, start, start + (end - start) / 2);\\n\\t\\t\\tint base = nums[start];\\n\\t\\t\\t// swap every number that is less than the base to the front of the subarray\\n\\t\\t\\tint i = start + 1;\\n\\t\\t\\tint j = i;\\n\\t\\t\\twhile (i <= end) {\\n\\t\\t\\t\\tif (nums[i] < base) {\\n\\t\\t\\t\\t\\tswap(nums, i, j++);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\t// after the iteration the numbers from index start+1 to index j-1 are less than the base\\n\\t\\t\\t// swap the number on index j-1 with the base\\n\\t\\t\\t// the first j-2 numbers are less than the base\\n\\t\\t\\t// the number on index j-1 is the base\\n\\t\\t\\t// numbers after index j-1 are larger or equal to the base\\n\\t\\t\\tswap(nums, j - 1, start);\\n\\t\\t\\treturn j - 1;\\n\\t\\t}\\n\\n\\t\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\t\\tint temp = nums[i];\\n\\t\\t\\tnums[i] = nums[j];\\n\\t\\t\\tnums[j] = temp;\\n\\t\\t}\\n\\n\\t}\\n```\n```\\n\\tclass Solution {\\n\\n\\t\\tpublic int[] sortArray(int[] nums) {\\n\\t\\t\\tmergeSort(nums, 0, nums.length - 1);\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\n\\t\\tpublic void mergeSort(int[] nums, int start, int end) {\\n\\t\\t\\t// if the start index is larger or equal to the end index, the sort of the subarray is finished\\n\\t\\t\\tif (start >= end) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tint mid = start + (end - start) / 2;\\n\\t\\t\\tmergeSort(nums, start, mid);\\n\\t\\t\\tmergeSort(nums, mid + 1, end);\\n\\t\\t\\tmerge(nums, start, end);\\n\\t\\t}\\n\\n\\t\\tpublic void merge(int[] nums, int start, int end) {\\n\\t\\t\\tint mid = start + (end - start) / 2;\\n\\t\\t\\tint[] temp = new int[end - start + 1];\\n\\t\\t\\tint leftStart = start;\\n\\t\\t\\tint leftEnd = mid;\\n\\t\\t\\tint rightStart = mid + 1;\\n\\t\\t\\tint rightEnd = end;\\n\\t\\t\\tint i = 0;\\n\\t\\t\\twhile (leftStart <= leftEnd && rightStart <= rightEnd) {\\n\\t\\t\\t\\tif (nums[leftStart] <= nums[rightStart]) {\\n\\t\\t\\t\\t\\ttemp[i] = nums[leftStart];\\n\\t\\t\\t\\t\\tleftStart++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttemp[i] = nums[rightStart];\\n\\t\\t\\t\\t\\trightStart++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\twhile (leftStart <= leftEnd) {\\n\\t\\t\\t\\ttemp[i] = nums[leftStart];\\n\\t\\t\\t\\tleftStart++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\twhile (rightStart <= rightEnd) {\\n\\t\\t\\t\\ttemp[i] = nums[rightStart];\\n\\t\\t\\t\\trightStart++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tnums[start + j] = temp[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\t\\tint temp = nums[i];\\n\\t\\t\\tnums[i] = nums[j];\\n\\t\\t\\tnums[j] = temp;\\n\\t\\t}\\n\\n\\t}\\n```\n```\\n\\tclass Solution {\\n\\n\\t\\tpublic int[] sortArray(int[] nums) {\\n\\t\\t\\tfor (int i = 0; i < nums.length - 1; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < nums.length - i - 1; j++) {\\n\\t\\t\\t\\t\\tif (nums[j + 1] < nums[j]) {\\n\\t\\t\\t\\t\\t\\tswap(nums, j, j + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\n\\t\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\t\\tnums[i] = nums[i] ^ nums[j];\\n\\t\\t\\tnums[j] = nums[i] ^ nums[j];\\n\\t\\t\\tnums[i] = nums[i] ^ nums[j];\\n\\t\\t}\\n\\n\\t}\\n```\n```\\n\\tpublic class Solution {\\n\\n\\t\\tpublic int[] sortArray(int[] nums) {\\n\\t\\t\\tif (nums.length <= 1) {\\n\\t\\t\\t\\treturn nums;\\n\\t\\t\\t}\\n\\t\\t\\tint[] res = new int[nums.length];\\n\\t\\t\\tInteger size = 0;\\n\\t\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\t\\tint min = nums[size];\\n\\t\\t\\t\\tint minIndex = size;\\n\\t\\t\\t\\tfor (int j = nums.length - 1; j > size; j--) {\\n\\t\\t\\t\\t\\tif (nums[j] < min) {\\n\\t\\t\\t\\t\\t\\tmin = nums[j];\\n\\t\\t\\t\\t\\t\\tminIndex = j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres[size] = min;\\n\\t\\t\\t\\tswap(nums, minIndex, size);\\n\\t\\t\\t\\tsize++;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\t\\tnums[i] = nums[i] ^ nums[j];\\n\\t\\t\\tnums[j] = nums[i] ^ nums[j];\\n\\t\\t\\tnums[i] = nums[i] ^ nums[j];\\n\\t\\t}\\n\\n\\t}\\n```\n```\\n\\tclass Solution {\\n\\t\\tpublic int[] sortArray(int[] nums) {\\n\\t\\t\\tif (nums == null || nums.length < 2) {\\n\\t\\t\\t\\treturn nums;\\n\\t\\t\\t}\\n\\t\\t\\theapSort(nums);\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\n\\t\\tprivate void heapSort(int[] nums) {\\n\\t\\t\\tfor (int i = nums.length / 2; i >= 0; i--) {\\n\\t\\t\\t\\theapify(nums, i, nums.length - 1);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\t\\tswap(nums, 0, nums.length - 1 - i);\\n\\t\\t\\t\\theapify(nums, 0, nums.length - 2 - i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate void heapify(int[] nums, int start, int end) {\\n\\t\\t\\twhile (start <= end) {\\n\\t\\t\\t\\tint l = 2 * start + 1;\\n\\t\\t\\t\\tint r = 2 * start + 2;\\n\\t\\t\\t\\tint maxIndex = start;\\n\\t\\t\\t\\tif (l <= end && nums[l] > nums[maxIndex]) {\\n\\t\\t\\t\\t\\tmaxIndex = l;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (r <= end && nums[r] > nums[maxIndex]) {\\n\\t\\t\\t\\t\\tmaxIndex = r;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (maxIndex == start) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tswap(nums, start, maxIndex);\\n\\t\\t\\t\\tstart = maxIndex;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\t\\tint tmp = nums[i];\\n\\t\\t\\tnums[i] = nums[j];\\n\\t\\t\\tnums[j] = tmp;\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319378,
                "title": "c-sorting-an-array-using-recursion",
                "content": "**Please note that this method will result in a TLE and only pass 10/13 of the test cases.\\nI am sharing it because I feel it\\'s a good application of recursion to sort an array**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n\\t\\t// Base Condition\\n        if (nums.size() == 1)\\n            return nums;  \\n        // Hypothesis\\n        vector<int> smallerUnsorted(nums.begin() + 1, nums.end());\\n        vector<int> smallerSorted = sortArray(smallerUnSorted);\\n        // Induction\\n        vector<int> originalSorted;\\n        int i = 0;\\n        while (i < smallerSorted.size() && smallerSorted[i] <= nums[0])\\n            originalSorted.push_back(smallerSorted[i++]);\\n        originalSorted.push_back(nums[0]);\\n        while (i < smallerSorted.size() && smallerSorted[i] > nums[0])\\n            originalSorted.push_back(smallerSorted[i++]);\\n        // Return sorted array\\n        return originalSorted;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n\\t\\t// Base Condition\\n        if (nums.size() == 1)\\n            return nums;  \\n        // Hypothesis\\n        vector<int> smallerUnsorted(nums.begin() + 1, nums.end());\\n        vector<int> smallerSorted = sortArray(smallerUnSorted);\\n        // Induction\\n        vector<int> originalSorted;\\n        int i = 0;\\n        while (i < smallerSorted.size() && smallerSorted[i] <= nums[0])\\n            originalSorted.push_back(smallerSorted[i++]);\\n        originalSorted.push_back(nums[0]);\\n        while (i < smallerSorted.size() && smallerSorted[i] > nums[0])\\n            originalSorted.push_back(smallerSorted[i++]);\\n        // Return sorted array\\n        return originalSorted;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702961,
                "title": "java-quick-sort-beat-95-time-time-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        \\n        if (nums.length == 0) { return nums;}\\n        \\n        QuickSort(nums, 0, nums.length - 1);\\n        return nums;\\n        \\n    }\\n    \\n    private void QuickSort(int[] nums, int start, int end) {\\n        \\n        if(start >= end) return;\\n        \\n        int pivot = nums[(start + end)/2];\\n        int left = start, right = end;\\n\\n        while (left <= right) {\\n            while (left <= right && nums[left] < pivot ) {\\n            left++;\\n            }\\n        \\n            while (left <= right && nums[right] > pivot) {\\n            right--;\\n            }\\n            \\n            if(left <= right) {\\n                int temp;\\n                temp = nums[left];\\n                nums[left] = nums[right];\\n                nums[right] = temp;\\n                \\n                left++;\\n                right--;\\n            }\\n        }\\n        \\n       QuickSort(nums, start, right);\\n       QuickSort(nums, left, end);\\n        \\n        \\n    }\\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        \\n        if (nums.length == 0) { return nums;}\\n        \\n        QuickSort(nums, 0, nums.length - 1);\\n        return nums;\\n        \\n    }\\n    \\n    private void QuickSort(int[] nums, int start, int end) {\\n        \\n        if(start >= end) return;\\n        \\n        int pivot = nums[(start + end)/2];\\n        int left = start, right = end;\\n\\n        while (left <= right) {\\n            while (left <= right && nums[left] < pivot ) {\\n            left++;\\n            }\\n        \\n            while (left <= right && nums[right] > pivot) {\\n            right--;\\n            }\\n            \\n            if(left <= right) {\\n                int temp;\\n                temp = nums[left];\\n                nums[left] = nums[right];\\n                nums[right] = temp;\\n                \\n                left++;\\n                right--;\\n            }\\n        }\\n        \\n       QuickSort(nums, start, right);\\n       QuickSort(nums, left, end);\\n        \\n        \\n    }\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491922,
                "title": "c-easy-1-line-solution",
                "content": "**Please upvote, if this helps!! (\\u25D4\\u203F\\u25D4)**\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n\\t\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n\\t\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1224348,
                "title": "java-iterative-recursive-quicksort-mergesort-3-ways-quicksort-3-ways-mergesort-max-min-heapsort",
                "content": "Iterative quick sort\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        return quickIterative(nums, 0, nums.length - 1);\\n    }\\n    \\n    private int[] quickIterative(int[] nums, int l, int h) {\\n        if (l >= h) {\\n            return nums;\\n        }\\n        // create a stack to store the low index and high index\\n        int[] stack = new int[h - l + 1];\\n        int top = 0;\\n        // push low index and high index into stack\\n        stack[top++] = l;\\n        \\n        stack[top++] = h;\\n        \\n        while (top > 0 ) {\\n            // pop high and low\\n            h = stack[--top];\\n            l = stack[--top];\\n            // partition, p is at the correct position\\n            int p = this.partition(nums, l, h);\\n            // if pivot\\'s left side has array left, push into stack;\\n            if (p - 1 > l) {\\n                stack[top++] = l;\\n                stack[top++] = p - 1;\\n            }\\n            // if pivot\\'s right side has array left, push into stack;\\n            if (p + 1 < h) {\\n                stack[top++] = p + 1;\\n                stack[top++] = h;\\n            }\\n            // keep doing this until the stack is empty;\\n        }\\n        return nums;\\n    }\\n    \\n    private int partition(int[] nums, int head, int tail) {\\n        int p_index = this.getMediumValueIndex(nums, head, tail);\\n        int pivot = nums[p_index];\\n        nums[p_index] = nums[tail];\\n        nums[tail] = pivot;\\n        p_index = tail;\\n        int i = head - 1;\\n        for (int j = head; j < tail; ++j) {\\n            if (nums[j] <= pivot) {\\n                i++;\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n        int temp = nums[i+1];\\n        nums[i+1] = nums[tail];\\n        nums[tail] = temp;\\n        return i + 1;\\n    }\\n    \\n    \\n    private int getMediumValueIndex(int[] nums, int head, int tail) {\\n        int mid = head + (tail - head) / 2;\\n        int l = nums[head];\\n        int m = nums[mid];\\n        int r = nums[tail];\\n        if (l > m) {\\n            // l > m > r\\n            if (m > r) return mid;\\n            // r > l > m\\n            else if (r > l) return head;\\n            //l > r > m\\n            else return tail;\\n        \\n        } \\n        // m > l\\n        else {\\n            // r > m > l\\n            if (r > m) return mid;\\n            // m > l > r\\n            else if (l > r) return head;\\n            // m > r > l\\n            else return tail;\\n        }\\n    }\\n}\\n```\\nStable iterative quick sort(TLE)\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        return quickIterative(nums, 0, nums.length - 1);\\n    }\\n    \\n    private int[] quickIterative(int[] nums, int l, int h) {\\n        if (l >= h) {\\n            return nums;\\n        }\\n        // create a stack to store the low index and high index\\n        int[] stack = new int[h - l + 1];\\n        int top = 0;\\n        // push low index and high index into stack\\n        stack[top++] = l;\\n        \\n        stack[top++] = h;\\n        \\n        while (top > 0 ) {\\n            // pop high and low\\n            h = stack[--top];\\n            l = stack[--top];\\n            // partition, p is at the correct position\\n            int p = this.partition(nums, l, h);\\n            // if pivot\\'s left side has array left, push into stack;\\n            if (p - 1 > l) {\\n                stack[top++] = l;\\n                stack[top++] = p - 1;\\n            }\\n            // if pivot\\'s right side has array left, push into stack;\\n            if (p + 1 < h) {\\n                stack[top++] = p + 1;\\n                stack[top++] = h;\\n            }\\n            // keep doing this until the stack is empty;\\n        }\\n        return nums;\\n    }\\n    \\n    private int partition(int[] nums, int head, int tail) {\\n        Queue<Integer> aux = new LinkedList<>();\\n        Queue<Integer> left = new LinkedList<>();\\n        Queue<Integer> right = new LinkedList<>();\\n        for (int i  = head + 1; i <= tail; ++i) {\\n            if (nums[i] < nums[head]) {\\n                left.add(nums[i]);\\n            } else {\\n                right.add(nums[i]);\\n            }\\n        }\\n        aux.addAll(left);\\n        aux.add(nums[head]);\\n        aux.addAll(right);\\n        for (int i = head; i <= tail; ++i) {\\n            nums[i] = aux.remove();\\n        }\\n        return head + left.size();\\n    }\\n    \\n    private int getMediumValueIndex(int[] nums, int head, int tail) {\\n        int mid = head + (tail - head) / 2;\\n        int l = nums[head];\\n        int m = nums[mid];\\n        int r = nums[tail];\\n        if (l > m) {\\n            // l > m > r\\n            if (m > r) return mid;\\n            // r > l > m\\n            else if (r > l) return head;\\n            //l > r > m\\n            else return tail;\\n        \\n        } \\n        // m > l\\n        else {\\n            // r > m > l\\n            if (r > m) return mid;\\n            // m > l > r\\n            else if (l > r) return head;\\n            // m > r > l\\n            else return tail;\\n        }\\n    }\\n}\\n```\\n\\n\\nRecursive quick sort\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        if (nums.length <= 1) return nums;\\n        this.qHelper(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n    \\n    private void qHelper(int[] nums, int head, int tail) {\\n        if (head >= tail) return;\\n        int pivot = this.partition(nums, head, tail);\\n        this.qHelper(nums, head, pivot-1);\\n        this.qHelper(nums, pivot+1, tail);\\n    }\\n    \\n    private int partition(int[] nums, int head, int tail) {\\n        // use the index with medium value as pivot point.\\n        int pivot_index = this.getMediumValueIndex(nums, head, tail);\\n        int pivot = nums[pivot_index];\\n        // int temp = nums[pivot_index];\\n        nums[pivot_index] = nums[tail];\\n        nums[tail] = pivot;\\n        pivot_index = tail;\\n        int i = head - 1;\\n        for (int j = head; j < tail; ++j) {\\n            if (nums[j] < pivot) {\\n                ++i;\\n                //swap i and j\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n        // swap i+1 and pivot_index\\n        int temp = nums[i+1];\\n        nums[i+1] = nums[pivot_index];\\n        nums[pivot_index] = temp;\\n        return i+1;\\n        \\n    }\\n    \\n    private int getMediumValueIndex(int[] nums, int head, int tail) {\\n        int mid = head + (tail - head) / 2;\\n        int l = nums[head];\\n        int m = nums[mid];\\n        int r = nums[tail];\\n        if (l > m) {\\n            // l > m > r\\n            if (m > r) return mid;\\n            // r > l > m\\n            else if (r > l) return head;\\n            //l > r > m\\n            else return tail;\\n        \\n        } \\n        // m > l\\n        else {\\n            // r > m > l\\n            if (r > m) return mid;\\n            // m > l > r\\n            else if (l > r) return head;\\n            // m > r > l\\n            else return tail;\\n        }\\n    }\\n    \\n```\\nStable recursive quick sort\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        List<Integer> l = new ArrayList<>();\\n        for (int i : nums) {\\n            l.add(i);\\n        }\\n        List<Integer> res = this.quickSort(l);\\n        int size = nums.length;\\n        for (int i = 0; i < size; ++i) {\\n            nums[i] = res.get(i);\\n        }\\n        return nums;\\n    }\\n    public static List<Integer> quickSort(List<Integer> ar) {\\n        // Base case\\n        if(ar.size() <= 1) {\\n            return ar;\\n        }\\n        // Let us choose middle element a pivot            \\n        int mid = ar.size() / 2;\\n        int pivat = ar.get(mid);\\n             \\n        // key element is used to break the array\\n        // into 2 halves according to their values\\n        List<Integer> smaller = new ArrayList<>();\\n        List<Integer> greater = new ArrayList<>();\\n             \\n        // Put greater elements in greater list,\\n        // smaller elements in smaller list. Also,\\n        // compare positions to decide where to put.        \\n        for (int ind = 0; ind < ar.size(); ind++) {\\n            int val = ar.get(ind);\\n            if ( ind != mid ) {\\n                if ( val < pivat ) {\\n                    smaller.add(val);\\n                } else if (val > pivat) {\\n                    greater.add(val);\\n                } else {\\n                    // If value is same, then considering\\n                    // position to decide the list.                   \\n                    if(ind < mid) {\\n                        smaller.add(val);\\n                    } else {\\n                        greater.add(val);\\n                    }\\n                }\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<Integer>();              \\n        List<Integer> sa1 = quickSort(smaller);\\n        List<Integer> sa2 = quickSort(greater);\\n        // add all elements of smaller list into ans list\\n        for (Integer val1 : sa1) {\\n            ans.add(val1);\\n        }     \\n        // add pivat element into ans list   \\n        ans.add(pivat);\\n        // add all elements of greater list into ans list\\n        for(Integer val2 : sa2) {\\n            ans.add(val2);\\n        }\\n        // return ans list\\n        return ans;        \\n    }\\n}\\n```\\n\\n\\n3 ways quick sort\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        this.quick3(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n    \\n    private void quick3(int[] nums, int start, int end) {\\n        if (start >= end) {\\n            return;\\n        }\\n        \\n        // choose the mid point as the pivot\\n        int m = this.pickMediumIndex(nums, start, end, (start + (end - start)) / 2);\\n        int pivot = nums[m];\\n        \\n        int temp = nums[start];\\n        nums[start] = nums[m];\\n        nums[m] = temp;\\n        \\n        int l = start;\\n        int r = end;\\n        int i = l + 1;\\n        // start the process;\\n        while (i <= r) {\\n            // if less, move to front\\n            if (nums[i] < pivot) {\\n                int tmp = nums[i];\\n                nums[i] = nums[l];\\n                nums[l] = tmp;\\n                ++i;\\n                ++l;\\n            }\\n            // if equal, just keep the same position and move to next index.\\n            else if (nums[i] == pivot) {\\n                ++i;\\n            } \\n            // if greater, move to end;\\n            // we do not increment i here because we do not know if the new element in ith position is greater or less than pivot.\\n            else {\\n                int tmp = nums[i];\\n                nums[i] = nums[r];\\n                nums[r] = tmp;\\n                --r;\\n            }\\n        }\\n        this.quick3(nums, start, l-1);\\n        this.quick3(nums, r + 1, end);\\n    }\\n    \\n    private int pickMediumIndex(int[] nums, int head, int tail, int mid) {\\n        int l = nums[head];\\n        int m = nums[mid];\\n        int r = nums[tail];\\n        if (l > m) {\\n            // l > m > r\\n            if (m > r) return mid;\\n            // r > l > m\\n            else if (r > l) return head;\\n            //l > r > m\\n            else return tail;\\n        \\n        } \\n        // m > l\\n        else {\\n            // r > m > l\\n            if (r > m) return mid;\\n            // m > l > r\\n            else if (l > r) return head;\\n            // m > r > l\\n            else return tail;\\n        }\\n    }\\n}\\n```\\n\\nIterative merge sort\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        mergeSort2(nums);\\n        return nums;\\n    }\\n    private void mergeSort2(int[] nums) {\\n        for (int size = 1; size < nums.length; size *= 2) {\\n            for (int i = 0; i < nums.length - size; i += 2 * size) {\\n                int mid = i + size - 1;\\n                int end = Math.min(i + 2 * size - 1, nums.length - 1);\\n                merge2(nums, i, mid, end);\\n            }\\n        }\\n    }\\n    private void merge2(int[] nums, int l, int mid, int r) {\\n        int[] tmp = new int[r - l + 1];\\n        int i = l, j = mid + 1, k = 0;\\n        while (i <= mid || j <= r) {\\n            if (i > mid) {\\n                tmp[k] = nums[j];\\n                ++k;\\n                ++j;\\n            } else if (j > r) {\\n                tmp[k] = nums[i];\\n                ++k;\\n                ++i;\\n            } else if (nums[i] > nums[j]) {\\n                tmp[k] = nums[j];\\n                ++k;\\n                ++j;\\n            } else {\\n                tmp[k] = nums[i];\\n                ++k;\\n                ++i;\\n            }\\n        }\\n        for (i = l; i <= r; ++i) {\\n            nums[i] = tmp[i-l];\\n        }\\n    }\\n}\\n```\\n\\nRecursive merge sort\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        return mergeSort(nums);\\n        \\n    }\\n    \\n    private int[] mergeSort(int[] nums) {\\n        if (nums.length <= 1) return nums;\\n        int length = nums.length;\\n        int mid = nums.length / 2;\\n        int[] left = new int[mid];\\n        for (int i = 0; i < mid; ++i) {\\n            left[i] = nums[i];\\n        }\\n        int[] right = new int[nums.length - mid];\\n        for (int i = mid; i < length; ++i) {\\n            right[i - mid] = nums[i];\\n        }\\n        left = mergeSort(left);\\n        right = mergeSort(right);\\n        return merge(left, right);\\n    }\\n    private int[] merge(int[] l, int[] r) {\\n        int[] res = new int[l.length+r.length];\\n        int lLen = l.length;\\n        int rLen = r.length;\\n        int i = 0;\\n        int li = 0;\\n        int ri = 0;\\n        while (lLen > 0 && rLen > 0) {\\n            if (l[li] <= r[ri]) {\\n                res[i] = l[li];\\n                ++i;\\n                li++;\\n                --lLen;\\n            } else {\\n                res[i] = r[ri];\\n                ++i;\\n                ri++;\\n                --rLen;\\n            }\\n        }\\n        while (lLen > 0) {\\n            res[i] = l[li];\\n            --lLen;\\n            ++i;\\n            ++li;\\n        }\\n        while (rLen > 0) {\\n            res[i] = r[ri];\\n            --rLen;\\n            ++i;\\n            ++ri;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nMax Heap Sort\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        return maxHeapSort(nums);\\n    }\\n    \\n    private int[] maxHeapSort(int[] nums) {\\n        int[] res = new int[nums.length];\\n        int size = nums.length;\\n        // build heap. start from first half because the second half is children.\\n        for (int i = size / 2 - 1; i >= 0; --i) {\\n            this.maxHeapify(nums, size, i);\\n        }\\n        for (int i = size - 1; i >= 0; --i) {\\n            // put current node to the end;\\n            int temp = nums[0];\\n            nums[0] = nums[i];\\n            nums[i] = temp;\\n            // put current largest into ith position.\\n            this.maxHeapify(nums, i, 0);\\n        }\\n        return nums;\\n    }\\n    \\n    private void maxHeapify(int[] nums, int size, int i) {\\n        int largest = i; \\n        int left = 2*i + 1;\\n        int right = 2*i + 2;\\n        if (left < size) {\\n            if (nums[left] > nums[largest]) largest = left;\\n        }\\n        if (right < size) {\\n            if (nums[right] > nums[largest]) largest = right;\\n        }\\n        if (largest != i) {\\n            int temp = nums[i];\\n            nums[i] = nums[largest];\\n            nums[largest] = temp;\\n            this.maxHeapify(nums, size, largest);\\n        }\\n    }\\n}\\n```\\n\\nMin Heap Sort\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        this.heapSort(nums, nums.length);\\n        return nums;\\n    }\\n    \\n    // main function to do heap sort\\n    static void heapSort(int arr[], int n)\\n    {\\n        // Build heap (rearrange array)\\n        for (int i = n / 2 - 1; i >= 0; i--)\\n            heapify(arr, n, i);\\n \\n        // One by one extract an element from heap\\n        for (int i = n - 1; i >= 0; i--) {\\n             \\n            // Move current root to end\\n            int temp = arr[0];\\n            arr[0] = arr[i];\\n            arr[i] = temp;\\n \\n            // call max heapify on the reduced heap\\n            heapify(arr, i, 0);\\n        }\\n        int l = 0;\\n        int r = n - 1;\\n        while (l < r) {\\n            int temp = arr[l];\\n            arr[l] = arr[r];\\n            arr[r] = temp;\\n            ++l;\\n            --r;\\n        }\\n    }\\n    \\n    static void heapify(int arr[], int n, int i)\\n    {\\n        int smallest = i; // Initialize smalles as root\\n        int l = 2 * i + 1; // left = 2*i + 1\\n        int r = 2 * i + 2; // right = 2*i + 2\\n \\n        // If left child is smaller than root\\n        if (l < n && arr[l] < arr[smallest])\\n            smallest = l;\\n \\n        // If right child is smaller than smallest so far\\n        if (r < n && arr[r] < arr[smallest])\\n            smallest = r;\\n \\n        // If smallest is not root\\n        if (smallest != i) {\\n            int temp = arr[i];\\n            arr[i] = arr[smallest];\\n            arr[smallest] = temp;\\n \\n            // Recursively heapify the affected sub-tree\\n            heapify(arr, n, smallest);\\n        }\\n    }\\n}\\n```\\n\\n3 way merge sort\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        return this.merge3ways(nums);\\n    }\\n    \\n    private int[] merge3ways(int[] nums) {\\n        if (nums == null) {\\n            return nums;\\n        }\\n        \\n        int length = nums.length;\\n        int[] tar = new int[length];\\n        for (int i = 0; i < length; ++i) {\\n            tar[i] = nums[i];\\n        }\\n        this.mergeSort(nums, 0, length, tar);\\n        return nums;\\n    }\\n    \\n    private void mergeSort(int[] ori, int l, int h, int[] tar) {\\n        if (h - l < 2) {\\n            return;\\n        }\\n        int m1 = l + ((h - l) / 3);\\n        int m2 = l + 2 * ((h - l) / 3) + 1;\\n        this.mergeSort(tar, l, m1, ori);\\n        this.mergeSort(tar, m1, m2, ori);\\n        this.mergeSort(tar, m2, h, ori);\\n        this.merge(tar, l, m1, m2, h, ori);\\n    }\\n    \\n    private void merge(int[] ori, int low, int m1, int m2, int h, int[] tar) {\\n        int i = low;\\n        int j = m1;\\n        int k = m2;\\n        int l = low;\\n        while ( (i < m1) && (j < m2) && (k < h)) {\\n            if (ori[i] < ori[j]) {\\n                if (ori[i] < ori[k]) {\\n                    tar[l++] = ori[i++];\\n                } else {\\n                    tar[l++] = ori[k++];\\n                }\\n            } else {\\n                if (ori[j] < ori[k]) {\\n                    tar[l++] = ori[j++];\\n                } else {\\n                    tar[l++] = ori[k++];\\n                }\\n            }\\n        }\\n        \\n        while ( (i < m1) && (j < m2)) {\\n            if (ori[i] < ori[j]) {\\n                tar[l++] = ori[i++];\\n            } else {\\n                tar[l++] = ori[j++];\\n            }\\n        }\\n        \\n        while ((j < m2) && (k < h)) {\\n            if (ori[j] < ori[k]) {\\n                tar[l++] = ori[j++];\\n            } else {\\n                tar[l++] = ori[k++];\\n            }\\n        }\\n        \\n        while ( (i < m1) && (k < h)) {\\n            if (ori[i] < ori[k]) {\\n                tar[l++] = ori[i++];\\n            } else {\\n                tar[l++] = ori[k++];\\n            }\\n        }\\n        \\n        while (i < m1) {\\n            tar[l++] = ori[i++];\\n        }\\n        \\n        while (j < m2) {\\n            tar[l++] = ori[j++];\\n        }\\n        \\n        while (k < h) {\\n            tar[l++] = ori[k++];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Merge Sort",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        return quickIterative(nums, 0, nums.length - 1);\\n    }\\n    \\n    private int[] quickIterative(int[] nums, int l, int h) {\\n        if (l >= h) {\\n            return nums;\\n        }\\n        // create a stack to store the low index and high index\\n        int[] stack = new int[h - l + 1];\\n        int top = 0;\\n        // push low index and high index into stack\\n        stack[top++] = l;\\n        \\n        stack[top++] = h;\\n        \\n        while (top > 0 ) {\\n            // pop high and low\\n            h = stack[--top];\\n            l = stack[--top];\\n            // partition, p is at the correct position\\n            int p = this.partition(nums, l, h);\\n            // if pivot\\'s left side has array left, push into stack;\\n            if (p - 1 > l) {\\n                stack[top++] = l;\\n                stack[top++] = p - 1;\\n            }\\n            // if pivot\\'s right side has array left, push into stack;\\n            if (p + 1 < h) {\\n                stack[top++] = p + 1;\\n                stack[top++] = h;\\n            }\\n            // keep doing this until the stack is empty;\\n        }\\n        return nums;\\n    }\\n    \\n    private int partition(int[] nums, int head, int tail) {\\n        int p_index = this.getMediumValueIndex(nums, head, tail);\\n        int pivot = nums[p_index];\\n        nums[p_index] = nums[tail];\\n        nums[tail] = pivot;\\n        p_index = tail;\\n        int i = head - 1;\\n        for (int j = head; j < tail; ++j) {\\n            if (nums[j] <= pivot) {\\n                i++;\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n        int temp = nums[i+1];\\n        nums[i+1] = nums[tail];\\n        nums[tail] = temp;\\n        return i + 1;\\n    }\\n    \\n    \\n    private int getMediumValueIndex(int[] nums, int head, int tail) {\\n        int mid = head + (tail - head) / 2;\\n        int l = nums[head];\\n        int m = nums[mid];\\n        int r = nums[tail];\\n        if (l > m) {\\n            // l > m > r\\n            if (m > r) return mid;\\n            // r > l > m\\n            else if (r > l) return head;\\n            //l > r > m\\n            else return tail;\\n        \\n        } \\n        // m > l\\n        else {\\n            // r > m > l\\n            if (r > m) return mid;\\n            // m > l > r\\n            else if (l > r) return head;\\n            // m > r > l\\n            else return tail;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        return quickIterative(nums, 0, nums.length - 1);\\n    }\\n    \\n    private int[] quickIterative(int[] nums, int l, int h) {\\n        if (l >= h) {\\n            return nums;\\n        }\\n        // create a stack to store the low index and high index\\n        int[] stack = new int[h - l + 1];\\n        int top = 0;\\n        // push low index and high index into stack\\n        stack[top++] = l;\\n        \\n        stack[top++] = h;\\n        \\n        while (top > 0 ) {\\n            // pop high and low\\n            h = stack[--top];\\n            l = stack[--top];\\n            // partition, p is at the correct position\\n            int p = this.partition(nums, l, h);\\n            // if pivot\\'s left side has array left, push into stack;\\n            if (p - 1 > l) {\\n                stack[top++] = l;\\n                stack[top++] = p - 1;\\n            }\\n            // if pivot\\'s right side has array left, push into stack;\\n            if (p + 1 < h) {\\n                stack[top++] = p + 1;\\n                stack[top++] = h;\\n            }\\n            // keep doing this until the stack is empty;\\n        }\\n        return nums;\\n    }\\n    \\n    private int partition(int[] nums, int head, int tail) {\\n        Queue<Integer> aux = new LinkedList<>();\\n        Queue<Integer> left = new LinkedList<>();\\n        Queue<Integer> right = new LinkedList<>();\\n        for (int i  = head + 1; i <= tail; ++i) {\\n            if (nums[i] < nums[head]) {\\n                left.add(nums[i]);\\n            } else {\\n                right.add(nums[i]);\\n            }\\n        }\\n        aux.addAll(left);\\n        aux.add(nums[head]);\\n        aux.addAll(right);\\n        for (int i = head; i <= tail; ++i) {\\n            nums[i] = aux.remove();\\n        }\\n        return head + left.size();\\n    }\\n    \\n    private int getMediumValueIndex(int[] nums, int head, int tail) {\\n        int mid = head + (tail - head) / 2;\\n        int l = nums[head];\\n        int m = nums[mid];\\n        int r = nums[tail];\\n        if (l > m) {\\n            // l > m > r\\n            if (m > r) return mid;\\n            // r > l > m\\n            else if (r > l) return head;\\n            //l > r > m\\n            else return tail;\\n        \\n        } \\n        // m > l\\n        else {\\n            // r > m > l\\n            if (r > m) return mid;\\n            // m > l > r\\n            else if (l > r) return head;\\n            // m > r > l\\n            else return tail;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        if (nums.length <= 1) return nums;\\n        this.qHelper(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n    \\n    private void qHelper(int[] nums, int head, int tail) {\\n        if (head >= tail) return;\\n        int pivot = this.partition(nums, head, tail);\\n        this.qHelper(nums, head, pivot-1);\\n        this.qHelper(nums, pivot+1, tail);\\n    }\\n    \\n    private int partition(int[] nums, int head, int tail) {\\n        // use the index with medium value as pivot point.\\n        int pivot_index = this.getMediumValueIndex(nums, head, tail);\\n        int pivot = nums[pivot_index];\\n        // int temp = nums[pivot_index];\\n        nums[pivot_index] = nums[tail];\\n        nums[tail] = pivot;\\n        pivot_index = tail;\\n        int i = head - 1;\\n        for (int j = head; j < tail; ++j) {\\n            if (nums[j] < pivot) {\\n                ++i;\\n                //swap i and j\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n        // swap i+1 and pivot_index\\n        int temp = nums[i+1];\\n        nums[i+1] = nums[pivot_index];\\n        nums[pivot_index] = temp;\\n        return i+1;\\n        \\n    }\\n    \\n    private int getMediumValueIndex(int[] nums, int head, int tail) {\\n        int mid = head + (tail - head) / 2;\\n        int l = nums[head];\\n        int m = nums[mid];\\n        int r = nums[tail];\\n        if (l > m) {\\n            // l > m > r\\n            if (m > r) return mid;\\n            // r > l > m\\n            else if (r > l) return head;\\n            //l > r > m\\n            else return tail;\\n        \\n        } \\n        // m > l\\n        else {\\n            // r > m > l\\n            if (r > m) return mid;\\n            // m > l > r\\n            else if (l > r) return head;\\n            // m > r > l\\n            else return tail;\\n        }\\n    }\\n    \\n```\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        List<Integer> l = new ArrayList<>();\\n        for (int i : nums) {\\n            l.add(i);\\n        }\\n        List<Integer> res = this.quickSort(l);\\n        int size = nums.length;\\n        for (int i = 0; i < size; ++i) {\\n            nums[i] = res.get(i);\\n        }\\n        return nums;\\n    }\\n    public static List<Integer> quickSort(List<Integer> ar) {\\n        // Base case\\n        if(ar.size() <= 1) {\\n            return ar;\\n        }\\n        // Let us choose middle element a pivot            \\n        int mid = ar.size() / 2;\\n        int pivat = ar.get(mid);\\n             \\n        // key element is used to break the array\\n        // into 2 halves according to their values\\n        List<Integer> smaller = new ArrayList<>();\\n        List<Integer> greater = new ArrayList<>();\\n             \\n        // Put greater elements in greater list,\\n        // smaller elements in smaller list. Also,\\n        // compare positions to decide where to put.        \\n        for (int ind = 0; ind < ar.size(); ind++) {\\n            int val = ar.get(ind);\\n            if ( ind != mid ) {\\n                if ( val < pivat ) {\\n                    smaller.add(val);\\n                } else if (val > pivat) {\\n                    greater.add(val);\\n                } else {\\n                    // If value is same, then considering\\n                    // position to decide the list.                   \\n                    if(ind < mid) {\\n                        smaller.add(val);\\n                    } else {\\n                        greater.add(val);\\n                    }\\n                }\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<Integer>();              \\n        List<Integer> sa1 = quickSort(smaller);\\n        List<Integer> sa2 = quickSort(greater);\\n        // add all elements of smaller list into ans list\\n        for (Integer val1 : sa1) {\\n            ans.add(val1);\\n        }     \\n        // add pivat element into ans list   \\n        ans.add(pivat);\\n        // add all elements of greater list into ans list\\n        for(Integer val2 : sa2) {\\n            ans.add(val2);\\n        }\\n        // return ans list\\n        return ans;        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        this.quick3(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n    \\n    private void quick3(int[] nums, int start, int end) {\\n        if (start >= end) {\\n            return;\\n        }\\n        \\n        // choose the mid point as the pivot\\n        int m = this.pickMediumIndex(nums, start, end, (start + (end - start)) / 2);\\n        int pivot = nums[m];\\n        \\n        int temp = nums[start];\\n        nums[start] = nums[m];\\n        nums[m] = temp;\\n        \\n        int l = start;\\n        int r = end;\\n        int i = l + 1;\\n        // start the process;\\n        while (i <= r) {\\n            // if less, move to front\\n            if (nums[i] < pivot) {\\n                int tmp = nums[i];\\n                nums[i] = nums[l];\\n                nums[l] = tmp;\\n                ++i;\\n                ++l;\\n            }\\n            // if equal, just keep the same position and move to next index.\\n            else if (nums[i] == pivot) {\\n                ++i;\\n            } \\n            // if greater, move to end;\\n            // we do not increment i here because we do not know if the new element in ith position is greater or less than pivot.\\n            else {\\n                int tmp = nums[i];\\n                nums[i] = nums[r];\\n                nums[r] = tmp;\\n                --r;\\n            }\\n        }\\n        this.quick3(nums, start, l-1);\\n        this.quick3(nums, r + 1, end);\\n    }\\n    \\n    private int pickMediumIndex(int[] nums, int head, int tail, int mid) {\\n        int l = nums[head];\\n        int m = nums[mid];\\n        int r = nums[tail];\\n        if (l > m) {\\n            // l > m > r\\n            if (m > r) return mid;\\n            // r > l > m\\n            else if (r > l) return head;\\n            //l > r > m\\n            else return tail;\\n        \\n        } \\n        // m > l\\n        else {\\n            // r > m > l\\n            if (r > m) return mid;\\n            // m > l > r\\n            else if (l > r) return head;\\n            // m > r > l\\n            else return tail;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        mergeSort2(nums);\\n        return nums;\\n    }\\n    private void mergeSort2(int[] nums) {\\n        for (int size = 1; size < nums.length; size *= 2) {\\n            for (int i = 0; i < nums.length - size; i += 2 * size) {\\n                int mid = i + size - 1;\\n                int end = Math.min(i + 2 * size - 1, nums.length - 1);\\n                merge2(nums, i, mid, end);\\n            }\\n        }\\n    }\\n    private void merge2(int[] nums, int l, int mid, int r) {\\n        int[] tmp = new int[r - l + 1];\\n        int i = l, j = mid + 1, k = 0;\\n        while (i <= mid || j <= r) {\\n            if (i > mid) {\\n                tmp[k] = nums[j];\\n                ++k;\\n                ++j;\\n            } else if (j > r) {\\n                tmp[k] = nums[i];\\n                ++k;\\n                ++i;\\n            } else if (nums[i] > nums[j]) {\\n                tmp[k] = nums[j];\\n                ++k;\\n                ++j;\\n            } else {\\n                tmp[k] = nums[i];\\n                ++k;\\n                ++i;\\n            }\\n        }\\n        for (i = l; i <= r; ++i) {\\n            nums[i] = tmp[i-l];\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        return mergeSort(nums);\\n        \\n    }\\n    \\n    private int[] mergeSort(int[] nums) {\\n        if (nums.length <= 1) return nums;\\n        int length = nums.length;\\n        int mid = nums.length / 2;\\n        int[] left = new int[mid];\\n        for (int i = 0; i < mid; ++i) {\\n            left[i] = nums[i];\\n        }\\n        int[] right = new int[nums.length - mid];\\n        for (int i = mid; i < length; ++i) {\\n            right[i - mid] = nums[i];\\n        }\\n        left = mergeSort(left);\\n        right = mergeSort(right);\\n        return merge(left, right);\\n    }\\n    private int[] merge(int[] l, int[] r) {\\n        int[] res = new int[l.length+r.length];\\n        int lLen = l.length;\\n        int rLen = r.length;\\n        int i = 0;\\n        int li = 0;\\n        int ri = 0;\\n        while (lLen > 0 && rLen > 0) {\\n            if (l[li] <= r[ri]) {\\n                res[i] = l[li];\\n                ++i;\\n                li++;\\n                --lLen;\\n            } else {\\n                res[i] = r[ri];\\n                ++i;\\n                ri++;\\n                --rLen;\\n            }\\n        }\\n        while (lLen > 0) {\\n            res[i] = l[li];\\n            --lLen;\\n            ++i;\\n            ++li;\\n        }\\n        while (rLen > 0) {\\n            res[i] = r[ri];\\n            --rLen;\\n            ++i;\\n            ++ri;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        return maxHeapSort(nums);\\n    }\\n    \\n    private int[] maxHeapSort(int[] nums) {\\n        int[] res = new int[nums.length];\\n        int size = nums.length;\\n        // build heap. start from first half because the second half is children.\\n        for (int i = size / 2 - 1; i >= 0; --i) {\\n            this.maxHeapify(nums, size, i);\\n        }\\n        for (int i = size - 1; i >= 0; --i) {\\n            // put current node to the end;\\n            int temp = nums[0];\\n            nums[0] = nums[i];\\n            nums[i] = temp;\\n            // put current largest into ith position.\\n            this.maxHeapify(nums, i, 0);\\n        }\\n        return nums;\\n    }\\n    \\n    private void maxHeapify(int[] nums, int size, int i) {\\n        int largest = i; \\n        int left = 2*i + 1;\\n        int right = 2*i + 2;\\n        if (left < size) {\\n            if (nums[left] > nums[largest]) largest = left;\\n        }\\n        if (right < size) {\\n            if (nums[right] > nums[largest]) largest = right;\\n        }\\n        if (largest != i) {\\n            int temp = nums[i];\\n            nums[i] = nums[largest];\\n            nums[largest] = temp;\\n            this.maxHeapify(nums, size, largest);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        this.heapSort(nums, nums.length);\\n        return nums;\\n    }\\n    \\n    // main function to do heap sort\\n    static void heapSort(int arr[], int n)\\n    {\\n        // Build heap (rearrange array)\\n        for (int i = n / 2 - 1; i >= 0; i--)\\n            heapify(arr, n, i);\\n \\n        // One by one extract an element from heap\\n        for (int i = n - 1; i >= 0; i--) {\\n             \\n            // Move current root to end\\n            int temp = arr[0];\\n            arr[0] = arr[i];\\n            arr[i] = temp;\\n \\n            // call max heapify on the reduced heap\\n            heapify(arr, i, 0);\\n        }\\n        int l = 0;\\n        int r = n - 1;\\n        while (l < r) {\\n            int temp = arr[l];\\n            arr[l] = arr[r];\\n            arr[r] = temp;\\n            ++l;\\n            --r;\\n        }\\n    }\\n    \\n    static void heapify(int arr[], int n, int i)\\n    {\\n        int smallest = i; // Initialize smalles as root\\n        int l = 2 * i + 1; // left = 2*i + 1\\n        int r = 2 * i + 2; // right = 2*i + 2\\n \\n        // If left child is smaller than root\\n        if (l < n && arr[l] < arr[smallest])\\n            smallest = l;\\n \\n        // If right child is smaller than smallest so far\\n        if (r < n && arr[r] < arr[smallest])\\n            smallest = r;\\n \\n        // If smallest is not root\\n        if (smallest != i) {\\n            int temp = arr[i];\\n            arr[i] = arr[smallest];\\n            arr[smallest] = temp;\\n \\n            // Recursively heapify the affected sub-tree\\n            heapify(arr, n, smallest);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        return this.merge3ways(nums);\\n    }\\n    \\n    private int[] merge3ways(int[] nums) {\\n        if (nums == null) {\\n            return nums;\\n        }\\n        \\n        int length = nums.length;\\n        int[] tar = new int[length];\\n        for (int i = 0; i < length; ++i) {\\n            tar[i] = nums[i];\\n        }\\n        this.mergeSort(nums, 0, length, tar);\\n        return nums;\\n    }\\n    \\n    private void mergeSort(int[] ori, int l, int h, int[] tar) {\\n        if (h - l < 2) {\\n            return;\\n        }\\n        int m1 = l + ((h - l) / 3);\\n        int m2 = l + 2 * ((h - l) / 3) + 1;\\n        this.mergeSort(tar, l, m1, ori);\\n        this.mergeSort(tar, m1, m2, ori);\\n        this.mergeSort(tar, m2, h, ori);\\n        this.merge(tar, l, m1, m2, h, ori);\\n    }\\n    \\n    private void merge(int[] ori, int low, int m1, int m2, int h, int[] tar) {\\n        int i = low;\\n        int j = m1;\\n        int k = m2;\\n        int l = low;\\n        while ( (i < m1) && (j < m2) && (k < h)) {\\n            if (ori[i] < ori[j]) {\\n                if (ori[i] < ori[k]) {\\n                    tar[l++] = ori[i++];\\n                } else {\\n                    tar[l++] = ori[k++];\\n                }\\n            } else {\\n                if (ori[j] < ori[k]) {\\n                    tar[l++] = ori[j++];\\n                } else {\\n                    tar[l++] = ori[k++];\\n                }\\n            }\\n        }\\n        \\n        while ( (i < m1) && (j < m2)) {\\n            if (ori[i] < ori[j]) {\\n                tar[l++] = ori[i++];\\n            } else {\\n                tar[l++] = ori[j++];\\n            }\\n        }\\n        \\n        while ((j < m2) && (k < h)) {\\n            if (ori[j] < ori[k]) {\\n                tar[l++] = ori[j++];\\n            } else {\\n                tar[l++] = ori[k++];\\n            }\\n        }\\n        \\n        while ( (i < m1) && (k < h)) {\\n            if (ori[i] < ori[k]) {\\n                tar[l++] = ori[i++];\\n            } else {\\n                tar[l++] = ori[k++];\\n            }\\n        }\\n        \\n        while (i < m1) {\\n            tar[l++] = ori[i++];\\n        }\\n        \\n        while (j < m2) {\\n            tar[l++] = ori[j++];\\n        }\\n        \\n        while (k < h) {\\n            tar[l++] = ori[k++];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 705134,
                "title": "python-merge-sort-easy-implementation",
                "content": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:      \\n        # Length 1 is always sorted\\n        if len(nums) == 1:\\n            return nums\\n        \\n        # Split array into two subarrays\\n        half = len(nums) // 2\\n        left = nums[:half]\\n        right = nums[half:]\\n        \\n        # Recursively break the arrays - O(log n)\\n        left = self.sortArray(left)\\n        right = self.sortArray(right)\\n        \\n        # O(n) sort\\n        return sort(left, right)\\n    \\n# Merge sort helper method\\ndef sort(a, b):\\n    out = []\\n    while a and b:\\n        if a[0] <= b[0]:\\n            out.append(a.pop(0))\\n        else:\\n            out.append(b.pop(0))\\n    if a:\\n        out += a\\n    else:\\n        out += b\\n    return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:      \\n        # Length 1 is always sorted\\n        if len(nums) == 1:\\n            return nums\\n        \\n        # Split array into two subarrays\\n        half = len(nums) // 2\\n        left = nums[:half]\\n        right = nums[half:]\\n        \\n        # Recursively break the arrays - O(log n)\\n        left = self.sortArray(left)\\n        right = self.sortArray(right)\\n        \\n        # O(n) sort\\n        return sort(left, right)\\n    \\n# Merge sort helper method\\ndef sort(a, b):\\n    out = []\\n    while a and b:\\n        if a[0] <= b[0]:\\n            out.append(a.pop(0))\\n        else:\\n            out.append(b.pop(0))\\n    if a:\\n        out += a\\n    else:\\n        out += b\\n    return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446099,
                "title": "javascript-merge-sort-and-quick-sort-solution",
                "content": "**Merge Short Solution\\n**\\n```\\nvar sortArray = function(nums) {\\n    let len = nums.length;\\n    if(len < 2) return nums;\\n    const mid = Math.floor(len / 2);\\n    const left = sortArray(nums.slice(0, mid));\\n    const right = sortArray(nums.slice(mid, len));\\n    return merge(left, right);\\n    \\n};\\n\\nfunction merge(left, right) {\\n    let res = [];\\n    while(left.length && right.length) {\\n        res.push( (left[0] < right[0]) ? left.shift() : right.shift() );\\n    }\\n    return res.concat(left, right);\\n}\\n```\\n\\n**Quick Sort Solution\\n**\\n\\n```\\nvar sortArray = function(nums) {\\n    let len = nums.length;\\n    if(len < 2) return nums;\\n    let pivot = nums[0], left=[], right = [];\\n\\n\\n    for(let i=1; i<len; i++) {\\n        if(nums[i] <= pivot) {\\n            left.push(nums[i])\\n        } else {\\n            right.push(nums[i])\\n        }\\n    }\\n    \\n    return sortArray(left).concat(pivot, sortArray(right));\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Merge Sort"
                ],
                "code": "```\\nvar sortArray = function(nums) {\\n    let len = nums.length;\\n    if(len < 2) return nums;\\n    const mid = Math.floor(len / 2);\\n    const left = sortArray(nums.slice(0, mid));\\n    const right = sortArray(nums.slice(mid, len));\\n    return merge(left, right);\\n    \\n};\\n\\nfunction merge(left, right) {\\n    let res = [];\\n    while(left.length && right.length) {\\n        res.push( (left[0] < right[0]) ? left.shift() : right.shift() );\\n    }\\n    return res.concat(left, right);\\n}\\n```\n```\\nvar sortArray = function(nums) {\\n    let len = nums.length;\\n    if(len < 2) return nums;\\n    let pivot = nums[0], left=[], right = [];\\n\\n\\n    for(let i=1; i<len; i++) {\\n        if(nums[i] <= pivot) {\\n            left.push(nums[i])\\n        } else {\\n            right.push(nums[i])\\n        }\\n    }\\n    \\n    return sortArray(left).concat(pivot, sortArray(right));\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515442,
                "title": "6-lines-java-solution-simple-solution-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\nUsed PriorityQueue to sort the input array in ascending order. A PriorityQueue is a heap-based data structure that maintains the order of its elements based on their priority. In this case, we are using a default natural ordering where smaller elements have a higher priority.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First creates an empty PriorityQueue, and then adds all the elements of the input array to the PriorityQueue using the add() method. Since PriorityQueue maintains the order of its elements, the elements are sorted as they are added to the PriorityQueue.\\n\\n- Then, iterates over the input array and replaces each element with the smallest element in the PriorityQueue using the poll() method. After iterating over all elements, the input array will be sorted in ascending order.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n      PriorityQueue<Integer> pQ = new PriorityQueue<>();\\n      for(int n:nums)\\n      pQ.add(n);\\n      for(int i=0;i<nums.length;i++)\\n      nums[i]=pQ.poll(); \\n      return nums;\\n    }\\n   \\n}\\n```\\n\\n# Brute force(Quick sort)\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n       Sort(nums,0,nums.length-1);\\n       return nums;\\n    }\\n    static void Sort(int []nums,int l,int h){\\n        if(l>=h){\\n            return ;\\n        }\\n        int s=l;\\n        int e=h;\\n        int m=s+(e-s)/2;\\n        int p=nums[m];\\n        while(s<=e){\\n            while(nums[s]<p){\\n                s++;\\n            }\\n            while(nums[e] > p){\\n                e--;\\n            }\\n            if(s<=e){\\n                int t=nums[s];\\n                nums[s]=nums[e];\\n                nums[e]=t;\\n                s++;\\n                e--;\\n            }\\n        }\\n        Sort(nums,l,e);\\n        Sort(nums,s,h);\\n    }\\n}\\n\\n```\\n\\nUpvotes are Encouraging",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n      PriorityQueue<Integer> pQ = new PriorityQueue<>();\\n      for(int n:nums)\\n      pQ.add(n);\\n      for(int i=0;i<nums.length;i++)\\n      nums[i]=pQ.poll(); \\n      return nums;\\n    }\\n   \\n}\\n```\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n       Sort(nums,0,nums.length-1);\\n       return nums;\\n    }\\n    static void Sort(int []nums,int l,int h){\\n        if(l>=h){\\n            return ;\\n        }\\n        int s=l;\\n        int e=h;\\n        int m=s+(e-s)/2;\\n        int p=nums[m];\\n        while(s<=e){\\n            while(nums[s]<p){\\n                s++;\\n            }\\n            while(nums[e] > p){\\n                e--;\\n            }\\n            if(s<=e){\\n                int t=nums[s];\\n                nums[s]=nums[e];\\n                nums[e]=t;\\n                s++;\\n                e--;\\n            }\\n        }\\n        Sort(nums,l,e);\\n        Sort(nums,s,h);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245185,
                "title": "python-3-a-cheat-version-and-a-legal-version-t-m-100-17",
                "content": "I think the time% and space% on this problem are extremely skewed because of the scofflaws who used`sort()`,`sorted`or`heapq`, not heeding the admonition on using \"built-in functions.\".\\n\\nUsing `Counter`,`chain`,`max`,or,`mn` techically makes me a scofflaw too, so I included a non-scofflaw version below as well.\\n\\nMy scofflaw version:\\n```\\nclass Solution:                                 \\n    def sortArray(self,nums:list[int]) -> list[int]:    #   Example: [3,3,1,8,6,5,5,5,5]\\n\\n        ctr  = Counter(nums)                            #   ctr = {5:4, 3:2, 1:1, 8:1, 6:1}\\n\\n        return list(chain(*([i]*ctr[i]                  #   return    list(chain( *([1]*1, [3]*2, [5]*4, [6]*1, [8]*1) ))   \\n                    for i in range(min(ctr),            #           = list(chain([1], [3,3,3], [5,5,5,5], [6], [8] ))\\n                    max(ctr)+1) if i in ctr)))          #           = [1, 3,3, 5,5,5,5, 6, 8]   \\n                    \\n\\n```\\n\\nNon-scofflaw:\\n```\\nclass Solution:\\n    def sortArray(self, nums: list[int]) -> list[int]: \\n\\n        ans, nSet, mx, mn = [],set(nums),nums[0],nums[0]\\n        d = {n:0 for n in nSet}\\n\\n        for n in nums: d[n]+= 1\\n\\n        for n in d:\\n            if n > mx: mx = n\\n            if n < mn: mn = n\\n\\n        for i in range(mn, mx+1):\\n            if i not in d: continue\\n            ans+= [i]*d[i]\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/sort-an-array/submissions/1007234945/](http://)\\n\\n\\nI could be wrong, but I think for each that time complexity is *O*(*NlogN*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:                                 \\n    def sortArray(self,nums:list[int]) -> list[int]:    #   Example: [3,3,1,8,6,5,5,5,5]\\n\\n        ctr  = Counter(nums)                            #   ctr = {5:4, 3:2, 1:1, 8:1, 6:1}\\n\\n        return list(chain(*([i]*ctr[i]                  #   return    list(chain( *([1]*1, [3]*2, [5]*4, [6]*1, [8]*1) ))   \\n                    for i in range(min(ctr),            #           = list(chain([1], [3,3,3], [5,5,5,5], [6], [8] ))\\n                    max(ctr)+1) if i in ctr)))          #           = [1, 3,3, 5,5,5,5, 6, 8]   \\n                    \\n\\n```\n```\\nclass Solution:\\n    def sortArray(self, nums: list[int]) -> list[int]: \\n\\n        ans, nSet, mx, mn = [],set(nums),nums[0],nums[0]\\n        d = {n:0 for n in nSet}\\n\\n        for n in nums: d[n]+= 1\\n\\n        for n in d:\\n            if n > mx: mx = n\\n            if n < mn: mn = n\\n\\n        for i in range(mn, mx+1):\\n            if i not in d: continue\\n            ans+= [i]*d[i]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244219,
                "title": "912-sort-an-array-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        int n = nums.size();\\n        mergeSort(nums, n);\\n        return nums;\\n    }\\n    void mergeSort(vector<int> &A, int n)\\n    {\\n        if (n < 2)\\n            return;\\n        int mid = n / 2;\\n        vector<int> L;\\n        vector<int> R;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i < mid)\\n            {\\n                L.push_back(A[i]);\\n            }\\n            else\\n                R.push_back(A[i]);\\n        }\\n        mergeSort(L, L.size());\\n        mergeSort(R, R.size());\\n        mergeArrays(A, L, R);\\n    }\\n\\n    void mergeArrays(vector<int> &A, vector<int> &L, vector<int> &R)\\n    {\\n\\n        int sizeL = L.size();\\n        int sizeR = R.size();\\n        int i = 0, j = 0, k = 0;\\n\\n        while (i < sizeL && j < sizeR)\\n        {\\n            if (L[i] <= R[j])\\n            {\\n                A[k] = L[i];\\n                i++;\\n            }\\n            else\\n            {\\n                A[k] = R[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n        while (i < sizeL)\\n        {\\n            A[k] = L[i];\\n            i++;\\n            k++;\\n        }\\n        while (j < sizeR)\\n        {\\n            A[k] = R[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        int n = nums.size();\\n        mergeSort(nums, n);\\n        return nums;\\n    }\\n    void mergeSort(vector<int> &A, int n)\\n    {\\n        if (n < 2)\\n            return;\\n        int mid = n / 2;\\n        vector<int> L;\\n        vector<int> R;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i < mid)\\n            {\\n                L.push_back(A[i]);\\n            }\\n            else\\n                R.push_back(A[i]);\\n        }\\n        mergeSort(L, L.size());\\n        mergeSort(R, R.size());\\n        mergeArrays(A, L, R);\\n    }\\n\\n    void mergeArrays(vector<int> &A, vector<int> &L, vector<int> &R)\\n    {\\n\\n        int sizeL = L.size();\\n        int sizeR = R.size();\\n        int i = 0, j = 0, k = 0;\\n\\n        while (i < sizeL && j < sizeR)\\n        {\\n            if (L[i] <= R[j])\\n            {\\n                A[k] = L[i];\\n                i++;\\n            }\\n            else\\n            {\\n                A[k] = R[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n        while (i < sizeL)\\n        {\\n            A[k] = L[i];\\n            i++;\\n            k++;\\n        }\\n        while (j < sizeR)\\n        {\\n            A[k] = R[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780708,
                "title": "sort-an-array-using-merge-sort",
                "content": "# Intuition\\n<!-- I thought of solving using merge sort using O(nlogn) complexity -->\\n\\n# Approach\\n<!-- Merge sort -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(nlogn) -->\\n\\n- Space complexity:\\n<!-- O(logn) -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        if(nums.length==1){\\n            return nums;\\n        }\\n        int mid=nums.length/2;\\n        int[] left=sortArray(Arrays.copyOfRange(nums,0,mid));\\n        int[] right=sortArray(Arrays.copyOfRange(nums,mid,nums.length));\\n        return merge(left,right);\\n    }\\n    static int[] merge(int[] first,int[] last){\\n        int[] mix=new int[first.length+last.length];\\n        int i=0,j=0,k=0;\\n        while(i<first.length && j<last.length){\\n            if(first[i]<last[j]){\\n                mix[k]=first[i];\\n                i++;\\n            }else{\\n                mix[k]=last[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n        while(i<first.length){\\n            mix[k]=first[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<last.length){\\n            mix[k]=last[j];\\n            j++;\\n            k++;\\n        }\\n        return mix;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        if(nums.length==1){\\n            return nums;\\n        }\\n        int mid=nums.length/2;\\n        int[] left=sortArray(Arrays.copyOfRange(nums,0,mid));\\n        int[] right=sortArray(Arrays.copyOfRange(nums,mid,nums.length));\\n        return merge(left,right);\\n    }\\n    static int[] merge(int[] first,int[] last){\\n        int[] mix=new int[first.length+last.length];\\n        int i=0,j=0,k=0;\\n        while(i<first.length && j<last.length){\\n            if(first[i]<last[j]){\\n                mix[k]=first[i];\\n                i++;\\n            }else{\\n                mix[k]=last[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n        while(i<first.length){\\n            mix[k]=first[i];\\n            i++;\\n            k++;\\n        }\\n        while(j<last.length){\\n            mix[k]=last[j];\\n            j++;\\n            k++;\\n        }\\n        return mix;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886607,
                "title": "python-quicksort-quick-sort-with-random-partition",
                "content": "Quick sort with random parition to make the sorting faster and to handle the worst case (when all elements are already sorted)\\n\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        self.quicksort(nums, 0, len(nums)-1)\\n        return nums\\n    \\n    def quicksort(self, nums, start, end):\\n        if start >= end:\\n            return\\n        \\n        part = self.part(nums, start, end) # partition the array\\n        self.quicksort(nums, start, part-1)\\n        self.quicksort(nums, part+1, end) # dont include the parition idx itself since left..... idx......right\\n    \\n    def part(self, nums, left, right):\\n        idx = left\\n        ran = randint(left, right)\\n        nums[right], nums[ran] = nums[ran], nums[right]\\n        pivot = nums[right]\\n        \\n        for i in range(left, right):\\n            if nums[i] <= pivot:\\n                nums[idx],nums[i] = nums[i], nums[idx]\\n                idx+=1\\n        \\n        nums[idx],nums[right] = nums[right], nums[idx]\\n        return idx # return the idx for part\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        self.quicksort(nums, 0, len(nums)-1)\\n        return nums\\n    \\n    def quicksort(self, nums, start, end):\\n        if start >= end:\\n            return\\n        \\n        part = self.part(nums, start, end) # partition the array\\n        self.quicksort(nums, start, part-1)\\n        self.quicksort(nums, part+1, end) # dont include the parition idx itself since left..... idx......right\\n    \\n    def part(self, nums, left, right):\\n        idx = left\\n        ran = randint(left, right)\\n        nums[right], nums[ran] = nums[ran], nums[right]\\n        pivot = nums[right]\\n        \\n        for i in range(left, right):\\n            if nums[i] <= pivot:\\n                nums[idx],nums[i] = nums[i], nums[idx]\\n                idx+=1\\n        \\n        nums[idx],nums[right] = nums[right], nums[idx]\\n        return idx # return the idx for part\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800787,
                "title": "fix-if-you-are-getting-tle-using-quick-sort",
                "content": "I was getting TLE using QuickSort.\\nI was always selecting the end element as the pivot. It seems that there are test cases designed to punish you for this, for example if the test case is nearly sorted, it will become O(n^2).\\n\\nA simple solution is to swap the middle element with the end element, before selecting the end element as the pivot.\\ne.g.\\n```\\nvar mid = (start+end)/2;\\nSwap(mid, end);\\nvar pivot = nums[end];\\n```\\nOr else you can use a more complicated pivot selection method",
                "solutionTags": [],
                "code": "```\\nvar mid = (start+end)/2;\\nSwap(mid, end);\\nvar pivot = nums[end];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1482867,
                "title": "randomize-quick-sort-worst-case-time-o-nlogn",
                "content": "```cpp\\n    int partition(vector<int>&arr,int start,int end){\\n        int pivot=arr[end];\\n        int partIdx=start;\\n        for(int i=start;i<end;i++){\\n            if(arr[i]<=pivot){\\n                swap(arr[i],arr[partIdx]);\\n                partIdx++;\\n            }\\n        }\\n        swap(arr[partIdx],arr[end]);\\n        return partIdx;\\n    }\\n    int randompartition(vector<int>&arr,int start,int end){\\n\\t\\t//select random element of array :\\n        srand(time(NULL));\\n        int pI = start + rand() % (end - start);\\n        swap(arr[pI],arr[end]);\\n        return partition(arr,start,end);\\n    }\\n    void quickSort(vector<int>&arr,int start,int end){\\n        if(start<end){\\n            int partitionIndex=randompartition(arr,start,end);\\n            quickSort(arr,start,partitionIndex-1);\\n            quickSort(arr,partitionIndex+1,end);\\n        }\\n    }\\n    vector<int> sortArray(vector<int>& arr) {\\n        //Quick sort : time: O(nlogn) and space : O(1)\\n        quickSort(arr,0,arr.size()-1); \\n        return arr;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```cpp\\n    int partition(vector<int>&arr,int start,int end){\\n        int pivot=arr[end];\\n        int partIdx=start;\\n        for(int i=start;i<end;i++){\\n            if(arr[i]<=pivot){\\n                swap(arr[i],arr[partIdx]);\\n                partIdx++;\\n            }\\n        }\\n        swap(arr[partIdx],arr[end]);\\n        return partIdx;\\n    }\\n    int randompartition(vector<int>&arr,int start,int end){\\n\\t\\t//select random element of array :\\n        srand(time(NULL));\\n        int pI = start + rand() % (end - start);\\n        swap(arr[pI],arr[end]);\\n        return partition(arr,start,end);\\n    }\\n    void quickSort(vector<int>&arr,int start,int end){\\n        if(start<end){\\n            int partitionIndex=randompartition(arr,start,end);\\n            quickSort(arr,start,partitionIndex-1);\\n            quickSort(arr,partitionIndex+1,end);\\n        }\\n    }\\n    vector<int> sortArray(vector<int>& arr) {\\n        //Quick sort : time: O(nlogn) and space : O(1)\\n        quickSort(arr,0,arr.size()-1); \\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1396338,
                "title": "js-all-sorting-algorithms-quick-merge-bucket-tree-heap-and-others",
                "content": "## Merge Sort : O(n log n) time O(n) space \\n\\n```\\nconst merge = (left, right) => {\\n    const mergeArr = [];\\n    let i=0,j=0;\\n    while(i < left.length && j < right.length) {\\n        if (left[i] <right[j]) {\\n            mergeArr.push(left[i++]);\\n        } else {\\n            mergeArr.push(right[j++]);\\n        }\\n    }\\n    while (i < left.length) {\\n        mergeArr.push(left[i++]);\\n    }\\n    while (j < right.length) {\\n        mergeArr.push(right[j++]);\\n    }\\n    \\n    return mergeArr;\\n}\\nconst mergeSort = (nums, start,end) => {\\n    if (end == start) {\\n        return [nums[start]];\\n    }\\n    const mid   = start + Math.floor((end-start)/2);\\n    const left  = mergeSort(nums, start, mid);\\n    const right = mergeSort(nums, mid+1, end);\\n    const mergeArr = merge(left, right);\\n\\n    return mergeArr;\\n}\\nvar sortArray = function(nums) {\\n    return mergeSort(nums, 0, nums.length-1);\\n};\\n/*\\n* Runtime: 140 ms, faster than 73.51% of JavaScript online submissions for Sort an Array.\\n* Memory Usage: 54.4 MB, less than 37.99% of JavaScript online submissions for Sort an Array.\\n*/\\n```\\n\\n\\n\\n## Quick Sort :O(n log n) time O(1) space | worst case O(n^2)\\n\\n```\\nconst swap = (nums, start,end) => {\\n    [nums[start],nums[end]] = [nums[end],nums[start]];\\n}\\nconst partition = (nums, start, end, pivot) => {\\n    let left = start, right=end;\\n    while(left <= right) {\\n        while(nums[left] < pivot && left <= end) {\\n            left++;\\n        }\\n        while(left <=right && nums[right] > pivot && right >= start) {\\n            right--;\\n        }\\n        if (left <= right) {\\n            swap(nums, left, right);\\n            left++;\\n            right--;\\n        }\\n    }\\n    \\n    return left;\\n}\\nconst quickSort = (nums, start, end) => {\\n    if (start >= end) return ;\\n    const mid = start + Math.floor((end-start)/2);\\n    const idx = partition(nums, start, end, nums[mid]);\\n    quickSort(nums, start, idx-1);\\n    quickSort(nums, idx, end); \\n}\\n\\nvar sortArray = function(nums) {\\n    quickSort(nums, 0, nums.length-1);\\n    return nums;\\n    \\n};\\n/*\\n*\\n* Runtime: 124 ms, faster than 96.80% of JavaScript online submissions for Sort an Array.\\n* Memory Usage: 50.2 MB, less than 70.74% of JavaScript online submissions for Sort an Array.\\n*\\n*/\\n\\n```\\n## Heap Sort : O(n log n) time O(1) space\\n```\\nconst heapify = (nums, n) => {\\n    const parent = Math.floor((n-1)/2);\\n    if (parent < 0) {\\n        return;\\n    }\\n    if (nums[parent] > nums[n]) {\\n        return;\\n    }\\n    [nums[parent],nums[n]] = [nums[n],nums[parent]];\\n    return heapify(nums, parent)\\n}\\n\\nconst updateHeap = (nums,n, lastIdx) => {\\n    if (n > lastIdx) return;\\n    const [left,right] = [2*n+1, 2*n+2];\\n    \\n    if (left > lastIdx) {\\n        return;\\n    }\\n    let next = left;\\n    if (right <= lastIdx && nums[left] < nums[right] ) {\\n        next = right\\n    }\\n    if (nums[next] > nums[n]) {\\n        [nums[n], nums[next]] = [nums[next],nums[n]];\\n        updateHeap(nums, next, lastIdx);\\n    } \\n\\n}\\nconst sortArray = function(nums) {\\n    for(let i=1; i<nums.length;i++) {\\n        heapify(nums, i);\\n    }\\n    for(let i=nums.length-1;i >0;i--) {\\n        const max = nums[0];\\n        nums[0] = nums[i];\\n        updateHeap(nums, 0, i-1);\\n        nums[i] = max;\\n    }\\n    return nums;\\n};\\n\\n/*\\n*\\n*Runtime: 168 ms, faster than 52.18% of JavaScript online submissions for Sort an Array.\\n*Memory Usage: 49.9 MB, less than 72.85% of JavaScript online submissions for Sort an Array.\\n*\\n*/\\n```\\n# Bucket Sort : 0(d*n) t.c O(n) s.c\\n`d = number of digits in max number `\\n\\n```\\nconst bucketSort = nums => {\\n    let place = 1, max = -Infinity;\\n    for(const num of nums) {\\n        max = Math.max(max, num);\\n    }\\n    const dcount = String(max).length;\\n    for(let i =0 ;i< dcount; i++) {\\n        const digits = Array.from(new Array(10), () => []);\\n        for(const num of nums) {\\n            const d =  Math.floor(num/place) % 10;\\n            digits[d].push(num);\\n        }\\n        let idx  = 0;\\n        for(const digit  of digits) {\\n            for(const num of digit) {\\n                nums[idx++] = num;\\n            }\\n        }\\n        place *= 10;  \\n    }\\n} \\n\\nvar sortArray = function(nums) {\\n    const p = [];\\n    const n = [];\\n    for(const num of nums) {\\n        const arr = num < 0 ? n : p;\\n        arr.push(Math.abs(num));\\n    }\\n    bucketSort(p);\\n    bucketSort(n);\\n    let idx =0;\\n    for(let i=n.length-1;i >= 0 ;i--) {\\n        nums[idx++] = -n[i];\\n    }\\n    for(const pnum of p) {\\n        nums[idx++] = pnum;\\n    }\\n    \\n    return nums;\\n};\\n\\n```\\n## Tree Sort : O(n log n) time space O(n) space \\nWorst case O(n^2)(unbalanced tree) \\nFor balanced tree worst O(n log n) time \\n```\\nclass Tree {\\n    constructor(val, left=null, right=null) {\\n        this.val = val;\\n        this.count = 1;\\n        this.left = left;\\n        this.right = right;\\n    }\\n}\\n\\nconst find = (root, val) => {\\n    let node = root;\\n    while(node !== null) {\\n        if (node.val == val) {\\n            return node;\\n        }\\n        if (node.val > val) {\\n            if (!node.left) {\\n                return node;\\n            }\\n            node = node.left;\\n        } else {\\n            if (!node.right) {\\n                return node;\\n            }\\n            node = node.right;\\n        }\\n\\n    }\\n}\\nconst insert = (root, val) => {\\n    const node  = find(root, val);\\n    if (node.val == val) {\\n        node.count += 1;\\n        return;\\n\\n    }\\n    if (node.val > val) {\\n        node.left = new Tree(val);\\n    } else {\\n        node.right = new Tree(val);\\n    }\\n}\\nconst inorder = (root, nums,idx) => {\\n    if (!root) return ;\\n    inorder(root.left, nums, idx);\\n    const val = root.val;\\n    for(let i=0;i<root.count;i++) {\\n        nums[idx.n] = val;\\n        idx.n += 1;\\n    }\\n  \\n   inorder(root.right,nums,idx);\\n}\\nvar sortArray = function(nums) {\\n    const root = new Tree(nums[0]);\\n    for(let i=1;i<nums.length;i++) {\\n        insert(root, nums[i]);\\n    }\\n    const idx = {n:0};\\n    inorder(root, nums, idx);\\n    \\n    return nums;\\n}\\n\\n/*\\nThough Tree sort passes test but is slow, blanced tree will be faster. \\nRuntime: 7356 ms, faster than 5.01% of JavaScript online submissions for Sort an Array.\\nMemory Usage: 59.1 MB, less than 8.95% of JavaScript online submissions for Sort an Array.\\n*/\\n```\\n\\n## Insertion Sort : O(n^2) time O(1) space | best O(n) time [TLE]\\n\\n```\\nvar sortArray = function(nums) { \\n    for(let i=1;i<nums.length;i++) {\\n        if(nums[i-1] > nums[i]) {\\n            let j=i;\\n            while(j>=0 && nums[j-1] > nums[j]) {\\n                [nums[j-1], nums[j]] = [nums[j], nums[j-1]];\\n                j--;\\n            }\\n        }\\n    }\\n    return nums;\\n}\\n```\\n\\n## Bubble Sort : O(n^2) time [TLE]\\n\\n```\\nvar sortArray = function(nums) {\\n    for(let i=0;i<nums.length;i++) {\\n        for(let j=0;j<nums.length;j++) {\\n            if (j <nums.length-1 && nums[j] > nums[j+1]) {\\n                [nums[j],nums[j+1]] = [nums[j+1], nums[j]];\\n            }\\n        }\\n    }\\n    \\n    return nums;\\n};\\n```\\n\\n\\nI will add more if i feel bored and feel like coding a Sorting algorithm. \\uD83D\\uDE05 \\uD83E\\uDD20",
                "solutionTags": [
                    "JavaScript",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```\\nconst merge = (left, right) => {\\n    const mergeArr = [];\\n    let i=0,j=0;\\n    while(i < left.length && j < right.length) {\\n        if (left[i] <right[j]) {\\n            mergeArr.push(left[i++]);\\n        } else {\\n            mergeArr.push(right[j++]);\\n        }\\n    }\\n    while (i < left.length) {\\n        mergeArr.push(left[i++]);\\n    }\\n    while (j < right.length) {\\n        mergeArr.push(right[j++]);\\n    }\\n    \\n    return mergeArr;\\n}\\nconst mergeSort = (nums, start,end) => {\\n    if (end == start) {\\n        return [nums[start]];\\n    }\\n    const mid   = start + Math.floor((end-start)/2);\\n    const left  = mergeSort(nums, start, mid);\\n    const right = mergeSort(nums, mid+1, end);\\n    const mergeArr = merge(left, right);\\n\\n    return mergeArr;\\n}\\nvar sortArray = function(nums) {\\n    return mergeSort(nums, 0, nums.length-1);\\n};\\n/*\\n* Runtime: 140 ms, faster than 73.51% of JavaScript online submissions for Sort an Array.\\n* Memory Usage: 54.4 MB, less than 37.99% of JavaScript online submissions for Sort an Array.\\n*/\\n```\n```\\nconst swap = (nums, start,end) => {\\n    [nums[start],nums[end]] = [nums[end],nums[start]];\\n}\\nconst partition = (nums, start, end, pivot) => {\\n    let left = start, right=end;\\n    while(left <= right) {\\n        while(nums[left] < pivot && left <= end) {\\n            left++;\\n        }\\n        while(left <=right && nums[right] > pivot && right >= start) {\\n            right--;\\n        }\\n        if (left <= right) {\\n            swap(nums, left, right);\\n            left++;\\n            right--;\\n        }\\n    }\\n    \\n    return left;\\n}\\nconst quickSort = (nums, start, end) => {\\n    if (start >= end) return ;\\n    const mid = start + Math.floor((end-start)/2);\\n    const idx = partition(nums, start, end, nums[mid]);\\n    quickSort(nums, start, idx-1);\\n    quickSort(nums, idx, end); \\n}\\n\\nvar sortArray = function(nums) {\\n    quickSort(nums, 0, nums.length-1);\\n    return nums;\\n    \\n};\\n/*\\n*\\n* Runtime: 124 ms, faster than 96.80% of JavaScript online submissions for Sort an Array.\\n* Memory Usage: 50.2 MB, less than 70.74% of JavaScript online submissions for Sort an Array.\\n*\\n*/\\n\\n```\n```\\nconst heapify = (nums, n) => {\\n    const parent = Math.floor((n-1)/2);\\n    if (parent < 0) {\\n        return;\\n    }\\n    if (nums[parent] > nums[n]) {\\n        return;\\n    }\\n    [nums[parent],nums[n]] = [nums[n],nums[parent]];\\n    return heapify(nums, parent)\\n}\\n\\nconst updateHeap = (nums,n, lastIdx) => {\\n    if (n > lastIdx) return;\\n    const [left,right] = [2*n+1, 2*n+2];\\n    \\n    if (left > lastIdx) {\\n        return;\\n    }\\n    let next = left;\\n    if (right <= lastIdx && nums[left] < nums[right] ) {\\n        next = right\\n    }\\n    if (nums[next] > nums[n]) {\\n        [nums[n], nums[next]] = [nums[next],nums[n]];\\n        updateHeap(nums, next, lastIdx);\\n    } \\n\\n}\\nconst sortArray = function(nums) {\\n    for(let i=1; i<nums.length;i++) {\\n        heapify(nums, i);\\n    }\\n    for(let i=nums.length-1;i >0;i--) {\\n        const max = nums[0];\\n        nums[0] = nums[i];\\n        updateHeap(nums, 0, i-1);\\n        nums[i] = max;\\n    }\\n    return nums;\\n};\\n\\n/*\\n*\\n*Runtime: 168 ms, faster than 52.18% of JavaScript online submissions for Sort an Array.\\n*Memory Usage: 49.9 MB, less than 72.85% of JavaScript online submissions for Sort an Array.\\n*\\n*/\\n```\n```\\nconst bucketSort = nums => {\\n    let place = 1, max = -Infinity;\\n    for(const num of nums) {\\n        max = Math.max(max, num);\\n    }\\n    const dcount = String(max).length;\\n    for(let i =0 ;i< dcount; i++) {\\n        const digits = Array.from(new Array(10), () => []);\\n        for(const num of nums) {\\n            const d =  Math.floor(num/place) % 10;\\n            digits[d].push(num);\\n        }\\n        let idx  = 0;\\n        for(const digit  of digits) {\\n            for(const num of digit) {\\n                nums[idx++] = num;\\n            }\\n        }\\n        place *= 10;  \\n    }\\n} \\n\\nvar sortArray = function(nums) {\\n    const p = [];\\n    const n = [];\\n    for(const num of nums) {\\n        const arr = num < 0 ? n : p;\\n        arr.push(Math.abs(num));\\n    }\\n    bucketSort(p);\\n    bucketSort(n);\\n    let idx =0;\\n    for(let i=n.length-1;i >= 0 ;i--) {\\n        nums[idx++] = -n[i];\\n    }\\n    for(const pnum of p) {\\n        nums[idx++] = pnum;\\n    }\\n    \\n    return nums;\\n};\\n\\n```\n```\\nclass Tree {\\n    constructor(val, left=null, right=null) {\\n        this.val = val;\\n        this.count = 1;\\n        this.left = left;\\n        this.right = right;\\n    }\\n}\\n\\nconst find = (root, val) => {\\n    let node = root;\\n    while(node !== null) {\\n        if (node.val == val) {\\n            return node;\\n        }\\n        if (node.val > val) {\\n            if (!node.left) {\\n                return node;\\n            }\\n            node = node.left;\\n        } else {\\n            if (!node.right) {\\n                return node;\\n            }\\n            node = node.right;\\n        }\\n\\n    }\\n}\\nconst insert = (root, val) => {\\n    const node  = find(root, val);\\n    if (node.val == val) {\\n        node.count += 1;\\n        return;\\n\\n    }\\n    if (node.val > val) {\\n        node.left = new Tree(val);\\n    } else {\\n        node.right = new Tree(val);\\n    }\\n}\\nconst inorder = (root, nums,idx) => {\\n    if (!root) return ;\\n    inorder(root.left, nums, idx);\\n    const val = root.val;\\n    for(let i=0;i<root.count;i++) {\\n        nums[idx.n] = val;\\n        idx.n += 1;\\n    }\\n  \\n   inorder(root.right,nums,idx);\\n}\\nvar sortArray = function(nums) {\\n    const root = new Tree(nums[0]);\\n    for(let i=1;i<nums.length;i++) {\\n        insert(root, nums[i]);\\n    }\\n    const idx = {n:0};\\n    inorder(root, nums, idx);\\n    \\n    return nums;\\n}\\n\\n/*\\nThough Tree sort passes test but is slow, blanced tree will be faster. \\nRuntime: 7356 ms, faster than 5.01% of JavaScript online submissions for Sort an Array.\\nMemory Usage: 59.1 MB, less than 8.95% of JavaScript online submissions for Sort an Array.\\n*/\\n```\n```\\nvar sortArray = function(nums) { \\n    for(let i=1;i<nums.length;i++) {\\n        if(nums[i-1] > nums[i]) {\\n            let j=i;\\n            while(j>=0 && nums[j-1] > nums[j]) {\\n                [nums[j-1], nums[j]] = [nums[j], nums[j-1]];\\n                j--;\\n            }\\n        }\\n    }\\n    return nums;\\n}\\n```\n```\\nvar sortArray = function(nums) {\\n    for(let i=0;i<nums.length;i++) {\\n        for(let j=0;j<nums.length;j++) {\\n            if (j <nums.length-1 && nums[j] > nums[j+1]) {\\n                [nums[j],nums[j+1]] = [nums[j+1], nums[j]];\\n            }\\n        }\\n    }\\n    \\n    return nums;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794513,
                "title": "c-recursive-merge-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> mergeSorted(vector<int>& a, vector<int>& b)\\n    {\\n        vector<int> res;\\n        int i=0, j=0;\\n        while (i<a.size() && j<b.size())\\n        {\\n            if (a[i] < b[j])\\n            {\\n                res.push_back(a[i]);\\n                i++;\\n            }\\n            else\\n            {\\n                res.push_back(b[j]);\\n                j++;\\n            }\\n        }\\n        while (i < a.size())\\n        {\\n            res.push_back(a[i]);\\n            i++;\\n        }\\n        while (j < b.size())\\n        {\\n            res.push_back(b[j]);\\n            j++;\\n        }\\n        return res;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if (nums.size() <= 1)\\n            return nums;\\n        auto start = nums.begin();\\n        auto mid = nums.begin() + nums.size()/2;\\n        auto end = nums.end();\\n        vector<int> v1(start, mid);\\n        vector<int> v2(mid, end);\\n        vector<int> left = sortArray(v1);\\n        vector<int> right = sortArray(v2);\\n        return mergeSorted(left, right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mergeSorted(vector<int>& a, vector<int>& b)\\n    {\\n        vector<int> res;\\n        int i=0, j=0;\\n        while (i<a.size() && j<b.size())\\n        {\\n            if (a[i] < b[j])\\n            {\\n                res.push_back(a[i]);\\n                i++;\\n            }\\n            else\\n            {\\n                res.push_back(b[j]);\\n                j++;\\n            }\\n        }\\n        while (i < a.size())\\n        {\\n            res.push_back(a[i]);\\n            i++;\\n        }\\n        while (j < b.size())\\n        {\\n            res.push_back(b[j]);\\n            j++;\\n        }\\n        return res;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if (nums.size() <= 1)\\n            return nums;\\n        auto start = nums.begin();\\n        auto mid = nums.begin() + nums.size()/2;\\n        auto end = nums.end();\\n        vector<int> v1(start, mid);\\n        vector<int> v2(mid, end);\\n        vector<int> left = sortArray(v1);\\n        vector<int> right = sortArray(v2);\\n        return mergeSorted(left, right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534961,
                "title": "java-lazysort",
                "content": "```\\nclass Solution {\\n    private static final int BBL = 30;\\n    private static final int SLT = 50;\\n    private static final int IST = 80;\\n    private static final int QCK = 300;\\n    private static final int LZY = 1000;\\n    private static final Random rnd = new Random();\\n    int[] ns;\\n    int n;\\n    public List<Integer> sortArray(int[] nums) {\\n        this.ns = nums;\\n        n = nums.length;\\n        if (n < BBL){\\n            bbl(); \\n        } else if (n < SLT) {\\n            slt();\\n        } else if (n < IST){\\n            ist();\\n        } else if (n < QCK){\\n            quick(0, n - 1);\\n        } else if (n < LZY) {\\n            mrg(0, n - 1);\\n        } else {\\n            lazySort();\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i : ns){\\n            res.add(i);\\n        }\\n        return res;\\n    }\\n    \\n    private void ist(){\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j > 0; j--) {\\n                if (ns[j] < ns[j - 1]){\\n                    swap(j, j - 1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private void bbl(){\\n        for (int i = n - 1; i >= 0; i--){\\n            for (int j = 0; j < i; j++) {\\n                if (ns[j] > ns[j + 1]){\\n                    swap(j, j + 1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private void mrg(int st, int ed) {\\n        if (st >= ed) return;\\n        int mid = (st + ed) >> 1;\\n        mrg(st, mid);\\n        mrg(mid + 1, ed);\\n        merge(st, mid, ed);\\n    }\\n    \\n    private void merge(int st, int mid, int ed){\\n        int[] arr = new int[ed - st + 1];\\n        int i = st, j = mid + 1, index = 0;\\n        while(i <= mid && j <= ed) {\\n            if (ns[i] < ns[j]) {\\n                arr[index++] = ns[i++];\\n            } else {\\n                arr[index++] = ns[j++];\\n            }\\n        }\\n        while(i <= mid) {\\n            arr[index++] = ns[i++];\\n        }\\n        while(j <= ed) {\\n            arr[index++] = ns[j++];\\n        }\\n        index = 0;\\n        while (st <= ed){\\n            ns[st++] = arr[index++];\\n        }\\n    }\\n    \\n    private void quick(int st, int ed){\\n        if (st >= ed) return;\\n        int p = st + rnd.nextInt(ed - st + 1);\\n        int pv = ns[p], idx = st + 1;\\n        swap(st, p);\\n        for (int i = st + 1; i <= ed; i++){\\n            if (ns[i] < pv) {\\n                swap(i, idx);     // remember idx++;\\n                idx++;\\n            }\\n        }\\n        swap(st, --idx);  // bug point\\n        quick(st, idx - 1);\\n        quick(idx + 1, ed);\\n    }\\n    \\n    private void slt() {\\n        for (int i = 0; i < n; i++) {\\n            int minIdx = i;\\n            for (int j = i + 1; j < n; j++){\\n                if (ns[j] < ns[minIdx]){\\n                    minIdx = j;\\n                }\\n            }\\n            swap(i, minIdx);\\n        }\\n    }\\n    \\n    private void lazySort(){\\n        Arrays.sort(ns);\\n    }\\n    \\n    private void swap(int i, int j){\\n        if (i == j) return;  // not working ofr i == j\\n        ns[i] ^= ns[j];\\n        ns[j] ^= ns[i];\\n        ns[i] ^= ns[j];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int BBL = 30;\\n    private static final int SLT = 50;\\n    private static final int IST = 80;\\n    private static final int QCK = 300;\\n    private static final int LZY = 1000;\\n    private static final Random rnd = new Random();\\n    int[] ns;\\n    int n;\\n    public List<Integer> sortArray(int[] nums) {\\n        this.ns = nums;\\n        n = nums.length;\\n        if (n < BBL){\\n            bbl(); \\n        } else if (n < SLT) {\\n            slt();\\n        } else if (n < IST){\\n            ist();\\n        } else if (n < QCK){\\n            quick(0, n - 1);\\n        } else if (n < LZY) {\\n            mrg(0, n - 1);\\n        } else {\\n            lazySort();\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i : ns){\\n            res.add(i);\\n        }\\n        return res;\\n    }\\n    \\n    private void ist(){\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j > 0; j--) {\\n                if (ns[j] < ns[j - 1]){\\n                    swap(j, j - 1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private void bbl(){\\n        for (int i = n - 1; i >= 0; i--){\\n            for (int j = 0; j < i; j++) {\\n                if (ns[j] > ns[j + 1]){\\n                    swap(j, j + 1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private void mrg(int st, int ed) {\\n        if (st >= ed) return;\\n        int mid = (st + ed) >> 1;\\n        mrg(st, mid);\\n        mrg(mid + 1, ed);\\n        merge(st, mid, ed);\\n    }\\n    \\n    private void merge(int st, int mid, int ed){\\n        int[] arr = new int[ed - st + 1];\\n        int i = st, j = mid + 1, index = 0;\\n        while(i <= mid && j <= ed) {\\n            if (ns[i] < ns[j]) {\\n                arr[index++] = ns[i++];\\n            } else {\\n                arr[index++] = ns[j++];\\n            }\\n        }\\n        while(i <= mid) {\\n            arr[index++] = ns[i++];\\n        }\\n        while(j <= ed) {\\n            arr[index++] = ns[j++];\\n        }\\n        index = 0;\\n        while (st <= ed){\\n            ns[st++] = arr[index++];\\n        }\\n    }\\n    \\n    private void quick(int st, int ed){\\n        if (st >= ed) return;\\n        int p = st + rnd.nextInt(ed - st + 1);\\n        int pv = ns[p], idx = st + 1;\\n        swap(st, p);\\n        for (int i = st + 1; i <= ed; i++){\\n            if (ns[i] < pv) {\\n                swap(i, idx);     // remember idx++;\\n                idx++;\\n            }\\n        }\\n        swap(st, --idx);  // bug point\\n        quick(st, idx - 1);\\n        quick(idx + 1, ed);\\n    }\\n    \\n    private void slt() {\\n        for (int i = 0; i < n; i++) {\\n            int minIdx = i;\\n            for (int j = i + 1; j < n; j++){\\n                if (ns[j] < ns[minIdx]){\\n                    minIdx = j;\\n                }\\n            }\\n            swap(i, minIdx);\\n        }\\n    }\\n    \\n    private void lazySort(){\\n        Arrays.sort(ns);\\n    }\\n    \\n    private void swap(int i, int j){\\n        if (i == j) return;  // not working ofr i == j\\n        ns[i] ^= ns[j];\\n        ns[j] ^= ns[i];\\n        ns[i] ^= ns[j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526014,
                "title": "c-merge-sort-quick-sort-heap-sort-bubble-sort-insert-sort-selection-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    1. Bubble sort:\\n    Worstcase time: O(n^2), Bestcase Time: O(n) -  list already sorted, Space: O(1)\\n    */\\n    vector<int> bubbleSort(vector<int>& nums) {\\n        for(int i=0;i<nums.size()-1;i++){\\n            bool found = false;\\n            for (int j=0;j<nums.size()-i-1;j++){\\n                if (nums[j]>nums[j+1]){\\n                    found = true;\\n                    swap(nums[j],nums[j+1]);\\n                }\\n            }\\n            if (!found)\\n                return nums;\\n        }\\n        return nums;\\n    }\\n    \\n\\t\\n    /*\\n    2. Insertion sort: (Inserting ith element in the proper position)\\n    Worstcase time: O(n^2), Bestcase Time: O(n) - list already sorted, Space: O(1)\\n    */\\n    vector<int> insertionSort(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            int j = i;\\n            while (j>0 && nums[j-1]>nums[j]){\\n                swap(nums[j],nums[j-1]);\\n                j--;\\n            }\\n        }\\n        return nums;   \\n    }\\n\\n\\n    /*\\n    3. Selection sort: (Select the  min/max value based on current element and swap it)\\n    Worstcase time: O(n^2), Bestcase Time: O(n^2), Space: O(1)\\n    */\\n    vector<int> selectionSort(vector<int>& nums) {\\n        for(int i=0;i<nums.size()-1;i++){\\n            int minIndex = i;\\n            for (int j=i+1;j<nums.size();j++){\\n                if (nums[minIndex]>nums[j])\\n                    minIndex = j;\\n            }\\n            swap(nums[i], nums[minIndex]);\\n        }\\n        return nums;\\n    }\\n\\n\\n    /*\\n    4. Merge sort: (divide and concur)\\n    Worstcase time: O(nlogn), Bestcase Time: O(nlogn), Space: O(n) (not considering recursion call stack space)\\n    It is a divide and concure technique which \\n    Divide: Break the given problem into sub-problems of same type.\\n    Conquer: Recursively solve these sub-problems\\n    Combine: Appropriately combine the answers\\n    1. Base operation: find the mid elemet\\n    2. Divide and  concure part: divide the array into two halves and recursively solve these sub-problems\\n    3. Combine part: appropriately add sorted two halves arrays\\n    T(n) = 0(1)(Finding mid index -- preprocessing) + 2T(n/2) + O(N) (merging - postprocessing)\\n    T(n) = 2T(n/2) + O(n) --> O(nlong)\\n    T(N) = aT(n/b) + f(n) -- >  logn(baseb) is the height and max no of leafs is a^heigh and total number a^(height+1)-1 (Here n is the length of the array)\\n    According to master method:\\n    T(N) = aT(n/b) + f(n)\\n    T(n) = \\u0398(nloga(baseb)) when f(n) has slower growth that n^loga(baseb)\\n    T(n) = \\u0398(nloga(baseb) log n) when f(n) has equal growth that n^loga(baseb)\\n    T(n) = \\u0398(f(n)) when f(n) has faster growth that n^loga(baseb) \\n    */\\n    void merge(vector<int>& nums, int low, int mid, int high) {\\n        int leftLength = mid-low + 1;\\n        int rightLength = high -mid; // high-(mid+1)+1\\n        vector<int> leftList(nums.begin()+low, nums.begin()+mid+1);\\n        vector<int> rightList(nums.begin()+mid+1, nums.begin()+high+1); \\n        int i=0,j=0,cur=low;\\n        while(i<leftLength && j<rightLength){\\n            if (leftList[i]<rightList[j]){\\n                nums[cur] = leftList[i];\\n                i++;\\n                cur++;\\n            } else {\\n                nums[cur] = rightList[j];\\n                j++;\\n                cur++;              \\n            }   \\n        }\\n        while(i<leftLength){\\n            nums[cur] = leftList[i];\\n            i++;\\n            cur++;\\n        }\\n         while(j<rightLength){\\n            nums[cur] = rightList[j];\\n            j++;\\n            cur++;\\n        }        \\n    }\\n    void mergeSortHelper(vector<int>& nums, int low, int high) {\\n        if (low<high){\\n            int mid = (high-low)/2 + low;\\n            mergeSortHelper(nums, low, mid);\\n            mergeSortHelper(nums, mid+1, high);\\n            merge(nums, low, mid, high);\\n        }\\n    }\\n    vector<int> mergeSort(vector<int>& nums) {\\n        mergeSortHelper(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n\\n\\n    /*\\n    5. Heapsort (Using heap)\\n    Worstcase time: O(nlogn), Bestcase Time: O(n)(when all elements are same then heapify will not cost O(logn), it will be O(1)), Space: O(1) (not including recursive function stack space.)\\n    */    \\n    // heapify opertaion for max heap\\n    void heapify(vector<int>& nums, int index, int size){\\n        int lChildIndex = 2*index +1;\\n        int rChildIndex = 2*index +2;\\n        int nextIndex = index;\\n        if (lChildIndex<size && nums[lChildIndex]>nums[nextIndex])\\n            nextIndex = lChildIndex;\\n        if (rChildIndex<size && nums[rChildIndex]>nums[nextIndex])\\n            nextIndex = rChildIndex;\\n        if (nextIndex != index){\\n            swap(nums[index], nums[nextIndex]);\\n            heapify(nums, nextIndex, size);\\n        }\\n    }\\n    void heapSortHelper(vector<int>& nums){\\n        // Make the array as max heap. Time complexity is O(n), it is not nlogn because height considered in each call is not the same and decreases.\\n        for (int i=nums.size()/2;i>=0;i--){ \\n            heapify(nums, i, nums.size());\\n        }\\n        // Swap 0th element with last, as 0 will be the max element and then heapify the 0th element by passing size as last-1. Time complexity is nlogn, and it will be n if all elements are same.\\n        for (int i=nums.size()-1;i>=0;i--){\\n            swap(nums[0], nums[i]);\\n            heapify(nums, 0, i);\\n        }\\n    }\\n    vector<int> heapSort(vector<int>& nums) {\\n        heapSortHelper(nums);\\n        return nums;\\n    }\\n\\n\\n    /*\\n    6. Quick sort:\\n    Worstcase time: O(n^2), Bestcase Time: O(nlogn), Ave: O(nlogn), Space: O(1)-- not including recursive function stack space.\\n    Quicksort uses divide-and-conquer approach.\\n    1. Base operation: find pivot element\\n    2. Divide and concure art: divide the array into two halves and recursselvy quicksort the array\\n    3. Combine part do nothing\\n    best case and avg case when partition element is around middle and in that case\\n    T(n) = O(n) + 2T((n-1)/2) + Nothing -- best case \\n    T(n) = O(n) + T(9n/10)+ T(n/10) -- > O(n logn) -- averge case\\n    Worstcase when partition element is around start and end every time -- revered sorted input list provided here:\\n    T(n) = O(n) + T(n-1) + Nothing -- > O(n + n-1 + n-2 + .. ) --> O(n^2)\\n    We can use randomized quicksort which gives worst case complexity as O(n logn) by picking pivot element randomly.  But it can not gurantee, complexity can go to O(n^2) here also.\\n    */\\n    \\n    int partitionIndex(vector<int>& nums, int low, int high){\\n        int index = low-1;\\n        for (int j=low;j<=high;j++){\\n            if (nums[j]<= nums[high]){\\n                index++;\\n                swap(nums[index], nums[j]);\\n            }\\n        }\\n        return index;\\n    }\\n    void quickSortHelper(vector<int>& nums, int low, int high){\\n        if (low<high){\\n            int p = partitionIndex(nums, low, high);\\n            quickSortHelper(nums, low, p-1);\\n            quickSortHelper(nums, p+1, high);\\n        }\\n    }\\n    vector<int> quickSort(vector<int>& nums) {\\n        quickSortHelper(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n    /*\\n    Note considering high index for finding partition element gives O(n^2) time complexity in case list is sorted in reverse order. So to increase the probability of getting O(nlogn) complexity, randomized quick sort can be used. \\n    int partitionIndex(vector<int>& nums, int low, int high){\\n        int randIndex = low + rand()%(high-low+1);\\n        swap(nums[randIndex], nums[high]);\\n        int index = low-1;\\n        for (int j=low;j<=high;j++){\\n            if (nums[j]<= nums[high]){\\n                index++;\\n                swap(nums[index], nums[j]);\\n            }\\n        }\\n        return index;\\n    }\\n    */\\n    \\n    vector<int> sortArray(vector<int>& nums) {\\n        //bubbleSort(nums);\\n        //insertionSort(nums);\\n        //selectionSort(nums);\\n        //heapSort(nums);\\n        mergeSort(nums);\\n        //quickSort(nums);\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    1. Bubble sort:\\n    Worstcase time: O(n^2), Bestcase Time: O(n) -  list already sorted, Space: O(1)\\n    */\\n    vector<int> bubbleSort(vector<int>& nums) {\\n        for(int i=0;i<nums.size()-1;i++){\\n            bool found = false;\\n            for (int j=0;j<nums.size()-i-1;j++){\\n                if (nums[j]>nums[j+1]){\\n                    found = true;\\n                    swap(nums[j],nums[j+1]);\\n                }\\n            }\\n            if (!found)\\n                return nums;\\n        }\\n        return nums;\\n    }\\n    \\n\\t\\n    /*\\n    2. Insertion sort: (Inserting ith element in the proper position)\\n    Worstcase time: O(n^2), Bestcase Time: O(n) - list already sorted, Space: O(1)\\n    */\\n    vector<int> insertionSort(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            int j = i;\\n            while (j>0 && nums[j-1]>nums[j]){\\n                swap(nums[j],nums[j-1]);\\n                j--;\\n            }\\n        }\\n        return nums;   \\n    }\\n\\n\\n    /*\\n    3. Selection sort: (Select the  min/max value based on current element and swap it)\\n    Worstcase time: O(n^2), Bestcase Time: O(n^2), Space: O(1)\\n    */\\n    vector<int> selectionSort(vector<int>& nums) {\\n        for(int i=0;i<nums.size()-1;i++){\\n            int minIndex = i;\\n            for (int j=i+1;j<nums.size();j++){\\n                if (nums[minIndex]>nums[j])\\n                    minIndex = j;\\n            }\\n            swap(nums[i], nums[minIndex]);\\n        }\\n        return nums;\\n    }\\n\\n\\n    /*\\n    4. Merge sort: (divide and concur)\\n    Worstcase time: O(nlogn), Bestcase Time: O(nlogn), Space: O(n) (not considering recursion call stack space)\\n    It is a divide and concure technique which \\n    Divide: Break the given problem into sub-problems of same type.\\n    Conquer: Recursively solve these sub-problems\\n    Combine: Appropriately combine the answers\\n    1. Base operation: find the mid elemet\\n    2. Divide and  concure part: divide the array into two halves and recursively solve these sub-problems\\n    3. Combine part: appropriately add sorted two halves arrays\\n    T(n) = 0(1)(Finding mid index -- preprocessing) + 2T(n/2) + O(N) (merging - postprocessing)\\n    T(n) = 2T(n/2) + O(n) --> O(nlong)\\n    T(N) = aT(n/b) + f(n) -- >  logn(baseb) is the height and max no of leafs is a^heigh and total number a^(height+1)-1 (Here n is the length of the array)\\n    According to master method:\\n    T(N) = aT(n/b) + f(n)\\n    T(n) = \\u0398(nloga(baseb)) when f(n) has slower growth that n^loga(baseb)\\n    T(n) = \\u0398(nloga(baseb) log n) when f(n) has equal growth that n^loga(baseb)\\n    T(n) = \\u0398(f(n)) when f(n) has faster growth that n^loga(baseb) \\n    */\\n    void merge(vector<int>& nums, int low, int mid, int high) {\\n        int leftLength = mid-low + 1;\\n        int rightLength = high -mid; // high-(mid+1)+1\\n        vector<int> leftList(nums.begin()+low, nums.begin()+mid+1);\\n        vector<int> rightList(nums.begin()+mid+1, nums.begin()+high+1); \\n        int i=0,j=0,cur=low;\\n        while(i<leftLength && j<rightLength){\\n            if (leftList[i]<rightList[j]){\\n                nums[cur] = leftList[i];\\n                i++;\\n                cur++;\\n            } else {\\n                nums[cur] = rightList[j];\\n                j++;\\n                cur++;              \\n            }   \\n        }\\n        while(i<leftLength){\\n            nums[cur] = leftList[i];\\n            i++;\\n            cur++;\\n        }\\n         while(j<rightLength){\\n            nums[cur] = rightList[j];\\n            j++;\\n            cur++;\\n        }        \\n    }\\n    void mergeSortHelper(vector<int>& nums, int low, int high) {\\n        if (low<high){\\n            int mid = (high-low)/2 + low;\\n            mergeSortHelper(nums, low, mid);\\n            mergeSortHelper(nums, mid+1, high);\\n            merge(nums, low, mid, high);\\n        }\\n    }\\n    vector<int> mergeSort(vector<int>& nums) {\\n        mergeSortHelper(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n\\n\\n    /*\\n    5. Heapsort (Using heap)\\n    Worstcase time: O(nlogn), Bestcase Time: O(n)(when all elements are same then heapify will not cost O(logn), it will be O(1)), Space: O(1) (not including recursive function stack space.)\\n    */    \\n    // heapify opertaion for max heap\\n    void heapify(vector<int>& nums, int index, int size){\\n        int lChildIndex = 2*index +1;\\n        int rChildIndex = 2*index +2;\\n        int nextIndex = index;\\n        if (lChildIndex<size && nums[lChildIndex]>nums[nextIndex])\\n            nextIndex = lChildIndex;\\n        if (rChildIndex<size && nums[rChildIndex]>nums[nextIndex])\\n            nextIndex = rChildIndex;\\n        if (nextIndex != index){\\n            swap(nums[index], nums[nextIndex]);\\n            heapify(nums, nextIndex, size);\\n        }\\n    }\\n    void heapSortHelper(vector<int>& nums){\\n        // Make the array as max heap. Time complexity is O(n), it is not nlogn because height considered in each call is not the same and decreases.\\n        for (int i=nums.size()/2;i>=0;i--){ \\n            heapify(nums, i, nums.size());\\n        }\\n        // Swap 0th element with last, as 0 will be the max element and then heapify the 0th element by passing size as last-1. Time complexity is nlogn, and it will be n if all elements are same.\\n        for (int i=nums.size()-1;i>=0;i--){\\n            swap(nums[0], nums[i]);\\n            heapify(nums, 0, i);\\n        }\\n    }\\n    vector<int> heapSort(vector<int>& nums) {\\n        heapSortHelper(nums);\\n        return nums;\\n    }\\n\\n\\n    /*\\n    6. Quick sort:\\n    Worstcase time: O(n^2), Bestcase Time: O(nlogn), Ave: O(nlogn), Space: O(1)-- not including recursive function stack space.\\n    Quicksort uses divide-and-conquer approach.\\n    1. Base operation: find pivot element\\n    2. Divide and concure art: divide the array into two halves and recursselvy quicksort the array\\n    3. Combine part do nothing\\n    best case and avg case when partition element is around middle and in that case\\n    T(n) = O(n) + 2T((n-1)/2) + Nothing -- best case \\n    T(n) = O(n) + T(9n/10)+ T(n/10) -- > O(n logn) -- averge case\\n    Worstcase when partition element is around start and end every time -- revered sorted input list provided here:\\n    T(n) = O(n) + T(n-1) + Nothing -- > O(n + n-1 + n-2 + .. ) --> O(n^2)\\n    We can use randomized quicksort which gives worst case complexity as O(n logn) by picking pivot element randomly.  But it can not gurantee, complexity can go to O(n^2) here also.\\n    */\\n    \\n    int partitionIndex(vector<int>& nums, int low, int high){\\n        int index = low-1;\\n        for (int j=low;j<=high;j++){\\n            if (nums[j]<= nums[high]){\\n                index++;\\n                swap(nums[index], nums[j]);\\n            }\\n        }\\n        return index;\\n    }\\n    void quickSortHelper(vector<int>& nums, int low, int high){\\n        if (low<high){\\n            int p = partitionIndex(nums, low, high);\\n            quickSortHelper(nums, low, p-1);\\n            quickSortHelper(nums, p+1, high);\\n        }\\n    }\\n    vector<int> quickSort(vector<int>& nums) {\\n        quickSortHelper(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n    /*\\n    Note considering high index for finding partition element gives O(n^2) time complexity in case list is sorted in reverse order. So to increase the probability of getting O(nlogn) complexity, randomized quick sort can be used. \\n    int partitionIndex(vector<int>& nums, int low, int high){\\n        int randIndex = low + rand()%(high-low+1);\\n        swap(nums[randIndex], nums[high]);\\n        int index = low-1;\\n        for (int j=low;j<=high;j++){\\n            if (nums[j]<= nums[high]){\\n                index++;\\n                swap(nums[index], nums[j]);\\n            }\\n        }\\n        return index;\\n    }\\n    */\\n    \\n    vector<int> sortArray(vector<int>& nums) {\\n        //bubbleSort(nums);\\n        //insertionSort(nums);\\n        //selectionSort(nums);\\n        //heapSort(nums);\\n        mergeSort(nums);\\n        //quickSort(nums);\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440213,
                "title": "heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        heap=[]\\n        final=[]\\n        for i in range(len(nums)):\\n            heapq.heappush(heap,nums[i])\\n        while(heap):\\n            a=heapq.heappop(heap)\\n            final.append(a)\\n        return(final)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        heap=[]\\n        final=[]\\n        for i in range(len(nums)):\\n            heapq.heappush(heap,nums[i])\\n        while(heap):\\n            a=heapq.heappop(heap)\\n            final.append(a)\\n        return(final)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241787,
                "title": "simple-way-merge-sort-in-java-python-and-c-with-video-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMerge sort is a sorting algorithm that uses the divide and conquer approach to sort an array or a list. In this algorithm, the given array is recursively divided into two halves until the base case of having a single element is reached. The two halves are then merged by comparing and sorting them, thus generating a sorted array\\n\\n# Approach\\nThe merge sort algorithm follows the divide and conquer approach to sort an array. The basic steps involved in the merge sort algorithm are as follows:\\n\\n1. Divide the array into two halves (left and right).\\n2. Recursively apply the merge sort algorithm on the left half until it is sorted.\\n3. Recursively apply the merge sort algorithm on the right half until it is sorted.\\n5. Merge the left and right halves to obtain a sorted array.\\n6. The merging process is performed by comparing and sorting the elements in the left and right halves one by one.\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/b7c3116f-9959-44d9-bfd6-d1d070ffa60e_1677632153.1925292.png)\\n\\n\\n\\n\\n# Video reference\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/mB5HXBb_HY8\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n![image.png](https://assets.leetcode.com/users/images/2b37d2cc-3ca9-4b0c-866d-48abc59d8fa5_1677216789.1769023.png)\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the merge sort algorithm is $$O(nlogn)$$ in all cases. This is because the algorithm divides the array into two halves at each recursive call, and the merging process takes $$O(n)$$ time. Therefore, the overall time complexity is given by `T(n) = 2T(n/2) + O(n)`, which results in $$O(nlogn)$$ time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the merge sort algorithm is $$O(n)$$. This is because the algorithm creates temporary arrays to store the left and right halves of the array during the merging process. The maximum size of the temporary arrays is` n/2`, which results in $$O(n)$$ space complexity.\\n\\n# Code\\n``` java []\\npublic class Solution {\\n    public int[] sortArray(int[] nums) {\\n        mergeSort(nums, 0, nums.length - 1); // Call the recursive Merge Sort \\n        return nums;\\n    }\\nprivate void mergeSort(int[] nums, int start, int end) {\\n    if (start < end) { // Base case - Check if array has only 1 element\\n        int mid = (start + end) / 2; // Calculate the middle index\\n        mergeSort(nums, start, mid); // Recursively call Merge Sort on left subarray\\n        mergeSort(nums, mid + 1, end); // Recursively call Merge Sort on right subarray\\n        merge(nums, start, mid, end); // Merge the sorted left and right subarrays\\n    }\\n}\\n\\nprivate void merge(int[] nums, int start, int mid, int end) {\\n    int[] temp = new int[end - start + 1]; // Create a temporary array to store the merged subarrays\\n    int i = start, j = mid + 1, k = 0; // Initialize indices for left subarray, right subarray, and temporary array\\n    \\n    // Compare elements in the left and right subarrays, and store the smaller element in the temporary array\\n    while (i <= mid && j <= end) {\\n        if (nums[i] < nums[j]) {\\n            temp[k++] = nums[i++];\\n        } else {\\n            temp[k++] = nums[j++];\\n        }\\n    }\\n    \\n    // Copy any remaining elements in the left subarray to the temporary array\\n    while (i <= mid) {\\n        temp[k++] = nums[i++];\\n    }\\n    \\n    // Copy any remaining elements in the right subarray to the temporary array\\n    while (j <= end) {\\n        temp[k++] = nums[j++];\\n    }\\n    \\n    // Copy the merged subarray from the temporary array back to the original array\\n    for (int p = 0; p < temp.length; p++) {\\n        nums[start + p] = temp[p];\\n    }\\n}\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    void mergeSort(vector<int>& nums, int start, int end) {\\n        if (start >= end) {\\n            return;\\n        }\\n        int mid = start + (end - start) / 2;\\n        mergeSort(nums, start, mid);\\n        mergeSort(nums, mid + 1, end);\\n        merge(nums, start, mid, end);\\n    }\\n    \\n    void merge(vector<int>& nums, int start, int mid, int end) {\\n        vector<int> temp(end - start + 1);\\n        int i = start, j = mid + 1, k = 0;\\n        while (i <= mid && j <= end) {\\n            if (nums[i] < nums[j]) {\\n                temp[k++] = nums[i++];\\n            } else {\\n                temp[k++] = nums[j++];\\n            }\\n        }\\n        while (i <= mid) {\\n            temp[k++] = nums[i++];\\n        }\\n        while (j <= end) {\\n            temp[k++] = nums[j++];\\n        }\\n        for (int p = 0; p < temp.size(); p++) {\\n            nums[start + p] = temp[p];\\n        }\\n    }\\n    \\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size() - 1);\\n        return nums;\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def mergeSort(self, nums, start, end):\\n        if start >= end:\\n            return\\n        mid = start + (end - start) // 2\\n        self.mergeSort(nums, start, mid)\\n        self.mergeSort(nums, mid + 1, end)\\n        self.merge(nums, start, mid, end)\\n        \\n    def merge(self, nums, start, mid, end):\\n        temp = []\\n        i, j = start, mid + 1\\n        while i <= mid and j <= end:\\n            if nums[i] < nums[j]:\\n                temp.append(nums[i])\\n                i += 1\\n            else:\\n                temp.append(nums[j])\\n                j += 1\\n        while i <= mid:\\n            temp.append(nums[i])\\n            i += 1\\n        while j <= end:\\n            temp.append(nums[j])\\n            j += 1\\n        nums[start:end+1] = temp\\n        \\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        self.mergeSort(nums, 0, len(nums) - 1)\\n        return nums\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\n```\n``` java []\\npublic class Solution {\\n    public int[] sortArray(int[] nums) {\\n        mergeSort(nums, 0, nums.length - 1); // Call the recursive Merge Sort \\n        return nums;\\n    }\\nprivate void mergeSort(int[] nums, int start, int end) {\\n    if (start < end) { // Base case - Check if array has only 1 element\\n        int mid = (start + end) / 2; // Calculate the middle index\\n        mergeSort(nums, start, mid); // Recursively call Merge Sort on left subarray\\n        mergeSort(nums, mid + 1, end); // Recursively call Merge Sort on right subarray\\n        merge(nums, start, mid, end); // Merge the sorted left and right subarrays\\n    }\\n}\\n\\nprivate void merge(int[] nums, int start, int mid, int end) {\\n    int[] temp = new int[end - start + 1]; // Create a temporary array to store the merged subarrays\\n    int i = start, j = mid + 1, k = 0; // Initialize indices for left subarray, right subarray, and temporary array\\n    \\n    // Compare elements in the left and right subarrays, and store the smaller element in the temporary array\\n    while (i <= mid && j <= end) {\\n        if (nums[i] < nums[j]) {\\n            temp[k++] = nums[i++];\\n        } else {\\n            temp[k++] = nums[j++];\\n        }\\n    }\\n    \\n    // Copy any remaining elements in the left subarray to the temporary array\\n    while (i <= mid) {\\n        temp[k++] = nums[i++];\\n    }\\n    \\n    // Copy any remaining elements in the right subarray to the temporary array\\n    while (j <= end) {\\n        temp[k++] = nums[j++];\\n    }\\n    \\n    // Copy the merged subarray from the temporary array back to the original array\\n    for (int p = 0; p < temp.length; p++) {\\n        nums[start + p] = temp[p];\\n    }\\n}\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    void mergeSort(vector<int>& nums, int start, int end) {\\n        if (start >= end) {\\n            return;\\n        }\\n        int mid = start + (end - start) / 2;\\n        mergeSort(nums, start, mid);\\n        mergeSort(nums, mid + 1, end);\\n        merge(nums, start, mid, end);\\n    }\\n    \\n    void merge(vector<int>& nums, int start, int mid, int end) {\\n        vector<int> temp(end - start + 1);\\n        int i = start, j = mid + 1, k = 0;\\n        while (i <= mid && j <= end) {\\n            if (nums[i] < nums[j]) {\\n                temp[k++] = nums[i++];\\n            } else {\\n                temp[k++] = nums[j++];\\n            }\\n        }\\n        while (i <= mid) {\\n            temp[k++] = nums[i++];\\n        }\\n        while (j <= end) {\\n            temp[k++] = nums[j++];\\n        }\\n        for (int p = 0; p < temp.size(); p++) {\\n            nums[start + p] = temp[p];\\n        }\\n    }\\n    \\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size() - 1);\\n        return nums;\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def mergeSort(self, nums, start, end):\\n        if start >= end:\\n            return\\n        mid = start + (end - start) // 2\\n        self.mergeSort(nums, start, mid)\\n        self.mergeSort(nums, mid + 1, end)\\n        self.merge(nums, start, mid, end)\\n        \\n    def merge(self, nums, start, mid, end):\\n        temp = []\\n        i, j = start, mid + 1\\n        while i <= mid and j <= end:\\n            if nums[i] < nums[j]:\\n                temp.append(nums[i])\\n                i += 1\\n            else:\\n                temp.append(nums[j])\\n                j += 1\\n        while i <= mid:\\n            temp.append(nums[i])\\n            i += 1\\n        while j <= end:\\n            temp.append(nums[j])\\n            j += 1\\n        nums[start:end+1] = temp\\n        \\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        self.mergeSort(nums, 0, len(nums) - 1)\\n        return nums\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670556,
                "title": "quick-sort-with-explanantion",
                "content": "1. Pick the middle number as the pivot.\\n2. Set two poiners, left and right, on the start index and end index.\\n3. left pointer searches for next number that is bigger or equal to pivot.\\n4. right pointer searches for next number that is smaller or equal to pivot.\\n5. if there exists two numbers as described, swap them. \\n**6. So on the left part of the left pointer, all numbers are smaller or equal to pivot. For the right part of right pointer, all numbers are bigger or equal to pivot.**\\n7. keep traversing until left pointer > right pointer, which means all numbers have been visited and set to correct positions.\\n8. divide into [start, right], [left, end], quick sort the subarray respectively.\\n   \\n```\\n   public int[] sortArray(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return nums;\\n        }\\n        \\n        quickSort(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n    \\n    private void quickSort(int[] nums, int start, int end) {\\n        if (start >= end) return;\\n        \\n        int left = start, right = end;\\n\\t\\t// Ideally, numbers are approximately increasing, which means the middle number is most likey the median number. \\n\\t\\t// The closer pivot is to the median number, the less swapping and recursion we need to do.\\n        int pivot = nums[left + (right - left) / 2];\\n        // with (left <= right), we can end with: \\n\\t\\t// 1. x, x, x, right, left, x, x, x,\\n\\t\\t// or\\n\\t\\t// 2. x, x, x, right, pivot, left, x, x, x\\n\\t\\t// easy to divide without boundary issues\\n        while (left <= right) {\\n\\t\\t\\t// if we put nums[left] <= pivot, for array like [2, 1], 1 swap with itself and leads to dead loop\\n            while (left <= right && nums[left] < pivot) left++;\\n            while (left <= right && nums[right] > pivot) right--;\\n            if (left <= right) {\\n                int temp = nums[left];\\n                nums[left] = nums[right];\\n                nums[right] = temp;\\n                left++;\\n                right--;\\n            }\\n        }\\n        \\n        quickSort(nums, start, right);\\n        quickSort(nums, left, end);\\n    }\\n```\\n\\ntime complexity: \\non average O(nlogn); \\narray can be divied **O(logn)** times, each time the whole array will be traversed, **O(n) time** every traversal . \\nworst case O(n * n): \\n[0, 0, 1, 0, 0], if we always choose smallest or biggest number as pivot, then **O(n)** times traverses with **O(n**) time every traversal.\\n\\t\\t\\t\\t\\t\\t\\t\\nspace complexity: \\non average O(logn), worst case O(n);\\ndecided by the depth of recursion.",
                "solutionTags": [],
                "code": "```\\n   public int[] sortArray(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return nums;\\n        }\\n        \\n        quickSort(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n    \\n    private void quickSort(int[] nums, int start, int end) {\\n        if (start >= end) return;\\n        \\n        int left = start, right = end;\\n\\t\\t// Ideally, numbers are approximately increasing, which means the middle number is most likey the median number. \\n\\t\\t// The closer pivot is to the median number, the less swapping and recursion we need to do.\\n        int pivot = nums[left + (right - left) / 2];\\n        // with (left <= right), we can end with: \\n\\t\\t// 1. x, x, x, right, left, x, x, x,\\n\\t\\t// or\\n\\t\\t// 2. x, x, x, right, pivot, left, x, x, x\\n\\t\\t// easy to divide without boundary issues\\n        while (left <= right) {\\n\\t\\t\\t// if we put nums[left] <= pivot, for array like [2, 1], 1 swap with itself and leads to dead loop\\n            while (left <= right && nums[left] < pivot) left++;\\n            while (left <= right && nums[right] > pivot) right--;\\n            if (left <= right) {\\n                int temp = nums[left];\\n                nums[left] = nums[right];\\n                nums[right] = temp;\\n                left++;\\n                right--;\\n            }\\n        }\\n        \\n        quickSort(nums, start, right);\\n        quickSort(nums, left, end);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2438854,
                "title": "merge-sort-solution",
                "content": "```\\n public int[] sortArray(int[] nums) {\\n        mergeSort(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n\\n    private void mergeSort(int[] array, int left, int right) {\\n        if (left < right) {\\n            var middle = left + (right - left) / 2;\\n\\n            mergeSort(array, left, middle);\\n            mergeSort(array, middle + 1, right);\\n\\n            merge(array, left, middle, right);\\n        }\\n    }\\n    \\n    \\n    private void merge(int[] array, int left, int middle, int right) {\\n        int n1 = middle - left + 1;\\n        int n2 = right - middle;\\n\\n        int[] leftArray = new int[n1];\\n        int[] rightArray = new int[n2];\\n\\n        for (int i = 0; i < n1; ++i)\\n            leftArray[i] = array[i+left];\\n\\n        for (int j = 0; j < n2; ++j)\\n            rightArray[j] = array[middle + j + 1];\\n\\n        int i = 0, j = 0, k = left;\\n\\n        while (i < n1 && j < n2) {\\n            if (leftArray[i] <= rightArray[j]) {\\n                array[k] = leftArray[i];\\n                i++;\\n            }\\n            else {\\n                array[k] = rightArray[j];\\n                j++;\\n            }\\n            k++;\\n\\n        }\\n\\n        while (i < n1) {\\n            array[k] = leftArray[i];\\n            k++;\\n            i++;\\n        }\\n\\n        while (j < n2) {\\n            array[k] = rightArray[j];\\n            j++;\\n            k++;\\n\\n        }\\n\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int[] sortArray(int[] nums) {\\n        mergeSort(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n\\n    private void mergeSort(int[] array, int left, int right) {\\n        if (left < right) {\\n            var middle = left + (right - left) / 2;\\n\\n            mergeSort(array, left, middle);\\n            mergeSort(array, middle + 1, right);\\n\\n            merge(array, left, middle, right);\\n        }\\n    }\\n    \\n    \\n    private void merge(int[] array, int left, int middle, int right) {\\n        int n1 = middle - left + 1;\\n        int n2 = right - middle;\\n\\n        int[] leftArray = new int[n1];\\n        int[] rightArray = new int[n2];\\n\\n        for (int i = 0; i < n1; ++i)\\n            leftArray[i] = array[i+left];\\n\\n        for (int j = 0; j < n2; ++j)\\n            rightArray[j] = array[middle + j + 1];\\n\\n        int i = 0, j = 0, k = left;\\n\\n        while (i < n1 && j < n2) {\\n            if (leftArray[i] <= rightArray[j]) {\\n                array[k] = leftArray[i];\\n                i++;\\n            }\\n            else {\\n                array[k] = rightArray[j];\\n                j++;\\n            }\\n            k++;\\n\\n        }\\n\\n        while (i < n1) {\\n            array[k] = leftArray[i];\\n            k++;\\n            i++;\\n        }\\n\\n        while (j < n2) {\\n            array[k] = rightArray[j];\\n            j++;\\n            k++;\\n\\n        }\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297919,
                "title": "c-shortest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184559,
                "title": "java-beats-99-6-count-sort-with-comments",
                "content": "```\\nclass Solution {\\n    \\n    // Count Sort\\n    public int[] sortArray(int[] arr) {\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        for (int i=0;i<arr.length;++i) {\\n          max = Math.max(max, arr[i]);\\n          min = Math.min(min, arr[i]);\\n        }\\n        \\n        int []farr = new int[max-min+1];\\n        int []ans = new int[arr.length];\\n\\n        // collecting the frequencies\\n        for(int i=0;i<arr.length;++i) \\n          farr[arr[i]-min]++;\\n\\n        // convert frequencies to prefix sum array\\n        for(int i=1;i<farr.length;++i) \\n          farr[i] += farr[i-1];\\n\\n        // fill the ans array from farr\\n        for(int i=arr.length-1;i>=0;--i) {\\n          int val = arr[i];\\n          int pos = farr[val-min];\\n          ans[pos-1] = val;\\n          farr[val-min]--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // Count Sort\\n    public int[] sortArray(int[] arr) {\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        for (int i=0;i<arr.length;++i) {\\n          max = Math.max(max, arr[i]);\\n          min = Math.min(min, arr[i]);\\n        }\\n        \\n        int []farr = new int[max-min+1];\\n        int []ans = new int[arr.length];\\n\\n        // collecting the frequencies\\n        for(int i=0;i<arr.length;++i) \\n          farr[arr[i]-min]++;\\n\\n        // convert frequencies to prefix sum array\\n        for(int i=1;i<farr.length;++i) \\n          farr[i] += farr[i-1];\\n\\n        // fill the ans array from farr\\n        for(int i=arr.length-1;i>=0;--i) {\\n          int val = arr[i];\\n          int pos = farr[val-min];\\n          ans[pos-1] = val;\\n          farr[val-min]--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162769,
                "title": "python3-5-common-sorting-algorithms-selection-bubble-insertion-merge-quick",
                "content": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        # self.selectionSort(nums)\\n        # self.bubbleSort(nums)\\n        # self.insertionSort(nums)\\n        # self.mergeSort(nums)       \\n        self.quickSort(nums)\\n        return nums\\n    \\n    \\'\\'\\' \\n    Selection Sort (TLE)\\n    TC: O(n^2) ;  SC: O(1), in-place\\n    Not Stable\\n    Minimum swaps\\n    \\'\\'\\'\\n    def selectionSort(self, nums):\\n        for i in range(len(nums)):\\n            min_idx=i\\n            for j in range(i, len(nums)):\\n                if nums[j]<nums[min_idx]:\\n                    min_idx=j\\n            nums[i], nums[min_idx] = nums[min_idx], nums[i]\\n            \\n    \\'\\'\\'\\n    Bubble Sort (TLE)\\n    TC: best-O(n), worst-O(n^2)\\n    SC: O(1)\\n    Stable\\n    Use when array is almost sorted\\n    \\'\\'\\'\\n    def bubbleSort(self, nums):\\n        for i in range(len(nums)):\\n            swapped = False\\n            for j in range(len(nums)-i-1):\\n                if nums[j]>nums[j+1]:\\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\\n                    swapped = True\\n            \\n            if not swapped:\\n                break\\n                \\n    \\'\\'\\'\\n    Insertion Sort (TLE)\\n    TC: best-O(n), worst-O(n^2)\\n    SC: O(1)\\n    Stable\\n    \\'\\'\\'\\n    def insertionSort(self, nums):\\n        for i in range(1, len(nums)):\\n            key = nums[i]\\n            j=i-1\\n            while j>=0 and key<nums[j]:\\n                nums[j+1]=nums[j]\\n                j-=1\\n            nums[j+1]=key\\n    \\n    \\'\\'\\'\\n    Merge Sort\\n    Recursive\\n    TC: O(nlogn)\\n    SC: O(n)\\n    Stable\\n    \\'\\'\\'\\n    def mergeSort(self, nums):\\n        def merge(nums,L,R):\\n            i = j = k = 0\\n            while i < len(L) and j < len(R): \\n                if L[i] < R[j]: \\n                    nums[k] = L[i] \\n                    i+=1\\n                else: \\n                    nums[k] = R[j] \\n                    j+=1\\n                k+=1\\n                \\n            while i < len(L): \\n                nums[k] = L[i] \\n                i+=1\\n                k+=1\\n\\n            while j < len(R): \\n                nums[k] = R[j] \\n                j+=1\\n                k+=1\\n                \\n        if len(nums)>1:\\n                mid=len(nums)//2\\n                L=nums[:mid]\\n                R=nums[mid:]\\n                self.mergeSort(L)\\n                self.mergeSort(R)\\n                merge(nums,L,R)\\n        \\n    \\'\\'\\'\\n    QuickSort\\n    Recursive\\n    TC: average-O(nlogn), worst-O(n^2)\\n    SC: average-O(logn), worst-O(n) recursion stack, in-place\\n    Not stable\\n    \\'\\'\\'\\n    def quickSort(self, nums):\\n        # 3-way randomized\\n        def partition(l, r):\\n            pivot_idx = random.choice(range(l,r+1))\\n            pivot = nums[pivot_idx]\\n            # print(pivot)\\n            left, move, right = l,l,r\\n            while move<=right:\\n                if nums[move]<pivot:\\n                    nums[left], nums[move] = nums[move], nums[left]\\n                    move+=1\\n                    left+=1\\n                elif nums[move]>pivot:\\n                    nums[right], nums[move] = nums[move], nums[right]\\n                    right-=1\\n                else:\\n                    move+=1\\n            return left-1, move\\n        \\n        def quicksort(nums, low, high):\\n            if low<high:\\n                l,r = partition(low, high)\\n                quicksort(nums, low, l)\\n                quicksort(nums, r, high)\\n                \\n        quicksort(nums, 0, len(nums)-1)\\n        \\n        #---------------------------------------------------------------\\n        # def helper(head, tail):\\n        #     if head >= tail: return \\n        #     l, r = head, tail\\n        #     m = (r - l) // 2 + l\\n        #     pivot = nums[m]\\n        #     while r >= l:\\n        #         while r >= l and nums[l] < pivot: l += 1\\n        #         while r >= l and nums[r] > pivot: r -= 1\\n        #         if r >= l:\\n        #             nums[l], nums[r] = nums[r], nums[l]\\n        #             l += 1\\n        #             r -= 1\\n        #     helper(head, r)\\n        #     helper(l, tail)\\n\\n        # helper(0, len(nums)-1)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        # self.selectionSort(nums)\\n        # self.bubbleSort(nums)\\n        # self.insertionSort(nums)\\n        # self.mergeSort(nums)       \\n        self.quickSort(nums)\\n        return nums\\n    \\n    \\'\\'\\' \\n    Selection Sort (TLE)\\n    TC: O(n^2) ;  SC: O(1), in-place\\n    Not Stable\\n    Minimum swaps\\n    \\'\\'\\'\\n    def selectionSort(self, nums):\\n        for i in range(len(nums)):\\n            min_idx=i\\n            for j in range(i, len(nums)):\\n                if nums[j]<nums[min_idx]:\\n                    min_idx=j\\n            nums[i], nums[min_idx] = nums[min_idx], nums[i]\\n            \\n    \\'\\'\\'\\n    Bubble Sort (TLE)\\n    TC: best-O(n), worst-O(n^2)\\n    SC: O(1)\\n    Stable\\n    Use when array is almost sorted\\n    \\'\\'\\'\\n    def bubbleSort(self, nums):\\n        for i in range(len(nums)):\\n            swapped = False\\n            for j in range(len(nums)-i-1):\\n                if nums[j]>nums[j+1]:\\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\\n                    swapped = True\\n            \\n            if not swapped:\\n                break\\n                \\n    \\'\\'\\'\\n    Insertion Sort (TLE)\\n    TC: best-O(n), worst-O(n^2)\\n    SC: O(1)\\n    Stable\\n    \\'\\'\\'\\n    def insertionSort(self, nums):\\n        for i in range(1, len(nums)):\\n            key = nums[i]\\n            j=i-1\\n            while j>=0 and key<nums[j]:\\n                nums[j+1]=nums[j]\\n                j-=1\\n            nums[j+1]=key\\n    \\n    \\'\\'\\'\\n    Merge Sort\\n    Recursive\\n    TC: O(nlogn)\\n    SC: O(n)\\n    Stable\\n    \\'\\'\\'\\n    def mergeSort(self, nums):\\n        def merge(nums,L,R):\\n            i = j = k = 0\\n            while i < len(L) and j < len(R): \\n                if L[i] < R[j]: \\n                    nums[k] = L[i] \\n                    i+=1\\n                else: \\n                    nums[k] = R[j] \\n                    j+=1\\n                k+=1\\n                \\n            while i < len(L): \\n                nums[k] = L[i] \\n                i+=1\\n                k+=1\\n\\n            while j < len(R): \\n                nums[k] = R[j] \\n                j+=1\\n                k+=1\\n                \\n        if len(nums)>1:\\n                mid=len(nums)//2\\n                L=nums[:mid]\\n                R=nums[mid:]\\n                self.mergeSort(L)\\n                self.mergeSort(R)\\n                merge(nums,L,R)\\n        \\n    \\'\\'\\'\\n    QuickSort\\n    Recursive\\n    TC: average-O(nlogn), worst-O(n^2)\\n    SC: average-O(logn), worst-O(n) recursion stack, in-place\\n    Not stable\\n    \\'\\'\\'\\n    def quickSort(self, nums):\\n        # 3-way randomized\\n        def partition(l, r):\\n            pivot_idx = random.choice(range(l,r+1))\\n            pivot = nums[pivot_idx]\\n            # print(pivot)\\n            left, move, right = l,l,r\\n            while move<=right:\\n                if nums[move]<pivot:\\n                    nums[left], nums[move] = nums[move], nums[left]\\n                    move+=1\\n                    left+=1\\n                elif nums[move]>pivot:\\n                    nums[right], nums[move] = nums[move], nums[right]\\n                    right-=1\\n                else:\\n                    move+=1\\n            return left-1, move\\n        \\n        def quicksort(nums, low, high):\\n            if low<high:\\n                l,r = partition(low, high)\\n                quicksort(nums, low, l)\\n                quicksort(nums, r, high)\\n                \\n        quicksort(nums, 0, len(nums)-1)\\n        \\n        #---------------------------------------------------------------\\n        # def helper(head, tail):\\n        #     if head >= tail: return \\n        #     l, r = head, tail\\n        #     m = (r - l) // 2 + l\\n        #     pivot = nums[m]\\n        #     while r >= l:\\n        #         while r >= l and nums[l] < pivot: l += 1\\n        #         while r >= l and nums[r] > pivot: r -= 1\\n        #         if r >= l:\\n        #             nums[l], nums[r] = nums[r], nums[l]\\n        #             l += 1\\n        #             r -= 1\\n        #     helper(head, r)\\n        #     helper(l, tail)\\n\\n        # helper(0, len(nums)-1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090261,
                "title": "sorting-using-recursion",
                "content": "**Learnt from: Aditya Verma**\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        if len(nums)==1:\\n            return nums         #arr=[1,5,2]\\n        temp=nums[-1]           #temp=2\\n        nums.pop()              #arr=[1,5]\\n        self.sortArray(nums)    #sort([1,5])\\n        self.insert(nums,temp)  #insert([1,5],2)\\n        return nums             #Yayyy! Array is sorted arr=[1,2,5]\\n    \\n    def insert(self,nums,temp):              \\n        if len(nums)==0 or nums[-1]<=temp:\\n            nums.append(temp)   #If arr is empty no need to think much just insert\\n            return              #arr=[1,5], temp=2\\n        val=nums[-1]            #val=5\\n        nums.pop()              #nums=[1]\\n        self.insert(nums,temp)  #insert([1],2) --> nums[-1]<=temp --> 1<=2 --> nums.append(2) --> arr=[1,2]\\n        nums.append(val)        #nums=[1,2,5]\\n        return\\n```\\n\\n*Disclaimer: Not the Best in terms of Time Complexity. We get TLE for large arrays.*",
                "solutionTags": [
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        if len(nums)==1:\\n            return nums         #arr=[1,5,2]\\n        temp=nums[-1]           #temp=2\\n        nums.pop()              #arr=[1,5]\\n        self.sortArray(nums)    #sort([1,5])\\n        self.insert(nums,temp)  #insert([1,5],2)\\n        return nums             #Yayyy! Array is sorted arr=[1,2,5]\\n    \\n    def insert(self,nums,temp):              \\n        if len(nums)==0 or nums[-1]<=temp:\\n            nums.append(temp)   #If arr is empty no need to think much just insert\\n            return              #arr=[1,5], temp=2\\n        val=nums[-1]            #val=5\\n        nums.pop()              #nums=[1]\\n        self.insert(nums,temp)  #insert([1],2) --> nums[-1]<=temp --> 1<=2 --> nums.append(2) --> arr=[1,2]\\n        nums.append(val)        #nums=[1,2,5]\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890144,
                "title": "easy-java-solution-in-two-line",
                "content": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n       Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n       Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735245,
                "title": "merge-sort-with-runtime-826-ms-n-log-n",
                "content": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        edge case\\n        \"\"\"\\n        if len(nums)<=1:\\n            return nums\\n        \"\"\"\\n        divide\\n        \"\"\"\\n        mid=len(nums)//2\\n        left=nums[:mid]\\n        right=nums[mid:]\\n        self.sortArray(left)\\n        self.sortArray(right)\\n        \\n        \"\"\"\\n        merge\\n        \"\"\"\\n        i=j=k=0\\n        while i<len(left) and j<len(right):\\n            if left[i]<right[j]:\\n                nums[k]=left[i]\\n                i+=1\\n            else:\\n                nums[k]=right[j]\\n                j+=1\\n                \\n            k+=1\\n        \"\"\"\\n        if left sublist is longer than the right one \\n        \"\"\"    \\n        while i<len(left):\\n            nums[k]=left[i]\\n            i+=1\\n            k+=1\\n            \\n        \"\"\"\\n        if right sublist is longer than left \\n        \"\"\"   \\n        while j<len(right):\\n            nums[k]=right[j]\\n            j+=1\\n            k+=1\\n            \\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        edge case\\n        \"\"\"\\n        if len(nums)<=1:\\n            return nums\\n        \"\"\"\\n        divide\\n        \"\"\"\\n        mid=len(nums)//2\\n        left=nums[:mid]\\n        right=nums[mid:]\\n        self.sortArray(left)\\n        self.sortArray(right)\\n        \\n        \"\"\"\\n        merge\\n        \"\"\"\\n        i=j=k=0\\n        while i<len(left) and j<len(right):\\n            if left[i]<right[j]:\\n                nums[k]=left[i]\\n                i+=1\\n            else:\\n                nums[k]=right[j]\\n                j+=1\\n                \\n            k+=1\\n        \"\"\"\\n        if left sublist is longer than the right one \\n        \"\"\"    \\n        while i<len(left):\\n            nums[k]=left[i]\\n            i+=1\\n            k+=1\\n            \\n        \"\"\"\\n        if right sublist is longer than left \\n        \"\"\"   \\n        while j<len(right):\\n            nums[k]=right[j]\\n            j+=1\\n            k+=1\\n            \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763448,
                "title": "javascript-quicksort",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArray = function(nums) {\\n    if (nums.length <= 1) return nums;\\n    const pivot = nums.pop();\\n    const less = sortArray(nums.filter(n => n <= pivot));\\n    const more = sortArray(nums.filter(n => n > pivot));\\n    return less.concat(pivot, more);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArray = function(nums) {\\n    if (nums.length <= 1) return nums;\\n    const pivot = nums.pop();\\n    const less = sortArray(nums.filter(n => n <= pivot));\\n    const more = sortArray(nums.filter(n => n > pivot));\\n    return less.concat(pivot, more);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 626546,
                "title": "iterative-merge-sort",
                "content": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        \\n        nums = [[num] for num in nums]\\n\\n        def merge(l1, l2):\\n            i = 0\\n            j = 0\\n            new = []\\n            \\n            while i < len(l1) and j < len(l2):\\n                if l1[i] < l2[j]:\\n                    new.append(l1[i])\\n                    i += 1\\n                else:\\n                    new.append(l2[j])\\n                    j += 1\\n                    \\n            while i < len(l1):\\n                new.append(l1[i])\\n                i += 1\\n                \\n            while j < len(l2):\\n                new.append(l2[j])\\n                j += 1\\n                \\n            return new\\n\\n        \\n        while len(nums) > 1:\\n            new = []\\n            for i in range(0, len(nums), 2):\\n                if i + 1 < len(nums):\\n                    new_arr = merge(nums[i], nums[i+1])\\n                    new.append(new_arr)\\n                else:\\n                    new.append(nums[i])\\n            nums = new\\n            \\n        return nums[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Merge Sort",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        \\n        nums = [[num] for num in nums]\\n\\n        def merge(l1, l2):\\n            i = 0\\n            j = 0\\n            new = []\\n            \\n            while i < len(l1) and j < len(l2):\\n                if l1[i] < l2[j]:\\n                    new.append(l1[i])\\n                    i += 1\\n                else:\\n                    new.append(l2[j])\\n                    j += 1\\n                    \\n            while i < len(l1):\\n                new.append(l1[i])\\n                i += 1\\n                \\n            while j < len(l2):\\n                new.append(l2[j])\\n                j += 1\\n                \\n            return new\\n\\n        \\n        while len(nums) > 1:\\n            new = []\\n            for i in range(0, len(nums), 2):\\n                if i + 1 < len(nums):\\n                    new_arr = merge(nums[i], nums[i+1])\\n                    new.append(new_arr)\\n                else:\\n                    new.append(nums[i])\\n            nums = new\\n            \\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541579,
                "title": "python-quicksort",
                "content": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n\\t\\n        if len(nums) <=1: return nums\\n        less , greater , base = [] , [] , nums.pop()\\n        for i in nums:\\n            if i < base: less.append(i)\\n            else: greater.append(i)\\n        return self.sortArray(less) + [base] + self.sortArray(greater)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n\\t\\n        if len(nums) <=1: return nums\\n        less , greater , base = [] , [] , nums.pop()\\n        for i in nums:\\n            if i < base: less.append(i)\\n            else: greater.append(i)\\n        return self.sortArray(less) + [base] + self.sortArray(greater)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488644,
                "title": "clean-java-mergesort",
                "content": "```\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        mergeSort(nums, 0, nums.length - 1);\\n        for (int num : nums) res.add(num);\\n        return res;\\n    }\\n    private void mergeSort(int[] nums, int low, int high) {\\n        int mid = low + (high - low) / 2;\\n        if (low < high) {\\n            mergeSort(nums, low, mid);\\n            mergeSort(nums, mid + 1, high);\\n            merge(nums, low, mid, high);\\n        }\\n        \\n    }\\n    \\n    private void merge(int[] nums, int lo, int mid, int hi) {\\n        int[] cache = new int[hi - lo + 1];\\n        int index = 0;\\n        int i = lo;\\n        int j = mid + 1;\\n        while (i <= mid && j <= hi) {\\n            if (nums[i] < nums[j]) {\\n                cache[index++] = nums[i++];\\n            } else {\\n                cache[index++] = nums[j++];\\n            }\\n        }\\n        while (i <= mid) {\\n            cache[index++] = nums[i++];\\n        }\\n        while (j <= hi) {\\n            cache[index++] = nums[j++];\\n        }\\n        \\n        for (int k = 0; k < cache.length; k++) {\\n            nums[k + lo] = cache[k];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> sortArray(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        mergeSort(nums, 0, nums.length - 1);\\n        for (int num : nums) res.add(num);\\n        return res;\\n    }\\n    private void mergeSort(int[] nums, int low, int high) {\\n        int mid = low + (high - low) / 2;\\n        if (low < high) {\\n            mergeSort(nums, low, mid);\\n            mergeSort(nums, mid + 1, high);\\n            merge(nums, low, mid, high);\\n        }\\n        \\n    }\\n    \\n    private void merge(int[] nums, int lo, int mid, int hi) {\\n        int[] cache = new int[hi - lo + 1];\\n        int index = 0;\\n        int i = lo;\\n        int j = mid + 1;\\n        while (i <= mid && j <= hi) {\\n            if (nums[i] < nums[j]) {\\n                cache[index++] = nums[i++];\\n            } else {\\n                cache[index++] = nums[j++];\\n            }\\n        }\\n        while (i <= mid) {\\n            cache[index++] = nums[i++];\\n        }\\n        while (j <= hi) {\\n            cache[index++] = nums[j++];\\n        }\\n        \\n        for (int k = 0; k < cache.length; k++) {\\n            nums[k + lo] = cache[k];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339079,
                "title": "java-heapsort",
                "content": "I haven\\'t seen any posts here using heapsort, despite it being reasonably good for sorting arrays in-place. A heap is a binary tree where a parent has a value greater than or equal to its children.\\n\\nBuilding a heap is nlogn. Each value is added as a leaf node, then it bubbles up the heap to its correct location. To turn a heap into a sorted array, remove the root (which is the current max value), replace it with a leaf node, then let the new root sink down to its correct location. This is also nlogn.\\n\\nedit: Thanks to [RodneyShag](https://leetcode.com/rodneyshag) for suggesting a significant optimization.\\nRather than iteratively adding nodes to a heap, we can merge smaller heaps until only one is left. This ends up being O(n) for building the heap.\\n\\nImproved code: O(n) build heap, O(nlogn) convert heap to sorted array\\n\\n```Java\\npublic static int[] heapSort(int[] nums) {\\n\\t//build the heap\\n\\tfor(int i=nums.length-1;i>=0;i--)\\n\\t\\t//merge the 2 sub-heaps below i, by bubbling nums[i] down to the correct location\\n\\t\\tsink(nums,i,nums.length);\\n\\t//turn it into a sorted list\\n\\tfor(int i=nums.length-1;i>0;i--){\\n\\t\\t//remove the root, and put the last leaf at the root of the heap\\n\\t\\tint tmp = nums[i];\\n\\t\\tnums[i]=nums[0];\\n\\t\\tnums[0] = tmp;\\n\\t\\t//bubble the new root down to the correct location\\n\\t\\tsink(nums,0,i);\\n\\t}\\n\\treturn nums;\\n}\\nstatic void sink(int[] nums, int start, int end){\\n\\tint val = nums[start];\\n\\tint i = start, next = 2*i+1;\\n\\twhile(next<end){\\n\\t\\tif(next+1<end && nums[next+1]>nums[next])\\n\\t\\t\\tnext++;\\n\\t\\tif(nums[next]<=val)\\n\\t\\t\\tbreak;\\n\\t\\tnums[i]=nums[next];\\n\\t\\ti=next;\\n\\t\\tnext = 2*i+1; //2*i+1, 2*i+2 are the children of i\\n\\t}\\n\\tnums[i]=val;\\n}\\n```\\n\\nOriginal code: O(nlogn) build heap\\n \\n```Java\\npublic static int[] heapSort(int[] nums) {\\n\\t//build the heap\\n\\tfor(int i=1;i<nums.length;i++){\\n\\t\\tint val = nums[i];\\n\\t\\tint j=i, next = (j-1)/2; //(j-i)/2 is the index of this location\\'s parent\\n\\t\\twhile(j>0 && nums[next]<val){\\n\\t\\t\\tnums[j]=nums[next];\\n\\t\\t\\tj=next;\\n\\t\\t\\tnext = (j-1)/2;\\n\\t\\t}\\n\\t\\tnums[j]=val;\\n\\t}\\n\\t\\n\\t//turn it into a sorted list\\n\\tfor(int i=nums.length-1;i>0;i--){\\n\\t\\tint val = nums[i];\\n\\t\\tnums[i]=nums[0];\\n\\t\\t\\n\\t\\tint j = 0, next = 1;\\n\\t\\twhile(next<i){\\n\\t\\t\\tif(next+1<i && nums[next+1]>nums[next])\\n\\t\\t\\t\\tnext++;\\n\\t\\t\\tif(nums[next]<=val)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tnums[j]=nums[next];\\n\\t\\t\\tj=next;\\n\\t\\t\\tnext = 2*j+1; //2*j+1, 2*j+2 are the children of j\\n\\t\\t}\\n\\t\\tnums[j]=val;\\n\\t}\\n\\treturn nums;\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\npublic static int[] heapSort(int[] nums) {\\n\\t//build the heap\\n\\tfor(int i=nums.length-1;i>=0;i--)\\n\\t\\t//merge the 2 sub-heaps below i, by bubbling nums[i] down to the correct location\\n\\t\\tsink(nums,i,nums.length);\\n\\t//turn it into a sorted list\\n\\tfor(int i=nums.length-1;i>0;i--){\\n\\t\\t//remove the root, and put the last leaf at the root of the heap\\n\\t\\tint tmp = nums[i];\\n\\t\\tnums[i]=nums[0];\\n\\t\\tnums[0] = tmp;\\n\\t\\t//bubble the new root down to the correct location\\n\\t\\tsink(nums,0,i);\\n\\t}\\n\\treturn nums;\\n}\\nstatic void sink(int[] nums, int start, int end){\\n\\tint val = nums[start];\\n\\tint i = start, next = 2*i+1;\\n\\twhile(next<end){\\n\\t\\tif(next+1<end && nums[next+1]>nums[next])\\n\\t\\t\\tnext++;\\n\\t\\tif(nums[next]<=val)\\n\\t\\t\\tbreak;\\n\\t\\tnums[i]=nums[next];\\n\\t\\ti=next;\\n\\t\\tnext = 2*i+1; //2*i+1, 2*i+2 are the children of i\\n\\t}\\n\\tnums[i]=val;\\n}\\n```\n```Java\\npublic static int[] heapSort(int[] nums) {\\n\\t//build the heap\\n\\tfor(int i=1;i<nums.length;i++){\\n\\t\\tint val = nums[i];\\n\\t\\tint j=i, next = (j-1)/2; //(j-i)/2 is the index of this location\\'s parent\\n\\t\\twhile(j>0 && nums[next]<val){\\n\\t\\t\\tnums[j]=nums[next];\\n\\t\\t\\tj=next;\\n\\t\\t\\tnext = (j-1)/2;\\n\\t\\t}\\n\\t\\tnums[j]=val;\\n\\t}\\n\\t\\n\\t//turn it into a sorted list\\n\\tfor(int i=nums.length-1;i>0;i--){\\n\\t\\tint val = nums[i];\\n\\t\\tnums[i]=nums[0];\\n\\t\\t\\n\\t\\tint j = 0, next = 1;\\n\\t\\twhile(next<i){\\n\\t\\t\\tif(next+1<i && nums[next+1]>nums[next])\\n\\t\\t\\t\\tnext++;\\n\\t\\t\\tif(nums[next]<=val)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tnums[j]=nums[next];\\n\\t\\t\\tj=next;\\n\\t\\t\\tnext = 2*j+1; //2*j+1, 2*j+2 are the children of j\\n\\t\\t}\\n\\t\\tnums[j]=val;\\n\\t}\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 315173,
                "title": "golang-merge-sort",
                "content": "Merge sort, O(n) space and O(nlog(n)) time complexity.\\n```go\\nfunc sortArray(nums []int) []int {\\n    mergesort(nums, 0, len(nums))\\n    return nums\\n}\\n\\nfunc mergesort(nums []int, start, end int) {\\n    if start >= end-1 {\\n        return\\n    }\\n    mergesort(nums, start, (start+end)/2)\\n    mergesort(nums, (start+end)/2, end)\\n    merge(nums, start, end)\\n}\\n\\nfunc merge(nums []int, start, end int) {\\n    arr, mid := make([]int, end-start), (start+end)/2\\n    for i, j, k := start, mid, 0; k < len(arr); k++ {\\n        if j == end || (i < mid && nums[i] < nums[j]) {\\n            arr[k] = nums[i]\\n            i++\\n        } else {\\n            arr[k] = nums[j]\\n            j++\\n        }\\n    }\\n    copy(nums[start:end], arr)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc sortArray(nums []int) []int {\\n    mergesort(nums, 0, len(nums))\\n    return nums\\n}\\n\\nfunc mergesort(nums []int, start, end int) {\\n    if start >= end-1 {\\n        return\\n    }\\n    mergesort(nums, start, (start+end)/2)\\n    mergesort(nums, (start+end)/2, end)\\n    merge(nums, start, end)\\n}\\n\\nfunc merge(nums []int, start, end int) {\\n    arr, mid := make([]int, end-start), (start+end)/2\\n    for i, j, k := start, mid, 0; k < len(arr); k++ {\\n        if j == end || (i < mid && nums[i] < nums[j]) {\\n            arr[k] = nums[i]\\n            i++\\n        } else {\\n            arr[k] = nums[j]\\n            j++\\n        }\\n    }\\n    copy(nums[start:end], arr)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 306250,
                "title": "swift-using-quicksort",
                "content": "Hey everyone! Did this in swift and used a high order function: filter\\n```\\nclass Solution {\\n    \\n    func sortArray(_ nums: [Int]) -> [Int] {\\n        \\n        let sortedArray = quickSort(array: nums)\\n        return sortedArray\\n    }\\n    \\n    func quickSort(array: [Int]) -> [Int] {\\n        \\n        if array.count < 1 {\\n            return array\\n        }\\n        \\n        let pivot = array[array.count / 2]\\n        let less  = array.filter { $0 < pivot }\\n        let equal = array.filter { $0 == pivot }\\n        let more  = array.filter { $0 > pivot }\\n        \\n        return quickSort(array: less) + equal + quickSort(array: more)\\n        \\n    }\\n}\\n```\\n\\nHappy Coding",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    \\n    func sortArray(_ nums: [Int]) -> [Int] {\\n        \\n        let sortedArray = quickSort(array: nums)\\n        return sortedArray\\n    }\\n    \\n    func quickSort(array: [Int]) -> [Int] {\\n        \\n        if array.count < 1 {\\n            return array\\n        }\\n        \\n        let pivot = array[array.count / 2]\\n        let less  = array.filter { $0 < pivot }\\n        let equal = array.filter { $0 == pivot }\\n        let more  = array.filter { $0 > pivot }\\n        \\n        return quickSort(array: less) + equal + quickSort(array: more)\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292356,
                "title": "simple-and-clear-quicksort-in-python",
                "content": "class Solution(object):\\n    def sortArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        self.quickSort(nums,0,len(nums)-1)\\n        return nums\\n    \\n    def quickSort(self, nums, l, r):\\n        if l>=r:\\n            return 0\\n        \\n        mid = (l+r)//2\\n        pivot = nums[mid]\\n        i,j=l,r\\n        while i<=j:\\n            while i<=j and nums[i]<pivot:\\n                i+=1\\n            while i<=j and nums[j]>pivot:\\n                j-=1\\n            \\n            if i<=j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i+=1\\n                j-=1\\n        self.quickSort(nums,l,j)\\n        self.quickSort(nums,i,r)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def sortArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        self.quickSort(nums,0,len(nums)-1)\\n        return nums\\n    \\n    def quickSort(self, nums, l, r):\\n        if l>=r:\\n            return 0\\n        \\n        mid = (l+r)//2\\n        pivot = nums[mid]\\n        i,j=l,r\\n        while i<=j:\\n            while i<=j and nums[i]<pivot:\\n                i+=1\\n            while i<=j and nums[j]>pivot:\\n                j-=1\\n            \\n            if i<=j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i+=1\\n                j-=1\\n        self.quickSort(nums,l,j)\\n        self.quickSort(nums,i,r)",
                "codeTag": "Java"
            },
            {
                "id": 280903,
                "title": "c-quicksort-and-countingsort-solutions",
                "content": "Here are two C++ soltuions with different runtimes:\\n1. QuickSort: Runtime: 68 ms, Memory Usage: 12.6 MB\\n```\\n    void quickSort(vector<int>& V, int from, int to) {\\n       if (from + 1 >= to) return;\\n       // choose random pivot:\\n       int piv = V[from + rand() % (to - from)];\\n       \\n       int i = from - 1, j = to;\\n       while (true) {\\n          do i++; while (V[i] < piv);\\n          do j--; while (V[j] > piv);\\n          if (i >= j) break;\\n          swap(V[i], V[j]);\\n       }\\n       quickSort(V, from, j + 1);\\n       quickSort(V, j + 1, to);\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n      quickSort(nums, 0, nums.size());\\n      return nums;\\n    }\\n```\\n2. CountingSort: Runtime: 44 ms, Memory Usage: 13 MB\\n```\\nvector<int> sortArray(vector<int>& nums) {\\n   int n = nums.size();\\n   int minEl = nums[0], maxEl = nums[0];\\n   for (int i = 1; i < n; ++i) {\\n      if (minEl > nums[i]) minEl = nums[i];\\n      if (maxEl < nums[i]) maxEl = nums[i];\\n   }\\n   vector<int> C(maxEl - minEl + 1);\\n   for (int i : nums) ++C[i - minEl];\\n   int j = 0;\\n   for (int i = 0; i < C.size(); ++i) {\\n      int el = i + minEl;\\n      int &cnt = C[i];\\n      while (cnt--) nums[j++] = el;\\n   }\\n   return nums;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    void quickSort(vector<int>& V, int from, int to) {\\n       if (from + 1 >= to) return;\\n       // choose random pivot:\\n       int piv = V[from + rand() % (to - from)];\\n       \\n       int i = from - 1, j = to;\\n       while (true) {\\n          do i++; while (V[i] < piv);\\n          do j--; while (V[j] > piv);\\n          if (i >= j) break;\\n          swap(V[i], V[j]);\\n       }\\n       quickSort(V, from, j + 1);\\n       quickSort(V, j + 1, to);\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n      quickSort(nums, 0, nums.size());\\n      return nums;\\n    }\\n```\n```\\nvector<int> sortArray(vector<int>& nums) {\\n   int n = nums.size();\\n   int minEl = nums[0], maxEl = nums[0];\\n   for (int i = 1; i < n; ++i) {\\n      if (minEl > nums[i]) minEl = nums[i];\\n      if (maxEl < nums[i]) maxEl = nums[i];\\n   }\\n   vector<int> C(maxEl - minEl + 1);\\n   for (int i : nums) ++C[i - minEl];\\n   int j = 0;\\n   for (int i = 0; i < C.size(); ++i) {\\n      int el = i + minEl;\\n      int &cnt = C[i];\\n      while (cnt--) nums[j++] = el;\\n   }\\n   return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 276359,
                "title": "java-quicksort",
                "content": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        if (nums == null || nums.length == 0) return nums;\\n        quickSort(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n    \\n    private void quickSort(int[] nums, int start, int end) {\\n        if (start >= end) return;\\n        \\n        int i = start, j = end, pivot = nums[i + (j - i) / 2];\\n        \\n        while (i <= j) {\\n            while (i <= j && nums[i] < pivot) ++i;\\n            while (i <= j && nums[j] > pivot) --j;\\n            \\n            if (i <= j) {\\n                int tmp = nums[i];\\n                nums[i++] = nums[j];\\n                nums[j--] = tmp;\\n            }\\n        }\\n        \\n        quickSort(nums, i, end);\\n        quickSort(nums, start, j);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        if (nums == null || nums.length == 0) return nums;\\n        quickSort(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n    \\n    private void quickSort(int[] nums, int start, int end) {\\n        if (start >= end) return;\\n        \\n        int i = start, j = end, pivot = nums[i + (j - i) / 2];\\n        \\n        while (i <= j) {\\n            while (i <= j && nums[i] < pivot) ++i;\\n            while (i <= j && nums[j] > pivot) --j;\\n            \\n            if (i <= j) {\\n                int tmp = nums[i];\\n                nums[i++] = nums[j];\\n                nums[j--] = tmp;\\n            }\\n        }\\n        \\n        quickSort(nums, i, end);\\n        quickSort(nums, start, j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299665,
                "title": "merge-sort-most-optimized",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvoid merge(int arr[], int l, int r, int mid) {      /* DR167937-ag255126-01 -> */\\n    int lsize = mid - l + 1, rsize = r - mid;\\n    int left[lsize];\\n    int i, j, k;\\n    int *right = arr + mid + 1;\\n    for(i = 0; i < lsize; i++)\\n        left[i] = arr[l + i];\\n    i = 0, j = 0, k = l;\\n    while(i < lsize && j < rsize) {\\n        if(left[i] < right[j])\\n            arr[k++] = left[i++];\\n        else\\n            arr[k++] = right[j++];\\n    }\\n    while(i < lsize)\\n        arr[k++] = left[i++];\\n    while(j < rsize)\\n        arr[k++] = right[j++];\\n}\\nvoid mergesort(int arr[], int l, int r) {\\n    if(l < r) {\\n        int mid = l + (r - l) / 2;\\n        mergesort(arr, l, mid);\\n        mergesort(arr, mid + 1, r);\\n        merge(arr, l, r, mid);\\n    }\\n}       /* <- DR167937-ag255126-01 -> */\\nint* sortArray(int* nums, int numsSize, int* returnSize){\\n    mergesort(nums, 0, numsSize - 1);\\n    *returnSize = numsSize;\\n    return nums;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Merge Sort"
                ],
                "code": "```\\nvoid merge(int arr[], int l, int r, int mid) {      /* DR167937-ag255126-01 -> */\\n    int lsize = mid - l + 1, rsize = r - mid;\\n    int left[lsize];\\n    int i, j, k;\\n    int *right = arr + mid + 1;\\n    for(i = 0; i < lsize; i++)\\n        left[i] = arr[l + i];\\n    i = 0, j = 0, k = l;\\n    while(i < lsize && j < rsize) {\\n        if(left[i] < right[j])\\n            arr[k++] = left[i++];\\n        else\\n            arr[k++] = right[j++];\\n    }\\n    while(i < lsize)\\n        arr[k++] = left[i++];\\n    while(j < rsize)\\n        arr[k++] = right[j++];\\n}\\nvoid mergesort(int arr[], int l, int r) {\\n    if(l < r) {\\n        int mid = l + (r - l) / 2;\\n        mergesort(arr, l, mid);\\n        mergesort(arr, mid + 1, r);\\n        merge(arr, l, r, mid);\\n    }\\n}       /* <- DR167937-ag255126-01 -> */\\nint* sortArray(int* nums, int numsSize, int* returnSize){\\n    mergesort(nums, 0, numsSize - 1);\\n    *returnSize = numsSize;\\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3249713,
                "title": "python3-merge-sort-accepted-and-others-time-limit-exceed",
                "content": "https://leetcode.com/submissions/detail/908040432/   \\nRuntime: **1743 ms, faster than 57.31%** of Python3 online submissions for Sort an Array.  \\nMemory Usage: 36.6 MB, less than 5.12% of Python3 online submissions for Sort an Array.  \\n```Python\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        # return sorted(nums) ## Accepted, Runtime: 689 ms, faster than 92.97%\\n        return self.mergeSort(nums) ## Accepted, Runtime: 1761 ms, faster than 56.47%, recursive, always O(nlog(n))\\n        # return self.quickSort2(nums) ## Time Limit Exceeded\\n        # return self.quickSort(nums) ## Time Limit Exceeded; recursive, avg O(nlog(n)), worst O(n^2)\\n        # return self.binarySort(nums) ## Time Limit Exceeded\\n        # return self.bubbleSort(nums) ## Time Limit Exceeded\\n        \\n    def mergeSort(self, nums):\\n        def recur(left, right):\\n            nonlocal tmp\\n            if left>=right: return ## base case\\n            \\n            mid = (left+right)//2\\n            recur(left, mid); recur(mid+1, right) ## recursive calls\\n            \\n            pl, pr, pt = left, mid+1, left ## left, right, tmp pointer\\n            while pl<=mid and pr<=right: ## merge\\n                if nums[pl]<=nums[pr]:\\n                    tmp[pt]=nums[pl]; pl+=1\\n                else:\\n                    tmp[pt]=nums[pr]; pr+=1\\n                pt += 1\\n            if pl<mid+1: ## merge rest\\n                tmp[pt:right+1] = nums[pl:mid+1] \\n            elif pr<right+1:\\n                tmp[pt:right+1] = nums[pr:right+1]\\n            nums[left:right+1] = tmp[left:right+1] ## copy back\\n            \\n        l=len(nums); tmp=[None]*l\\n        recur(0, l-1)\\n        return nums\\n    \\n    def quickSort2(self, nums):\\n        def recur(head, tail):\\n            if head>=tail: return ## base case\\n            l, r = head, tail\\n            pivot = nums[(r-l)//2+l] ## choose middle point as pivot\\n            while r>=l:\\n                while r>=l and nums[l]<pivot: l+=1\\n                while r>=l and nums[r]>pivot: r-=1\\n                if r>=l:\\n                    nums[l], nums[r] = nums[r], nums[l]\\n                    l += 1; r -= 1\\n            recur(head, r); recur(l, tail)\\n        recur(0, len(nums)-1)\\n        return nums\\n    \\n    def quickSort(self, nums): \\n        l = len(nums)\\n        if l<2: return nums ## base case\\n        curr = 0 \\n        for i in range(1,l):\\n            if nums[0]>nums[i]:\\n                curr += 1\\n                nums[curr], nums[i] = nums[i], nums[curr]\\n        nums[curr], nums[0] = nums[0], nums[curr]\\n        return self.quickSort(nums[:curr]) + [nums[curr]] + self.quickSort(nums[curr+1:])\\n    \\n    def binarySort(self, nums): \\n        def insert(n):\\n            nonlocal ns\\n            if not ns: ns=[n]; return\\n            if n>ns[-1]: ns=ns+[n]; return\\n            if n<ns[0]: ns=[n]+ns; return\\n            low, high = 0, len(ns)-1\\n            while low<high:\\n                mid = (low + high) // 2\\n                if ns[mid]==n:\\n                    ns = ns[:mid]+[n]+ns[mid:]\\n                    return \\n                if ns[mid]<n:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n            ns = ns[:low]+[n]+ns[low:] \\n        ns = []\\n        for n in nums:\\n            insert(n) #;print(ns)\\n        return ns\\n    \\n    def bubbleSort(self, nums): \\n        l = len(nums)\\n        for i in range(l-1):\\n            for j in range(l-1-i):\\n                if nums[j]>nums[j+1]:\\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\\n        return nums\\n```\\n**Some test cases**  \\n```text\\n[5,2,3,1]\\n[5,1,1,2,0,0]\\n[-4,0,7,4,9,-5,-1,0,-7,-1]\\n[0]\\n[3,0]\\n[0,3]\\n[9,0,3]\\n[9,3,0]\\n```\\n**Some large test cases**   \\nhttps://leetcode.com/submissions/detail/906896742/testcase/  \\nhttps://leetcode.com/submissions/detail/907318050/testcase/  \\nhttps://leetcode.com/submissions/detail/907319122/testcase/  \\n\\n**YouTube tutorials**  \\nMerge Sort\\nhttps://www.youtube.com/watch?v=KF2j-9iSf4Q (recursive)\\nhttps://www.youtube.com/watch?v=3j0SWDX4AtU, (recursive, however can be implemented as DFS)\\nQuick Sort 2 \\nhttps://www.youtube.com/watch?v=SLauY6PpjW4 (middle element as pivot)  \\nQuick Sort  \\nhttps://www.youtube.com/watch?v=Hoixgm4-P4M (first element as pivot)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Merge Sort"
                ],
                "code": "```Python\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        # return sorted(nums) ## Accepted, Runtime: 689 ms, faster than 92.97%\\n        return self.mergeSort(nums) ## Accepted, Runtime: 1761 ms, faster than 56.47%, recursive, always O(nlog(n))\\n        # return self.quickSort2(nums) ## Time Limit Exceeded\\n        # return self.quickSort(nums) ## Time Limit Exceeded; recursive, avg O(nlog(n)), worst O(n^2)\\n        # return self.binarySort(nums) ## Time Limit Exceeded\\n        # return self.bubbleSort(nums) ## Time Limit Exceeded\\n        \\n    def mergeSort(self, nums):\\n        def recur(left, right):\\n            nonlocal tmp\\n            if left>=right: return ## base case\\n            \\n            mid = (left+right)//2\\n            recur(left, mid); recur(mid+1, right) ## recursive calls\\n            \\n            pl, pr, pt = left, mid+1, left ## left, right, tmp pointer\\n            while pl<=mid and pr<=right: ## merge\\n                if nums[pl]<=nums[pr]:\\n                    tmp[pt]=nums[pl]; pl+=1\\n                else:\\n                    tmp[pt]=nums[pr]; pr+=1\\n                pt += 1\\n            if pl<mid+1: ## merge rest\\n                tmp[pt:right+1] = nums[pl:mid+1] \\n            elif pr<right+1:\\n                tmp[pt:right+1] = nums[pr:right+1]\\n            nums[left:right+1] = tmp[left:right+1] ## copy back\\n            \\n        l=len(nums); tmp=[None]*l\\n        recur(0, l-1)\\n        return nums\\n    \\n    def quickSort2(self, nums):\\n        def recur(head, tail):\\n            if head>=tail: return ## base case\\n            l, r = head, tail\\n            pivot = nums[(r-l)//2+l] ## choose middle point as pivot\\n            while r>=l:\\n                while r>=l and nums[l]<pivot: l+=1\\n                while r>=l and nums[r]>pivot: r-=1\\n                if r>=l:\\n                    nums[l], nums[r] = nums[r], nums[l]\\n                    l += 1; r -= 1\\n            recur(head, r); recur(l, tail)\\n        recur(0, len(nums)-1)\\n        return nums\\n    \\n    def quickSort(self, nums): \\n        l = len(nums)\\n        if l<2: return nums ## base case\\n        curr = 0 \\n        for i in range(1,l):\\n            if nums[0]>nums[i]:\\n                curr += 1\\n                nums[curr], nums[i] = nums[i], nums[curr]\\n        nums[curr], nums[0] = nums[0], nums[curr]\\n        return self.quickSort(nums[:curr]) + [nums[curr]] + self.quickSort(nums[curr+1:])\\n    \\n    def binarySort(self, nums): \\n        def insert(n):\\n            nonlocal ns\\n            if not ns: ns=[n]; return\\n            if n>ns[-1]: ns=ns+[n]; return\\n            if n<ns[0]: ns=[n]+ns; return\\n            low, high = 0, len(ns)-1\\n            while low<high:\\n                mid = (low + high) // 2\\n                if ns[mid]==n:\\n                    ns = ns[:mid]+[n]+ns[mid:]\\n                    return \\n                if ns[mid]<n:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n            ns = ns[:low]+[n]+ns[low:] \\n        ns = []\\n        for n in nums:\\n            insert(n) #;print(ns)\\n        return ns\\n    \\n    def bubbleSort(self, nums): \\n        l = len(nums)\\n        for i in range(l-1):\\n            for j in range(l-1-i):\\n                if nums[j]>nums[j+1]:\\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\\n        return nums\\n```\n```text\\n[5,2,3,1]\\n[5,1,1,2,0,0]\\n[-4,0,7,4,9,-5,-1,0,-7,-1]\\n[0]\\n[3,0]\\n[0,3]\\n[9,0,3]\\n[9,3,0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244967,
                "title": "killer-solution-by-sd-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n        priority_queue<int,vector<int>, greater<int>> pq;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        vector<int> vec;\\n        while(!pq.empty())\\n        {\\n            vec.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n        priority_queue<int,vector<int>, greater<int>> pq;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        vector<int> vec;\\n        while(!pq.empty())\\n        {\\n            vec.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244550,
                "title": "python3-3-methods",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing inbuilt function, heap/priorityqueue sort and merger sort we can solve this.\\n\\n# Approach 1: Inbuilt function\\n- used python\\'s inbuilt fastest sorting function **TimeSort**\\n![Capture.PNG](https://assets.leetcode.com/users/images/06aa2b51-7890-4821-b880-e8c7421ad855_1677688428.8423078.png)\\n\\n```\\nfrom random import randint as ri\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        return nums\\n```\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n---\\n# Approach 2: PriorityQueue\\n- python\\'s priority queue uses heap structure\\n- so we know popping from heap always gives sorted array.\\n![Capture.PNG](https://assets.leetcode.com/users/images/449a84a5-cea1-43fb-adb1-b516b800b31b_1677688874.0392013.png)\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n- Space complexity: O(2N)\\n# Code\\n```\\nfrom queue import PriorityQueue as pq\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        q = pq()\\n        for i in nums: q.put(i)\\n        for i in range(len(nums)): nums[i] = q.get()\\n        return nums\\n```\\n---\\n# Approach 3: MergeSort\\n- using mergesort we can solve this\\n- mergesort will take same time no matter what input is so this makes it easy when we have sorted array as input.\\n- and stack load is also fixed.\\n![Capture.PNG](https://assets.leetcode.com/users/images/e388ad68-4e20-4e34-a455-c66b2fd6b3b3_1677688912.2943568.png)\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n- Space complexity: O(N)\\n# Code\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        def mergesort(arr = nums):\\n            if len(arr) - 1:\\n                mid = len(arr) // 2\\n                left = arr[:mid]\\n                right = arr[mid:]\\n                mergesort(left)\\n                mergesort(right)\\n\\n                i = j = k = 0\\n\\n                while i < len(left) and j < len(right):\\n                    if left[i] <= right[j]:\\n                        arr[k] = left[i]\\n                        i += 1\\n                    else:\\n                        arr[k] = right[j]\\n                        j += 1\\n                    k += 1\\n                \\n                while i < len(left):\\n                    arr[k] = left[i]\\n                    i += 1\\n                    k += 1\\n                \\n                while j < len(right):\\n                    arr[k] = right[j]\\n                    j += 1\\n                    k += 1\\n        mergesort()\\n        return nums\\n```\\n# please like and comment :-)",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```\\nfrom random import randint as ri\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        return nums\\n```\n```\\nfrom queue import PriorityQueue as pq\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        q = pq()\\n        for i in nums: q.put(i)\\n        for i in range(len(nums)): nums[i] = q.get()\\n        return nums\\n```\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        def mergesort(arr = nums):\\n            if len(arr) - 1:\\n                mid = len(arr) // 2\\n                left = arr[:mid]\\n                right = arr[mid:]\\n                mergesort(left)\\n                mergesort(right)\\n\\n                i = j = k = 0\\n\\n                while i < len(left) and j < len(right):\\n                    if left[i] <= right[j]:\\n                        arr[k] = left[i]\\n                        i += 1\\n                    else:\\n                        arr[k] = right[j]\\n                        j += 1\\n                    k += 1\\n                \\n                while i < len(left):\\n                    arr[k] = left[i]\\n                    i += 1\\n                    k += 1\\n                \\n                while j < len(right):\\n                    arr[k] = right[j]\\n                    j += 1\\n                    k += 1\\n        mergesort()\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244258,
                "title": "four-ways-in-c-inbuilt-merge-sort-easy-faster-than-98-85",
                "content": "I have come up with 4 methods to solve this problem (bcoz I was bored of university classes).\\n\\n<details>\\n<summary> <strong>Spoiler Alert</strong> </summary>\\n<br/>\\nThe best method is at the end.\\n<br/>\\n</details>\\n\\n**Method 1:**\\n\\nThe shortest solution is to use inbuilt sort function.\\n```\\nclass Solution {\\npublic:\\n\\tvector<int> sortArray(vector<int>& nums) {\\n\\t\\tsort(begin(nums), end(nums));\\n\\t\\treturn nums;\\n\\t}\\n};\\n```\\nExpected Time Complexity: **O(nlogn)**\\nAverage Runtime: **147ms**\\n\\n**Method 2:**\\n\\nNow talking about what leetcode wants, a.k.a, merge sort. The code below is standard merge sort.\\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int> &nums, int l, int m, int r){\\n        int n1 = m + 1 - l, n2 = r - m;\\n        vector<int> left(n1), right(n2);\\n        for (int i = 0; i < n1; i++)\\n            left[i] = nums[l + i];\\n        for (int i = 0; i < n2; i++)\\n            right[i] = nums[m + 1 + i];\\n        int i = 0, j = 0, k = l;\\n        while (i < n1 || j < n2) \\n        {\\n            if (j == n2 || i < n1 && left[i] < right[j])\\n                nums[k++] = left[i++];\\n            else\\n                nums[k++] = right[j++];\\n        }\\n    }\\n    \\n    void mergeSort(vector<int> &nums, int l, int r){\\n        if(l >= r)\\n            return;\\n        int mid = (l + r) / 2;\\n        mergeSort(nums, l, mid);\\n        mergeSort(nums, mid + 1, r);\\n        merge(nums, l, mid, r);\\n    }\\n    \\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size() - 1);\\n        return nums;\\n    }\\n};\\n```\\nExpected Time Complexity: **O(nlogn)**\\nAverage Runtime: **730ms**\\n\\n**Method 3:**\\n\\nUse a min-heap priority queue. Push all elements into this priority queue, when you sequentially pop elements from this queue they will be ordered in ascending order.\\n```\\nclass Solution {\\npublic:\\n\\tvector<int> sortArray(vector<int>& nums) {\\n\\t\\tpriority_queue<int, vector<int>, greater<int>> pq; //Min-Heap Priority Queue\\n\\t\\tfor(int num : nums)\\n            pq.push(num);\\n\\t\\tvector<int> ans;\\n\\t\\twhile(!pq.empty())\\n        {\\n\\t\\t\\tans.push_back(pq.top());\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\nExpected Time Complexity: **O(nlogn)**\\nAverage Runtime: **185ms**\\n\\n**Method 4:**\\n\\nIf we think a little we observe that all the elements in the array will lie in between the max and min element in the array. Therefore we construct a frequency array to keep track of the elements we have and sequentially dequeue these elements from the freq vector to give us the final sorted array.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        int mx = INT_MIN, mn = INT_MAX;\\n        for(int i: nums) \\n            mx = max(mx, i), mn = min(mn, i);\\n        vector<int> freq(mx - mn + 2, 0), ans;\\n        for(int num : nums)\\n            freq[num - mn]++;\\n        for(int i = 0; i < freq.size(); i++)\\n            while(freq[i]--)\\n                ans.push_back(i + mn);\\n        return ans;\\n    }\\n};\\n```\\nExpected Time Complexity: **O(n)**\\nAverage Runtime: **108ms**\\n\\n<br/>\\n\\nIf you found my solution useful, please **upvote** \\u2B06\\uFE0F.\\n\\n**Comments** are appreciated!\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Recursion",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int> sortArray(vector<int>& nums) {\\n\\t\\tsort(begin(nums), end(nums));\\n\\t\\treturn nums;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void merge(vector<int> &nums, int l, int m, int r){\\n        int n1 = m + 1 - l, n2 = r - m;\\n        vector<int> left(n1), right(n2);\\n        for (int i = 0; i < n1; i++)\\n            left[i] = nums[l + i];\\n        for (int i = 0; i < n2; i++)\\n            right[i] = nums[m + 1 + i];\\n        int i = 0, j = 0, k = l;\\n        while (i < n1 || j < n2) \\n        {\\n            if (j == n2 || i < n1 && left[i] < right[j])\\n                nums[k++] = left[i++];\\n            else\\n                nums[k++] = right[j++];\\n        }\\n    }\\n    \\n    void mergeSort(vector<int> &nums, int l, int r){\\n        if(l >= r)\\n            return;\\n        int mid = (l + r) / 2;\\n        mergeSort(nums, l, mid);\\n        mergeSort(nums, mid + 1, r);\\n        merge(nums, l, mid, r);\\n    }\\n    \\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size() - 1);\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tvector<int> sortArray(vector<int>& nums) {\\n\\t\\tpriority_queue<int, vector<int>, greater<int>> pq; //Min-Heap Priority Queue\\n\\t\\tfor(int num : nums)\\n            pq.push(num);\\n\\t\\tvector<int> ans;\\n\\t\\twhile(!pq.empty())\\n        {\\n\\t\\t\\tans.push_back(pq.top());\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        int mx = INT_MIN, mn = INT_MAX;\\n        for(int i: nums) \\n            mx = max(mx, i), mn = min(mn, i);\\n        vector<int> freq(mx - mn + 2, 0), ans;\\n        for(int num : nums)\\n            freq[num - mn]++;\\n        for(int i = 0; i < freq.size(); i++)\\n            while(freq[i]--)\\n                ans.push_back(i + mn);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243577,
                "title": "heap-sort-o-1-space-complexity-c",
                "content": "# Intuition\\nHeap Sort and Merge Sort are such Sorting Algorithms that has the time complexity of O(nlogn). Merge Sort has a Space Complexity of O(n), but Heap sort can be done in O(1), as it doesn\\'t take extra space. As the Question suggests to take the **smallest space complexity possible,** it is better to go with Heap Sort.\\n\\n# Approach\\n1. We are converting the given Array to a Max-heap by **Build Heap Algorithm**.\\n2. Then We are Sorting the Array by the moving the current Maximum element to the end of the Array and appling **Heapify Algorithm** to the rest of the unsorted array at every iteration.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void Max_Heapify(vector<int> &nums, int i, int N){\\n        int left = 2*i + 1;\\n        int right = 2 * i + 2;\\n        int largest = i;\\n        if(left <= N && nums[left] > nums[largest])\\n            largest = left;\\n        if(right <= N && nums[right] > nums[largest])\\n            largest = right;\\n        if(largest != i){\\n            swap(nums[largest], nums[i]);\\n            Max_Heapify(nums, largest, N);\\n        }\\n        \\n    }\\n    void Build_Max_Heap(vector<int> &nums, int N){\\n        for(int i = N/2; i>= 0; i--){\\n            Max_Heapify(nums, i, N);\\n        }\\n    }\\n    void HeapSort(vector<int> &nums, int N){\\n        for(int i = N; i > 0; i--){\\n            swap(nums[0],nums[i]);\\n            Max_Heapify(nums, 0, i-1);\\n        }\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        int N = nums.size()-1;\\n        Build_Max_Heap(nums, N);\\n        HeapSort(nums, N);\\n        return nums;\\n    }\\n};\\n```\\n*Please Upvote if the code and explanation is helpful to you*",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void Max_Heapify(vector<int> &nums, int i, int N){\\n        int left = 2*i + 1;\\n        int right = 2 * i + 2;\\n        int largest = i;\\n        if(left <= N && nums[left] > nums[largest])\\n            largest = left;\\n        if(right <= N && nums[right] > nums[largest])\\n            largest = right;\\n        if(largest != i){\\n            swap(nums[largest], nums[i]);\\n            Max_Heapify(nums, largest, N);\\n        }\\n        \\n    }\\n    void Build_Max_Heap(vector<int> &nums, int N){\\n        for(int i = N/2; i>= 0; i--){\\n            Max_Heapify(nums, i, N);\\n        }\\n    }\\n    void HeapSort(vector<int> &nums, int N){\\n        for(int i = N; i > 0; i--){\\n            swap(nums[0],nums[i]);\\n            Max_Heapify(nums, 0, i-1);\\n        }\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        int N = nums.size()-1;\\n        Build_Max_Heap(nums, N);\\n        HeapSort(nums, N);\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243344,
                "title": "easy-priority-queue-solution",
                "content": "# Intuition\\nPriority queue gives us the smallest element first.\\n# Approach\\nWe can put the elements of nums in a Priority queue and then override the vales of nums with the smallest element given by Priority queue.\\n# Complexity\\n- Time complexity: O(nlog(n))\\n- Space complexity: O(n)\\n\\n# Java\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) \\n    {\\n    // using priority queue ->\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int n: nums){\\n            pq.add(n);\\n        }\\n\\n        for(int i=0; i<nums.length; i++){\\n            nums[i] = pq.peek();\\n            pq.remove();\\n        }\\n        return nums;      \\n    }\\n     \\n}\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int n: nums)\\n            pq.push(n);\\n\\n        for(int i=0; i<nums.size(); i++){\\n            nums[i] = pq.top();\\n            pq.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) \\n    {\\n    // using priority queue ->\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int n: nums){\\n            pq.add(n);\\n        }\\n\\n        for(int i=0; i<nums.length; i++){\\n            nums[i] = pq.peek();\\n            pq.remove();\\n        }\\n        return nums;      \\n    }\\n     \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int n: nums)\\n            pq.push(n);\\n\\n        for(int i=0; i<nums.size(); i++){\\n            nums[i] = pq.top();\\n            pq.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243337,
                "title": "java-mergesort",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        mergeSort(nums,0,nums.length-1);\\n        return nums;\\n    }\\n    public  void mergeSort(int[] nums,int start,int end){\\n        if(start<end){\\n            int mid=start+(end-start)/2;\\n            mergeSort(nums,start,mid);\\n            mergeSort(nums,mid+1,end);\\n            merge(nums,start,mid,end);\\n        }\\n    }\\n    public void merge(int[] nums,int start,int mid,int end){\\n        int[] arr1=Arrays.copyOfRange(nums,start,mid+1);\\n        int[] arr2=Arrays.copyOfRange(nums,mid+1,end+1);\\n        int i=0,j=0;\\n        int index=start;\\n        while(i<arr1.length && j<arr2.length){\\n            if(arr1[i]<=arr2[j]){\\n                nums[index]=arr1[i];\\n                i++;\\n            }else{\\n                nums[index]=arr2[j];\\n                j++;\\n            }\\n            index++;    \\n        }\\n        while(i<arr1.length){\\n            nums[index]=arr1[i];\\n            i++;index++;\\n        }\\n        while(j<arr2.length){\\n            nums[index]=arr2[j];\\n            j++;index++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        mergeSort(nums,0,nums.length-1);\\n        return nums;\\n    }\\n    public  void mergeSort(int[] nums,int start,int end){\\n        if(start<end){\\n            int mid=start+(end-start)/2;\\n            mergeSort(nums,start,mid);\\n            mergeSort(nums,mid+1,end);\\n            merge(nums,start,mid,end);\\n        }\\n    }\\n    public void merge(int[] nums,int start,int mid,int end){\\n        int[] arr1=Arrays.copyOfRange(nums,start,mid+1);\\n        int[] arr2=Arrays.copyOfRange(nums,mid+1,end+1);\\n        int i=0,j=0;\\n        int index=start;\\n        while(i<arr1.length && j<arr2.length){\\n            if(arr1[i]<=arr2[j]){\\n                nums[index]=arr1[i];\\n                i++;\\n            }else{\\n                nums[index]=arr2[j];\\n                j++;\\n            }\\n            index++;    \\n        }\\n        while(i<arr1.length){\\n            nums[index]=arr1[i];\\n            i++;index++;\\n        }\\n        while(j<arr2.length){\\n            nums[index]=arr2[j];\\n            j++;index++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243247,
                "title": "c-code-heap-sort-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Question demands for a sorting algorithm, with O(nlog(n))\\ntime complexity and with the smallest space complexity possible.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe know heap sort best suits the desired requirements.\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    \\n    void maxheapify(vector<int>&nums,int n,int i)\\n    {\\n        int largest=i,left=(2*i)+1,right=(2*i)+2;\\n        if(left<n&&nums[left]>nums[largest])\\n        {\\n            largest=left;\\n        }\\n        if(right<n&&nums[right]>nums[largest])\\n        {\\n            largest=right;\\n        }\\n        if(largest!=i)\\n        {\\n            swap(nums[largest],nums[i]);\\n            maxheapify(nums,n,largest);\\n        }\\n\\n    }\\n    void buildheap(vector<int> &nums,int n)\\n    {\\n        for(int i=(n-2)/2;i>=0;i--)\\n        {\\n            maxheapify(nums,n,i);\\n        }\\n    }\\n\\n    void heapsort(vector<int>&nums,int n)\\n    {\\n       \\n        buildheap(nums,n);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            swap(nums[0],nums[i]);\\n            maxheapify(nums,i,0);\\n        }\\n       \\n    }\\n\\n\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        heapsort(nums,nums.size());\\n        return nums;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    \\n    void maxheapify(vector<int>&nums,int n,int i)\\n    {\\n        int largest=i,left=(2*i)+1,right=(2*i)+2;\\n        if(left<n&&nums[left]>nums[largest])\\n        {\\n            largest=left;\\n        }\\n        if(right<n&&nums[right]>nums[largest])\\n        {\\n            largest=right;\\n        }\\n        if(largest!=i)\\n        {\\n            swap(nums[largest],nums[i]);\\n            maxheapify(nums,n,largest);\\n        }\\n\\n    }\\n    void buildheap(vector<int> &nums,int n)\\n    {\\n        for(int i=(n-2)/2;i>=0;i--)\\n        {\\n            maxheapify(nums,n,i);\\n        }\\n    }\\n\\n    void heapsort(vector<int>&nums,int n)\\n    {\\n       \\n        buildheap(nums,n);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            swap(nums[0],nums[i]);\\n            maxheapify(nums,i,0);\\n        }\\n       \\n    }\\n\\n\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        heapsort(nums,nums.size());\\n        return nums;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242961,
                "title": "7-lines-java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num : nums) pq.offer(num);\\n\\n        int i = 0;\\n        while(!pq.isEmpty()) ans[i++] = pq.poll();\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num : nums) pq.offer(num);\\n\\n        int i = 0;\\n        while(!pq.isEmpty()) ans[i++] = pq.poll();\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242764,
                "title": "merge-sort-o-n-log-n-and-priority-queue-o-n-log-n",
                "content": "# Approach\\nUsing Merge Sort\\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO ( n )\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        sort(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n    private void merge(int[] nums, int left, int right, int mid) {\\n        int n1 = mid - left + 1;\\n        int n2 = right - mid;\\n\\n        // temp variables\\n        int[] l = new int[n1];\\n        int[] r = new int[n2];\\n\\n        for (int i = 0; i < n1; i++) {\\n            l[i] = nums[left  + i];\\n        }\\n        for (int j = 0; j < n2; j++) {\\n            r[j] = nums[mid + j + 1];\\n        }\\n\\n        int i = 0, j = 0, k = left;\\n        while (i < n1 && j < n2) {\\n            if (l[i] <= r[j]) {\\n                nums[k] = l[i];\\n                i++;\\n            } else {\\n                nums[k] = r[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n\\n        while (i < n1) {\\n            nums[k++] = l[i++];\\n        }\\n        while (j < n2) {\\n            nums[k++] = r[j++];\\n        }\\n    }\\n    private void sort(int[] nums, int left , int right) {\\n        if (left < right) {\\n            int mid  = left + (right - left) / 2;\\n            sort(nums, left, mid);\\n            sort(nums, mid + 1, right);\\n            merge(nums, left, right, mid);\\n        }\\n    }\\n}\\n```\\n\\n# Hindi Explanation\\nhttps://youtu.be/oZWd8xsB1dk\\n# Approach\\nUsing Priority Queue\\n\\n# Complexity\\n- Time complexity:\\nO ( n log n)\\n\\n- Space complexity:\\nO ( n )\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            pq.add(nums[i]);\\n        }\\n        int i = 0;\\n        while (!pq.isEmpty()) {\\n            nums[i] = pq.poll();\\n            i++;\\n        }\\n        return nums;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        sort(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n    private void merge(int[] nums, int left, int right, int mid) {\\n        int n1 = mid - left + 1;\\n        int n2 = right - mid;\\n\\n        // temp variables\\n        int[] l = new int[n1];\\n        int[] r = new int[n2];\\n\\n        for (int i = 0; i < n1; i++) {\\n            l[i] = nums[left  + i];\\n        }\\n        for (int j = 0; j < n2; j++) {\\n            r[j] = nums[mid + j + 1];\\n        }\\n\\n        int i = 0, j = 0, k = left;\\n        while (i < n1 && j < n2) {\\n            if (l[i] <= r[j]) {\\n                nums[k] = l[i];\\n                i++;\\n            } else {\\n                nums[k] = r[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n\\n        while (i < n1) {\\n            nums[k++] = l[i++];\\n        }\\n        while (j < n2) {\\n            nums[k++] = r[j++];\\n        }\\n    }\\n    private void sort(int[] nums, int left , int right) {\\n        if (left < right) {\\n            int mid  = left + (right - left) / 2;\\n            sort(nums, left, mid);\\n            sort(nums, mid + 1, right);\\n            merge(nums, left, right, mid);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            pq.add(nums[i]);\\n        }\\n        int i = 0;\\n        while (!pq.isEmpty()) {\\n            nums[i] = pq.poll();\\n            i++;\\n        }\\n        return nums;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242505,
                "title": "simple-program-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n- O(1)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArray = function(nums) {\\n    nums=nums.sort((a,b)=>{return a-b});\\n    return nums;\\n};\\n```\\n![6233d50d-1433-4516-8d8e-90fb8e13d32f_1677303191.974716.jpeg](https://assets.leetcode.com/users/images/430dd0dc-7cf9-449e-969c-d5197dc8a7b6_1677650319.954917.jpeg)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArray = function(nums) {\\n    nums=nums.sort((a,b)=>{return a-b});\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3242481,
                "title": "beats-99-java-code",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        int n = nums.length;\\n        int max = nums[0];\\n        int min = nums[0];\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n            min = Math.min(min, num);\\n        }\\n        int len = max - min;\\n        int[] arr = new int[len + 1];\\n        for (int num : nums) {\\n            arr[num - min]++;\\n        }\\n        int index = 0;\\n        for (int i = 0; i <= len; i++) {\\n            while (arr[i] > 0) {\\n                nums[index] = min;\\n                index++;\\n                arr[i]--;\\n            }\\n            min++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Divide and Conquer",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        int n = nums.length;\\n        int max = nums[0];\\n        int min = nums[0];\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n            min = Math.min(min, num);\\n        }\\n        int len = max - min;\\n        int[] arr = new int[len + 1];\\n        for (int num : nums) {\\n            arr[num - min]++;\\n        }\\n        int index = 0;\\n        for (int i = 0; i <= len; i++) {\\n            while (arr[i] > 0) {\\n                nums[index] = min;\\n                index++;\\n                arr[i]--;\\n            }\\n            min++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241730,
                "title": "basic-merge-sort-c-no-in-built-function-used",
                "content": "# Complexity\\n- Time complexity:\\nO(NLOGN)\\n\\n- Space complexity:\\nO(NLOGN)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mergesorted(vector<int>&arr)\\n    {\\n        if(arr.size()==1)\\n        {\\n            return arr;\\n        }\\n        int dividesize=arr.size()/2;\\n        vector<int>merge1,merge2;\\n        for(int i=0;i<dividesize;i++)\\n        {\\n            merge1.push_back(arr[i]);\\n        }\\n        for(int i=dividesize;i<arr.size();i++)\\n        {\\n            merge2.push_back(arr[i]);\\n        }\\n        merge1=mergesorted(merge1);\\n        merge2=mergesorted(merge2);\\n        int ptr1=0,ptr2=0,ptr3=0;\\n        while(ptr3<arr.size())\\n        {\\n            if(ptr1==merge1.size())\\n            {\\n                arr[ptr3]=merge2[ptr2];\\n                ptr2++;\\n                ptr3++;\\n                continue;\\n            }\\n            if(ptr2==merge2.size())\\n            {\\n                arr[ptr3]=merge1[ptr1];\\n                ptr1++;\\n                ptr3++;\\n                continue;   \\n            }\\n            if(merge1[ptr1]<merge2[ptr2])\\n            {\\n                arr[ptr3]=merge1[ptr1];\\n                ptr1++;\\n                ptr3++;\\n            }\\n            else\\n            {\\n                arr[ptr3]=merge2[ptr2];\\n                ptr2++;\\n                ptr3++;\\n            }\\n        }\\n        return arr;\\n    }\\n    vector<int> sortArray(vector<int>&nums) \\n    {\\n        return mergesorted(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mergesorted(vector<int>&arr)\\n    {\\n        if(arr.size()==1)\\n        {\\n            return arr;\\n        }\\n        int dividesize=arr.size()/2;\\n        vector<int>merge1,merge2;\\n        for(int i=0;i<dividesize;i++)\\n        {\\n            merge1.push_back(arr[i]);\\n        }\\n        for(int i=dividesize;i<arr.size();i++)\\n        {\\n            merge2.push_back(arr[i]);\\n        }\\n        merge1=mergesorted(merge1);\\n        merge2=mergesorted(merge2);\\n        int ptr1=0,ptr2=0,ptr3=0;\\n        while(ptr3<arr.size())\\n        {\\n            if(ptr1==merge1.size())\\n            {\\n                arr[ptr3]=merge2[ptr2];\\n                ptr2++;\\n                ptr3++;\\n                continue;\\n            }\\n            if(ptr2==merge2.size())\\n            {\\n                arr[ptr3]=merge1[ptr1];\\n                ptr1++;\\n                ptr3++;\\n                continue;   \\n            }\\n            if(merge1[ptr1]<merge2[ptr2])\\n            {\\n                arr[ptr3]=merge1[ptr1];\\n                ptr1++;\\n                ptr3++;\\n            }\\n            else\\n            {\\n                arr[ptr3]=merge2[ptr2];\\n                ptr2++;\\n                ptr3++;\\n            }\\n        }\\n        return arr;\\n    }\\n    vector<int> sortArray(vector<int>&nums) \\n    {\\n        return mergesorted(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241709,
                "title": "daily-leetcoding-challenge-march-day-1",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sort-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sort-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2924360,
                "title": "java-quick-sort-with-explaination",
                "content": "In-place,Not Stable,Not adaptive,Divide and conquer.\\n\\nFor primitive it is preferred and for objects merge sort is preferred. As merge sort takes extra o(n) memory it is not preferred for array. But for linked list merge sort does not need extra space.\\n\\n# Approach\\nWe will take one element as pivot(here the last one) and will try to put it in correct position. By correct position we mean that all element to the left of it are small and right to it are greater than pivot. So, basically we fixing pivot position one by one.\\n\\n![quickPartition.JPG](https://assets.leetcode.com/users/images/30ff6f60-bf82-4e78-b4ca-570d47db3331_1671347685.4171877.jpeg)\\n\\n\\nSo,now swap high with low. and return low i.e. index 2. So,that we will have two partition {13,6} {17,15} now and index 2 element is fixed.\\n\\n# Complexity\\n- Time complexity:\\n $$O(nlogn)$$, but in worst case when data is already sorted it might go to $$O(n2)$$. To avoid worst case we can make pivot as random or mid element always.\\n\\n- Space complexity:\\n$$O(logn)$$ if pivot chosen correctly. else it recursion call might take entire array length and hence will be $$O(n)$$ in worst case.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        quickSort(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n    public void quickSort(int[] arr,int i, int j){\\n       if (i < j) {\\n\\t\\t\\tint p = partition(arr, i, j); \\n            // p is fixed and call quickSort again for left and right array\\n\\t\\t\\tquickSort(arr, i, p-1); \\n\\t\\t\\tquickSort(arr, p+1, j); \\n\\t\\t}\\n    }\\n    public int partition(int[] arr,int l,int h) {\\n        // In worst case it will be o(n^2). i.e. if data is already sorted\\n\\t\\t// we can improve it by using middle element as pivot and then before starting\\n\\t\\t// anything just swap it with high. so, that high will remain pivot.\\n\\n\\t\\t// Find mid of the array\\n\\t\\tint mid = (low + high) / 2;\\n\\t\\t// swap array element present in mid and high index\\n\\t\\tswapIntArray(arr, mid, high);\\n\\t\\t// now pivot is high again.\\n\\t\\t// we goes from low till high-1 because high is reserved for pivot\\n\\t\\tfor (int j = low; j < high; j++) {\\n\\t\\t\\tif (arr[j] < arr[high]) {\\n\\t\\t\\t\\tswapIntArray(arr, j, low);\\n\\t\\t\\t\\tlow++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// when j reached high,we know that low is in pivot position. so we just swap it\\n\\t\\tswapIntArray(arr, high, low);\\n\\t\\treturn low;\\n    }\\n    private void swapIntArray(int[] a, int i,int j){\\n        int temp=a[i];\\n        a[i]=a[j];\\n        a[j]=temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        quickSort(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n    public void quickSort(int[] arr,int i, int j){\\n       if (i < j) {\\n\\t\\t\\tint p = partition(arr, i, j); \\n            // p is fixed and call quickSort again for left and right array\\n\\t\\t\\tquickSort(arr, i, p-1); \\n\\t\\t\\tquickSort(arr, p+1, j); \\n\\t\\t}\\n    }\\n    public int partition(int[] arr,int l,int h) {\\n        // In worst case it will be o(n^2). i.e. if data is already sorted\\n\\t\\t// we can improve it by using middle element as pivot and then before starting\\n\\t\\t// anything just swap it with high. so, that high will remain pivot.\\n\\n\\t\\t// Find mid of the array\\n\\t\\tint mid = (low + high) / 2;\\n\\t\\t// swap array element present in mid and high index\\n\\t\\tswapIntArray(arr, mid, high);\\n\\t\\t// now pivot is high again.\\n\\t\\t// we goes from low till high-1 because high is reserved for pivot\\n\\t\\tfor (int j = low; j < high; j++) {\\n\\t\\t\\tif (arr[j] < arr[high]) {\\n\\t\\t\\t\\tswapIntArray(arr, j, low);\\n\\t\\t\\t\\tlow++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// when j reached high,we know that low is in pivot position. so we just swap it\\n\\t\\tswapIntArray(arr, high, low);\\n\\t\\treturn low;\\n    }\\n    private void swapIntArray(int[] a, int i,int j){\\n        int temp=a[i];\\n        a[i]=a[j];\\n        a[j]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745572,
                "title": "easiest-solution-o-1-one-line-solution-toursit-approved",
                "content": "\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] sortArray(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2646439,
                "title": "c-merge-sort-quicksort-insertion-sort-heap-sort-bubble-sort",
                "content": "Bubble sort\\n\\n\\t// bubbleSort(nums);\\n\\tvoid bubbleSort(vector<int>& nums){\\n        for(int i = nums.size() - 1; i >= 0; i--)\\n            for(int j = 0; j < i; j++)\\n                if(nums[j] > nums[j + 1]) \\n                    swap(nums[j], nums[j + 1]);\\n    }\\nInsertion sort\\n\\n\\t// insertionSort(nums);\\n\\tvoid insertionSort(vector<int>& nums){\\n        if(nums.size() == 0 || nums.size() == 1) return;\\n        for(int i = 1; i < nums.size(); i++){\\n            int tmp = nums[i];\\n            int j = i - 1;\\n            while(j >= 0 && nums[j] > tmp){\\n                nums[j + 1] = nums[j];\\n                j--;\\n            }\\n            nums[j + 1] = tmp;\\n        }\\n    }\\nHeap sort\\n\\nIn terms of heapify stage:\\n\\nBottom up approach (beginning from bottom + sift down) O(n)\\nTop down approach (beginning from top + sift up) O(nlogn)\\nBeginning from top + sift down not working\\nIn fact, \"sift down\" of a certain node x works properly only if both of its left subtree and right subtree (if any) already satisfy the heap property.\\n\\nFor zero-based arrays, for a certain node x:\\n\\nits parent floor( (x - 1) / 2 )\\nits left child 2x + 1\\nits right child 2x + 2\\nThe index of the last non-leaf node of a n-sized heap is floor( n / 2 ) - 1.\\n\\n\\tvoid siftDown(vector<int>& nums, int n, int i){\\n        int biggest = i;\\n        int l = 2 * i + 1;\\n        int r = 2 * i + 2;\\n        if(l < n && nums[biggest] < nums[l])\\n            biggest = l;\\n        if(r < n && nums[biggest] < nums[r])\\n            biggest = r;\\n        if(biggest != i){\\n            swap(nums[i], nums[biggest]);\\n            siftDown(nums, n, biggest);\\n        }\\n    }\\n    \\n\\t// heapSort(nums);\\n    void heapSort(vector<int>& nums){\\n        // heapify stage (bottom up approach)\\n        for(int i = nums.size() / 2 - 1; i >= 0; i--)\\n            siftDown(nums, nums.size(), i);\\n        // sorting stage\\n        for(int i = nums.size() - 1; i > 0; i--){\\n            swap(nums[0], nums[i]);\\n            siftDown(nums, i, 0);\\n        }\\n    }\\nMerge sort (recursive version)\\n\\n\\tvoid merge(vector<int>& nums, int l, int m, int r){\\n        vector<int> tmp(r - l + 1);\\n        int i = l; // index for left subarray\\n        int j = m + 1; // index for right subarray\\n        int k = 0; // index for temporary array\\n        while(i <= m && j <= r){\\n            if(nums[i] <= nums[j]) tmp[k++] = nums[i++]; \\n            else tmp[k++] = nums[j++];\\n        }\\n        while(i <= m) tmp[k++] = nums[i++];\\n        while(j <= r) tmp[k++] = nums[j++]; \\n        for(i = 0; i < k; i++) nums[l + i] = tmp[i];\\n    }\\n\\t\\n\\t// mergeSort(nums, 0, nums.size() - 1);\\n    void mergeSort(vector<int>& nums, int l, int r){\\n        if(l >= r) return;\\n        int m = l + (r - l) / 2; //middle index, same as (l+r)/2\\n        mergeSort(nums, l, m);\\n        mergeSort(nums, m + 1, r);\\n        merge(nums, l, m, r);\\n    }\\nQuick sort (recursive version)\\n\\n\\t// quickSort(nums, 0, nums.size() - 1);\\n    void quickSort(vector<int>& nums, int l, int r){\\n        if(l >= r) return;\\n        int i = l; // cursor for final pivot location \\n        for(int j = l; j <= r - 1; j++){ // nums[r] is chosen as the pivot\\n            if(nums[j] <= nums[r]){\\n                swap(nums[i], nums[j]);\\n                i++; // smaller or equal elements go to the left of i \\n            }\\n        }\\n        swap(nums[i], nums[r]); // after swap, the pivot is nums[i]\\n        quickSort(nums, l, i - 1);\\n        quickSort(nums, i + 1, r);\\n    }\\nThe utility function swap is defined as follows\\n\\n\\tvoid swap(int& a, int& b){\\n        int tmp = a;\\n        a = b;\\n        b = tmp;\\n    }",
                "solutionTags": [
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "Bubble sort\\n\\n\\t// bubbleSort(nums);\\n\\tvoid bubbleSort(vector<int>& nums){\\n        for(int i = nums.size() - 1; i >= 0; i--)\\n            for(int j = 0; j < i; j++)\\n                if(nums[j] > nums[j + 1]) \\n                    swap(nums[j], nums[j + 1]);\\n    }\\nInsertion sort\\n\\n\\t// insertionSort(nums);\\n\\tvoid insertionSort(vector<int>& nums){\\n        if(nums.size() == 0 || nums.size() == 1) return;\\n        for(int i = 1; i < nums.size(); i++){\\n            int tmp = nums[i];\\n            int j = i - 1;\\n            while(j >= 0 && nums[j] > tmp){\\n                nums[j + 1] = nums[j];\\n                j--;\\n            }\\n            nums[j + 1] = tmp;\\n        }\\n    }\\nHeap sort\\n\\nIn terms of heapify stage:\\n\\nBottom up approach (beginning from bottom + sift down) O(n)\\nTop down approach (beginning from top + sift up) O(nlogn)\\nBeginning from top + sift down not working\\nIn fact, \"sift down\" of a certain node x works properly only if both of its left subtree and right subtree (if any) already satisfy the heap property.\\n\\nFor zero-based arrays, for a certain node x:\\n\\nits parent floor( (x - 1) / 2 )\\nits left child 2x + 1\\nits right child 2x + 2\\nThe index of the last non-leaf node of a n-sized heap is floor( n / 2 ) - 1.\\n\\n\\tvoid siftDown(vector<int>& nums, int n, int i){\\n        int biggest = i;\\n        int l = 2 * i + 1;\\n        int r = 2 * i + 2;\\n        if(l < n && nums[biggest] < nums[l])\\n            biggest = l;\\n        if(r < n && nums[biggest] < nums[r])\\n            biggest = r;\\n        if(biggest != i){\\n            swap(nums[i], nums[biggest]);\\n            siftDown(nums, n, biggest);\\n        }\\n    }\\n    \\n\\t// heapSort(nums);\\n    void heapSort(vector<int>& nums){\\n        // heapify stage (bottom up approach)\\n        for(int i = nums.size() / 2 - 1; i >= 0; i--)\\n            siftDown(nums, nums.size(), i);\\n        // sorting stage\\n        for(int i = nums.size() - 1; i > 0; i--){\\n            swap(nums[0], nums[i]);\\n            siftDown(nums, i, 0);\\n        }\\n    }\\nMerge sort (recursive version)\\n\\n\\tvoid merge(vector<int>& nums, int l, int m, int r){\\n        vector<int> tmp(r - l + 1);\\n        int i = l; // index for left subarray\\n        int j = m + 1; // index for right subarray\\n        int k = 0; // index for temporary array\\n        while(i <= m && j <= r){\\n            if(nums[i] <= nums[j]) tmp[k++] = nums[i++]; \\n            else tmp[k++] = nums[j++];\\n        }\\n        while(i <= m) tmp[k++] = nums[i++];\\n        while(j <= r) tmp[k++] = nums[j++]; \\n        for(i = 0; i < k; i++) nums[l + i] = tmp[i];\\n    }\\n\\t\\n\\t// mergeSort(nums, 0, nums.size() - 1);\\n    void mergeSort(vector<int>& nums, int l, int r){\\n        if(l >= r) return;\\n        int m = l + (r - l) / 2; //middle index, same as (l+r)/2\\n        mergeSort(nums, l, m);\\n        mergeSort(nums, m + 1, r);\\n        merge(nums, l, m, r);\\n    }\\nQuick sort (recursive version)\\n\\n\\t// quickSort(nums, 0, nums.size() - 1);\\n    void quickSort(vector<int>& nums, int l, int r){\\n        if(l >= r) return;\\n        int i = l; // cursor for final pivot location \\n        for(int j = l; j <= r - 1; j++){ // nums[r] is chosen as the pivot\\n            if(nums[j] <= nums[r]){\\n                swap(nums[i], nums[j]);\\n                i++; // smaller or equal elements go to the left of i \\n            }\\n        }\\n        swap(nums[i], nums[r]); // after swap, the pivot is nums[i]\\n        quickSort(nums, l, i - 1);\\n        quickSort(nums, i + 1, r);\\n    }\\nThe utility function swap is defined as follows\\n\\n\\tvoid swap(int& a, int& b){\\n        int tmp = a;\\n        a = b;\\n        b = tmp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2409954,
                "title": "optimal-javascript-solution",
                "content": "```\\nOne Liner\\n```\\n\\n```\\nvar sortArray = function(nums) {\\n    return nums.sort((a, b) => a - b)\\n};\\n```\\n\\n```\\nMerge Sort: Time Complexity - O(N Log N) & Space complexity - O(n)\\n```\\n\\n```\\nvar sortArray = function(nums) {\\n    if(nums.length <= 1) return nums\\n    \\n    let midIdx = Math.floor(nums.length / 2)\\n    let leftArr = sortArray(nums.slice(0, midIdx))\\n    let rightArr = sortArray(nums.slice(midIdx))\\n    \\n    return mergeArr(leftArr, rightArr)\\n};\\n\\nvar mergeArr = function(arr1, arr2) {\\n    let results = []\\n    let i = 0\\n    let j = 0\\n    \\n    while(i <  arr1.length && j < arr2.length){\\n        if(arr2[j] > arr1[i]){\\n            results.push(arr1[i]);\\n            i++;\\n        } else {\\n            results.push(arr2[j])\\n            j++;\\n        }\\n    }\\n    \\n    while(i < arr1.length) {\\n        results.push(arr1[i])\\n        i++;\\n    }\\n    \\n    while(j < arr2.length) {\\n        results.push(arr2[j])\\n        j++;\\n    }\\n    \\n     return results;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nOne Liner\\n```\n```\\nvar sortArray = function(nums) {\\n    return nums.sort((a, b) => a - b)\\n};\\n```\n```\\nMerge Sort: Time Complexity - O(N Log N) & Space complexity - O(n)\\n```\n```\\nvar sortArray = function(nums) {\\n    if(nums.length <= 1) return nums\\n    \\n    let midIdx = Math.floor(nums.length / 2)\\n    let leftArr = sortArray(nums.slice(0, midIdx))\\n    let rightArr = sortArray(nums.slice(midIdx))\\n    \\n    return mergeArr(leftArr, rightArr)\\n};\\n\\nvar mergeArr = function(arr1, arr2) {\\n    let results = []\\n    let i = 0\\n    let j = 0\\n    \\n    while(i <  arr1.length && j < arr2.length){\\n        if(arr2[j] > arr1[i]){\\n            results.push(arr1[i]);\\n            i++;\\n        } else {\\n            results.push(arr2[j])\\n            j++;\\n        }\\n    }\\n    \\n    while(i < arr1.length) {\\n        results.push(arr1[i])\\n        i++;\\n    }\\n    \\n    while(j < arr2.length) {\\n        results.push(arr2[j])\\n        j++;\\n    }\\n    \\n     return results;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2366432,
                "title": "one-line-c-code",
                "content": "```\\nvector<int> sortArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end()); return nums;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nvector<int> sortArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end()); return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2206237,
                "title": "easy-solution-cpp-quick-sort-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int partition(vector<int> &nums, int start, int end) {\\n        //1. take any element\\n        //2. count number of elements lesser than this\\n        //3. swap this element with element at start + count\\n        //4. then run a while loop using two pointers that will sort the elements in both the partitions\\n        \\n        //picking up a random index as pivot to avoid TLE\\n        int ran = rand()%(end-start + 1) + start;\\n        swap(nums[start], nums[ran]);\\n        \\n        int count = 0;\\n        for(int i=start+1;i<=end;i++) {\\n            if(nums[i]<nums[start]) count++;\\n        }\\n        int pivot = start+count;\\n        swap(nums[start], nums[pivot]);\\n        \\n        // cout << \"start: \" << start << \" end: \" << end << \" pivot: \" << pivot << endl;\\n        \\n        while(start<pivot && end>pivot) {\\n            while(nums[start]<nums[pivot]) {\\n                start++;\\n            }\\n            while(nums[end]>=nums[pivot]) {\\n                end--;\\n            } \\n            \\n            if(start<pivot && end>pivot) {\\n                swap(nums[start], nums[end]);\\n                start++;end--;\\n            }\\n        }\\n        return pivot;\\n    }\\n    \\n    void quicksort(vector<int> &nums, int start, int end) {\\n        //base case\\n        //pick a pivot\\n        //sort the remaining left array and right array similarly(recursively)\\n        if(start>=end) return;\\n        int p = partition(nums, start, end);\\n        quicksort(nums, start, p-1);\\n        quicksort(nums, p+1, end);\\n    }\\n    \\n    vector<int> sortArray(vector<int>& nums) {\\n        //quick sort\\n        quicksort(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int partition(vector<int> &nums, int start, int end) {\\n        //1. take any element\\n        //2. count number of elements lesser than this\\n        //3. swap this element with element at start + count\\n        //4. then run a while loop using two pointers that will sort the elements in both the partitions\\n        \\n        //picking up a random index as pivot to avoid TLE\\n        int ran = rand()%(end-start + 1) + start;\\n        swap(nums[start], nums[ran]);\\n        \\n        int count = 0;\\n        for(int i=start+1;i<=end;i++) {\\n            if(nums[i]<nums[start]) count++;\\n        }\\n        int pivot = start+count;\\n        swap(nums[start], nums[pivot]);\\n        \\n        // cout << \"start: \" << start << \" end: \" << end << \" pivot: \" << pivot << endl;\\n        \\n        while(start<pivot && end>pivot) {\\n            while(nums[start]<nums[pivot]) {\\n                start++;\\n            }\\n            while(nums[end]>=nums[pivot]) {\\n                end--;\\n            } \\n            \\n            if(start<pivot && end>pivot) {\\n                swap(nums[start], nums[end]);\\n                start++;end--;\\n            }\\n        }\\n        return pivot;\\n    }\\n    \\n    void quicksort(vector<int> &nums, int start, int end) {\\n        //base case\\n        //pick a pivot\\n        //sort the remaining left array and right array similarly(recursively)\\n        if(start>=end) return;\\n        int p = partition(nums, start, end);\\n        quicksort(nums, start, p-1);\\n        quicksort(nums, p+1, end);\\n    }\\n    \\n    vector<int> sortArray(vector<int>& nums) {\\n        //quick sort\\n        quicksort(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1993428,
                "title": "python-merge-sort-o-nlogn",
                "content": "I can add other sorting algo as well. \\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        \\n        def merge_sort(arr):\\n\\n            if len(arr)<=1:\\n                return arr\\n\\n            start = 0\\n            end = len(arr)\\n            mid = (start+end)//2\\n\\n            left = arr[:mid]\\n            right = arr[mid:]\\n\\n            merge_sort(left)\\n            merge_sort(right)\\n\\n            i = j = k = 0\\n\\n\\n            while i < len(left) and j < len(right):\\n\\n                if left[i] <= right[j]:\\n                    arr[k] = left[i]\\n                    i += 1\\n                else:\\n                    arr[k] = right[j]\\n                    j += 1\\n                k += 1\\n\\n            while i < len(left):\\n                arr[k] = left[i]\\n                i += 1\\n                k += 1\\n\\n            while j < len(right):\\n                arr[k] = right[j]\\n                j += 1\\n                k += 1\\n                \\n        merge_sort(nums)\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        \\n        def merge_sort(arr):\\n\\n            if len(arr)<=1:\\n                return arr\\n\\n            start = 0\\n            end = len(arr)\\n            mid = (start+end)//2\\n\\n            left = arr[:mid]\\n            right = arr[mid:]\\n\\n            merge_sort(left)\\n            merge_sort(right)\\n\\n            i = j = k = 0\\n\\n\\n            while i < len(left) and j < len(right):\\n\\n                if left[i] <= right[j]:\\n                    arr[k] = left[i]\\n                    i += 1\\n                else:\\n                    arr[k] = right[j]\\n                    j += 1\\n                k += 1\\n\\n            while i < len(left):\\n                arr[k] = left[i]\\n                i += 1\\n                k += 1\\n\\n            while j < len(right):\\n                arr[k] = right[j]\\n                j += 1\\n                k += 1\\n                \\n        merge_sort(nums)\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892185,
                "title": "javascript-quicksort-vs-mergesort-solutions-time-complexity-and-explanation",
                "content": "```\\n//Merge Sort (Runtime: O(nlogn))\\nvar sortArray = function(nums) {\\n    if (nums.length < 2) return nums\\n    let mid = Math.floor(nums.length/2)\\n    let left = nums.slice(0, mid)\\n    let right = nums.slice(mid)\\n    return merge(sortArray(left), sortArray(right))\\n};\\n\\nvar merge = (arr1, arr2) => {\\n    let arr = []\\n    while (arr1.length && arr2.length) {\\n        if (arr1[0] <= arr2[0]) arr.push(arr1.shift())\\n        else arr.push(arr2.shift())\\n    }\\n    return [...arr, ...arr1, ...arr2]\\n}\\n```\\n```\\n//Quick sort Runtime: O(n^2) | Memory: O(logn)\\nvar sortArray = function(nums) {\\n    if (nums.length < 2) return nums\\n    quickSort(nums, 0, nums.length-1)\\n    return nums\\n}\\n\\nvar quickSort = (nums, start, end) => {\\n    if (start >= end) return\\n    let left = start, right=end\\n    let pivot = nums[Math.floor((start+end)/2)]\\n    while (left <= right) {\\n        while (nums[left] < pivot) left++\\n        while (nums[right] > pivot) right--\\n        if (left <= right) {\\n            let temp = nums[left]\\n            nums[left] = nums[right]\\n            nums[right] = temp\\n            left++\\n            right--\\n        }\\n    }\\n    quickSort(nums,start,right)\\n    quickSort(nums,left,end)\\n}\\n```\\n- Mergesort is a divide and conquer algorithm (recursive). It divides the array in half, sorts each then merges them together. The divide step doesn\\'t do anything; it\\'s the merge part that does all the work. In merge sort, you never see a subarray with no elements.\\n- Quicksort is also a divide and conquer algorithm. The combine step doesn\\'t do much; it\\'s the divide step that does all the heavy lifting.\\nAlthough we can choose any element in the subarray as the pivot, it\\'s easy to implement partitioning if we choose the rightmost element of the subarray. Unlike in mergesort where you never see a subarray with no element, you can in quicksort.\\n<b>!! Note: In practice, quicksort outperforms merge sort, and it significantly outperforms selection sort and insertion sort.</b>\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\n//Merge Sort (Runtime: O(nlogn))\\nvar sortArray = function(nums) {\\n    if (nums.length < 2) return nums\\n    let mid = Math.floor(nums.length/2)\\n    let left = nums.slice(0, mid)\\n    let right = nums.slice(mid)\\n    return merge(sortArray(left), sortArray(right))\\n};\\n\\nvar merge = (arr1, arr2) => {\\n    let arr = []\\n    while (arr1.length && arr2.length) {\\n        if (arr1[0] <= arr2[0]) arr.push(arr1.shift())\\n        else arr.push(arr2.shift())\\n    }\\n    return [...arr, ...arr1, ...arr2]\\n}\\n```\n```\\n//Quick sort Runtime: O(n^2) | Memory: O(logn)\\nvar sortArray = function(nums) {\\n    if (nums.length < 2) return nums\\n    quickSort(nums, 0, nums.length-1)\\n    return nums\\n}\\n\\nvar quickSort = (nums, start, end) => {\\n    if (start >= end) return\\n    let left = start, right=end\\n    let pivot = nums[Math.floor((start+end)/2)]\\n    while (left <= right) {\\n        while (nums[left] < pivot) left++\\n        while (nums[right] > pivot) right--\\n        if (left <= right) {\\n            let temp = nums[left]\\n            nums[left] = nums[right]\\n            nums[right] = temp\\n            left++\\n            right--\\n        }\\n    }\\n    quickSort(nums,start,right)\\n    quickSort(nums,left,end)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1767073,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n\\t    //sorting with help of Priority Queue\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        nums.clear();\\n        int t=pq.size();\\n        while(t--)\\n        {\\n            int x=pq.top();\\n            nums.push_back(x);\\n            pq.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n\\t    //sorting with help of Priority Queue\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        nums.clear();\\n        int t=pq.size();\\n        while(t--)\\n        {\\n            int x=pq.top();\\n            nums.push_back(x);\\n            pq.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747976,
                "title": "heap-sort",
                "content": "```\\n public int[] SortArray(int[] nums)\\n        {\\n            if (nums.Length == 1) return nums;\\n            heapSort(nums);\\n            return nums;\\n        }\\n public void HeapSort(int[] nums)\\n        {\\n\\t\\t//here we are taking i=nums.Length/2-1 because when you plot the array element into heap \\n\\t\\t//structure then you might notice that all leaf node at lowest level are equal to all parent node in \\n\\t\\t//tree and to heapify our heap into max heap we need to start it will last parent \\n\\t\\t//which we will get by doing num.Length/2-1 \\n            for (var i = nums.Length / 2 - 1; i >= 0; i--)\\n            {\\n\\t\\t\\t//we passing arr , start ndex and end index because we will use same Method for sorting our max Heap into ascending order\\n                Heapify(nums, i, nums.Length - 1);\\n            }\\n            for (var i = nums.Length - 1; i >= 0; i--)\\n            {\\n\\t\\t\\t//here we swap first element(max) in array with last element(min) and \\n\\t\\t\\t//than we call heapify starting node 0 to i-1(by doing this we will get \\n\\t\\t\\t//max elment in our last index of array then we call heapify \\n\\t\\t\\t//to rearrange tree into max heap again and we do same again)\\n                swap(nums, 0, i);\\n                Heapify(nums, 0, i - 1);\\n            }\\n\\n        }\\n\\n\\n        public void Heapify(int[] nums, int i, int end)\\n        {\\n            while (i <= end)\\n            {\\n                int l = 2 * i + 1; //left node of parent i\\n                int r = 2 * i + 2;//right node of parent i\\n                int maxIndex = i;\\n                if (l <= end && nums[l] > nums[maxIndex]) //if left node exist and left node is larger than maxIndex\\n                {\\n                    maxIndex = l; //assign max\\n                }\\n                if (r <= end && nums[r] > nums[maxIndex])//if right node exist and left node is larger than maxIndex\\n                {\\n                    maxIndex = r;\\n                }\\n                if (maxIndex == i) break;  //if left and right both node are smaller than parent no need to heapify its already max heap  so break\\n                swap(nums, i, maxIndex); \\n                i = maxIndex; //assign i to left or right node index whichever was greater than other\\n            }\\n        }\\n\\t\\t//method that swaps elements in array\\n        void swap(int[] nums, int i1, int i2)\\n        {\\n            var tmp = nums[i1]; nums[i1] = nums[i2]; nums[i2] = tmp;\\n        }\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n public int[] SortArray(int[] nums)\\n        {\\n            if (nums.Length == 1) return nums;\\n            heapSort(nums);\\n            return nums;\\n        }\\n public void HeapSort(int[] nums)\\n        {\\n\\t\\t//here we are taking i=nums.Length/2-1 because when you plot the array element into heap \\n\\t\\t//structure then you might notice that all leaf node at lowest level are equal to all parent node in \\n\\t\\t//tree and to heapify our heap into max heap we need to start it will last parent \\n\\t\\t//which we will get by doing num.Length/2-1 \\n            for (var i = nums.Length / 2 - 1; i >= 0; i--)\\n            {\\n\\t\\t\\t//we passing arr , start ndex and end index because we will use same Method for sorting our max Heap into ascending order\\n                Heapify(nums, i, nums.Length - 1);\\n            }\\n            for (var i = nums.Length - 1; i >= 0; i--)\\n            {\\n\\t\\t\\t//here we swap first element(max) in array with last element(min) and \\n\\t\\t\\t//than we call heapify starting node 0 to i-1(by doing this we will get \\n\\t\\t\\t//max elment in our last index of array then we call heapify \\n\\t\\t\\t//to rearrange tree into max heap again and we do same again)\\n                swap(nums, 0, i);\\n                Heapify(nums, 0, i - 1);\\n            }\\n\\n        }\\n\\n\\n        public void Heapify(int[] nums, int i, int end)\\n        {\\n            while (i <= end)\\n            {\\n                int l = 2 * i + 1; //left node of parent i\\n                int r = 2 * i + 2;//right node of parent i\\n                int maxIndex = i;\\n                if (l <= end && nums[l] > nums[maxIndex]) //if left node exist and left node is larger than maxIndex\\n                {\\n                    maxIndex = l; //assign max\\n                }\\n                if (r <= end && nums[r] > nums[maxIndex])//if right node exist and left node is larger than maxIndex\\n                {\\n                    maxIndex = r;\\n                }\\n                if (maxIndex == i) break;  //if left and right both node are smaller than parent no need to heapify its already max heap  so break\\n                swap(nums, i, maxIndex); \\n                i = maxIndex; //assign i to left or right node index whichever was greater than other\\n            }\\n        }\\n\\t\\t//method that swaps elements in array\\n        void swap(int[] nums, int i1, int i2)\\n        {\\n            var tmp = nums[i1]; nums[i1] = nums[i2]; nums[i2] = tmp;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677667,
                "title": "python-merge-sort",
                "content": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        if len(nums)>1:\\n            mid=len(nums)//2\\n            l=nums[:mid]\\n            r=nums[mid:]\\n            self.sortArray(l)\\n            self.sortArray(r)\\n            i=j=k=0\\n            while i<len(l) and j<len(r):\\n                if l[i]<r[j]:\\n                    nums[k]=l[i]\\n                    i+=1\\n                else:\\n                    nums[k]=r[j]\\n                    j+=1\\n                k+=1\\n            while i<len(l):\\n                nums[k]=l[i]\\n                i+=1\\n                k+=1\\n            while j<len(r):\\n                nums[k]=r[j]\\n                j+=1\\n                k+=1\\n        return nums\\n        # nums.sort()\\n        # return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        if len(nums)>1:\\n            mid=len(nums)//2\\n            l=nums[:mid]\\n            r=nums[mid:]\\n            self.sortArray(l)\\n            self.sortArray(r)\\n            i=j=k=0\\n            while i<len(l) and j<len(r):\\n                if l[i]<r[j]:\\n                    nums[k]=l[i]\\n                    i+=1\\n                else:\\n                    nums[k]=r[j]\\n                    j+=1\\n                k+=1\\n            while i<len(l):\\n                nums[k]=l[i]\\n                i+=1\\n                k+=1\\n            while j<len(r):\\n                nums[k]=r[j]\\n                j+=1\\n                k+=1\\n        return nums\\n        # nums.sort()\\n        # return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621914,
                "title": "python-quicksort-merge-sort-counting-sort",
                "content": "Quicksort\\nTime complexity: O(n log n) average case, O(n^2) worst case\\nSpace complexity: O(log n) due to stack space needed for recursive calls, array is sorted in place\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        def quicksort(arr, left, right):\\n            if left >= right:\\n                return\\n            pivot = partition(arr, left, right)\\n            quicksort(arr, left, pivot-1)\\n            quicksort(arr, pivot+1, right)\\n            return\\n        \\n        def partition(arr, left, right):\\n\\t\\t\\t# using arr[right] as the pivot\\n            rand_index = random.randint(left,right) # select a random index between left and right\\n            arr[rand_index], arr[right] = arr[right], arr[rand_index] # swap rightmost value with randomly selected index\\n\\t\\t\\t# randomizing the pivot value gives significantly better average case performance\\n            new_pivot = left # this will be our value that we return\\n\\t\\t\\t# we partition the array such that all values greater than arr[new_pivot] are to the right of index new_pivot\\n\\t\\t\\t# and all values less than arr[new_pivot] are to the left, then we recursively will partition those sub arrays\\n            for index in range(left,right):\\n                if arr[index] <= arr[right]:\\n                    arr[new_pivot], arr[index] = arr[index], arr[new_pivot]\\n                    new_pivot += 1\\n            arr[right], arr[new_pivot] = arr[new_pivot], arr[right] # swap old pivot value with the new\\n            return new_pivot\\n        \\n        quicksort(nums, 0, len(nums)-1)\\n        return nums\\n```\\nMerge Sort\\nTime complexity: O(n log n)\\nSpace complexity: O(n)\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        def merge(left, right):\\n\\t\\t\\t# left and right are two sorted arrays\\n\\t\\t\\t# the aim is to merge them into a single sorted array\\n\\t\\t\\t# ex: left=[1,2,3], right=[0,3,4], merged=[0,1,2,3,3,4]\\n            merged = []\\n            l_ptr, r_ptr = 0, 0\\n            \\n            while l_ptr < len(left) and r_ptr < len(right):\\n                if left[l_ptr] < right[r_ptr]:\\n                    merged.append(left[l_ptr])\\n                    l_ptr += 1\\n                else:\\n                    merged.append(right[r_ptr])\\n                    r_ptr += 1\\n            \\n            if l_ptr < len(left):\\n                merged += left[l_ptr:]\\n            if r_ptr < len(right):\\n                merged += right[r_ptr:]\\n                \\n            return merged\\n        \\n        def merge_sort(arr):\\n            if len(arr) <= 1:\\n                return arr\\n            mid = len(arr) // 2\\n            left = merge_sort(arr[mid:])\\n            right = merge_sort(arr[:mid])\\n            return merge(left,right)\\n        \\n        return merge_sort(nums)\\n```\\nCounting Sort\\nTime complexity: O(n+k)\\nSpace complexity: O(n+k)\\nwhere n is the number of elements and k is the range of values\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        counts = [0] * ((10* 10**4)+1)\\n        offset = 5 * 10**4\\n        \\n        # num can be between -5 * 10**4 and +5 * 10**4\\n        \\n        for num in nums:\\n            counts[num+offset] += 1\\n            \\n        result = []\\n        for index in range(len(counts)):\\n            if counts[index] != 0:\\n                for _ in range(counts[index]):\\n                    result.append(index-offset)\\n                    \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Merge Sort",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        def quicksort(arr, left, right):\\n            if left >= right:\\n                return\\n            pivot = partition(arr, left, right)\\n            quicksort(arr, left, pivot-1)\\n            quicksort(arr, pivot+1, right)\\n            return\\n        \\n        def partition(arr, left, right):\\n\\t\\t\\t# using arr[right] as the pivot\\n            rand_index = random.randint(left,right) # select a random index between left and right\\n            arr[rand_index], arr[right] = arr[right], arr[rand_index] # swap rightmost value with randomly selected index\\n\\t\\t\\t# randomizing the pivot value gives significantly better average case performance\\n            new_pivot = left # this will be our value that we return\\n\\t\\t\\t# we partition the array such that all values greater than arr[new_pivot] are to the right of index new_pivot\\n\\t\\t\\t# and all values less than arr[new_pivot] are to the left, then we recursively will partition those sub arrays\\n            for index in range(left,right):\\n                if arr[index] <= arr[right]:\\n                    arr[new_pivot], arr[index] = arr[index], arr[new_pivot]\\n                    new_pivot += 1\\n            arr[right], arr[new_pivot] = arr[new_pivot], arr[right] # swap old pivot value with the new\\n            return new_pivot\\n        \\n        quicksort(nums, 0, len(nums)-1)\\n        return nums\\n```\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        def merge(left, right):\\n\\t\\t\\t# left and right are two sorted arrays\\n\\t\\t\\t# the aim is to merge them into a single sorted array\\n\\t\\t\\t# ex: left=[1,2,3], right=[0,3,4], merged=[0,1,2,3,3,4]\\n            merged = []\\n            l_ptr, r_ptr = 0, 0\\n            \\n            while l_ptr < len(left) and r_ptr < len(right):\\n                if left[l_ptr] < right[r_ptr]:\\n                    merged.append(left[l_ptr])\\n                    l_ptr += 1\\n                else:\\n                    merged.append(right[r_ptr])\\n                    r_ptr += 1\\n            \\n            if l_ptr < len(left):\\n                merged += left[l_ptr:]\\n            if r_ptr < len(right):\\n                merged += right[r_ptr:]\\n                \\n            return merged\\n        \\n        def merge_sort(arr):\\n            if len(arr) <= 1:\\n                return arr\\n            mid = len(arr) // 2\\n            left = merge_sort(arr[mid:])\\n            right = merge_sort(arr[:mid])\\n            return merge(left,right)\\n        \\n        return merge_sort(nums)\\n```\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        counts = [0] * ((10* 10**4)+1)\\n        offset = 5 * 10**4\\n        \\n        # num can be between -5 * 10**4 and +5 * 10**4\\n        \\n        for num in nums:\\n            counts[num+offset] += 1\\n            \\n        result = []\\n        for index in range(len(counts)):\\n            if counts[index] != 0:\\n                for _ in range(counts[index]):\\n                    result.append(index-offset)\\n                    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619954,
                "title": "swift-merge-sort",
                "content": "```\\nfunc sortArray(_ num: [Int]) -> [Int] {\\n    if num.count == 1{\\n        return num\\n    }\\n    let midPoint = Int (num.count / 2)\\n    let leftList = sortArray(Array(num[0..<midPoint]))\\n    let rightList = sortArray(Array(num[midPoint..<num.count]))\\n   return mergeList(leftList: leftList, rightList: rightList)\\n}\\n\\n\\nfunc mergeList(leftList: [Int], rightList: [Int]) -> [Int] {\\n    var finalArray = [Int]()\\n    var leftList = leftList\\n    var rightList = rightList\\n    while !leftList.isEmpty && !rightList.isEmpty {\\n        if leftList.first! < rightList.first! {\\n            finalArray.append(leftList.removeFirst())\\n        } else {\\n            finalArray.append(rightList.removeFirst())\\n        }\\n    }\\n\\n    if !leftList.isEmpty {\\n        finalArray.append(contentsOf: leftList)\\n    }\\n    if !rightList.isEmpty {\\n        finalArray.append(contentsOf: rightList)\\n    }\\n    return finalArray\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc sortArray(_ num: [Int]) -> [Int] {\\n    if num.count == 1{\\n        return num\\n    }\\n    let midPoint = Int (num.count / 2)\\n    let leftList = sortArray(Array(num[0..<midPoint]))\\n    let rightList = sortArray(Array(num[midPoint..<num.count]))\\n   return mergeList(leftList: leftList, rightList: rightList)\\n}\\n\\n\\nfunc mergeList(leftList: [Int], rightList: [Int]) -> [Int] {\\n    var finalArray = [Int]()\\n    var leftList = leftList\\n    var rightList = rightList\\n    while !leftList.isEmpty && !rightList.isEmpty {\\n        if leftList.first! < rightList.first! {\\n            finalArray.append(leftList.removeFirst())\\n        } else {\\n            finalArray.append(rightList.removeFirst())\\n        }\\n    }\\n\\n    if !leftList.isEmpty {\\n        finalArray.append(contentsOf: leftList)\\n    }\\n    if !rightList.isEmpty {\\n        finalArray.append(contentsOf: rightList)\\n    }\\n    return finalArray\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589476,
                "title": "all-sorting-algs-in-rust-heap-sort-merge-sort-shell-bubble-sort",
                "content": "```\\n//  Heap Sort \\n//  Min heap \\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\nimpl Solution {\\n    pub fn sort_array(nums: Vec<i32>) -> Vec<i32> {\\n        let l = nums.len();\\n        let mut minheap = BinaryHeap::with_capacity(l as usize);\\n        nums.into_iter().for_each(|i| minheap.push(Reverse(i)));\\n        let mut res = Vec::new();\\n        while let Some(Reverse(max)) = minheap.pop() { \\n            res.push(max);\\n            if res.len() == l { \\n                break\\n            }\\n        }\\n        res\\n    }\\n}\\n\\n//  Max heap \\nuse std::collections::BinaryHeap;\\nimpl Solution {\\n    pub fn sort_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut maxheap = BinaryHeap::from(nums);\\n        maxheap.into_sorted_vec()\\n    }\\n}\\n\\n//  Bubble Sort \\n//  Time Limit Exceeded\\nimpl Solution {\\n    pub fn sort_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut res: Vec<i32> = nums.into();\\n        \\n        for _ in 0..res.len() { \\n            let mut swaps = 0;\\n            for i in 1..res.len() { \\n                if res[i-1] > res[i] { \\n                    res.swap(i -1, i);\\n                    swaps +=1;\\n                }\\n            }\\n            if swaps == 0 { \\n                break;\\n            }\\n        }\\n        res\\n    }\\n}\\n// Shell Sort \\nimpl Solution {\\n    pub fn sort_array(nums: Vec<i32>) -> Vec<i32> {\\n        let l = nums.len();\\n        let mut gap = l/2;\\n        let mut res: Vec<i32> = nums.into();\\n        \\n        while gap > 0 { \\n            for i in gap..l { \\n                let tmp = res[i].clone();\\n                let mut j = i;\\n                while j >= gap && res[j - gap] > tmp { \\n                    res[j] = res[j - gap].clone();\\n                    j -= gap;\\n                }\\n                res[j] = tmp;\\n            }\\n            gap /= 2;\\n        }\\n        res\\n    }\\n}\\n\\n//  Sort unstable\\nimpl Solution {\\n    pub fn sort_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n        nums\\n    }\\n}\\n\\n// Merge Sort \\nimpl Solution {\\n    pub fn sort_array(nums: Vec<i32>) -> Vec<i32> {\\n        if nums.len() > 1 { \\n            let (l, r) = nums.split_at(nums.len() /2);\\n            let sorted_r = Self::sort_array(r.to_vec());\\n            let sorted_l = Self::sort_array(l.to_vec());\\n            \\n            let mut res: Vec<i32> = nums.into();\\n            let (mut i, mut j) = (0, 0);\\n            \\n            let mut k = 0;\\n            while i < sorted_l.len() && j < sorted_r.len() { \\n                \\n                if sorted_l[i] <= sorted_r[j] { \\n                    res[k] = sorted_l[i].clone();\\n                    i += 1;\\n                } else { \\n                    res[k] = sorted_r[j].clone();\\n                    j += 1;\\n                }\\n                k += 1;\\n            }\\n            while i < sorted_l.len() { \\n                res[k] = sorted_l[i].clone();\\n                k +=1;\\n                i +=1;\\n            }\\n            while j < sorted_r.len() { \\n                res[k] = sorted_r[j].clone();\\n                k +=1;\\n                j +=1;\\n            }\\n            res\\n        } else { \\n            nums.to_vec()\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n//  Heap Sort \\n//  Min heap \\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\nimpl Solution {\\n    pub fn sort_array(nums: Vec<i32>) -> Vec<i32> {\\n        let l = nums.len();\\n        let mut minheap = BinaryHeap::with_capacity(l as usize);\\n        nums.into_iter().for_each(|i| minheap.push(Reverse(i)));\\n        let mut res = Vec::new();\\n        while let Some(Reverse(max)) = minheap.pop() { \\n            res.push(max);\\n            if res.len() == l { \\n                break\\n            }\\n        }\\n        res\\n    }\\n}\\n\\n//  Max heap \\nuse std::collections::BinaryHeap;\\nimpl Solution {\\n    pub fn sort_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut maxheap = BinaryHeap::from(nums);\\n        maxheap.into_sorted_vec()\\n    }\\n}\\n\\n//  Bubble Sort \\n//  Time Limit Exceeded\\nimpl Solution {\\n    pub fn sort_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut res: Vec<i32> = nums.into();\\n        \\n        for _ in 0..res.len() { \\n            let mut swaps = 0;\\n            for i in 1..res.len() { \\n                if res[i-1] > res[i] { \\n                    res.swap(i -1, i);\\n                    swaps +=1;\\n                }\\n            }\\n            if swaps == 0 { \\n                break;\\n            }\\n        }\\n        res\\n    }\\n}\\n// Shell Sort \\nimpl Solution {\\n    pub fn sort_array(nums: Vec<i32>) -> Vec<i32> {\\n        let l = nums.len();\\n        let mut gap = l/2;\\n        let mut res: Vec<i32> = nums.into();\\n        \\n        while gap > 0 { \\n            for i in gap..l { \\n                let tmp = res[i].clone();\\n                let mut j = i;\\n                while j >= gap && res[j - gap] > tmp { \\n                    res[j] = res[j - gap].clone();\\n                    j -= gap;\\n                }\\n                res[j] = tmp;\\n            }\\n            gap /= 2;\\n        }\\n        res\\n    }\\n}\\n\\n//  Sort unstable\\nimpl Solution {\\n    pub fn sort_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n        nums\\n    }\\n}\\n\\n// Merge Sort \\nimpl Solution {\\n    pub fn sort_array(nums: Vec<i32>) -> Vec<i32> {\\n        if nums.len() > 1 { \\n            let (l, r) = nums.split_at(nums.len() /2);\\n            let sorted_r = Self::sort_array(r.to_vec());\\n            let sorted_l = Self::sort_array(l.to_vec());\\n            \\n            let mut res: Vec<i32> = nums.into();\\n            let (mut i, mut j) = (0, 0);\\n            \\n            let mut k = 0;\\n            while i < sorted_l.len() && j < sorted_r.len() { \\n                \\n                if sorted_l[i] <= sorted_r[j] { \\n                    res[k] = sorted_l[i].clone();\\n                    i += 1;\\n                } else { \\n                    res[k] = sorted_r[j].clone();\\n                    j += 1;\\n                }\\n                k += 1;\\n            }\\n            while i < sorted_l.len() { \\n                res[k] = sorted_l[i].clone();\\n                k +=1;\\n                i +=1;\\n            }\\n            while j < sorted_r.len() { \\n                res[k] = sorted_r[j].clone();\\n                k +=1;\\n                j +=1;\\n            }\\n            res\\n        } else { \\n            nums.to_vec()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538541,
                "title": "java-using-quick-sort-with-middle-element-is-pivot",
                "content": "Document reference: https://www.algolist.net/Algorithms/Sorting/Quicksort\\n```\\n\\tpublic int[] sortArray(int[] nums) {\\n        quickSortWithRecursion(0, nums.length - 1, nums);\\n        \\n        return nums;\\n    }\\n    \\n    public void quickSortWithRecursion(int low, int high, int[] work) {\\n        if (low >= high) return;\\n\\n        int left = low, right = high;\\n        int pivot = work[(low + high) / 2];\\n\\n        while (left <= right) {\\n            while (work[left] < pivot) left++;\\n            while (work[right] > pivot) right--;\\n            if (left > right) break;\\n\\n            swap(left, right, work);\\n            left++;\\n            right--;\\n        }\\n\\n        quickSortWithRecursion(low, right, work);\\n        quickSortWithRecursion(left, high, work);\\n    }\\n    \\n    public void swap(int i, int j, int[] array) {\\n        int temp = array[i];\\n        array[i] = array[j];\\n        array[j] = temp;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[] sortArray(int[] nums) {\\n        quickSortWithRecursion(0, nums.length - 1, nums);\\n        \\n        return nums;\\n    }\\n    \\n    public void quickSortWithRecursion(int low, int high, int[] work) {\\n        if (low >= high) return;\\n\\n        int left = low, right = high;\\n        int pivot = work[(low + high) / 2];\\n\\n        while (left <= right) {\\n            while (work[left] < pivot) left++;\\n            while (work[right] > pivot) right--;\\n            if (left > right) break;\\n\\n            swap(left, right, work);\\n            left++;\\n            right--;\\n        }\\n\\n        quickSortWithRecursion(low, right, work);\\n        quickSortWithRecursion(left, high, work);\\n    }\\n    \\n    public void swap(int i, int j, int[] array) {\\n        int temp = array[i];\\n        array[i] = array[j];\\n        array[j] = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1532587,
                "title": "merge-sort-solution",
                "content": "### **Merge Sort Approach**\\n\\n```\\n\\nvar sortArray = function(arr) {\\n    let n=arr.length;\\n    mergeSort(arr,0,n-1);\\n    \\n    function mergeSort(arr,l,r){\\n        if(l<r){\\n            let mid=Math.floor((l+r)/2);\\n            mergeSort(arr,l,mid);\\n            mergeSort(arr,mid+1,r);\\n            \\n            merge(arr,l,mid,r);\\n        }\\n    }\\n    function merge(arr,l,mid,r){\\n        let n1=mid-l+1;\\n        let n2=r-mid;\\n        \\n        let a1=new Array(n1);\\n        let a2=new Array(n2);\\n        \\n        for(let i=0;i<n1;i++){\\n            a1[i]=arr[l+i]\\n        }\\n        for(let i=0;i<n1;i++){\\n            a2[i]=arr[mid+1+i]\\n        }\\n        let i=0; let j=0;\\n        let k=l;\\n        while(i<n1 && j<n2){\\n            if(a1[i]<a2[j]){\\n                arr[k]=a1[i];\\n                k++;\\n                i++;\\n            }else{\\n                arr[k]=a2[j];\\n                k++;\\n                j++;\\n            }\\n        }\\n        \\n        while(i<n1){\\n            arr[k]=a1[i];\\n            k++; i++\\n        }\\n        while(i<n1){\\n            arr[k]=a1[i];\\n            k++; i++\\n        }\\n    }\\n    return arr\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Merge Sort"
                ],
                "code": "```\\n\\nvar sortArray = function(arr) {\\n    let n=arr.length;\\n    mergeSort(arr,0,n-1);\\n    \\n    function mergeSort(arr,l,r){\\n        if(l<r){\\n            let mid=Math.floor((l+r)/2);\\n            mergeSort(arr,l,mid);\\n            mergeSort(arr,mid+1,r);\\n            \\n            merge(arr,l,mid,r);\\n        }\\n    }\\n    function merge(arr,l,mid,r){\\n        let n1=mid-l+1;\\n        let n2=r-mid;\\n        \\n        let a1=new Array(n1);\\n        let a2=new Array(n2);\\n        \\n        for(let i=0;i<n1;i++){\\n            a1[i]=arr[l+i]\\n        }\\n        for(let i=0;i<n1;i++){\\n            a2[i]=arr[mid+1+i]\\n        }\\n        let i=0; let j=0;\\n        let k=l;\\n        while(i<n1 && j<n2){\\n            if(a1[i]<a2[j]){\\n                arr[k]=a1[i];\\n                k++;\\n                i++;\\n            }else{\\n                arr[k]=a2[j];\\n                k++;\\n                j++;\\n            }\\n        }\\n        \\n        while(i<n1){\\n            arr[k]=a1[i];\\n            k++; i++\\n        }\\n        while(i<n1){\\n            arr[k]=a1[i];\\n            k++; i++\\n        }\\n    }\\n    return arr\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 905905,
                "title": "python3-shell-sort",
                "content": "O(n^1.5)\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        #shell\\n        sub = len(nums) // 2\\n        while sub > 0:\\n            for start in range(sub):\\n                self.shell(nums, start, sub)\\n            sub = sub // 2\\n        return nums\\n    \\n    def shell(self, alist, start, gap):\\n        for i in range(start+gap, len(alist), gap):\\n            current = alist[i]\\n            position = i\\n            while position >= gap and alist[position-gap] > current:\\n                alist[position] = alist[position-gap]\\n                position -= gap\\n            alist[position] = current\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        #shell\\n        sub = len(nums) // 2\\n        while sub > 0:\\n            for start in range(sub):\\n                self.shell(nums, start, sub)\\n            sub = sub // 2\\n        return nums\\n    \\n    def shell(self, alist, start, gap):\\n        for i in range(start+gap, len(alist), gap):\\n            current = alist[i]\\n            position = i\\n            while position >= gap and alist[position-gap] > current:\\n                alist[position] = alist[position-gap]\\n                position -= gap\\n            alist[position] = current\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862176,
                "title": "java-beat-99-8-time-2ms-91-memory-o-n-time",
                "content": "// O(n) time using counting sort\\n```\\npublic int[] sortArray(int[] nums) {\\n\\t//-50000 <= nums[i] <= 50000\\n\\t// you can even use a smaller array if you know min and max values\\n\\tint[] buckets = new int[100_001]; \\n\\tfor (int c: nums) {\\n\\t\\tbuckets[c + 50_001]++;\\n\\t}\\n\\t// use new array\\n\\tint[] res = new int[nums.length];\\n\\tint i = 0;\\n\\tfor (int j = 0; j < buckets.length; j++) {\\n\\t\\twhile (buckets[j] > 0) {\\n\\t\\t\\tres[i++] = j - 50_001;\\n\\t\\t\\tbuckets[j]--;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting Sort"
                ],
                "code": "```\\npublic int[] sortArray(int[] nums) {\\n\\t//-50000 <= nums[i] <= 50000\\n\\t// you can even use a smaller array if you know min and max values\\n\\tint[] buckets = new int[100_001]; \\n\\tfor (int c: nums) {\\n\\t\\tbuckets[c + 50_001]++;\\n\\t}\\n\\t// use new array\\n\\tint[] res = new int[nums.length];\\n\\tint i = 0;\\n\\tfor (int j = 0; j < buckets.length; j++) {\\n\\t\\twhile (buckets[j] > 0) {\\n\\t\\t\\tres[i++] = j - 50_001;\\n\\t\\t\\tbuckets[j]--;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764169,
                "title": "java-merge-sort-shortest-solution-in-terms-of-lines-of-code",
                "content": "```\\n/**\\n* Classic merge-sort chosen because divide-and-conquer leaves room for light technical banter in the interview.\\n**/\\nclass Solution {\\n    \\n    public int[] sortArray(int[] nums) {\\n        if(nums.length <= 1) return nums;\\n        int midpoint = nums.length/2;\\n        int[] left = new int[midpoint], right = nums.length%2 == 0 ? new int[midpoint] : new int[midpoint+1];\\n        for(int index=0; index<left.length; index++) left[index] = nums[index]; //fill left\\n        for(int index=0; index<right.length; index++) right[index] = nums[index+midpoint]; //fill right\\n        //Divide - keeps recursing until each \"array\" is only one element in length. \\n        left = sortArray(left); right = sortArray(right);\\n        //Conquer - merge the independent arrays and sort!\\n        return sortArray(left, right);\\n    }\\n    \\n    /**\\n    * The \"conquer\" portion of merge-sort uses what I like to call a two-and-a-half pointer solution.\\n    * This is a standard 2-ptr solution, with a 3rd pointer filling in the result array.\\n    **/\\n    private int[] sortArray(int[] left, int[] right){\\n        int[] res = new int[left.length + right.length];    //\"res\" == shorthand for result\\n        int lp=0, rp=0, resp=0; //lp = leftPointer, rp = rightPointer, resp = resultPointer\\n        while(lp < left.length || rp < right.length){  // While there\\'s still elements in both left and right...\\n            if(lp < left.length && rp < right.length){  // If there\\'s still elements in both l & r, choose the smaller number.\\n                if(left[lp] < right[rp]) res[resp++] = left[lp++]; // Post-increment increments the respective ptr AFTER execution\\n                else res[resp++] = right[rp++];\\n            } else if(lp < left.length) res[resp++] = left[lp++];   // else if there\\'s only elements in left, choose left\\n            else res[resp++] = right[rp++];     // else there\\'s only elements left in right, choose right\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\n/**\\n* Classic merge-sort chosen because divide-and-conquer leaves room for light technical banter in the interview.\\n**/\\nclass Solution {\\n    \\n    public int[] sortArray(int[] nums) {\\n        if(nums.length <= 1) return nums;\\n        int midpoint = nums.length/2;\\n        int[] left = new int[midpoint], right = nums.length%2 == 0 ? new int[midpoint] : new int[midpoint+1];\\n        for(int index=0; index<left.length; index++) left[index] = nums[index]; //fill left\\n        for(int index=0; index<right.length; index++) right[index] = nums[index+midpoint]; //fill right\\n        //Divide - keeps recursing until each \"array\" is only one element in length. \\n        left = sortArray(left); right = sortArray(right);\\n        //Conquer - merge the independent arrays and sort!\\n        return sortArray(left, right);\\n    }\\n    \\n    /**\\n    * The \"conquer\" portion of merge-sort uses what I like to call a two-and-a-half pointer solution.\\n    * This is a standard 2-ptr solution, with a 3rd pointer filling in the result array.\\n    **/\\n    private int[] sortArray(int[] left, int[] right){\\n        int[] res = new int[left.length + right.length];    //\"res\" == shorthand for result\\n        int lp=0, rp=0, resp=0; //lp = leftPointer, rp = rightPointer, resp = resultPointer\\n        while(lp < left.length || rp < right.length){  // While there\\'s still elements in both left and right...\\n            if(lp < left.length && rp < right.length){  // If there\\'s still elements in both l & r, choose the smaller number.\\n                if(left[lp] < right[rp]) res[resp++] = left[lp++]; // Post-increment increments the respective ptr AFTER execution\\n                else res[resp++] = right[rp++];\\n            } else if(lp < left.length) res[resp++] = left[lp++];   // else if there\\'s only elements in left, choose left\\n            else res[resp++] = right[rp++];     // else there\\'s only elements left in right, choose right\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627497,
                "title": "java-selection-bubble-insertion-heap-merge-quick-counting",
                "content": "```\\n /**\\n     *\\n     * Selection Sort\\n     * Brute Force or Decrease and Conquer\\n     *\\n     * Select min for each index by scanning through rest of the array\\n     *\\n     * Time  : O(N^2)\\n     * Space : O(1)\\n     *\\n     * Inplace, Stable\\n     * @param nums\\n     */\\n    public int[] sort(int[] nums) {\\n\\n        for(int i=0;i<nums.length;++i) {\\n            for(int j=i+1;j<nums.length;++j) {\\n                if(nums[j]<nums[i]) {\\n                    int temp=nums[i];\\n                    nums[i]=nums[j];\\n                    nums[j]=temp;\\n                }\\n            }\\n        }\\n\\n        return nums;\\n    }\\n\\t\\n\\t/**\\n     *\\n     *  Bubble Sort\\n     * Brute force sorting algorithm, similar to\\n     *\\n     * Time: O(n^2)\\n     * Space: O(1)\\n     *\\n     * series of scan on each iteration:\\n     * s=n-1+n-2+n-3 .... +1\\n     * reverse\\n     * 2s=1+2+3...+n-2+n-1\\n     *\\n     * 2s=n+n+..+n\\n     * 2s=n(n-1)\\n     * s=(n(n-1))/2\\n     * s=n^2\\n     *\\n     *\\n     *\\n     *\\n     * Inplace\\n     * Stable\\n     *\\n     * @param nums\\n     * @return\\n     */\\n\\n\\n    public int[] sort(int[] nums) {\\n\\n        for(int i=0;i<nums.length;++i) {\\n            for (int j = nums.length - 1; j > i; --j) {\\n                if(nums[j]<nums[j-1]) {\\n                    int temp=nums[j-1];\\n                    nums[j-1]=nums[j];\\n                    nums[j]=temp;\\n                }\\n            }\\n        }\\n\\n        return nums;\\n    }\\n\\t\\n\\t/**\\n     * \\n     * Insertion Sort\\n     * Decrease and conquer algorithm\\n     *\\n     * Think that n-1 problem is already sorted and insert the new element into it.\\n     *\\n     * (n-1) to n\\n     *\\n     * Time: O(n^2)\\n     * Space: O(1)\\n     *\\n     * This might be better than the previous algorithms in base case time of O(n)\\n     *\\n     * @return\\n     */\\n\\n    public int[] sort(int[] nums) {\\n        helper(nums, nums.length-1);\\n        return nums;\\n    }\\n\\n    private void helper(int[] nums, int n) {\\n        if(n<=0)\\n            return;\\n\\n        helper(nums, n-1);\\n\\n        // extend the  from n-1 solution\\n        int nth=nums[n];\\n        int j=n-1;\\n\\n        while(j>=0 && nums[j]>nth) {\\n            nums[j+1]=nums[j];\\n            --j;\\n        }\\n\\n        nums[j+1]=nth;\\n    }\\n\\t\\n\\t/**\\n     * Heap Sort- using array\\n     * \\n     *  root contains the max/min.\\n     *  \\n     *  operations\\n     *  add - add to the last unfilled index and heapify O(logn)\\n     *  extract - swap root with last element and heapify the rest. O(logn) \\n     * \\n     * Time: O(nlogn) O(n) for re-arrange\\n     * Space: O(logn) - stack memory for heapify.\\n     * Inplace: yes\\n     * Stable : no\\n     * @param nums\\n     * @return\\n     */\\n    public int[] sort(int[] nums) {\\n\\n        // rearrange the given array to build the heap\\n        int n=nums.length;\\n        for(int i=n/2-1;i>=0;--i)\\n            heapify(nums, n, i);\\n\\n        // extract the min from heap\\n        for(int i=n-1;i>=0;--i) {\\n\\n            // move root to the last\\n            swap(nums, 0,i);\\n            heapify(nums, i, 0);\\n        }\\n\\n        return nums;\\n    }\\n\\n\\n    private void heapify(int[] nums, int n, int i) {\\n        int parent = i; // root\\n        int left = 2*i + 1; // left child\\n        int right = 2*i + 2; // right child\\n\\n        if(left<n && nums[left]>nums[parent]) {\\n            parent=left;\\n        }\\n\\n        if(right<n && nums[right]>nums[parent]) {\\n            parent=right;\\n        }\\n\\n        if(parent != i) {\\n            // heapify\\n            swap(nums, parent, i);\\n            heapify(nums, n, parent);\\n        }\\n\\n    }\\n\\n    private void swap(int[] nums, int i , int j) {\\n        int temp = nums[i];\\n        nums[i]=nums[j];\\n        nums[j] = temp;\\n    }\\n\\t\\n\\t   /**\\n     * Merge Sort: Divide and Conquer\\n     * We divide the problem here by n/2 and merge\\n     *  Divide: n/2\\n     *  Conquer:\\n     *      Merge Part: Compare and merge the smallest element to the result.\\n     *\\n     *\\n     * Time: O(nlogn)\\n     * Space: O(n) additional array space\\n     *\\n     * @param nums\\n     * @return\\n     */\\n    public int[] sort(int[] nums) {\\n       return helper(nums, 0, nums.length-1);\\n    }\\n\\n    private int[] helper(int[] nums, int start, int end) {\\n\\n            if(start==end)\\n                return new int[]{nums[start]};\\n\\n\\n            int mid=start+(end-start)/2;\\n            // divide\\n            int[] left = helper(nums, start, mid);\\n            int[] right = helper(nums, mid+1, end);\\n\\n            int[] res=new int[left.length+right.length];\\n\\n            // merge\\n            int i=0, j=0, k=0;\\n            while(i<left.length && j<right.length) {\\n                if(left[i]<=right[j])\\n                    res[k++]=left[i++];\\n                else\\n                    res[k++]=right[j++];\\n            }\\n\\n            while(i<left.length) {\\n                res[k++]=left[i++];\\n            }\\n\\n            while(j<right.length) {\\n                res[k++]=right[j++];\\n            }\\n\\n            return res;\\n    }\\n\\t\\n\\t /**\\n     * Quick sort is also a divide and conquer but we this time divide/partition the data based on pivot element.\\n     *\\n     * unlike merge sort, the divide part will be time consuming in quick sort\\n     * quick sort is inplace\\n     * but not stable as merge sort\\n     *\\n     * Time: O(nlogn) average case and O(n^2) worst case.\\n     * Space: O(logN)  stack space.\\n     *\\n     * inplace\\n     * not-stable.\\n     *\\n     * @param nums\\n     * @return\\n     */\\n    public int[] sort(int[] nums) {\\n        helper(nums,0, nums.length-1);\\n        return nums;\\n    }\\n\\n    private void helper(int[] nums, int start, int end) {\\n        if(start>=end)\\n            return;\\n\\n        // Divide or Partition step\\n        // choose a pivot, choosing first element as pivot this can lead to n2 time\\n         // don\\'t need to swap in this case, we can use randomized pivot selection as well.\\n        // Lumoto\\'s partition or Hoare\\'s partition(inventor)\\n        Random r = new Random();\\n        int randIndex=r.nextInt(end-start)+start;\\n        swap(nums, start, randIndex);\\n\\n        int pivot=nums[start];\\n        int orange=start, green;\\n        for(green=orange+1;green<=end;++green) {\\n            if(nums[green]<pivot) {\\n                ++ orange;\\n                swap(nums, orange, green);\\n            }\\n        }\\n\\n\\n        swap(nums, orange, start);\\n\\n        // conquer\\n        helper(nums, start, orange-1);\\n        helper(nums, orange+1, end);\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n\\t\\n\\t/**\\n     * Count the numbers and  rearrange\\n     *\\n     * Time: O(n+k) k=100k here\\n     * Space: O(1)\\n     *\\n     * @param nums\\n     * @return\\n     */\\n    public int[] sort(int[] nums) {\\n        int[] count = new int[100000];\\n\\n        for(int num:nums) {\\n            count[num+50000]++;\\n        }\\n\\n        int k=0;\\n        for(int i=0;i<100000 && k<nums.length;++i) {\\n            int j=0;\\n            while(j<count[i]) {\\n                nums[k++]=i-50000;\\n                ++j;\\n            }\\n        }\\n\\n        return nums;\\n    }\\n\\t\\n\\t/** radix sort is  to do counting sort start from LSB and  go over all the digits, O(dn) \\n```",
                "solutionTags": [],
                "code": "```\\n /**\\n     *\\n     * Selection Sort\\n     * Brute Force or Decrease and Conquer\\n     *\\n     * Select min for each index by scanning through rest of the array\\n     *\\n     * Time  : O(N^2)\\n     * Space : O(1)\\n     *\\n     * Inplace, Stable\\n     * @param nums\\n     */\\n    public int[] sort(int[] nums) {\\n\\n        for(int i=0;i<nums.length;++i) {\\n            for(int j=i+1;j<nums.length;++j) {\\n                if(nums[j]<nums[i]) {\\n                    int temp=nums[i];\\n                    nums[i]=nums[j];\\n                    nums[j]=temp;\\n                }\\n            }\\n        }\\n\\n        return nums;\\n    }\\n\\t\\n\\t/**\\n     *\\n     *  Bubble Sort\\n     * Brute force sorting algorithm, similar to\\n     *\\n     * Time: O(n^2)\\n     * Space: O(1)\\n     *\\n     * series of scan on each iteration:\\n     * s=n-1+n-2+n-3 .... +1\\n     * reverse\\n     * 2s=1+2+3...+n-2+n-1\\n     *\\n     * 2s=n+n+..+n\\n     * 2s=n(n-1)\\n     * s=(n(n-1))/2\\n     * s=n^2\\n     *\\n     *\\n     *\\n     *\\n     * Inplace\\n     * Stable\\n     *\\n     * @param nums\\n     * @return\\n     */\\n\\n\\n    public int[] sort(int[] nums) {\\n\\n        for(int i=0;i<nums.length;++i) {\\n            for (int j = nums.length - 1; j > i; --j) {\\n                if(nums[j]<nums[j-1]) {\\n                    int temp=nums[j-1];\\n                    nums[j-1]=nums[j];\\n                    nums[j]=temp;\\n                }\\n            }\\n        }\\n\\n        return nums;\\n    }\\n\\t\\n\\t/**\\n     * \\n     * Insertion Sort\\n     * Decrease and conquer algorithm\\n     *\\n     * Think that n-1 problem is already sorted and insert the new element into it.\\n     *\\n     * (n-1) to n\\n     *\\n     * Time: O(n^2)\\n     * Space: O(1)\\n     *\\n     * This might be better than the previous algorithms in base case time of O(n)\\n     *\\n     * @return\\n     */\\n\\n    public int[] sort(int[] nums) {\\n        helper(nums, nums.length-1);\\n        return nums;\\n    }\\n\\n    private void helper(int[] nums, int n) {\\n        if(n<=0)\\n            return;\\n\\n        helper(nums, n-1);\\n\\n        // extend the  from n-1 solution\\n        int nth=nums[n];\\n        int j=n-1;\\n\\n        while(j>=0 && nums[j]>nth) {\\n            nums[j+1]=nums[j];\\n            --j;\\n        }\\n\\n        nums[j+1]=nth;\\n    }\\n\\t\\n\\t/**\\n     * Heap Sort- using array\\n     * \\n     *  root contains the max/min.\\n     *  \\n     *  operations\\n     *  add - add to the last unfilled index and heapify O(logn)\\n     *  extract - swap root with last element and heapify the rest. O(logn) \\n     * \\n     * Time: O(nlogn) O(n) for re-arrange\\n     * Space: O(logn) - stack memory for heapify.\\n     * Inplace: yes\\n     * Stable : no\\n     * @param nums\\n     * @return\\n     */\\n    public int[] sort(int[] nums) {\\n\\n        // rearrange the given array to build the heap\\n        int n=nums.length;\\n        for(int i=n/2-1;i>=0;--i)\\n            heapify(nums, n, i);\\n\\n        // extract the min from heap\\n        for(int i=n-1;i>=0;--i) {\\n\\n            // move root to the last\\n            swap(nums, 0,i);\\n            heapify(nums, i, 0);\\n        }\\n\\n        return nums;\\n    }\\n\\n\\n    private void heapify(int[] nums, int n, int i) {\\n        int parent = i; // root\\n        int left = 2*i + 1; // left child\\n        int right = 2*i + 2; // right child\\n\\n        if(left<n && nums[left]>nums[parent]) {\\n            parent=left;\\n        }\\n\\n        if(right<n && nums[right]>nums[parent]) {\\n            parent=right;\\n        }\\n\\n        if(parent != i) {\\n            // heapify\\n            swap(nums, parent, i);\\n            heapify(nums, n, parent);\\n        }\\n\\n    }\\n\\n    private void swap(int[] nums, int i , int j) {\\n        int temp = nums[i];\\n        nums[i]=nums[j];\\n        nums[j] = temp;\\n    }\\n\\t\\n\\t   /**\\n     * Merge Sort: Divide and Conquer\\n     * We divide the problem here by n/2 and merge\\n     *  Divide: n/2\\n     *  Conquer:\\n     *      Merge Part: Compare and merge the smallest element to the result.\\n     *\\n     *\\n     * Time: O(nlogn)\\n     * Space: O(n) additional array space\\n     *\\n     * @param nums\\n     * @return\\n     */\\n    public int[] sort(int[] nums) {\\n       return helper(nums, 0, nums.length-1);\\n    }\\n\\n    private int[] helper(int[] nums, int start, int end) {\\n\\n            if(start==end)\\n                return new int[]{nums[start]};\\n\\n\\n            int mid=start+(end-start)/2;\\n            // divide\\n            int[] left = helper(nums, start, mid);\\n            int[] right = helper(nums, mid+1, end);\\n\\n            int[] res=new int[left.length+right.length];\\n\\n            // merge\\n            int i=0, j=0, k=0;\\n            while(i<left.length && j<right.length) {\\n                if(left[i]<=right[j])\\n                    res[k++]=left[i++];\\n                else\\n                    res[k++]=right[j++];\\n            }\\n\\n            while(i<left.length) {\\n                res[k++]=left[i++];\\n            }\\n\\n            while(j<right.length) {\\n                res[k++]=right[j++];\\n            }\\n\\n            return res;\\n    }\\n\\t\\n\\t /**\\n     * Quick sort is also a divide and conquer but we this time divide/partition the data based on pivot element.\\n     *\\n     * unlike merge sort, the divide part will be time consuming in quick sort\\n     * quick sort is inplace\\n     * but not stable as merge sort\\n     *\\n     * Time: O(nlogn) average case and O(n^2) worst case.\\n     * Space: O(logN)  stack space.\\n     *\\n     * inplace\\n     * not-stable.\\n     *\\n     * @param nums\\n     * @return\\n     */\\n    public int[] sort(int[] nums) {\\n        helper(nums,0, nums.length-1);\\n        return nums;\\n    }\\n\\n    private void helper(int[] nums, int start, int end) {\\n        if(start>=end)\\n            return;\\n\\n        // Divide or Partition step\\n        // choose a pivot, choosing first element as pivot this can lead to n2 time\\n         // don\\'t need to swap in this case, we can use randomized pivot selection as well.\\n        // Lumoto\\'s partition or Hoare\\'s partition(inventor)\\n        Random r = new Random();\\n        int randIndex=r.nextInt(end-start)+start;\\n        swap(nums, start, randIndex);\\n\\n        int pivot=nums[start];\\n        int orange=start, green;\\n        for(green=orange+1;green<=end;++green) {\\n            if(nums[green]<pivot) {\\n                ++ orange;\\n                swap(nums, orange, green);\\n            }\\n        }\\n\\n\\n        swap(nums, orange, start);\\n\\n        // conquer\\n        helper(nums, start, orange-1);\\n        helper(nums, orange+1, end);\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n\\t\\n\\t/**\\n     * Count the numbers and  rearrange\\n     *\\n     * Time: O(n+k) k=100k here\\n     * Space: O(1)\\n     *\\n     * @param nums\\n     * @return\\n     */\\n    public int[] sort(int[] nums) {\\n        int[] count = new int[100000];\\n\\n        for(int num:nums) {\\n            count[num+50000]++;\\n        }\\n\\n        int k=0;\\n        for(int i=0;i<100000 && k<nums.length;++i) {\\n            int j=0;\\n            while(j<count[i]) {\\n                nums[k++]=i-50000;\\n                ++j;\\n            }\\n        }\\n\\n        return nums;\\n    }\\n\\t\\n\\t/** radix sort is  to do counting sort start from LSB and  go over all the digits, O(dn) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 543597,
                "title": "heap-sort",
                "content": "\\tclass Solution {\\n\\t\\tpublic List<Integer> sortArray(int[] nums) {\\n\\n\\t\\t\\tnums= h(nums);\\n\\t\\t\\tnums=del(nums,new int[nums.length]);\\n\\n\\t\\t\\tList<Integer> list= new ArrayList<>();\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\tlist.add(nums[i]);\\n\\n\\t\\t\\t}        \\n\\t\\t\\treturn list ;     \\n\\t\\t}\\n\\t\\t//heapify the original array\\n\\t\\tpublic int[] h(int[] nums){\\n\\t\\t\\tfor(int i=nums.length-1;i>=0;i--){\\n\\t\\t\\t\\tint a=i+1;\\n\\t\\t\\t\\twhile(2*a-1<nums.length||2*a<nums.length){\\n\\t\\t\\t\\tint prev=a;\\n\\t\\t\\t\\t\\tif(2*a<nums.length){\\n\\t\\t\\t\\t\\t\\tif(nums[2*a-1]>nums[2*a]){\\n\\t\\t\\t\\t\\t\\t\\ta=2*a;\\n\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\ta=2*a+1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(nums[a-1]>nums[prev-1]){\\n\\t\\t\\t\\t\\t\\t\\tint temp=nums[a-1];\\n\\t\\t\\t\\t\\t\\t\\tnums[a-1]=nums[prev-1];\\n\\t\\t\\t\\t\\t\\t\\tnums[prev-1]=temp;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\ta=2*a;\\n\\t\\t\\t\\t\\t\\tif(nums[a-1]>nums[prev-1]){\\n\\t\\t\\t\\t\\t\\t\\tint temp=nums[a-1];\\n\\t\\t\\t\\t\\t\\t\\tnums[a-1]=nums[prev-1];\\n\\t\\t\\t\\t\\t\\t\\tnums[prev-1]=temp;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\t\\t//continously delete max element ,ie,first block of heapified array\\n\\t\\tpublic int[] del(int[]nums, int[] sort){\\n\\t\\t\\tfor(int x=nums.length-1;x>=0;x--){\\n\\t\\t\\t\\tsort[x]=nums[0];\\n\\t\\t\\t\\tnums[0]=nums[x];\\n\\t\\t\\t\\tnums[x]=Integer.MIN_VALUE;\\n\\t\\t\\t\\tint a=1;\\n\\t\\t\\t\\t//make array again a complete binary tree\\n\\t\\t\\t\\twhile(2*a-1<nums.length||2*a<nums.length){\\n\\t\\t\\t\\tint prev=a;\\n\\t\\t\\t\\t\\tif(2*a<nums.length){\\n\\t\\t\\t\\t\\t\\tif(nums[2*a-1]>nums[2*a]){\\n\\t\\t\\t\\t\\t\\t\\ta=2*a;\\n\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\ta=2*a+1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(nums[a-1]>nums[prev-1]){\\n\\t\\t\\t\\t\\t\\t\\tint temp=nums[a-1];\\n\\t\\t\\t\\t\\t\\t\\tnums[a-1]=nums[prev-1];\\n\\t\\t\\t\\t\\t\\t\\tnums[prev-1]=temp;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\ta=2*a;\\n\\t\\t\\t\\t\\t\\tif(nums[a-1]>nums[prev-1]){\\n\\t\\t\\t\\t\\t\\t\\tint temp=nums[a-1];\\n\\t\\t\\t\\t\\t\\t\\tnums[a-1]=nums[prev-1];\\n\\t\\t\\t\\t\\t\\t\\tnums[prev-1]=temp;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn sort;\\n\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\t\\tpublic List<Integer> sortArray(int[] nums) {\\n\\n\\t\\t\\tnums= h(nums);\\n\\t\\t\\tnums=del(nums,new int[nums.length]);\\n\\n\\t\\t\\tList<Integer> list= new ArrayList<>();\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\tlist.add(nums[i]);\\n\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 499407,
                "title": "c-counting-sort-o-n-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid countingsort(vector<int>& nums){\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tvector<int> count(100001,0);\\n\\t\\t\\tfor(auto& x:nums){\\n\\t\\t\\t\\tcount[x+50000]++;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=1;i<count.size();i++){\\n\\t\\t\\t\\tcount[i]+=count[i-1];\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> ans(n);\\n\\t\\t\\tfor(auto& v:nums){\\n\\t\\t\\t\\tans[count[v+50000]-1]=v;\\n\\t\\t\\t\\tcount[v+50000]--;\\n\\t\\t\\t}\\n\\t\\t\\tnums=ans;\\n\\t\\t}\\n\\t\\tvector<int> sortArray(vector<int>& nums) {\\n\\t\\t\\tcountingsort(nums);\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting Sort"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid countingsort(vector<int>& nums){\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tvector<int> count(100001,0);\\n\\t\\t\\tfor(auto& x:nums){\\n\\t\\t\\t\\tcount[x+50000]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 415151,
                "title": "merge-sort-bottom-up-java",
                "content": "Have not found the bottom-up java merge sort solution here.\\n\\n```\\nclass Solution {\\n\\n    public int[] sortArray(int[] nums) {\\n        // starting from nums.length arrays of size 1 (already sorted)\\n        // on each step merge two adjacent sorted arrays so that they remain sorted\\n        // you may notice that sizes of arrays doubles on each step\\n        for(int currSize = 1; currSize < nums.length; currSize *= 2) {\\n            // on each step we need to merge/sort two adjacent arrays\\n            // we calculate the start index of this pair and call merge function\\n            for(int start = 0; start < nums.length; start += 2*currSize) {\\n                merge(nums, start, start + currSize, start + 2*currSize);\\n            }\\n        }\\n        \\n        return nums;\\n    }\\n    \\n    // merge two sorted adjacent arrays\\n    // first array (start, ..., mid-1) and second array (mid, ..., end-1)\\n    private void merge(int[] nums, int start, int mid, int end) {\\n        // need to check for cases when second array do not fully fits in the source array \\n        if (end > nums.length) end = nums.length;\\n        // need to check for cases when the first array just partially fits in the source array\\n        if (mid >= end) return;\\n        int[] nums2 = new int[end-mid];\\n        for(int i=0;i<nums2.length;i++) nums2[i] = nums[mid+i];\\n        \\n        int i = mid-1, j = nums2.length-1, k = end-1;\\n        while(i >= start && j >= 0) {\\n            if (nums[i] > nums2[j]) {\\n                nums[k--] = nums[i--];\\n            } else {\\n                nums[k--] = nums2[j--];\\n            }\\n        }\\n        \\n        while(i>=start) nums[k--] = nums[i--];\\n        while(j>=0) nums[k--] = nums2[j--];        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] sortArray(int[] nums) {\\n        // starting from nums.length arrays of size 1 (already sorted)\\n        // on each step merge two adjacent sorted arrays so that they remain sorted\\n        // you may notice that sizes of arrays doubles on each step\\n        for(int currSize = 1; currSize < nums.length; currSize *= 2) {\\n            // on each step we need to merge/sort two adjacent arrays\\n            // we calculate the start index of this pair and call merge function\\n            for(int start = 0; start < nums.length; start += 2*currSize) {\\n                merge(nums, start, start + currSize, start + 2*currSize);\\n            }\\n        }\\n        \\n        return nums;\\n    }\\n    \\n    // merge two sorted adjacent arrays\\n    // first array (start, ..., mid-1) and second array (mid, ..., end-1)\\n    private void merge(int[] nums, int start, int mid, int end) {\\n        // need to check for cases when second array do not fully fits in the source array \\n        if (end > nums.length) end = nums.length;\\n        // need to check for cases when the first array just partially fits in the source array\\n        if (mid >= end) return;\\n        int[] nums2 = new int[end-mid];\\n        for(int i=0;i<nums2.length;i++) nums2[i] = nums[mid+i];\\n        \\n        int i = mid-1, j = nums2.length-1, k = end-1;\\n        while(i >= start && j >= 0) {\\n            if (nums[i] > nums2[j]) {\\n                nums[k--] = nums[i--];\\n            } else {\\n                nums[k--] = nums2[j--];\\n            }\\n        }\\n        \\n        while(i>=start) nums[k--] = nums[i--];\\n        while(j>=0) nums[k--] = nums2[j--];        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388164,
                "title": "python-merge-sort-recursive",
                "content": "\\n    def merge(self,left,right):\\n        i =0 \\n        j =0 \\n        if len(left) == 0:\\n            return right \\n        if len(right) ==0:\\n            return left\\n        result =[]\\n        while i <len(left) and j < len(right):\\n            if left[i] < right[j]:\\n                result.append(left[i])\\n                i += 1\\n            else:\\n                result.append(right[j])\\n                j += 1\\n        if len(left[i:])>0:\\n            result.extend(left[i:])\\n            \\n        if len(right[j:])>0:\\n            result.extend(right[j:])\\n            \\n        return result    \\n    \\n    def sortArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(nums) <=1:\\n            return nums\\n        mid = len(nums)//2\\n        left = self.sortArray(nums[:mid])\\n        right = self.sortArray(nums[mid:])\\n\\n        return self.merge(left,right)",
                "solutionTags": [],
                "code": "\\n    def merge(self,left,right):\\n        i =0 \\n        j =0 \\n        if len(left) == 0:\\n            return right \\n        if len(right) ==0:\\n            return left\\n        result =[]\\n        while i <len(left) and j < len(right):\\n            if left[i] < right[j]:\\n                result.append(left[i])\\n                i += 1\\n            else:\\n                result.append(right[j])\\n                j += 1\\n        if len(left[i:])>0:\\n            result.extend(left[i:])\\n            \\n        if len(right[j:])>0:\\n            result.extend(right[j:])\\n            \\n        return result    \\n    \\n    def sortArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(nums) <=1:\\n            return nums\\n        mid = len(nums)//2\\n        left = self.sortArray(nums[:mid])\\n        right = self.sortArray(nums[mid:])\\n\\n        return self.merge(left,right)",
                "codeTag": "Python3"
            },
            {
                "id": 279017,
                "title": "js-bubblesort-selectionsort-insertionsort-mergesort-and-quicksort",
                "content": "```js\\nfunction bubbleSort(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        for (let j = 0; j < arr.length - i - 1; j++) {\\n            if (arr[j] > arr[j + 1]) {\\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\\n            }\\n        }\\n    }\\n    return arr;\\n}\\nfunction selectionSort(arr) {\\n    for (let i = 0; i < arr.length - 1; i++) {\\n        let min = i;\\n        for (let j = i + 1; j < arr.length; j++) {\\n            if (arr[j] < arr[min]) {\\n                min = j;\\n            }\\n        }\\n        [arr[i], arr[min]] = [arr[min], arr[i]];\\n    }\\n    return arr;\\n}\\n\\nfunction insertSort(arr) {\\n    for (let i = 0; i < arr.length - 1; i++) {\\n        for (let j = i + 1; j > 0; j--) {\\n            if (arr[j] < arr[j - 1]) {\\n                [arr[j - 1], arr[j]] = [arr[j], arr[j - 1]];\\n            } else {\\n                break; \\n            }\\n        }\\n    }\\n    return arr;\\n}\\n\\nfunction mergeSort(arr, start, end) {\\n    if (start < end) {\\n        let mid = Math.floor((start + end) / 2);\\n        let left = mergeSort(arr, start, mid);\\n        let right = mergeSort(arr, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    return arr.slice(start, end + 1);\\n}\\n\\nfunction merge(arr1, arr2) {\\n    let arr = [];\\n    let i = 0;\\n    let j = 0;\\n    while (i < arr1.length && j < arr2.length) {\\n        if (arr1[i] <= arr2[j]) {\\n            arr.push(arr1[i]);\\n            i++;\\n        } else {\\n            arr.push(arr2[j]);\\n            j++;\\n        }\\n    }\\n    if (i === arr1.length) {\\n        arr.push(...arr2.slice(j));\\n    }\\n    if (j === arr2.length) {\\n        arr.push(...arr1.slice(i));\\n    }\\n    return arr;\\n}\\n\\nfunction quickSort(arr, start, end) {\\n    if (start < end) {\\n        let pivotIndex = findPivot(arr, start, end);\\n        quickSort(arr, start, pivotIndex - 1);\\n        quickSort(arr, pivotIndex + 1, end);\\n    }\\n    return arr;\\n}\\n\\nfunction findPivot(arr, start, end) {\\n    let i = start - 1;\\n    let j = start;\\n    let pivot = arr[end];\\n    while (j < end) {\\n        if (arr[j] < pivot) {\\n            i++;\\n            [arr[i], arr[j]] = [arr[j], arr[i]];\\n        }\\n        j++;\\n    }\\n    [arr[i + 1], arr[end]] = [arr[end], arr[i + 1]];\\n    return i + 1;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```js\\nfunction bubbleSort(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        for (let j = 0; j < arr.length - i - 1; j++) {\\n            if (arr[j] > arr[j + 1]) {\\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\\n            }\\n        }\\n    }\\n    return arr;\\n}\\nfunction selectionSort(arr) {\\n    for (let i = 0; i < arr.length - 1; i++) {\\n        let min = i;\\n        for (let j = i + 1; j < arr.length; j++) {\\n            if (arr[j] < arr[min]) {\\n                min = j;\\n            }\\n        }\\n        [arr[i], arr[min]] = [arr[min], arr[i]];\\n    }\\n    return arr;\\n}\\n\\nfunction insertSort(arr) {\\n    for (let i = 0; i < arr.length - 1; i++) {\\n        for (let j = i + 1; j > 0; j--) {\\n            if (arr[j] < arr[j - 1]) {\\n                [arr[j - 1], arr[j]] = [arr[j], arr[j - 1]];\\n            } else {\\n                break; \\n            }\\n        }\\n    }\\n    return arr;\\n}\\n\\nfunction mergeSort(arr, start, end) {\\n    if (start < end) {\\n        let mid = Math.floor((start + end) / 2);\\n        let left = mergeSort(arr, start, mid);\\n        let right = mergeSort(arr, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    return arr.slice(start, end + 1);\\n}\\n\\nfunction merge(arr1, arr2) {\\n    let arr = [];\\n    let i = 0;\\n    let j = 0;\\n    while (i < arr1.length && j < arr2.length) {\\n        if (arr1[i] <= arr2[j]) {\\n            arr.push(arr1[i]);\\n            i++;\\n        } else {\\n            arr.push(arr2[j]);\\n            j++;\\n        }\\n    }\\n    if (i === arr1.length) {\\n        arr.push(...arr2.slice(j));\\n    }\\n    if (j === arr2.length) {\\n        arr.push(...arr1.slice(i));\\n    }\\n    return arr;\\n}\\n\\nfunction quickSort(arr, start, end) {\\n    if (start < end) {\\n        let pivotIndex = findPivot(arr, start, end);\\n        quickSort(arr, start, pivotIndex - 1);\\n        quickSort(arr, pivotIndex + 1, end);\\n    }\\n    return arr;\\n}\\n\\nfunction findPivot(arr, start, end) {\\n    let i = start - 1;\\n    let j = start;\\n    let pivot = arr[end];\\n    while (j < end) {\\n        if (arr[j] < pivot) {\\n            i++;\\n            [arr[i], arr[j]] = [arr[j], arr[i]];\\n        }\\n        j++;\\n    }\\n    [arr[i + 1], arr[end]] = [arr[end], arr[i + 1]];\\n    return i + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 277582,
                "title": "c-linear-time-count-sort-beat-99",
                "content": "reference : https://en.wikipedia.org/wiki/Counting_sort\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        vector<int> refmap(50000+50000+1,0); \\n        for(int I : nums) refmap[I+50000]++;\\n        int idx = 0;\\n        for(int i = 0 ; i < refmap.size();i++){\\n            if(refmap[i]--){\\n                nums[idx++] = i-50000;\\n                i--;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        vector<int> refmap(50000+50000+1,0); \\n        for(int I : nums) refmap[I+50000]++;\\n        int idx = 0;\\n        for(int i = 0 ; i < refmap.size();i++){\\n            if(refmap[i]--){\\n                nums[idx++] = i-50000;\\n                i--;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 276511,
                "title": "python-3-way-partitioning-quick-sort-merge-sort",
                "content": "3-way Partitioning Quick Sort\\nImprovement proposed by [Dijkstra](https://en.wikipedia.org/wiki/Dutch_national_flag_problem).\\nRegular inplace quicksort performes a 2-way partitioning, either rearrange array to [<= pivot] + [> pivot] or [< pivot] + [>= pivot].\\n3-way partitioning rearrange array to 3 parts:  [< pivot] + [= pivot] + [> pivot] and then sort the 1st and 3rd subarray. This greatly improve sorting with duplicate keys. Basically it\\'s:\\n```\\np = nums[0]\\nreturn qsort([x for x in nums if x < p]) + [x for x in nums if x == p] + qsort([x for x in nums if x > p])\\n```\\nBut we can achieve an inplace quick sort which is a great advantage over merge sort.\\n\\n```\\ndef qsort(nums):\\n\\tqsort(nums, 0, len(nums))\\n\\treturn nums\\n\\ndef subsort(self, A, l, r):\\n\\tp = A[l]\\n\\t# i: beginning of mid section, j: end of mid section, k: beginning of large section\\n\\ti, j, k = l+1, l+1, r-1   \\n\\twhile j <= k:\\n\\t\\tif A[j] <= p:\\n\\t\\t\\tif A[j] < p:\\n\\t\\t\\t\\tA[i], A[j] = A[j], A[i]\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\telse:\\n\\t\\t\\tA[j], A[k] = A[k], A[j]\\n\\t\\t\\tk -= 1\\n\\tA[l], A[i-1] = A[i-1], A[l]\\n\\tif l+1 < i-1: subsort(A, l, i-1)\\n\\tif j+1 < r: subsort(A, j, r)\\n```\\n\\nMerge Sort\\n```\\ndef msort(nums):\\n\\tn = len(nums)\\n\\treturn nums if n < 2 else merge(msort(nums[:n>>1]), msort(nums[n>>1:]))\\n\\t\\ndef merge(A, B):\\n\\tC = []\\n\\ti, j, m, n = 0, 0, len(A), len(B)\\n\\twhile i < m and j < n:\\n\\t\\tif A[i] < B[j]: \\n\\t\\t\\tC.append(A[i])\\n\\t\\t\\ti += 1\\n\\t\\telse: \\n\\t\\t\\tC.append(B[j])\\n\\t\\t\\tj +=1\\n\\treturn C + A[i:] + B[j:]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\np = nums[0]\\nreturn qsort([x for x in nums if x < p]) + [x for x in nums if x == p] + qsort([x for x in nums if x > p])\\n```\n```\\ndef qsort(nums):\\n\\tqsort(nums, 0, len(nums))\\n\\treturn nums\\n\\ndef subsort(self, A, l, r):\\n\\tp = A[l]\\n\\t# i: beginning of mid section, j: end of mid section, k: beginning of large section\\n\\ti, j, k = l+1, l+1, r-1   \\n\\twhile j <= k:\\n\\t\\tif A[j] <= p:\\n\\t\\t\\tif A[j] < p:\\n\\t\\t\\t\\tA[i], A[j] = A[j], A[i]\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\telse:\\n\\t\\t\\tA[j], A[k] = A[k], A[j]\\n\\t\\t\\tk -= 1\\n\\tA[l], A[i-1] = A[i-1], A[l]\\n\\tif l+1 < i-1: subsort(A, l, i-1)\\n\\tif j+1 < r: subsort(A, j, r)\\n```\n```\\ndef msort(nums):\\n\\tn = len(nums)\\n\\treturn nums if n < 2 else merge(msort(nums[:n>>1]), msort(nums[n>>1:]))\\n\\t\\ndef merge(A, B):\\n\\tC = []\\n\\ti, j, m, n = 0, 0, len(A), len(B)\\n\\twhile i < m and j < n:\\n\\t\\tif A[i] < B[j]: \\n\\t\\t\\tC.append(A[i])\\n\\t\\t\\ti += 1\\n\\t\\telse: \\n\\t\\t\\tC.append(B[j])\\n\\t\\t\\tj +=1\\n\\treturn C + A[i:] + B[j:]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3973263,
                "title": "counting-sort-using-map",
                "content": "unor\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n      unordered_map<int,int>mp;\\n      for(int &num: nums){//insert element in map \\n        mp[num]++;\\n      }\\n      // finding min and max element in nums \\n        int minE=*min_element(begin(nums),end(nums));\\n        int maxE=*max_element(begin(nums),end(nums));\\n      int i = 0;\\n      for(int j= minE ; j<= maxE ; j++){\\n          while(mp[j] > 0){\\n            nums[i] = j;\\n            i++;\\n            mp[j]--;\\n          }\\n      }\\n      return nums;\\n\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n      unordered_map<int,int>mp;\\n      for(int &num: nums){//insert element in map \\n        mp[num]++;\\n      }\\n      // finding min and max element in nums \\n        int minE=*min_element(begin(nums),end(nums));\\n        int maxE=*max_element(begin(nums),end(nums));\\n      int i = 0;\\n      for(int j= minE ; j<= maxE ; j++){\\n          while(mp[j] > 0){\\n            nums[i] = j;\\n            i++;\\n            mp[j]--;\\n          }\\n      }\\n      return nums;\\n\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748384,
                "title": "c-merge-sort",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void merge(vector<int>& nums, int l, int mid, int r) {\\n        int i = l, j = mid+1;\\n        vector<int> mergedArray;\\n\\n        while(i <= mid && j <= r) {\\n            if(nums[i] <= nums[j]) {\\n                mergedArray.push_back(nums[i]);\\n                i++;\\n            }\\n            else {\\n                mergedArray.push_back(nums[j]);\\n                j++;\\n            }\\n        }\\n        while(i <= mid) {\\n            mergedArray.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j <= r) {\\n            mergedArray.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = l; i <= r; i++) {\\n            nums[i] = mergedArray[i-l];\\n        }\\n    }\\n    void mergeSort(vector<int>& nums, int l, int r) {\\n        if(l >= r) return;\\n        int mid = l + (r-l)/2;\\n        mergeSort(nums, l, mid);\\n        mergeSort(nums, mid+1, r);\\n        merge(nums, l, mid, r);\\n    }\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void merge(vector<int>& nums, int l, int mid, int r) {\\n        int i = l, j = mid+1;\\n        vector<int> mergedArray;\\n\\n        while(i <= mid && j <= r) {\\n            if(nums[i] <= nums[j]) {\\n                mergedArray.push_back(nums[i]);\\n                i++;\\n            }\\n            else {\\n                mergedArray.push_back(nums[j]);\\n                j++;\\n            }\\n        }\\n        while(i <= mid) {\\n            mergedArray.push_back(nums[i]);\\n            i++;\\n        }\\n        while(j <= r) {\\n            mergedArray.push_back(nums[j]);\\n            j++;\\n        }\\n        for(int i = l; i <= r; i++) {\\n            nums[i] = mergedArray[i-l];\\n        }\\n    }\\n    void mergeSort(vector<int>& nums, int l, int r) {\\n        if(l >= r) return;\\n        int mid = l + (r-l)/2;\\n        mergeSort(nums, l, mid);\\n        mergeSort(nums, mid+1, r);\\n        merge(nums, l, mid, r);\\n    }\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683761,
                "title": "java-easy-4-liner-solution-using-priorityqueue",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n      int i = 0;\\n      PriorityQueue<Integer> pq = new PriorityQueue<>();\\n      for(int n : nums) pq.offer(n);\\n      while(!pq.isEmpty()) nums[i ++] = pq.poll();\\n      return nums;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Divide and Conquer",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n      int i = 0;\\n      PriorityQueue<Integer> pq = new PriorityQueue<>();\\n      for(int n : nums) pq.offer(n);\\n      while(!pq.isEmpty()) nums[i ++] = pq.poll();\\n      return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575119,
                "title": "c-merge-sort-o-n-logn",
                "content": "# Intuition\\nOnly you need to know how to merge two sorted array and binary search basics.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst divide the array into two such part that they both will contain only single unit by recurrsion, after that merge them into one unit.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N LogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // merging the array\\n    void merge(vector<int>& arr, int s, int mid, int e){\\n        int len1 = mid-s+1;\\n        int len2 = e-mid;\\n\\n        vector<int> l(len1);\\n        vector<int> r(len2);\\n        // storing the values of both sides.\\n        int mi = s;\\n        for(int i=0; i<len1; i++)\\n            l[i] = arr[mi++];\\n\\n        mi = mid+1;\\n        for(int i=0; i<len2; i++)\\n            r[i] = arr[mi++];\\n\\n\\n        int i=0, j = 0;\\n        mi = s;\\n        while(i<len1 && j<len2){\\n            if(l[i] < r[j])\\n                arr[mi++] = l[i++];\\n            else\\n                arr[mi++] = r[j++];\\n        }\\n        while(i<len1)\\n            arr[mi++] = l[i++];\\n        while(j<len2)\\n            arr[mi++] = r[j++];\\n    }\\n    // diving into parts\\n    void divide(vector<int>& arr, int s, int e){\\n        if(s >= e){\\n            return;\\n        }\\n        int mid = (s+e)/2;\\n        divide(arr, s, mid);\\n        divide(arr, mid+1, e);\\n\\n        merge(arr, s, mid, e);\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        divide(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // merging the array\\n    void merge(vector<int>& arr, int s, int mid, int e){\\n        int len1 = mid-s+1;\\n        int len2 = e-mid;\\n\\n        vector<int> l(len1);\\n        vector<int> r(len2);\\n        // storing the values of both sides.\\n        int mi = s;\\n        for(int i=0; i<len1; i++)\\n            l[i] = arr[mi++];\\n\\n        mi = mid+1;\\n        for(int i=0; i<len2; i++)\\n            r[i] = arr[mi++];\\n\\n\\n        int i=0, j = 0;\\n        mi = s;\\n        while(i<len1 && j<len2){\\n            if(l[i] < r[j])\\n                arr[mi++] = l[i++];\\n            else\\n                arr[mi++] = r[j++];\\n        }\\n        while(i<len1)\\n            arr[mi++] = l[i++];\\n        while(j<len2)\\n            arr[mi++] = r[j++];\\n    }\\n    // diving into parts\\n    void divide(vector<int>& arr, int s, int e){\\n        if(s >= e){\\n            return;\\n        }\\n        int mid = (s+e)/2;\\n        divide(arr, s, mid);\\n        divide(arr, mid+1, e);\\n\\n        merge(arr, s, mid, e);\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        divide(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542546,
                "title": "merge-sort-divide-and-conquer-explained-and-simple-approach",
                "content": "# Intuition\\nwe divide the vector in sun vector untill all the sub vector become size of one and then we will sort one by one and push them vector and return it \\n\\nthese smaller part are easy to sort \\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n     vector<int> mergesort (vector<int>& nums ,int start , int end ) {\\n     \\n         if(start==end){\\n          // start is firstindex\\n          // end is lastindex\\n          //for arr= [5] start is equal to end so size is one we return that \\n            vector<int> ans;\\n            ans.push_back(nums[start]);\\n             return ans;\\n         }\\n        // we divided array in two part and sort them \\n        int mid=start+(end-start)/2;\\n        //[5,2,3,1]  mid = 2;\\n        vector<int> ans1= mergesort (nums,start,mid); //divided first part [5,2] \\n        vector<int> ans2= mergesort (nums,mid+1,end);  //divided second part [3,1]\\n\\n\\n        int s1=0; \\n        int s2=0;\\n         vector<int> result;\\n        // we will merge our all size one length part in sort vector and return it\\n\\n      \\n\\n\\n        //merging and sorting of these divided vector \\n        while(s1<ans1.size() && s2<ans2.size()){\\n        \\n          if(ans1[s1]<=ans2[s2]){\\n            result.push_back(ans1[s1]);\\n            s1++;\\n          }\\n          else{\\n            result.push_back(ans2[s2]);\\n            s2++;\\n          }\\n    \\n        }\\n        while(s1<ans1.size()){\\n           result.push_back(ans1[s1]);\\n           s1++;\\n        }\\n         while(s2<ans2.size()){\\n           result.push_back(ans2[s2]);\\n           s2++;\\n        }\\n\\n\\n       // return the sorted vector\\n        return result;\\n     }\\n\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n      \\n     return  mergesort (nums ,0 , nums.size()-1 );\\n     \\n    }\\n};\\n\\n// 5.  2.  3.  1\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n     vector<int> mergesort (vector<int>& nums ,int start , int end ) {\\n     \\n         if(start==end){\\n          // start is firstindex\\n          // end is lastindex\\n          //for arr= [5] start is equal to end so size is one we return that \\n            vector<int> ans;\\n            ans.push_back(nums[start]);\\n             return ans;\\n         }\\n        // we divided array in two part and sort them \\n        int mid=start+(end-start)/2;\\n        //[5,2,3,1]  mid = 2;\\n        vector<int> ans1= mergesort (nums,start,mid); //divided first part [5,2] \\n        vector<int> ans2= mergesort (nums,mid+1,end);  //divided second part [3,1]\\n\\n\\n        int s1=0; \\n        int s2=0;\\n         vector<int> result;\\n        // we will merge our all size one length part in sort vector and return it\\n\\n      \\n\\n\\n        //merging and sorting of these divided vector \\n        while(s1<ans1.size() && s2<ans2.size()){\\n        \\n          if(ans1[s1]<=ans2[s2]){\\n            result.push_back(ans1[s1]);\\n            s1++;\\n          }\\n          else{\\n            result.push_back(ans2[s2]);\\n            s2++;\\n          }\\n    \\n        }\\n        while(s1<ans1.size()){\\n           result.push_back(ans1[s1]);\\n           s1++;\\n        }\\n         while(s2<ans2.size()){\\n           result.push_back(ans2[s2]);\\n           s2++;\\n        }\\n\\n\\n       // return the sorted vector\\n        return result;\\n     }\\n\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n      \\n     return  mergesort (nums ,0 , nums.size()-1 );\\n     \\n    }\\n};\\n\\n// 5.  2.  3.  1\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503913,
                "title": "mergesort-o-nlogn-c-solution",
                "content": "# Intuition\\nJust Sort The Using MergrSort Algorithm\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(NLOGN)\\n- Space complexity:\\no(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid merge(vector<int>&nums,int low,int high,int mid)\\n{\\n    int i=low,j=mid+1;\\n    vector<int>temp;\\n    while(i<=mid&&j<=high)\\n    {\\n          if(nums[i]<=nums[j])\\n          {\\n                  temp.push_back(nums[i++]);\\n          }\\n          else \\n          {\\n               temp.push_back(nums[j++]);\\n          }\\n    }\\n    while(i<=mid)\\n    {\\n              temp.push_back(nums[i++]);\\n    }\\n    while(j<=high)\\n    {\\n temp.push_back(nums[j++]);\\n    }\\n    for(int i=low;i<=high;i++)\\n     nums[i]=temp[i-low];\\n     return;\\n}\\n void divide(vector<int>&nums,int low,int high)\\n    {\\n        if(low==high) return;\\n        int mid=(low+high)/2;\\n         //lefthalf\\n         divide(nums,low,mid);\\n         //righthalf\\n         divide(nums,mid+1,high);\\n         //conquer them\\n         merge(nums,low,high,mid);\\n         return;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        divide(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid merge(vector<int>&nums,int low,int high,int mid)\\n{\\n    int i=low,j=mid+1;\\n    vector<int>temp;\\n    while(i<=mid&&j<=high)\\n    {\\n          if(nums[i]<=nums[j])\\n          {\\n                  temp.push_back(nums[i++]);\\n          }\\n          else \\n          {\\n               temp.push_back(nums[j++]);\\n          }\\n    }\\n    while(i<=mid)\\n    {\\n              temp.push_back(nums[i++]);\\n    }\\n    while(j<=high)\\n    {\\n temp.push_back(nums[j++]);\\n    }\\n    for(int i=low;i<=high;i++)\\n     nums[i]=temp[i-low];\\n     return;\\n}\\n void divide(vector<int>&nums,int low,int high)\\n    {\\n        if(low==high) return;\\n        int mid=(low+high)/2;\\n         //lefthalf\\n         divide(nums,low,mid);\\n         //righthalf\\n         divide(nums,mid+1,high);\\n         //conquer them\\n         merge(nums,low,high,mid);\\n         return;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        divide(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450597,
                "title": "java-2-approaches-step-by-step-explained-merge-quick-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/ea9be7b2-f96a-4bae-a1e2-2b8533e069a2_1682342509.146119.png)\\n\\n\\n# Merge Sort \\n# Code\\n```**\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return nums;\\n        }\\n        // Call the mergesort method to sort the input array recursively\\n        mergesort(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n    \\n    private void mergesort(int[] nums, int left, int right) {\\n        if (left < right) {\\n            // Calculate the midpoint of the input array\\n            int mid = (left + right) / 2;\\n            // Recursively sort the left half of the array\\n            mergesort(nums, left, mid);\\n            // Recursively sort the right half of the array\\n            mergesort(nums, mid + 1, right);\\n            // Merge the two sorted halves of the array\\n            merge(nums, left, mid, right);\\n        }\\n    }\\n    \\n    private void merge(int[] nums, int left, int mid, int right) {\\n        // Create a temporary array to hold the merged values\\n        int[] temp = new int[right - left + 1];\\n        int i = left, j = mid + 1, k = 0;\\n        // Iterate over the two halves of the array and add the smaller value to the temporary array\\n        while (i <= mid && j <= right) {\\n            if (nums[i] < nums[j]) {\\n                temp[k++] = nums[i++];\\n            } else {\\n                temp[k++] = nums[j++];\\n            }\\n        }\\n        // Copy any remaining values from the left half of the array to the temporary array\\n        while (i <= mid) {\\n            temp[k++] = nums[i++];\\n        }\\n        // Copy any remaining values from the right half of the array to the temporary array\\n        while (j <= right) {\\n            temp[k++] = nums[j++];\\n        }\\n        // Copy the sorted values from the temporary array back to the original array\\n        for (int p = 0; p < temp.length; p++) {\\n            nums[left + p] = temp[p];\\n        }\\n    }\\n}\\n\\n```\\n\\n# Quick Sort\\n\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        qs(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n\\n    // This method implements the QuickSort algorithm\\n    public void qs(int nums[], int low, int high) {\\n        // Base case: If the subarray has only one element or is empty, it is already sorted\\n        if (low < high) {\\n            // Partition the subarray and recursively sort the left and right subarrays\\n            int pIndex = partition(nums, low, high);\\n            qs(nums, low, pIndex - 1);\\n            qs(nums, pIndex + 1, high);\\n        }\\n    }\\n\\n    // This method partitions the subarray around a pivot element\\n    public int partition(int nums[], int low, int high) {\\n        // Select a random pivot index and swap the pivot element to the end of the subarray\\n        int pivotIndex = low + (int) (Math.random() * (high - low + 1));\\n        int pivot = nums[pivotIndex];\\n        swap(nums, pivotIndex, high);\\n\\n        int i = low;\\n        // Iterate through the elements in the subarray\\n        for (int j = low; j < high; j++) {\\n            // If the current element is less than the pivot, swap it with the element at index i\\n            if (nums[j] < pivot) {\\n                swap(nums, i, j);\\n                i++;\\n            }\\n        }\\n        // Swap the pivot element with the element at index i, which puts the pivot in its final position\\n        swap(nums, i, high);\\n        return i;\\n    }\\n\\n    // This method swaps two elements in an array given their indices\\n    public static void swap(int[] arr, int index1, int index2) {\\n        int temp = arr[index1];\\n        arr[index1] = arr[index2];\\n        arr[index2] = temp;\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Recursion"
                ],
                "code": "```**\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return nums;\\n        }\\n        // Call the mergesort method to sort the input array recursively\\n        mergesort(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n    \\n    private void mergesort(int[] nums, int left, int right) {\\n        if (left < right) {\\n            // Calculate the midpoint of the input array\\n            int mid = (left + right) / 2;\\n            // Recursively sort the left half of the array\\n            mergesort(nums, left, mid);\\n            // Recursively sort the right half of the array\\n            mergesort(nums, mid + 1, right);\\n            // Merge the two sorted halves of the array\\n            merge(nums, left, mid, right);\\n        }\\n    }\\n    \\n    private void merge(int[] nums, int left, int mid, int right) {\\n        // Create a temporary array to hold the merged values\\n        int[] temp = new int[right - left + 1];\\n        int i = left, j = mid + 1, k = 0;\\n        // Iterate over the two halves of the array and add the smaller value to the temporary array\\n        while (i <= mid && j <= right) {\\n            if (nums[i] < nums[j]) {\\n                temp[k++] = nums[i++];\\n            } else {\\n                temp[k++] = nums[j++];\\n            }\\n        }\\n        // Copy any remaining values from the left half of the array to the temporary array\\n        while (i <= mid) {\\n            temp[k++] = nums[i++];\\n        }\\n        // Copy any remaining values from the right half of the array to the temporary array\\n        while (j <= right) {\\n            temp[k++] = nums[j++];\\n        }\\n        // Copy the sorted values from the temporary array back to the original array\\n        for (int p = 0; p < temp.length; p++) {\\n            nums[left + p] = temp[p];\\n        }\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        qs(nums, 0, nums.length - 1);\\n        return nums;\\n    }\\n\\n    // This method implements the QuickSort algorithm\\n    public void qs(int nums[], int low, int high) {\\n        // Base case: If the subarray has only one element or is empty, it is already sorted\\n        if (low < high) {\\n            // Partition the subarray and recursively sort the left and right subarrays\\n            int pIndex = partition(nums, low, high);\\n            qs(nums, low, pIndex - 1);\\n            qs(nums, pIndex + 1, high);\\n        }\\n    }\\n\\n    // This method partitions the subarray around a pivot element\\n    public int partition(int nums[], int low, int high) {\\n        // Select a random pivot index and swap the pivot element to the end of the subarray\\n        int pivotIndex = low + (int) (Math.random() * (high - low + 1));\\n        int pivot = nums[pivotIndex];\\n        swap(nums, pivotIndex, high);\\n\\n        int i = low;\\n        // Iterate through the elements in the subarray\\n        for (int j = low; j < high; j++) {\\n            // If the current element is less than the pivot, swap it with the element at index i\\n            if (nums[j] < pivot) {\\n                swap(nums, i, j);\\n                i++;\\n            }\\n        }\\n        // Swap the pivot element with the element at index i, which puts the pivot in its final position\\n        swap(nums, i, high);\\n        return i;\\n    }\\n\\n    // This method swaps two elements in an array given their indices\\n    public static void swap(int[] arr, int index1, int index2) {\\n        int temp = arr[index1];\\n        arr[index1] = arr[index2];\\n        arr[index2] = temp;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383447,
                "title": "easy-c-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasic Merge Sort is used\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void mergeSort(vector<int>&nums,int l,int h){\\n        if(l>=h){\\n            return;\\n        }\\n        int mid=(l+h)/2;\\n        mergeSort(nums,l,mid);\\n        mergeSort(nums,mid+1,h);\\n        merge(nums,l,mid,h);\\n    }\\n    void merge(vector<int>&nums,int l,int mid,int h){\\n        vector<int>temp;\\n        int left=l;\\n        int right=mid+1;\\n        while(left<=mid && right<=h){\\n            if(nums[left]<=nums[right]){\\n                temp.push_back(nums[left]);\\n                left++;\\n            }else{\\n                temp.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        while(left<=mid){\\n            temp.push_back(nums[left]);\\n            left++;\\n        }\\n        while(right<=h){\\n            temp.push_back(nums[right]);\\n            right++;\\n        }\\n        for(int i=l;i<=h;i++){\\n            nums[i]=temp[i-l];\\n        }\\n        return;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        int low=0;\\n        int high=nums.size()-1;\\n        mergeSort(nums,low,high);\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void mergeSort(vector<int>&nums,int l,int h){\\n        if(l>=h){\\n            return;\\n        }\\n        int mid=(l+h)/2;\\n        mergeSort(nums,l,mid);\\n        mergeSort(nums,mid+1,h);\\n        merge(nums,l,mid,h);\\n    }\\n    void merge(vector<int>&nums,int l,int mid,int h){\\n        vector<int>temp;\\n        int left=l;\\n        int right=mid+1;\\n        while(left<=mid && right<=h){\\n            if(nums[left]<=nums[right]){\\n                temp.push_back(nums[left]);\\n                left++;\\n            }else{\\n                temp.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        while(left<=mid){\\n            temp.push_back(nums[left]);\\n            left++;\\n        }\\n        while(right<=h){\\n            temp.push_back(nums[right]);\\n            right++;\\n        }\\n        for(int i=l;i<=h;i++){\\n            nums[i]=temp[i-l];\\n        }\\n        return;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        int low=0;\\n        int high=nums.size()-1;\\n        mergeSort(nums,low,high);\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313271,
                "title": "exploring-introsort-a-hybrid-sorting-algorithm",
                "content": "# Intuition\\nWhen I was looking for an efficient general-purpose sorting algorithm for thsi question, I wanted to find a method that combines the best aspects of different sorting algorithms while minimizing the weaknesses of each individual approach.\\n\\n# Approach\\nI decided to implement IntroSort, an adaptive sorting algorithm that uses three different sorting methods depending on the input data and the current recursion depth:\\n\\n1. QuickSort: I used QuickSort for most of the sorting process.\\n2. HeapSort: I switched to HeapSort when the recursion depth limit was reached. This helps avoid the worst-case performance of QuickSort.\\n3. Insertion Sort: I used Insertion Sort for small partitions (\\u226416 elements in this implementation). Insertion Sort is fast for small data sets.\\n\\nThis hybrid approach makes IntroSort an excellent general-purpose sorting algorithm because it combines the advantages of the three algorithms, resulting in good average-case performance and avoiding the worst-case performance of QuickSort.\\n\\n# Complexity\\n- Time complexity:\\nIntroSort has an average and worst-case time complexity of $$O(n \\\\log n)$$, which is similar to other efficient algorithms like Merge Sort and HeapSort.\\n\\n- Space complexity:\\nIntroSort is an in-place sorting algorithm, meaning it does not require additional memory allocations. Its space complexity is $$O(\\\\log n)$$ due to the recursion depth of QuickSort.\\n\\n# Comparison with other sorting algorithms (leetcode-world)\\nGiven the problem constraints, the goal is to sort an array of integers in ascending order using a sorting algorithm with O(nlog(n)) time complexity and the smallest possible space complexity. IntroSort is an excellent choice for this problem. Here\\'s a more specific comparison with other sorting algorithms:\\n\\n1. Insertion Sort:\\n    - Time complexity: $$O(n^2)$$, which exceeds the required O(nlog(n)).\\n    - Space complexity: $$O(1)$$, but the time complexity makes it unsuitable for this problem.\\n\\n2. Selection Sort:\\n    - Time complexity: $$O(n^2)$$, which exceeds the required O(nlog(n)).\\n    - Space complexity: $$O(1)$$, but the time complexity makes it unsuitable for this problem.\\n\\n3. Bubble Sort:\\n    - Time complexity: $$O(n^2)$$, which exceeds the required O(nlog(n)).\\n    - Space complexity: $$O(1)$$, but the time complexity makes it unsuitable for this problem.\\n\\n4. Quick Sort:\\n    - Time complexity: $$O(n \\\\log n)$$ on average, but $$O(n^2)$$ in the worst case. The worst-case scenario can be mitigated by using a randomized pivot or switching to another algorithm when the recursion depth is too deep.\\n    - Space complexity: $$O(\\\\log n)$$ for the recursion stack.\\n\\n5. Merge Sort:\\n    - Time complexity: $$O(n \\\\log n)$$, which meets the problem requirements.\\n    - Space complexity: $$O(n)$$ for the merging step, which is not optimal for this problem.\\n\\n6. Heap Sort:\\n    - Time complexity: $$O(n \\\\log n)$$, which meets the problem requirements.\\n    - Space complexity: $$O(1)$$, an in-place variant could be used to minimize space complexity.\\n\\n7. Radix Sort and Bucket Sort:\\n    - Time complexity: $$O(nk)$$ and $$O(n + k)$$, respectively, where k is the range of the input integers. However, the problem statement has a large range of input integers (-50,000 to 50,000), which makes these algorithms inefficient for this problem.\\n    - Space complexity: Both require additional space, which is not optimal for this problem.\\n\\n8. Counting Sort:\\n    - Time complexity: $$O(n+k)$$, but the large range of input integers makes it inefficient for this problem.\\n    - Space complexity: $$O(n+k)$$, not optimal for this problem as it requires additional space.\\n\\nConsidering the required O(nlog(n)) time complexity and the smallest possible space complexity, IntroSort is a great choice for this problem. It meets the time complexity requirement, and its space complexity is $$O(\\\\log n)$$ due to the recursion depth. Moreover, it switches to HeapSort when the recursion depth is too deep and Insertion Sort for small partitions, making it a versatile and efficient solution for the given constraints.\\n\\n# Comparison with other sorting algorithms (real-world)\\nIn comparison to other sorting algorithms, IntroSort offers a balanced approach:\\n\\n- It has a better average-case performance compared to Insertion Sort, Selection Sort, and Bubble Sort, which all have a quadratic $$O(n^2)$$ time complexity.\\n- It avoids the worst-case performance of QuickSort, which can also be $$O(n^2)$$, by switching to HeapSort when the recursion depth limit is reached.\\n- It has a better space complexity compared to Merge Sort, which requires an additional $$O(n)$$ space for merging.\\n\\nConsidering these factors, IntroSort is an excellent choice for a general-purpose sorting algorithm as it offers both good average-case performance and avoids the worst-case scenarios of other sorting algorithms.\\n\\nHowever, for specific use cases, you might still consider other algorithms:\\n\\n- For small or partially sorted data sets, Insertion Sort or Bubble Sort might be more efficient.\\n- For data sets with a fixed range of integers, Counting Sort, Radix Sort, or Bucket Sort might be more appropriate.\\n\\nIt\\'s essential to understand the specific use case before choosing the most appropriate sorting algorithm for the task at hand.\\n\\n# Code\\n```\\n#include <vector>\\n#include <algorithm>\\n#include <cmath>\\n\\nclass Solution {\\npublic:\\n    // Main function to sort the given vector of integers\\n    std::vector<int> sortArray(std::vector<int>& nums) {\\n        // Call the introSort function to sort the vector\\n        introSort(nums, 0, nums.size() - 1, 2 * floor(log2(nums.size())));\\n        return nums;\\n    }\\n\\n    // The introSort function combines quicksort, heapsort, and insertion sort\\n    void introSort(std::vector<int>& nums, int low, int high, int depthLimit) {\\n        int size = high - low + 1;\\n\\n        // Base case: return if the size is less than or equal to 1\\n        if (size <= 1) {\\n            return;\\n        }\\n\\n        // If the depth limit is reached, switch to heapsort\\n        if (depthLimit == 0) {\\n            std::make_heap(nums.begin() + low, nums.begin() + high + 1);\\n            std::sort_heap(nums.begin() + low, nums.begin() + high + 1);\\n            return;\\n        }\\n\\n        // If the size is smaller or equal to 16, switch to insertion sort\\n        if (size <= 16) {\\n            insertionSort(nums, low, high);\\n            return;\\n        }\\n\\n        // Otherwise, continue with quicksort\\n        int pivotIndex = partition(nums, low, high);\\n        introSort(nums, low, pivotIndex - 1, depthLimit - 1);\\n        introSort(nums, pivotIndex + 1, high, depthLimit - 1);\\n    }\\n\\n    // Insertion sort implementation\\n    void insertionSort(std::vector<int>& nums, int low, int high) {\\n        for (int i = low + 1; i <= high; i++) {\\n            int key = nums[i];\\n            int j = i - 1;\\n            while (j >= low && nums[j] > key) {\\n                nums[j + 1] = nums[j];\\n                j -= 1;\\n            }\\n            nums[j + 1] = key;\\n        }\\n    }\\n\\n    // Median-of-three function to select the pivot in quicksort\\n    int medianOfThree(std::vector<int>& nums, int low, int high) {\\n        int mid = (low + high) / 2;\\n        if (nums[low] > nums[mid]) {\\n            std::swap(nums[low], nums[mid]);\\n        }\\n        if (nums[low] > nums[high]) {\\n            std::swap(nums[low], nums[high]);\\n        }\\n        if (nums[mid] > nums[high]) {\\n            std::swap(nums[mid], nums[high]);\\n        }\\n        return mid;\\n    }\\n\\n    // Partition function for quicksort\\n    int partition(std::vector<int>& nums, int low, int high) {\\n        int pivotIndex = medianOfThree(nums, low, high);\\n        int pivot = nums[pivotIndex];\\n        std::swap(nums[pivotIndex], nums[high]);\\n\\n        int i = low - 1;\\n        for (int j = low; j < high; j++) {\\n            if (nums[j] < pivot) {\\n                i += 1;\\n                std::swap(nums[i], nums[j]);\\n            }\\n        }\\n        std::swap(nums[i + 1], nums[high]);\\n        return i + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort"
                ],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n#include <cmath>\\n\\nclass Solution {\\npublic:\\n    // Main function to sort the given vector of integers\\n    std::vector<int> sortArray(std::vector<int>& nums) {\\n        // Call the introSort function to sort the vector\\n        introSort(nums, 0, nums.size() - 1, 2 * floor(log2(nums.size())));\\n        return nums;\\n    }\\n\\n    // The introSort function combines quicksort, heapsort, and insertion sort\\n    void introSort(std::vector<int>& nums, int low, int high, int depthLimit) {\\n        int size = high - low + 1;\\n\\n        // Base case: return if the size is less than or equal to 1\\n        if (size <= 1) {\\n            return;\\n        }\\n\\n        // If the depth limit is reached, switch to heapsort\\n        if (depthLimit == 0) {\\n            std::make_heap(nums.begin() + low, nums.begin() + high + 1);\\n            std::sort_heap(nums.begin() + low, nums.begin() + high + 1);\\n            return;\\n        }\\n\\n        // If the size is smaller or equal to 16, switch to insertion sort\\n        if (size <= 16) {\\n            insertionSort(nums, low, high);\\n            return;\\n        }\\n\\n        // Otherwise, continue with quicksort\\n        int pivotIndex = partition(nums, low, high);\\n        introSort(nums, low, pivotIndex - 1, depthLimit - 1);\\n        introSort(nums, pivotIndex + 1, high, depthLimit - 1);\\n    }\\n\\n    // Insertion sort implementation\\n    void insertionSort(std::vector<int>& nums, int low, int high) {\\n        for (int i = low + 1; i <= high; i++) {\\n            int key = nums[i];\\n            int j = i - 1;\\n            while (j >= low && nums[j] > key) {\\n                nums[j + 1] = nums[j];\\n                j -= 1;\\n            }\\n            nums[j + 1] = key;\\n        }\\n    }\\n\\n    // Median-of-three function to select the pivot in quicksort\\n    int medianOfThree(std::vector<int>& nums, int low, int high) {\\n        int mid = (low + high) / 2;\\n        if (nums[low] > nums[mid]) {\\n            std::swap(nums[low], nums[mid]);\\n        }\\n        if (nums[low] > nums[high]) {\\n            std::swap(nums[low], nums[high]);\\n        }\\n        if (nums[mid] > nums[high]) {\\n            std::swap(nums[mid], nums[high]);\\n        }\\n        return mid;\\n    }\\n\\n    // Partition function for quicksort\\n    int partition(std::vector<int>& nums, int low, int high) {\\n        int pivotIndex = medianOfThree(nums, low, high);\\n        int pivot = nums[pivotIndex];\\n        std::swap(nums[pivotIndex], nums[high]);\\n\\n        int i = low - 1;\\n        for (int j = low; j < high; j++) {\\n            if (nums[j] < pivot) {\\n                i += 1;\\n                std::swap(nums[i], nums[j]);\\n            }\\n        }\\n        std::swap(nums[i + 1], nums[high]);\\n        return i + 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3244294,
                "title": "java-code-merge-sort-explain-line-by-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution {\\n//     public int[] sortArray(int[] nums) {\\n//\\n//       }\\n//  }\\n\\n\\n\\nclass Solution {\\n   \\n    // This function is called by the sortArray() function to divide the input array recursively\\n    public static void divide(int arr[], int si, int ei) {\\n        \\n        // Check if the sub-array has only one element or less\\n        if(si >= ei) {\\n            return; // If yes, return without dividing further\\n        }\\n        \\n        // Calculate the middle index of the sub-array\\n        int mid = si + (ei - si) / 2;\\n        \\n        // Recursively divide the left half of the array\\n        divide(arr, si, mid);\\n        \\n        // Recursively divide the right half of the array\\n        divide(arr, mid + 1, ei);\\n        \\n        // Merge the two sorted halves\\n        conquer(arr, si, mid, ei);\\n    }\\n    \\n    // This function is called by the divide() function to merge two sorted sub-arrays\\n    public static void conquer(int [] arr, int si, int mid, int ei) {\\n        \\n        // Create a new array to store the merged sub-array\\n        int merged[] = new int[ei - si + 1];\\n       \\n        // Initialize the indices for the left and right sub-arrays, and for the merged array\\n        int indx1 = si;\\n        int indx2 = mid + 1;\\n        int x = 0;\\n\\t\\t\\n        // Compare elements from both sub-arrays and add them to the merged array in ascending order\\n        while(indx1 <= mid && indx2 <= ei) {\\n            if(arr[indx1] <= arr[indx2]) {\\n                merged[x] = arr[indx1];\\n                x++;\\n                indx1++;\\n            } else {\\n                merged[x++] = arr[indx2++];\\n            }\\n        }\\n        \\n        // Add any remaining elements from the left sub-array to the merged array\\n        while(indx1 <= mid) {\\n            merged[x++] = arr[indx1++];\\n        }\\n        \\n        // Add any remaining elements from the right sub-array to the merged array\\n        while(indx2 <= ei) {\\n            merged[x++] = arr[indx2++];\\n        }\\n        \\n        // Copy the merged array back to the original array\\n        for(int i = 0, j = si; i < merged.length; i++, j++) {\\n            arr[j] = merged[i];\\n        }\\n    }\\n\\n    // This function is called to sort the input array using merge sort\\n    public int[] sortArray(int[] nums) {\\n        \\n        // Call the divide() function to start the merge sort\\n        divide(nums, 0, nums.length - 1);\\n        \\n        // Return the sorted array\\n        return nums;\\n    }\\n    \\n   \\n}\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// class Solution {\\n//     public int[] sortArray(int[] nums) {\\n//\\n//       }\\n//  }\\n\\n\\n\\nclass Solution {\\n   \\n    // This function is called by the sortArray() function to divide the input array recursively\\n    public static void divide(int arr[], int si, int ei) {\\n        \\n        // Check if the sub-array has only one element or less\\n        if(si >= ei) {\\n            return; // If yes, return without dividing further\\n        }\\n        \\n        // Calculate the middle index of the sub-array\\n        int mid = si + (ei - si) / 2;\\n        \\n        // Recursively divide the left half of the array\\n        divide(arr, si, mid);\\n        \\n        // Recursively divide the right half of the array\\n        divide(arr, mid + 1, ei);\\n        \\n        // Merge the two sorted halves\\n        conquer(arr, si, mid, ei);\\n    }\\n    \\n    // This function is called by the divide() function to merge two sorted sub-arrays\\n    public static void conquer(int [] arr, int si, int mid, int ei) {\\n        \\n        // Create a new array to store the merged sub-array\\n        int merged[] = new int[ei - si + 1];\\n       \\n        // Initialize the indices for the left and right sub-arrays, and for the merged array\\n        int indx1 = si;\\n        int indx2 = mid + 1;\\n        int x = 0;\\n\\t\\t\\n        // Compare elements from both sub-arrays and add them to the merged array in ascending order\\n        while(indx1 <= mid && indx2 <= ei) {\\n            if(arr[indx1] <= arr[indx2]) {\\n                merged[x] = arr[indx1];\\n                x++;\\n                indx1++;\\n            } else {\\n                merged[x++] = arr[indx2++];\\n            }\\n        }\\n        \\n        // Add any remaining elements from the left sub-array to the merged array\\n        while(indx1 <= mid) {\\n            merged[x++] = arr[indx1++];\\n        }\\n        \\n        // Add any remaining elements from the right sub-array to the merged array\\n        while(indx2 <= ei) {\\n            merged[x++] = arr[indx2++];\\n        }\\n        \\n        // Copy the merged array back to the original array\\n        for(int i = 0, j = si; i < merged.length; i++, j++) {\\n            arr[j] = merged[i];\\n        }\\n    }\\n\\n    // This function is called to sort the input array using merge sort\\n    public int[] sortArray(int[] nums) {\\n        \\n        // Call the divide() function to start the merge sort\\n        divide(nums, 0, nums.length - 1);\\n        \\n        // Return the sorted array\\n        return nums;\\n    }\\n    \\n   \\n}\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244243,
                "title": "java-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        int i=0;\\n        int sortedArray[] = new int[nums.length];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();  // using min Heap (arrange element itself in ascending order)\\n        for(int num : nums){\\n            pq.add(num);\\n        }\\n        while(!pq.isEmpty()){\\n            sortedArray[i] = pq.poll();\\n            i++;\\n        }\\n        return sortedArray;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int[] sortArray(int[] nums) {\\n        int i=0;\\n        int sortedArray[] = new int[nums.length];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();  // using min Heap (arrange element itself in ascending order)\\n        for(int num : nums){\\n            pq.add(num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3243712,
                "title": "sort-an-array-c-easty-approach-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n       sort(nums.begin(),nums.end());\\n       return nums;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n       sort(nums.begin(),nums.end());\\n       return nums;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243702,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> mergesorted(vector<int>&arr)\\n    {\\n        if(arr.size()==1)\\n        {\\n            return arr;\\n        }\\n        int dividesize=arr.size()/2;\\n        vector<int>merge1,merge2;\\n        for(int i=0;i<dividesize;i++)\\n        {\\n            merge1.push_back(arr[i]);\\n        }\\n        for(int i=dividesize;i<arr.size();i++)\\n        {\\n            merge2.push_back(arr[i]);\\n        }\\n        merge1=mergesorted(merge1);\\n        merge2=mergesorted(merge2);\\n        int ptr1=0,ptr2=0,ptr3=0;\\n        while(ptr3<arr.size())\\n        {\\n            if(ptr1==merge1.size())\\n            {\\n                arr[ptr3]=merge2[ptr2];\\n                ptr2++;\\n                ptr3++;\\n                continue;\\n            }\\n            if(ptr2==merge2.size())\\n            {\\n                arr[ptr3]=merge1[ptr1];\\n                ptr1++;\\n                ptr3++;\\n                continue;   \\n            }\\n            if(merge1[ptr1]<merge2[ptr2])\\n            {\\n                arr[ptr3]=merge1[ptr1];\\n                ptr1++;\\n                ptr3++;\\n            }\\n            else\\n            {\\n                arr[ptr3]=merge2[ptr2];\\n                ptr2++;\\n                ptr3++;\\n            }\\n        }\\n        return arr;\\n    }\\n    vector<int> sortArray(vector<int>&nums) \\n    {\\n        return mergesorted(nums);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> mergesorted(vector<int>&arr)\\n    {\\n        if(arr.size()==1)\\n        {\\n            return arr;\\n        }\\n        int dividesize=arr.size()/2;\\n        vector<int>merge1,merge2;\\n        for(int i=0;i<dividesize;i++)\\n        {\\n            merge1.push_back(arr[i]);\\n        }\\n        for(int i=dividesize;i<arr.size();i++)\\n        {\\n            merge2.push_back(arr[i]);\\n        }\\n        merge1=mergesorted(merge1);\\n        merge2=mergesorted(merge2);\\n        int ptr1=0,ptr2=0,ptr3=0;\\n        while(ptr3<arr.size())\\n        {\\n            if(ptr1==merge1.size())\\n            {\\n                arr[ptr3]=merge2[ptr2];\\n                ptr2++;\\n                ptr3++;\\n                continue;\\n            }\\n            if(ptr2==merge2.size())\\n            {\\n                arr[ptr3]=merge1[ptr1];\\n                ptr1++;\\n                ptr3++;\\n                continue;   \\n            }\\n            if(merge1[ptr1]<merge2[ptr2])\\n            {\\n                arr[ptr3]=merge1[ptr1];\\n                ptr1++;\\n                ptr3++;\\n            }\\n            else\\n            {\\n                arr[ptr3]=merge2[ptr2];\\n                ptr2++;\\n                ptr3++;\\n            }\\n        }\\n        return arr;\\n    }\\n    vector<int> sortArray(vector<int>&nums) \\n    {\\n        return mergesorted(nums);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243542,
                "title": "easiest-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Consider upvoting if found helpful\\n# Code\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        if len(nums)>1:\\n            mid=len(nums)//2\\n            left=nums[:mid]\\n            right=nums[mid:]\\n            self.sortArray(left)\\n            self.sortArray(right)\\n            i=j=k=0\\n            while i<len(left) and j<len(right):\\n                if left[i]<right[j]:\\n                    nums[k]=left[i]\\n                    i+=1\\n                else:\\n                    nums[k]=right[j]\\n                    j+=1\\n                k+=1\\n            while i<len(left):\\n                nums[k]=left[i]\\n                i+=1\\n                k+=1\\n            while j<len(right):\\n                nums[k]=right[j]\\n                j+=1\\n                k+=1\\n        return nums\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        if len(nums)>1:\\n            mid=len(nums)//2\\n            left=nums[:mid]\\n            right=nums[mid:]\\n            self.sortArray(left)\\n            self.sortArray(right)\\n            i=j=k=0\\n            while i<len(left) and j<len(right):\\n                if left[i]<right[j]:\\n                    nums[k]=left[i]\\n                    i+=1\\n                else:\\n                    nums[k]=right[j]\\n                    j+=1\\n                k+=1\\n            while i<len(left):\\n                nums[k]=left[i]\\n                i+=1\\n                k+=1\\n            while j<len(right):\\n                nums[k]=right[j]\\n                j+=1\\n                k+=1\\n        return nums\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243448,
                "title": "java-array-best-solution-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243320,
                "title": "merge-sort-using-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Question is to Sort the Array in minimun Space complexity and time complexity of O(nlog(n).\\nThe catch here is i used Used Merge sort but its Space Complexity is O(n) compared to Heap sort which has Space Complexity of O(1).\\n\\nIt is ok to do Merge sort but i recommed doing Heap Sort As per the question\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n1. Assign a Mid pointer \\n2. Now divide Ur Array into Two subarrays\\n3. Recurvisly Call the Function to divide such that it ends up being a single Value in the Array\\n4. Now u need to compare the left most element of ur left array with left most element of ur right array and then insert to orginal array\\n5. Use two pointers i,j to take care of both left and right list\\n6. With the help of K pointer we mantain the orginal array\\n7. First we need to check whether both array have valus and now we compare our both left and right arrays with the help of pointers\\n8. Now the next case is there is no element in the Right array not visited So we directly add them into our answer array\\n9. The final case is when there is no elemtn in left array we directly add it into our answer array\\n# Complexity\\n- Time complexity:O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sortArray(self, arr: List[int]) -> List[int]:\\n   \\n        if len(arr)>1:\\n            \\n            mid=len(arr)//2\\n            left_arr=arr[:mid]\\n            right_arr=arr[mid:]\\n            \\n            self.sortArray(left_arr)\\n            \\n            self.sortArray(right_arr)\\n            \\n            #merge set\\n            i,j=0,0\\n            k=0 #merge array index\\n            temp=[]\\n            while i<len(left_arr) and j<len(right_arr):\\n                if left_arr[i]<right_arr[j]:\\n                    arr[k]=left_arr[i]\\n                    i+=1\\n                    # k+=1\\n                else:\\n                    arr[k]=right_arr[j]\\n                    j+=1\\n                k+=1 \\n            while i<len(left_arr):\\n                arr[k]=left_arr[i]\\n                i+=1\\n                k+=1\\n                \\n            while j<len(right_arr):\\n                arr[k]=right_arr[j]\\n                j+=1\\n                k+=1\\n        return arr\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArray(self, arr: List[int]) -> List[int]:\\n   \\n        if len(arr)>1:\\n            \\n            mid=len(arr)//2\\n            left_arr=arr[:mid]\\n            right_arr=arr[mid:]\\n            \\n            self.sortArray(left_arr)\\n            \\n            self.sortArray(right_arr)\\n            \\n            #merge set\\n            i,j=0,0\\n            k=0 #merge array index\\n            temp=[]\\n            while i<len(left_arr) and j<len(right_arr):\\n                if left_arr[i]<right_arr[j]:\\n                    arr[k]=left_arr[i]\\n                    i+=1\\n                    # k+=1\\n                else:\\n                    arr[k]=right_arr[j]\\n                    j+=1\\n                k+=1 \\n            while i<len(left_arr):\\n                arr[k]=left_arr[i]\\n                i+=1\\n                k+=1\\n                \\n            while j<len(right_arr):\\n                arr[k]=right_arr[j]\\n                j+=1\\n                k+=1\\n        return arr\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243098,
                "title": "easy-and-fast-solution-explained",
                "content": "\\n# Approach\\nwell the approach is to use priority queue class, if you are not familiar with priority queue, the definition is: \"Represents a collection of items that have a value and a priority. On dequeue, the item with the lowest priority value is removed.\"\\nso by using a for loop we easily add nums[i] to the priority queue as both Element and Priority, so now we have our array sorted, we just use another for loop to add values to a list and for sake of having it sorted, we use Dequeue() method which the definition is : \"Removes and returns the minimal element from the PriorityQueue<TElement,TPriority> - that is, the element with the lowest priority value.\"\\n\\n\\n\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] SortArray(int[] nums) {\\n        // here we make the priority queue \\n       PriorityQueue<int,int> _sort = new PriorityQueue<int,int>();\\n        // here we make the output array\\n       int[] output=new int[nums.Length];\\n       for (int i = 0; i < nums.Length; i++)\\n        {\\n            // here we add nums[i] to the priority queue\\n            _sort.Enqueue(nums[i], nums[i]);\\n        }\\n        for (int j = 0; j <nums.Length; j++)\\n        {\\n            // here we add values to the output based on the lowest priority\\n            output[j]= _sort.Dequeue();\\n        }\\n        return output;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] SortArray(int[] nums) {\\n        // here we make the priority queue \\n       PriorityQueue<int,int> _sort = new PriorityQueue<int,int>();\\n        // here we make the output array\\n       int[] output=new int[nums.Length];\\n       for (int i = 0; i < nums.Length; i++)\\n        {\\n            // here we add nums[i] to the priority queue\\n            _sort.Enqueue(nums[i], nums[i]);\\n        }\\n        for (int j = 0; j <nums.Length; j++)\\n        {\\n            // here we add values to the output based on the lowest priority\\n            output[j]= _sort.Dequeue();\\n        }\\n        return output;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242713,
                "title": "merge-sort-solution-with-simulation-beats-82-java",
                "content": "# Intuition\\nDivide and Conquer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMerge Sort\\n<!-- Describe your approach to solving the problem. -->\\n\\nDetailed discussion in Bangla:\\n\\nhttps://youtu.be/94l1kqb-XIA\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        return mergeSort(nums, 0, nums.length);\\n    }\\n    private int[] mergeSort(int[] nums, int start, int end){\\n        if(end-start == 1){\\n            return new int[]{nums[start]};\\n        }\\n        // Divide...\\n        int mid = start + (end-start)/2;\\n\\n        int[] leftArr = mergeSort(nums, start, mid);\\n\\n        int[] rightArr = mergeSort(nums, mid, end);\\n\\n        int len1 = leftArr.length;\\n        int len2 = rightArr.length;\\n\\n        // Conquer...\\n        int[] mergedArr = new int[len1+len2];\\n        int i=0, j=0, k=0;\\n        while(i<len1 && j<len2){\\n            if(leftArr[i]<rightArr[j]){\\n                mergedArr[k++] = leftArr[i++];\\n            }\\n            else{\\n                mergedArr[k++] = rightArr[j++];\\n            }\\n        }\\n        \\n        while(i<len1){\\n            mergedArr[k++] = leftArr[i++]; \\n        }\\n\\n        while(j<len2){\\n            mergedArr[k++] = rightArr[j++];\\n        }\\n\\n        return mergedArr;\\n    }\\n}\\n```\\n\\nSubmission: https://leetcode.com/problems/sort-an-array/submissions/906934269/\\n\\n![image.png](https://assets.leetcode.com/users/images/0f4cdd3f-3919-455b-9f5f-ad362afdf4ba_1677653735.607323.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        return mergeSort(nums, 0, nums.length);\\n    }\\n    private int[] mergeSort(int[] nums, int start, int end){\\n        if(end-start == 1){\\n            return new int[]{nums[start]};\\n        }\\n        // Divide...\\n        int mid = start + (end-start)/2;\\n\\n        int[] leftArr = mergeSort(nums, start, mid);\\n\\n        int[] rightArr = mergeSort(nums, mid, end);\\n\\n        int len1 = leftArr.length;\\n        int len2 = rightArr.length;\\n\\n        // Conquer...\\n        int[] mergedArr = new int[len1+len2];\\n        int i=0, j=0, k=0;\\n        while(i<len1 && j<len2){\\n            if(leftArr[i]<rightArr[j]){\\n                mergedArr[k++] = leftArr[i++];\\n            }\\n            else{\\n                mergedArr[k++] = rightArr[j++];\\n            }\\n        }\\n        \\n        while(i<len1){\\n            mergedArr[k++] = leftArr[i++]; \\n        }\\n\\n        while(j<len2){\\n            mergedArr[k++] = rightArr[j++];\\n        }\\n\\n        return mergedArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242666,
                "title": "fast-c-typescript-solution-merge-sort",
                "content": "# \\u2B06\\uFE0FLike|\\uD83C\\uDFAFShare|\\u2B50Favourite\\n\\n# Runtime & Memory\\n![image.png](https://assets.leetcode.com/users/images/16827e93-dc52-4c83-bab2-d44d8184796f_1677652745.368328.png)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# C# Code\\n```\\npublic class Solution\\n{\\n    public int[] SortArray(int[] nums)\\n    {\\n        int[] temp = new int[nums.Length];\\n        MergeSort(nums, temp, 0, nums.Length - 1);\\n        return nums;\\n    }\\n\\n    private void MergeSort(int[] nums, int[] temp, int left, int right)\\n    {\\n        if (left < right)\\n        {\\n            int mid = (left + right) / 2;\\n            MergeSort(nums, temp, left, mid);\\n            MergeSort(nums, temp, mid + 1, right);\\n            Merge(nums, temp, left, mid, right);\\n        }\\n    }\\n\\n    private void Merge(int[] nums, int[] temp, int left, int mid, int right)\\n    {\\n        int i = left;\\n        int j = mid + 1;\\n        int k = left;\\n        while (i <= mid && j <= right)\\n        {\\n            if (nums[i] <= nums[j])\\n            {\\n                temp[k++] = nums[i++];\\n            }\\n            else\\n            {\\n                temp[k++] = nums[j++];\\n            }\\n        }\\n\\n        while (i <= mid)\\n        {\\n            temp[k++] = nums[i++];\\n        }\\n\\n        while (j <= right)\\n        {\\n            temp[k++] = nums[j++];\\n        }\\n\\n        for (int m = left; m <= right; m++)\\n        {\\n            nums[m] = temp[m];\\n        }\\n    }\\n}\\n```\\n\\n# TypeScript Code\\n```\\nfunction sortArray(nums: number[]): number[] {\\n    let temp: number[] = new Array(nums.length);\\n    mergeSort(nums, temp, 0, nums.length - 1);\\n    return nums;\\n};\\n\\nfunction mergeSort(nums: number[], temp: number[], left: number, right: number): void {\\n    if (left < right) {\\n        let mid: number = Math.floor((left + right) / 2);\\n        mergeSort(nums, temp, left, mid);\\n        mergeSort(nums, temp, mid + 1, right);\\n        merge(nums, temp, left, mid, right);\\n    }\\n}\\n\\nfunction merge(nums: number[], temp: number[], left: number, mid: number, right: number): void {\\n    let i: number = left;\\n    let j: number = mid + 1;\\n    let k: number = left;\\n    while (i <= mid && j <= right) {\\n        if (nums[i] <= nums[j]) {\\n            temp[k++] = nums[i++];\\n        }\\n        else {\\n            temp[k++] = nums[j++];\\n        }\\n    }\\n\\n    while (i <= mid) {\\n        temp[k++] = nums[i++];\\n    }\\n\\n    while (j <= right) {\\n        temp[k++] = nums[j++];\\n    }\\n\\n    for (let m: number = left; m <= right; m++) {\\n        nums[m] = temp[m];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "TypeScript",
                    "Array",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[] SortArray(int[] nums)\\n    {\\n        int[] temp = new int[nums.Length];\\n        MergeSort(nums, temp, 0, nums.Length - 1);\\n        return nums;\\n    }\\n\\n    private void MergeSort(int[] nums, int[] temp, int left, int right)\\n    {\\n        if (left < right)\\n        {\\n            int mid = (left + right) / 2;\\n            MergeSort(nums, temp, left, mid);\\n            MergeSort(nums, temp, mid + 1, right);\\n            Merge(nums, temp, left, mid, right);\\n        }\\n    }\\n\\n    private void Merge(int[] nums, int[] temp, int left, int mid, int right)\\n    {\\n        int i = left;\\n        int j = mid + 1;\\n        int k = left;\\n        while (i <= mid && j <= right)\\n        {\\n            if (nums[i] <= nums[j])\\n            {\\n                temp[k++] = nums[i++];\\n            }\\n            else\\n            {\\n                temp[k++] = nums[j++];\\n            }\\n        }\\n\\n        while (i <= mid)\\n        {\\n            temp[k++] = nums[i++];\\n        }\\n\\n        while (j <= right)\\n        {\\n            temp[k++] = nums[j++];\\n        }\\n\\n        for (int m = left; m <= right; m++)\\n        {\\n            nums[m] = temp[m];\\n        }\\n    }\\n}\\n```\n```\\nfunction sortArray(nums: number[]): number[] {\\n    let temp: number[] = new Array(nums.length);\\n    mergeSort(nums, temp, 0, nums.length - 1);\\n    return nums;\\n};\\n\\nfunction mergeSort(nums: number[], temp: number[], left: number, right: number): void {\\n    if (left < right) {\\n        let mid: number = Math.floor((left + right) / 2);\\n        mergeSort(nums, temp, left, mid);\\n        mergeSort(nums, temp, mid + 1, right);\\n        merge(nums, temp, left, mid, right);\\n    }\\n}\\n\\nfunction merge(nums: number[], temp: number[], left: number, mid: number, right: number): void {\\n    let i: number = left;\\n    let j: number = mid + 1;\\n    let k: number = left;\\n    while (i <= mid && j <= right) {\\n        if (nums[i] <= nums[j]) {\\n            temp[k++] = nums[i++];\\n        }\\n        else {\\n            temp[k++] = nums[j++];\\n        }\\n    }\\n\\n    while (i <= mid) {\\n        temp[k++] = nums[i++];\\n    }\\n\\n    while (j <= right) {\\n        temp[k++] = nums[j++];\\n    }\\n\\n    for (let m: number = left; m <= right; m++) {\\n        nums[m] = temp[m];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242596,
                "title": "swift-mergesort",
                "content": "# Complexity\\n- Time complexity:\\nThe time complexity of the sortArray function is O(n log n) where n is the length of the input array nums. This is because heap sort has an average time complexity of O(n log n) for sorting an array of n elements.\\n\\n- Space complexity:\\nThe space complexity of the function is O(1) because the sorting is done in-place, without using any additional memory proportional to the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    func sortArray(_ nums: [Int]) -> [Int] {\\n        var nums = nums\\n        heapify(&nums, nums.count) // O(n)\\n        for i in stride(from: nums.count - 1, through: 0, by: -1) { // O(n)\\n            nums.swapAt(0, i)\\n            siftDown(&nums, 0, i) // O(log n)\\n        }\\n        // O(n) + O(n) * O(log n) = O(n log n)\\n        return nums\\n    }\\n\\n    // O(n)\\n    func heapify(_ nums: inout [Int], _ n: Int) {\\n        for i in stride(from: n / 2, through: 0, by: -1) {\\n            siftDown(&nums, i, n)\\n        }\\n    }\\n\\n    // O(log n)\\n    func siftDown(_ nums: inout [Int], _ i: Int, _ n: Int) {\\n        let left = i * 2 + 1\\n        let right = i * 2 + 2\\n        var min = i\\n        if left < n, nums[i] < nums[left] {\\n            min = left\\n        }\\n        if right < n, nums[min] < nums[right] {\\n            min = right\\n        }\\n        guard min != i else { return }\\n        nums.swapAt(i, min)\\n        siftDown(&nums, min, n)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func sortArray(_ nums: [Int]) -> [Int] {\\n        var nums = nums\\n        heapify(&nums, nums.count) // O(n)\\n        for i in stride(from: nums.count - 1, through: 0, by: -1) { // O(n)\\n            nums.swapAt(0, i)\\n            siftDown(&nums, 0, i) // O(log n)\\n        }\\n        // O(n) + O(n) * O(log n) = O(n log n)\\n        return nums\\n    }\\n\\n    // O(n)\\n    func heapify(_ nums: inout [Int], _ n: Int) {\\n        for i in stride(from: n / 2, through: 0, by: -1) {\\n            siftDown(&nums, i, n)\\n        }\\n    }\\n\\n    // O(log n)\\n    func siftDown(_ nums: inout [Int], _ i: Int, _ n: Int) {\\n        let left = i * 2 + 1\\n        let right = i * 2 + 2\\n        var min = i\\n        if left < n, nums[i] < nums[left] {\\n            min = left\\n        }\\n        if right < n, nums[min] < nums[right] {\\n            min = right\\n        }\\n        guard min != i else { return }\\n        nums.swapAt(i, min)\\n        siftDown(&nums, min, n)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242472,
                "title": "java-quick-sort-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        quicksort(nums,0,nums.length-1);\\n        return nums;\\n    }\\n    public void quicksort(int[]nums,int l,int r){\\n        if(l<r){\\n            int pivot=quick(nums,l,r);\\n            quicksort(nums,l,pivot-1);\\n            quicksort(nums,pivot+1,r);\\n            \\n        }\\n    }\\n    public int quick(int[]arr,int low,int high){\\n        int pivot = arr[low];\\n        int i = low;\\n        int j = high;\\n\\n        while (i < j) {\\n            while (arr[i] <= pivot && i <= high - 1) {\\n                i++;\\n            }\\n\\n            while (arr[j] > pivot && j >= low) {\\n                j--;\\n            }\\n\\n            if (i < j){\\n                int t = arr[i]; \\n                arr[i] = arr[j]; \\n                arr[j] = t; \\n            }\\n        }\\n\\n        int t = arr[j]; \\n        arr[j] = arr[low]; \\n        arr[low] =t; \\n        return j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        quicksort(nums,0,nums.length-1);\\n        return nums;\\n    }\\n    public void quicksort(int[]nums,int l,int r){\\n        if(l<r){\\n            int pivot=quick(nums,l,r);\\n            quicksort(nums,l,pivot-1);\\n            quicksort(nums,pivot+1,r);\\n            \\n        }\\n    }\\n    public int quick(int[]arr,int low,int high){\\n        int pivot = arr[low];\\n        int i = low;\\n        int j = high;\\n\\n        while (i < j) {\\n            while (arr[i] <= pivot && i <= high - 1) {\\n                i++;\\n            }\\n\\n            while (arr[j] > pivot && j >= low) {\\n                j--;\\n            }\\n\\n            if (i < j){\\n                int t = arr[i]; \\n                arr[i] = arr[j]; \\n                arr[j] = t; \\n            }\\n        }\\n\\n        int t = arr[j]; \\n        arr[j] = arr[low]; \\n        arr[low] =t; \\n        return j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242046,
                "title": "c-simple-clear-and-concise-easy-to-understand-priority-queue-heaps",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        priority_queue<int, vector<int>, greater<int>> minHeap;\\n        for (auto &num:nums) minHeap.push(num);\\n        nums.clear();\\n        while (!minHeap.empty()) {\\n            nums.emplace_back(minHeap.top());\\n            minHeap.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        priority_queue<int, vector<int>, greater<int>> minHeap;\\n        for (auto &num:nums) minHeap.push(num);\\n        nums.clear();\\n        while (!minHeap.empty()) {\\n            nums.emplace_back(minHeap.top());\\n            minHeap.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241719,
                "title": "easy-solution-98-beats-o-n-complexity-bucket-sort-c-day-60-2023",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Bucket Sort\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. add 5e4 to all values bcz bucket sort will work only for non negative numbers \\n2. count every numbers frequency\\n3. print the numbers from 0th index\\n4. use dynamic memory allocation for memory save\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n![image.png](https://assets.leetcode.com/users/images/140225ee-4436-41a3-b23e-87a88ccce50a_1677629531.753817.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        int mx = 0, n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            nums[i] += 5e4;\\n            mx = max(mx, nums[i]);\\n        }\\n\\n        int *bucket = new int[mx + 1];\\n        memset(bucket, 0, (mx + 1) * sizeof(int));\\n\\n        for(auto it : nums)\\n            bucket[it]++;\\n        \\n        for(int i = 0, idx = 0; i <= mx; i++){\\n            while(bucket[i]){\\n                nums[idx++] = i - 5e4;\\n                bucket[i]--;\\n            }\\n        }\\n\\n        delete[] bucket;\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        int mx = 0, n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            nums[i] += 5e4;\\n            mx = max(mx, nums[i]);\\n        }\\n\\n        int *bucket = new int[mx + 1];\\n        memset(bucket, 0, (mx + 1) * sizeof(int));\\n\\n        for(auto it : nums)\\n            bucket[it]++;\\n        \\n        for(int i = 0, idx = 0; i <= mx; i++){\\n            while(bucket[i]){\\n                nums[idx++] = i - 5e4;\\n                bucket[i]--;\\n            }\\n        }\\n\\n        delete[] bucket;\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164193,
                "title": "merge-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] arr) {\\n        if(arr.length == 1){\\n            return arr;\\n        }\\n        int mid = arr.length / 2;\\n        int[] left = sortArray(Arrays.copyOfRange(arr, 0, mid));\\n        int[] right = sortArray(Arrays.copyOfRange(arr,mid,arr.length));\\n        return merge(left, right);\\n    }\\n    public int[] merge(int[] first, int[] second){\\n        int[] mix = new int[first.length + second.length];\\n        int i = 0;\\n        int j = 0;\\n        int k = 0;\\n        while(i < first.length && j < second.length){\\n            if(first[i] < second[j]){\\n                mix[k] = first[i];\\n                i++;\\n            }\\n            else{\\n                mix[k] = second[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n        while(i < first.length){\\n            mix[k] = first[i];\\n            i++;\\n            k++;\\n        }\\n        while(j < second.length){\\n            mix[k] = second[j];\\n            j++;\\n            k++;\\n        }\\n        return mix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] arr) {\\n        if(arr.length == 1){\\n            return arr;\\n        }\\n        int mid = arr.length / 2;\\n        int[] left = sortArray(Arrays.copyOfRange(arr, 0, mid));\\n        int[] right = sortArray(Arrays.copyOfRange(arr,mid,arr.length));\\n        return merge(left, right);\\n    }\\n    public int[] merge(int[] first, int[] second){\\n        int[] mix = new int[first.length + second.length];\\n        int i = 0;\\n        int j = 0;\\n        int k = 0;\\n        while(i < first.length && j < second.length){\\n            if(first[i] < second[j]){\\n                mix[k] = first[i];\\n                i++;\\n            }\\n            else{\\n                mix[k] = second[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n        while(i < first.length){\\n            mix[k] = first[i];\\n            i++;\\n            k++;\\n        }\\n        while(j < second.length){\\n            mix[k] = second[j];\\n            j++;\\n            k++;\\n        }\\n        return mix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136676,
                "title": "java-count-sort",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        if (nums == null || nums.length == 0) return null;\\n\\n        int[] count = new int[100001];\\n        for (int num : nums) ++count[num + 50000];\\n        for (int i = 1; i < 100001; ++i) count[i] += count[i - 1];\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        for (int i = n - 1; i >= 0; --i) {\\n            res[count[nums[i] + 50000] - 1] = nums[i];\\n            --count[nums[i] + 50000];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n        if (nums == null || nums.length == 0) return null;\\n\\n        int[] count = new int[100001];\\n        for (int num : nums) ++count[num + 50000];\\n        for (int i = 1; i < 100001; ++i) count[i] += count[i - 1];\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        for (int i = n - 1; i >= 0; --i) {\\n            res[count[nums[i] + 50000] - 1] = nums[i];\\n            --count[nums[i] + 50000];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040565,
                "title": "c-solution-beats-90-75-runtime",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n\\nvoid swap(int *a, int* b) {\\n    int temp = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nvoid heapify(int *arr, int n, int i) {\\n    int largest = i, l = 2 * i + 1, r = 2 * i + 2; \\n \\n    if (l < n && arr[l] > arr[largest])\\n        largest = l;\\n \\n    if (r < n && arr[r] > arr[largest])\\n        largest = r;\\n \\n    if (largest != i) {\\n        swap(&arr[i], &arr[largest]);\\n        heapify(arr, n, largest);\\n    }\\n}\\n\\nvoid buildHeap(int *arr, int n) {\\n    for (int i = (n / 2) - 1; i >= 0; i--) \\n        heapify(arr, n, i);\\n}\\n\\nint* sortArray(int* nums, int numsSize, int* returnSize){\\n    buildHeap(nums, numsSize);\\n    *returnSize = numsSize;\\n\\n    // Sort\\n    for (int i = numsSize - 1; i > 0; i--) {\\n        swap(&nums[i], &nums[0]);\\n        heapify(nums, i, 0);   \\n    }\\n\\n    return nums;    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n\\nvoid swap(int *a, int* b) {\\n    int temp = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nvoid heapify(int *arr, int n, int i) {\\n    int largest = i, l = 2 * i + 1, r = 2 * i + 2; \\n \\n    if (l < n && arr[l] > arr[largest])\\n        largest = l;\\n \\n    if (r < n && arr[r] > arr[largest])\\n        largest = r;\\n \\n    if (largest != i) {\\n        swap(&arr[i], &arr[largest]);\\n        heapify(arr, n, largest);\\n    }\\n}\\n\\nvoid buildHeap(int *arr, int n) {\\n    for (int i = (n / 2) - 1; i >= 0; i--) \\n        heapify(arr, n, i);\\n}\\n\\nint* sortArray(int* nums, int numsSize, int* returnSize){\\n    buildHeap(nums, numsSize);\\n    *returnSize = numsSize;\\n\\n    // Sort\\n    for (int i = numsSize - 1; i > 0; i--) {\\n        swap(&nums[i], &nums[0]);\\n        heapify(nums, i, 0);   \\n    }\\n\\n    return nums;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2849286,
                "title": "c-easiest-approach-anyone-can-understand-beginners-approach",
                "content": "# Intuition\\nPrerequisite: Priority Queue just take 5 minutes learn from Youtube\\n\\n# Approach\\nEasy\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& a) {\\n        vector<int>ans;\\n        priority_queue<int>p;\\n        for(auto &x:a)p.push(x);\\n        while(!p.empty())\\n        {\\n            ans.push_back(p.top());\\n            p.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& a) {\\n        vector<int>ans;\\n        priority_queue<int>p;\\n        for(auto &x:a)p.push(x);\\n        while(!p.empty())\\n        {\\n            ans.push_back(p.top());\\n            p.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805427,
                "title": "sort-the-array-using-heap-sort-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     void heapify(vector<int>&nums,int n,int i){\\n       int l=2*i+1;\\n       int r=2*i+2;\\n       int lar=i;\\n\\n       if(l<n && nums[l]>nums[lar])\\n          lar=l;\\n        if(r<n && nums[r]>nums[lar])\\n         lar=r;\\n\\n         if(lar!=i){\\n             swap(nums[lar],nums[i]);\\n             heapify(nums,n,lar);\\n         }\\n    }\\n     \\n    void buildheap(vector<int>&nums,int n){\\n        for(int i=(n-2)/2;i>=0;i--){\\n            heapify(nums,n,i);\\n        }\\n    }\\n\\n    void heapsort(vector<int>&nums,int n){\\n        buildheap(nums,n);\\n\\n        for(int i=n-1;i>=0;i--){\\n            swap(nums[i],nums[0]);\\n            heapify(nums,i,0);\\n        }\\n    }\\n\\n\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        heapsort(nums,nums.size());\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n     void heapify(vector<int>&nums,int n,int i){\\n       int l=2*i+1;\\n       int r=2*i+2;\\n       int lar=i;\\n\\n       if(l<n && nums[l]>nums[lar])\\n          lar=l;\\n        if(r<n && nums[r]>nums[lar])\\n         lar=r;\\n\\n         if(lar!=i){\\n             swap(nums[lar],nums[i]);\\n             heapify(nums,n,lar);\\n         }\\n    }\\n     \\n    void buildheap(vector<int>&nums,int n){\\n        for(int i=(n-2)/2;i>=0;i--){\\n            heapify(nums,n,i);\\n        }\\n    }\\n\\n    void heapsort(vector<int>&nums,int n){\\n        buildheap(nums,n);\\n\\n        for(int i=n-1;i>=0;i--){\\n            swap(nums[i],nums[0]);\\n            heapify(nums,i,0);\\n        }\\n    }\\n\\n\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        heapsort(nums,nums.size());\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780778,
                "title": "sort-an-array-merge-sort",
                "content": "**TIME COMPLEXITY :** O(NlogN)\\n\\n----------------------------------------------------------------------\\n\\'\\n\\n\\tclass Solution\\n\\t{\\n\\tpublic int[] sortArray(int[] nums) {\\n        if(nums.length == 1)\\n\\t\\t{\\n            return nums;\\n        }\\n        int len = nums.length;\\n        int mid = len/2;\\n        int[] left = sortArray(Arrays.copyOfRange(nums, 0, mid));\\n        int[] right = sortArray(Arrays.copyOfRange(nums, mid, len));\\n        return merge(left, right);\\n    }\\n    public int[] merge(int[] first, int[] second){\\n        int[] res = new int[first.length+second.length];\\n        int i = 0, j = 0, k = 0;\\n        while(i < first.length && j < second.length){\\n            if(first[i] < second[j]){\\n                res[k] = first[i];\\n                i++;\\n            }else{\\n                res[k] = second[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n        while(i < first.length){\\n            res[k] = first[i];\\n            i++;\\n            k++;\\n        }\\n        while(j < second.length){\\n            res[k] = second[j];\\n            j++;\\n            k++;\\n        }\\n        return res;\\n    }\\n}\\n\\n----------------------------------------------------------------------\\n",
                "solutionTags": [
                    "Array",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "class Solution\\n\\t{\\n\\tpublic int[] sortArray(int[] nums) {\\n        if(nums.length == 1)\\n\\t\\t{\\n            return nums;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2759465,
                "title": "bucket-sort-o-n-space-time-complexity",
                "content": "# Observations\\n- Bucket sort only works for non-negative numbers.\\n- Since $-5 \\\\cdot 10^4 \\\\leq nums[i] \\\\leq 5 \\\\cdot 10^4$, you can add $5 \\\\cdot 10^4$ to every $num[i]$. So $0 \\\\leq nums[i] \\\\leq 10^5$. Now you can use bucket sort.\\n- Use dynamic memory to reduce memory consumption.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        int maxi = 0, n = nums.size();\\n        for(int i = 0; i < n; ++i){\\n            nums[i] += 5e4;\\n            maxi = max(maxi, nums[i]);\\n        }\\n\\n        int *bucket = new int[maxi + 1];\\n        memset(bucket, 0, (maxi + 1) * sizeof(int));\\n\\n        for(int it : nums)\\n            bucket[it]++;\\n        \\n        for(int i = 0, idx = 0; i <= maxi; ++i){\\n            while(bucket[i]){\\n                nums[idx++] = i - 5e4;\\n                bucket[i]--;\\n            }\\n        }\\n\\n        delete[] bucket;\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArray(vector<int>& nums) {\\n        int maxi = 0, n = nums.size();\\n        for(int i = 0; i < n; ++i){\\n            nums[i] += 5e4;\\n            maxi = max(maxi, nums[i]);\\n        }\\n\\n        int *bucket = new int[maxi + 1];\\n        memset(bucket, 0, (maxi + 1) * sizeof(int));\\n\\n        for(int it : nums)\\n            bucket[it]++;\\n        \\n        for(int i = 0, idx = 0; i <= maxi; ++i){\\n            while(bucket[i]){\\n                nums[idx++] = i - 5e4;\\n                bucket[i]--;\\n            }\\n        }\\n\\n        delete[] bucket;\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745592,
                "title": "temir-sort",
                "content": "class Solution {\\n    public int[] sortArray(int[] nums) {\\n        TemirSort(nums);\\n        return nums;\\n    }\\n    public static void TemirSort(int []nums){\\n        Arrays.sort(nums);\\n        System.out.println(\"Made by Temir Sort\");\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] sortArray(int[] nums) {\\n        TemirSort(nums);\\n        return nums;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2672670,
                "title": "one-line-solution-in-java-simple-java-solution-kavinprashad-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n\\n        Arrays.sort(nums);\\n\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArray(int[] nums) {\\n\\n        Arrays.sort(nums);\\n\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558137,
                "title": "recursion-c",
                "content": "class Solution {\\n    void sort(vector<int>&n)\\n    {\\n        if(n.size()==0)\\n            return;\\n        int val=n[n.size()-1];\\n        n.pop_back();\\n        sort(n);\\n        insert(n,val);\\n    }\\n    void insert(vector<int>&n,int val)\\n    {\\n        if(n.size()==0||n[n.size()-1]<=val)\\n        {\\n            n.push_back(val);\\n            return;\\n        }\\n        int num=n[n.size()-1];\\n        n.pop_back();\\n        insert(n,val);\\n        n.push_back(num);\\n    }\\npublic:\\n    vector<int> sortArray(vector<int>& nums)\\n    {\\n        sort(nums);\\n        return nums;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    void sort(vector<int>&n)\\n    {\\n        if(n.size()==0)\\n            return;\\n        int val=n[n.size()-1];\\n        n.pop_back();\\n        sort(n);\\n        insert(n,val);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2507523,
                "title": "o-n-k-counting-sort-98-51",
                "content": "```\\nclass Solution {\\n    \\n    // Counting sort with negative offsets\\n    public int[] sortArray(int[] nums) {\\n        // No sorting needed if this is true\\n        if (nums.length < 2) {\\n            return nums;\\n        }\\n        \\n        // Make variables needed for map array\\n        int max = nums[0];\\n        int negOffset = 0; // Needed in case of negatives because there are no negative indices in arrays\\n        for (int n : nums) {\\n            max = Math.max(n, max);\\n            negOffset = Math.min(n, negOffset);\\n        }\\n        negOffset = -negOffset;\\n        \\n        // Create the map array\\n        int[] map = new int[max+negOffset+1];\\n        for (int n : nums)\\n            map[n+negOffset]++;\\n        \\n        // Going through map array and putting all elements back into original array sorted\\n        int arrI = 0;\\n        for (int i = 0; i < map.length; i++) {\\n            while (map[i]-- > 0) {\\n                nums[arrI++] = i - negOffset;\\n            }\\n        }\\n        \\n        return nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    // Counting sort with negative offsets\\n    public int[] sortArray(int[] nums) {\\n        // No sorting needed if this is true\\n        if (nums.length < 2) {\\n            return nums;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2423913,
                "title": "simple-solution-in-javascript-merge-sort-time-o-nlogn",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArray = function(nums) {\\n  mergeSort(nums, 0, nums.length - 1);\\n  return nums;\\n};\\n\\nfunction merge(arr, low, mid, high) {\\n  let n1 = mid - low + 1;\\n  let n2 = high - mid;\\n  let left = new Array(n1), right = new Array(n2);\\n  for (let i = 0; i < n1; i++) {\\n    left[i] = arr[low + i];\\n  }\\n  for (let i = 0; i < n2; i++) {\\n    right[i] = arr[mid + 1 + i];\\n  }\\n  let i = 0, j = 0, k = low;\\n  while (i < n1 && j < n2) {\\n    if (left[i] < right[j]) {\\n      arr[k++] = left[i++];\\n    } else {\\n      arr[k++] = right[j++];\\n    }\\n  }\\n  while (i < n1) {\\n    arr[k++] = left[i++];\\n  }\\n  while (j < n2) {\\n    arr[k++] = right[j++];\\n  }\\n}\\n\\nfunction mergeSort(arr, low, high) {\\n  if (low < high) {\\n    let mid = Math.floor((high + low) / 2);\\n    mergeSort(arr, low, mid);\\n    mergeSort(arr, mid + 1, high);\\n    merge(arr, low, mid, high);\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Merge Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArray = function(nums) {\\n  mergeSort(nums, 0, nums.length - 1);\\n  return nums;\\n};\\n\\nfunction merge(arr, low, mid, high) {\\n  let n1 = mid - low + 1;\\n  let n2 = high - mid;\\n  let left = new Array(n1), right = new Array(n2);\\n  for (let i = 0; i < n1; i++) {\\n    left[i] = arr[low + i];\\n  }\\n  for (let i = 0; i < n2; i++) {\\n    right[i] = arr[mid + 1 + i];\\n  }\\n  let i = 0, j = 0, k = low;\\n  while (i < n1 && j < n2) {\\n    if (left[i] < right[j]) {\\n      arr[k++] = left[i++];\\n    } else {\\n      arr[k++] = right[j++];\\n    }\\n  }\\n  while (i < n1) {\\n    arr[k++] = left[i++];\\n  }\\n  while (j < n2) {\\n    arr[k++] = right[j++];\\n  }\\n}\\n\\nfunction mergeSort(arr, low, high) {\\n  if (low < high) {\\n    let mid = Math.floor((high + low) / 2);\\n    mergeSort(arr, low, mid);\\n    mergeSort(arr, mid + 1, high);\\n    merge(arr, low, mid, high);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379276,
                "title": "c-clean-code-solution-using-min-heap",
                "content": "```\\nvector<int> sortArray(vector<int>& v) {\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<v.size();i++){\\n            pq.push(v[i]);\\n        }\\n        int i=0;\\n        while(!pq.empty()){\\n            v[i] = pq.top();\\n            pq.pop();\\n            i++;\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvector<int> sortArray(vector<int>& v) {\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<v.size();i++){\\n            pq.push(v[i]);\\n        }\\n        int i=0;\\n        while(!pq.empty()){\\n            v[i] = pq.top();\\n            pq.pop();\\n            i++;\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1568587,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1817818,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1817821,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1575387,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1818213,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1565234,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1818662,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1566972,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1818429,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1818377,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1568587,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1817818,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1817821,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1575387,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1818213,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1565234,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1818662,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1566972,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1818429,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1818377,
                "content": [
                    {
                        "username": "glorialearncoding",
                        "content": "The first time I tried the classic quicksort algorithm, it passed perfectly, with 11 cases passed.\\nTwo months later, I got \"Time Limit Exceeded\" with 11/13 passed."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "LOL facing the same thing right now, I have a good command on quick sort so used it instantly only to miss few testcases."
                    },
                    {
                        "username": "c8763yee",
                        "content": "or use heap sort if you want the smallest space complexity possible(O(1) auxiliary)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "use merge sort instead of quick sort"
                    },
                    {
                        "username": "jga111",
                        "content": "Quicksort worst case complexity is N^2"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Let's be honest, who here were as lazy as me and wrote ```sort(nums.begin(), nums.end())``` or ```Arrays.sort(nums)``` instead of actually writing merge sort algorithm?"
                    },
                    {
                        "username": "ritikydv64",
                        "content": "Then, the interviewer will be as lazy as you to send the offer letter."
                    },
                    {
                        "username": "Msey",
                        "content": "Similarly \"nums.OrderBy(x => x).ToArray();\""
                    },
                    {
                        "username": "nirajthakare",
                        "content": "I Made Typo In that too ."
                    },
                    {
                        "username": "cloudvy",
                        "content": "Ig you are supposed to implement quicksort here instead of merge sort, since it says to use as little memory as possible\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Same lmao"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le me, who used Arrays.sort(nums) \\uD83D\\uDE02"
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "This isn\\'t a useful thing to practice or test. There\\'s no room for creativity or interpretation - it\\'s seeing if you know canonical sorting algorithms."
                    },
                    {
                        "username": "hershey890",
                        "content": "regurgitating sorting algorithms is common in interviews, and its very helpful to have a question to practice it."
                    },
                    {
                        "username": "pyrus277",
                        "content": "Idk, it\\'s nice to have some questions on the site just for practice on the classics. "
                    },
                    {
                        "username": "CalCreate",
                        "content": "I felt like it was actually really useful to learn about the sorting algorithms. Sure we\\'ll probably never need to come up with our own algorithms like that in our jobs but it\\'s nice to be able to think different ways to partition and work with data. It\\'s worth it to dig into the DS & A if only to improve an understanding of the best and worst case run times. "
                    },
                    {
                        "username": "AlecLC",
                        "content": "And yet interviewers do ask it. So if you\\'re trying to get a job, yes it\\'s useful to practice"
                    },
                    {
                        "username": "sshrey06",
                        "content": "I was trying to implement quicksort in C++, but it is exceeding time limit. I even tried to submit answers that were posted in discussion. I also pasted exact solutions of quick sort in C++, even they were not working. \\nAnd exactly same/similar implementation in JAVA is working fine. Why and How?"
                    },
                    {
                        "username": "aelentux",
                        "content": "you can use random_shuffle before sorting"
                    },
                    {
                        "username": "daniel_de_darik",
                        "content": "[@bhavesh0124](/bhavesh0124) pick the pivot element randomly, it is possible to construct a test case, where always picking a pivot in the middle of range causes O(n^2)"
                    },
                    {
                        "username": "lostfish",
                        "content": "Try Three-way Partition"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "Same is happening with me, this is because the worst time complexity of quicksort is n^2, so there some is test case where it is running n^2. So this happens when the array is already sorted ascending or descending therefore the partition that will be created will be of size 1 and (n-1). So time complexity is O(n) + O(n-1) = O (n^2) "
                    },
                    {
                        "username": "ayodudewth",
                        "content": "Use QuickSort, but don\\'t pick the rightmost element as the pivot. Instead, use a random element as the pivot."
                    },
                    {
                        "username": "chouhanviky9",
                        "content": "randomizing pivot  still at 18/21 test case with TLE"
                    },
                    {
                        "username": "pyrus277",
                        "content": "[@sek788432](/sek788432) Same. In response I just added an extra bit to my base case conditional addressing that exact edge case, and then it passed lol:\n```\n if (len(nums) < 2) or (len(set(nums))==1):\n     return nums\n```"
                    },
                    {
                        "username": "sek788432",
                        "content": "still TLE when all elements having the same value"
                    },
                    {
                        "username": "_aka5h",
                        "content": "It maybe working but you still you can\\'t guarantee to avoid that N ^ 2 worst case."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "That, or pre-shuffle the array and use the first / last whatever element works best for your coding. And you still need to make sure you don\\'t do O(n^2) work in case of an array with all the same values."
                    },
                    {
                        "username": "Shanezzz",
                        "content": "Why is this question a medium level?"
                    },
                    {
                        "username": "user0813fz",
                        "content": "IDK"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Why mergeSort passes all the test cases while quickSort does not?"
                    },
                    {
                        "username": "vinni20",
                        "content": "Because the worst case complexity of quick sort is O(n^2) and the question says to solve it in O(nlogn ) strictly which is in case of merge sort. That is why "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "quicksort downside is when u encountered worst case `n^2`"
                    },
                    {
                        "username": "kamui_amaterasu33",
                        "content": "The point of this question should be to test different methods of sorting. If you force a TLE on most sorting methods that are O(n^2) and are clearly only accepting nlogn sorting methods, what is the point of this question then? It\\'s so ambiguous. Just say the runtime must be nlogn. So stupid."
                    },
                    {
                        "username": "0icy",
                        "content": "it does say that now"
                    },
                    {
                        "username": "bhavesh0124",
                        "content": "use merge sort"
                    },
                    {
                        "username": "skuila22",
                        "content": "heap sort might be the best option? TC O(nlogn) SC O(1) "
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "heapq is in build\\n"
                    },
                    {
                        "username": "LordRasputin",
                        "content": "Concerning quick sort:\\n\\nUse Hoare\\'s or Dutch national flag partitions.\\nIt doesn\\'t work with regular or even randomized partition,\\nbecause it handles badly repeated elements.\\n\\nThis is why it\\'s a medium level question."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Also merge sort performs way better then hoarse partition here."
                    },
                    {
                        "username": "boooom86608",
                        "content": "[@manmeet2341](/manmeet2341) Check my solution for Hoare\\'s partition it beats 65% memory wise and 24% time wise i think the only reason my solution can\\'t beat other is because most of the submission are in built-in methods which is strictly prohibited."
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here\\n\\nBut as far as Dutch National Flag partition is concerned it cannot be used here because the problem originally only solved repetition of 3 elements e.g. 0\\'s, 1\\'s and 2\\'s of course you change the implementation to support 4 or 5 categories of numbers but the catch is the algorithm will get complex and slow.\\nBecause we have to create partition for those categories of numbers. \\nIt is only only application to I would say 5 categories of number other than that it would not be practical."
                    },
                    {
                        "username": "manmeet2341",
                        "content": "I tried both Hoare's and Dutch national flag partition methods, and they to resulted in TLE."
                    }
                ]
            },
            {
                "id": 1818089,
                "content": [
                    {
                        "username": "watsize",
                        "content": "First, I tried quick sort but no lucky, It\\'s time limit exceeded."
                    },
                    {
                        "username": "Msey",
                        "content": "because it\\'s n^2 in worst cases"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "select the pivote element middle one\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "This is a reminder from Leetcode to revise old topics \\uD83D\\uDE02."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This question is awesome. Quicksort fails as it can easily lead to `n^2` complexity.\\n\\nSo check what other types of algorithms exist that their worst case is still `nlogn`.\\n\\nAlso check introsort (awesome implementation) for best case hybrid algorithms which is used in most modern frameworks."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "[@Athanasios-Kataras](/Athanasios-Kataras) Indeed, my bad, was thinking of sth else that uses an extra heap of O(n). I'm forgetting my sorting algos, apparently ;) So probably both heapsort and quicksort might be considered \"optimal\" solutions to today's challenge? And introsort :)"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@zvezdalion](/zvezdalion) Heapsort is an in-place algorithm. https://en.wikipedia.org/wiki/Heapsort Meaning no extra space is required appart from auxilary values. Both cases though use recursion so extra space is needed for both internally."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "quicksort does not fail, if implemented properly (like I did manage to in the end). Heapsort is not what they require, as it uses O(n) space, and the problem asks for:\n> smallest space complexity possible"
                    },
                    {
                        "username": "TiltedDice",
                        "content": "modified counting sort (because there are also values < 0)\\nhttps://www.ripublication.com/ijaer18/ijaerv13n1_28.pdf  (page 3 for guidance)"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "just one line answer in python but dont do it guys"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "less gooo\\n"
                    },
                    {
                        "username": "sr388",
                        "content": "Now a proper Python implementation of in-place quicksort gets LTE. The same code works fine 3 years ago. Could the moderator fix the time limit?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I guess you can pre-check if the array is already sorted and return immediately... Takes care of that pesky all \"2\"s array case which will forec your algo to be O(n^2)"
                    },
                    {
                        "username": "SpartanB312",
                        "content": "https://leetcode.com/submissions/detail/741193756/"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "And this, ladies and gentlemen, is why we use **library functions**! Off-by-ones and edge cases eating my head, even though I \"know\" quicksort. Not much value implementing from scratch, imho, but here I am, sinking 1+ hours of otherwise productive ( :D ) time! Solving it wasn't particularly satisfying, as I feel if you are to ask me to reimplement it next month same thing will happen. Unless you study it by heart, which is pointless considering we now have ChatGPT to study things by heart."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "One person has **no sense of humour** and does not like using library functions. Have fun implementing your own window manager in Haskell in your basement, hater!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "This is a bad answer. merge sort users aux space. quick sort doesn\\'t. Don\\'t use merge sort for primitive types."
                    }
                ]
            },
            {
                "id": 1818032,
                "content": [
                    {
                        "username": "watsize",
                        "content": "First, I tried quick sort but no lucky, It\\'s time limit exceeded."
                    },
                    {
                        "username": "Msey",
                        "content": "because it\\'s n^2 in worst cases"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "select the pivote element middle one\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "This is a reminder from Leetcode to revise old topics \\uD83D\\uDE02."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This question is awesome. Quicksort fails as it can easily lead to `n^2` complexity.\\n\\nSo check what other types of algorithms exist that their worst case is still `nlogn`.\\n\\nAlso check introsort (awesome implementation) for best case hybrid algorithms which is used in most modern frameworks."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "[@Athanasios-Kataras](/Athanasios-Kataras) Indeed, my bad, was thinking of sth else that uses an extra heap of O(n). I'm forgetting my sorting algos, apparently ;) So probably both heapsort and quicksort might be considered \"optimal\" solutions to today's challenge? And introsort :)"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@zvezdalion](/zvezdalion) Heapsort is an in-place algorithm. https://en.wikipedia.org/wiki/Heapsort Meaning no extra space is required appart from auxilary values. Both cases though use recursion so extra space is needed for both internally."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "quicksort does not fail, if implemented properly (like I did manage to in the end). Heapsort is not what they require, as it uses O(n) space, and the problem asks for:\n> smallest space complexity possible"
                    },
                    {
                        "username": "TiltedDice",
                        "content": "modified counting sort (because there are also values < 0)\\nhttps://www.ripublication.com/ijaer18/ijaerv13n1_28.pdf  (page 3 for guidance)"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "just one line answer in python but dont do it guys"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "less gooo\\n"
                    },
                    {
                        "username": "sr388",
                        "content": "Now a proper Python implementation of in-place quicksort gets LTE. The same code works fine 3 years ago. Could the moderator fix the time limit?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I guess you can pre-check if the array is already sorted and return immediately... Takes care of that pesky all \"2\"s array case which will forec your algo to be O(n^2)"
                    },
                    {
                        "username": "SpartanB312",
                        "content": "https://leetcode.com/submissions/detail/741193756/"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "And this, ladies and gentlemen, is why we use **library functions**! Off-by-ones and edge cases eating my head, even though I \"know\" quicksort. Not much value implementing from scratch, imho, but here I am, sinking 1+ hours of otherwise productive ( :D ) time! Solving it wasn't particularly satisfying, as I feel if you are to ask me to reimplement it next month same thing will happen. Unless you study it by heart, which is pointless considering we now have ChatGPT to study things by heart."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "One person has **no sense of humour** and does not like using library functions. Have fun implementing your own window manager in Haskell in your basement, hater!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "This is a bad answer. merge sort users aux space. quick sort doesn\\'t. Don\\'t use merge sort for primitive types."
                    }
                ]
            },
            {
                "id": 1818201,
                "content": [
                    {
                        "username": "watsize",
                        "content": "First, I tried quick sort but no lucky, It\\'s time limit exceeded."
                    },
                    {
                        "username": "Msey",
                        "content": "because it\\'s n^2 in worst cases"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "select the pivote element middle one\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "This is a reminder from Leetcode to revise old topics \\uD83D\\uDE02."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This question is awesome. Quicksort fails as it can easily lead to `n^2` complexity.\\n\\nSo check what other types of algorithms exist that their worst case is still `nlogn`.\\n\\nAlso check introsort (awesome implementation) for best case hybrid algorithms which is used in most modern frameworks."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "[@Athanasios-Kataras](/Athanasios-Kataras) Indeed, my bad, was thinking of sth else that uses an extra heap of O(n). I'm forgetting my sorting algos, apparently ;) So probably both heapsort and quicksort might be considered \"optimal\" solutions to today's challenge? And introsort :)"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@zvezdalion](/zvezdalion) Heapsort is an in-place algorithm. https://en.wikipedia.org/wiki/Heapsort Meaning no extra space is required appart from auxilary values. Both cases though use recursion so extra space is needed for both internally."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "quicksort does not fail, if implemented properly (like I did manage to in the end). Heapsort is not what they require, as it uses O(n) space, and the problem asks for:\n> smallest space complexity possible"
                    },
                    {
                        "username": "TiltedDice",
                        "content": "modified counting sort (because there are also values < 0)\\nhttps://www.ripublication.com/ijaer18/ijaerv13n1_28.pdf  (page 3 for guidance)"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "just one line answer in python but dont do it guys"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "less gooo\\n"
                    },
                    {
                        "username": "sr388",
                        "content": "Now a proper Python implementation of in-place quicksort gets LTE. The same code works fine 3 years ago. Could the moderator fix the time limit?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I guess you can pre-check if the array is already sorted and return immediately... Takes care of that pesky all \"2\"s array case which will forec your algo to be O(n^2)"
                    },
                    {
                        "username": "SpartanB312",
                        "content": "https://leetcode.com/submissions/detail/741193756/"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "And this, ladies and gentlemen, is why we use **library functions**! Off-by-ones and edge cases eating my head, even though I \"know\" quicksort. Not much value implementing from scratch, imho, but here I am, sinking 1+ hours of otherwise productive ( :D ) time! Solving it wasn't particularly satisfying, as I feel if you are to ask me to reimplement it next month same thing will happen. Unless you study it by heart, which is pointless considering we now have ChatGPT to study things by heart."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "One person has **no sense of humour** and does not like using library functions. Have fun implementing your own window manager in Haskell in your basement, hater!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "This is a bad answer. merge sort users aux space. quick sort doesn\\'t. Don\\'t use merge sort for primitive types."
                    }
                ]
            },
            {
                "id": 1818170,
                "content": [
                    {
                        "username": "watsize",
                        "content": "First, I tried quick sort but no lucky, It\\'s time limit exceeded."
                    },
                    {
                        "username": "Msey",
                        "content": "because it\\'s n^2 in worst cases"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "select the pivote element middle one\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "This is a reminder from Leetcode to revise old topics \\uD83D\\uDE02."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This question is awesome. Quicksort fails as it can easily lead to `n^2` complexity.\\n\\nSo check what other types of algorithms exist that their worst case is still `nlogn`.\\n\\nAlso check introsort (awesome implementation) for best case hybrid algorithms which is used in most modern frameworks."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "[@Athanasios-Kataras](/Athanasios-Kataras) Indeed, my bad, was thinking of sth else that uses an extra heap of O(n). I'm forgetting my sorting algos, apparently ;) So probably both heapsort and quicksort might be considered \"optimal\" solutions to today's challenge? And introsort :)"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@zvezdalion](/zvezdalion) Heapsort is an in-place algorithm. https://en.wikipedia.org/wiki/Heapsort Meaning no extra space is required appart from auxilary values. Both cases though use recursion so extra space is needed for both internally."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "quicksort does not fail, if implemented properly (like I did manage to in the end). Heapsort is not what they require, as it uses O(n) space, and the problem asks for:\n> smallest space complexity possible"
                    },
                    {
                        "username": "TiltedDice",
                        "content": "modified counting sort (because there are also values < 0)\\nhttps://www.ripublication.com/ijaer18/ijaerv13n1_28.pdf  (page 3 for guidance)"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "just one line answer in python but dont do it guys"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "less gooo\\n"
                    },
                    {
                        "username": "sr388",
                        "content": "Now a proper Python implementation of in-place quicksort gets LTE. The same code works fine 3 years ago. Could the moderator fix the time limit?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I guess you can pre-check if the array is already sorted and return immediately... Takes care of that pesky all \"2\"s array case which will forec your algo to be O(n^2)"
                    },
                    {
                        "username": "SpartanB312",
                        "content": "https://leetcode.com/submissions/detail/741193756/"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "And this, ladies and gentlemen, is why we use **library functions**! Off-by-ones and edge cases eating my head, even though I \"know\" quicksort. Not much value implementing from scratch, imho, but here I am, sinking 1+ hours of otherwise productive ( :D ) time! Solving it wasn't particularly satisfying, as I feel if you are to ask me to reimplement it next month same thing will happen. Unless you study it by heart, which is pointless considering we now have ChatGPT to study things by heart."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "One person has **no sense of humour** and does not like using library functions. Have fun implementing your own window manager in Haskell in your basement, hater!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "This is a bad answer. merge sort users aux space. quick sort doesn\\'t. Don\\'t use merge sort for primitive types."
                    }
                ]
            },
            {
                "id": 1818169,
                "content": [
                    {
                        "username": "watsize",
                        "content": "First, I tried quick sort but no lucky, It\\'s time limit exceeded."
                    },
                    {
                        "username": "Msey",
                        "content": "because it\\'s n^2 in worst cases"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "select the pivote element middle one\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "This is a reminder from Leetcode to revise old topics \\uD83D\\uDE02."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This question is awesome. Quicksort fails as it can easily lead to `n^2` complexity.\\n\\nSo check what other types of algorithms exist that their worst case is still `nlogn`.\\n\\nAlso check introsort (awesome implementation) for best case hybrid algorithms which is used in most modern frameworks."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "[@Athanasios-Kataras](/Athanasios-Kataras) Indeed, my bad, was thinking of sth else that uses an extra heap of O(n). I'm forgetting my sorting algos, apparently ;) So probably both heapsort and quicksort might be considered \"optimal\" solutions to today's challenge? And introsort :)"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@zvezdalion](/zvezdalion) Heapsort is an in-place algorithm. https://en.wikipedia.org/wiki/Heapsort Meaning no extra space is required appart from auxilary values. Both cases though use recursion so extra space is needed for both internally."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "quicksort does not fail, if implemented properly (like I did manage to in the end). Heapsort is not what they require, as it uses O(n) space, and the problem asks for:\n> smallest space complexity possible"
                    },
                    {
                        "username": "TiltedDice",
                        "content": "modified counting sort (because there are also values < 0)\\nhttps://www.ripublication.com/ijaer18/ijaerv13n1_28.pdf  (page 3 for guidance)"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "just one line answer in python but dont do it guys"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "less gooo\\n"
                    },
                    {
                        "username": "sr388",
                        "content": "Now a proper Python implementation of in-place quicksort gets LTE. The same code works fine 3 years ago. Could the moderator fix the time limit?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I guess you can pre-check if the array is already sorted and return immediately... Takes care of that pesky all \"2\"s array case which will forec your algo to be O(n^2)"
                    },
                    {
                        "username": "SpartanB312",
                        "content": "https://leetcode.com/submissions/detail/741193756/"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "And this, ladies and gentlemen, is why we use **library functions**! Off-by-ones and edge cases eating my head, even though I \"know\" quicksort. Not much value implementing from scratch, imho, but here I am, sinking 1+ hours of otherwise productive ( :D ) time! Solving it wasn't particularly satisfying, as I feel if you are to ask me to reimplement it next month same thing will happen. Unless you study it by heart, which is pointless considering we now have ChatGPT to study things by heart."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "One person has **no sense of humour** and does not like using library functions. Have fun implementing your own window manager in Haskell in your basement, hater!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "This is a bad answer. merge sort users aux space. quick sort doesn\\'t. Don\\'t use merge sort for primitive types."
                    }
                ]
            },
            {
                "id": 1817825,
                "content": [
                    {
                        "username": "watsize",
                        "content": "First, I tried quick sort but no lucky, It\\'s time limit exceeded."
                    },
                    {
                        "username": "Msey",
                        "content": "because it\\'s n^2 in worst cases"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "select the pivote element middle one\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "This is a reminder from Leetcode to revise old topics \\uD83D\\uDE02."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This question is awesome. Quicksort fails as it can easily lead to `n^2` complexity.\\n\\nSo check what other types of algorithms exist that their worst case is still `nlogn`.\\n\\nAlso check introsort (awesome implementation) for best case hybrid algorithms which is used in most modern frameworks."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "[@Athanasios-Kataras](/Athanasios-Kataras) Indeed, my bad, was thinking of sth else that uses an extra heap of O(n). I'm forgetting my sorting algos, apparently ;) So probably both heapsort and quicksort might be considered \"optimal\" solutions to today's challenge? And introsort :)"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@zvezdalion](/zvezdalion) Heapsort is an in-place algorithm. https://en.wikipedia.org/wiki/Heapsort Meaning no extra space is required appart from auxilary values. Both cases though use recursion so extra space is needed for both internally."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "quicksort does not fail, if implemented properly (like I did manage to in the end). Heapsort is not what they require, as it uses O(n) space, and the problem asks for:\n> smallest space complexity possible"
                    },
                    {
                        "username": "TiltedDice",
                        "content": "modified counting sort (because there are also values < 0)\\nhttps://www.ripublication.com/ijaer18/ijaerv13n1_28.pdf  (page 3 for guidance)"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "just one line answer in python but dont do it guys"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "less gooo\\n"
                    },
                    {
                        "username": "sr388",
                        "content": "Now a proper Python implementation of in-place quicksort gets LTE. The same code works fine 3 years ago. Could the moderator fix the time limit?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I guess you can pre-check if the array is already sorted and return immediately... Takes care of that pesky all \"2\"s array case which will forec your algo to be O(n^2)"
                    },
                    {
                        "username": "SpartanB312",
                        "content": "https://leetcode.com/submissions/detail/741193756/"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "And this, ladies and gentlemen, is why we use **library functions**! Off-by-ones and edge cases eating my head, even though I \"know\" quicksort. Not much value implementing from scratch, imho, but here I am, sinking 1+ hours of otherwise productive ( :D ) time! Solving it wasn't particularly satisfying, as I feel if you are to ask me to reimplement it next month same thing will happen. Unless you study it by heart, which is pointless considering we now have ChatGPT to study things by heart."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "One person has **no sense of humour** and does not like using library functions. Have fun implementing your own window manager in Haskell in your basement, hater!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "This is a bad answer. merge sort users aux space. quick sort doesn\\'t. Don\\'t use merge sort for primitive types."
                    }
                ]
            },
            {
                "id": 1795253,
                "content": [
                    {
                        "username": "watsize",
                        "content": "First, I tried quick sort but no lucky, It\\'s time limit exceeded."
                    },
                    {
                        "username": "Msey",
                        "content": "because it\\'s n^2 in worst cases"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "select the pivote element middle one\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "This is a reminder from Leetcode to revise old topics \\uD83D\\uDE02."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This question is awesome. Quicksort fails as it can easily lead to `n^2` complexity.\\n\\nSo check what other types of algorithms exist that their worst case is still `nlogn`.\\n\\nAlso check introsort (awesome implementation) for best case hybrid algorithms which is used in most modern frameworks."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "[@Athanasios-Kataras](/Athanasios-Kataras) Indeed, my bad, was thinking of sth else that uses an extra heap of O(n). I'm forgetting my sorting algos, apparently ;) So probably both heapsort and quicksort might be considered \"optimal\" solutions to today's challenge? And introsort :)"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@zvezdalion](/zvezdalion) Heapsort is an in-place algorithm. https://en.wikipedia.org/wiki/Heapsort Meaning no extra space is required appart from auxilary values. Both cases though use recursion so extra space is needed for both internally."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "quicksort does not fail, if implemented properly (like I did manage to in the end). Heapsort is not what they require, as it uses O(n) space, and the problem asks for:\n> smallest space complexity possible"
                    },
                    {
                        "username": "TiltedDice",
                        "content": "modified counting sort (because there are also values < 0)\\nhttps://www.ripublication.com/ijaer18/ijaerv13n1_28.pdf  (page 3 for guidance)"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "just one line answer in python but dont do it guys"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "less gooo\\n"
                    },
                    {
                        "username": "sr388",
                        "content": "Now a proper Python implementation of in-place quicksort gets LTE. The same code works fine 3 years ago. Could the moderator fix the time limit?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I guess you can pre-check if the array is already sorted and return immediately... Takes care of that pesky all \"2\"s array case which will forec your algo to be O(n^2)"
                    },
                    {
                        "username": "SpartanB312",
                        "content": "https://leetcode.com/submissions/detail/741193756/"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "And this, ladies and gentlemen, is why we use **library functions**! Off-by-ones and edge cases eating my head, even though I \"know\" quicksort. Not much value implementing from scratch, imho, but here I am, sinking 1+ hours of otherwise productive ( :D ) time! Solving it wasn't particularly satisfying, as I feel if you are to ask me to reimplement it next month same thing will happen. Unless you study it by heart, which is pointless considering we now have ChatGPT to study things by heart."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "One person has **no sense of humour** and does not like using library functions. Have fun implementing your own window manager in Haskell in your basement, hater!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "This is a bad answer. merge sort users aux space. quick sort doesn\\'t. Don\\'t use merge sort for primitive types."
                    }
                ]
            },
            {
                "id": 1576998,
                "content": [
                    {
                        "username": "watsize",
                        "content": "First, I tried quick sort but no lucky, It\\'s time limit exceeded."
                    },
                    {
                        "username": "Msey",
                        "content": "because it\\'s n^2 in worst cases"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "select the pivote element middle one\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "This is a reminder from Leetcode to revise old topics \\uD83D\\uDE02."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This question is awesome. Quicksort fails as it can easily lead to `n^2` complexity.\\n\\nSo check what other types of algorithms exist that their worst case is still `nlogn`.\\n\\nAlso check introsort (awesome implementation) for best case hybrid algorithms which is used in most modern frameworks."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "[@Athanasios-Kataras](/Athanasios-Kataras) Indeed, my bad, was thinking of sth else that uses an extra heap of O(n). I'm forgetting my sorting algos, apparently ;) So probably both heapsort and quicksort might be considered \"optimal\" solutions to today's challenge? And introsort :)"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@zvezdalion](/zvezdalion) Heapsort is an in-place algorithm. https://en.wikipedia.org/wiki/Heapsort Meaning no extra space is required appart from auxilary values. Both cases though use recursion so extra space is needed for both internally."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "quicksort does not fail, if implemented properly (like I did manage to in the end). Heapsort is not what they require, as it uses O(n) space, and the problem asks for:\n> smallest space complexity possible"
                    },
                    {
                        "username": "TiltedDice",
                        "content": "modified counting sort (because there are also values < 0)\\nhttps://www.ripublication.com/ijaer18/ijaerv13n1_28.pdf  (page 3 for guidance)"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "just one line answer in python but dont do it guys"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "less gooo\\n"
                    },
                    {
                        "username": "sr388",
                        "content": "Now a proper Python implementation of in-place quicksort gets LTE. The same code works fine 3 years ago. Could the moderator fix the time limit?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I guess you can pre-check if the array is already sorted and return immediately... Takes care of that pesky all \"2\"s array case which will forec your algo to be O(n^2)"
                    },
                    {
                        "username": "SpartanB312",
                        "content": "https://leetcode.com/submissions/detail/741193756/"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "And this, ladies and gentlemen, is why we use **library functions**! Off-by-ones and edge cases eating my head, even though I \"know\" quicksort. Not much value implementing from scratch, imho, but here I am, sinking 1+ hours of otherwise productive ( :D ) time! Solving it wasn't particularly satisfying, as I feel if you are to ask me to reimplement it next month same thing will happen. Unless you study it by heart, which is pointless considering we now have ChatGPT to study things by heart."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "One person has **no sense of humour** and does not like using library functions. Have fun implementing your own window manager in Haskell in your basement, hater!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "This is a bad answer. merge sort users aux space. quick sort doesn\\'t. Don\\'t use merge sort for primitive types."
                    }
                ]
            },
            {
                "id": 1818178,
                "content": [
                    {
                        "username": "watsize",
                        "content": "First, I tried quick sort but no lucky, It\\'s time limit exceeded."
                    },
                    {
                        "username": "Msey",
                        "content": "because it\\'s n^2 in worst cases"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "select the pivote element middle one\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "This is a reminder from Leetcode to revise old topics \\uD83D\\uDE02."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This question is awesome. Quicksort fails as it can easily lead to `n^2` complexity.\\n\\nSo check what other types of algorithms exist that their worst case is still `nlogn`.\\n\\nAlso check introsort (awesome implementation) for best case hybrid algorithms which is used in most modern frameworks."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "[@Athanasios-Kataras](/Athanasios-Kataras) Indeed, my bad, was thinking of sth else that uses an extra heap of O(n). I'm forgetting my sorting algos, apparently ;) So probably both heapsort and quicksort might be considered \"optimal\" solutions to today's challenge? And introsort :)"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@zvezdalion](/zvezdalion) Heapsort is an in-place algorithm. https://en.wikipedia.org/wiki/Heapsort Meaning no extra space is required appart from auxilary values. Both cases though use recursion so extra space is needed for both internally."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "quicksort does not fail, if implemented properly (like I did manage to in the end). Heapsort is not what they require, as it uses O(n) space, and the problem asks for:\n> smallest space complexity possible"
                    },
                    {
                        "username": "TiltedDice",
                        "content": "modified counting sort (because there are also values < 0)\\nhttps://www.ripublication.com/ijaer18/ijaerv13n1_28.pdf  (page 3 for guidance)"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "just one line answer in python but dont do it guys"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "less gooo\\n"
                    },
                    {
                        "username": "sr388",
                        "content": "Now a proper Python implementation of in-place quicksort gets LTE. The same code works fine 3 years ago. Could the moderator fix the time limit?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I guess you can pre-check if the array is already sorted and return immediately... Takes care of that pesky all \"2\"s array case which will forec your algo to be O(n^2)"
                    },
                    {
                        "username": "SpartanB312",
                        "content": "https://leetcode.com/submissions/detail/741193756/"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "And this, ladies and gentlemen, is why we use **library functions**! Off-by-ones and edge cases eating my head, even though I \"know\" quicksort. Not much value implementing from scratch, imho, but here I am, sinking 1+ hours of otherwise productive ( :D ) time! Solving it wasn't particularly satisfying, as I feel if you are to ask me to reimplement it next month same thing will happen. Unless you study it by heart, which is pointless considering we now have ChatGPT to study things by heart."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "One person has **no sense of humour** and does not like using library functions. Have fun implementing your own window manager in Haskell in your basement, hater!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "This is a bad answer. merge sort users aux space. quick sort doesn\\'t. Don\\'t use merge sort for primitive types."
                    }
                ]
            },
            {
                "id": 1742817,
                "content": [
                    {
                        "username": "watsize",
                        "content": "First, I tried quick sort but no lucky, It\\'s time limit exceeded."
                    },
                    {
                        "username": "Msey",
                        "content": "because it\\'s n^2 in worst cases"
                    },
                    {
                        "username": "Sameer_Hake",
                        "content": "select the pivote element middle one\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "This is a reminder from Leetcode to revise old topics \\uD83D\\uDE02."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This question is awesome. Quicksort fails as it can easily lead to `n^2` complexity.\\n\\nSo check what other types of algorithms exist that their worst case is still `nlogn`.\\n\\nAlso check introsort (awesome implementation) for best case hybrid algorithms which is used in most modern frameworks."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "[@Athanasios-Kataras](/Athanasios-Kataras) Indeed, my bad, was thinking of sth else that uses an extra heap of O(n). I'm forgetting my sorting algos, apparently ;) So probably both heapsort and quicksort might be considered \"optimal\" solutions to today's challenge? And introsort :)"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@zvezdalion](/zvezdalion) Heapsort is an in-place algorithm. https://en.wikipedia.org/wiki/Heapsort Meaning no extra space is required appart from auxilary values. Both cases though use recursion so extra space is needed for both internally."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "quicksort does not fail, if implemented properly (like I did manage to in the end). Heapsort is not what they require, as it uses O(n) space, and the problem asks for:\n> smallest space complexity possible"
                    },
                    {
                        "username": "TiltedDice",
                        "content": "modified counting sort (because there are also values < 0)\\nhttps://www.ripublication.com/ijaer18/ijaerv13n1_28.pdf  (page 3 for guidance)"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "just one line answer in python but dont do it guys"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "less gooo\\n"
                    },
                    {
                        "username": "sr388",
                        "content": "Now a proper Python implementation of in-place quicksort gets LTE. The same code works fine 3 years ago. Could the moderator fix the time limit?"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "I guess you can pre-check if the array is already sorted and return immediately... Takes care of that pesky all \"2\"s array case which will forec your algo to be O(n^2)"
                    },
                    {
                        "username": "SpartanB312",
                        "content": "https://leetcode.com/submissions/detail/741193756/"
                    },
                    {
                        "username": "zvezdalion",
                        "content": "And this, ladies and gentlemen, is why we use **library functions**! Off-by-ones and edge cases eating my head, even though I \"know\" quicksort. Not much value implementing from scratch, imho, but here I am, sinking 1+ hours of otherwise productive ( :D ) time! Solving it wasn't particularly satisfying, as I feel if you are to ask me to reimplement it next month same thing will happen. Unless you study it by heart, which is pointless considering we now have ChatGPT to study things by heart."
                    },
                    {
                        "username": "zvezdalion",
                        "content": "One person has **no sense of humour** and does not like using library functions. Have fun implementing your own window manager in Haskell in your basement, hater!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "This is a bad answer. merge sort users aux space. quick sort doesn\\'t. Don\\'t use merge sort for primitive types."
                    }
                ]
            },
            {
                "id": 2069575,
                "content": [
                    {
                        "username": "Rahul3060",
                        "content": "For below code \\'Time Limit Exceeded\\' error\\nWhat modification can I make to reduce execution time?\\n\\nclass Solution:\\n    def sortArray(self,nums: List[int]):\\n        self.quick_sort(nums, 0, len(nums) - 1)\\n        return nums\\n\\n    def quick_sort(self, nums, first, last):\\n        if first < last:\\n            p = self.partition(nums, first, last)\\n            self.quick_sort(nums, first, p - 1)\\n            self.quick_sort(nums, p + 1, last)\\n\\n    def partition(self, nums, first, last):\\n        pivot = nums[first]\\n        left = first + 1\\n        right = last\\n        while True:\\n            while left <= right and nums[left] <= pivot:\\n                left += 1\\n            while left <= right and nums[right] >= pivot:\\n                right -= 1\\n            if left > right:\\n                break\\n            else:\\n                nums[left], nums[right] = nums[right], nums[left]\\n        nums[first], nums[right] = nums[right], nums[first]\\n        return right"
                    },
                    {
                        "username": "kishore_001",
                        "content": "By using the priority queue we get the output as the time complexity as O(nlog(n))"
                    },
                    {
                        "username": "AndraPintilescu",
                        "content": "so i\\'ve tried merge sort but i get TLE. someone can help?\\n\\nhere\\'s my solution:\\n\\nclass Solution {\\npublic:\\n\\n    void merge(vector<int>&nums, int lb, int mid, int ub){\\n        vector<int> v;\\n        v.resize(nums.size());\\n        int i=lb,j=mid+1,k=lb;\\n        while(i<=mid && j<=ub){\\n            if(nums[i]<=nums[j]){\\n                v[k++]=nums[i++];\\n            }\\n            else{\\n                v[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid) v[k++]=nums[i++];\\n        while(j<=ub) v[k++]=nums[j++];\\n        for(int k=lb;k<=ub;k++) nums[k]=v[k];\\n    }\\n    void mergeSort(vector<int> &nums, int lb, int ub){\\n        if(lb<ub){\\n            int mid=lb+(ub-lb)/2;\\n            mergeSort(nums,lb,mid);\\n            mergeSort(nums,mid+1,ub);\\n            merge(nums,lb,mid,ub);\\n        }\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what I suggest is, under the merge function write a simple base case telling when the lb and ub are equal meaning the single element, return nums[lb]. Then catch those number is as first = mergeSort(nums,lb,mid) and                                                                         second = mergeSort(nums,mid+1,ub) Now pass first  and second to the merge, which would merge and return the merged values                                                                    In python this is how it would look                                                                                     def mergesort(self,low,high,nums):\\n        if low==high:\\n            return [nums[low]]\\n\\n        mid = int((low+high)/2)\\n        a = self.mergesort(low,mid,nums)\\n        b = self.mergesort(mid+1,high,nums)\\n        merged = self.merge(a,b)\\n        return merged                                                                                                                                                                                                                                                                                                                                                                                                                                                     def merge(self,leftarr,rightarr):\\n        #create a temp array\\n        temp = []\\n\\n        #length of the left array\\n        l1= len(leftarr)\\n        #length of the right array\\n        l2 = len(rightarr)\\n        #initialise the first pointer \\n        p1 = 0\\n        #intialise the second pointer\\n        p2 = 0\\n\\n        #keep interating untill one of the the pointers exhausts \\n        while(p1<l1 and p2<l2):\\n            #compare the values of the first pointer and seocnd pointer     \\n            if(leftarr[p1]<=rightarr[p2]):\\n                #if left pointer value is smaller or equal to the right pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(leftarr[p1])\\n                p1 = p1 + 1\\n\\n            else:\\n                #if right pointer value is smaller than the left pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(rightarr[p2])\\n                p2 = p2 + 1\\n\\n        #when it comes out it means that one of the array has exhausted\\n\\n        #keep adding the pending leftarray elements\\n        while(p1<l1):\\n            temp.append(leftarr[p1])\\n            p1 = p1+ 1\\n\\n        #keep adding the pending right array elements\\n        while(p2<l2):\\n            temp.append(rightarr[p2])\\n            p2 = p2+ 1\\n        \\n        \\n        return temp\\n                                                                                                                                    "
                    },
                    {
                        "username": "akshay_kota018",
                        "content": "Compile Error\\nLine 85: Char 25: error: use of undeclared identifier \\'Solution\\'\\n      vector<int> ret = Solution().sortArray(param_1); return ret;"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Lets say [-5,1,-3,-9,-2,0,-7,-8] is my array. Lets assume I am using the quick sort algorithm and picking my pivot element being the middle most element ie: int((high+low)/2). Could anyone give me a dry run using this? I tried this and was not able to achieve the sorting . Also, I tried the same problem using by picking the pivot element to be pivot = low and that seems to be working fine but when I tried the same  for large sorted input which contained about 5000 sorted numbers, it seems to give me TLE and that is why I though of  picking the middle element as pivot to tackle the issue, However was not able to sort. Can anyone help me?  \n*any thing wrong with the logic?*    \n\n                                                                                                                    `class Solve:\n    def __init__(self,nums):\n        self.arr = nums\n\n    def findpivot(self,low,high):\n        pivot = int((low+high)/2)\n        #pivot = low\n        #pivot = int((low+high)/2)\n        i = low\n        j = high\n        #print('outside the while:',pivot,low,high)\n        while(i<j):\n            #print(\"hi\")\n        #find the element that is greater than the pivot \n            while(i<=high and self.arr[i] <= self.arr[pivot]):\n                    i = i+ 1\n\n\n            \n                \n            while(j>=low and self.arr[j] > self.arr[pivot]):\n                j = j - 1\n\n\n            #print(\"i:\",i,\"j:\",j)\n            if(i<j):\n\n               # print(\"swapping indices\",i,j)\n                temp = self.arr[i]\n                self.arr[i] = self.arr[j]\n                self.arr[j] = temp\n                #print(\"after swapping\",self.arr)\n\n            \n            \n\n        #print(\"current pivot index\",j)\n        temp = self.arr[j]\n        self.arr[j] = self.arr[pivot]\n        self.arr[pivot] = temp\n\n        #print(\"after swapping the pivot\",self.arr)\n        return j\n\n\n    def sort(self,low,high):\n\n        if(low < high):\n            pivot = self.findpivot(low,high)\n            self.sort(low,pivot-1)\n            self.sort(pivot+1,high)\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        low = 0\n        high = len(nums)-1\n        S = Solve(nums)\n        S.sort(low,high)\n        print(S.arr)\n        return S.arr    \n        `"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Java 8 using merge sort\\n`public int[] sortArray(int[] nums) {\\n        return divideArray(0, nums.length - 1, nums);\\n    }\\n\\n    public int[] divideArray(int lower, int higher, int[] nums) {\\n        if (lower < higher) {\\n            int middle = ((lower + higher) / 2);\\n            // left part\\n            divideArray(lower, middle, nums);\\n            // right part\\n            divideArray(middle + 1, higher, nums);\\n            // merge the array\\n            mergeArray(lower, middle, higher, nums);\\n        }\\n        return nums;\\n    }\\n\\n    public void mergeArray(int lower, int middle, int higher, int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for (int i = lower; i <= higher; i++) {\\n            temp[i] = nums[i];\\n        }\\n        int i = lower;\\n        int j = middle + 1;\\n        int k = lower;\\n        while (i <= middle && j <= higher) {\\n            if (temp[i] <= temp[j]) {\\n                nums[k] = temp[i];\\n                i++;\\n                k++;\\n            } else {\\n                nums[k] = temp[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        // remaining elements from left part\\n        while (i <= middle) {\\n            nums[k] = temp[i];\\n            i++;\\n            k++;\\n        }\\n        // remaining elements from right part\\n         while (j <= higher) {\\n            nums[k] = temp[j];\\n            j++;\\n            k++;\\n        }\\n    }`"
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "easy easy  && easy\\n"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Can we do this with minHeap ,but still it is in-build in python ?? so do we need to implement any other algo of O(nlogn) T.C ??? "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Any built-in functions or features are forbidden. You can choose any known sorting algorithm in `O(n * Log(n))`, such as `merge insertion sort`, and implement it."
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Anyone who used built-in functions like `std::sort` will burn in hell in a separate VIP cauldron of 5000 degree boiling water."
                    }
                ]
            },
            {
                "id": 2069559,
                "content": [
                    {
                        "username": "Rahul3060",
                        "content": "For below code \\'Time Limit Exceeded\\' error\\nWhat modification can I make to reduce execution time?\\n\\nclass Solution:\\n    def sortArray(self,nums: List[int]):\\n        self.quick_sort(nums, 0, len(nums) - 1)\\n        return nums\\n\\n    def quick_sort(self, nums, first, last):\\n        if first < last:\\n            p = self.partition(nums, first, last)\\n            self.quick_sort(nums, first, p - 1)\\n            self.quick_sort(nums, p + 1, last)\\n\\n    def partition(self, nums, first, last):\\n        pivot = nums[first]\\n        left = first + 1\\n        right = last\\n        while True:\\n            while left <= right and nums[left] <= pivot:\\n                left += 1\\n            while left <= right and nums[right] >= pivot:\\n                right -= 1\\n            if left > right:\\n                break\\n            else:\\n                nums[left], nums[right] = nums[right], nums[left]\\n        nums[first], nums[right] = nums[right], nums[first]\\n        return right"
                    },
                    {
                        "username": "kishore_001",
                        "content": "By using the priority queue we get the output as the time complexity as O(nlog(n))"
                    },
                    {
                        "username": "AndraPintilescu",
                        "content": "so i\\'ve tried merge sort but i get TLE. someone can help?\\n\\nhere\\'s my solution:\\n\\nclass Solution {\\npublic:\\n\\n    void merge(vector<int>&nums, int lb, int mid, int ub){\\n        vector<int> v;\\n        v.resize(nums.size());\\n        int i=lb,j=mid+1,k=lb;\\n        while(i<=mid && j<=ub){\\n            if(nums[i]<=nums[j]){\\n                v[k++]=nums[i++];\\n            }\\n            else{\\n                v[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid) v[k++]=nums[i++];\\n        while(j<=ub) v[k++]=nums[j++];\\n        for(int k=lb;k<=ub;k++) nums[k]=v[k];\\n    }\\n    void mergeSort(vector<int> &nums, int lb, int ub){\\n        if(lb<ub){\\n            int mid=lb+(ub-lb)/2;\\n            mergeSort(nums,lb,mid);\\n            mergeSort(nums,mid+1,ub);\\n            merge(nums,lb,mid,ub);\\n        }\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what I suggest is, under the merge function write a simple base case telling when the lb and ub are equal meaning the single element, return nums[lb]. Then catch those number is as first = mergeSort(nums,lb,mid) and                                                                         second = mergeSort(nums,mid+1,ub) Now pass first  and second to the merge, which would merge and return the merged values                                                                    In python this is how it would look                                                                                     def mergesort(self,low,high,nums):\\n        if low==high:\\n            return [nums[low]]\\n\\n        mid = int((low+high)/2)\\n        a = self.mergesort(low,mid,nums)\\n        b = self.mergesort(mid+1,high,nums)\\n        merged = self.merge(a,b)\\n        return merged                                                                                                                                                                                                                                                                                                                                                                                                                                                     def merge(self,leftarr,rightarr):\\n        #create a temp array\\n        temp = []\\n\\n        #length of the left array\\n        l1= len(leftarr)\\n        #length of the right array\\n        l2 = len(rightarr)\\n        #initialise the first pointer \\n        p1 = 0\\n        #intialise the second pointer\\n        p2 = 0\\n\\n        #keep interating untill one of the the pointers exhausts \\n        while(p1<l1 and p2<l2):\\n            #compare the values of the first pointer and seocnd pointer     \\n            if(leftarr[p1]<=rightarr[p2]):\\n                #if left pointer value is smaller or equal to the right pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(leftarr[p1])\\n                p1 = p1 + 1\\n\\n            else:\\n                #if right pointer value is smaller than the left pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(rightarr[p2])\\n                p2 = p2 + 1\\n\\n        #when it comes out it means that one of the array has exhausted\\n\\n        #keep adding the pending leftarray elements\\n        while(p1<l1):\\n            temp.append(leftarr[p1])\\n            p1 = p1+ 1\\n\\n        #keep adding the pending right array elements\\n        while(p2<l2):\\n            temp.append(rightarr[p2])\\n            p2 = p2+ 1\\n        \\n        \\n        return temp\\n                                                                                                                                    "
                    },
                    {
                        "username": "akshay_kota018",
                        "content": "Compile Error\\nLine 85: Char 25: error: use of undeclared identifier \\'Solution\\'\\n      vector<int> ret = Solution().sortArray(param_1); return ret;"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Lets say [-5,1,-3,-9,-2,0,-7,-8] is my array. Lets assume I am using the quick sort algorithm and picking my pivot element being the middle most element ie: int((high+low)/2). Could anyone give me a dry run using this? I tried this and was not able to achieve the sorting . Also, I tried the same problem using by picking the pivot element to be pivot = low and that seems to be working fine but when I tried the same  for large sorted input which contained about 5000 sorted numbers, it seems to give me TLE and that is why I though of  picking the middle element as pivot to tackle the issue, However was not able to sort. Can anyone help me?  \n*any thing wrong with the logic?*    \n\n                                                                                                                    `class Solve:\n    def __init__(self,nums):\n        self.arr = nums\n\n    def findpivot(self,low,high):\n        pivot = int((low+high)/2)\n        #pivot = low\n        #pivot = int((low+high)/2)\n        i = low\n        j = high\n        #print('outside the while:',pivot,low,high)\n        while(i<j):\n            #print(\"hi\")\n        #find the element that is greater than the pivot \n            while(i<=high and self.arr[i] <= self.arr[pivot]):\n                    i = i+ 1\n\n\n            \n                \n            while(j>=low and self.arr[j] > self.arr[pivot]):\n                j = j - 1\n\n\n            #print(\"i:\",i,\"j:\",j)\n            if(i<j):\n\n               # print(\"swapping indices\",i,j)\n                temp = self.arr[i]\n                self.arr[i] = self.arr[j]\n                self.arr[j] = temp\n                #print(\"after swapping\",self.arr)\n\n            \n            \n\n        #print(\"current pivot index\",j)\n        temp = self.arr[j]\n        self.arr[j] = self.arr[pivot]\n        self.arr[pivot] = temp\n\n        #print(\"after swapping the pivot\",self.arr)\n        return j\n\n\n    def sort(self,low,high):\n\n        if(low < high):\n            pivot = self.findpivot(low,high)\n            self.sort(low,pivot-1)\n            self.sort(pivot+1,high)\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        low = 0\n        high = len(nums)-1\n        S = Solve(nums)\n        S.sort(low,high)\n        print(S.arr)\n        return S.arr    \n        `"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Java 8 using merge sort\\n`public int[] sortArray(int[] nums) {\\n        return divideArray(0, nums.length - 1, nums);\\n    }\\n\\n    public int[] divideArray(int lower, int higher, int[] nums) {\\n        if (lower < higher) {\\n            int middle = ((lower + higher) / 2);\\n            // left part\\n            divideArray(lower, middle, nums);\\n            // right part\\n            divideArray(middle + 1, higher, nums);\\n            // merge the array\\n            mergeArray(lower, middle, higher, nums);\\n        }\\n        return nums;\\n    }\\n\\n    public void mergeArray(int lower, int middle, int higher, int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for (int i = lower; i <= higher; i++) {\\n            temp[i] = nums[i];\\n        }\\n        int i = lower;\\n        int j = middle + 1;\\n        int k = lower;\\n        while (i <= middle && j <= higher) {\\n            if (temp[i] <= temp[j]) {\\n                nums[k] = temp[i];\\n                i++;\\n                k++;\\n            } else {\\n                nums[k] = temp[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        // remaining elements from left part\\n        while (i <= middle) {\\n            nums[k] = temp[i];\\n            i++;\\n            k++;\\n        }\\n        // remaining elements from right part\\n         while (j <= higher) {\\n            nums[k] = temp[j];\\n            j++;\\n            k++;\\n        }\\n    }`"
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "easy easy  && easy\\n"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Can we do this with minHeap ,but still it is in-build in python ?? so do we need to implement any other algo of O(nlogn) T.C ??? "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Any built-in functions or features are forbidden. You can choose any known sorting algorithm in `O(n * Log(n))`, such as `merge insertion sort`, and implement it."
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Anyone who used built-in functions like `std::sort` will burn in hell in a separate VIP cauldron of 5000 degree boiling water."
                    }
                ]
            },
            {
                "id": 2054770,
                "content": [
                    {
                        "username": "Rahul3060",
                        "content": "For below code \\'Time Limit Exceeded\\' error\\nWhat modification can I make to reduce execution time?\\n\\nclass Solution:\\n    def sortArray(self,nums: List[int]):\\n        self.quick_sort(nums, 0, len(nums) - 1)\\n        return nums\\n\\n    def quick_sort(self, nums, first, last):\\n        if first < last:\\n            p = self.partition(nums, first, last)\\n            self.quick_sort(nums, first, p - 1)\\n            self.quick_sort(nums, p + 1, last)\\n\\n    def partition(self, nums, first, last):\\n        pivot = nums[first]\\n        left = first + 1\\n        right = last\\n        while True:\\n            while left <= right and nums[left] <= pivot:\\n                left += 1\\n            while left <= right and nums[right] >= pivot:\\n                right -= 1\\n            if left > right:\\n                break\\n            else:\\n                nums[left], nums[right] = nums[right], nums[left]\\n        nums[first], nums[right] = nums[right], nums[first]\\n        return right"
                    },
                    {
                        "username": "kishore_001",
                        "content": "By using the priority queue we get the output as the time complexity as O(nlog(n))"
                    },
                    {
                        "username": "AndraPintilescu",
                        "content": "so i\\'ve tried merge sort but i get TLE. someone can help?\\n\\nhere\\'s my solution:\\n\\nclass Solution {\\npublic:\\n\\n    void merge(vector<int>&nums, int lb, int mid, int ub){\\n        vector<int> v;\\n        v.resize(nums.size());\\n        int i=lb,j=mid+1,k=lb;\\n        while(i<=mid && j<=ub){\\n            if(nums[i]<=nums[j]){\\n                v[k++]=nums[i++];\\n            }\\n            else{\\n                v[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid) v[k++]=nums[i++];\\n        while(j<=ub) v[k++]=nums[j++];\\n        for(int k=lb;k<=ub;k++) nums[k]=v[k];\\n    }\\n    void mergeSort(vector<int> &nums, int lb, int ub){\\n        if(lb<ub){\\n            int mid=lb+(ub-lb)/2;\\n            mergeSort(nums,lb,mid);\\n            mergeSort(nums,mid+1,ub);\\n            merge(nums,lb,mid,ub);\\n        }\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what I suggest is, under the merge function write a simple base case telling when the lb and ub are equal meaning the single element, return nums[lb]. Then catch those number is as first = mergeSort(nums,lb,mid) and                                                                         second = mergeSort(nums,mid+1,ub) Now pass first  and second to the merge, which would merge and return the merged values                                                                    In python this is how it would look                                                                                     def mergesort(self,low,high,nums):\\n        if low==high:\\n            return [nums[low]]\\n\\n        mid = int((low+high)/2)\\n        a = self.mergesort(low,mid,nums)\\n        b = self.mergesort(mid+1,high,nums)\\n        merged = self.merge(a,b)\\n        return merged                                                                                                                                                                                                                                                                                                                                                                                                                                                     def merge(self,leftarr,rightarr):\\n        #create a temp array\\n        temp = []\\n\\n        #length of the left array\\n        l1= len(leftarr)\\n        #length of the right array\\n        l2 = len(rightarr)\\n        #initialise the first pointer \\n        p1 = 0\\n        #intialise the second pointer\\n        p2 = 0\\n\\n        #keep interating untill one of the the pointers exhausts \\n        while(p1<l1 and p2<l2):\\n            #compare the values of the first pointer and seocnd pointer     \\n            if(leftarr[p1]<=rightarr[p2]):\\n                #if left pointer value is smaller or equal to the right pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(leftarr[p1])\\n                p1 = p1 + 1\\n\\n            else:\\n                #if right pointer value is smaller than the left pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(rightarr[p2])\\n                p2 = p2 + 1\\n\\n        #when it comes out it means that one of the array has exhausted\\n\\n        #keep adding the pending leftarray elements\\n        while(p1<l1):\\n            temp.append(leftarr[p1])\\n            p1 = p1+ 1\\n\\n        #keep adding the pending right array elements\\n        while(p2<l2):\\n            temp.append(rightarr[p2])\\n            p2 = p2+ 1\\n        \\n        \\n        return temp\\n                                                                                                                                    "
                    },
                    {
                        "username": "akshay_kota018",
                        "content": "Compile Error\\nLine 85: Char 25: error: use of undeclared identifier \\'Solution\\'\\n      vector<int> ret = Solution().sortArray(param_1); return ret;"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Lets say [-5,1,-3,-9,-2,0,-7,-8] is my array. Lets assume I am using the quick sort algorithm and picking my pivot element being the middle most element ie: int((high+low)/2). Could anyone give me a dry run using this? I tried this and was not able to achieve the sorting . Also, I tried the same problem using by picking the pivot element to be pivot = low and that seems to be working fine but when I tried the same  for large sorted input which contained about 5000 sorted numbers, it seems to give me TLE and that is why I though of  picking the middle element as pivot to tackle the issue, However was not able to sort. Can anyone help me?  \n*any thing wrong with the logic?*    \n\n                                                                                                                    `class Solve:\n    def __init__(self,nums):\n        self.arr = nums\n\n    def findpivot(self,low,high):\n        pivot = int((low+high)/2)\n        #pivot = low\n        #pivot = int((low+high)/2)\n        i = low\n        j = high\n        #print('outside the while:',pivot,low,high)\n        while(i<j):\n            #print(\"hi\")\n        #find the element that is greater than the pivot \n            while(i<=high and self.arr[i] <= self.arr[pivot]):\n                    i = i+ 1\n\n\n            \n                \n            while(j>=low and self.arr[j] > self.arr[pivot]):\n                j = j - 1\n\n\n            #print(\"i:\",i,\"j:\",j)\n            if(i<j):\n\n               # print(\"swapping indices\",i,j)\n                temp = self.arr[i]\n                self.arr[i] = self.arr[j]\n                self.arr[j] = temp\n                #print(\"after swapping\",self.arr)\n\n            \n            \n\n        #print(\"current pivot index\",j)\n        temp = self.arr[j]\n        self.arr[j] = self.arr[pivot]\n        self.arr[pivot] = temp\n\n        #print(\"after swapping the pivot\",self.arr)\n        return j\n\n\n    def sort(self,low,high):\n\n        if(low < high):\n            pivot = self.findpivot(low,high)\n            self.sort(low,pivot-1)\n            self.sort(pivot+1,high)\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        low = 0\n        high = len(nums)-1\n        S = Solve(nums)\n        S.sort(low,high)\n        print(S.arr)\n        return S.arr    \n        `"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Java 8 using merge sort\\n`public int[] sortArray(int[] nums) {\\n        return divideArray(0, nums.length - 1, nums);\\n    }\\n\\n    public int[] divideArray(int lower, int higher, int[] nums) {\\n        if (lower < higher) {\\n            int middle = ((lower + higher) / 2);\\n            // left part\\n            divideArray(lower, middle, nums);\\n            // right part\\n            divideArray(middle + 1, higher, nums);\\n            // merge the array\\n            mergeArray(lower, middle, higher, nums);\\n        }\\n        return nums;\\n    }\\n\\n    public void mergeArray(int lower, int middle, int higher, int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for (int i = lower; i <= higher; i++) {\\n            temp[i] = nums[i];\\n        }\\n        int i = lower;\\n        int j = middle + 1;\\n        int k = lower;\\n        while (i <= middle && j <= higher) {\\n            if (temp[i] <= temp[j]) {\\n                nums[k] = temp[i];\\n                i++;\\n                k++;\\n            } else {\\n                nums[k] = temp[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        // remaining elements from left part\\n        while (i <= middle) {\\n            nums[k] = temp[i];\\n            i++;\\n            k++;\\n        }\\n        // remaining elements from right part\\n         while (j <= higher) {\\n            nums[k] = temp[j];\\n            j++;\\n            k++;\\n        }\\n    }`"
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "easy easy  && easy\\n"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Can we do this with minHeap ,but still it is in-build in python ?? so do we need to implement any other algo of O(nlogn) T.C ??? "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Any built-in functions or features are forbidden. You can choose any known sorting algorithm in `O(n * Log(n))`, such as `merge insertion sort`, and implement it."
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Anyone who used built-in functions like `std::sort` will burn in hell in a separate VIP cauldron of 5000 degree boiling water."
                    }
                ]
            },
            {
                "id": 2053156,
                "content": [
                    {
                        "username": "Rahul3060",
                        "content": "For below code \\'Time Limit Exceeded\\' error\\nWhat modification can I make to reduce execution time?\\n\\nclass Solution:\\n    def sortArray(self,nums: List[int]):\\n        self.quick_sort(nums, 0, len(nums) - 1)\\n        return nums\\n\\n    def quick_sort(self, nums, first, last):\\n        if first < last:\\n            p = self.partition(nums, first, last)\\n            self.quick_sort(nums, first, p - 1)\\n            self.quick_sort(nums, p + 1, last)\\n\\n    def partition(self, nums, first, last):\\n        pivot = nums[first]\\n        left = first + 1\\n        right = last\\n        while True:\\n            while left <= right and nums[left] <= pivot:\\n                left += 1\\n            while left <= right and nums[right] >= pivot:\\n                right -= 1\\n            if left > right:\\n                break\\n            else:\\n                nums[left], nums[right] = nums[right], nums[left]\\n        nums[first], nums[right] = nums[right], nums[first]\\n        return right"
                    },
                    {
                        "username": "kishore_001",
                        "content": "By using the priority queue we get the output as the time complexity as O(nlog(n))"
                    },
                    {
                        "username": "AndraPintilescu",
                        "content": "so i\\'ve tried merge sort but i get TLE. someone can help?\\n\\nhere\\'s my solution:\\n\\nclass Solution {\\npublic:\\n\\n    void merge(vector<int>&nums, int lb, int mid, int ub){\\n        vector<int> v;\\n        v.resize(nums.size());\\n        int i=lb,j=mid+1,k=lb;\\n        while(i<=mid && j<=ub){\\n            if(nums[i]<=nums[j]){\\n                v[k++]=nums[i++];\\n            }\\n            else{\\n                v[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid) v[k++]=nums[i++];\\n        while(j<=ub) v[k++]=nums[j++];\\n        for(int k=lb;k<=ub;k++) nums[k]=v[k];\\n    }\\n    void mergeSort(vector<int> &nums, int lb, int ub){\\n        if(lb<ub){\\n            int mid=lb+(ub-lb)/2;\\n            mergeSort(nums,lb,mid);\\n            mergeSort(nums,mid+1,ub);\\n            merge(nums,lb,mid,ub);\\n        }\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what I suggest is, under the merge function write a simple base case telling when the lb and ub are equal meaning the single element, return nums[lb]. Then catch those number is as first = mergeSort(nums,lb,mid) and                                                                         second = mergeSort(nums,mid+1,ub) Now pass first  and second to the merge, which would merge and return the merged values                                                                    In python this is how it would look                                                                                     def mergesort(self,low,high,nums):\\n        if low==high:\\n            return [nums[low]]\\n\\n        mid = int((low+high)/2)\\n        a = self.mergesort(low,mid,nums)\\n        b = self.mergesort(mid+1,high,nums)\\n        merged = self.merge(a,b)\\n        return merged                                                                                                                                                                                                                                                                                                                                                                                                                                                     def merge(self,leftarr,rightarr):\\n        #create a temp array\\n        temp = []\\n\\n        #length of the left array\\n        l1= len(leftarr)\\n        #length of the right array\\n        l2 = len(rightarr)\\n        #initialise the first pointer \\n        p1 = 0\\n        #intialise the second pointer\\n        p2 = 0\\n\\n        #keep interating untill one of the the pointers exhausts \\n        while(p1<l1 and p2<l2):\\n            #compare the values of the first pointer and seocnd pointer     \\n            if(leftarr[p1]<=rightarr[p2]):\\n                #if left pointer value is smaller or equal to the right pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(leftarr[p1])\\n                p1 = p1 + 1\\n\\n            else:\\n                #if right pointer value is smaller than the left pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(rightarr[p2])\\n                p2 = p2 + 1\\n\\n        #when it comes out it means that one of the array has exhausted\\n\\n        #keep adding the pending leftarray elements\\n        while(p1<l1):\\n            temp.append(leftarr[p1])\\n            p1 = p1+ 1\\n\\n        #keep adding the pending right array elements\\n        while(p2<l2):\\n            temp.append(rightarr[p2])\\n            p2 = p2+ 1\\n        \\n        \\n        return temp\\n                                                                                                                                    "
                    },
                    {
                        "username": "akshay_kota018",
                        "content": "Compile Error\\nLine 85: Char 25: error: use of undeclared identifier \\'Solution\\'\\n      vector<int> ret = Solution().sortArray(param_1); return ret;"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Lets say [-5,1,-3,-9,-2,0,-7,-8] is my array. Lets assume I am using the quick sort algorithm and picking my pivot element being the middle most element ie: int((high+low)/2). Could anyone give me a dry run using this? I tried this and was not able to achieve the sorting . Also, I tried the same problem using by picking the pivot element to be pivot = low and that seems to be working fine but when I tried the same  for large sorted input which contained about 5000 sorted numbers, it seems to give me TLE and that is why I though of  picking the middle element as pivot to tackle the issue, However was not able to sort. Can anyone help me?  \n*any thing wrong with the logic?*    \n\n                                                                                                                    `class Solve:\n    def __init__(self,nums):\n        self.arr = nums\n\n    def findpivot(self,low,high):\n        pivot = int((low+high)/2)\n        #pivot = low\n        #pivot = int((low+high)/2)\n        i = low\n        j = high\n        #print('outside the while:',pivot,low,high)\n        while(i<j):\n            #print(\"hi\")\n        #find the element that is greater than the pivot \n            while(i<=high and self.arr[i] <= self.arr[pivot]):\n                    i = i+ 1\n\n\n            \n                \n            while(j>=low and self.arr[j] > self.arr[pivot]):\n                j = j - 1\n\n\n            #print(\"i:\",i,\"j:\",j)\n            if(i<j):\n\n               # print(\"swapping indices\",i,j)\n                temp = self.arr[i]\n                self.arr[i] = self.arr[j]\n                self.arr[j] = temp\n                #print(\"after swapping\",self.arr)\n\n            \n            \n\n        #print(\"current pivot index\",j)\n        temp = self.arr[j]\n        self.arr[j] = self.arr[pivot]\n        self.arr[pivot] = temp\n\n        #print(\"after swapping the pivot\",self.arr)\n        return j\n\n\n    def sort(self,low,high):\n\n        if(low < high):\n            pivot = self.findpivot(low,high)\n            self.sort(low,pivot-1)\n            self.sort(pivot+1,high)\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        low = 0\n        high = len(nums)-1\n        S = Solve(nums)\n        S.sort(low,high)\n        print(S.arr)\n        return S.arr    \n        `"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Java 8 using merge sort\\n`public int[] sortArray(int[] nums) {\\n        return divideArray(0, nums.length - 1, nums);\\n    }\\n\\n    public int[] divideArray(int lower, int higher, int[] nums) {\\n        if (lower < higher) {\\n            int middle = ((lower + higher) / 2);\\n            // left part\\n            divideArray(lower, middle, nums);\\n            // right part\\n            divideArray(middle + 1, higher, nums);\\n            // merge the array\\n            mergeArray(lower, middle, higher, nums);\\n        }\\n        return nums;\\n    }\\n\\n    public void mergeArray(int lower, int middle, int higher, int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for (int i = lower; i <= higher; i++) {\\n            temp[i] = nums[i];\\n        }\\n        int i = lower;\\n        int j = middle + 1;\\n        int k = lower;\\n        while (i <= middle && j <= higher) {\\n            if (temp[i] <= temp[j]) {\\n                nums[k] = temp[i];\\n                i++;\\n                k++;\\n            } else {\\n                nums[k] = temp[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        // remaining elements from left part\\n        while (i <= middle) {\\n            nums[k] = temp[i];\\n            i++;\\n            k++;\\n        }\\n        // remaining elements from right part\\n         while (j <= higher) {\\n            nums[k] = temp[j];\\n            j++;\\n            k++;\\n        }\\n    }`"
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "easy easy  && easy\\n"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Can we do this with minHeap ,but still it is in-build in python ?? so do we need to implement any other algo of O(nlogn) T.C ??? "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Any built-in functions or features are forbidden. You can choose any known sorting algorithm in `O(n * Log(n))`, such as `merge insertion sort`, and implement it."
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Anyone who used built-in functions like `std::sort` will burn in hell in a separate VIP cauldron of 5000 degree boiling water."
                    }
                ]
            },
            {
                "id": 2052192,
                "content": [
                    {
                        "username": "Rahul3060",
                        "content": "For below code \\'Time Limit Exceeded\\' error\\nWhat modification can I make to reduce execution time?\\n\\nclass Solution:\\n    def sortArray(self,nums: List[int]):\\n        self.quick_sort(nums, 0, len(nums) - 1)\\n        return nums\\n\\n    def quick_sort(self, nums, first, last):\\n        if first < last:\\n            p = self.partition(nums, first, last)\\n            self.quick_sort(nums, first, p - 1)\\n            self.quick_sort(nums, p + 1, last)\\n\\n    def partition(self, nums, first, last):\\n        pivot = nums[first]\\n        left = first + 1\\n        right = last\\n        while True:\\n            while left <= right and nums[left] <= pivot:\\n                left += 1\\n            while left <= right and nums[right] >= pivot:\\n                right -= 1\\n            if left > right:\\n                break\\n            else:\\n                nums[left], nums[right] = nums[right], nums[left]\\n        nums[first], nums[right] = nums[right], nums[first]\\n        return right"
                    },
                    {
                        "username": "kishore_001",
                        "content": "By using the priority queue we get the output as the time complexity as O(nlog(n))"
                    },
                    {
                        "username": "AndraPintilescu",
                        "content": "so i\\'ve tried merge sort but i get TLE. someone can help?\\n\\nhere\\'s my solution:\\n\\nclass Solution {\\npublic:\\n\\n    void merge(vector<int>&nums, int lb, int mid, int ub){\\n        vector<int> v;\\n        v.resize(nums.size());\\n        int i=lb,j=mid+1,k=lb;\\n        while(i<=mid && j<=ub){\\n            if(nums[i]<=nums[j]){\\n                v[k++]=nums[i++];\\n            }\\n            else{\\n                v[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid) v[k++]=nums[i++];\\n        while(j<=ub) v[k++]=nums[j++];\\n        for(int k=lb;k<=ub;k++) nums[k]=v[k];\\n    }\\n    void mergeSort(vector<int> &nums, int lb, int ub){\\n        if(lb<ub){\\n            int mid=lb+(ub-lb)/2;\\n            mergeSort(nums,lb,mid);\\n            mergeSort(nums,mid+1,ub);\\n            merge(nums,lb,mid,ub);\\n        }\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what I suggest is, under the merge function write a simple base case telling when the lb and ub are equal meaning the single element, return nums[lb]. Then catch those number is as first = mergeSort(nums,lb,mid) and                                                                         second = mergeSort(nums,mid+1,ub) Now pass first  and second to the merge, which would merge and return the merged values                                                                    In python this is how it would look                                                                                     def mergesort(self,low,high,nums):\\n        if low==high:\\n            return [nums[low]]\\n\\n        mid = int((low+high)/2)\\n        a = self.mergesort(low,mid,nums)\\n        b = self.mergesort(mid+1,high,nums)\\n        merged = self.merge(a,b)\\n        return merged                                                                                                                                                                                                                                                                                                                                                                                                                                                     def merge(self,leftarr,rightarr):\\n        #create a temp array\\n        temp = []\\n\\n        #length of the left array\\n        l1= len(leftarr)\\n        #length of the right array\\n        l2 = len(rightarr)\\n        #initialise the first pointer \\n        p1 = 0\\n        #intialise the second pointer\\n        p2 = 0\\n\\n        #keep interating untill one of the the pointers exhausts \\n        while(p1<l1 and p2<l2):\\n            #compare the values of the first pointer and seocnd pointer     \\n            if(leftarr[p1]<=rightarr[p2]):\\n                #if left pointer value is smaller or equal to the right pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(leftarr[p1])\\n                p1 = p1 + 1\\n\\n            else:\\n                #if right pointer value is smaller than the left pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(rightarr[p2])\\n                p2 = p2 + 1\\n\\n        #when it comes out it means that one of the array has exhausted\\n\\n        #keep adding the pending leftarray elements\\n        while(p1<l1):\\n            temp.append(leftarr[p1])\\n            p1 = p1+ 1\\n\\n        #keep adding the pending right array elements\\n        while(p2<l2):\\n            temp.append(rightarr[p2])\\n            p2 = p2+ 1\\n        \\n        \\n        return temp\\n                                                                                                                                    "
                    },
                    {
                        "username": "akshay_kota018",
                        "content": "Compile Error\\nLine 85: Char 25: error: use of undeclared identifier \\'Solution\\'\\n      vector<int> ret = Solution().sortArray(param_1); return ret;"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Lets say [-5,1,-3,-9,-2,0,-7,-8] is my array. Lets assume I am using the quick sort algorithm and picking my pivot element being the middle most element ie: int((high+low)/2). Could anyone give me a dry run using this? I tried this and was not able to achieve the sorting . Also, I tried the same problem using by picking the pivot element to be pivot = low and that seems to be working fine but when I tried the same  for large sorted input which contained about 5000 sorted numbers, it seems to give me TLE and that is why I though of  picking the middle element as pivot to tackle the issue, However was not able to sort. Can anyone help me?  \n*any thing wrong with the logic?*    \n\n                                                                                                                    `class Solve:\n    def __init__(self,nums):\n        self.arr = nums\n\n    def findpivot(self,low,high):\n        pivot = int((low+high)/2)\n        #pivot = low\n        #pivot = int((low+high)/2)\n        i = low\n        j = high\n        #print('outside the while:',pivot,low,high)\n        while(i<j):\n            #print(\"hi\")\n        #find the element that is greater than the pivot \n            while(i<=high and self.arr[i] <= self.arr[pivot]):\n                    i = i+ 1\n\n\n            \n                \n            while(j>=low and self.arr[j] > self.arr[pivot]):\n                j = j - 1\n\n\n            #print(\"i:\",i,\"j:\",j)\n            if(i<j):\n\n               # print(\"swapping indices\",i,j)\n                temp = self.arr[i]\n                self.arr[i] = self.arr[j]\n                self.arr[j] = temp\n                #print(\"after swapping\",self.arr)\n\n            \n            \n\n        #print(\"current pivot index\",j)\n        temp = self.arr[j]\n        self.arr[j] = self.arr[pivot]\n        self.arr[pivot] = temp\n\n        #print(\"after swapping the pivot\",self.arr)\n        return j\n\n\n    def sort(self,low,high):\n\n        if(low < high):\n            pivot = self.findpivot(low,high)\n            self.sort(low,pivot-1)\n            self.sort(pivot+1,high)\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        low = 0\n        high = len(nums)-1\n        S = Solve(nums)\n        S.sort(low,high)\n        print(S.arr)\n        return S.arr    \n        `"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Java 8 using merge sort\\n`public int[] sortArray(int[] nums) {\\n        return divideArray(0, nums.length - 1, nums);\\n    }\\n\\n    public int[] divideArray(int lower, int higher, int[] nums) {\\n        if (lower < higher) {\\n            int middle = ((lower + higher) / 2);\\n            // left part\\n            divideArray(lower, middle, nums);\\n            // right part\\n            divideArray(middle + 1, higher, nums);\\n            // merge the array\\n            mergeArray(lower, middle, higher, nums);\\n        }\\n        return nums;\\n    }\\n\\n    public void mergeArray(int lower, int middle, int higher, int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for (int i = lower; i <= higher; i++) {\\n            temp[i] = nums[i];\\n        }\\n        int i = lower;\\n        int j = middle + 1;\\n        int k = lower;\\n        while (i <= middle && j <= higher) {\\n            if (temp[i] <= temp[j]) {\\n                nums[k] = temp[i];\\n                i++;\\n                k++;\\n            } else {\\n                nums[k] = temp[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        // remaining elements from left part\\n        while (i <= middle) {\\n            nums[k] = temp[i];\\n            i++;\\n            k++;\\n        }\\n        // remaining elements from right part\\n         while (j <= higher) {\\n            nums[k] = temp[j];\\n            j++;\\n            k++;\\n        }\\n    }`"
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "easy easy  && easy\\n"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Can we do this with minHeap ,but still it is in-build in python ?? so do we need to implement any other algo of O(nlogn) T.C ??? "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Any built-in functions or features are forbidden. You can choose any known sorting algorithm in `O(n * Log(n))`, such as `merge insertion sort`, and implement it."
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Anyone who used built-in functions like `std::sort` will burn in hell in a separate VIP cauldron of 5000 degree boiling water."
                    }
                ]
            },
            {
                "id": 2024929,
                "content": [
                    {
                        "username": "Rahul3060",
                        "content": "For below code \\'Time Limit Exceeded\\' error\\nWhat modification can I make to reduce execution time?\\n\\nclass Solution:\\n    def sortArray(self,nums: List[int]):\\n        self.quick_sort(nums, 0, len(nums) - 1)\\n        return nums\\n\\n    def quick_sort(self, nums, first, last):\\n        if first < last:\\n            p = self.partition(nums, first, last)\\n            self.quick_sort(nums, first, p - 1)\\n            self.quick_sort(nums, p + 1, last)\\n\\n    def partition(self, nums, first, last):\\n        pivot = nums[first]\\n        left = first + 1\\n        right = last\\n        while True:\\n            while left <= right and nums[left] <= pivot:\\n                left += 1\\n            while left <= right and nums[right] >= pivot:\\n                right -= 1\\n            if left > right:\\n                break\\n            else:\\n                nums[left], nums[right] = nums[right], nums[left]\\n        nums[first], nums[right] = nums[right], nums[first]\\n        return right"
                    },
                    {
                        "username": "kishore_001",
                        "content": "By using the priority queue we get the output as the time complexity as O(nlog(n))"
                    },
                    {
                        "username": "AndraPintilescu",
                        "content": "so i\\'ve tried merge sort but i get TLE. someone can help?\\n\\nhere\\'s my solution:\\n\\nclass Solution {\\npublic:\\n\\n    void merge(vector<int>&nums, int lb, int mid, int ub){\\n        vector<int> v;\\n        v.resize(nums.size());\\n        int i=lb,j=mid+1,k=lb;\\n        while(i<=mid && j<=ub){\\n            if(nums[i]<=nums[j]){\\n                v[k++]=nums[i++];\\n            }\\n            else{\\n                v[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid) v[k++]=nums[i++];\\n        while(j<=ub) v[k++]=nums[j++];\\n        for(int k=lb;k<=ub;k++) nums[k]=v[k];\\n    }\\n    void mergeSort(vector<int> &nums, int lb, int ub){\\n        if(lb<ub){\\n            int mid=lb+(ub-lb)/2;\\n            mergeSort(nums,lb,mid);\\n            mergeSort(nums,mid+1,ub);\\n            merge(nums,lb,mid,ub);\\n        }\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what I suggest is, under the merge function write a simple base case telling when the lb and ub are equal meaning the single element, return nums[lb]. Then catch those number is as first = mergeSort(nums,lb,mid) and                                                                         second = mergeSort(nums,mid+1,ub) Now pass first  and second to the merge, which would merge and return the merged values                                                                    In python this is how it would look                                                                                     def mergesort(self,low,high,nums):\\n        if low==high:\\n            return [nums[low]]\\n\\n        mid = int((low+high)/2)\\n        a = self.mergesort(low,mid,nums)\\n        b = self.mergesort(mid+1,high,nums)\\n        merged = self.merge(a,b)\\n        return merged                                                                                                                                                                                                                                                                                                                                                                                                                                                     def merge(self,leftarr,rightarr):\\n        #create a temp array\\n        temp = []\\n\\n        #length of the left array\\n        l1= len(leftarr)\\n        #length of the right array\\n        l2 = len(rightarr)\\n        #initialise the first pointer \\n        p1 = 0\\n        #intialise the second pointer\\n        p2 = 0\\n\\n        #keep interating untill one of the the pointers exhausts \\n        while(p1<l1 and p2<l2):\\n            #compare the values of the first pointer and seocnd pointer     \\n            if(leftarr[p1]<=rightarr[p2]):\\n                #if left pointer value is smaller or equal to the right pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(leftarr[p1])\\n                p1 = p1 + 1\\n\\n            else:\\n                #if right pointer value is smaller than the left pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(rightarr[p2])\\n                p2 = p2 + 1\\n\\n        #when it comes out it means that one of the array has exhausted\\n\\n        #keep adding the pending leftarray elements\\n        while(p1<l1):\\n            temp.append(leftarr[p1])\\n            p1 = p1+ 1\\n\\n        #keep adding the pending right array elements\\n        while(p2<l2):\\n            temp.append(rightarr[p2])\\n            p2 = p2+ 1\\n        \\n        \\n        return temp\\n                                                                                                                                    "
                    },
                    {
                        "username": "akshay_kota018",
                        "content": "Compile Error\\nLine 85: Char 25: error: use of undeclared identifier \\'Solution\\'\\n      vector<int> ret = Solution().sortArray(param_1); return ret;"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Lets say [-5,1,-3,-9,-2,0,-7,-8] is my array. Lets assume I am using the quick sort algorithm and picking my pivot element being the middle most element ie: int((high+low)/2). Could anyone give me a dry run using this? I tried this and was not able to achieve the sorting . Also, I tried the same problem using by picking the pivot element to be pivot = low and that seems to be working fine but when I tried the same  for large sorted input which contained about 5000 sorted numbers, it seems to give me TLE and that is why I though of  picking the middle element as pivot to tackle the issue, However was not able to sort. Can anyone help me?  \n*any thing wrong with the logic?*    \n\n                                                                                                                    `class Solve:\n    def __init__(self,nums):\n        self.arr = nums\n\n    def findpivot(self,low,high):\n        pivot = int((low+high)/2)\n        #pivot = low\n        #pivot = int((low+high)/2)\n        i = low\n        j = high\n        #print('outside the while:',pivot,low,high)\n        while(i<j):\n            #print(\"hi\")\n        #find the element that is greater than the pivot \n            while(i<=high and self.arr[i] <= self.arr[pivot]):\n                    i = i+ 1\n\n\n            \n                \n            while(j>=low and self.arr[j] > self.arr[pivot]):\n                j = j - 1\n\n\n            #print(\"i:\",i,\"j:\",j)\n            if(i<j):\n\n               # print(\"swapping indices\",i,j)\n                temp = self.arr[i]\n                self.arr[i] = self.arr[j]\n                self.arr[j] = temp\n                #print(\"after swapping\",self.arr)\n\n            \n            \n\n        #print(\"current pivot index\",j)\n        temp = self.arr[j]\n        self.arr[j] = self.arr[pivot]\n        self.arr[pivot] = temp\n\n        #print(\"after swapping the pivot\",self.arr)\n        return j\n\n\n    def sort(self,low,high):\n\n        if(low < high):\n            pivot = self.findpivot(low,high)\n            self.sort(low,pivot-1)\n            self.sort(pivot+1,high)\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        low = 0\n        high = len(nums)-1\n        S = Solve(nums)\n        S.sort(low,high)\n        print(S.arr)\n        return S.arr    \n        `"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Java 8 using merge sort\\n`public int[] sortArray(int[] nums) {\\n        return divideArray(0, nums.length - 1, nums);\\n    }\\n\\n    public int[] divideArray(int lower, int higher, int[] nums) {\\n        if (lower < higher) {\\n            int middle = ((lower + higher) / 2);\\n            // left part\\n            divideArray(lower, middle, nums);\\n            // right part\\n            divideArray(middle + 1, higher, nums);\\n            // merge the array\\n            mergeArray(lower, middle, higher, nums);\\n        }\\n        return nums;\\n    }\\n\\n    public void mergeArray(int lower, int middle, int higher, int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for (int i = lower; i <= higher; i++) {\\n            temp[i] = nums[i];\\n        }\\n        int i = lower;\\n        int j = middle + 1;\\n        int k = lower;\\n        while (i <= middle && j <= higher) {\\n            if (temp[i] <= temp[j]) {\\n                nums[k] = temp[i];\\n                i++;\\n                k++;\\n            } else {\\n                nums[k] = temp[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        // remaining elements from left part\\n        while (i <= middle) {\\n            nums[k] = temp[i];\\n            i++;\\n            k++;\\n        }\\n        // remaining elements from right part\\n         while (j <= higher) {\\n            nums[k] = temp[j];\\n            j++;\\n            k++;\\n        }\\n    }`"
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "easy easy  && easy\\n"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Can we do this with minHeap ,but still it is in-build in python ?? so do we need to implement any other algo of O(nlogn) T.C ??? "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Any built-in functions or features are forbidden. You can choose any known sorting algorithm in `O(n * Log(n))`, such as `merge insertion sort`, and implement it."
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Anyone who used built-in functions like `std::sort` will burn in hell in a separate VIP cauldron of 5000 degree boiling water."
                    }
                ]
            },
            {
                "id": 2022894,
                "content": [
                    {
                        "username": "Rahul3060",
                        "content": "For below code \\'Time Limit Exceeded\\' error\\nWhat modification can I make to reduce execution time?\\n\\nclass Solution:\\n    def sortArray(self,nums: List[int]):\\n        self.quick_sort(nums, 0, len(nums) - 1)\\n        return nums\\n\\n    def quick_sort(self, nums, first, last):\\n        if first < last:\\n            p = self.partition(nums, first, last)\\n            self.quick_sort(nums, first, p - 1)\\n            self.quick_sort(nums, p + 1, last)\\n\\n    def partition(self, nums, first, last):\\n        pivot = nums[first]\\n        left = first + 1\\n        right = last\\n        while True:\\n            while left <= right and nums[left] <= pivot:\\n                left += 1\\n            while left <= right and nums[right] >= pivot:\\n                right -= 1\\n            if left > right:\\n                break\\n            else:\\n                nums[left], nums[right] = nums[right], nums[left]\\n        nums[first], nums[right] = nums[right], nums[first]\\n        return right"
                    },
                    {
                        "username": "kishore_001",
                        "content": "By using the priority queue we get the output as the time complexity as O(nlog(n))"
                    },
                    {
                        "username": "AndraPintilescu",
                        "content": "so i\\'ve tried merge sort but i get TLE. someone can help?\\n\\nhere\\'s my solution:\\n\\nclass Solution {\\npublic:\\n\\n    void merge(vector<int>&nums, int lb, int mid, int ub){\\n        vector<int> v;\\n        v.resize(nums.size());\\n        int i=lb,j=mid+1,k=lb;\\n        while(i<=mid && j<=ub){\\n            if(nums[i]<=nums[j]){\\n                v[k++]=nums[i++];\\n            }\\n            else{\\n                v[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid) v[k++]=nums[i++];\\n        while(j<=ub) v[k++]=nums[j++];\\n        for(int k=lb;k<=ub;k++) nums[k]=v[k];\\n    }\\n    void mergeSort(vector<int> &nums, int lb, int ub){\\n        if(lb<ub){\\n            int mid=lb+(ub-lb)/2;\\n            mergeSort(nums,lb,mid);\\n            mergeSort(nums,mid+1,ub);\\n            merge(nums,lb,mid,ub);\\n        }\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what I suggest is, under the merge function write a simple base case telling when the lb and ub are equal meaning the single element, return nums[lb]. Then catch those number is as first = mergeSort(nums,lb,mid) and                                                                         second = mergeSort(nums,mid+1,ub) Now pass first  and second to the merge, which would merge and return the merged values                                                                    In python this is how it would look                                                                                     def mergesort(self,low,high,nums):\\n        if low==high:\\n            return [nums[low]]\\n\\n        mid = int((low+high)/2)\\n        a = self.mergesort(low,mid,nums)\\n        b = self.mergesort(mid+1,high,nums)\\n        merged = self.merge(a,b)\\n        return merged                                                                                                                                                                                                                                                                                                                                                                                                                                                     def merge(self,leftarr,rightarr):\\n        #create a temp array\\n        temp = []\\n\\n        #length of the left array\\n        l1= len(leftarr)\\n        #length of the right array\\n        l2 = len(rightarr)\\n        #initialise the first pointer \\n        p1 = 0\\n        #intialise the second pointer\\n        p2 = 0\\n\\n        #keep interating untill one of the the pointers exhausts \\n        while(p1<l1 and p2<l2):\\n            #compare the values of the first pointer and seocnd pointer     \\n            if(leftarr[p1]<=rightarr[p2]):\\n                #if left pointer value is smaller or equal to the right pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(leftarr[p1])\\n                p1 = p1 + 1\\n\\n            else:\\n                #if right pointer value is smaller than the left pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(rightarr[p2])\\n                p2 = p2 + 1\\n\\n        #when it comes out it means that one of the array has exhausted\\n\\n        #keep adding the pending leftarray elements\\n        while(p1<l1):\\n            temp.append(leftarr[p1])\\n            p1 = p1+ 1\\n\\n        #keep adding the pending right array elements\\n        while(p2<l2):\\n            temp.append(rightarr[p2])\\n            p2 = p2+ 1\\n        \\n        \\n        return temp\\n                                                                                                                                    "
                    },
                    {
                        "username": "akshay_kota018",
                        "content": "Compile Error\\nLine 85: Char 25: error: use of undeclared identifier \\'Solution\\'\\n      vector<int> ret = Solution().sortArray(param_1); return ret;"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Lets say [-5,1,-3,-9,-2,0,-7,-8] is my array. Lets assume I am using the quick sort algorithm and picking my pivot element being the middle most element ie: int((high+low)/2). Could anyone give me a dry run using this? I tried this and was not able to achieve the sorting . Also, I tried the same problem using by picking the pivot element to be pivot = low and that seems to be working fine but when I tried the same  for large sorted input which contained about 5000 sorted numbers, it seems to give me TLE and that is why I though of  picking the middle element as pivot to tackle the issue, However was not able to sort. Can anyone help me?  \n*any thing wrong with the logic?*    \n\n                                                                                                                    `class Solve:\n    def __init__(self,nums):\n        self.arr = nums\n\n    def findpivot(self,low,high):\n        pivot = int((low+high)/2)\n        #pivot = low\n        #pivot = int((low+high)/2)\n        i = low\n        j = high\n        #print('outside the while:',pivot,low,high)\n        while(i<j):\n            #print(\"hi\")\n        #find the element that is greater than the pivot \n            while(i<=high and self.arr[i] <= self.arr[pivot]):\n                    i = i+ 1\n\n\n            \n                \n            while(j>=low and self.arr[j] > self.arr[pivot]):\n                j = j - 1\n\n\n            #print(\"i:\",i,\"j:\",j)\n            if(i<j):\n\n               # print(\"swapping indices\",i,j)\n                temp = self.arr[i]\n                self.arr[i] = self.arr[j]\n                self.arr[j] = temp\n                #print(\"after swapping\",self.arr)\n\n            \n            \n\n        #print(\"current pivot index\",j)\n        temp = self.arr[j]\n        self.arr[j] = self.arr[pivot]\n        self.arr[pivot] = temp\n\n        #print(\"after swapping the pivot\",self.arr)\n        return j\n\n\n    def sort(self,low,high):\n\n        if(low < high):\n            pivot = self.findpivot(low,high)\n            self.sort(low,pivot-1)\n            self.sort(pivot+1,high)\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        low = 0\n        high = len(nums)-1\n        S = Solve(nums)\n        S.sort(low,high)\n        print(S.arr)\n        return S.arr    \n        `"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Java 8 using merge sort\\n`public int[] sortArray(int[] nums) {\\n        return divideArray(0, nums.length - 1, nums);\\n    }\\n\\n    public int[] divideArray(int lower, int higher, int[] nums) {\\n        if (lower < higher) {\\n            int middle = ((lower + higher) / 2);\\n            // left part\\n            divideArray(lower, middle, nums);\\n            // right part\\n            divideArray(middle + 1, higher, nums);\\n            // merge the array\\n            mergeArray(lower, middle, higher, nums);\\n        }\\n        return nums;\\n    }\\n\\n    public void mergeArray(int lower, int middle, int higher, int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for (int i = lower; i <= higher; i++) {\\n            temp[i] = nums[i];\\n        }\\n        int i = lower;\\n        int j = middle + 1;\\n        int k = lower;\\n        while (i <= middle && j <= higher) {\\n            if (temp[i] <= temp[j]) {\\n                nums[k] = temp[i];\\n                i++;\\n                k++;\\n            } else {\\n                nums[k] = temp[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        // remaining elements from left part\\n        while (i <= middle) {\\n            nums[k] = temp[i];\\n            i++;\\n            k++;\\n        }\\n        // remaining elements from right part\\n         while (j <= higher) {\\n            nums[k] = temp[j];\\n            j++;\\n            k++;\\n        }\\n    }`"
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "easy easy  && easy\\n"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Can we do this with minHeap ,but still it is in-build in python ?? so do we need to implement any other algo of O(nlogn) T.C ??? "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Any built-in functions or features are forbidden. You can choose any known sorting algorithm in `O(n * Log(n))`, such as `merge insertion sort`, and implement it."
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Anyone who used built-in functions like `std::sort` will burn in hell in a separate VIP cauldron of 5000 degree boiling water."
                    }
                ]
            },
            {
                "id": 2018285,
                "content": [
                    {
                        "username": "Rahul3060",
                        "content": "For below code \\'Time Limit Exceeded\\' error\\nWhat modification can I make to reduce execution time?\\n\\nclass Solution:\\n    def sortArray(self,nums: List[int]):\\n        self.quick_sort(nums, 0, len(nums) - 1)\\n        return nums\\n\\n    def quick_sort(self, nums, first, last):\\n        if first < last:\\n            p = self.partition(nums, first, last)\\n            self.quick_sort(nums, first, p - 1)\\n            self.quick_sort(nums, p + 1, last)\\n\\n    def partition(self, nums, first, last):\\n        pivot = nums[first]\\n        left = first + 1\\n        right = last\\n        while True:\\n            while left <= right and nums[left] <= pivot:\\n                left += 1\\n            while left <= right and nums[right] >= pivot:\\n                right -= 1\\n            if left > right:\\n                break\\n            else:\\n                nums[left], nums[right] = nums[right], nums[left]\\n        nums[first], nums[right] = nums[right], nums[first]\\n        return right"
                    },
                    {
                        "username": "kishore_001",
                        "content": "By using the priority queue we get the output as the time complexity as O(nlog(n))"
                    },
                    {
                        "username": "AndraPintilescu",
                        "content": "so i\\'ve tried merge sort but i get TLE. someone can help?\\n\\nhere\\'s my solution:\\n\\nclass Solution {\\npublic:\\n\\n    void merge(vector<int>&nums, int lb, int mid, int ub){\\n        vector<int> v;\\n        v.resize(nums.size());\\n        int i=lb,j=mid+1,k=lb;\\n        while(i<=mid && j<=ub){\\n            if(nums[i]<=nums[j]){\\n                v[k++]=nums[i++];\\n            }\\n            else{\\n                v[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid) v[k++]=nums[i++];\\n        while(j<=ub) v[k++]=nums[j++];\\n        for(int k=lb;k<=ub;k++) nums[k]=v[k];\\n    }\\n    void mergeSort(vector<int> &nums, int lb, int ub){\\n        if(lb<ub){\\n            int mid=lb+(ub-lb)/2;\\n            mergeSort(nums,lb,mid);\\n            mergeSort(nums,mid+1,ub);\\n            merge(nums,lb,mid,ub);\\n        }\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what I suggest is, under the merge function write a simple base case telling when the lb and ub are equal meaning the single element, return nums[lb]. Then catch those number is as first = mergeSort(nums,lb,mid) and                                                                         second = mergeSort(nums,mid+1,ub) Now pass first  and second to the merge, which would merge and return the merged values                                                                    In python this is how it would look                                                                                     def mergesort(self,low,high,nums):\\n        if low==high:\\n            return [nums[low]]\\n\\n        mid = int((low+high)/2)\\n        a = self.mergesort(low,mid,nums)\\n        b = self.mergesort(mid+1,high,nums)\\n        merged = self.merge(a,b)\\n        return merged                                                                                                                                                                                                                                                                                                                                                                                                                                                     def merge(self,leftarr,rightarr):\\n        #create a temp array\\n        temp = []\\n\\n        #length of the left array\\n        l1= len(leftarr)\\n        #length of the right array\\n        l2 = len(rightarr)\\n        #initialise the first pointer \\n        p1 = 0\\n        #intialise the second pointer\\n        p2 = 0\\n\\n        #keep interating untill one of the the pointers exhausts \\n        while(p1<l1 and p2<l2):\\n            #compare the values of the first pointer and seocnd pointer     \\n            if(leftarr[p1]<=rightarr[p2]):\\n                #if left pointer value is smaller or equal to the right pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(leftarr[p1])\\n                p1 = p1 + 1\\n\\n            else:\\n                #if right pointer value is smaller than the left pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(rightarr[p2])\\n                p2 = p2 + 1\\n\\n        #when it comes out it means that one of the array has exhausted\\n\\n        #keep adding the pending leftarray elements\\n        while(p1<l1):\\n            temp.append(leftarr[p1])\\n            p1 = p1+ 1\\n\\n        #keep adding the pending right array elements\\n        while(p2<l2):\\n            temp.append(rightarr[p2])\\n            p2 = p2+ 1\\n        \\n        \\n        return temp\\n                                                                                                                                    "
                    },
                    {
                        "username": "akshay_kota018",
                        "content": "Compile Error\\nLine 85: Char 25: error: use of undeclared identifier \\'Solution\\'\\n      vector<int> ret = Solution().sortArray(param_1); return ret;"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Lets say [-5,1,-3,-9,-2,0,-7,-8] is my array. Lets assume I am using the quick sort algorithm and picking my pivot element being the middle most element ie: int((high+low)/2). Could anyone give me a dry run using this? I tried this and was not able to achieve the sorting . Also, I tried the same problem using by picking the pivot element to be pivot = low and that seems to be working fine but when I tried the same  for large sorted input which contained about 5000 sorted numbers, it seems to give me TLE and that is why I though of  picking the middle element as pivot to tackle the issue, However was not able to sort. Can anyone help me?  \n*any thing wrong with the logic?*    \n\n                                                                                                                    `class Solve:\n    def __init__(self,nums):\n        self.arr = nums\n\n    def findpivot(self,low,high):\n        pivot = int((low+high)/2)\n        #pivot = low\n        #pivot = int((low+high)/2)\n        i = low\n        j = high\n        #print('outside the while:',pivot,low,high)\n        while(i<j):\n            #print(\"hi\")\n        #find the element that is greater than the pivot \n            while(i<=high and self.arr[i] <= self.arr[pivot]):\n                    i = i+ 1\n\n\n            \n                \n            while(j>=low and self.arr[j] > self.arr[pivot]):\n                j = j - 1\n\n\n            #print(\"i:\",i,\"j:\",j)\n            if(i<j):\n\n               # print(\"swapping indices\",i,j)\n                temp = self.arr[i]\n                self.arr[i] = self.arr[j]\n                self.arr[j] = temp\n                #print(\"after swapping\",self.arr)\n\n            \n            \n\n        #print(\"current pivot index\",j)\n        temp = self.arr[j]\n        self.arr[j] = self.arr[pivot]\n        self.arr[pivot] = temp\n\n        #print(\"after swapping the pivot\",self.arr)\n        return j\n\n\n    def sort(self,low,high):\n\n        if(low < high):\n            pivot = self.findpivot(low,high)\n            self.sort(low,pivot-1)\n            self.sort(pivot+1,high)\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        low = 0\n        high = len(nums)-1\n        S = Solve(nums)\n        S.sort(low,high)\n        print(S.arr)\n        return S.arr    \n        `"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Java 8 using merge sort\\n`public int[] sortArray(int[] nums) {\\n        return divideArray(0, nums.length - 1, nums);\\n    }\\n\\n    public int[] divideArray(int lower, int higher, int[] nums) {\\n        if (lower < higher) {\\n            int middle = ((lower + higher) / 2);\\n            // left part\\n            divideArray(lower, middle, nums);\\n            // right part\\n            divideArray(middle + 1, higher, nums);\\n            // merge the array\\n            mergeArray(lower, middle, higher, nums);\\n        }\\n        return nums;\\n    }\\n\\n    public void mergeArray(int lower, int middle, int higher, int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for (int i = lower; i <= higher; i++) {\\n            temp[i] = nums[i];\\n        }\\n        int i = lower;\\n        int j = middle + 1;\\n        int k = lower;\\n        while (i <= middle && j <= higher) {\\n            if (temp[i] <= temp[j]) {\\n                nums[k] = temp[i];\\n                i++;\\n                k++;\\n            } else {\\n                nums[k] = temp[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        // remaining elements from left part\\n        while (i <= middle) {\\n            nums[k] = temp[i];\\n            i++;\\n            k++;\\n        }\\n        // remaining elements from right part\\n         while (j <= higher) {\\n            nums[k] = temp[j];\\n            j++;\\n            k++;\\n        }\\n    }`"
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "easy easy  && easy\\n"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Can we do this with minHeap ,but still it is in-build in python ?? so do we need to implement any other algo of O(nlogn) T.C ??? "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Any built-in functions or features are forbidden. You can choose any known sorting algorithm in `O(n * Log(n))`, such as `merge insertion sort`, and implement it."
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Anyone who used built-in functions like `std::sort` will burn in hell in a separate VIP cauldron of 5000 degree boiling water."
                    }
                ]
            },
            {
                "id": 2008702,
                "content": [
                    {
                        "username": "Rahul3060",
                        "content": "For below code \\'Time Limit Exceeded\\' error\\nWhat modification can I make to reduce execution time?\\n\\nclass Solution:\\n    def sortArray(self,nums: List[int]):\\n        self.quick_sort(nums, 0, len(nums) - 1)\\n        return nums\\n\\n    def quick_sort(self, nums, first, last):\\n        if first < last:\\n            p = self.partition(nums, first, last)\\n            self.quick_sort(nums, first, p - 1)\\n            self.quick_sort(nums, p + 1, last)\\n\\n    def partition(self, nums, first, last):\\n        pivot = nums[first]\\n        left = first + 1\\n        right = last\\n        while True:\\n            while left <= right and nums[left] <= pivot:\\n                left += 1\\n            while left <= right and nums[right] >= pivot:\\n                right -= 1\\n            if left > right:\\n                break\\n            else:\\n                nums[left], nums[right] = nums[right], nums[left]\\n        nums[first], nums[right] = nums[right], nums[first]\\n        return right"
                    },
                    {
                        "username": "kishore_001",
                        "content": "By using the priority queue we get the output as the time complexity as O(nlog(n))"
                    },
                    {
                        "username": "AndraPintilescu",
                        "content": "so i\\'ve tried merge sort but i get TLE. someone can help?\\n\\nhere\\'s my solution:\\n\\nclass Solution {\\npublic:\\n\\n    void merge(vector<int>&nums, int lb, int mid, int ub){\\n        vector<int> v;\\n        v.resize(nums.size());\\n        int i=lb,j=mid+1,k=lb;\\n        while(i<=mid && j<=ub){\\n            if(nums[i]<=nums[j]){\\n                v[k++]=nums[i++];\\n            }\\n            else{\\n                v[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid) v[k++]=nums[i++];\\n        while(j<=ub) v[k++]=nums[j++];\\n        for(int k=lb;k<=ub;k++) nums[k]=v[k];\\n    }\\n    void mergeSort(vector<int> &nums, int lb, int ub){\\n        if(lb<ub){\\n            int mid=lb+(ub-lb)/2;\\n            mergeSort(nums,lb,mid);\\n            mergeSort(nums,mid+1,ub);\\n            merge(nums,lb,mid,ub);\\n        }\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what I suggest is, under the merge function write a simple base case telling when the lb and ub are equal meaning the single element, return nums[lb]. Then catch those number is as first = mergeSort(nums,lb,mid) and                                                                         second = mergeSort(nums,mid+1,ub) Now pass first  and second to the merge, which would merge and return the merged values                                                                    In python this is how it would look                                                                                     def mergesort(self,low,high,nums):\\n        if low==high:\\n            return [nums[low]]\\n\\n        mid = int((low+high)/2)\\n        a = self.mergesort(low,mid,nums)\\n        b = self.mergesort(mid+1,high,nums)\\n        merged = self.merge(a,b)\\n        return merged                                                                                                                                                                                                                                                                                                                                                                                                                                                     def merge(self,leftarr,rightarr):\\n        #create a temp array\\n        temp = []\\n\\n        #length of the left array\\n        l1= len(leftarr)\\n        #length of the right array\\n        l2 = len(rightarr)\\n        #initialise the first pointer \\n        p1 = 0\\n        #intialise the second pointer\\n        p2 = 0\\n\\n        #keep interating untill one of the the pointers exhausts \\n        while(p1<l1 and p2<l2):\\n            #compare the values of the first pointer and seocnd pointer     \\n            if(leftarr[p1]<=rightarr[p2]):\\n                #if left pointer value is smaller or equal to the right pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(leftarr[p1])\\n                p1 = p1 + 1\\n\\n            else:\\n                #if right pointer value is smaller than the left pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(rightarr[p2])\\n                p2 = p2 + 1\\n\\n        #when it comes out it means that one of the array has exhausted\\n\\n        #keep adding the pending leftarray elements\\n        while(p1<l1):\\n            temp.append(leftarr[p1])\\n            p1 = p1+ 1\\n\\n        #keep adding the pending right array elements\\n        while(p2<l2):\\n            temp.append(rightarr[p2])\\n            p2 = p2+ 1\\n        \\n        \\n        return temp\\n                                                                                                                                    "
                    },
                    {
                        "username": "akshay_kota018",
                        "content": "Compile Error\\nLine 85: Char 25: error: use of undeclared identifier \\'Solution\\'\\n      vector<int> ret = Solution().sortArray(param_1); return ret;"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Lets say [-5,1,-3,-9,-2,0,-7,-8] is my array. Lets assume I am using the quick sort algorithm and picking my pivot element being the middle most element ie: int((high+low)/2). Could anyone give me a dry run using this? I tried this and was not able to achieve the sorting . Also, I tried the same problem using by picking the pivot element to be pivot = low and that seems to be working fine but when I tried the same  for large sorted input which contained about 5000 sorted numbers, it seems to give me TLE and that is why I though of  picking the middle element as pivot to tackle the issue, However was not able to sort. Can anyone help me?  \n*any thing wrong with the logic?*    \n\n                                                                                                                    `class Solve:\n    def __init__(self,nums):\n        self.arr = nums\n\n    def findpivot(self,low,high):\n        pivot = int((low+high)/2)\n        #pivot = low\n        #pivot = int((low+high)/2)\n        i = low\n        j = high\n        #print('outside the while:',pivot,low,high)\n        while(i<j):\n            #print(\"hi\")\n        #find the element that is greater than the pivot \n            while(i<=high and self.arr[i] <= self.arr[pivot]):\n                    i = i+ 1\n\n\n            \n                \n            while(j>=low and self.arr[j] > self.arr[pivot]):\n                j = j - 1\n\n\n            #print(\"i:\",i,\"j:\",j)\n            if(i<j):\n\n               # print(\"swapping indices\",i,j)\n                temp = self.arr[i]\n                self.arr[i] = self.arr[j]\n                self.arr[j] = temp\n                #print(\"after swapping\",self.arr)\n\n            \n            \n\n        #print(\"current pivot index\",j)\n        temp = self.arr[j]\n        self.arr[j] = self.arr[pivot]\n        self.arr[pivot] = temp\n\n        #print(\"after swapping the pivot\",self.arr)\n        return j\n\n\n    def sort(self,low,high):\n\n        if(low < high):\n            pivot = self.findpivot(low,high)\n            self.sort(low,pivot-1)\n            self.sort(pivot+1,high)\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        low = 0\n        high = len(nums)-1\n        S = Solve(nums)\n        S.sort(low,high)\n        print(S.arr)\n        return S.arr    \n        `"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Java 8 using merge sort\\n`public int[] sortArray(int[] nums) {\\n        return divideArray(0, nums.length - 1, nums);\\n    }\\n\\n    public int[] divideArray(int lower, int higher, int[] nums) {\\n        if (lower < higher) {\\n            int middle = ((lower + higher) / 2);\\n            // left part\\n            divideArray(lower, middle, nums);\\n            // right part\\n            divideArray(middle + 1, higher, nums);\\n            // merge the array\\n            mergeArray(lower, middle, higher, nums);\\n        }\\n        return nums;\\n    }\\n\\n    public void mergeArray(int lower, int middle, int higher, int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for (int i = lower; i <= higher; i++) {\\n            temp[i] = nums[i];\\n        }\\n        int i = lower;\\n        int j = middle + 1;\\n        int k = lower;\\n        while (i <= middle && j <= higher) {\\n            if (temp[i] <= temp[j]) {\\n                nums[k] = temp[i];\\n                i++;\\n                k++;\\n            } else {\\n                nums[k] = temp[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        // remaining elements from left part\\n        while (i <= middle) {\\n            nums[k] = temp[i];\\n            i++;\\n            k++;\\n        }\\n        // remaining elements from right part\\n         while (j <= higher) {\\n            nums[k] = temp[j];\\n            j++;\\n            k++;\\n        }\\n    }`"
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "easy easy  && easy\\n"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Can we do this with minHeap ,but still it is in-build in python ?? so do we need to implement any other algo of O(nlogn) T.C ??? "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Any built-in functions or features are forbidden. You can choose any known sorting algorithm in `O(n * Log(n))`, such as `merge insertion sort`, and implement it."
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Anyone who used built-in functions like `std::sort` will burn in hell in a separate VIP cauldron of 5000 degree boiling water."
                    }
                ]
            },
            {
                "id": 2005269,
                "content": [
                    {
                        "username": "Rahul3060",
                        "content": "For below code \\'Time Limit Exceeded\\' error\\nWhat modification can I make to reduce execution time?\\n\\nclass Solution:\\n    def sortArray(self,nums: List[int]):\\n        self.quick_sort(nums, 0, len(nums) - 1)\\n        return nums\\n\\n    def quick_sort(self, nums, first, last):\\n        if first < last:\\n            p = self.partition(nums, first, last)\\n            self.quick_sort(nums, first, p - 1)\\n            self.quick_sort(nums, p + 1, last)\\n\\n    def partition(self, nums, first, last):\\n        pivot = nums[first]\\n        left = first + 1\\n        right = last\\n        while True:\\n            while left <= right and nums[left] <= pivot:\\n                left += 1\\n            while left <= right and nums[right] >= pivot:\\n                right -= 1\\n            if left > right:\\n                break\\n            else:\\n                nums[left], nums[right] = nums[right], nums[left]\\n        nums[first], nums[right] = nums[right], nums[first]\\n        return right"
                    },
                    {
                        "username": "kishore_001",
                        "content": "By using the priority queue we get the output as the time complexity as O(nlog(n))"
                    },
                    {
                        "username": "AndraPintilescu",
                        "content": "so i\\'ve tried merge sort but i get TLE. someone can help?\\n\\nhere\\'s my solution:\\n\\nclass Solution {\\npublic:\\n\\n    void merge(vector<int>&nums, int lb, int mid, int ub){\\n        vector<int> v;\\n        v.resize(nums.size());\\n        int i=lb,j=mid+1,k=lb;\\n        while(i<=mid && j<=ub){\\n            if(nums[i]<=nums[j]){\\n                v[k++]=nums[i++];\\n            }\\n            else{\\n                v[k++]=nums[j++];\\n            }\\n        }\\n        while(i<=mid) v[k++]=nums[i++];\\n        while(j<=ub) v[k++]=nums[j++];\\n        for(int k=lb;k<=ub;k++) nums[k]=v[k];\\n    }\\n    void mergeSort(vector<int> &nums, int lb, int ub){\\n        if(lb<ub){\\n            int mid=lb+(ub-lb)/2;\\n            mergeSort(nums,lb,mid);\\n            mergeSort(nums,mid+1,ub);\\n            merge(nums,lb,mid,ub);\\n        }\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "what I suggest is, under the merge function write a simple base case telling when the lb and ub are equal meaning the single element, return nums[lb]. Then catch those number is as first = mergeSort(nums,lb,mid) and                                                                         second = mergeSort(nums,mid+1,ub) Now pass first  and second to the merge, which would merge and return the merged values                                                                    In python this is how it would look                                                                                     def mergesort(self,low,high,nums):\\n        if low==high:\\n            return [nums[low]]\\n\\n        mid = int((low+high)/2)\\n        a = self.mergesort(low,mid,nums)\\n        b = self.mergesort(mid+1,high,nums)\\n        merged = self.merge(a,b)\\n        return merged                                                                                                                                                                                                                                                                                                                                                                                                                                                     def merge(self,leftarr,rightarr):\\n        #create a temp array\\n        temp = []\\n\\n        #length of the left array\\n        l1= len(leftarr)\\n        #length of the right array\\n        l2 = len(rightarr)\\n        #initialise the first pointer \\n        p1 = 0\\n        #intialise the second pointer\\n        p2 = 0\\n\\n        #keep interating untill one of the the pointers exhausts \\n        while(p1<l1 and p2<l2):\\n            #compare the values of the first pointer and seocnd pointer     \\n            if(leftarr[p1]<=rightarr[p2]):\\n                #if left pointer value is smaller or equal to the right pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(leftarr[p1])\\n                p1 = p1 + 1\\n\\n            else:\\n                #if right pointer value is smaller than the left pointer, add the left pointer value to the new temp array and increament the left pointer\\n                temp.append(rightarr[p2])\\n                p2 = p2 + 1\\n\\n        #when it comes out it means that one of the array has exhausted\\n\\n        #keep adding the pending leftarray elements\\n        while(p1<l1):\\n            temp.append(leftarr[p1])\\n            p1 = p1+ 1\\n\\n        #keep adding the pending right array elements\\n        while(p2<l2):\\n            temp.append(rightarr[p2])\\n            p2 = p2+ 1\\n        \\n        \\n        return temp\\n                                                                                                                                    "
                    },
                    {
                        "username": "akshay_kota018",
                        "content": "Compile Error\\nLine 85: Char 25: error: use of undeclared identifier \\'Solution\\'\\n      vector<int> ret = Solution().sortArray(param_1); return ret;"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Lets say [-5,1,-3,-9,-2,0,-7,-8] is my array. Lets assume I am using the quick sort algorithm and picking my pivot element being the middle most element ie: int((high+low)/2). Could anyone give me a dry run using this? I tried this and was not able to achieve the sorting . Also, I tried the same problem using by picking the pivot element to be pivot = low and that seems to be working fine but when I tried the same  for large sorted input which contained about 5000 sorted numbers, it seems to give me TLE and that is why I though of  picking the middle element as pivot to tackle the issue, However was not able to sort. Can anyone help me?  \n*any thing wrong with the logic?*    \n\n                                                                                                                    `class Solve:\n    def __init__(self,nums):\n        self.arr = nums\n\n    def findpivot(self,low,high):\n        pivot = int((low+high)/2)\n        #pivot = low\n        #pivot = int((low+high)/2)\n        i = low\n        j = high\n        #print('outside the while:',pivot,low,high)\n        while(i<j):\n            #print(\"hi\")\n        #find the element that is greater than the pivot \n            while(i<=high and self.arr[i] <= self.arr[pivot]):\n                    i = i+ 1\n\n\n            \n                \n            while(j>=low and self.arr[j] > self.arr[pivot]):\n                j = j - 1\n\n\n            #print(\"i:\",i,\"j:\",j)\n            if(i<j):\n\n               # print(\"swapping indices\",i,j)\n                temp = self.arr[i]\n                self.arr[i] = self.arr[j]\n                self.arr[j] = temp\n                #print(\"after swapping\",self.arr)\n\n            \n            \n\n        #print(\"current pivot index\",j)\n        temp = self.arr[j]\n        self.arr[j] = self.arr[pivot]\n        self.arr[pivot] = temp\n\n        #print(\"after swapping the pivot\",self.arr)\n        return j\n\n\n    def sort(self,low,high):\n\n        if(low < high):\n            pivot = self.findpivot(low,high)\n            self.sort(low,pivot-1)\n            self.sort(pivot+1,high)\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        low = 0\n        high = len(nums)-1\n        S = Solve(nums)\n        S.sort(low,high)\n        print(S.arr)\n        return S.arr    \n        `"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Java 8 using merge sort\\n`public int[] sortArray(int[] nums) {\\n        return divideArray(0, nums.length - 1, nums);\\n    }\\n\\n    public int[] divideArray(int lower, int higher, int[] nums) {\\n        if (lower < higher) {\\n            int middle = ((lower + higher) / 2);\\n            // left part\\n            divideArray(lower, middle, nums);\\n            // right part\\n            divideArray(middle + 1, higher, nums);\\n            // merge the array\\n            mergeArray(lower, middle, higher, nums);\\n        }\\n        return nums;\\n    }\\n\\n    public void mergeArray(int lower, int middle, int higher, int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for (int i = lower; i <= higher; i++) {\\n            temp[i] = nums[i];\\n        }\\n        int i = lower;\\n        int j = middle + 1;\\n        int k = lower;\\n        while (i <= middle && j <= higher) {\\n            if (temp[i] <= temp[j]) {\\n                nums[k] = temp[i];\\n                i++;\\n                k++;\\n            } else {\\n                nums[k] = temp[j];\\n                j++;\\n                k++;\\n            }\\n        }\\n        // remaining elements from left part\\n        while (i <= middle) {\\n            nums[k] = temp[i];\\n            i++;\\n            k++;\\n        }\\n        // remaining elements from right part\\n         while (j <= higher) {\\n            nums[k] = temp[j];\\n            j++;\\n            k++;\\n        }\\n    }`"
                    },
                    {
                        "username": "boooom86608",
                        "content": "Hoare\\'s partition scheme is the one to use here if you implement it correctly it will give you a good running time.\\n\\nAlso merge sort performs better than Hoare\\'s partition here"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "easy easy  && easy\\n"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Can we do this with minHeap ,but still it is in-build in python ?? so do we need to implement any other algo of O(nlogn) T.C ??? "
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Any built-in functions or features are forbidden. You can choose any known sorting algorithm in `O(n * Log(n))`, such as `merge insertion sort`, and implement it."
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "Anyone who used built-in functions like `std::sort` will burn in hell in a separate VIP cauldron of 5000 degree boiling water."
                    }
                ]
            },
            {
                "id": 1979517,
                "content": [
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "We can solve it by simply using Gap method in the merge function that we create for merge sort. Gap method requires O(1) space complexity thus bringing down space complexity to O(1) for complete question and time complexity stays O(nlogn)"
                    },
                    {
                        "username": "Rahul_KD",
                        "content": "People discussing about quick sort or merge sort, le me did this using minHeap "
                    },
                    {
                        "username": "user0411bt",
                        "content": "To all people saying quicksort is giving TLE-> maybe they changed the test cases which are the worst for quicksort. You have to remember at the end of the day, quicksort uses a pivot randomly which we assign as the last element generally. It is fast but not always optimal. Hence it may result in a slower algo sometimes than mergesort. "
                    },
                    {
                        "username": "RP47",
                        "content": "can someone help me? idk why am i getting wrong output for some test cases...i know it will give tle for some test cases since i am using quicksort but it is giving  wrong answer for some test cases.\\n\\nclass Solution {\\npublic:\\n\\nint partition(vector<int>& arr,int s,int e)\\n{\\n    //pick first element for pivot\\n    int pivotindex=s;\\n    int count=0;\\n\\n    //checking how many numbers less than pivot element are on right of pivot\\n    for(int i=pivotindex+1;i<=e;i++)\\n    {\\n        if(arr[i]<arr[pivotindex])\\n            count++;\\n    }\\n\\n    //placing pivot element in its correct position\\n    pivotindex=s+count;\\n    swap(arr[pivotindex],arr[s]);\\n\\n    //now sorting left and right part of pivot by using two pointers i and j\\n    int i=s;//left pointer\\n    int j=e;//right pointer\\n    while(i<pivotindex && j>pivotindex)\\n    {\\n        while(arr[i]<arr[pivotindex])\\n            i++;\\n\\n        while(arr[j]>arr[pivotindex])\\n            j--;\\n\\n        //checking while condition again since we have altered i and j in above loops and haven\\'t checked the condition\\n        if(i<pivotindex && j>pivotindex)\\n        {\\n            swap(arr[i],arr[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    //return partition index to help in calling left and right part quicksort recursively\\n    return pivotindex;\\n}\\n\\nvoid quicksort(vector<int>& arr,int s,int e)\\n{\\n    //Base Case for array consisting of only 0 or 1 element\\n    if(s>=e)\\n        return;\\n\\n    //Finding pivot partition index to use quicksort recursively for left and right of partition\\n    int pivot=partition(arr,s,e);\\n\\n    //recursive call for left of partition\\n    quicksort(arr,s,pivot-1);\\n\\n    //recursive call for right of partition\\n    quicksort(arr,pivot+1,e);\\n}\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        quicksort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "robot_07",
                        "content": "Why does the Inplace Merge Sort technique give TLE here"
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I\\'m using the Dutch national flag 3 way partition and its giving TLE.......WHY.......?????"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Quicksort will work if you do a dual pivot partition (I think its the partition used in the Dutch National Flag Problem). Or alternatively look up a Bentley Mcllroy Partition. \\n\\nI can\\'t imagine being able to come up with that without having previously seen it. And even now that I have, I still can\\'t implement it without spending like 15 -20 minutes debugging it. "
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I did the dual pivot way...still TLE ;("
                    },
                    {
                        "username": "aman3091",
                        "content": "i tried it using recurion but getting an error please correct me \\nclass Solution {\\npublic:\\n    void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n            return ;\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am trying to do it using recursion but getting run time error. please correct it\\n\\n void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "The problem: \"Write 3 partition quick sort\""
                    }
                ]
            },
            {
                "id": 1962689,
                "content": [
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "We can solve it by simply using Gap method in the merge function that we create for merge sort. Gap method requires O(1) space complexity thus bringing down space complexity to O(1) for complete question and time complexity stays O(nlogn)"
                    },
                    {
                        "username": "Rahul_KD",
                        "content": "People discussing about quick sort or merge sort, le me did this using minHeap "
                    },
                    {
                        "username": "user0411bt",
                        "content": "To all people saying quicksort is giving TLE-> maybe they changed the test cases which are the worst for quicksort. You have to remember at the end of the day, quicksort uses a pivot randomly which we assign as the last element generally. It is fast but not always optimal. Hence it may result in a slower algo sometimes than mergesort. "
                    },
                    {
                        "username": "RP47",
                        "content": "can someone help me? idk why am i getting wrong output for some test cases...i know it will give tle for some test cases since i am using quicksort but it is giving  wrong answer for some test cases.\\n\\nclass Solution {\\npublic:\\n\\nint partition(vector<int>& arr,int s,int e)\\n{\\n    //pick first element for pivot\\n    int pivotindex=s;\\n    int count=0;\\n\\n    //checking how many numbers less than pivot element are on right of pivot\\n    for(int i=pivotindex+1;i<=e;i++)\\n    {\\n        if(arr[i]<arr[pivotindex])\\n            count++;\\n    }\\n\\n    //placing pivot element in its correct position\\n    pivotindex=s+count;\\n    swap(arr[pivotindex],arr[s]);\\n\\n    //now sorting left and right part of pivot by using two pointers i and j\\n    int i=s;//left pointer\\n    int j=e;//right pointer\\n    while(i<pivotindex && j>pivotindex)\\n    {\\n        while(arr[i]<arr[pivotindex])\\n            i++;\\n\\n        while(arr[j]>arr[pivotindex])\\n            j--;\\n\\n        //checking while condition again since we have altered i and j in above loops and haven\\'t checked the condition\\n        if(i<pivotindex && j>pivotindex)\\n        {\\n            swap(arr[i],arr[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    //return partition index to help in calling left and right part quicksort recursively\\n    return pivotindex;\\n}\\n\\nvoid quicksort(vector<int>& arr,int s,int e)\\n{\\n    //Base Case for array consisting of only 0 or 1 element\\n    if(s>=e)\\n        return;\\n\\n    //Finding pivot partition index to use quicksort recursively for left and right of partition\\n    int pivot=partition(arr,s,e);\\n\\n    //recursive call for left of partition\\n    quicksort(arr,s,pivot-1);\\n\\n    //recursive call for right of partition\\n    quicksort(arr,pivot+1,e);\\n}\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        quicksort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "robot_07",
                        "content": "Why does the Inplace Merge Sort technique give TLE here"
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I\\'m using the Dutch national flag 3 way partition and its giving TLE.......WHY.......?????"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Quicksort will work if you do a dual pivot partition (I think its the partition used in the Dutch National Flag Problem). Or alternatively look up a Bentley Mcllroy Partition. \\n\\nI can\\'t imagine being able to come up with that without having previously seen it. And even now that I have, I still can\\'t implement it without spending like 15 -20 minutes debugging it. "
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I did the dual pivot way...still TLE ;("
                    },
                    {
                        "username": "aman3091",
                        "content": "i tried it using recurion but getting an error please correct me \\nclass Solution {\\npublic:\\n    void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n            return ;\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am trying to do it using recursion but getting run time error. please correct it\\n\\n void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "The problem: \"Write 3 partition quick sort\""
                    }
                ]
            },
            {
                "id": 1945945,
                "content": [
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "We can solve it by simply using Gap method in the merge function that we create for merge sort. Gap method requires O(1) space complexity thus bringing down space complexity to O(1) for complete question and time complexity stays O(nlogn)"
                    },
                    {
                        "username": "Rahul_KD",
                        "content": "People discussing about quick sort or merge sort, le me did this using minHeap "
                    },
                    {
                        "username": "user0411bt",
                        "content": "To all people saying quicksort is giving TLE-> maybe they changed the test cases which are the worst for quicksort. You have to remember at the end of the day, quicksort uses a pivot randomly which we assign as the last element generally. It is fast but not always optimal. Hence it may result in a slower algo sometimes than mergesort. "
                    },
                    {
                        "username": "RP47",
                        "content": "can someone help me? idk why am i getting wrong output for some test cases...i know it will give tle for some test cases since i am using quicksort but it is giving  wrong answer for some test cases.\\n\\nclass Solution {\\npublic:\\n\\nint partition(vector<int>& arr,int s,int e)\\n{\\n    //pick first element for pivot\\n    int pivotindex=s;\\n    int count=0;\\n\\n    //checking how many numbers less than pivot element are on right of pivot\\n    for(int i=pivotindex+1;i<=e;i++)\\n    {\\n        if(arr[i]<arr[pivotindex])\\n            count++;\\n    }\\n\\n    //placing pivot element in its correct position\\n    pivotindex=s+count;\\n    swap(arr[pivotindex],arr[s]);\\n\\n    //now sorting left and right part of pivot by using two pointers i and j\\n    int i=s;//left pointer\\n    int j=e;//right pointer\\n    while(i<pivotindex && j>pivotindex)\\n    {\\n        while(arr[i]<arr[pivotindex])\\n            i++;\\n\\n        while(arr[j]>arr[pivotindex])\\n            j--;\\n\\n        //checking while condition again since we have altered i and j in above loops and haven\\'t checked the condition\\n        if(i<pivotindex && j>pivotindex)\\n        {\\n            swap(arr[i],arr[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    //return partition index to help in calling left and right part quicksort recursively\\n    return pivotindex;\\n}\\n\\nvoid quicksort(vector<int>& arr,int s,int e)\\n{\\n    //Base Case for array consisting of only 0 or 1 element\\n    if(s>=e)\\n        return;\\n\\n    //Finding pivot partition index to use quicksort recursively for left and right of partition\\n    int pivot=partition(arr,s,e);\\n\\n    //recursive call for left of partition\\n    quicksort(arr,s,pivot-1);\\n\\n    //recursive call for right of partition\\n    quicksort(arr,pivot+1,e);\\n}\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        quicksort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "robot_07",
                        "content": "Why does the Inplace Merge Sort technique give TLE here"
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I\\'m using the Dutch national flag 3 way partition and its giving TLE.......WHY.......?????"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Quicksort will work if you do a dual pivot partition (I think its the partition used in the Dutch National Flag Problem). Or alternatively look up a Bentley Mcllroy Partition. \\n\\nI can\\'t imagine being able to come up with that without having previously seen it. And even now that I have, I still can\\'t implement it without spending like 15 -20 minutes debugging it. "
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I did the dual pivot way...still TLE ;("
                    },
                    {
                        "username": "aman3091",
                        "content": "i tried it using recurion but getting an error please correct me \\nclass Solution {\\npublic:\\n    void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n            return ;\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am trying to do it using recursion but getting run time error. please correct it\\n\\n void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "The problem: \"Write 3 partition quick sort\""
                    }
                ]
            },
            {
                "id": 1936996,
                "content": [
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "We can solve it by simply using Gap method in the merge function that we create for merge sort. Gap method requires O(1) space complexity thus bringing down space complexity to O(1) for complete question and time complexity stays O(nlogn)"
                    },
                    {
                        "username": "Rahul_KD",
                        "content": "People discussing about quick sort or merge sort, le me did this using minHeap "
                    },
                    {
                        "username": "user0411bt",
                        "content": "To all people saying quicksort is giving TLE-> maybe they changed the test cases which are the worst for quicksort. You have to remember at the end of the day, quicksort uses a pivot randomly which we assign as the last element generally. It is fast but not always optimal. Hence it may result in a slower algo sometimes than mergesort. "
                    },
                    {
                        "username": "RP47",
                        "content": "can someone help me? idk why am i getting wrong output for some test cases...i know it will give tle for some test cases since i am using quicksort but it is giving  wrong answer for some test cases.\\n\\nclass Solution {\\npublic:\\n\\nint partition(vector<int>& arr,int s,int e)\\n{\\n    //pick first element for pivot\\n    int pivotindex=s;\\n    int count=0;\\n\\n    //checking how many numbers less than pivot element are on right of pivot\\n    for(int i=pivotindex+1;i<=e;i++)\\n    {\\n        if(arr[i]<arr[pivotindex])\\n            count++;\\n    }\\n\\n    //placing pivot element in its correct position\\n    pivotindex=s+count;\\n    swap(arr[pivotindex],arr[s]);\\n\\n    //now sorting left and right part of pivot by using two pointers i and j\\n    int i=s;//left pointer\\n    int j=e;//right pointer\\n    while(i<pivotindex && j>pivotindex)\\n    {\\n        while(arr[i]<arr[pivotindex])\\n            i++;\\n\\n        while(arr[j]>arr[pivotindex])\\n            j--;\\n\\n        //checking while condition again since we have altered i and j in above loops and haven\\'t checked the condition\\n        if(i<pivotindex && j>pivotindex)\\n        {\\n            swap(arr[i],arr[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    //return partition index to help in calling left and right part quicksort recursively\\n    return pivotindex;\\n}\\n\\nvoid quicksort(vector<int>& arr,int s,int e)\\n{\\n    //Base Case for array consisting of only 0 or 1 element\\n    if(s>=e)\\n        return;\\n\\n    //Finding pivot partition index to use quicksort recursively for left and right of partition\\n    int pivot=partition(arr,s,e);\\n\\n    //recursive call for left of partition\\n    quicksort(arr,s,pivot-1);\\n\\n    //recursive call for right of partition\\n    quicksort(arr,pivot+1,e);\\n}\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        quicksort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "robot_07",
                        "content": "Why does the Inplace Merge Sort technique give TLE here"
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I\\'m using the Dutch national flag 3 way partition and its giving TLE.......WHY.......?????"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Quicksort will work if you do a dual pivot partition (I think its the partition used in the Dutch National Flag Problem). Or alternatively look up a Bentley Mcllroy Partition. \\n\\nI can\\'t imagine being able to come up with that without having previously seen it. And even now that I have, I still can\\'t implement it without spending like 15 -20 minutes debugging it. "
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I did the dual pivot way...still TLE ;("
                    },
                    {
                        "username": "aman3091",
                        "content": "i tried it using recurion but getting an error please correct me \\nclass Solution {\\npublic:\\n    void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n            return ;\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am trying to do it using recursion but getting run time error. please correct it\\n\\n void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "The problem: \"Write 3 partition quick sort\""
                    }
                ]
            },
            {
                "id": 1927498,
                "content": [
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "We can solve it by simply using Gap method in the merge function that we create for merge sort. Gap method requires O(1) space complexity thus bringing down space complexity to O(1) for complete question and time complexity stays O(nlogn)"
                    },
                    {
                        "username": "Rahul_KD",
                        "content": "People discussing about quick sort or merge sort, le me did this using minHeap "
                    },
                    {
                        "username": "user0411bt",
                        "content": "To all people saying quicksort is giving TLE-> maybe they changed the test cases which are the worst for quicksort. You have to remember at the end of the day, quicksort uses a pivot randomly which we assign as the last element generally. It is fast but not always optimal. Hence it may result in a slower algo sometimes than mergesort. "
                    },
                    {
                        "username": "RP47",
                        "content": "can someone help me? idk why am i getting wrong output for some test cases...i know it will give tle for some test cases since i am using quicksort but it is giving  wrong answer for some test cases.\\n\\nclass Solution {\\npublic:\\n\\nint partition(vector<int>& arr,int s,int e)\\n{\\n    //pick first element for pivot\\n    int pivotindex=s;\\n    int count=0;\\n\\n    //checking how many numbers less than pivot element are on right of pivot\\n    for(int i=pivotindex+1;i<=e;i++)\\n    {\\n        if(arr[i]<arr[pivotindex])\\n            count++;\\n    }\\n\\n    //placing pivot element in its correct position\\n    pivotindex=s+count;\\n    swap(arr[pivotindex],arr[s]);\\n\\n    //now sorting left and right part of pivot by using two pointers i and j\\n    int i=s;//left pointer\\n    int j=e;//right pointer\\n    while(i<pivotindex && j>pivotindex)\\n    {\\n        while(arr[i]<arr[pivotindex])\\n            i++;\\n\\n        while(arr[j]>arr[pivotindex])\\n            j--;\\n\\n        //checking while condition again since we have altered i and j in above loops and haven\\'t checked the condition\\n        if(i<pivotindex && j>pivotindex)\\n        {\\n            swap(arr[i],arr[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    //return partition index to help in calling left and right part quicksort recursively\\n    return pivotindex;\\n}\\n\\nvoid quicksort(vector<int>& arr,int s,int e)\\n{\\n    //Base Case for array consisting of only 0 or 1 element\\n    if(s>=e)\\n        return;\\n\\n    //Finding pivot partition index to use quicksort recursively for left and right of partition\\n    int pivot=partition(arr,s,e);\\n\\n    //recursive call for left of partition\\n    quicksort(arr,s,pivot-1);\\n\\n    //recursive call for right of partition\\n    quicksort(arr,pivot+1,e);\\n}\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        quicksort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "robot_07",
                        "content": "Why does the Inplace Merge Sort technique give TLE here"
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I\\'m using the Dutch national flag 3 way partition and its giving TLE.......WHY.......?????"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Quicksort will work if you do a dual pivot partition (I think its the partition used in the Dutch National Flag Problem). Or alternatively look up a Bentley Mcllroy Partition. \\n\\nI can\\'t imagine being able to come up with that without having previously seen it. And even now that I have, I still can\\'t implement it without spending like 15 -20 minutes debugging it. "
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I did the dual pivot way...still TLE ;("
                    },
                    {
                        "username": "aman3091",
                        "content": "i tried it using recurion but getting an error please correct me \\nclass Solution {\\npublic:\\n    void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n            return ;\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am trying to do it using recursion but getting run time error. please correct it\\n\\n void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "The problem: \"Write 3 partition quick sort\""
                    }
                ]
            },
            {
                "id": 1907902,
                "content": [
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "We can solve it by simply using Gap method in the merge function that we create for merge sort. Gap method requires O(1) space complexity thus bringing down space complexity to O(1) for complete question and time complexity stays O(nlogn)"
                    },
                    {
                        "username": "Rahul_KD",
                        "content": "People discussing about quick sort or merge sort, le me did this using minHeap "
                    },
                    {
                        "username": "user0411bt",
                        "content": "To all people saying quicksort is giving TLE-> maybe they changed the test cases which are the worst for quicksort. You have to remember at the end of the day, quicksort uses a pivot randomly which we assign as the last element generally. It is fast but not always optimal. Hence it may result in a slower algo sometimes than mergesort. "
                    },
                    {
                        "username": "RP47",
                        "content": "can someone help me? idk why am i getting wrong output for some test cases...i know it will give tle for some test cases since i am using quicksort but it is giving  wrong answer for some test cases.\\n\\nclass Solution {\\npublic:\\n\\nint partition(vector<int>& arr,int s,int e)\\n{\\n    //pick first element for pivot\\n    int pivotindex=s;\\n    int count=0;\\n\\n    //checking how many numbers less than pivot element are on right of pivot\\n    for(int i=pivotindex+1;i<=e;i++)\\n    {\\n        if(arr[i]<arr[pivotindex])\\n            count++;\\n    }\\n\\n    //placing pivot element in its correct position\\n    pivotindex=s+count;\\n    swap(arr[pivotindex],arr[s]);\\n\\n    //now sorting left and right part of pivot by using two pointers i and j\\n    int i=s;//left pointer\\n    int j=e;//right pointer\\n    while(i<pivotindex && j>pivotindex)\\n    {\\n        while(arr[i]<arr[pivotindex])\\n            i++;\\n\\n        while(arr[j]>arr[pivotindex])\\n            j--;\\n\\n        //checking while condition again since we have altered i and j in above loops and haven\\'t checked the condition\\n        if(i<pivotindex && j>pivotindex)\\n        {\\n            swap(arr[i],arr[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    //return partition index to help in calling left and right part quicksort recursively\\n    return pivotindex;\\n}\\n\\nvoid quicksort(vector<int>& arr,int s,int e)\\n{\\n    //Base Case for array consisting of only 0 or 1 element\\n    if(s>=e)\\n        return;\\n\\n    //Finding pivot partition index to use quicksort recursively for left and right of partition\\n    int pivot=partition(arr,s,e);\\n\\n    //recursive call for left of partition\\n    quicksort(arr,s,pivot-1);\\n\\n    //recursive call for right of partition\\n    quicksort(arr,pivot+1,e);\\n}\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        quicksort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "robot_07",
                        "content": "Why does the Inplace Merge Sort technique give TLE here"
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I\\'m using the Dutch national flag 3 way partition and its giving TLE.......WHY.......?????"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Quicksort will work if you do a dual pivot partition (I think its the partition used in the Dutch National Flag Problem). Or alternatively look up a Bentley Mcllroy Partition. \\n\\nI can\\'t imagine being able to come up with that without having previously seen it. And even now that I have, I still can\\'t implement it without spending like 15 -20 minutes debugging it. "
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I did the dual pivot way...still TLE ;("
                    },
                    {
                        "username": "aman3091",
                        "content": "i tried it using recurion but getting an error please correct me \\nclass Solution {\\npublic:\\n    void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n            return ;\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am trying to do it using recursion but getting run time error. please correct it\\n\\n void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "The problem: \"Write 3 partition quick sort\""
                    }
                ]
            },
            {
                "id": 1906597,
                "content": [
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "We can solve it by simply using Gap method in the merge function that we create for merge sort. Gap method requires O(1) space complexity thus bringing down space complexity to O(1) for complete question and time complexity stays O(nlogn)"
                    },
                    {
                        "username": "Rahul_KD",
                        "content": "People discussing about quick sort or merge sort, le me did this using minHeap "
                    },
                    {
                        "username": "user0411bt",
                        "content": "To all people saying quicksort is giving TLE-> maybe they changed the test cases which are the worst for quicksort. You have to remember at the end of the day, quicksort uses a pivot randomly which we assign as the last element generally. It is fast but not always optimal. Hence it may result in a slower algo sometimes than mergesort. "
                    },
                    {
                        "username": "RP47",
                        "content": "can someone help me? idk why am i getting wrong output for some test cases...i know it will give tle for some test cases since i am using quicksort but it is giving  wrong answer for some test cases.\\n\\nclass Solution {\\npublic:\\n\\nint partition(vector<int>& arr,int s,int e)\\n{\\n    //pick first element for pivot\\n    int pivotindex=s;\\n    int count=0;\\n\\n    //checking how many numbers less than pivot element are on right of pivot\\n    for(int i=pivotindex+1;i<=e;i++)\\n    {\\n        if(arr[i]<arr[pivotindex])\\n            count++;\\n    }\\n\\n    //placing pivot element in its correct position\\n    pivotindex=s+count;\\n    swap(arr[pivotindex],arr[s]);\\n\\n    //now sorting left and right part of pivot by using two pointers i and j\\n    int i=s;//left pointer\\n    int j=e;//right pointer\\n    while(i<pivotindex && j>pivotindex)\\n    {\\n        while(arr[i]<arr[pivotindex])\\n            i++;\\n\\n        while(arr[j]>arr[pivotindex])\\n            j--;\\n\\n        //checking while condition again since we have altered i and j in above loops and haven\\'t checked the condition\\n        if(i<pivotindex && j>pivotindex)\\n        {\\n            swap(arr[i],arr[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    //return partition index to help in calling left and right part quicksort recursively\\n    return pivotindex;\\n}\\n\\nvoid quicksort(vector<int>& arr,int s,int e)\\n{\\n    //Base Case for array consisting of only 0 or 1 element\\n    if(s>=e)\\n        return;\\n\\n    //Finding pivot partition index to use quicksort recursively for left and right of partition\\n    int pivot=partition(arr,s,e);\\n\\n    //recursive call for left of partition\\n    quicksort(arr,s,pivot-1);\\n\\n    //recursive call for right of partition\\n    quicksort(arr,pivot+1,e);\\n}\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        quicksort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "robot_07",
                        "content": "Why does the Inplace Merge Sort technique give TLE here"
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I\\'m using the Dutch national flag 3 way partition and its giving TLE.......WHY.......?????"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Quicksort will work if you do a dual pivot partition (I think its the partition used in the Dutch National Flag Problem). Or alternatively look up a Bentley Mcllroy Partition. \\n\\nI can\\'t imagine being able to come up with that without having previously seen it. And even now that I have, I still can\\'t implement it without spending like 15 -20 minutes debugging it. "
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I did the dual pivot way...still TLE ;("
                    },
                    {
                        "username": "aman3091",
                        "content": "i tried it using recurion but getting an error please correct me \\nclass Solution {\\npublic:\\n    void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n            return ;\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am trying to do it using recursion but getting run time error. please correct it\\n\\n void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "The problem: \"Write 3 partition quick sort\""
                    }
                ]
            },
            {
                "id": 1847464,
                "content": [
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "We can solve it by simply using Gap method in the merge function that we create for merge sort. Gap method requires O(1) space complexity thus bringing down space complexity to O(1) for complete question and time complexity stays O(nlogn)"
                    },
                    {
                        "username": "Rahul_KD",
                        "content": "People discussing about quick sort or merge sort, le me did this using minHeap "
                    },
                    {
                        "username": "user0411bt",
                        "content": "To all people saying quicksort is giving TLE-> maybe they changed the test cases which are the worst for quicksort. You have to remember at the end of the day, quicksort uses a pivot randomly which we assign as the last element generally. It is fast but not always optimal. Hence it may result in a slower algo sometimes than mergesort. "
                    },
                    {
                        "username": "RP47",
                        "content": "can someone help me? idk why am i getting wrong output for some test cases...i know it will give tle for some test cases since i am using quicksort but it is giving  wrong answer for some test cases.\\n\\nclass Solution {\\npublic:\\n\\nint partition(vector<int>& arr,int s,int e)\\n{\\n    //pick first element for pivot\\n    int pivotindex=s;\\n    int count=0;\\n\\n    //checking how many numbers less than pivot element are on right of pivot\\n    for(int i=pivotindex+1;i<=e;i++)\\n    {\\n        if(arr[i]<arr[pivotindex])\\n            count++;\\n    }\\n\\n    //placing pivot element in its correct position\\n    pivotindex=s+count;\\n    swap(arr[pivotindex],arr[s]);\\n\\n    //now sorting left and right part of pivot by using two pointers i and j\\n    int i=s;//left pointer\\n    int j=e;//right pointer\\n    while(i<pivotindex && j>pivotindex)\\n    {\\n        while(arr[i]<arr[pivotindex])\\n            i++;\\n\\n        while(arr[j]>arr[pivotindex])\\n            j--;\\n\\n        //checking while condition again since we have altered i and j in above loops and haven\\'t checked the condition\\n        if(i<pivotindex && j>pivotindex)\\n        {\\n            swap(arr[i],arr[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    //return partition index to help in calling left and right part quicksort recursively\\n    return pivotindex;\\n}\\n\\nvoid quicksort(vector<int>& arr,int s,int e)\\n{\\n    //Base Case for array consisting of only 0 or 1 element\\n    if(s>=e)\\n        return;\\n\\n    //Finding pivot partition index to use quicksort recursively for left and right of partition\\n    int pivot=partition(arr,s,e);\\n\\n    //recursive call for left of partition\\n    quicksort(arr,s,pivot-1);\\n\\n    //recursive call for right of partition\\n    quicksort(arr,pivot+1,e);\\n}\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        quicksort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "robot_07",
                        "content": "Why does the Inplace Merge Sort technique give TLE here"
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I\\'m using the Dutch national flag 3 way partition and its giving TLE.......WHY.......?????"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Quicksort will work if you do a dual pivot partition (I think its the partition used in the Dutch National Flag Problem). Or alternatively look up a Bentley Mcllroy Partition. \\n\\nI can\\'t imagine being able to come up with that without having previously seen it. And even now that I have, I still can\\'t implement it without spending like 15 -20 minutes debugging it. "
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I did the dual pivot way...still TLE ;("
                    },
                    {
                        "username": "aman3091",
                        "content": "i tried it using recurion but getting an error please correct me \\nclass Solution {\\npublic:\\n    void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n            return ;\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am trying to do it using recursion but getting run time error. please correct it\\n\\n void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "The problem: \"Write 3 partition quick sort\""
                    }
                ]
            },
            {
                "id": 1847462,
                "content": [
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "We can solve it by simply using Gap method in the merge function that we create for merge sort. Gap method requires O(1) space complexity thus bringing down space complexity to O(1) for complete question and time complexity stays O(nlogn)"
                    },
                    {
                        "username": "Rahul_KD",
                        "content": "People discussing about quick sort or merge sort, le me did this using minHeap "
                    },
                    {
                        "username": "user0411bt",
                        "content": "To all people saying quicksort is giving TLE-> maybe they changed the test cases which are the worst for quicksort. You have to remember at the end of the day, quicksort uses a pivot randomly which we assign as the last element generally. It is fast but not always optimal. Hence it may result in a slower algo sometimes than mergesort. "
                    },
                    {
                        "username": "RP47",
                        "content": "can someone help me? idk why am i getting wrong output for some test cases...i know it will give tle for some test cases since i am using quicksort but it is giving  wrong answer for some test cases.\\n\\nclass Solution {\\npublic:\\n\\nint partition(vector<int>& arr,int s,int e)\\n{\\n    //pick first element for pivot\\n    int pivotindex=s;\\n    int count=0;\\n\\n    //checking how many numbers less than pivot element are on right of pivot\\n    for(int i=pivotindex+1;i<=e;i++)\\n    {\\n        if(arr[i]<arr[pivotindex])\\n            count++;\\n    }\\n\\n    //placing pivot element in its correct position\\n    pivotindex=s+count;\\n    swap(arr[pivotindex],arr[s]);\\n\\n    //now sorting left and right part of pivot by using two pointers i and j\\n    int i=s;//left pointer\\n    int j=e;//right pointer\\n    while(i<pivotindex && j>pivotindex)\\n    {\\n        while(arr[i]<arr[pivotindex])\\n            i++;\\n\\n        while(arr[j]>arr[pivotindex])\\n            j--;\\n\\n        //checking while condition again since we have altered i and j in above loops and haven\\'t checked the condition\\n        if(i<pivotindex && j>pivotindex)\\n        {\\n            swap(arr[i],arr[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    //return partition index to help in calling left and right part quicksort recursively\\n    return pivotindex;\\n}\\n\\nvoid quicksort(vector<int>& arr,int s,int e)\\n{\\n    //Base Case for array consisting of only 0 or 1 element\\n    if(s>=e)\\n        return;\\n\\n    //Finding pivot partition index to use quicksort recursively for left and right of partition\\n    int pivot=partition(arr,s,e);\\n\\n    //recursive call for left of partition\\n    quicksort(arr,s,pivot-1);\\n\\n    //recursive call for right of partition\\n    quicksort(arr,pivot+1,e);\\n}\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        quicksort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "robot_07",
                        "content": "Why does the Inplace Merge Sort technique give TLE here"
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I\\'m using the Dutch national flag 3 way partition and its giving TLE.......WHY.......?????"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Quicksort will work if you do a dual pivot partition (I think its the partition used in the Dutch National Flag Problem). Or alternatively look up a Bentley Mcllroy Partition. \\n\\nI can\\'t imagine being able to come up with that without having previously seen it. And even now that I have, I still can\\'t implement it without spending like 15 -20 minutes debugging it. "
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I did the dual pivot way...still TLE ;("
                    },
                    {
                        "username": "aman3091",
                        "content": "i tried it using recurion but getting an error please correct me \\nclass Solution {\\npublic:\\n    void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n            return ;\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am trying to do it using recursion but getting run time error. please correct it\\n\\n void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "The problem: \"Write 3 partition quick sort\""
                    }
                ]
            },
            {
                "id": 1819603,
                "content": [
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "We can solve it by simply using Gap method in the merge function that we create for merge sort. Gap method requires O(1) space complexity thus bringing down space complexity to O(1) for complete question and time complexity stays O(nlogn)"
                    },
                    {
                        "username": "Rahul_KD",
                        "content": "People discussing about quick sort or merge sort, le me did this using minHeap "
                    },
                    {
                        "username": "user0411bt",
                        "content": "To all people saying quicksort is giving TLE-> maybe they changed the test cases which are the worst for quicksort. You have to remember at the end of the day, quicksort uses a pivot randomly which we assign as the last element generally. It is fast but not always optimal. Hence it may result in a slower algo sometimes than mergesort. "
                    },
                    {
                        "username": "RP47",
                        "content": "can someone help me? idk why am i getting wrong output for some test cases...i know it will give tle for some test cases since i am using quicksort but it is giving  wrong answer for some test cases.\\n\\nclass Solution {\\npublic:\\n\\nint partition(vector<int>& arr,int s,int e)\\n{\\n    //pick first element for pivot\\n    int pivotindex=s;\\n    int count=0;\\n\\n    //checking how many numbers less than pivot element are on right of pivot\\n    for(int i=pivotindex+1;i<=e;i++)\\n    {\\n        if(arr[i]<arr[pivotindex])\\n            count++;\\n    }\\n\\n    //placing pivot element in its correct position\\n    pivotindex=s+count;\\n    swap(arr[pivotindex],arr[s]);\\n\\n    //now sorting left and right part of pivot by using two pointers i and j\\n    int i=s;//left pointer\\n    int j=e;//right pointer\\n    while(i<pivotindex && j>pivotindex)\\n    {\\n        while(arr[i]<arr[pivotindex])\\n            i++;\\n\\n        while(arr[j]>arr[pivotindex])\\n            j--;\\n\\n        //checking while condition again since we have altered i and j in above loops and haven\\'t checked the condition\\n        if(i<pivotindex && j>pivotindex)\\n        {\\n            swap(arr[i],arr[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    //return partition index to help in calling left and right part quicksort recursively\\n    return pivotindex;\\n}\\n\\nvoid quicksort(vector<int>& arr,int s,int e)\\n{\\n    //Base Case for array consisting of only 0 or 1 element\\n    if(s>=e)\\n        return;\\n\\n    //Finding pivot partition index to use quicksort recursively for left and right of partition\\n    int pivot=partition(arr,s,e);\\n\\n    //recursive call for left of partition\\n    quicksort(arr,s,pivot-1);\\n\\n    //recursive call for right of partition\\n    quicksort(arr,pivot+1,e);\\n}\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        quicksort(nums,0,nums.size()-1);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "robot_07",
                        "content": "Why does the Inplace Merge Sort technique give TLE here"
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I\\'m using the Dutch national flag 3 way partition and its giving TLE.......WHY.......?????"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Quicksort will work if you do a dual pivot partition (I think its the partition used in the Dutch National Flag Problem). Or alternatively look up a Bentley Mcllroy Partition. \\n\\nI can\\'t imagine being able to come up with that without having previously seen it. And even now that I have, I still can\\'t implement it without spending like 15 -20 minutes debugging it. "
                    },
                    {
                        "username": "Kartik_Srivas19",
                        "content": "I did the dual pivot way...still TLE ;("
                    },
                    {
                        "username": "aman3091",
                        "content": "i tried it using recurion but getting an error please correct me \\nclass Solution {\\npublic:\\n    void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n            return ;\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am trying to do it using recursion but getting run time error. please correct it\\n\\n void insert(vector<int>& nums, int temp){\\n        if(nums[nums.size()-1]<=temp||nums.size()==0){\\n            nums.push_back(temp);\\n        }\\n        int temp2=nums[nums.size()-1];\\n        nums.pop_back();\\n        insert(nums,temp);\\n        nums.push_back(temp2);\\n        return ;\\n    }\\n    void sorting(vector<int>&nums){\\n        if(nums.size()==1){\\n            return ;\\n        }\\n        int temp=nums[nums.size()-1];\\n        nums.pop_back();\\n        sorting(nums);\\n        insert(nums,temp);\\n        return ;\\n    }\\n    vector<int> sortArray(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==0){\\n            return nums;\\n        }\\n        sorting(nums);\\n        return nums;\\n    }"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "The problem: \"Write 3 partition quick sort\""
                    }
                ]
            },
            {
                "id": 1819562,
                "content": [
                    {
                        "username": "faisaladuko",
                        "content": "But why am I getting \"maximum recursion depth exceeded\" error message when I try either Merge Sort or Quick Sort ?"
                    },
                    {
                        "username": "jems1123",
                        "content": "what about min space it will be O(n) whether we are using merge sort or priority queue ,  can someone suggest better the this?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Heap sort"
                    },
                    {
                        "username": "sivaraman12",
                        "content": "I used bubble sort it came up with time limit exceeded"
                    },
                    {
                        "username": "Adarsh_28",
                        "content": "#merge sort\\nfor(int a=0;a<temp.size();a++){\\n            nums[s+a]=temp[a];\\n }\\nwhile copying elements into nums vector why we are doing s+a instead of simply doing nums[a]=temp[a]//it\\'s showing error but i didn\\'t get what actually it means :) "
                    },
                    {
                        "username": "_aka5h",
                        "content": "Heap Sort is Underrated."
                    },
                    {
                        "username": "umeshsakinala",
                        "content": "can we write direct sort(nums.begin(), nums.end()) without writing mergesort algo ?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "You can but is not recommended."
                    },
                    {
                        "username": "Jaiff",
                        "content": "And I chose to ignore that."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Why we are not used built-in library here...\\n  public int[] sortArray(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\nthis code is also accepted by leetcode. so why we need quick sort and other sorting algo. someone explain it.."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@luanct](/luanct) Indeed! I learned quite a lot when quicksort failed for even random picking of pivot. n^2 is not common but could happen so visiting and implementing other algorithms as well as learning about introsort was of great value to me as well!"
                    },
                    {
                        "username": "luanct",
                        "content": "bro they are testing your knowledge about implementing sorting algorithms. "
                    },
                    {
                        "username": "fefe982",
                        "content": "You need an algorithm with worst case complexity of O(nlog(n)) . Average time complexity of O(nlog(n)) may cause \"Time Limit Exceeded\""
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Most probably 1st question of coding interviews"
                    }
                ]
            },
            {
                "id": 1818623,
                "content": [
                    {
                        "username": "faisaladuko",
                        "content": "But why am I getting \"maximum recursion depth exceeded\" error message when I try either Merge Sort or Quick Sort ?"
                    },
                    {
                        "username": "jems1123",
                        "content": "what about min space it will be O(n) whether we are using merge sort or priority queue ,  can someone suggest better the this?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Heap sort"
                    },
                    {
                        "username": "sivaraman12",
                        "content": "I used bubble sort it came up with time limit exceeded"
                    },
                    {
                        "username": "Adarsh_28",
                        "content": "#merge sort\\nfor(int a=0;a<temp.size();a++){\\n            nums[s+a]=temp[a];\\n }\\nwhile copying elements into nums vector why we are doing s+a instead of simply doing nums[a]=temp[a]//it\\'s showing error but i didn\\'t get what actually it means :) "
                    },
                    {
                        "username": "_aka5h",
                        "content": "Heap Sort is Underrated."
                    },
                    {
                        "username": "umeshsakinala",
                        "content": "can we write direct sort(nums.begin(), nums.end()) without writing mergesort algo ?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "You can but is not recommended."
                    },
                    {
                        "username": "Jaiff",
                        "content": "And I chose to ignore that."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Why we are not used built-in library here...\\n  public int[] sortArray(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\nthis code is also accepted by leetcode. so why we need quick sort and other sorting algo. someone explain it.."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@luanct](/luanct) Indeed! I learned quite a lot when quicksort failed for even random picking of pivot. n^2 is not common but could happen so visiting and implementing other algorithms as well as learning about introsort was of great value to me as well!"
                    },
                    {
                        "username": "luanct",
                        "content": "bro they are testing your knowledge about implementing sorting algorithms. "
                    },
                    {
                        "username": "fefe982",
                        "content": "You need an algorithm with worst case complexity of O(nlog(n)) . Average time complexity of O(nlog(n)) may cause \"Time Limit Exceeded\""
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Most probably 1st question of coding interviews"
                    }
                ]
            },
            {
                "id": 1818576,
                "content": [
                    {
                        "username": "faisaladuko",
                        "content": "But why am I getting \"maximum recursion depth exceeded\" error message when I try either Merge Sort or Quick Sort ?"
                    },
                    {
                        "username": "jems1123",
                        "content": "what about min space it will be O(n) whether we are using merge sort or priority queue ,  can someone suggest better the this?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Heap sort"
                    },
                    {
                        "username": "sivaraman12",
                        "content": "I used bubble sort it came up with time limit exceeded"
                    },
                    {
                        "username": "Adarsh_28",
                        "content": "#merge sort\\nfor(int a=0;a<temp.size();a++){\\n            nums[s+a]=temp[a];\\n }\\nwhile copying elements into nums vector why we are doing s+a instead of simply doing nums[a]=temp[a]//it\\'s showing error but i didn\\'t get what actually it means :) "
                    },
                    {
                        "username": "_aka5h",
                        "content": "Heap Sort is Underrated."
                    },
                    {
                        "username": "umeshsakinala",
                        "content": "can we write direct sort(nums.begin(), nums.end()) without writing mergesort algo ?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "You can but is not recommended."
                    },
                    {
                        "username": "Jaiff",
                        "content": "And I chose to ignore that."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Why we are not used built-in library here...\\n  public int[] sortArray(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\nthis code is also accepted by leetcode. so why we need quick sort and other sorting algo. someone explain it.."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@luanct](/luanct) Indeed! I learned quite a lot when quicksort failed for even random picking of pivot. n^2 is not common but could happen so visiting and implementing other algorithms as well as learning about introsort was of great value to me as well!"
                    },
                    {
                        "username": "luanct",
                        "content": "bro they are testing your knowledge about implementing sorting algorithms. "
                    },
                    {
                        "username": "fefe982",
                        "content": "You need an algorithm with worst case complexity of O(nlog(n)) . Average time complexity of O(nlog(n)) may cause \"Time Limit Exceeded\""
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Most probably 1st question of coding interviews"
                    }
                ]
            },
            {
                "id": 1818575,
                "content": [
                    {
                        "username": "faisaladuko",
                        "content": "But why am I getting \"maximum recursion depth exceeded\" error message when I try either Merge Sort or Quick Sort ?"
                    },
                    {
                        "username": "jems1123",
                        "content": "what about min space it will be O(n) whether we are using merge sort or priority queue ,  can someone suggest better the this?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Heap sort"
                    },
                    {
                        "username": "sivaraman12",
                        "content": "I used bubble sort it came up with time limit exceeded"
                    },
                    {
                        "username": "Adarsh_28",
                        "content": "#merge sort\\nfor(int a=0;a<temp.size();a++){\\n            nums[s+a]=temp[a];\\n }\\nwhile copying elements into nums vector why we are doing s+a instead of simply doing nums[a]=temp[a]//it\\'s showing error but i didn\\'t get what actually it means :) "
                    },
                    {
                        "username": "_aka5h",
                        "content": "Heap Sort is Underrated."
                    },
                    {
                        "username": "umeshsakinala",
                        "content": "can we write direct sort(nums.begin(), nums.end()) without writing mergesort algo ?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "You can but is not recommended."
                    },
                    {
                        "username": "Jaiff",
                        "content": "And I chose to ignore that."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Why we are not used built-in library here...\\n  public int[] sortArray(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\nthis code is also accepted by leetcode. so why we need quick sort and other sorting algo. someone explain it.."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@luanct](/luanct) Indeed! I learned quite a lot when quicksort failed for even random picking of pivot. n^2 is not common but could happen so visiting and implementing other algorithms as well as learning about introsort was of great value to me as well!"
                    },
                    {
                        "username": "luanct",
                        "content": "bro they are testing your knowledge about implementing sorting algorithms. "
                    },
                    {
                        "username": "fefe982",
                        "content": "You need an algorithm with worst case complexity of O(nlog(n)) . Average time complexity of O(nlog(n)) may cause \"Time Limit Exceeded\""
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Most probably 1st question of coding interviews"
                    }
                ]
            },
            {
                "id": 1818414,
                "content": [
                    {
                        "username": "faisaladuko",
                        "content": "But why am I getting \"maximum recursion depth exceeded\" error message when I try either Merge Sort or Quick Sort ?"
                    },
                    {
                        "username": "jems1123",
                        "content": "what about min space it will be O(n) whether we are using merge sort or priority queue ,  can someone suggest better the this?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Heap sort"
                    },
                    {
                        "username": "sivaraman12",
                        "content": "I used bubble sort it came up with time limit exceeded"
                    },
                    {
                        "username": "Adarsh_28",
                        "content": "#merge sort\\nfor(int a=0;a<temp.size();a++){\\n            nums[s+a]=temp[a];\\n }\\nwhile copying elements into nums vector why we are doing s+a instead of simply doing nums[a]=temp[a]//it\\'s showing error but i didn\\'t get what actually it means :) "
                    },
                    {
                        "username": "_aka5h",
                        "content": "Heap Sort is Underrated."
                    },
                    {
                        "username": "umeshsakinala",
                        "content": "can we write direct sort(nums.begin(), nums.end()) without writing mergesort algo ?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "You can but is not recommended."
                    },
                    {
                        "username": "Jaiff",
                        "content": "And I chose to ignore that."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Why we are not used built-in library here...\\n  public int[] sortArray(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\nthis code is also accepted by leetcode. so why we need quick sort and other sorting algo. someone explain it.."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@luanct](/luanct) Indeed! I learned quite a lot when quicksort failed for even random picking of pivot. n^2 is not common but could happen so visiting and implementing other algorithms as well as learning about introsort was of great value to me as well!"
                    },
                    {
                        "username": "luanct",
                        "content": "bro they are testing your knowledge about implementing sorting algorithms. "
                    },
                    {
                        "username": "fefe982",
                        "content": "You need an algorithm with worst case complexity of O(nlog(n)) . Average time complexity of O(nlog(n)) may cause \"Time Limit Exceeded\""
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Most probably 1st question of coding interviews"
                    }
                ]
            },
            {
                "id": 1818371,
                "content": [
                    {
                        "username": "faisaladuko",
                        "content": "But why am I getting \"maximum recursion depth exceeded\" error message when I try either Merge Sort or Quick Sort ?"
                    },
                    {
                        "username": "jems1123",
                        "content": "what about min space it will be O(n) whether we are using merge sort or priority queue ,  can someone suggest better the this?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Heap sort"
                    },
                    {
                        "username": "sivaraman12",
                        "content": "I used bubble sort it came up with time limit exceeded"
                    },
                    {
                        "username": "Adarsh_28",
                        "content": "#merge sort\\nfor(int a=0;a<temp.size();a++){\\n            nums[s+a]=temp[a];\\n }\\nwhile copying elements into nums vector why we are doing s+a instead of simply doing nums[a]=temp[a]//it\\'s showing error but i didn\\'t get what actually it means :) "
                    },
                    {
                        "username": "_aka5h",
                        "content": "Heap Sort is Underrated."
                    },
                    {
                        "username": "umeshsakinala",
                        "content": "can we write direct sort(nums.begin(), nums.end()) without writing mergesort algo ?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "You can but is not recommended."
                    },
                    {
                        "username": "Jaiff",
                        "content": "And I chose to ignore that."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Why we are not used built-in library here...\\n  public int[] sortArray(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\nthis code is also accepted by leetcode. so why we need quick sort and other sorting algo. someone explain it.."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@luanct](/luanct) Indeed! I learned quite a lot when quicksort failed for even random picking of pivot. n^2 is not common but could happen so visiting and implementing other algorithms as well as learning about introsort was of great value to me as well!"
                    },
                    {
                        "username": "luanct",
                        "content": "bro they are testing your knowledge about implementing sorting algorithms. "
                    },
                    {
                        "username": "fefe982",
                        "content": "You need an algorithm with worst case complexity of O(nlog(n)) . Average time complexity of O(nlog(n)) may cause \"Time Limit Exceeded\""
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Most probably 1st question of coding interviews"
                    }
                ]
            },
            {
                "id": 1818228,
                "content": [
                    {
                        "username": "faisaladuko",
                        "content": "But why am I getting \"maximum recursion depth exceeded\" error message when I try either Merge Sort or Quick Sort ?"
                    },
                    {
                        "username": "jems1123",
                        "content": "what about min space it will be O(n) whether we are using merge sort or priority queue ,  can someone suggest better the this?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Heap sort"
                    },
                    {
                        "username": "sivaraman12",
                        "content": "I used bubble sort it came up with time limit exceeded"
                    },
                    {
                        "username": "Adarsh_28",
                        "content": "#merge sort\\nfor(int a=0;a<temp.size();a++){\\n            nums[s+a]=temp[a];\\n }\\nwhile copying elements into nums vector why we are doing s+a instead of simply doing nums[a]=temp[a]//it\\'s showing error but i didn\\'t get what actually it means :) "
                    },
                    {
                        "username": "_aka5h",
                        "content": "Heap Sort is Underrated."
                    },
                    {
                        "username": "umeshsakinala",
                        "content": "can we write direct sort(nums.begin(), nums.end()) without writing mergesort algo ?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "You can but is not recommended."
                    },
                    {
                        "username": "Jaiff",
                        "content": "And I chose to ignore that."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Why we are not used built-in library here...\\n  public int[] sortArray(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\nthis code is also accepted by leetcode. so why we need quick sort and other sorting algo. someone explain it.."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@luanct](/luanct) Indeed! I learned quite a lot when quicksort failed for even random picking of pivot. n^2 is not common but could happen so visiting and implementing other algorithms as well as learning about introsort was of great value to me as well!"
                    },
                    {
                        "username": "luanct",
                        "content": "bro they are testing your knowledge about implementing sorting algorithms. "
                    },
                    {
                        "username": "fefe982",
                        "content": "You need an algorithm with worst case complexity of O(nlog(n)) . Average time complexity of O(nlog(n)) may cause \"Time Limit Exceeded\""
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Most probably 1st question of coding interviews"
                    }
                ]
            },
            {
                "id": 1818109,
                "content": [
                    {
                        "username": "faisaladuko",
                        "content": "But why am I getting \"maximum recursion depth exceeded\" error message when I try either Merge Sort or Quick Sort ?"
                    },
                    {
                        "username": "jems1123",
                        "content": "what about min space it will be O(n) whether we are using merge sort or priority queue ,  can someone suggest better the this?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Heap sort"
                    },
                    {
                        "username": "sivaraman12",
                        "content": "I used bubble sort it came up with time limit exceeded"
                    },
                    {
                        "username": "Adarsh_28",
                        "content": "#merge sort\\nfor(int a=0;a<temp.size();a++){\\n            nums[s+a]=temp[a];\\n }\\nwhile copying elements into nums vector why we are doing s+a instead of simply doing nums[a]=temp[a]//it\\'s showing error but i didn\\'t get what actually it means :) "
                    },
                    {
                        "username": "_aka5h",
                        "content": "Heap Sort is Underrated."
                    },
                    {
                        "username": "umeshsakinala",
                        "content": "can we write direct sort(nums.begin(), nums.end()) without writing mergesort algo ?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "You can but is not recommended."
                    },
                    {
                        "username": "Jaiff",
                        "content": "And I chose to ignore that."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Why we are not used built-in library here...\\n  public int[] sortArray(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\nthis code is also accepted by leetcode. so why we need quick sort and other sorting algo. someone explain it.."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@luanct](/luanct) Indeed! I learned quite a lot when quicksort failed for even random picking of pivot. n^2 is not common but could happen so visiting and implementing other algorithms as well as learning about introsort was of great value to me as well!"
                    },
                    {
                        "username": "luanct",
                        "content": "bro they are testing your knowledge about implementing sorting algorithms. "
                    },
                    {
                        "username": "fefe982",
                        "content": "You need an algorithm with worst case complexity of O(nlog(n)) . Average time complexity of O(nlog(n)) may cause \"Time Limit Exceeded\""
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Most probably 1st question of coding interviews"
                    }
                ]
            },
            {
                "id": 1818033,
                "content": [
                    {
                        "username": "faisaladuko",
                        "content": "But why am I getting \"maximum recursion depth exceeded\" error message when I try either Merge Sort or Quick Sort ?"
                    },
                    {
                        "username": "jems1123",
                        "content": "what about min space it will be O(n) whether we are using merge sort or priority queue ,  can someone suggest better the this?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Heap sort"
                    },
                    {
                        "username": "sivaraman12",
                        "content": "I used bubble sort it came up with time limit exceeded"
                    },
                    {
                        "username": "Adarsh_28",
                        "content": "#merge sort\\nfor(int a=0;a<temp.size();a++){\\n            nums[s+a]=temp[a];\\n }\\nwhile copying elements into nums vector why we are doing s+a instead of simply doing nums[a]=temp[a]//it\\'s showing error but i didn\\'t get what actually it means :) "
                    },
                    {
                        "username": "_aka5h",
                        "content": "Heap Sort is Underrated."
                    },
                    {
                        "username": "umeshsakinala",
                        "content": "can we write direct sort(nums.begin(), nums.end()) without writing mergesort algo ?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "You can but is not recommended."
                    },
                    {
                        "username": "Jaiff",
                        "content": "And I chose to ignore that."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Why we are not used built-in library here...\\n  public int[] sortArray(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\nthis code is also accepted by leetcode. so why we need quick sort and other sorting algo. someone explain it.."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@luanct](/luanct) Indeed! I learned quite a lot when quicksort failed for even random picking of pivot. n^2 is not common but could happen so visiting and implementing other algorithms as well as learning about introsort was of great value to me as well!"
                    },
                    {
                        "username": "luanct",
                        "content": "bro they are testing your knowledge about implementing sorting algorithms. "
                    },
                    {
                        "username": "fefe982",
                        "content": "You need an algorithm with worst case complexity of O(nlog(n)) . Average time complexity of O(nlog(n)) may cause \"Time Limit Exceeded\""
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Most probably 1st question of coding interviews"
                    }
                ]
            },
            {
                "id": 1817986,
                "content": [
                    {
                        "username": "faisaladuko",
                        "content": "But why am I getting \"maximum recursion depth exceeded\" error message when I try either Merge Sort or Quick Sort ?"
                    },
                    {
                        "username": "jems1123",
                        "content": "what about min space it will be O(n) whether we are using merge sort or priority queue ,  can someone suggest better the this?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Heap sort"
                    },
                    {
                        "username": "sivaraman12",
                        "content": "I used bubble sort it came up with time limit exceeded"
                    },
                    {
                        "username": "Adarsh_28",
                        "content": "#merge sort\\nfor(int a=0;a<temp.size();a++){\\n            nums[s+a]=temp[a];\\n }\\nwhile copying elements into nums vector why we are doing s+a instead of simply doing nums[a]=temp[a]//it\\'s showing error but i didn\\'t get what actually it means :) "
                    },
                    {
                        "username": "_aka5h",
                        "content": "Heap Sort is Underrated."
                    },
                    {
                        "username": "umeshsakinala",
                        "content": "can we write direct sort(nums.begin(), nums.end()) without writing mergesort algo ?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "You can but is not recommended."
                    },
                    {
                        "username": "Jaiff",
                        "content": "And I chose to ignore that."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Why we are not used built-in library here...\\n  public int[] sortArray(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\nthis code is also accepted by leetcode. so why we need quick sort and other sorting algo. someone explain it.."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "[@luanct](/luanct) Indeed! I learned quite a lot when quicksort failed for even random picking of pivot. n^2 is not common but could happen so visiting and implementing other algorithms as well as learning about introsort was of great value to me as well!"
                    },
                    {
                        "username": "luanct",
                        "content": "bro they are testing your knowledge about implementing sorting algorithms. "
                    },
                    {
                        "username": "fefe982",
                        "content": "You need an algorithm with worst case complexity of O(nlog(n)) . Average time complexity of O(nlog(n)) may cause \"Time Limit Exceeded\""
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Most probably 1st question of coding interviews"
                    }
                ]
            },
            {
                "id": 1817977,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "quicksort vs merge sort ?? "
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "I used Quicksort algorithm but I got TLE on 11/19 testcase.\n\n*Edit: Used Mergesort algorithm passed all testcases 19/19"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Let\\'s say we have an unsorted array [6, 3, 9, 1, 5, 7]. We want to sort this array using the merge sort algorithm. Here\\'s how the algorithm works step by step:\\n\\nThe algorithm starts by dividing the array into two halves. In this case, the midpoint is at index 2, so we have [6, 3, 9] on the left and [1, 5, 7] on the right.\\n\\nThe algorithm recursively sorts the left half of the array using merge sort. This involves dividing the left half again, so the midpoint is at index 1. We have [6, 3] on the left and [9] on the right.\\n\\nThe algorithm recursively sorts the left half of the left half using merge sort. This involves dividing the left half again, so the midpoint is at index 0. We have [6] on the left and [3] on the right.\\n\\nSince both halves of the left half are now sorted, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [3, 6].\\n\\nWe repeat the same process for the right half of the left half. Since there is only one element, we can just copy it over to the new array. We end up with [3, 6, 9].\\n\\nWe repeat the same process for the right half of the original array. We divide the array into [1] and [5, 7], then recursively sort the right half. We divide the right half into [5] and [7], then merge them back together to get [5, 7].\\n\\nNow that we have two sorted halves, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 5, 7].\\n\\nFinally, we merge the two sorted halves together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 3, 5, 6, 7, 9], which is the sorted array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/sort-an-array/solutions/3216911/simple-mergesort-thanks-to-abdul-bari-sir/?orderBy=most_votes"
                    },
                    {
                        "username": "halfengineer",
                        "content": "merge sort"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Thanks for editorial. I now know another approach to sort algorithm- counting sort (easiest sorting)"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Some tips for Quick Sort\\n1. Randomise the pivot.\\n2. Use Hoare\\'s partitioning technique intead of Naive or Lomuto\\'s. Its the fastest.\\n\\n\\nAlthough, in my opinion following would be cheating and would defeat the purpose of solving this tivial propblem, but its still a point to be considered.\\n/*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*/\\nYou can check if the array is sorted or not. If it is then return it as it is. This can help in avoiding certain edge cases for Quick Sort which can result in quadratic time complexity.\\nBesides it won\\'t take much time since you\\'ll be able to check this in linear time."
                    },
                    {
                        "username": "Finally_i_got_the_reason",
                        "content": "Any idea about in-place merge Sort ??"
                    },
                    {
                        "username": "nafizishtiaque",
                        "content": "Even though quicksort performs as O(n^2) in the worst cases, by taking a random pivot point each time one can make sure that the worst case is highly unlikely."
                    },
                    {
                        "username": "2021ugpi047",
                        "content": "counting sort    O(n) approach best approach\\n\\nvector<int> sortArray(vector<int>& arr) {\\n    int max = *max_element(arr.begin(), arr.end());\\n    int min = *min_element(arr.begin(), arr.end());\\n    int range = max - min + 1;\\n \\n    vector<int> count(range), output(arr.size());\\n    for (int i = 0; i < arr.size(); i++)\\n        count[arr[i] - min]++;\\n \\n    for (int i = 1; i < count.size(); i++)\\n        count[i] += count[i - 1];\\n \\n    for (int i = arr.size() - 1; i >= 0; i--) {\\n        output[count[arr[i] - min] - 1] = arr[i];\\n        count[arr[i] - min]--;\\n    }\\n \\n    for (int i = 0; i < arr.size(); i++)\\n        arr[i] = output[i];\\n    return output;\\n    }\\n"
                    },
                    {
                        "username": "Yashw12",
                        "content": " `your inline code...your inline code...` why i am getting runtime error\\n\\nclass Solution {\\npublic:\\n   \\n    void Quicksort(vector<int>& nums,int lb,int ub)\\n    {\\n        \\n            if(lb<ub)\\n            {\\n                int loc = partition(nums,lb,ub);\\n                Quicksort(nums,lb,loc-1);\\n                Quicksort(nums,loc+1,ub);\\n            }\\n            else\\n            {\\n                return;\\n            }\\n    }\\n\\n\\n    int partition(vector<int>& nums, int lb,int ub)\\n    {\\n            \\n            int pivot = nums[lb];\\n            int start = lb;\\n            int end = ub;\\n            while (start<end)\\n            {\\n                while(nums[start]<=pivot)\\n                {\\n                    start++;\\n                }\\n                while(nums[end]> pivot)\\n                {\\n                    end--;\\n                }\\n                if(start<end)\\n                {\\n                    swap(nums[start],nums[end]);\\n                }\\n            }\\n            swap(nums[lb],nums[end]);\\n            return end;\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n    \\n        int n= nums.size();\\n        //int lb = 0;\\n        //int ub = n-1;\\n        Quicksort(nums,0,n-1);\\n        return nums; \\n    }\\n\\n};"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "use a quick sort , got Time limit exceeded for that test case [2,2,2.........2]."
                    }
                ]
            },
            {
                "id": 1817957,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "quicksort vs merge sort ?? "
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "I used Quicksort algorithm but I got TLE on 11/19 testcase.\n\n*Edit: Used Mergesort algorithm passed all testcases 19/19"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Let\\'s say we have an unsorted array [6, 3, 9, 1, 5, 7]. We want to sort this array using the merge sort algorithm. Here\\'s how the algorithm works step by step:\\n\\nThe algorithm starts by dividing the array into two halves. In this case, the midpoint is at index 2, so we have [6, 3, 9] on the left and [1, 5, 7] on the right.\\n\\nThe algorithm recursively sorts the left half of the array using merge sort. This involves dividing the left half again, so the midpoint is at index 1. We have [6, 3] on the left and [9] on the right.\\n\\nThe algorithm recursively sorts the left half of the left half using merge sort. This involves dividing the left half again, so the midpoint is at index 0. We have [6] on the left and [3] on the right.\\n\\nSince both halves of the left half are now sorted, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [3, 6].\\n\\nWe repeat the same process for the right half of the left half. Since there is only one element, we can just copy it over to the new array. We end up with [3, 6, 9].\\n\\nWe repeat the same process for the right half of the original array. We divide the array into [1] and [5, 7], then recursively sort the right half. We divide the right half into [5] and [7], then merge them back together to get [5, 7].\\n\\nNow that we have two sorted halves, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 5, 7].\\n\\nFinally, we merge the two sorted halves together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 3, 5, 6, 7, 9], which is the sorted array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/sort-an-array/solutions/3216911/simple-mergesort-thanks-to-abdul-bari-sir/?orderBy=most_votes"
                    },
                    {
                        "username": "halfengineer",
                        "content": "merge sort"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Thanks for editorial. I now know another approach to sort algorithm- counting sort (easiest sorting)"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Some tips for Quick Sort\\n1. Randomise the pivot.\\n2. Use Hoare\\'s partitioning technique intead of Naive or Lomuto\\'s. Its the fastest.\\n\\n\\nAlthough, in my opinion following would be cheating and would defeat the purpose of solving this tivial propblem, but its still a point to be considered.\\n/*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*/\\nYou can check if the array is sorted or not. If it is then return it as it is. This can help in avoiding certain edge cases for Quick Sort which can result in quadratic time complexity.\\nBesides it won\\'t take much time since you\\'ll be able to check this in linear time."
                    },
                    {
                        "username": "Finally_i_got_the_reason",
                        "content": "Any idea about in-place merge Sort ??"
                    },
                    {
                        "username": "nafizishtiaque",
                        "content": "Even though quicksort performs as O(n^2) in the worst cases, by taking a random pivot point each time one can make sure that the worst case is highly unlikely."
                    },
                    {
                        "username": "2021ugpi047",
                        "content": "counting sort    O(n) approach best approach\\n\\nvector<int> sortArray(vector<int>& arr) {\\n    int max = *max_element(arr.begin(), arr.end());\\n    int min = *min_element(arr.begin(), arr.end());\\n    int range = max - min + 1;\\n \\n    vector<int> count(range), output(arr.size());\\n    for (int i = 0; i < arr.size(); i++)\\n        count[arr[i] - min]++;\\n \\n    for (int i = 1; i < count.size(); i++)\\n        count[i] += count[i - 1];\\n \\n    for (int i = arr.size() - 1; i >= 0; i--) {\\n        output[count[arr[i] - min] - 1] = arr[i];\\n        count[arr[i] - min]--;\\n    }\\n \\n    for (int i = 0; i < arr.size(); i++)\\n        arr[i] = output[i];\\n    return output;\\n    }\\n"
                    },
                    {
                        "username": "Yashw12",
                        "content": " `your inline code...your inline code...` why i am getting runtime error\\n\\nclass Solution {\\npublic:\\n   \\n    void Quicksort(vector<int>& nums,int lb,int ub)\\n    {\\n        \\n            if(lb<ub)\\n            {\\n                int loc = partition(nums,lb,ub);\\n                Quicksort(nums,lb,loc-1);\\n                Quicksort(nums,loc+1,ub);\\n            }\\n            else\\n            {\\n                return;\\n            }\\n    }\\n\\n\\n    int partition(vector<int>& nums, int lb,int ub)\\n    {\\n            \\n            int pivot = nums[lb];\\n            int start = lb;\\n            int end = ub;\\n            while (start<end)\\n            {\\n                while(nums[start]<=pivot)\\n                {\\n                    start++;\\n                }\\n                while(nums[end]> pivot)\\n                {\\n                    end--;\\n                }\\n                if(start<end)\\n                {\\n                    swap(nums[start],nums[end]);\\n                }\\n            }\\n            swap(nums[lb],nums[end]);\\n            return end;\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n    \\n        int n= nums.size();\\n        //int lb = 0;\\n        //int ub = n-1;\\n        Quicksort(nums,0,n-1);\\n        return nums; \\n    }\\n\\n};"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "use a quick sort , got Time limit exceeded for that test case [2,2,2.........2]."
                    }
                ]
            },
            {
                "id": 1817944,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "quicksort vs merge sort ?? "
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "I used Quicksort algorithm but I got TLE on 11/19 testcase.\n\n*Edit: Used Mergesort algorithm passed all testcases 19/19"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Let\\'s say we have an unsorted array [6, 3, 9, 1, 5, 7]. We want to sort this array using the merge sort algorithm. Here\\'s how the algorithm works step by step:\\n\\nThe algorithm starts by dividing the array into two halves. In this case, the midpoint is at index 2, so we have [6, 3, 9] on the left and [1, 5, 7] on the right.\\n\\nThe algorithm recursively sorts the left half of the array using merge sort. This involves dividing the left half again, so the midpoint is at index 1. We have [6, 3] on the left and [9] on the right.\\n\\nThe algorithm recursively sorts the left half of the left half using merge sort. This involves dividing the left half again, so the midpoint is at index 0. We have [6] on the left and [3] on the right.\\n\\nSince both halves of the left half are now sorted, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [3, 6].\\n\\nWe repeat the same process for the right half of the left half. Since there is only one element, we can just copy it over to the new array. We end up with [3, 6, 9].\\n\\nWe repeat the same process for the right half of the original array. We divide the array into [1] and [5, 7], then recursively sort the right half. We divide the right half into [5] and [7], then merge them back together to get [5, 7].\\n\\nNow that we have two sorted halves, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 5, 7].\\n\\nFinally, we merge the two sorted halves together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 3, 5, 6, 7, 9], which is the sorted array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/sort-an-array/solutions/3216911/simple-mergesort-thanks-to-abdul-bari-sir/?orderBy=most_votes"
                    },
                    {
                        "username": "halfengineer",
                        "content": "merge sort"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Thanks for editorial. I now know another approach to sort algorithm- counting sort (easiest sorting)"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Some tips for Quick Sort\\n1. Randomise the pivot.\\n2. Use Hoare\\'s partitioning technique intead of Naive or Lomuto\\'s. Its the fastest.\\n\\n\\nAlthough, in my opinion following would be cheating and would defeat the purpose of solving this tivial propblem, but its still a point to be considered.\\n/*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*/\\nYou can check if the array is sorted or not. If it is then return it as it is. This can help in avoiding certain edge cases for Quick Sort which can result in quadratic time complexity.\\nBesides it won\\'t take much time since you\\'ll be able to check this in linear time."
                    },
                    {
                        "username": "Finally_i_got_the_reason",
                        "content": "Any idea about in-place merge Sort ??"
                    },
                    {
                        "username": "nafizishtiaque",
                        "content": "Even though quicksort performs as O(n^2) in the worst cases, by taking a random pivot point each time one can make sure that the worst case is highly unlikely."
                    },
                    {
                        "username": "2021ugpi047",
                        "content": "counting sort    O(n) approach best approach\\n\\nvector<int> sortArray(vector<int>& arr) {\\n    int max = *max_element(arr.begin(), arr.end());\\n    int min = *min_element(arr.begin(), arr.end());\\n    int range = max - min + 1;\\n \\n    vector<int> count(range), output(arr.size());\\n    for (int i = 0; i < arr.size(); i++)\\n        count[arr[i] - min]++;\\n \\n    for (int i = 1; i < count.size(); i++)\\n        count[i] += count[i - 1];\\n \\n    for (int i = arr.size() - 1; i >= 0; i--) {\\n        output[count[arr[i] - min] - 1] = arr[i];\\n        count[arr[i] - min]--;\\n    }\\n \\n    for (int i = 0; i < arr.size(); i++)\\n        arr[i] = output[i];\\n    return output;\\n    }\\n"
                    },
                    {
                        "username": "Yashw12",
                        "content": " `your inline code...your inline code...` why i am getting runtime error\\n\\nclass Solution {\\npublic:\\n   \\n    void Quicksort(vector<int>& nums,int lb,int ub)\\n    {\\n        \\n            if(lb<ub)\\n            {\\n                int loc = partition(nums,lb,ub);\\n                Quicksort(nums,lb,loc-1);\\n                Quicksort(nums,loc+1,ub);\\n            }\\n            else\\n            {\\n                return;\\n            }\\n    }\\n\\n\\n    int partition(vector<int>& nums, int lb,int ub)\\n    {\\n            \\n            int pivot = nums[lb];\\n            int start = lb;\\n            int end = ub;\\n            while (start<end)\\n            {\\n                while(nums[start]<=pivot)\\n                {\\n                    start++;\\n                }\\n                while(nums[end]> pivot)\\n                {\\n                    end--;\\n                }\\n                if(start<end)\\n                {\\n                    swap(nums[start],nums[end]);\\n                }\\n            }\\n            swap(nums[lb],nums[end]);\\n            return end;\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n    \\n        int n= nums.size();\\n        //int lb = 0;\\n        //int ub = n-1;\\n        Quicksort(nums,0,n-1);\\n        return nums; \\n    }\\n\\n};"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "use a quick sort , got Time limit exceeded for that test case [2,2,2.........2]."
                    }
                ]
            },
            {
                "id": 1817926,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "quicksort vs merge sort ?? "
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "I used Quicksort algorithm but I got TLE on 11/19 testcase.\n\n*Edit: Used Mergesort algorithm passed all testcases 19/19"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Let\\'s say we have an unsorted array [6, 3, 9, 1, 5, 7]. We want to sort this array using the merge sort algorithm. Here\\'s how the algorithm works step by step:\\n\\nThe algorithm starts by dividing the array into two halves. In this case, the midpoint is at index 2, so we have [6, 3, 9] on the left and [1, 5, 7] on the right.\\n\\nThe algorithm recursively sorts the left half of the array using merge sort. This involves dividing the left half again, so the midpoint is at index 1. We have [6, 3] on the left and [9] on the right.\\n\\nThe algorithm recursively sorts the left half of the left half using merge sort. This involves dividing the left half again, so the midpoint is at index 0. We have [6] on the left and [3] on the right.\\n\\nSince both halves of the left half are now sorted, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [3, 6].\\n\\nWe repeat the same process for the right half of the left half. Since there is only one element, we can just copy it over to the new array. We end up with [3, 6, 9].\\n\\nWe repeat the same process for the right half of the original array. We divide the array into [1] and [5, 7], then recursively sort the right half. We divide the right half into [5] and [7], then merge them back together to get [5, 7].\\n\\nNow that we have two sorted halves, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 5, 7].\\n\\nFinally, we merge the two sorted halves together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 3, 5, 6, 7, 9], which is the sorted array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/sort-an-array/solutions/3216911/simple-mergesort-thanks-to-abdul-bari-sir/?orderBy=most_votes"
                    },
                    {
                        "username": "halfengineer",
                        "content": "merge sort"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Thanks for editorial. I now know another approach to sort algorithm- counting sort (easiest sorting)"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Some tips for Quick Sort\\n1. Randomise the pivot.\\n2. Use Hoare\\'s partitioning technique intead of Naive or Lomuto\\'s. Its the fastest.\\n\\n\\nAlthough, in my opinion following would be cheating and would defeat the purpose of solving this tivial propblem, but its still a point to be considered.\\n/*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*/\\nYou can check if the array is sorted or not. If it is then return it as it is. This can help in avoiding certain edge cases for Quick Sort which can result in quadratic time complexity.\\nBesides it won\\'t take much time since you\\'ll be able to check this in linear time."
                    },
                    {
                        "username": "Finally_i_got_the_reason",
                        "content": "Any idea about in-place merge Sort ??"
                    },
                    {
                        "username": "nafizishtiaque",
                        "content": "Even though quicksort performs as O(n^2) in the worst cases, by taking a random pivot point each time one can make sure that the worst case is highly unlikely."
                    },
                    {
                        "username": "2021ugpi047",
                        "content": "counting sort    O(n) approach best approach\\n\\nvector<int> sortArray(vector<int>& arr) {\\n    int max = *max_element(arr.begin(), arr.end());\\n    int min = *min_element(arr.begin(), arr.end());\\n    int range = max - min + 1;\\n \\n    vector<int> count(range), output(arr.size());\\n    for (int i = 0; i < arr.size(); i++)\\n        count[arr[i] - min]++;\\n \\n    for (int i = 1; i < count.size(); i++)\\n        count[i] += count[i - 1];\\n \\n    for (int i = arr.size() - 1; i >= 0; i--) {\\n        output[count[arr[i] - min] - 1] = arr[i];\\n        count[arr[i] - min]--;\\n    }\\n \\n    for (int i = 0; i < arr.size(); i++)\\n        arr[i] = output[i];\\n    return output;\\n    }\\n"
                    },
                    {
                        "username": "Yashw12",
                        "content": " `your inline code...your inline code...` why i am getting runtime error\\n\\nclass Solution {\\npublic:\\n   \\n    void Quicksort(vector<int>& nums,int lb,int ub)\\n    {\\n        \\n            if(lb<ub)\\n            {\\n                int loc = partition(nums,lb,ub);\\n                Quicksort(nums,lb,loc-1);\\n                Quicksort(nums,loc+1,ub);\\n            }\\n            else\\n            {\\n                return;\\n            }\\n    }\\n\\n\\n    int partition(vector<int>& nums, int lb,int ub)\\n    {\\n            \\n            int pivot = nums[lb];\\n            int start = lb;\\n            int end = ub;\\n            while (start<end)\\n            {\\n                while(nums[start]<=pivot)\\n                {\\n                    start++;\\n                }\\n                while(nums[end]> pivot)\\n                {\\n                    end--;\\n                }\\n                if(start<end)\\n                {\\n                    swap(nums[start],nums[end]);\\n                }\\n            }\\n            swap(nums[lb],nums[end]);\\n            return end;\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n    \\n        int n= nums.size();\\n        //int lb = 0;\\n        //int ub = n-1;\\n        Quicksort(nums,0,n-1);\\n        return nums; \\n    }\\n\\n};"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "use a quick sort , got Time limit exceeded for that test case [2,2,2.........2]."
                    }
                ]
            },
            {
                "id": 1817880,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "quicksort vs merge sort ?? "
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "I used Quicksort algorithm but I got TLE on 11/19 testcase.\n\n*Edit: Used Mergesort algorithm passed all testcases 19/19"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Let\\'s say we have an unsorted array [6, 3, 9, 1, 5, 7]. We want to sort this array using the merge sort algorithm. Here\\'s how the algorithm works step by step:\\n\\nThe algorithm starts by dividing the array into two halves. In this case, the midpoint is at index 2, so we have [6, 3, 9] on the left and [1, 5, 7] on the right.\\n\\nThe algorithm recursively sorts the left half of the array using merge sort. This involves dividing the left half again, so the midpoint is at index 1. We have [6, 3] on the left and [9] on the right.\\n\\nThe algorithm recursively sorts the left half of the left half using merge sort. This involves dividing the left half again, so the midpoint is at index 0. We have [6] on the left and [3] on the right.\\n\\nSince both halves of the left half are now sorted, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [3, 6].\\n\\nWe repeat the same process for the right half of the left half. Since there is only one element, we can just copy it over to the new array. We end up with [3, 6, 9].\\n\\nWe repeat the same process for the right half of the original array. We divide the array into [1] and [5, 7], then recursively sort the right half. We divide the right half into [5] and [7], then merge them back together to get [5, 7].\\n\\nNow that we have two sorted halves, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 5, 7].\\n\\nFinally, we merge the two sorted halves together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 3, 5, 6, 7, 9], which is the sorted array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/sort-an-array/solutions/3216911/simple-mergesort-thanks-to-abdul-bari-sir/?orderBy=most_votes"
                    },
                    {
                        "username": "halfengineer",
                        "content": "merge sort"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Thanks for editorial. I now know another approach to sort algorithm- counting sort (easiest sorting)"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Some tips for Quick Sort\\n1. Randomise the pivot.\\n2. Use Hoare\\'s partitioning technique intead of Naive or Lomuto\\'s. Its the fastest.\\n\\n\\nAlthough, in my opinion following would be cheating and would defeat the purpose of solving this tivial propblem, but its still a point to be considered.\\n/*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*/\\nYou can check if the array is sorted or not. If it is then return it as it is. This can help in avoiding certain edge cases for Quick Sort which can result in quadratic time complexity.\\nBesides it won\\'t take much time since you\\'ll be able to check this in linear time."
                    },
                    {
                        "username": "Finally_i_got_the_reason",
                        "content": "Any idea about in-place merge Sort ??"
                    },
                    {
                        "username": "nafizishtiaque",
                        "content": "Even though quicksort performs as O(n^2) in the worst cases, by taking a random pivot point each time one can make sure that the worst case is highly unlikely."
                    },
                    {
                        "username": "2021ugpi047",
                        "content": "counting sort    O(n) approach best approach\\n\\nvector<int> sortArray(vector<int>& arr) {\\n    int max = *max_element(arr.begin(), arr.end());\\n    int min = *min_element(arr.begin(), arr.end());\\n    int range = max - min + 1;\\n \\n    vector<int> count(range), output(arr.size());\\n    for (int i = 0; i < arr.size(); i++)\\n        count[arr[i] - min]++;\\n \\n    for (int i = 1; i < count.size(); i++)\\n        count[i] += count[i - 1];\\n \\n    for (int i = arr.size() - 1; i >= 0; i--) {\\n        output[count[arr[i] - min] - 1] = arr[i];\\n        count[arr[i] - min]--;\\n    }\\n \\n    for (int i = 0; i < arr.size(); i++)\\n        arr[i] = output[i];\\n    return output;\\n    }\\n"
                    },
                    {
                        "username": "Yashw12",
                        "content": " `your inline code...your inline code...` why i am getting runtime error\\n\\nclass Solution {\\npublic:\\n   \\n    void Quicksort(vector<int>& nums,int lb,int ub)\\n    {\\n        \\n            if(lb<ub)\\n            {\\n                int loc = partition(nums,lb,ub);\\n                Quicksort(nums,lb,loc-1);\\n                Quicksort(nums,loc+1,ub);\\n            }\\n            else\\n            {\\n                return;\\n            }\\n    }\\n\\n\\n    int partition(vector<int>& nums, int lb,int ub)\\n    {\\n            \\n            int pivot = nums[lb];\\n            int start = lb;\\n            int end = ub;\\n            while (start<end)\\n            {\\n                while(nums[start]<=pivot)\\n                {\\n                    start++;\\n                }\\n                while(nums[end]> pivot)\\n                {\\n                    end--;\\n                }\\n                if(start<end)\\n                {\\n                    swap(nums[start],nums[end]);\\n                }\\n            }\\n            swap(nums[lb],nums[end]);\\n            return end;\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n    \\n        int n= nums.size();\\n        //int lb = 0;\\n        //int ub = n-1;\\n        Quicksort(nums,0,n-1);\\n        return nums; \\n    }\\n\\n};"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "use a quick sort , got Time limit exceeded for that test case [2,2,2.........2]."
                    }
                ]
            },
            {
                "id": 1817875,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "quicksort vs merge sort ?? "
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "I used Quicksort algorithm but I got TLE on 11/19 testcase.\n\n*Edit: Used Mergesort algorithm passed all testcases 19/19"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Let\\'s say we have an unsorted array [6, 3, 9, 1, 5, 7]. We want to sort this array using the merge sort algorithm. Here\\'s how the algorithm works step by step:\\n\\nThe algorithm starts by dividing the array into two halves. In this case, the midpoint is at index 2, so we have [6, 3, 9] on the left and [1, 5, 7] on the right.\\n\\nThe algorithm recursively sorts the left half of the array using merge sort. This involves dividing the left half again, so the midpoint is at index 1. We have [6, 3] on the left and [9] on the right.\\n\\nThe algorithm recursively sorts the left half of the left half using merge sort. This involves dividing the left half again, so the midpoint is at index 0. We have [6] on the left and [3] on the right.\\n\\nSince both halves of the left half are now sorted, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [3, 6].\\n\\nWe repeat the same process for the right half of the left half. Since there is only one element, we can just copy it over to the new array. We end up with [3, 6, 9].\\n\\nWe repeat the same process for the right half of the original array. We divide the array into [1] and [5, 7], then recursively sort the right half. We divide the right half into [5] and [7], then merge them back together to get [5, 7].\\n\\nNow that we have two sorted halves, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 5, 7].\\n\\nFinally, we merge the two sorted halves together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 3, 5, 6, 7, 9], which is the sorted array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/sort-an-array/solutions/3216911/simple-mergesort-thanks-to-abdul-bari-sir/?orderBy=most_votes"
                    },
                    {
                        "username": "halfengineer",
                        "content": "merge sort"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Thanks for editorial. I now know another approach to sort algorithm- counting sort (easiest sorting)"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Some tips for Quick Sort\\n1. Randomise the pivot.\\n2. Use Hoare\\'s partitioning technique intead of Naive or Lomuto\\'s. Its the fastest.\\n\\n\\nAlthough, in my opinion following would be cheating and would defeat the purpose of solving this tivial propblem, but its still a point to be considered.\\n/*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*/\\nYou can check if the array is sorted or not. If it is then return it as it is. This can help in avoiding certain edge cases for Quick Sort which can result in quadratic time complexity.\\nBesides it won\\'t take much time since you\\'ll be able to check this in linear time."
                    },
                    {
                        "username": "Finally_i_got_the_reason",
                        "content": "Any idea about in-place merge Sort ??"
                    },
                    {
                        "username": "nafizishtiaque",
                        "content": "Even though quicksort performs as O(n^2) in the worst cases, by taking a random pivot point each time one can make sure that the worst case is highly unlikely."
                    },
                    {
                        "username": "2021ugpi047",
                        "content": "counting sort    O(n) approach best approach\\n\\nvector<int> sortArray(vector<int>& arr) {\\n    int max = *max_element(arr.begin(), arr.end());\\n    int min = *min_element(arr.begin(), arr.end());\\n    int range = max - min + 1;\\n \\n    vector<int> count(range), output(arr.size());\\n    for (int i = 0; i < arr.size(); i++)\\n        count[arr[i] - min]++;\\n \\n    for (int i = 1; i < count.size(); i++)\\n        count[i] += count[i - 1];\\n \\n    for (int i = arr.size() - 1; i >= 0; i--) {\\n        output[count[arr[i] - min] - 1] = arr[i];\\n        count[arr[i] - min]--;\\n    }\\n \\n    for (int i = 0; i < arr.size(); i++)\\n        arr[i] = output[i];\\n    return output;\\n    }\\n"
                    },
                    {
                        "username": "Yashw12",
                        "content": " `your inline code...your inline code...` why i am getting runtime error\\n\\nclass Solution {\\npublic:\\n   \\n    void Quicksort(vector<int>& nums,int lb,int ub)\\n    {\\n        \\n            if(lb<ub)\\n            {\\n                int loc = partition(nums,lb,ub);\\n                Quicksort(nums,lb,loc-1);\\n                Quicksort(nums,loc+1,ub);\\n            }\\n            else\\n            {\\n                return;\\n            }\\n    }\\n\\n\\n    int partition(vector<int>& nums, int lb,int ub)\\n    {\\n            \\n            int pivot = nums[lb];\\n            int start = lb;\\n            int end = ub;\\n            while (start<end)\\n            {\\n                while(nums[start]<=pivot)\\n                {\\n                    start++;\\n                }\\n                while(nums[end]> pivot)\\n                {\\n                    end--;\\n                }\\n                if(start<end)\\n                {\\n                    swap(nums[start],nums[end]);\\n                }\\n            }\\n            swap(nums[lb],nums[end]);\\n            return end;\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n    \\n        int n= nums.size();\\n        //int lb = 0;\\n        //int ub = n-1;\\n        Quicksort(nums,0,n-1);\\n        return nums; \\n    }\\n\\n};"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "use a quick sort , got Time limit exceeded for that test case [2,2,2.........2]."
                    }
                ]
            },
            {
                "id": 1817861,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "quicksort vs merge sort ?? "
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "I used Quicksort algorithm but I got TLE on 11/19 testcase.\n\n*Edit: Used Mergesort algorithm passed all testcases 19/19"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Let\\'s say we have an unsorted array [6, 3, 9, 1, 5, 7]. We want to sort this array using the merge sort algorithm. Here\\'s how the algorithm works step by step:\\n\\nThe algorithm starts by dividing the array into two halves. In this case, the midpoint is at index 2, so we have [6, 3, 9] on the left and [1, 5, 7] on the right.\\n\\nThe algorithm recursively sorts the left half of the array using merge sort. This involves dividing the left half again, so the midpoint is at index 1. We have [6, 3] on the left and [9] on the right.\\n\\nThe algorithm recursively sorts the left half of the left half using merge sort. This involves dividing the left half again, so the midpoint is at index 0. We have [6] on the left and [3] on the right.\\n\\nSince both halves of the left half are now sorted, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [3, 6].\\n\\nWe repeat the same process for the right half of the left half. Since there is only one element, we can just copy it over to the new array. We end up with [3, 6, 9].\\n\\nWe repeat the same process for the right half of the original array. We divide the array into [1] and [5, 7], then recursively sort the right half. We divide the right half into [5] and [7], then merge them back together to get [5, 7].\\n\\nNow that we have two sorted halves, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 5, 7].\\n\\nFinally, we merge the two sorted halves together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 3, 5, 6, 7, 9], which is the sorted array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/sort-an-array/solutions/3216911/simple-mergesort-thanks-to-abdul-bari-sir/?orderBy=most_votes"
                    },
                    {
                        "username": "halfengineer",
                        "content": "merge sort"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Thanks for editorial. I now know another approach to sort algorithm- counting sort (easiest sorting)"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Some tips for Quick Sort\\n1. Randomise the pivot.\\n2. Use Hoare\\'s partitioning technique intead of Naive or Lomuto\\'s. Its the fastest.\\n\\n\\nAlthough, in my opinion following would be cheating and would defeat the purpose of solving this tivial propblem, but its still a point to be considered.\\n/*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*/\\nYou can check if the array is sorted or not. If it is then return it as it is. This can help in avoiding certain edge cases for Quick Sort which can result in quadratic time complexity.\\nBesides it won\\'t take much time since you\\'ll be able to check this in linear time."
                    },
                    {
                        "username": "Finally_i_got_the_reason",
                        "content": "Any idea about in-place merge Sort ??"
                    },
                    {
                        "username": "nafizishtiaque",
                        "content": "Even though quicksort performs as O(n^2) in the worst cases, by taking a random pivot point each time one can make sure that the worst case is highly unlikely."
                    },
                    {
                        "username": "2021ugpi047",
                        "content": "counting sort    O(n) approach best approach\\n\\nvector<int> sortArray(vector<int>& arr) {\\n    int max = *max_element(arr.begin(), arr.end());\\n    int min = *min_element(arr.begin(), arr.end());\\n    int range = max - min + 1;\\n \\n    vector<int> count(range), output(arr.size());\\n    for (int i = 0; i < arr.size(); i++)\\n        count[arr[i] - min]++;\\n \\n    for (int i = 1; i < count.size(); i++)\\n        count[i] += count[i - 1];\\n \\n    for (int i = arr.size() - 1; i >= 0; i--) {\\n        output[count[arr[i] - min] - 1] = arr[i];\\n        count[arr[i] - min]--;\\n    }\\n \\n    for (int i = 0; i < arr.size(); i++)\\n        arr[i] = output[i];\\n    return output;\\n    }\\n"
                    },
                    {
                        "username": "Yashw12",
                        "content": " `your inline code...your inline code...` why i am getting runtime error\\n\\nclass Solution {\\npublic:\\n   \\n    void Quicksort(vector<int>& nums,int lb,int ub)\\n    {\\n        \\n            if(lb<ub)\\n            {\\n                int loc = partition(nums,lb,ub);\\n                Quicksort(nums,lb,loc-1);\\n                Quicksort(nums,loc+1,ub);\\n            }\\n            else\\n            {\\n                return;\\n            }\\n    }\\n\\n\\n    int partition(vector<int>& nums, int lb,int ub)\\n    {\\n            \\n            int pivot = nums[lb];\\n            int start = lb;\\n            int end = ub;\\n            while (start<end)\\n            {\\n                while(nums[start]<=pivot)\\n                {\\n                    start++;\\n                }\\n                while(nums[end]> pivot)\\n                {\\n                    end--;\\n                }\\n                if(start<end)\\n                {\\n                    swap(nums[start],nums[end]);\\n                }\\n            }\\n            swap(nums[lb],nums[end]);\\n            return end;\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n    \\n        int n= nums.size();\\n        //int lb = 0;\\n        //int ub = n-1;\\n        Quicksort(nums,0,n-1);\\n        return nums; \\n    }\\n\\n};"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "use a quick sort , got Time limit exceeded for that test case [2,2,2.........2]."
                    }
                ]
            },
            {
                "id": 1801270,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "quicksort vs merge sort ?? "
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "I used Quicksort algorithm but I got TLE on 11/19 testcase.\n\n*Edit: Used Mergesort algorithm passed all testcases 19/19"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Let\\'s say we have an unsorted array [6, 3, 9, 1, 5, 7]. We want to sort this array using the merge sort algorithm. Here\\'s how the algorithm works step by step:\\n\\nThe algorithm starts by dividing the array into two halves. In this case, the midpoint is at index 2, so we have [6, 3, 9] on the left and [1, 5, 7] on the right.\\n\\nThe algorithm recursively sorts the left half of the array using merge sort. This involves dividing the left half again, so the midpoint is at index 1. We have [6, 3] on the left and [9] on the right.\\n\\nThe algorithm recursively sorts the left half of the left half using merge sort. This involves dividing the left half again, so the midpoint is at index 0. We have [6] on the left and [3] on the right.\\n\\nSince both halves of the left half are now sorted, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [3, 6].\\n\\nWe repeat the same process for the right half of the left half. Since there is only one element, we can just copy it over to the new array. We end up with [3, 6, 9].\\n\\nWe repeat the same process for the right half of the original array. We divide the array into [1] and [5, 7], then recursively sort the right half. We divide the right half into [5] and [7], then merge them back together to get [5, 7].\\n\\nNow that we have two sorted halves, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 5, 7].\\n\\nFinally, we merge the two sorted halves together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 3, 5, 6, 7, 9], which is the sorted array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/sort-an-array/solutions/3216911/simple-mergesort-thanks-to-abdul-bari-sir/?orderBy=most_votes"
                    },
                    {
                        "username": "halfengineer",
                        "content": "merge sort"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Thanks for editorial. I now know another approach to sort algorithm- counting sort (easiest sorting)"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Some tips for Quick Sort\\n1. Randomise the pivot.\\n2. Use Hoare\\'s partitioning technique intead of Naive or Lomuto\\'s. Its the fastest.\\n\\n\\nAlthough, in my opinion following would be cheating and would defeat the purpose of solving this tivial propblem, but its still a point to be considered.\\n/*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*/\\nYou can check if the array is sorted or not. If it is then return it as it is. This can help in avoiding certain edge cases for Quick Sort which can result in quadratic time complexity.\\nBesides it won\\'t take much time since you\\'ll be able to check this in linear time."
                    },
                    {
                        "username": "Finally_i_got_the_reason",
                        "content": "Any idea about in-place merge Sort ??"
                    },
                    {
                        "username": "nafizishtiaque",
                        "content": "Even though quicksort performs as O(n^2) in the worst cases, by taking a random pivot point each time one can make sure that the worst case is highly unlikely."
                    },
                    {
                        "username": "2021ugpi047",
                        "content": "counting sort    O(n) approach best approach\\n\\nvector<int> sortArray(vector<int>& arr) {\\n    int max = *max_element(arr.begin(), arr.end());\\n    int min = *min_element(arr.begin(), arr.end());\\n    int range = max - min + 1;\\n \\n    vector<int> count(range), output(arr.size());\\n    for (int i = 0; i < arr.size(); i++)\\n        count[arr[i] - min]++;\\n \\n    for (int i = 1; i < count.size(); i++)\\n        count[i] += count[i - 1];\\n \\n    for (int i = arr.size() - 1; i >= 0; i--) {\\n        output[count[arr[i] - min] - 1] = arr[i];\\n        count[arr[i] - min]--;\\n    }\\n \\n    for (int i = 0; i < arr.size(); i++)\\n        arr[i] = output[i];\\n    return output;\\n    }\\n"
                    },
                    {
                        "username": "Yashw12",
                        "content": " `your inline code...your inline code...` why i am getting runtime error\\n\\nclass Solution {\\npublic:\\n   \\n    void Quicksort(vector<int>& nums,int lb,int ub)\\n    {\\n        \\n            if(lb<ub)\\n            {\\n                int loc = partition(nums,lb,ub);\\n                Quicksort(nums,lb,loc-1);\\n                Quicksort(nums,loc+1,ub);\\n            }\\n            else\\n            {\\n                return;\\n            }\\n    }\\n\\n\\n    int partition(vector<int>& nums, int lb,int ub)\\n    {\\n            \\n            int pivot = nums[lb];\\n            int start = lb;\\n            int end = ub;\\n            while (start<end)\\n            {\\n                while(nums[start]<=pivot)\\n                {\\n                    start++;\\n                }\\n                while(nums[end]> pivot)\\n                {\\n                    end--;\\n                }\\n                if(start<end)\\n                {\\n                    swap(nums[start],nums[end]);\\n                }\\n            }\\n            swap(nums[lb],nums[end]);\\n            return end;\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n    \\n        int n= nums.size();\\n        //int lb = 0;\\n        //int ub = n-1;\\n        Quicksort(nums,0,n-1);\\n        return nums; \\n    }\\n\\n};"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "use a quick sort , got Time limit exceeded for that test case [2,2,2.........2]."
                    }
                ]
            },
            {
                "id": 1792216,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "quicksort vs merge sort ?? "
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "I used Quicksort algorithm but I got TLE on 11/19 testcase.\n\n*Edit: Used Mergesort algorithm passed all testcases 19/19"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Let\\'s say we have an unsorted array [6, 3, 9, 1, 5, 7]. We want to sort this array using the merge sort algorithm. Here\\'s how the algorithm works step by step:\\n\\nThe algorithm starts by dividing the array into two halves. In this case, the midpoint is at index 2, so we have [6, 3, 9] on the left and [1, 5, 7] on the right.\\n\\nThe algorithm recursively sorts the left half of the array using merge sort. This involves dividing the left half again, so the midpoint is at index 1. We have [6, 3] on the left and [9] on the right.\\n\\nThe algorithm recursively sorts the left half of the left half using merge sort. This involves dividing the left half again, so the midpoint is at index 0. We have [6] on the left and [3] on the right.\\n\\nSince both halves of the left half are now sorted, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [3, 6].\\n\\nWe repeat the same process for the right half of the left half. Since there is only one element, we can just copy it over to the new array. We end up with [3, 6, 9].\\n\\nWe repeat the same process for the right half of the original array. We divide the array into [1] and [5, 7], then recursively sort the right half. We divide the right half into [5] and [7], then merge them back together to get [5, 7].\\n\\nNow that we have two sorted halves, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 5, 7].\\n\\nFinally, we merge the two sorted halves together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 3, 5, 6, 7, 9], which is the sorted array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/sort-an-array/solutions/3216911/simple-mergesort-thanks-to-abdul-bari-sir/?orderBy=most_votes"
                    },
                    {
                        "username": "halfengineer",
                        "content": "merge sort"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Thanks for editorial. I now know another approach to sort algorithm- counting sort (easiest sorting)"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Some tips for Quick Sort\\n1. Randomise the pivot.\\n2. Use Hoare\\'s partitioning technique intead of Naive or Lomuto\\'s. Its the fastest.\\n\\n\\nAlthough, in my opinion following would be cheating and would defeat the purpose of solving this tivial propblem, but its still a point to be considered.\\n/*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*/\\nYou can check if the array is sorted or not. If it is then return it as it is. This can help in avoiding certain edge cases for Quick Sort which can result in quadratic time complexity.\\nBesides it won\\'t take much time since you\\'ll be able to check this in linear time."
                    },
                    {
                        "username": "Finally_i_got_the_reason",
                        "content": "Any idea about in-place merge Sort ??"
                    },
                    {
                        "username": "nafizishtiaque",
                        "content": "Even though quicksort performs as O(n^2) in the worst cases, by taking a random pivot point each time one can make sure that the worst case is highly unlikely."
                    },
                    {
                        "username": "2021ugpi047",
                        "content": "counting sort    O(n) approach best approach\\n\\nvector<int> sortArray(vector<int>& arr) {\\n    int max = *max_element(arr.begin(), arr.end());\\n    int min = *min_element(arr.begin(), arr.end());\\n    int range = max - min + 1;\\n \\n    vector<int> count(range), output(arr.size());\\n    for (int i = 0; i < arr.size(); i++)\\n        count[arr[i] - min]++;\\n \\n    for (int i = 1; i < count.size(); i++)\\n        count[i] += count[i - 1];\\n \\n    for (int i = arr.size() - 1; i >= 0; i--) {\\n        output[count[arr[i] - min] - 1] = arr[i];\\n        count[arr[i] - min]--;\\n    }\\n \\n    for (int i = 0; i < arr.size(); i++)\\n        arr[i] = output[i];\\n    return output;\\n    }\\n"
                    },
                    {
                        "username": "Yashw12",
                        "content": " `your inline code...your inline code...` why i am getting runtime error\\n\\nclass Solution {\\npublic:\\n   \\n    void Quicksort(vector<int>& nums,int lb,int ub)\\n    {\\n        \\n            if(lb<ub)\\n            {\\n                int loc = partition(nums,lb,ub);\\n                Quicksort(nums,lb,loc-1);\\n                Quicksort(nums,loc+1,ub);\\n            }\\n            else\\n            {\\n                return;\\n            }\\n    }\\n\\n\\n    int partition(vector<int>& nums, int lb,int ub)\\n    {\\n            \\n            int pivot = nums[lb];\\n            int start = lb;\\n            int end = ub;\\n            while (start<end)\\n            {\\n                while(nums[start]<=pivot)\\n                {\\n                    start++;\\n                }\\n                while(nums[end]> pivot)\\n                {\\n                    end--;\\n                }\\n                if(start<end)\\n                {\\n                    swap(nums[start],nums[end]);\\n                }\\n            }\\n            swap(nums[lb],nums[end]);\\n            return end;\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n    \\n        int n= nums.size();\\n        //int lb = 0;\\n        //int ub = n-1;\\n        Quicksort(nums,0,n-1);\\n        return nums; \\n    }\\n\\n};"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "use a quick sort , got Time limit exceeded for that test case [2,2,2.........2]."
                    }
                ]
            },
            {
                "id": 1788059,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "quicksort vs merge sort ?? "
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "I used Quicksort algorithm but I got TLE on 11/19 testcase.\n\n*Edit: Used Mergesort algorithm passed all testcases 19/19"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Let\\'s say we have an unsorted array [6, 3, 9, 1, 5, 7]. We want to sort this array using the merge sort algorithm. Here\\'s how the algorithm works step by step:\\n\\nThe algorithm starts by dividing the array into two halves. In this case, the midpoint is at index 2, so we have [6, 3, 9] on the left and [1, 5, 7] on the right.\\n\\nThe algorithm recursively sorts the left half of the array using merge sort. This involves dividing the left half again, so the midpoint is at index 1. We have [6, 3] on the left and [9] on the right.\\n\\nThe algorithm recursively sorts the left half of the left half using merge sort. This involves dividing the left half again, so the midpoint is at index 0. We have [6] on the left and [3] on the right.\\n\\nSince both halves of the left half are now sorted, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [3, 6].\\n\\nWe repeat the same process for the right half of the left half. Since there is only one element, we can just copy it over to the new array. We end up with [3, 6, 9].\\n\\nWe repeat the same process for the right half of the original array. We divide the array into [1] and [5, 7], then recursively sort the right half. We divide the right half into [5] and [7], then merge them back together to get [5, 7].\\n\\nNow that we have two sorted halves, we merge them back together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 5, 7].\\n\\nFinally, we merge the two sorted halves together. We start with two pointers, one for each half, and compare the values at those pointers. We take the smaller value and add it to a new array, incrementing the pointer for that half. We continue doing this until we have added all the elements to the new array. In this case, we end up with [1, 3, 5, 6, 7, 9], which is the sorted array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/sort-an-array/solutions/3216911/simple-mergesort-thanks-to-abdul-bari-sir/?orderBy=most_votes"
                    },
                    {
                        "username": "halfengineer",
                        "content": "merge sort"
                    },
                    {
                        "username": "LeeCohen43",
                        "content": "Thanks for editorial. I now know another approach to sort algorithm- counting sort (easiest sorting)"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Some tips for Quick Sort\\n1. Randomise the pivot.\\n2. Use Hoare\\'s partitioning technique intead of Naive or Lomuto\\'s. Its the fastest.\\n\\n\\nAlthough, in my opinion following would be cheating and would defeat the purpose of solving this tivial propblem, but its still a point to be considered.\\n/*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*\\n*/\\nYou can check if the array is sorted or not. If it is then return it as it is. This can help in avoiding certain edge cases for Quick Sort which can result in quadratic time complexity.\\nBesides it won\\'t take much time since you\\'ll be able to check this in linear time."
                    },
                    {
                        "username": "Finally_i_got_the_reason",
                        "content": "Any idea about in-place merge Sort ??"
                    },
                    {
                        "username": "nafizishtiaque",
                        "content": "Even though quicksort performs as O(n^2) in the worst cases, by taking a random pivot point each time one can make sure that the worst case is highly unlikely."
                    },
                    {
                        "username": "2021ugpi047",
                        "content": "counting sort    O(n) approach best approach\\n\\nvector<int> sortArray(vector<int>& arr) {\\n    int max = *max_element(arr.begin(), arr.end());\\n    int min = *min_element(arr.begin(), arr.end());\\n    int range = max - min + 1;\\n \\n    vector<int> count(range), output(arr.size());\\n    for (int i = 0; i < arr.size(); i++)\\n        count[arr[i] - min]++;\\n \\n    for (int i = 1; i < count.size(); i++)\\n        count[i] += count[i - 1];\\n \\n    for (int i = arr.size() - 1; i >= 0; i--) {\\n        output[count[arr[i] - min] - 1] = arr[i];\\n        count[arr[i] - min]--;\\n    }\\n \\n    for (int i = 0; i < arr.size(); i++)\\n        arr[i] = output[i];\\n    return output;\\n    }\\n"
                    },
                    {
                        "username": "Yashw12",
                        "content": " `your inline code...your inline code...` why i am getting runtime error\\n\\nclass Solution {\\npublic:\\n   \\n    void Quicksort(vector<int>& nums,int lb,int ub)\\n    {\\n        \\n            if(lb<ub)\\n            {\\n                int loc = partition(nums,lb,ub);\\n                Quicksort(nums,lb,loc-1);\\n                Quicksort(nums,loc+1,ub);\\n            }\\n            else\\n            {\\n                return;\\n            }\\n    }\\n\\n\\n    int partition(vector<int>& nums, int lb,int ub)\\n    {\\n            \\n            int pivot = nums[lb];\\n            int start = lb;\\n            int end = ub;\\n            while (start<end)\\n            {\\n                while(nums[start]<=pivot)\\n                {\\n                    start++;\\n                }\\n                while(nums[end]> pivot)\\n                {\\n                    end--;\\n                }\\n                if(start<end)\\n                {\\n                    swap(nums[start],nums[end]);\\n                }\\n            }\\n            swap(nums[lb],nums[end]);\\n            return end;\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) \\n    {\\n    \\n        int n= nums.size();\\n        //int lb = 0;\\n        //int ub = n-1;\\n        Quicksort(nums,0,n-1);\\n        return nums; \\n    }\\n\\n};"
                    },
                    {
                        "username": "bluecode2017",
                        "content": "use a quick sort , got Time limit exceeded for that test case [2,2,2.........2]."
                    }
                ]
            },
            {
                "id": 1777053,
                "content": [
                    {
                        "username": "pratyaksh_jindal",
                        "content": "This is a simple merge sort question.\\nIf anyone faces any difficulty I strongly recommend video from Love Babbar on youtube."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "merge sort is better for LinkedLists than arrays. Try using CountSort. "
                    },
                    {
                        "username": "riya00singh99",
                        "content": "what is problem in this code??\n\nclass Solution {\npublic:\n    void conquere(vector<int> &nums,int l,int e){\n        if(l>=e){\n            return;\n        }\n        int mid=(e-l)/2+l;\n        int i=l;\n        int j=mid+1;\n        int k=l;\n        int size=e-l+1;\n        vector<int> arr(size,0);\n        while(i<=mid && j<=e){\n            if(nums[i]<nums[j]){\n                arr[k++]=nums[i++];\n            }\n            else if(nums[i]>nums[j]){\n                arr[k++]=nums[j++];\n            }\n            else{\n                arr[k++]=nums[i++];\n            }\n        }\n         while(i<=mid){\n        arr[k++]=nums[i++];\n        }\n            \n\n        while(j<=e){\n         arr[k++]=nums[j++];\n        }\n        for(int i=l;i<=e;i++){\n            nums[i]=arr[i];\n        }\n\n    }\n    void divide(vector<int> &nums,int l,int e){\n        if(l<e){ \n            int mid=l+(e-l)/2;\n            divide(nums,l,mid);\n            divide(nums,mid+1,e);\n            conquere(nums,l,e);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        if (nums.size() == 1||nums.size()==0){\n            return nums;\n        }\n\n        divide(nums,0,nums.size()-1);\n        return nums;\n    }\n};"
                    },
                    {
                        "username": "guobao2",
                        "content": "Here is a parallel implementation with Java Fork & Join framework https://leetcode.com/problems/sort-an-array/solutions/3051840/parallel-implantation (faster than 57.6%). I thought it would be faster than all other approaches. However, it's slower than an iterative implementation I submitted https://leetcode.com/problems/sort-an-array/solutions/3052184/iterative-implementation (faster than 91.6%). If you know why please let me know."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "isn\\'t this problem set Asking for merge Sort to be applied on it?"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "There\\'s a lot of O(nlogn) sorting algorithms, merge sort is just the most well known"
                    },
                    {
                        "username": "vishalRai26",
                        "content": "yes"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried using sorted(nums) in python just to see what happened if I tried to use a built in function and it went through just fine."
                    },
                    {
                        "username": "zafirhossain69",
                        "content": "and its even faster xD"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "I am getting the following answer (I am using quick sort combined with bubble sort): \n\nTime Limit Exceeded\n18 / 18 testcases passed\n\nLast Executed Input\nnums =\n\nCould this be a bug?"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "[@Ashutosh_Bhai](/Ashutosh_Bhai) Quick sort is too slow in some cases. I managed to get an accepted time with merge sort. My question was about the contradiction that initially all testcases passed, but TLE."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "U have used Bubble sort that\\'s why you faced TLE. I suggest, using either Heap sort or Quick sort will satisfy all given constraints."
                    },
                    {
                        "username": "akki407",
                        "content": "Can we solve this question using recursion ??"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": " Solve this question by using Heap sort or quick sort algorithm ...It will satisfy all given condition"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "recursion works yes in O(nlogn) afaik"
                    },
                    {
                        "username": "simrann20",
                        "content": "Yes I tried with recursion, however time complexity would be greater than O(nlogn) and only 9/18 test cases pass and give TLE."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": " Easy C++ Solution\\n`vector<int> sortArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Read the question Carefully. **without using any built-in functions** written."
                    },
                    {
                        "username": "jjq_piano",
                        "content": "C quick sort memory beats 79%\\n\\n```\\n\\nint* sortArray(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    srand((unsigned)time(NULL));\\n    for (int i=0; i< numsSize; i++) {\\n        int j = rand() % numsSize;\\n        swap(nums, nums+j, nums+i);\\n    }\\n    q_sort(nums, 0, numsSize - 1);\\n    return nums;\\n}\\n\\n\\n\\nvoid q_sort(int* q, int l, int r) {\\n    if (l >= r) return;\\n    int mid = q[l], i = l+1, j = r;\\n    while (i<j) {\\n        while (q[i] < mid && i<j) {\\n            i++;\\n        }\\n        while (q[j] >mid && j > i) {\\n            j--;\\n        }\\n        if (i<j) {\\n            swap(q+i, q+j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    if (q[i] < mid) {\\n        swap(q+l, q+i);\\n        q_sort(q, l, i-1);\\n        q_sort(q,i+1,r);\\n    } else {\\n        swap(q+l, q+i-1);\\n        q_sort(q, l, i-2);\\n        q_sort(q,i,r);\\n    }\\n\\n}\\n\\nvoid swap(int* i , int* j) {\\n    int tmp = *i;\\n    *i = *j;\\n    *j = tmp;\\n}\\n\\n```"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\n     public static void quickSort(int arr[],int si,int ei){\n        if(si>=ei)\n            return;\n        int p_ind = ei;\n        int pivot = arr[p_ind];\n        int j=si;\n        int i=si-1,temp=0;\n        while(j<ei){\n            if(arr[j]<=pivot){\n                i++;\n                temp = arr[j];\n                arr[j]=arr[i];\n                arr[i]=temp;\n            }\n            j++;\n        }\n        i++;\n        temp = pivot;\n        arr[ei]=arr[i];\n        arr[i]=temp;\n        quickSort(arr,si,i-1);\n        quickSort(arr,i+1,ei);\n        \n    }\n    public int[] sortArray(int[] nums) {\n        quickSort(nums,0,nums.length-1);\n        return nums;\n    }\n}\nWhy this code is passing 14/18 test cases can anyone explain?"
                    },
                    {
                        "username": "Udit_69",
                        "content": "[@manishdude1998](/manishdude1998)  No bro its giving wrong answer\nI have done this \nclass Solution {\npublic static void quickSort(int arr[],int si,int ei){\nif(si>=ei)\nreturn;\nint mid = (si + ei)/2;\nint temp = arr[ei];\narr[si] = arr[mid];\narr[mid] = temp;\nint p_ind = ei;\nint pivot = arr[p_ind];\nint j=si;\nint i=si-1;\nwhile(j<ei){\nif(arr[j]<=pivot){\ni++;\ntemp = arr[j];\narr[j]=arr[i];\narr[i]=temp;\n}\nj++;\n}\ni++;\ntemp = pivot;\narr[ei]=arr[i];\narr[i]=temp;\nquickSort(arr,si,i-1);\nquickSort(arr,i+1,ei);\n\n}\npublic int[] sortArray(int[] nums) {\n    if (nums == null || nums.length == 0){\n            return nums;\n        }\n    quickSort(nums,0,nums.length-1);\n    return nums;\n}\n}\nBut dude quicksort in worst case will give n square complexity, so I try with merge sort  which has best and worst complexity as nlogn so below is my code, it works and accepted as well check this\n\n// code for same by merge sort\nclass Solution {\n    \tpublic static void merge(int arr[],int si,int ei){\n        int mid = si+(ei-si)/2;\n        int i=si,j=mid+1,k=si;\n        int temp[]=new int[ei+1];\n        while(i<=mid&&j<=ei){\n            if(arr[i]<arr[j])\n                temp[k++]=arr[i++];\n            else if(arr[i]>arr[j])\n                temp[k++]=arr[j++];\n            else\n               temp[k++] = arr[i++];\n        }\n        for(;i<=mid;i++){\n            temp[k]=arr[i];\n            k++;\n        }\n        for(;j<=ei;j++){\n            temp[k]=arr[j];\n            k++;\n        }\n        for(int l=si;l<=ei;l++) {\n        \tarr[l]=temp[l];\n        }\n        \n    }\n    public static void mergeSort(int arr[],int start,int end){\n        int si=start;\n        int ei=end;\n        int mid = si+(ei-si)/2;\n     if(si>=ei){\n         return;\n     }\n     mergeSort(arr,si,mid); \n     mergeSort(arr,mid+1,ei);\n     merge(arr,si,ei);\n    }\n\n    public int[] sortArray(int[] nums) {\n        if (nums == null || nums.length == 0){\n            return nums;\n        }\n        mergeSort(nums,0,nums.length-1);\n        return nums;\n    }\n} "
                    },
                    {
                        "username": "manishdude1998",
                        "content": "let\\'s say we have\\n\\nnums = [ 1,2,3,4,5,6,7,8,9,10,11,12,14,13] \\n\\nIn this case, if we use the last element as a pivot we are making about 12 calls to quickSort();\\n\\nhowever, if you change the way you are partitioning the array the number of calls can be decreased\\n\\nlike swapping the middle element with the last element first and then partitioning the array\\nthis will make less than 12 calls\\n\\njust add this to your code after the base condition in quickSort function,\\n\\n```java\\nint mid = (si + ei)/2;\\nint tmp = arr[ei];\\narr[si] = arr[mid];\\narr[mid] = tmp;\\n```\\n\\nalso add this at the top in the given sortArray function\\n\\n```java\\nif (nums == null || nums.length == 0){\\n            return nums;\\n        }\\n```\\n\\nThis should clear all the test cases."
                    }
                ]
            },
            {
                "id": 1776900,
                "content": [
                    {
                        "username": "pratyaksh_jindal",
                        "content": "This is a simple merge sort question.\\nIf anyone faces any difficulty I strongly recommend video from Love Babbar on youtube."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "merge sort is better for LinkedLists than arrays. Try using CountSort. "
                    },
                    {
                        "username": "riya00singh99",
                        "content": "what is problem in this code??\n\nclass Solution {\npublic:\n    void conquere(vector<int> &nums,int l,int e){\n        if(l>=e){\n            return;\n        }\n        int mid=(e-l)/2+l;\n        int i=l;\n        int j=mid+1;\n        int k=l;\n        int size=e-l+1;\n        vector<int> arr(size,0);\n        while(i<=mid && j<=e){\n            if(nums[i]<nums[j]){\n                arr[k++]=nums[i++];\n            }\n            else if(nums[i]>nums[j]){\n                arr[k++]=nums[j++];\n            }\n            else{\n                arr[k++]=nums[i++];\n            }\n        }\n         while(i<=mid){\n        arr[k++]=nums[i++];\n        }\n            \n\n        while(j<=e){\n         arr[k++]=nums[j++];\n        }\n        for(int i=l;i<=e;i++){\n            nums[i]=arr[i];\n        }\n\n    }\n    void divide(vector<int> &nums,int l,int e){\n        if(l<e){ \n            int mid=l+(e-l)/2;\n            divide(nums,l,mid);\n            divide(nums,mid+1,e);\n            conquere(nums,l,e);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        if (nums.size() == 1||nums.size()==0){\n            return nums;\n        }\n\n        divide(nums,0,nums.size()-1);\n        return nums;\n    }\n};"
                    },
                    {
                        "username": "guobao2",
                        "content": "Here is a parallel implementation with Java Fork & Join framework https://leetcode.com/problems/sort-an-array/solutions/3051840/parallel-implantation (faster than 57.6%). I thought it would be faster than all other approaches. However, it's slower than an iterative implementation I submitted https://leetcode.com/problems/sort-an-array/solutions/3052184/iterative-implementation (faster than 91.6%). If you know why please let me know."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "isn\\'t this problem set Asking for merge Sort to be applied on it?"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "There\\'s a lot of O(nlogn) sorting algorithms, merge sort is just the most well known"
                    },
                    {
                        "username": "vishalRai26",
                        "content": "yes"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried using sorted(nums) in python just to see what happened if I tried to use a built in function and it went through just fine."
                    },
                    {
                        "username": "zafirhossain69",
                        "content": "and its even faster xD"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "I am getting the following answer (I am using quick sort combined with bubble sort): \n\nTime Limit Exceeded\n18 / 18 testcases passed\n\nLast Executed Input\nnums =\n\nCould this be a bug?"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "[@Ashutosh_Bhai](/Ashutosh_Bhai) Quick sort is too slow in some cases. I managed to get an accepted time with merge sort. My question was about the contradiction that initially all testcases passed, but TLE."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "U have used Bubble sort that\\'s why you faced TLE. I suggest, using either Heap sort or Quick sort will satisfy all given constraints."
                    },
                    {
                        "username": "akki407",
                        "content": "Can we solve this question using recursion ??"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": " Solve this question by using Heap sort or quick sort algorithm ...It will satisfy all given condition"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "recursion works yes in O(nlogn) afaik"
                    },
                    {
                        "username": "simrann20",
                        "content": "Yes I tried with recursion, however time complexity would be greater than O(nlogn) and only 9/18 test cases pass and give TLE."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": " Easy C++ Solution\\n`vector<int> sortArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Read the question Carefully. **without using any built-in functions** written."
                    },
                    {
                        "username": "jjq_piano",
                        "content": "C quick sort memory beats 79%\\n\\n```\\n\\nint* sortArray(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    srand((unsigned)time(NULL));\\n    for (int i=0; i< numsSize; i++) {\\n        int j = rand() % numsSize;\\n        swap(nums, nums+j, nums+i);\\n    }\\n    q_sort(nums, 0, numsSize - 1);\\n    return nums;\\n}\\n\\n\\n\\nvoid q_sort(int* q, int l, int r) {\\n    if (l >= r) return;\\n    int mid = q[l], i = l+1, j = r;\\n    while (i<j) {\\n        while (q[i] < mid && i<j) {\\n            i++;\\n        }\\n        while (q[j] >mid && j > i) {\\n            j--;\\n        }\\n        if (i<j) {\\n            swap(q+i, q+j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    if (q[i] < mid) {\\n        swap(q+l, q+i);\\n        q_sort(q, l, i-1);\\n        q_sort(q,i+1,r);\\n    } else {\\n        swap(q+l, q+i-1);\\n        q_sort(q, l, i-2);\\n        q_sort(q,i,r);\\n    }\\n\\n}\\n\\nvoid swap(int* i , int* j) {\\n    int tmp = *i;\\n    *i = *j;\\n    *j = tmp;\\n}\\n\\n```"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\n     public static void quickSort(int arr[],int si,int ei){\n        if(si>=ei)\n            return;\n        int p_ind = ei;\n        int pivot = arr[p_ind];\n        int j=si;\n        int i=si-1,temp=0;\n        while(j<ei){\n            if(arr[j]<=pivot){\n                i++;\n                temp = arr[j];\n                arr[j]=arr[i];\n                arr[i]=temp;\n            }\n            j++;\n        }\n        i++;\n        temp = pivot;\n        arr[ei]=arr[i];\n        arr[i]=temp;\n        quickSort(arr,si,i-1);\n        quickSort(arr,i+1,ei);\n        \n    }\n    public int[] sortArray(int[] nums) {\n        quickSort(nums,0,nums.length-1);\n        return nums;\n    }\n}\nWhy this code is passing 14/18 test cases can anyone explain?"
                    },
                    {
                        "username": "Udit_69",
                        "content": "[@manishdude1998](/manishdude1998)  No bro its giving wrong answer\nI have done this \nclass Solution {\npublic static void quickSort(int arr[],int si,int ei){\nif(si>=ei)\nreturn;\nint mid = (si + ei)/2;\nint temp = arr[ei];\narr[si] = arr[mid];\narr[mid] = temp;\nint p_ind = ei;\nint pivot = arr[p_ind];\nint j=si;\nint i=si-1;\nwhile(j<ei){\nif(arr[j]<=pivot){\ni++;\ntemp = arr[j];\narr[j]=arr[i];\narr[i]=temp;\n}\nj++;\n}\ni++;\ntemp = pivot;\narr[ei]=arr[i];\narr[i]=temp;\nquickSort(arr,si,i-1);\nquickSort(arr,i+1,ei);\n\n}\npublic int[] sortArray(int[] nums) {\n    if (nums == null || nums.length == 0){\n            return nums;\n        }\n    quickSort(nums,0,nums.length-1);\n    return nums;\n}\n}\nBut dude quicksort in worst case will give n square complexity, so I try with merge sort  which has best and worst complexity as nlogn so below is my code, it works and accepted as well check this\n\n// code for same by merge sort\nclass Solution {\n    \tpublic static void merge(int arr[],int si,int ei){\n        int mid = si+(ei-si)/2;\n        int i=si,j=mid+1,k=si;\n        int temp[]=new int[ei+1];\n        while(i<=mid&&j<=ei){\n            if(arr[i]<arr[j])\n                temp[k++]=arr[i++];\n            else if(arr[i]>arr[j])\n                temp[k++]=arr[j++];\n            else\n               temp[k++] = arr[i++];\n        }\n        for(;i<=mid;i++){\n            temp[k]=arr[i];\n            k++;\n        }\n        for(;j<=ei;j++){\n            temp[k]=arr[j];\n            k++;\n        }\n        for(int l=si;l<=ei;l++) {\n        \tarr[l]=temp[l];\n        }\n        \n    }\n    public static void mergeSort(int arr[],int start,int end){\n        int si=start;\n        int ei=end;\n        int mid = si+(ei-si)/2;\n     if(si>=ei){\n         return;\n     }\n     mergeSort(arr,si,mid); \n     mergeSort(arr,mid+1,ei);\n     merge(arr,si,ei);\n    }\n\n    public int[] sortArray(int[] nums) {\n        if (nums == null || nums.length == 0){\n            return nums;\n        }\n        mergeSort(nums,0,nums.length-1);\n        return nums;\n    }\n} "
                    },
                    {
                        "username": "manishdude1998",
                        "content": "let\\'s say we have\\n\\nnums = [ 1,2,3,4,5,6,7,8,9,10,11,12,14,13] \\n\\nIn this case, if we use the last element as a pivot we are making about 12 calls to quickSort();\\n\\nhowever, if you change the way you are partitioning the array the number of calls can be decreased\\n\\nlike swapping the middle element with the last element first and then partitioning the array\\nthis will make less than 12 calls\\n\\njust add this to your code after the base condition in quickSort function,\\n\\n```java\\nint mid = (si + ei)/2;\\nint tmp = arr[ei];\\narr[si] = arr[mid];\\narr[mid] = tmp;\\n```\\n\\nalso add this at the top in the given sortArray function\\n\\n```java\\nif (nums == null || nums.length == 0){\\n            return nums;\\n        }\\n```\\n\\nThis should clear all the test cases."
                    }
                ]
            },
            {
                "id": 1758036,
                "content": [
                    {
                        "username": "pratyaksh_jindal",
                        "content": "This is a simple merge sort question.\\nIf anyone faces any difficulty I strongly recommend video from Love Babbar on youtube."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "merge sort is better for LinkedLists than arrays. Try using CountSort. "
                    },
                    {
                        "username": "riya00singh99",
                        "content": "what is problem in this code??\n\nclass Solution {\npublic:\n    void conquere(vector<int> &nums,int l,int e){\n        if(l>=e){\n            return;\n        }\n        int mid=(e-l)/2+l;\n        int i=l;\n        int j=mid+1;\n        int k=l;\n        int size=e-l+1;\n        vector<int> arr(size,0);\n        while(i<=mid && j<=e){\n            if(nums[i]<nums[j]){\n                arr[k++]=nums[i++];\n            }\n            else if(nums[i]>nums[j]){\n                arr[k++]=nums[j++];\n            }\n            else{\n                arr[k++]=nums[i++];\n            }\n        }\n         while(i<=mid){\n        arr[k++]=nums[i++];\n        }\n            \n\n        while(j<=e){\n         arr[k++]=nums[j++];\n        }\n        for(int i=l;i<=e;i++){\n            nums[i]=arr[i];\n        }\n\n    }\n    void divide(vector<int> &nums,int l,int e){\n        if(l<e){ \n            int mid=l+(e-l)/2;\n            divide(nums,l,mid);\n            divide(nums,mid+1,e);\n            conquere(nums,l,e);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        if (nums.size() == 1||nums.size()==0){\n            return nums;\n        }\n\n        divide(nums,0,nums.size()-1);\n        return nums;\n    }\n};"
                    },
                    {
                        "username": "guobao2",
                        "content": "Here is a parallel implementation with Java Fork & Join framework https://leetcode.com/problems/sort-an-array/solutions/3051840/parallel-implantation (faster than 57.6%). I thought it would be faster than all other approaches. However, it's slower than an iterative implementation I submitted https://leetcode.com/problems/sort-an-array/solutions/3052184/iterative-implementation (faster than 91.6%). If you know why please let me know."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "isn\\'t this problem set Asking for merge Sort to be applied on it?"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "There\\'s a lot of O(nlogn) sorting algorithms, merge sort is just the most well known"
                    },
                    {
                        "username": "vishalRai26",
                        "content": "yes"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried using sorted(nums) in python just to see what happened if I tried to use a built in function and it went through just fine."
                    },
                    {
                        "username": "zafirhossain69",
                        "content": "and its even faster xD"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "I am getting the following answer (I am using quick sort combined with bubble sort): \n\nTime Limit Exceeded\n18 / 18 testcases passed\n\nLast Executed Input\nnums =\n\nCould this be a bug?"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "[@Ashutosh_Bhai](/Ashutosh_Bhai) Quick sort is too slow in some cases. I managed to get an accepted time with merge sort. My question was about the contradiction that initially all testcases passed, but TLE."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "U have used Bubble sort that\\'s why you faced TLE. I suggest, using either Heap sort or Quick sort will satisfy all given constraints."
                    },
                    {
                        "username": "akki407",
                        "content": "Can we solve this question using recursion ??"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": " Solve this question by using Heap sort or quick sort algorithm ...It will satisfy all given condition"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "recursion works yes in O(nlogn) afaik"
                    },
                    {
                        "username": "simrann20",
                        "content": "Yes I tried with recursion, however time complexity would be greater than O(nlogn) and only 9/18 test cases pass and give TLE."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": " Easy C++ Solution\\n`vector<int> sortArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Read the question Carefully. **without using any built-in functions** written."
                    },
                    {
                        "username": "jjq_piano",
                        "content": "C quick sort memory beats 79%\\n\\n```\\n\\nint* sortArray(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    srand((unsigned)time(NULL));\\n    for (int i=0; i< numsSize; i++) {\\n        int j = rand() % numsSize;\\n        swap(nums, nums+j, nums+i);\\n    }\\n    q_sort(nums, 0, numsSize - 1);\\n    return nums;\\n}\\n\\n\\n\\nvoid q_sort(int* q, int l, int r) {\\n    if (l >= r) return;\\n    int mid = q[l], i = l+1, j = r;\\n    while (i<j) {\\n        while (q[i] < mid && i<j) {\\n            i++;\\n        }\\n        while (q[j] >mid && j > i) {\\n            j--;\\n        }\\n        if (i<j) {\\n            swap(q+i, q+j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    if (q[i] < mid) {\\n        swap(q+l, q+i);\\n        q_sort(q, l, i-1);\\n        q_sort(q,i+1,r);\\n    } else {\\n        swap(q+l, q+i-1);\\n        q_sort(q, l, i-2);\\n        q_sort(q,i,r);\\n    }\\n\\n}\\n\\nvoid swap(int* i , int* j) {\\n    int tmp = *i;\\n    *i = *j;\\n    *j = tmp;\\n}\\n\\n```"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\n     public static void quickSort(int arr[],int si,int ei){\n        if(si>=ei)\n            return;\n        int p_ind = ei;\n        int pivot = arr[p_ind];\n        int j=si;\n        int i=si-1,temp=0;\n        while(j<ei){\n            if(arr[j]<=pivot){\n                i++;\n                temp = arr[j];\n                arr[j]=arr[i];\n                arr[i]=temp;\n            }\n            j++;\n        }\n        i++;\n        temp = pivot;\n        arr[ei]=arr[i];\n        arr[i]=temp;\n        quickSort(arr,si,i-1);\n        quickSort(arr,i+1,ei);\n        \n    }\n    public int[] sortArray(int[] nums) {\n        quickSort(nums,0,nums.length-1);\n        return nums;\n    }\n}\nWhy this code is passing 14/18 test cases can anyone explain?"
                    },
                    {
                        "username": "Udit_69",
                        "content": "[@manishdude1998](/manishdude1998)  No bro its giving wrong answer\nI have done this \nclass Solution {\npublic static void quickSort(int arr[],int si,int ei){\nif(si>=ei)\nreturn;\nint mid = (si + ei)/2;\nint temp = arr[ei];\narr[si] = arr[mid];\narr[mid] = temp;\nint p_ind = ei;\nint pivot = arr[p_ind];\nint j=si;\nint i=si-1;\nwhile(j<ei){\nif(arr[j]<=pivot){\ni++;\ntemp = arr[j];\narr[j]=arr[i];\narr[i]=temp;\n}\nj++;\n}\ni++;\ntemp = pivot;\narr[ei]=arr[i];\narr[i]=temp;\nquickSort(arr,si,i-1);\nquickSort(arr,i+1,ei);\n\n}\npublic int[] sortArray(int[] nums) {\n    if (nums == null || nums.length == 0){\n            return nums;\n        }\n    quickSort(nums,0,nums.length-1);\n    return nums;\n}\n}\nBut dude quicksort in worst case will give n square complexity, so I try with merge sort  which has best and worst complexity as nlogn so below is my code, it works and accepted as well check this\n\n// code for same by merge sort\nclass Solution {\n    \tpublic static void merge(int arr[],int si,int ei){\n        int mid = si+(ei-si)/2;\n        int i=si,j=mid+1,k=si;\n        int temp[]=new int[ei+1];\n        while(i<=mid&&j<=ei){\n            if(arr[i]<arr[j])\n                temp[k++]=arr[i++];\n            else if(arr[i]>arr[j])\n                temp[k++]=arr[j++];\n            else\n               temp[k++] = arr[i++];\n        }\n        for(;i<=mid;i++){\n            temp[k]=arr[i];\n            k++;\n        }\n        for(;j<=ei;j++){\n            temp[k]=arr[j];\n            k++;\n        }\n        for(int l=si;l<=ei;l++) {\n        \tarr[l]=temp[l];\n        }\n        \n    }\n    public static void mergeSort(int arr[],int start,int end){\n        int si=start;\n        int ei=end;\n        int mid = si+(ei-si)/2;\n     if(si>=ei){\n         return;\n     }\n     mergeSort(arr,si,mid); \n     mergeSort(arr,mid+1,ei);\n     merge(arr,si,ei);\n    }\n\n    public int[] sortArray(int[] nums) {\n        if (nums == null || nums.length == 0){\n            return nums;\n        }\n        mergeSort(nums,0,nums.length-1);\n        return nums;\n    }\n} "
                    },
                    {
                        "username": "manishdude1998",
                        "content": "let\\'s say we have\\n\\nnums = [ 1,2,3,4,5,6,7,8,9,10,11,12,14,13] \\n\\nIn this case, if we use the last element as a pivot we are making about 12 calls to quickSort();\\n\\nhowever, if you change the way you are partitioning the array the number of calls can be decreased\\n\\nlike swapping the middle element with the last element first and then partitioning the array\\nthis will make less than 12 calls\\n\\njust add this to your code after the base condition in quickSort function,\\n\\n```java\\nint mid = (si + ei)/2;\\nint tmp = arr[ei];\\narr[si] = arr[mid];\\narr[mid] = tmp;\\n```\\n\\nalso add this at the top in the given sortArray function\\n\\n```java\\nif (nums == null || nums.length == 0){\\n            return nums;\\n        }\\n```\\n\\nThis should clear all the test cases."
                    }
                ]
            },
            {
                "id": 1750758,
                "content": [
                    {
                        "username": "pratyaksh_jindal",
                        "content": "This is a simple merge sort question.\\nIf anyone faces any difficulty I strongly recommend video from Love Babbar on youtube."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "merge sort is better for LinkedLists than arrays. Try using CountSort. "
                    },
                    {
                        "username": "riya00singh99",
                        "content": "what is problem in this code??\n\nclass Solution {\npublic:\n    void conquere(vector<int> &nums,int l,int e){\n        if(l>=e){\n            return;\n        }\n        int mid=(e-l)/2+l;\n        int i=l;\n        int j=mid+1;\n        int k=l;\n        int size=e-l+1;\n        vector<int> arr(size,0);\n        while(i<=mid && j<=e){\n            if(nums[i]<nums[j]){\n                arr[k++]=nums[i++];\n            }\n            else if(nums[i]>nums[j]){\n                arr[k++]=nums[j++];\n            }\n            else{\n                arr[k++]=nums[i++];\n            }\n        }\n         while(i<=mid){\n        arr[k++]=nums[i++];\n        }\n            \n\n        while(j<=e){\n         arr[k++]=nums[j++];\n        }\n        for(int i=l;i<=e;i++){\n            nums[i]=arr[i];\n        }\n\n    }\n    void divide(vector<int> &nums,int l,int e){\n        if(l<e){ \n            int mid=l+(e-l)/2;\n            divide(nums,l,mid);\n            divide(nums,mid+1,e);\n            conquere(nums,l,e);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        if (nums.size() == 1||nums.size()==0){\n            return nums;\n        }\n\n        divide(nums,0,nums.size()-1);\n        return nums;\n    }\n};"
                    },
                    {
                        "username": "guobao2",
                        "content": "Here is a parallel implementation with Java Fork & Join framework https://leetcode.com/problems/sort-an-array/solutions/3051840/parallel-implantation (faster than 57.6%). I thought it would be faster than all other approaches. However, it's slower than an iterative implementation I submitted https://leetcode.com/problems/sort-an-array/solutions/3052184/iterative-implementation (faster than 91.6%). If you know why please let me know."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "isn\\'t this problem set Asking for merge Sort to be applied on it?"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "There\\'s a lot of O(nlogn) sorting algorithms, merge sort is just the most well known"
                    },
                    {
                        "username": "vishalRai26",
                        "content": "yes"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried using sorted(nums) in python just to see what happened if I tried to use a built in function and it went through just fine."
                    },
                    {
                        "username": "zafirhossain69",
                        "content": "and its even faster xD"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "I am getting the following answer (I am using quick sort combined with bubble sort): \n\nTime Limit Exceeded\n18 / 18 testcases passed\n\nLast Executed Input\nnums =\n\nCould this be a bug?"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "[@Ashutosh_Bhai](/Ashutosh_Bhai) Quick sort is too slow in some cases. I managed to get an accepted time with merge sort. My question was about the contradiction that initially all testcases passed, but TLE."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "U have used Bubble sort that\\'s why you faced TLE. I suggest, using either Heap sort or Quick sort will satisfy all given constraints."
                    },
                    {
                        "username": "akki407",
                        "content": "Can we solve this question using recursion ??"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": " Solve this question by using Heap sort or quick sort algorithm ...It will satisfy all given condition"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "recursion works yes in O(nlogn) afaik"
                    },
                    {
                        "username": "simrann20",
                        "content": "Yes I tried with recursion, however time complexity would be greater than O(nlogn) and only 9/18 test cases pass and give TLE."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": " Easy C++ Solution\\n`vector<int> sortArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Read the question Carefully. **without using any built-in functions** written."
                    },
                    {
                        "username": "jjq_piano",
                        "content": "C quick sort memory beats 79%\\n\\n```\\n\\nint* sortArray(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    srand((unsigned)time(NULL));\\n    for (int i=0; i< numsSize; i++) {\\n        int j = rand() % numsSize;\\n        swap(nums, nums+j, nums+i);\\n    }\\n    q_sort(nums, 0, numsSize - 1);\\n    return nums;\\n}\\n\\n\\n\\nvoid q_sort(int* q, int l, int r) {\\n    if (l >= r) return;\\n    int mid = q[l], i = l+1, j = r;\\n    while (i<j) {\\n        while (q[i] < mid && i<j) {\\n            i++;\\n        }\\n        while (q[j] >mid && j > i) {\\n            j--;\\n        }\\n        if (i<j) {\\n            swap(q+i, q+j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    if (q[i] < mid) {\\n        swap(q+l, q+i);\\n        q_sort(q, l, i-1);\\n        q_sort(q,i+1,r);\\n    } else {\\n        swap(q+l, q+i-1);\\n        q_sort(q, l, i-2);\\n        q_sort(q,i,r);\\n    }\\n\\n}\\n\\nvoid swap(int* i , int* j) {\\n    int tmp = *i;\\n    *i = *j;\\n    *j = tmp;\\n}\\n\\n```"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\n     public static void quickSort(int arr[],int si,int ei){\n        if(si>=ei)\n            return;\n        int p_ind = ei;\n        int pivot = arr[p_ind];\n        int j=si;\n        int i=si-1,temp=0;\n        while(j<ei){\n            if(arr[j]<=pivot){\n                i++;\n                temp = arr[j];\n                arr[j]=arr[i];\n                arr[i]=temp;\n            }\n            j++;\n        }\n        i++;\n        temp = pivot;\n        arr[ei]=arr[i];\n        arr[i]=temp;\n        quickSort(arr,si,i-1);\n        quickSort(arr,i+1,ei);\n        \n    }\n    public int[] sortArray(int[] nums) {\n        quickSort(nums,0,nums.length-1);\n        return nums;\n    }\n}\nWhy this code is passing 14/18 test cases can anyone explain?"
                    },
                    {
                        "username": "Udit_69",
                        "content": "[@manishdude1998](/manishdude1998)  No bro its giving wrong answer\nI have done this \nclass Solution {\npublic static void quickSort(int arr[],int si,int ei){\nif(si>=ei)\nreturn;\nint mid = (si + ei)/2;\nint temp = arr[ei];\narr[si] = arr[mid];\narr[mid] = temp;\nint p_ind = ei;\nint pivot = arr[p_ind];\nint j=si;\nint i=si-1;\nwhile(j<ei){\nif(arr[j]<=pivot){\ni++;\ntemp = arr[j];\narr[j]=arr[i];\narr[i]=temp;\n}\nj++;\n}\ni++;\ntemp = pivot;\narr[ei]=arr[i];\narr[i]=temp;\nquickSort(arr,si,i-1);\nquickSort(arr,i+1,ei);\n\n}\npublic int[] sortArray(int[] nums) {\n    if (nums == null || nums.length == 0){\n            return nums;\n        }\n    quickSort(nums,0,nums.length-1);\n    return nums;\n}\n}\nBut dude quicksort in worst case will give n square complexity, so I try with merge sort  which has best and worst complexity as nlogn so below is my code, it works and accepted as well check this\n\n// code for same by merge sort\nclass Solution {\n    \tpublic static void merge(int arr[],int si,int ei){\n        int mid = si+(ei-si)/2;\n        int i=si,j=mid+1,k=si;\n        int temp[]=new int[ei+1];\n        while(i<=mid&&j<=ei){\n            if(arr[i]<arr[j])\n                temp[k++]=arr[i++];\n            else if(arr[i]>arr[j])\n                temp[k++]=arr[j++];\n            else\n               temp[k++] = arr[i++];\n        }\n        for(;i<=mid;i++){\n            temp[k]=arr[i];\n            k++;\n        }\n        for(;j<=ei;j++){\n            temp[k]=arr[j];\n            k++;\n        }\n        for(int l=si;l<=ei;l++) {\n        \tarr[l]=temp[l];\n        }\n        \n    }\n    public static void mergeSort(int arr[],int start,int end){\n        int si=start;\n        int ei=end;\n        int mid = si+(ei-si)/2;\n     if(si>=ei){\n         return;\n     }\n     mergeSort(arr,si,mid); \n     mergeSort(arr,mid+1,ei);\n     merge(arr,si,ei);\n    }\n\n    public int[] sortArray(int[] nums) {\n        if (nums == null || nums.length == 0){\n            return nums;\n        }\n        mergeSort(nums,0,nums.length-1);\n        return nums;\n    }\n} "
                    },
                    {
                        "username": "manishdude1998",
                        "content": "let\\'s say we have\\n\\nnums = [ 1,2,3,4,5,6,7,8,9,10,11,12,14,13] \\n\\nIn this case, if we use the last element as a pivot we are making about 12 calls to quickSort();\\n\\nhowever, if you change the way you are partitioning the array the number of calls can be decreased\\n\\nlike swapping the middle element with the last element first and then partitioning the array\\nthis will make less than 12 calls\\n\\njust add this to your code after the base condition in quickSort function,\\n\\n```java\\nint mid = (si + ei)/2;\\nint tmp = arr[ei];\\narr[si] = arr[mid];\\narr[mid] = tmp;\\n```\\n\\nalso add this at the top in the given sortArray function\\n\\n```java\\nif (nums == null || nums.length == 0){\\n            return nums;\\n        }\\n```\\n\\nThis should clear all the test cases."
                    }
                ]
            },
            {
                "id": 1750690,
                "content": [
                    {
                        "username": "pratyaksh_jindal",
                        "content": "This is a simple merge sort question.\\nIf anyone faces any difficulty I strongly recommend video from Love Babbar on youtube."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "merge sort is better for LinkedLists than arrays. Try using CountSort. "
                    },
                    {
                        "username": "riya00singh99",
                        "content": "what is problem in this code??\n\nclass Solution {\npublic:\n    void conquere(vector<int> &nums,int l,int e){\n        if(l>=e){\n            return;\n        }\n        int mid=(e-l)/2+l;\n        int i=l;\n        int j=mid+1;\n        int k=l;\n        int size=e-l+1;\n        vector<int> arr(size,0);\n        while(i<=mid && j<=e){\n            if(nums[i]<nums[j]){\n                arr[k++]=nums[i++];\n            }\n            else if(nums[i]>nums[j]){\n                arr[k++]=nums[j++];\n            }\n            else{\n                arr[k++]=nums[i++];\n            }\n        }\n         while(i<=mid){\n        arr[k++]=nums[i++];\n        }\n            \n\n        while(j<=e){\n         arr[k++]=nums[j++];\n        }\n        for(int i=l;i<=e;i++){\n            nums[i]=arr[i];\n        }\n\n    }\n    void divide(vector<int> &nums,int l,int e){\n        if(l<e){ \n            int mid=l+(e-l)/2;\n            divide(nums,l,mid);\n            divide(nums,mid+1,e);\n            conquere(nums,l,e);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        if (nums.size() == 1||nums.size()==0){\n            return nums;\n        }\n\n        divide(nums,0,nums.size()-1);\n        return nums;\n    }\n};"
                    },
                    {
                        "username": "guobao2",
                        "content": "Here is a parallel implementation with Java Fork & Join framework https://leetcode.com/problems/sort-an-array/solutions/3051840/parallel-implantation (faster than 57.6%). I thought it would be faster than all other approaches. However, it's slower than an iterative implementation I submitted https://leetcode.com/problems/sort-an-array/solutions/3052184/iterative-implementation (faster than 91.6%). If you know why please let me know."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "isn\\'t this problem set Asking for merge Sort to be applied on it?"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "There\\'s a lot of O(nlogn) sorting algorithms, merge sort is just the most well known"
                    },
                    {
                        "username": "vishalRai26",
                        "content": "yes"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried using sorted(nums) in python just to see what happened if I tried to use a built in function and it went through just fine."
                    },
                    {
                        "username": "zafirhossain69",
                        "content": "and its even faster xD"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "I am getting the following answer (I am using quick sort combined with bubble sort): \n\nTime Limit Exceeded\n18 / 18 testcases passed\n\nLast Executed Input\nnums =\n\nCould this be a bug?"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "[@Ashutosh_Bhai](/Ashutosh_Bhai) Quick sort is too slow in some cases. I managed to get an accepted time with merge sort. My question was about the contradiction that initially all testcases passed, but TLE."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "U have used Bubble sort that\\'s why you faced TLE. I suggest, using either Heap sort or Quick sort will satisfy all given constraints."
                    },
                    {
                        "username": "akki407",
                        "content": "Can we solve this question using recursion ??"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": " Solve this question by using Heap sort or quick sort algorithm ...It will satisfy all given condition"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "recursion works yes in O(nlogn) afaik"
                    },
                    {
                        "username": "simrann20",
                        "content": "Yes I tried with recursion, however time complexity would be greater than O(nlogn) and only 9/18 test cases pass and give TLE."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": " Easy C++ Solution\\n`vector<int> sortArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Read the question Carefully. **without using any built-in functions** written."
                    },
                    {
                        "username": "jjq_piano",
                        "content": "C quick sort memory beats 79%\\n\\n```\\n\\nint* sortArray(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    srand((unsigned)time(NULL));\\n    for (int i=0; i< numsSize; i++) {\\n        int j = rand() % numsSize;\\n        swap(nums, nums+j, nums+i);\\n    }\\n    q_sort(nums, 0, numsSize - 1);\\n    return nums;\\n}\\n\\n\\n\\nvoid q_sort(int* q, int l, int r) {\\n    if (l >= r) return;\\n    int mid = q[l], i = l+1, j = r;\\n    while (i<j) {\\n        while (q[i] < mid && i<j) {\\n            i++;\\n        }\\n        while (q[j] >mid && j > i) {\\n            j--;\\n        }\\n        if (i<j) {\\n            swap(q+i, q+j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    if (q[i] < mid) {\\n        swap(q+l, q+i);\\n        q_sort(q, l, i-1);\\n        q_sort(q,i+1,r);\\n    } else {\\n        swap(q+l, q+i-1);\\n        q_sort(q, l, i-2);\\n        q_sort(q,i,r);\\n    }\\n\\n}\\n\\nvoid swap(int* i , int* j) {\\n    int tmp = *i;\\n    *i = *j;\\n    *j = tmp;\\n}\\n\\n```"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\n     public static void quickSort(int arr[],int si,int ei){\n        if(si>=ei)\n            return;\n        int p_ind = ei;\n        int pivot = arr[p_ind];\n        int j=si;\n        int i=si-1,temp=0;\n        while(j<ei){\n            if(arr[j]<=pivot){\n                i++;\n                temp = arr[j];\n                arr[j]=arr[i];\n                arr[i]=temp;\n            }\n            j++;\n        }\n        i++;\n        temp = pivot;\n        arr[ei]=arr[i];\n        arr[i]=temp;\n        quickSort(arr,si,i-1);\n        quickSort(arr,i+1,ei);\n        \n    }\n    public int[] sortArray(int[] nums) {\n        quickSort(nums,0,nums.length-1);\n        return nums;\n    }\n}\nWhy this code is passing 14/18 test cases can anyone explain?"
                    },
                    {
                        "username": "Udit_69",
                        "content": "[@manishdude1998](/manishdude1998)  No bro its giving wrong answer\nI have done this \nclass Solution {\npublic static void quickSort(int arr[],int si,int ei){\nif(si>=ei)\nreturn;\nint mid = (si + ei)/2;\nint temp = arr[ei];\narr[si] = arr[mid];\narr[mid] = temp;\nint p_ind = ei;\nint pivot = arr[p_ind];\nint j=si;\nint i=si-1;\nwhile(j<ei){\nif(arr[j]<=pivot){\ni++;\ntemp = arr[j];\narr[j]=arr[i];\narr[i]=temp;\n}\nj++;\n}\ni++;\ntemp = pivot;\narr[ei]=arr[i];\narr[i]=temp;\nquickSort(arr,si,i-1);\nquickSort(arr,i+1,ei);\n\n}\npublic int[] sortArray(int[] nums) {\n    if (nums == null || nums.length == 0){\n            return nums;\n        }\n    quickSort(nums,0,nums.length-1);\n    return nums;\n}\n}\nBut dude quicksort in worst case will give n square complexity, so I try with merge sort  which has best and worst complexity as nlogn so below is my code, it works and accepted as well check this\n\n// code for same by merge sort\nclass Solution {\n    \tpublic static void merge(int arr[],int si,int ei){\n        int mid = si+(ei-si)/2;\n        int i=si,j=mid+1,k=si;\n        int temp[]=new int[ei+1];\n        while(i<=mid&&j<=ei){\n            if(arr[i]<arr[j])\n                temp[k++]=arr[i++];\n            else if(arr[i]>arr[j])\n                temp[k++]=arr[j++];\n            else\n               temp[k++] = arr[i++];\n        }\n        for(;i<=mid;i++){\n            temp[k]=arr[i];\n            k++;\n        }\n        for(;j<=ei;j++){\n            temp[k]=arr[j];\n            k++;\n        }\n        for(int l=si;l<=ei;l++) {\n        \tarr[l]=temp[l];\n        }\n        \n    }\n    public static void mergeSort(int arr[],int start,int end){\n        int si=start;\n        int ei=end;\n        int mid = si+(ei-si)/2;\n     if(si>=ei){\n         return;\n     }\n     mergeSort(arr,si,mid); \n     mergeSort(arr,mid+1,ei);\n     merge(arr,si,ei);\n    }\n\n    public int[] sortArray(int[] nums) {\n        if (nums == null || nums.length == 0){\n            return nums;\n        }\n        mergeSort(nums,0,nums.length-1);\n        return nums;\n    }\n} "
                    },
                    {
                        "username": "manishdude1998",
                        "content": "let\\'s say we have\\n\\nnums = [ 1,2,3,4,5,6,7,8,9,10,11,12,14,13] \\n\\nIn this case, if we use the last element as a pivot we are making about 12 calls to quickSort();\\n\\nhowever, if you change the way you are partitioning the array the number of calls can be decreased\\n\\nlike swapping the middle element with the last element first and then partitioning the array\\nthis will make less than 12 calls\\n\\njust add this to your code after the base condition in quickSort function,\\n\\n```java\\nint mid = (si + ei)/2;\\nint tmp = arr[ei];\\narr[si] = arr[mid];\\narr[mid] = tmp;\\n```\\n\\nalso add this at the top in the given sortArray function\\n\\n```java\\nif (nums == null || nums.length == 0){\\n            return nums;\\n        }\\n```\\n\\nThis should clear all the test cases."
                    }
                ]
            },
            {
                "id": 1740279,
                "content": [
                    {
                        "username": "pratyaksh_jindal",
                        "content": "This is a simple merge sort question.\\nIf anyone faces any difficulty I strongly recommend video from Love Babbar on youtube."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "merge sort is better for LinkedLists than arrays. Try using CountSort. "
                    },
                    {
                        "username": "riya00singh99",
                        "content": "what is problem in this code??\n\nclass Solution {\npublic:\n    void conquere(vector<int> &nums,int l,int e){\n        if(l>=e){\n            return;\n        }\n        int mid=(e-l)/2+l;\n        int i=l;\n        int j=mid+1;\n        int k=l;\n        int size=e-l+1;\n        vector<int> arr(size,0);\n        while(i<=mid && j<=e){\n            if(nums[i]<nums[j]){\n                arr[k++]=nums[i++];\n            }\n            else if(nums[i]>nums[j]){\n                arr[k++]=nums[j++];\n            }\n            else{\n                arr[k++]=nums[i++];\n            }\n        }\n         while(i<=mid){\n        arr[k++]=nums[i++];\n        }\n            \n\n        while(j<=e){\n         arr[k++]=nums[j++];\n        }\n        for(int i=l;i<=e;i++){\n            nums[i]=arr[i];\n        }\n\n    }\n    void divide(vector<int> &nums,int l,int e){\n        if(l<e){ \n            int mid=l+(e-l)/2;\n            divide(nums,l,mid);\n            divide(nums,mid+1,e);\n            conquere(nums,l,e);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        if (nums.size() == 1||nums.size()==0){\n            return nums;\n        }\n\n        divide(nums,0,nums.size()-1);\n        return nums;\n    }\n};"
                    },
                    {
                        "username": "guobao2",
                        "content": "Here is a parallel implementation with Java Fork & Join framework https://leetcode.com/problems/sort-an-array/solutions/3051840/parallel-implantation (faster than 57.6%). I thought it would be faster than all other approaches. However, it's slower than an iterative implementation I submitted https://leetcode.com/problems/sort-an-array/solutions/3052184/iterative-implementation (faster than 91.6%). If you know why please let me know."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "isn\\'t this problem set Asking for merge Sort to be applied on it?"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "There\\'s a lot of O(nlogn) sorting algorithms, merge sort is just the most well known"
                    },
                    {
                        "username": "vishalRai26",
                        "content": "yes"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried using sorted(nums) in python just to see what happened if I tried to use a built in function and it went through just fine."
                    },
                    {
                        "username": "zafirhossain69",
                        "content": "and its even faster xD"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "I am getting the following answer (I am using quick sort combined with bubble sort): \n\nTime Limit Exceeded\n18 / 18 testcases passed\n\nLast Executed Input\nnums =\n\nCould this be a bug?"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "[@Ashutosh_Bhai](/Ashutosh_Bhai) Quick sort is too slow in some cases. I managed to get an accepted time with merge sort. My question was about the contradiction that initially all testcases passed, but TLE."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "U have used Bubble sort that\\'s why you faced TLE. I suggest, using either Heap sort or Quick sort will satisfy all given constraints."
                    },
                    {
                        "username": "akki407",
                        "content": "Can we solve this question using recursion ??"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": " Solve this question by using Heap sort or quick sort algorithm ...It will satisfy all given condition"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "recursion works yes in O(nlogn) afaik"
                    },
                    {
                        "username": "simrann20",
                        "content": "Yes I tried with recursion, however time complexity would be greater than O(nlogn) and only 9/18 test cases pass and give TLE."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": " Easy C++ Solution\\n`vector<int> sortArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Read the question Carefully. **without using any built-in functions** written."
                    },
                    {
                        "username": "jjq_piano",
                        "content": "C quick sort memory beats 79%\\n\\n```\\n\\nint* sortArray(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    srand((unsigned)time(NULL));\\n    for (int i=0; i< numsSize; i++) {\\n        int j = rand() % numsSize;\\n        swap(nums, nums+j, nums+i);\\n    }\\n    q_sort(nums, 0, numsSize - 1);\\n    return nums;\\n}\\n\\n\\n\\nvoid q_sort(int* q, int l, int r) {\\n    if (l >= r) return;\\n    int mid = q[l], i = l+1, j = r;\\n    while (i<j) {\\n        while (q[i] < mid && i<j) {\\n            i++;\\n        }\\n        while (q[j] >mid && j > i) {\\n            j--;\\n        }\\n        if (i<j) {\\n            swap(q+i, q+j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    if (q[i] < mid) {\\n        swap(q+l, q+i);\\n        q_sort(q, l, i-1);\\n        q_sort(q,i+1,r);\\n    } else {\\n        swap(q+l, q+i-1);\\n        q_sort(q, l, i-2);\\n        q_sort(q,i,r);\\n    }\\n\\n}\\n\\nvoid swap(int* i , int* j) {\\n    int tmp = *i;\\n    *i = *j;\\n    *j = tmp;\\n}\\n\\n```"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\n     public static void quickSort(int arr[],int si,int ei){\n        if(si>=ei)\n            return;\n        int p_ind = ei;\n        int pivot = arr[p_ind];\n        int j=si;\n        int i=si-1,temp=0;\n        while(j<ei){\n            if(arr[j]<=pivot){\n                i++;\n                temp = arr[j];\n                arr[j]=arr[i];\n                arr[i]=temp;\n            }\n            j++;\n        }\n        i++;\n        temp = pivot;\n        arr[ei]=arr[i];\n        arr[i]=temp;\n        quickSort(arr,si,i-1);\n        quickSort(arr,i+1,ei);\n        \n    }\n    public int[] sortArray(int[] nums) {\n        quickSort(nums,0,nums.length-1);\n        return nums;\n    }\n}\nWhy this code is passing 14/18 test cases can anyone explain?"
                    },
                    {
                        "username": "Udit_69",
                        "content": "[@manishdude1998](/manishdude1998)  No bro its giving wrong answer\nI have done this \nclass Solution {\npublic static void quickSort(int arr[],int si,int ei){\nif(si>=ei)\nreturn;\nint mid = (si + ei)/2;\nint temp = arr[ei];\narr[si] = arr[mid];\narr[mid] = temp;\nint p_ind = ei;\nint pivot = arr[p_ind];\nint j=si;\nint i=si-1;\nwhile(j<ei){\nif(arr[j]<=pivot){\ni++;\ntemp = arr[j];\narr[j]=arr[i];\narr[i]=temp;\n}\nj++;\n}\ni++;\ntemp = pivot;\narr[ei]=arr[i];\narr[i]=temp;\nquickSort(arr,si,i-1);\nquickSort(arr,i+1,ei);\n\n}\npublic int[] sortArray(int[] nums) {\n    if (nums == null || nums.length == 0){\n            return nums;\n        }\n    quickSort(nums,0,nums.length-1);\n    return nums;\n}\n}\nBut dude quicksort in worst case will give n square complexity, so I try with merge sort  which has best and worst complexity as nlogn so below is my code, it works and accepted as well check this\n\n// code for same by merge sort\nclass Solution {\n    \tpublic static void merge(int arr[],int si,int ei){\n        int mid = si+(ei-si)/2;\n        int i=si,j=mid+1,k=si;\n        int temp[]=new int[ei+1];\n        while(i<=mid&&j<=ei){\n            if(arr[i]<arr[j])\n                temp[k++]=arr[i++];\n            else if(arr[i]>arr[j])\n                temp[k++]=arr[j++];\n            else\n               temp[k++] = arr[i++];\n        }\n        for(;i<=mid;i++){\n            temp[k]=arr[i];\n            k++;\n        }\n        for(;j<=ei;j++){\n            temp[k]=arr[j];\n            k++;\n        }\n        for(int l=si;l<=ei;l++) {\n        \tarr[l]=temp[l];\n        }\n        \n    }\n    public static void mergeSort(int arr[],int start,int end){\n        int si=start;\n        int ei=end;\n        int mid = si+(ei-si)/2;\n     if(si>=ei){\n         return;\n     }\n     mergeSort(arr,si,mid); \n     mergeSort(arr,mid+1,ei);\n     merge(arr,si,ei);\n    }\n\n    public int[] sortArray(int[] nums) {\n        if (nums == null || nums.length == 0){\n            return nums;\n        }\n        mergeSort(nums,0,nums.length-1);\n        return nums;\n    }\n} "
                    },
                    {
                        "username": "manishdude1998",
                        "content": "let\\'s say we have\\n\\nnums = [ 1,2,3,4,5,6,7,8,9,10,11,12,14,13] \\n\\nIn this case, if we use the last element as a pivot we are making about 12 calls to quickSort();\\n\\nhowever, if you change the way you are partitioning the array the number of calls can be decreased\\n\\nlike swapping the middle element with the last element first and then partitioning the array\\nthis will make less than 12 calls\\n\\njust add this to your code after the base condition in quickSort function,\\n\\n```java\\nint mid = (si + ei)/2;\\nint tmp = arr[ei];\\narr[si] = arr[mid];\\narr[mid] = tmp;\\n```\\n\\nalso add this at the top in the given sortArray function\\n\\n```java\\nif (nums == null || nums.length == 0){\\n            return nums;\\n        }\\n```\\n\\nThis should clear all the test cases."
                    }
                ]
            },
            {
                "id": 1713992,
                "content": [
                    {
                        "username": "pratyaksh_jindal",
                        "content": "This is a simple merge sort question.\\nIf anyone faces any difficulty I strongly recommend video from Love Babbar on youtube."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "merge sort is better for LinkedLists than arrays. Try using CountSort. "
                    },
                    {
                        "username": "riya00singh99",
                        "content": "what is problem in this code??\n\nclass Solution {\npublic:\n    void conquere(vector<int> &nums,int l,int e){\n        if(l>=e){\n            return;\n        }\n        int mid=(e-l)/2+l;\n        int i=l;\n        int j=mid+1;\n        int k=l;\n        int size=e-l+1;\n        vector<int> arr(size,0);\n        while(i<=mid && j<=e){\n            if(nums[i]<nums[j]){\n                arr[k++]=nums[i++];\n            }\n            else if(nums[i]>nums[j]){\n                arr[k++]=nums[j++];\n            }\n            else{\n                arr[k++]=nums[i++];\n            }\n        }\n         while(i<=mid){\n        arr[k++]=nums[i++];\n        }\n            \n\n        while(j<=e){\n         arr[k++]=nums[j++];\n        }\n        for(int i=l;i<=e;i++){\n            nums[i]=arr[i];\n        }\n\n    }\n    void divide(vector<int> &nums,int l,int e){\n        if(l<e){ \n            int mid=l+(e-l)/2;\n            divide(nums,l,mid);\n            divide(nums,mid+1,e);\n            conquere(nums,l,e);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        if (nums.size() == 1||nums.size()==0){\n            return nums;\n        }\n\n        divide(nums,0,nums.size()-1);\n        return nums;\n    }\n};"
                    },
                    {
                        "username": "guobao2",
                        "content": "Here is a parallel implementation with Java Fork & Join framework https://leetcode.com/problems/sort-an-array/solutions/3051840/parallel-implantation (faster than 57.6%). I thought it would be faster than all other approaches. However, it's slower than an iterative implementation I submitted https://leetcode.com/problems/sort-an-array/solutions/3052184/iterative-implementation (faster than 91.6%). If you know why please let me know."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "isn\\'t this problem set Asking for merge Sort to be applied on it?"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "There\\'s a lot of O(nlogn) sorting algorithms, merge sort is just the most well known"
                    },
                    {
                        "username": "vishalRai26",
                        "content": "yes"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried using sorted(nums) in python just to see what happened if I tried to use a built in function and it went through just fine."
                    },
                    {
                        "username": "zafirhossain69",
                        "content": "and its even faster xD"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "I am getting the following answer (I am using quick sort combined with bubble sort): \n\nTime Limit Exceeded\n18 / 18 testcases passed\n\nLast Executed Input\nnums =\n\nCould this be a bug?"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "[@Ashutosh_Bhai](/Ashutosh_Bhai) Quick sort is too slow in some cases. I managed to get an accepted time with merge sort. My question was about the contradiction that initially all testcases passed, but TLE."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "U have used Bubble sort that\\'s why you faced TLE. I suggest, using either Heap sort or Quick sort will satisfy all given constraints."
                    },
                    {
                        "username": "akki407",
                        "content": "Can we solve this question using recursion ??"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": " Solve this question by using Heap sort or quick sort algorithm ...It will satisfy all given condition"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "recursion works yes in O(nlogn) afaik"
                    },
                    {
                        "username": "simrann20",
                        "content": "Yes I tried with recursion, however time complexity would be greater than O(nlogn) and only 9/18 test cases pass and give TLE."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": " Easy C++ Solution\\n`vector<int> sortArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Read the question Carefully. **without using any built-in functions** written."
                    },
                    {
                        "username": "jjq_piano",
                        "content": "C quick sort memory beats 79%\\n\\n```\\n\\nint* sortArray(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    srand((unsigned)time(NULL));\\n    for (int i=0; i< numsSize; i++) {\\n        int j = rand() % numsSize;\\n        swap(nums, nums+j, nums+i);\\n    }\\n    q_sort(nums, 0, numsSize - 1);\\n    return nums;\\n}\\n\\n\\n\\nvoid q_sort(int* q, int l, int r) {\\n    if (l >= r) return;\\n    int mid = q[l], i = l+1, j = r;\\n    while (i<j) {\\n        while (q[i] < mid && i<j) {\\n            i++;\\n        }\\n        while (q[j] >mid && j > i) {\\n            j--;\\n        }\\n        if (i<j) {\\n            swap(q+i, q+j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    if (q[i] < mid) {\\n        swap(q+l, q+i);\\n        q_sort(q, l, i-1);\\n        q_sort(q,i+1,r);\\n    } else {\\n        swap(q+l, q+i-1);\\n        q_sort(q, l, i-2);\\n        q_sort(q,i,r);\\n    }\\n\\n}\\n\\nvoid swap(int* i , int* j) {\\n    int tmp = *i;\\n    *i = *j;\\n    *j = tmp;\\n}\\n\\n```"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\n     public static void quickSort(int arr[],int si,int ei){\n        if(si>=ei)\n            return;\n        int p_ind = ei;\n        int pivot = arr[p_ind];\n        int j=si;\n        int i=si-1,temp=0;\n        while(j<ei){\n            if(arr[j]<=pivot){\n                i++;\n                temp = arr[j];\n                arr[j]=arr[i];\n                arr[i]=temp;\n            }\n            j++;\n        }\n        i++;\n        temp = pivot;\n        arr[ei]=arr[i];\n        arr[i]=temp;\n        quickSort(arr,si,i-1);\n        quickSort(arr,i+1,ei);\n        \n    }\n    public int[] sortArray(int[] nums) {\n        quickSort(nums,0,nums.length-1);\n        return nums;\n    }\n}\nWhy this code is passing 14/18 test cases can anyone explain?"
                    },
                    {
                        "username": "Udit_69",
                        "content": "[@manishdude1998](/manishdude1998)  No bro its giving wrong answer\nI have done this \nclass Solution {\npublic static void quickSort(int arr[],int si,int ei){\nif(si>=ei)\nreturn;\nint mid = (si + ei)/2;\nint temp = arr[ei];\narr[si] = arr[mid];\narr[mid] = temp;\nint p_ind = ei;\nint pivot = arr[p_ind];\nint j=si;\nint i=si-1;\nwhile(j<ei){\nif(arr[j]<=pivot){\ni++;\ntemp = arr[j];\narr[j]=arr[i];\narr[i]=temp;\n}\nj++;\n}\ni++;\ntemp = pivot;\narr[ei]=arr[i];\narr[i]=temp;\nquickSort(arr,si,i-1);\nquickSort(arr,i+1,ei);\n\n}\npublic int[] sortArray(int[] nums) {\n    if (nums == null || nums.length == 0){\n            return nums;\n        }\n    quickSort(nums,0,nums.length-1);\n    return nums;\n}\n}\nBut dude quicksort in worst case will give n square complexity, so I try with merge sort  which has best and worst complexity as nlogn so below is my code, it works and accepted as well check this\n\n// code for same by merge sort\nclass Solution {\n    \tpublic static void merge(int arr[],int si,int ei){\n        int mid = si+(ei-si)/2;\n        int i=si,j=mid+1,k=si;\n        int temp[]=new int[ei+1];\n        while(i<=mid&&j<=ei){\n            if(arr[i]<arr[j])\n                temp[k++]=arr[i++];\n            else if(arr[i]>arr[j])\n                temp[k++]=arr[j++];\n            else\n               temp[k++] = arr[i++];\n        }\n        for(;i<=mid;i++){\n            temp[k]=arr[i];\n            k++;\n        }\n        for(;j<=ei;j++){\n            temp[k]=arr[j];\n            k++;\n        }\n        for(int l=si;l<=ei;l++) {\n        \tarr[l]=temp[l];\n        }\n        \n    }\n    public static void mergeSort(int arr[],int start,int end){\n        int si=start;\n        int ei=end;\n        int mid = si+(ei-si)/2;\n     if(si>=ei){\n         return;\n     }\n     mergeSort(arr,si,mid); \n     mergeSort(arr,mid+1,ei);\n     merge(arr,si,ei);\n    }\n\n    public int[] sortArray(int[] nums) {\n        if (nums == null || nums.length == 0){\n            return nums;\n        }\n        mergeSort(nums,0,nums.length-1);\n        return nums;\n    }\n} "
                    },
                    {
                        "username": "manishdude1998",
                        "content": "let\\'s say we have\\n\\nnums = [ 1,2,3,4,5,6,7,8,9,10,11,12,14,13] \\n\\nIn this case, if we use the last element as a pivot we are making about 12 calls to quickSort();\\n\\nhowever, if you change the way you are partitioning the array the number of calls can be decreased\\n\\nlike swapping the middle element with the last element first and then partitioning the array\\nthis will make less than 12 calls\\n\\njust add this to your code after the base condition in quickSort function,\\n\\n```java\\nint mid = (si + ei)/2;\\nint tmp = arr[ei];\\narr[si] = arr[mid];\\narr[mid] = tmp;\\n```\\n\\nalso add this at the top in the given sortArray function\\n\\n```java\\nif (nums == null || nums.length == 0){\\n            return nums;\\n        }\\n```\\n\\nThis should clear all the test cases."
                    }
                ]
            },
            {
                "id": 1694162,
                "content": [
                    {
                        "username": "pratyaksh_jindal",
                        "content": "This is a simple merge sort question.\\nIf anyone faces any difficulty I strongly recommend video from Love Babbar on youtube."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "merge sort is better for LinkedLists than arrays. Try using CountSort. "
                    },
                    {
                        "username": "riya00singh99",
                        "content": "what is problem in this code??\n\nclass Solution {\npublic:\n    void conquere(vector<int> &nums,int l,int e){\n        if(l>=e){\n            return;\n        }\n        int mid=(e-l)/2+l;\n        int i=l;\n        int j=mid+1;\n        int k=l;\n        int size=e-l+1;\n        vector<int> arr(size,0);\n        while(i<=mid && j<=e){\n            if(nums[i]<nums[j]){\n                arr[k++]=nums[i++];\n            }\n            else if(nums[i]>nums[j]){\n                arr[k++]=nums[j++];\n            }\n            else{\n                arr[k++]=nums[i++];\n            }\n        }\n         while(i<=mid){\n        arr[k++]=nums[i++];\n        }\n            \n\n        while(j<=e){\n         arr[k++]=nums[j++];\n        }\n        for(int i=l;i<=e;i++){\n            nums[i]=arr[i];\n        }\n\n    }\n    void divide(vector<int> &nums,int l,int e){\n        if(l<e){ \n            int mid=l+(e-l)/2;\n            divide(nums,l,mid);\n            divide(nums,mid+1,e);\n            conquere(nums,l,e);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        if (nums.size() == 1||nums.size()==0){\n            return nums;\n        }\n\n        divide(nums,0,nums.size()-1);\n        return nums;\n    }\n};"
                    },
                    {
                        "username": "guobao2",
                        "content": "Here is a parallel implementation with Java Fork & Join framework https://leetcode.com/problems/sort-an-array/solutions/3051840/parallel-implantation (faster than 57.6%). I thought it would be faster than all other approaches. However, it's slower than an iterative implementation I submitted https://leetcode.com/problems/sort-an-array/solutions/3052184/iterative-implementation (faster than 91.6%). If you know why please let me know."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "isn\\'t this problem set Asking for merge Sort to be applied on it?"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "There\\'s a lot of O(nlogn) sorting algorithms, merge sort is just the most well known"
                    },
                    {
                        "username": "vishalRai26",
                        "content": "yes"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried using sorted(nums) in python just to see what happened if I tried to use a built in function and it went through just fine."
                    },
                    {
                        "username": "zafirhossain69",
                        "content": "and its even faster xD"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "I am getting the following answer (I am using quick sort combined with bubble sort): \n\nTime Limit Exceeded\n18 / 18 testcases passed\n\nLast Executed Input\nnums =\n\nCould this be a bug?"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "[@Ashutosh_Bhai](/Ashutosh_Bhai) Quick sort is too slow in some cases. I managed to get an accepted time with merge sort. My question was about the contradiction that initially all testcases passed, but TLE."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "U have used Bubble sort that\\'s why you faced TLE. I suggest, using either Heap sort or Quick sort will satisfy all given constraints."
                    },
                    {
                        "username": "akki407",
                        "content": "Can we solve this question using recursion ??"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": " Solve this question by using Heap sort or quick sort algorithm ...It will satisfy all given condition"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "recursion works yes in O(nlogn) afaik"
                    },
                    {
                        "username": "simrann20",
                        "content": "Yes I tried with recursion, however time complexity would be greater than O(nlogn) and only 9/18 test cases pass and give TLE."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": " Easy C++ Solution\\n`vector<int> sortArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Read the question Carefully. **without using any built-in functions** written."
                    },
                    {
                        "username": "jjq_piano",
                        "content": "C quick sort memory beats 79%\\n\\n```\\n\\nint* sortArray(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    srand((unsigned)time(NULL));\\n    for (int i=0; i< numsSize; i++) {\\n        int j = rand() % numsSize;\\n        swap(nums, nums+j, nums+i);\\n    }\\n    q_sort(nums, 0, numsSize - 1);\\n    return nums;\\n}\\n\\n\\n\\nvoid q_sort(int* q, int l, int r) {\\n    if (l >= r) return;\\n    int mid = q[l], i = l+1, j = r;\\n    while (i<j) {\\n        while (q[i] < mid && i<j) {\\n            i++;\\n        }\\n        while (q[j] >mid && j > i) {\\n            j--;\\n        }\\n        if (i<j) {\\n            swap(q+i, q+j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    if (q[i] < mid) {\\n        swap(q+l, q+i);\\n        q_sort(q, l, i-1);\\n        q_sort(q,i+1,r);\\n    } else {\\n        swap(q+l, q+i-1);\\n        q_sort(q, l, i-2);\\n        q_sort(q,i,r);\\n    }\\n\\n}\\n\\nvoid swap(int* i , int* j) {\\n    int tmp = *i;\\n    *i = *j;\\n    *j = tmp;\\n}\\n\\n```"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\n     public static void quickSort(int arr[],int si,int ei){\n        if(si>=ei)\n            return;\n        int p_ind = ei;\n        int pivot = arr[p_ind];\n        int j=si;\n        int i=si-1,temp=0;\n        while(j<ei){\n            if(arr[j]<=pivot){\n                i++;\n                temp = arr[j];\n                arr[j]=arr[i];\n                arr[i]=temp;\n            }\n            j++;\n        }\n        i++;\n        temp = pivot;\n        arr[ei]=arr[i];\n        arr[i]=temp;\n        quickSort(arr,si,i-1);\n        quickSort(arr,i+1,ei);\n        \n    }\n    public int[] sortArray(int[] nums) {\n        quickSort(nums,0,nums.length-1);\n        return nums;\n    }\n}\nWhy this code is passing 14/18 test cases can anyone explain?"
                    },
                    {
                        "username": "Udit_69",
                        "content": "[@manishdude1998](/manishdude1998)  No bro its giving wrong answer\nI have done this \nclass Solution {\npublic static void quickSort(int arr[],int si,int ei){\nif(si>=ei)\nreturn;\nint mid = (si + ei)/2;\nint temp = arr[ei];\narr[si] = arr[mid];\narr[mid] = temp;\nint p_ind = ei;\nint pivot = arr[p_ind];\nint j=si;\nint i=si-1;\nwhile(j<ei){\nif(arr[j]<=pivot){\ni++;\ntemp = arr[j];\narr[j]=arr[i];\narr[i]=temp;\n}\nj++;\n}\ni++;\ntemp = pivot;\narr[ei]=arr[i];\narr[i]=temp;\nquickSort(arr,si,i-1);\nquickSort(arr,i+1,ei);\n\n}\npublic int[] sortArray(int[] nums) {\n    if (nums == null || nums.length == 0){\n            return nums;\n        }\n    quickSort(nums,0,nums.length-1);\n    return nums;\n}\n}\nBut dude quicksort in worst case will give n square complexity, so I try with merge sort  which has best and worst complexity as nlogn so below is my code, it works and accepted as well check this\n\n// code for same by merge sort\nclass Solution {\n    \tpublic static void merge(int arr[],int si,int ei){\n        int mid = si+(ei-si)/2;\n        int i=si,j=mid+1,k=si;\n        int temp[]=new int[ei+1];\n        while(i<=mid&&j<=ei){\n            if(arr[i]<arr[j])\n                temp[k++]=arr[i++];\n            else if(arr[i]>arr[j])\n                temp[k++]=arr[j++];\n            else\n               temp[k++] = arr[i++];\n        }\n        for(;i<=mid;i++){\n            temp[k]=arr[i];\n            k++;\n        }\n        for(;j<=ei;j++){\n            temp[k]=arr[j];\n            k++;\n        }\n        for(int l=si;l<=ei;l++) {\n        \tarr[l]=temp[l];\n        }\n        \n    }\n    public static void mergeSort(int arr[],int start,int end){\n        int si=start;\n        int ei=end;\n        int mid = si+(ei-si)/2;\n     if(si>=ei){\n         return;\n     }\n     mergeSort(arr,si,mid); \n     mergeSort(arr,mid+1,ei);\n     merge(arr,si,ei);\n    }\n\n    public int[] sortArray(int[] nums) {\n        if (nums == null || nums.length == 0){\n            return nums;\n        }\n        mergeSort(nums,0,nums.length-1);\n        return nums;\n    }\n} "
                    },
                    {
                        "username": "manishdude1998",
                        "content": "let\\'s say we have\\n\\nnums = [ 1,2,3,4,5,6,7,8,9,10,11,12,14,13] \\n\\nIn this case, if we use the last element as a pivot we are making about 12 calls to quickSort();\\n\\nhowever, if you change the way you are partitioning the array the number of calls can be decreased\\n\\nlike swapping the middle element with the last element first and then partitioning the array\\nthis will make less than 12 calls\\n\\njust add this to your code after the base condition in quickSort function,\\n\\n```java\\nint mid = (si + ei)/2;\\nint tmp = arr[ei];\\narr[si] = arr[mid];\\narr[mid] = tmp;\\n```\\n\\nalso add this at the top in the given sortArray function\\n\\n```java\\nif (nums == null || nums.length == 0){\\n            return nums;\\n        }\\n```\\n\\nThis should clear all the test cases."
                    }
                ]
            },
            {
                "id": 1690199,
                "content": [
                    {
                        "username": "pratyaksh_jindal",
                        "content": "This is a simple merge sort question.\\nIf anyone faces any difficulty I strongly recommend video from Love Babbar on youtube."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "merge sort is better for LinkedLists than arrays. Try using CountSort. "
                    },
                    {
                        "username": "riya00singh99",
                        "content": "what is problem in this code??\n\nclass Solution {\npublic:\n    void conquere(vector<int> &nums,int l,int e){\n        if(l>=e){\n            return;\n        }\n        int mid=(e-l)/2+l;\n        int i=l;\n        int j=mid+1;\n        int k=l;\n        int size=e-l+1;\n        vector<int> arr(size,0);\n        while(i<=mid && j<=e){\n            if(nums[i]<nums[j]){\n                arr[k++]=nums[i++];\n            }\n            else if(nums[i]>nums[j]){\n                arr[k++]=nums[j++];\n            }\n            else{\n                arr[k++]=nums[i++];\n            }\n        }\n         while(i<=mid){\n        arr[k++]=nums[i++];\n        }\n            \n\n        while(j<=e){\n         arr[k++]=nums[j++];\n        }\n        for(int i=l;i<=e;i++){\n            nums[i]=arr[i];\n        }\n\n    }\n    void divide(vector<int> &nums,int l,int e){\n        if(l<e){ \n            int mid=l+(e-l)/2;\n            divide(nums,l,mid);\n            divide(nums,mid+1,e);\n            conquere(nums,l,e);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        if (nums.size() == 1||nums.size()==0){\n            return nums;\n        }\n\n        divide(nums,0,nums.size()-1);\n        return nums;\n    }\n};"
                    },
                    {
                        "username": "guobao2",
                        "content": "Here is a parallel implementation with Java Fork & Join framework https://leetcode.com/problems/sort-an-array/solutions/3051840/parallel-implantation (faster than 57.6%). I thought it would be faster than all other approaches. However, it's slower than an iterative implementation I submitted https://leetcode.com/problems/sort-an-array/solutions/3052184/iterative-implementation (faster than 91.6%). If you know why please let me know."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "isn\\'t this problem set Asking for merge Sort to be applied on it?"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "There\\'s a lot of O(nlogn) sorting algorithms, merge sort is just the most well known"
                    },
                    {
                        "username": "vishalRai26",
                        "content": "yes"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried using sorted(nums) in python just to see what happened if I tried to use a built in function and it went through just fine."
                    },
                    {
                        "username": "zafirhossain69",
                        "content": "and its even faster xD"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "I am getting the following answer (I am using quick sort combined with bubble sort): \n\nTime Limit Exceeded\n18 / 18 testcases passed\n\nLast Executed Input\nnums =\n\nCould this be a bug?"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "[@Ashutosh_Bhai](/Ashutosh_Bhai) Quick sort is too slow in some cases. I managed to get an accepted time with merge sort. My question was about the contradiction that initially all testcases passed, but TLE."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "U have used Bubble sort that\\'s why you faced TLE. I suggest, using either Heap sort or Quick sort will satisfy all given constraints."
                    },
                    {
                        "username": "akki407",
                        "content": "Can we solve this question using recursion ??"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": " Solve this question by using Heap sort or quick sort algorithm ...It will satisfy all given condition"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "recursion works yes in O(nlogn) afaik"
                    },
                    {
                        "username": "simrann20",
                        "content": "Yes I tried with recursion, however time complexity would be greater than O(nlogn) and only 9/18 test cases pass and give TLE."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": " Easy C++ Solution\\n`vector<int> sortArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Read the question Carefully. **without using any built-in functions** written."
                    },
                    {
                        "username": "jjq_piano",
                        "content": "C quick sort memory beats 79%\\n\\n```\\n\\nint* sortArray(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    srand((unsigned)time(NULL));\\n    for (int i=0; i< numsSize; i++) {\\n        int j = rand() % numsSize;\\n        swap(nums, nums+j, nums+i);\\n    }\\n    q_sort(nums, 0, numsSize - 1);\\n    return nums;\\n}\\n\\n\\n\\nvoid q_sort(int* q, int l, int r) {\\n    if (l >= r) return;\\n    int mid = q[l], i = l+1, j = r;\\n    while (i<j) {\\n        while (q[i] < mid && i<j) {\\n            i++;\\n        }\\n        while (q[j] >mid && j > i) {\\n            j--;\\n        }\\n        if (i<j) {\\n            swap(q+i, q+j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    if (q[i] < mid) {\\n        swap(q+l, q+i);\\n        q_sort(q, l, i-1);\\n        q_sort(q,i+1,r);\\n    } else {\\n        swap(q+l, q+i-1);\\n        q_sort(q, l, i-2);\\n        q_sort(q,i,r);\\n    }\\n\\n}\\n\\nvoid swap(int* i , int* j) {\\n    int tmp = *i;\\n    *i = *j;\\n    *j = tmp;\\n}\\n\\n```"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\n     public static void quickSort(int arr[],int si,int ei){\n        if(si>=ei)\n            return;\n        int p_ind = ei;\n        int pivot = arr[p_ind];\n        int j=si;\n        int i=si-1,temp=0;\n        while(j<ei){\n            if(arr[j]<=pivot){\n                i++;\n                temp = arr[j];\n                arr[j]=arr[i];\n                arr[i]=temp;\n            }\n            j++;\n        }\n        i++;\n        temp = pivot;\n        arr[ei]=arr[i];\n        arr[i]=temp;\n        quickSort(arr,si,i-1);\n        quickSort(arr,i+1,ei);\n        \n    }\n    public int[] sortArray(int[] nums) {\n        quickSort(nums,0,nums.length-1);\n        return nums;\n    }\n}\nWhy this code is passing 14/18 test cases can anyone explain?"
                    },
                    {
                        "username": "Udit_69",
                        "content": "[@manishdude1998](/manishdude1998)  No bro its giving wrong answer\nI have done this \nclass Solution {\npublic static void quickSort(int arr[],int si,int ei){\nif(si>=ei)\nreturn;\nint mid = (si + ei)/2;\nint temp = arr[ei];\narr[si] = arr[mid];\narr[mid] = temp;\nint p_ind = ei;\nint pivot = arr[p_ind];\nint j=si;\nint i=si-1;\nwhile(j<ei){\nif(arr[j]<=pivot){\ni++;\ntemp = arr[j];\narr[j]=arr[i];\narr[i]=temp;\n}\nj++;\n}\ni++;\ntemp = pivot;\narr[ei]=arr[i];\narr[i]=temp;\nquickSort(arr,si,i-1);\nquickSort(arr,i+1,ei);\n\n}\npublic int[] sortArray(int[] nums) {\n    if (nums == null || nums.length == 0){\n            return nums;\n        }\n    quickSort(nums,0,nums.length-1);\n    return nums;\n}\n}\nBut dude quicksort in worst case will give n square complexity, so I try with merge sort  which has best and worst complexity as nlogn so below is my code, it works and accepted as well check this\n\n// code for same by merge sort\nclass Solution {\n    \tpublic static void merge(int arr[],int si,int ei){\n        int mid = si+(ei-si)/2;\n        int i=si,j=mid+1,k=si;\n        int temp[]=new int[ei+1];\n        while(i<=mid&&j<=ei){\n            if(arr[i]<arr[j])\n                temp[k++]=arr[i++];\n            else if(arr[i]>arr[j])\n                temp[k++]=arr[j++];\n            else\n               temp[k++] = arr[i++];\n        }\n        for(;i<=mid;i++){\n            temp[k]=arr[i];\n            k++;\n        }\n        for(;j<=ei;j++){\n            temp[k]=arr[j];\n            k++;\n        }\n        for(int l=si;l<=ei;l++) {\n        \tarr[l]=temp[l];\n        }\n        \n    }\n    public static void mergeSort(int arr[],int start,int end){\n        int si=start;\n        int ei=end;\n        int mid = si+(ei-si)/2;\n     if(si>=ei){\n         return;\n     }\n     mergeSort(arr,si,mid); \n     mergeSort(arr,mid+1,ei);\n     merge(arr,si,ei);\n    }\n\n    public int[] sortArray(int[] nums) {\n        if (nums == null || nums.length == 0){\n            return nums;\n        }\n        mergeSort(nums,0,nums.length-1);\n        return nums;\n    }\n} "
                    },
                    {
                        "username": "manishdude1998",
                        "content": "let\\'s say we have\\n\\nnums = [ 1,2,3,4,5,6,7,8,9,10,11,12,14,13] \\n\\nIn this case, if we use the last element as a pivot we are making about 12 calls to quickSort();\\n\\nhowever, if you change the way you are partitioning the array the number of calls can be decreased\\n\\nlike swapping the middle element with the last element first and then partitioning the array\\nthis will make less than 12 calls\\n\\njust add this to your code after the base condition in quickSort function,\\n\\n```java\\nint mid = (si + ei)/2;\\nint tmp = arr[ei];\\narr[si] = arr[mid];\\narr[mid] = tmp;\\n```\\n\\nalso add this at the top in the given sortArray function\\n\\n```java\\nif (nums == null || nums.length == 0){\\n            return nums;\\n        }\\n```\\n\\nThis should clear all the test cases."
                    }
                ]
            },
            {
                "id": 1684242,
                "content": [
                    {
                        "username": "pratyaksh_jindal",
                        "content": "This is a simple merge sort question.\\nIf anyone faces any difficulty I strongly recommend video from Love Babbar on youtube."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "merge sort is better for LinkedLists than arrays. Try using CountSort. "
                    },
                    {
                        "username": "riya00singh99",
                        "content": "what is problem in this code??\n\nclass Solution {\npublic:\n    void conquere(vector<int> &nums,int l,int e){\n        if(l>=e){\n            return;\n        }\n        int mid=(e-l)/2+l;\n        int i=l;\n        int j=mid+1;\n        int k=l;\n        int size=e-l+1;\n        vector<int> arr(size,0);\n        while(i<=mid && j<=e){\n            if(nums[i]<nums[j]){\n                arr[k++]=nums[i++];\n            }\n            else if(nums[i]>nums[j]){\n                arr[k++]=nums[j++];\n            }\n            else{\n                arr[k++]=nums[i++];\n            }\n        }\n         while(i<=mid){\n        arr[k++]=nums[i++];\n        }\n            \n\n        while(j<=e){\n         arr[k++]=nums[j++];\n        }\n        for(int i=l;i<=e;i++){\n            nums[i]=arr[i];\n        }\n\n    }\n    void divide(vector<int> &nums,int l,int e){\n        if(l<e){ \n            int mid=l+(e-l)/2;\n            divide(nums,l,mid);\n            divide(nums,mid+1,e);\n            conquere(nums,l,e);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        if (nums.size() == 1||nums.size()==0){\n            return nums;\n        }\n\n        divide(nums,0,nums.size()-1);\n        return nums;\n    }\n};"
                    },
                    {
                        "username": "guobao2",
                        "content": "Here is a parallel implementation with Java Fork & Join framework https://leetcode.com/problems/sort-an-array/solutions/3051840/parallel-implantation (faster than 57.6%). I thought it would be faster than all other approaches. However, it's slower than an iterative implementation I submitted https://leetcode.com/problems/sort-an-array/solutions/3052184/iterative-implementation (faster than 91.6%). If you know why please let me know."
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "isn\\'t this problem set Asking for merge Sort to be applied on it?"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "There\\'s a lot of O(nlogn) sorting algorithms, merge sort is just the most well known"
                    },
                    {
                        "username": "vishalRai26",
                        "content": "yes"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried using sorted(nums) in python just to see what happened if I tried to use a built in function and it went through just fine."
                    },
                    {
                        "username": "zafirhossain69",
                        "content": "and its even faster xD"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "I am getting the following answer (I am using quick sort combined with bubble sort): \n\nTime Limit Exceeded\n18 / 18 testcases passed\n\nLast Executed Input\nnums =\n\nCould this be a bug?"
                    },
                    {
                        "username": "constantin_tiberiu",
                        "content": "[@Ashutosh_Bhai](/Ashutosh_Bhai) Quick sort is too slow in some cases. I managed to get an accepted time with merge sort. My question was about the contradiction that initially all testcases passed, but TLE."
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "U have used Bubble sort that\\'s why you faced TLE. I suggest, using either Heap sort or Quick sort will satisfy all given constraints."
                    },
                    {
                        "username": "akki407",
                        "content": "Can we solve this question using recursion ??"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": " Solve this question by using Heap sort or quick sort algorithm ...It will satisfy all given condition"
                    },
                    {
                        "username": "hbwhalewhalewhale",
                        "content": "recursion works yes in O(nlogn) afaik"
                    },
                    {
                        "username": "simrann20",
                        "content": "Yes I tried with recursion, however time complexity would be greater than O(nlogn) and only 9/18 test cases pass and give TLE."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": " Easy C++ Solution\\n`vector<int> sortArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Read the question Carefully. **without using any built-in functions** written."
                    },
                    {
                        "username": "jjq_piano",
                        "content": "C quick sort memory beats 79%\\n\\n```\\n\\nint* sortArray(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    srand((unsigned)time(NULL));\\n    for (int i=0; i< numsSize; i++) {\\n        int j = rand() % numsSize;\\n        swap(nums, nums+j, nums+i);\\n    }\\n    q_sort(nums, 0, numsSize - 1);\\n    return nums;\\n}\\n\\n\\n\\nvoid q_sort(int* q, int l, int r) {\\n    if (l >= r) return;\\n    int mid = q[l], i = l+1, j = r;\\n    while (i<j) {\\n        while (q[i] < mid && i<j) {\\n            i++;\\n        }\\n        while (q[j] >mid && j > i) {\\n            j--;\\n        }\\n        if (i<j) {\\n            swap(q+i, q+j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    if (q[i] < mid) {\\n        swap(q+l, q+i);\\n        q_sort(q, l, i-1);\\n        q_sort(q,i+1,r);\\n    } else {\\n        swap(q+l, q+i-1);\\n        q_sort(q, l, i-2);\\n        q_sort(q,i,r);\\n    }\\n\\n}\\n\\nvoid swap(int* i , int* j) {\\n    int tmp = *i;\\n    *i = *j;\\n    *j = tmp;\\n}\\n\\n```"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\n     public static void quickSort(int arr[],int si,int ei){\n        if(si>=ei)\n            return;\n        int p_ind = ei;\n        int pivot = arr[p_ind];\n        int j=si;\n        int i=si-1,temp=0;\n        while(j<ei){\n            if(arr[j]<=pivot){\n                i++;\n                temp = arr[j];\n                arr[j]=arr[i];\n                arr[i]=temp;\n            }\n            j++;\n        }\n        i++;\n        temp = pivot;\n        arr[ei]=arr[i];\n        arr[i]=temp;\n        quickSort(arr,si,i-1);\n        quickSort(arr,i+1,ei);\n        \n    }\n    public int[] sortArray(int[] nums) {\n        quickSort(nums,0,nums.length-1);\n        return nums;\n    }\n}\nWhy this code is passing 14/18 test cases can anyone explain?"
                    },
                    {
                        "username": "Udit_69",
                        "content": "[@manishdude1998](/manishdude1998)  No bro its giving wrong answer\nI have done this \nclass Solution {\npublic static void quickSort(int arr[],int si,int ei){\nif(si>=ei)\nreturn;\nint mid = (si + ei)/2;\nint temp = arr[ei];\narr[si] = arr[mid];\narr[mid] = temp;\nint p_ind = ei;\nint pivot = arr[p_ind];\nint j=si;\nint i=si-1;\nwhile(j<ei){\nif(arr[j]<=pivot){\ni++;\ntemp = arr[j];\narr[j]=arr[i];\narr[i]=temp;\n}\nj++;\n}\ni++;\ntemp = pivot;\narr[ei]=arr[i];\narr[i]=temp;\nquickSort(arr,si,i-1);\nquickSort(arr,i+1,ei);\n\n}\npublic int[] sortArray(int[] nums) {\n    if (nums == null || nums.length == 0){\n            return nums;\n        }\n    quickSort(nums,0,nums.length-1);\n    return nums;\n}\n}\nBut dude quicksort in worst case will give n square complexity, so I try with merge sort  which has best and worst complexity as nlogn so below is my code, it works and accepted as well check this\n\n// code for same by merge sort\nclass Solution {\n    \tpublic static void merge(int arr[],int si,int ei){\n        int mid = si+(ei-si)/2;\n        int i=si,j=mid+1,k=si;\n        int temp[]=new int[ei+1];\n        while(i<=mid&&j<=ei){\n            if(arr[i]<arr[j])\n                temp[k++]=arr[i++];\n            else if(arr[i]>arr[j])\n                temp[k++]=arr[j++];\n            else\n               temp[k++] = arr[i++];\n        }\n        for(;i<=mid;i++){\n            temp[k]=arr[i];\n            k++;\n        }\n        for(;j<=ei;j++){\n            temp[k]=arr[j];\n            k++;\n        }\n        for(int l=si;l<=ei;l++) {\n        \tarr[l]=temp[l];\n        }\n        \n    }\n    public static void mergeSort(int arr[],int start,int end){\n        int si=start;\n        int ei=end;\n        int mid = si+(ei-si)/2;\n     if(si>=ei){\n         return;\n     }\n     mergeSort(arr,si,mid); \n     mergeSort(arr,mid+1,ei);\n     merge(arr,si,ei);\n    }\n\n    public int[] sortArray(int[] nums) {\n        if (nums == null || nums.length == 0){\n            return nums;\n        }\n        mergeSort(nums,0,nums.length-1);\n        return nums;\n    }\n} "
                    },
                    {
                        "username": "manishdude1998",
                        "content": "let\\'s say we have\\n\\nnums = [ 1,2,3,4,5,6,7,8,9,10,11,12,14,13] \\n\\nIn this case, if we use the last element as a pivot we are making about 12 calls to quickSort();\\n\\nhowever, if you change the way you are partitioning the array the number of calls can be decreased\\n\\nlike swapping the middle element with the last element first and then partitioning the array\\nthis will make less than 12 calls\\n\\njust add this to your code after the base condition in quickSort function,\\n\\n```java\\nint mid = (si + ei)/2;\\nint tmp = arr[ei];\\narr[si] = arr[mid];\\narr[mid] = tmp;\\n```\\n\\nalso add this at the top in the given sortArray function\\n\\n```java\\nif (nums == null || nums.length == 0){\\n            return nums;\\n        }\\n```\\n\\nThis should clear all the test cases."
                    }
                ]
            }
        ]
    },
    {
        "title": "Sum of Nodes with Even-Valued Grandparent",
        "question_content": "<p>Given the <code>root</code> of a binary tree, return <em>the sum of values of nodes with an <strong>even-valued grandparent</strong></em>. If there are no nodes with an <strong>even-valued grandparent</strong>, return <code>0</code>.</p>\n\n<p>A <strong>grandparent</strong> of a node is the parent of its parent if it exists.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/even1-tree.jpg\" style=\"width: 504px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n<strong>Output:</strong> 18\n<strong>Explanation:</strong> The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/even2-tree.jpg\" style=\"width: 64px; height: 65px;\" />\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 477048,
                "title": "java-c-python-1-line-recursive-solution",
                "content": "## **Intuition**\\nLet children know who their grandparent is.\\n<br>\\n\\n## **Explanation**\\nAssume `node` has `parent.val = 1` and `grandparent.val = 1`.\\nRecursive iterate the whole tree and pass on the value of parent and grandparent.\\nCount the `node.val` when grandparant is even-valued.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(height)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int sumEvenGrandparent(TreeNode root) {\\n        return helper(root, 1, 1);\\n    }\\n\\n    public int helper(TreeNode node, int p, int gp) {\\n        if (node == null) return 0;\\n        return helper(node.left, node.val, p) + helper(node.right, node.val, p) + (gp % 2 == 0 ? node.val : 0);\\n    }\\n```\\n\\n**1-line C++:**\\n```cpp\\n    int sumEvenGrandparent(TreeNode* root, int p = 1, int gp = 1) {\\n        return root ? sumEvenGrandparent(root->left, root->val, p)\\n               + sumEvenGrandparent(root->right, root->val, p)\\n               + (gp % 2 ? 0 : root->val)  : 0;\\n    }\\n```\\n\\n**1-line Python:**\\n```python\\n    def sumEvenGrandparent(self, root, p=1, gp=1):\\n        return self.sumEvenGrandparent(root.left, root.val, p) \\\\\\n            + self.sumEvenGrandparent(root.right, root.val, p) \\\\\\n            + root.val * (1 - gp % 2) if root else 0\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int sumEvenGrandparent(TreeNode root) {\\n        return helper(root, 1, 1);\\n    }\\n\\n    public int helper(TreeNode node, int p, int gp) {\\n        if (node == null) return 0;\\n        return helper(node.left, node.val, p) + helper(node.right, node.val, p) + (gp % 2 == 0 ? node.val : 0);\\n    }\\n```\n```cpp\\n    int sumEvenGrandparent(TreeNode* root, int p = 1, int gp = 1) {\\n        return root ? sumEvenGrandparent(root->left, root->val, p)\\n               + sumEvenGrandparent(root->right, root->val, p)\\n               + (gp % 2 ? 0 : root->val)  : 0;\\n    }\\n```\n```python\\n    def sumEvenGrandparent(self, root, p=1, gp=1):\\n        return self.sumEvenGrandparent(root.left, root.val, p) \\\\\\n            + self.sumEvenGrandparent(root.right, root.val, p) \\\\\\n            + root.val * (1 - gp % 2) if root else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 477095,
                "title": "easy-dfs-solution",
                "content": "```\\n    public static int sum = 0;\\n\\n    public int sumEvenGrandparent(TreeNode root) {\\n        dfs(root, null, null);\\n        return sum;\\n    }\\n\\n    void dfs(TreeNode current, TreeNode parent, TreeNode grandParent) {\\n        if (current == null) return; // base case \\n        if (grandParent != null && grandParent.val % 2 == 0) {\\n            sum += current.val;\\n        }\\n        dfs(current.left, current, parent);// ( newChild, parent, GrandParent)\\n        dfs(current.right, current, parent);\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public static int sum = 0;\\n\\n    public int sumEvenGrandparent(TreeNode root) {\\n        dfs(root, null, null);\\n        return sum;\\n    }\\n\\n    void dfs(TreeNode current, TreeNode parent, TreeNode grandParent) {\\n        if (current == null) return; // base case \\n        if (grandParent != null && grandParent.val % 2 == 0) {\\n            sum += current.val;\\n        }\\n        dfs(current.left, current, parent);// ( newChild, parent, GrandParent)\\n        dfs(current.right, current, parent);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482991,
                "title": "easy-bfs-solution-in-java",
                "content": "```\\npublic int sumEvenGrandparent(TreeNode root) {\\n        int sum = 0;\\n        Queue<TreeNode> q = new LinkedList();\\n        q.add(root);\\n        \\n        //LevelOrderTraversal\\n        while(!q.isEmpty()) {\\n            TreeNode node = q.poll();\\n            if(node.left != null) {\\n                q.add(node.left);\\n                if(node.val % 2 == 0) {\\n                    if(node.left.left != null) {\\n                        sum += node.left.left.val;\\n                    }\\n                    if(node.left.right != null) {\\n                        sum += node.left.right.val;\\n                    }\\n                }\\n            }\\n\\n            if(node.right != null) {\\n                q.add(node.right);\\n                if(node.val % 2 == 0) {\\n                    if(node.right.left != null) {\\n                        sum += node.right.left.val;\\n                    }\\n                    if(node.right.right != null) {\\n                        sum += node.right.right.val;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int sumEvenGrandparent(TreeNode root) {\\n        int sum = 0;\\n        Queue<TreeNode> q = new LinkedList();\\n        q.add(root);\\n        \\n        //LevelOrderTraversal\\n        while(!q.isEmpty()) {\\n            TreeNode node = q.poll();\\n            if(node.left != null) {\\n                q.add(node.left);\\n                if(node.val % 2 == 0) {\\n                    if(node.left.left != null) {\\n                        sum += node.left.left.val;\\n                    }\\n                    if(node.left.right != null) {\\n                        sum += node.left.right.val;\\n                    }\\n                }\\n            }\\n\\n            if(node.right != null) {\\n                q.add(node.right);\\n                if(node.val % 2 == 0) {\\n                    if(node.right.left != null) {\\n                        sum += node.right.left.val;\\n                    }\\n                    if(node.right.right != null) {\\n                        sum += node.right.right.val;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1017710,
                "title": "c-easy-understanding-faster-than-99-77",
                "content": "**Runtime: 32 ms, faster than 99.77% of C++ online submissions**\\n**Memory Usage: 38 MB, less than 99.53% of C++ online submissions**\\n```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n\\t\\n        if(root==NULL) \\n\\t\\t     return 0;\\n        \\n        int sum=0;\\n        \\n\\t\\t//check node with even-valued grandparent add grandchildren value in sum if exist\\n\\t\\t\\n        if(root->val%2==0){\\n            if(root->left!=NULL && root->left->left!=NULL)\\n                sum+=root->left->left->val;\\n            if(root->left!=NULL && root->left->right!=NULL)\\n                sum+=root->left->right->val;\\n            if(root->right!=NULL && root->right->right!=NULL)\\n                sum+=root->right->right->val;\\n            if(root->right!=NULL && root->right->left!=NULL)\\n                sum+=root->right->left->val;\\n        }\\n\\t\\t\\n\\t\\t//dfs\\n        sum+=sumEvenGrandparent(root->left); \\n        sum+=sumEvenGrandparent(root->right); \\n\\t\\t\\n        return sum;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n\\t\\n        if(root==NULL) \\n\\t\\t     return 0;\\n        \\n        int sum=0;\\n        \\n\\t\\t//check node with even-valued grandparent add grandchildren value in sum if exist\\n\\t\\t\\n        if(root->val%2==0){\\n            if(root->left!=NULL && root->left->left!=NULL)\\n                sum+=root->left->left->val;\\n            if(root->left!=NULL && root->left->right!=NULL)\\n                sum+=root->left->right->val;\\n            if(root->right!=NULL && root->right->right!=NULL)\\n                sum+=root->right->right->val;\\n            if(root->right!=NULL && root->right->left!=NULL)\\n                sum+=root->right->left->val;\\n        }\\n\\t\\t\\n\\t\\t//dfs\\n        sum+=sumEvenGrandparent(root->left); \\n        sum+=sumEvenGrandparent(root->right); \\n\\t\\t\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480981,
                "title": "simple-python-3-dfs-solution-beats-99-38",
                "content": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        \\n        def dfs(node: TreeNode, parent: TreeNode, grandParent: TreeNode):\\n            if not node:\\n                return\\n            nonlocal answer\\n            if parent and grandParent and grandParent.val % 2 == 0:\\n                answer += node.val\\n            dfs(node.left, node, parent)\\n            dfs(node.right, node, parent)\\n\\n        answer = 0\\n        dfs(root, None, None)\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        \\n        def dfs(node: TreeNode, parent: TreeNode, grandParent: TreeNode):\\n            if not node:\\n                return\\n            nonlocal answer\\n            if parent and grandParent and grandParent.val % 2 == 0:\\n                answer += node.val\\n            dfs(node.left, node, parent)\\n            dfs(node.right, node, parent)\\n\\n        answer = 0\\n        dfs(root, None, None)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695385,
                "title": "c-easiest-explained-bfs-dfs-solution-beats-51-81",
                "content": "**DFS Solution**\\n```\\nclass Solution {\\npublic:\\n    int s=0;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        fun(root,NULL,NULL);  //passing the root node with it\\'s parent & grandparent as NULL\\n        return s;\\n    }\\n    void fun(TreeNode* root,TreeNode* parent,TreeNode* grandparent)\\n    {\\n        if(!root) return;  //if root is null then return \\n        if(grandparent && grandparent->val%2==0)  //checking even valued grandparent existance \\n            s+=root->val;\\n        fun(root->left,root,parent);  //calling function for left subtree where root will be the parent & previous parent will act as the grandparent for left subtree of the root.\\n        fun(root->right,root,parent);  //same for right subtree\\n    }\\n};\\n```\\n**BFS Solution**\\n```\\nclass Solution {\\npublic:\\n    int fun(TreeNode* root)  //function to return it\\'s value if exist or return 0\\n    {\\n        return root?root->val:0;   \\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root) return 0;  //returns 0 if root is NULL\\n        queue<TreeNode*> q;\\n        q.push(root);  //push root node into the queue\\n        int sum=0;\\n        while(!q.empty())  //iterate the loop until the queue gets empty\\n        {\\n            TreeNode* temp=q.front();  //retrieving front of queue and pop it\\n            q.pop();\\n            if(temp->val%2==0)  //if it\\'s value will be divisible by 2 then check for it\\'s grandson\\n            {\\n                if(temp->left) sum+=fun(temp->left->left)+fun(temp->left->right);  //if it\\'s left child exist then move to both left and right subtree of temp->left\\n                if(temp->right) sum+=fun(temp->right->left)+fun(temp->right->right);  //if it\\'s right child exist then move to both left and right subtree of temp->right\\n            }\\n            if(temp->left) q.push(temp->left);  //if left child exist then push the left node to the queue\\n            if(temp->right) q.push(temp->right);  //if right child exist then push the right node to the queue\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int s=0;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        fun(root,NULL,NULL);  //passing the root node with it\\'s parent & grandparent as NULL\\n        return s;\\n    }\\n    void fun(TreeNode* root,TreeNode* parent,TreeNode* grandparent)\\n    {\\n        if(!root) return;  //if root is null then return \\n        if(grandparent && grandparent->val%2==0)  //checking even valued grandparent existance \\n            s+=root->val;\\n        fun(root->left,root,parent);  //calling function for left subtree where root will be the parent & previous parent will act as the grandparent for left subtree of the root.\\n        fun(root->right,root,parent);  //same for right subtree\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(TreeNode* root)  //function to return it\\'s value if exist or return 0\\n    {\\n        return root?root->val:0;   \\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root) return 0;  //returns 0 if root is NULL\\n        queue<TreeNode*> q;\\n        q.push(root);  //push root node into the queue\\n        int sum=0;\\n        while(!q.empty())  //iterate the loop until the queue gets empty\\n        {\\n            TreeNode* temp=q.front();  //retrieving front of queue and pop it\\n            q.pop();\\n            if(temp->val%2==0)  //if it\\'s value will be divisible by 2 then check for it\\'s grandson\\n            {\\n                if(temp->left) sum+=fun(temp->left->left)+fun(temp->left->right);  //if it\\'s left child exist then move to both left and right subtree of temp->left\\n                if(temp->right) sum+=fun(temp->right->left)+fun(temp->right->right);  //if it\\'s right child exist then move to both left and right subtree of temp->right\\n            }\\n            if(temp->left) q.push(temp->left);  //if left child exist then push the left node to the queue\\n            if(temp->right) q.push(temp->right);  //if right child exist then push the right node to the queue\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651251,
                "title": "solve-using-grand-child-rather-than-grand-parent-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int sumEvenGrandparent(TreeNode* root) {\\n       if(!root) return 0;\\n    if(root->val%2==0){\\n        if(root->left)\\n        {if(root->left->left) sum+=root->left->left->val;\\n        if(root->left->right) sum+=root->left->right->val;}\\n        if(root->right){\\n        if(root->right->left) sum+=root->right->left->val;\\n        if(root->right->right) sum+=root->right->right->val;\\n        }\\n    }\\n        sumEvenGrandparent(root->left);\\n        sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int sumEvenGrandparent(TreeNode* root) {\\n       if(!root) return 0;\\n    if(root->val%2==0){\\n        if(root->left)\\n        {if(root->left->left) sum+=root->left->left->val;\\n        if(root->left->right) sum+=root->left->right->val;}\\n        if(root->right){\\n        if(root->right->left) sum+=root->right->left->val;\\n        if(root->right->right) sum+=root->right->right->val;\\n        }\\n    }\\n        sumEvenGrandparent(root->left);\\n        sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338283,
                "title": "python3-beats-99-61-dfs",
                "content": "![image.png](https://assets.leetcode.com/users/images/6081c989-8823-44d5-bec6-b3295d39c846_1679723623.5277226.png)\\n# Please UPVOTE\\uD83D\\uDE0A\\n\\n# Python3\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        def dfs(root,dad,gp):\\n            if not root:\\n                return 0\\n            x=0\\n            if(gp%2==0):\\n                x=root.val\\n            x+=dfs(root.left,root.val,dad)\\n            x+=dfs(root.right,root.val,dad)\\n            return x\\n\\n        return dfs(root,1,1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        def dfs(root,dad,gp):\\n            if not root:\\n                return 0\\n            x=0\\n            if(gp%2==0):\\n                x=root.val\\n            x+=dfs(root.left,root.val,dad)\\n            x+=dfs(root.right,root.val,dad)\\n            return x\\n\\n        return dfs(root,1,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500065,
                "title": "java-straightforward-dfs-solution-without-a-global-variable",
                "content": "```\\npublic int sumEvenGrandparent(TreeNode root) {\\n            if (root == null) {\\n                return 0;\\n            }\\n            return dfs(root, root.left, 0) + dfs(root, root.right, 0);\\n        }\\n\\n        private int dfs(TreeNode grandparent, TreeNode parent, int sum) {\\n            if (grandparent == null || parent == null) {\\n                return sum;\\n            }\\n            if (grandparent.val % 2 == 0 && parent.left != null) {\\n                sum += parent.left.val;\\n            }\\n            if (grandparent.val % 2 == 0 && parent.right != null) {\\n                sum += parent.right.val;\\n            }\\n            sum = dfs(parent, parent.left, sum);\\n            sum = dfs(parent, parent.right, sum);\\n            return sum;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int sumEvenGrandparent(TreeNode root) {\\n            if (root == null) {\\n                return 0;\\n            }\\n            return dfs(root, root.left, 0) + dfs(root, root.right, 0);\\n        }\\n\\n        private int dfs(TreeNode grandparent, TreeNode parent, int sum) {\\n            if (grandparent == null || parent == null) {\\n                return sum;\\n            }\\n            if (grandparent.val % 2 == 0 && parent.left != null) {\\n                sum += parent.left.val;\\n            }\\n            if (grandparent.val % 2 == 0 && parent.right != null) {\\n                sum += parent.right.val;\\n            }\\n            sum = dfs(parent, parent.left, sum);\\n            sum = dfs(parent, parent.right, sum);\\n            return sum;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 649664,
                "title": "easy-java-dfs-98-6-runtime-100-mem",
                "content": "```\\nclass Solution {\\n    \\n    int sum = 0;\\n    \\n    public int sumEvenGrandparent(TreeNode root) {\\n        \\n        dfs(root, null, null);\\n        return sum;\\n    }\\n    \\n    public void dfs(TreeNode root, TreeNode parent, TreeNode gparent) {\\n        if (root == null) return;\\n        \\n        if (gparent != null && gparent.val % 2 == 0) {\\n            sum += root.val;\\n        }\\n        \\n        if (root.left != null) {\\n            dfs(root.left, root, parent);\\n        }\\n        \\n        if (root.right != null) {\\n            dfs(root.right, root, parent);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int sum = 0;\\n    \\n    public int sumEvenGrandparent(TreeNode root) {\\n        \\n        dfs(root, null, null);\\n        return sum;\\n    }\\n    \\n    public void dfs(TreeNode root, TreeNode parent, TreeNode gparent) {\\n        if (root == null) return;\\n        \\n        if (gparent != null && gparent.val % 2 == 0) {\\n            sum += root.val;\\n        }\\n        \\n        if (root.left != null) {\\n            dfs(root.left, root, parent);\\n        }\\n        \\n        if (root.right != null) {\\n            dfs(root.right, root, parent);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477232,
                "title": "java-python-3-bfs-succinct-codes-w-brief-explanation-and-analysis",
                "content": "Since we can only traverse binary tree from parent to its children, NOT the opposite. In order to sum the nodes with even-value grandparents, we need keep grandparent information before visiting children. \\n\\nTherefore, for BFS, it is an intuitive idea to bind the parent node with the even/odd flag of grand parent.\\n\\n```java\\nimport javafx.util.Pair;\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        int ans = 0;\\n        Queue<Pair<TreeNode, Boolean>> q = new LinkedList<>();\\n        q.add(new Pair(root, false));\\n        while(!q.isEmpty()) {\\n            Pair<TreeNode, Boolean> pair = q.poll();\\n            TreeNode parent = pair.getKey();\\n            boolean evenParent = parent.val % 2 == 0, evenGrandParent = pair.getValue();\\n            for (TreeNode child : new TreeNode[]{parent.left, parent.right}) {\\n                if(child != null) {\\n                    q.add(new Pair(child, evenParent));\\n                    ans += evenGrandParent ? child.val : 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }     \\n}\\n```\\n```python\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        ans, dq = 0, collections.deque([(root, False)])\\n        while dq:\\n            parent, evenGrandParent = dq.popleft()\\n            evenParent = parent.val % 2 == 0\\n            for child in parent.left, parent.right:\\n                if child:\\n                    dq.append((child, evenParent))\\n                    ans += child.val if evenGrandParent else 0\\n        return ans\\n```\\n**Analysis:**\\n\\nTime & space: O(n), where n = the # of nodes in the tree.",
                "solutionTags": [],
                "code": "```java\\nimport javafx.util.Pair;\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        int ans = 0;\\n        Queue<Pair<TreeNode, Boolean>> q = new LinkedList<>();\\n        q.add(new Pair(root, false));\\n        while(!q.isEmpty()) {\\n            Pair<TreeNode, Boolean> pair = q.poll();\\n            TreeNode parent = pair.getKey();\\n            boolean evenParent = parent.val % 2 == 0, evenGrandParent = pair.getValue();\\n            for (TreeNode child : new TreeNode[]{parent.left, parent.right}) {\\n                if(child != null) {\\n                    q.add(new Pair(child, evenParent));\\n                    ans += evenGrandParent ? child.val : 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }     \\n}\\n```\n```python\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        ans, dq = 0, collections.deque([(root, False)])\\n        while dq:\\n            parent, evenGrandParent = dq.popleft()\\n            evenParent = parent.val % 2 == 0\\n            for child in parent.left, parent.right:\\n                if child:\\n                    dq.append((child, evenParent))\\n                    ans += child.val if evenGrandParent else 0\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486682,
                "title": "python-3-recursive-dfs-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, node: TreeNode) -> int:\\n        self.total = 0\\n        \\n        def dfs(root):\\n            if root.val % 2 == 0:\\n                if root.left:\\n                    if root.left.left:\\n                        self.total += root.left.left.val  # Add grandchild\\'s value\\n                    if root.left.right:\\n                        self.total += root.left.right.val\\n                if root.right:\\n                    if root.right.left:\\n                        self.total += root.right.left.val\\n                    if root.right.right:\\n                        self.total += root.right.right.val\\n            if root.left:\\n                dfs(root.left)\\n            if root.right:\\n                dfs(root.right)\\n            return\\n        \\n        dfs(node)\\n        return self.total\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, node: TreeNode) -> int:\\n        self.total = 0\\n        \\n        def dfs(root):\\n            if root.val % 2 == 0:\\n                if root.left:\\n                    if root.left.left:\\n                        self.total += root.left.left.val  # Add grandchild\\'s value\\n                    if root.left.right:\\n                        self.total += root.left.right.val\\n                if root.right:\\n                    if root.right.left:\\n                        self.total += root.right.left.val\\n                    if root.right.right:\\n                        self.total += root.right.right.val\\n            if root.left:\\n                dfs(root.left)\\n            if root.right:\\n                dfs(root.right)\\n            return\\n        \\n        dfs(node)\\n        return self.total\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 478478,
                "title": "c-solution",
                "content": "remember parent and grandparent while traversing down, whenever grandparent is even, add the node value in return and call with updated parent and grandparent on both sides, else only call with updated parent and grandparent.\\nbase condition of recursion is root is not null.\\ninitially assume parent and grandparent both to be odd, say 9.\\n```\\nint sumEvenGrandparent(TreeNode* root, int pr = 9, int gpr = 9) {\\n        if(root)\\n\\t\\t\\treturn sumEvenGrandparent(root->left, root->val, pr)\\n               + sumEvenGrandparent(root->right, root->val, pr)\\n               + (gpr % 2==0 ? root->val:0) ;\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint sumEvenGrandparent(TreeNode* root, int pr = 9, int gpr = 9) {\\n        if(root)\\n\\t\\t\\treturn sumEvenGrandparent(root->left, root->val, pr)\\n               + sumEvenGrandparent(root->right, root->val, pr)\\n               + (gpr % 2==0 ? root->val:0) ;\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3674532,
                "title": "c-2-easy-approaches",
                "content": "# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void c(TreeNode* root){\\n        if(root==NULL)return;\\n        int x = 0;\\n        if(root->left)x+=root->left->val;\\n        if(root->right)x+=root->right->val;\\n        sum += x;\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root==NULL)return 0;\\n        if(root->val%2==0){\\n            c(root->left);\\n            c(root->right);\\n        }\\n        sumEvenGrandparent(root->left);\\n        sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void helper(TreeNode* root,TreeNode* parent,TreeNode* gp){\\n        if(root==NULL)return;\\n        if(gp && gp->val%2==0)sum+=root->val;\\n        helper(root->left,root,parent);\\n        helper(root->right,root,parent);\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root==NULL)return 0;\\n        helper(root,NULL,NULL);\\n        return sum;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/f7711813-1227-4952-8f21-ebaa966a1a6b_1687541918.8806655.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void c(TreeNode* root){\\n        if(root==NULL)return;\\n        int x = 0;\\n        if(root->left)x+=root->left->val;\\n        if(root->right)x+=root->right->val;\\n        sum += x;\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root==NULL)return 0;\\n        if(root->val%2==0){\\n            c(root->left);\\n            c(root->right);\\n        }\\n        sumEvenGrandparent(root->left);\\n        sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void helper(TreeNode* root,TreeNode* parent,TreeNode* gp){\\n        if(root==NULL)return;\\n        if(gp && gp->val%2==0)sum+=root->val;\\n        helper(root->left,root,parent);\\n        helper(root->right,root,parent);\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root==NULL)return 0;\\n        helper(root,NULL,NULL);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799028,
                "title": "cpp-easy-to-understand-explained-with-very-simple-concept",
                "content": "**Main motive :**\\n   \\n *     if a node is child then in next step it will be parent\\n *     if a node is parent then in next step it will be grandparent  \\n*      next child will be currentchild->child\\n\\t \\n```Here is the implementation```\\t \\n\\n```\\nclass Solution {\\npublic:\\n    int s=0;\\n    void find(TreeNode *gp,TreeNode *p, TreeNode * child)\\n    {\\n        if(child==NULL) return; \\n        if(gp!=NULL&&gp->val%2==0){ s+=child->val;} \\n        //make parent to gp, child to parent ,child= child->child \\n        find(p,child,child->left);\\n        find(p,child,child->right);\\n    }\\n    int sumEvenGrandparent(TreeNode* root) { \\n        \\n        find(NULL,NULL,root);  //we are passing grandparent(gp),parent(p),child\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```Here is the implementation```\n```\\nclass Solution {\\npublic:\\n    int s=0;\\n    void find(TreeNode *gp,TreeNode *p, TreeNode * child)\\n    {\\n        if(child==NULL) return; \\n        if(gp!=NULL&&gp->val%2==0){ s+=child->val;} \\n        //make parent to gp, child to parent ,child= child->child \\n        find(p,child,child->left);\\n        find(p,child,child->right);\\n    }\\n    int sumEvenGrandparent(TreeNode* root) { \\n        \\n        find(NULL,NULL,root);  //we are passing grandparent(gp),parent(p),child\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531639,
                "title": "java-fast-and-beautiful-little-trick",
                "content": "Explanation:\\n1. if a node is even it will add 1 to var \"lev\" and pass on to its children\\n2. If a node receives a 1 in \"lev\" var, it means the parent node is even and it adds another one to the var and pass on\\n3. if a node receives 2 in \"lev\" var, it means the grandparent was even and the current value is to be included\\n\\nThe three steps needs to be done in reverse for proper updation of variable \"lev\"\\n\\n\\n```class Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        return sum(root, 0);   \\n    }\\n    \\n    public int sum(TreeNode root, int lev) {\\n        if (root == null) return 0;\\n        int val = 0;\\n        \\n        if(lev > 1) {\\n            val = root.val;\\n            lev-=2;\\n        } \\n        \\n        if(lev == 1) {\\n            lev++;\\n        }\\n        \\n        if(root.val%2 == 0) {\\n            lev++;\\n        }\\n\\n        return sum(root.left, lev) + sum(root.right, lev) + val;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        return sum(root, 0);   \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 634433,
                "title": "2-solutions-faster-than-86-easy-to-understand-python-solution",
                "content": "```\\n    def other_way(self, root):\\n        #as per the hints\\n        def rec(node, parent, grand):\\n            if node:\\n                if grand%2==0: self.s+= node.val\\n                rec(node.left, node.val, parent)\\n                rec(node.right, node.val, parent)\\n        rec(root, 1, 1)\\n        return self.s\\n        \\n        \\n    def one_way(self, root):\\n        def addSum(node):\\n            if node.left:\\n                if node.left.left: self.s+= node.left.left.val\\n                if node.left.right: self.s+= node.left.right.val\\n            if node.right:\\n                if node.right.left: self.s+= node.right.left.val\\n                if node.right.right: self.s+= node.right.right.val\\n  \\n            \\n        def rec(node):\\n            if node:\\n                if node.val%2==0:\\n                    addSum(node)\\n                rec(node.left)\\n                rec(node.right)\\n                \\n        rec(root)\\n        return self.s\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def other_way(self, root):\\n        #as per the hints\\n        def rec(node, parent, grand):\\n            if node:\\n                if grand%2==0: self.s+= node.val\\n                rec(node.left, node.val, parent)\\n                rec(node.right, node.val, parent)\\n        rec(root, 1, 1)\\n        return self.s\\n        \\n        \\n    def one_way(self, root):\\n        def addSum(node):\\n            if node.left:\\n                if node.left.left: self.s+= node.left.left.val\\n                if node.left.right: self.s+= node.left.right.val\\n            if node.right:\\n                if node.right.left: self.s+= node.right.left.val\\n                if node.right.right: self.s+= node.right.right.val\\n  \\n            \\n        def rec(node):\\n            if node:\\n                if node.val%2==0:\\n                    addSum(node)\\n                rec(node.left)\\n                rec(node.right)\\n                \\n        rec(root)\\n        return self.s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 668270,
                "title": "two-solution-in-python-3-both-bfs-and-dfs",
                "content": "BFS:\\n```\\ndef sumEvenGrandparent(self, root: TreeNode) -> int:\\n\\tif not root:\\n\\t\\treturn 0\\n\\tq = [root]\\n\\ts = 0\\n\\twhile q:\\n\\t\\tcurr = q.pop()\\n\\t\\tif curr:\\n\\t\\t\\tq+=[curr.right, curr.left]\\n\\t\\t\\tif curr.val%2==0:\\n\\t\\t\\t\\tif curr.left:\\n\\t\\t\\t\\t\\tif curr.left.left:\\n\\t\\t\\t\\t\\t\\ts+=curr.left.left.val\\n\\t\\t\\t\\t\\tif curr.left.right:\\n\\t\\t\\t\\t\\t\\ts+=curr.left.right.val\\n\\t\\t\\t\\tif curr.right:\\n\\t\\t\\t\\t\\tif curr.right.left:\\n\\t\\t\\t\\t\\t\\ts+=curr.right.left.val\\n\\t\\t\\t\\t\\tif curr.right.right:\\n\\t\\t\\t\\t\\t\\ts+=curr.right.right.val\\n\\treturn s\\n```\\n\\nDFS:\\n\\n```\\ndef sumEvenGrandparent(self, root: TreeNode) -> int:\\n\\tstack = [(root, None)]\\n\\tres = 0\\n\\twhile stack:\\n\\t\\tnode, even_parent = stack.pop()\\n\\t\\tif node.left:\\n\\t\\t\\tstack.append((node.left, node.val%2==0))\\n\\t\\t\\tif even_parent:\\n\\t\\t\\t\\tres+=node.left.val\\n\\t\\tif node.right:\\n\\t\\t\\tstack.append((node.right, node.val%2==0))\\n\\t\\t\\tif even_parent:\\n\\t\\t\\t\\tres+=node.right.val\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\ndef sumEvenGrandparent(self, root: TreeNode) -> int:\\n\\tif not root:\\n\\t\\treturn 0\\n\\tq = [root]\\n\\ts = 0\\n\\twhile q:\\n\\t\\tcurr = q.pop()\\n\\t\\tif curr:\\n\\t\\t\\tq+=[curr.right, curr.left]\\n\\t\\t\\tif curr.val%2==0:\\n\\t\\t\\t\\tif curr.left:\\n\\t\\t\\t\\t\\tif curr.left.left:\\n\\t\\t\\t\\t\\t\\ts+=curr.left.left.val\\n\\t\\t\\t\\t\\tif curr.left.right:\\n\\t\\t\\t\\t\\t\\ts+=curr.left.right.val\\n\\t\\t\\t\\tif curr.right:\\n\\t\\t\\t\\t\\tif curr.right.left:\\n\\t\\t\\t\\t\\t\\ts+=curr.right.left.val\\n\\t\\t\\t\\t\\tif curr.right.right:\\n\\t\\t\\t\\t\\t\\ts+=curr.right.right.val\\n\\treturn s\\n```\n```\\ndef sumEvenGrandparent(self, root: TreeNode) -> int:\\n\\tstack = [(root, None)]\\n\\tres = 0\\n\\twhile stack:\\n\\t\\tnode, even_parent = stack.pop()\\n\\t\\tif node.left:\\n\\t\\t\\tstack.append((node.left, node.val%2==0))\\n\\t\\t\\tif even_parent:\\n\\t\\t\\t\\tres+=node.left.val\\n\\t\\tif node.right:\\n\\t\\t\\tstack.append((node.right, node.val%2==0))\\n\\t\\t\\tif even_parent:\\n\\t\\t\\t\\tres+=node.right.val\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 637289,
                "title": "easy-to-understand-python-dfs",
                "content": "```\\n    def sumEvenGrandparent(self, root):\\n        self.sum = 0\\n        \\n        def dfs(root, even_grandparent, parent_val):\\n            if root == None:\\n                return \\n            \\n            if even_grandparent:\\n                self.sum += root.val\\n                \\n            even_grandparent = (parent_val % 2) == 0\\n            dfs(root.left, even_grandparent, root.val)\\n            dfs(root.right, even_grandparent, root.val)\\n            \\n        dfs(root, False, 1)\\n        \\n        return self.sum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def sumEvenGrandparent(self, root):\\n        self.sum = 0\\n        \\n        def dfs(root, even_grandparent, parent_val):\\n            if root == None:\\n                return \\n            \\n            if even_grandparent:\\n                self.sum += root.val\\n                \\n            even_grandparent = (parent_val % 2) == 0\\n            dfs(root.left, even_grandparent, root.val)\\n            dfs(root.right, even_grandparent, root.val)\\n            \\n        dfs(root, False, 1)\\n        \\n        return self.sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 514777,
                "title": "python3-96ms-solution",
                "content": "```python\\nclass Solution:\\n    def __init__(self):\\n        self.summary = 0\\n\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        self.walk(root, False, False)\\n        return self.summary\\n\\n    def walk(self, node: TreeNode, parent_even: bool, grand_parent_even: bool):\\n        if node is None:\\n            return\\n        if grand_parent_even:\\n            self.summary += node.val\\n        next_parent_even = True if node.val % 2 == 0 else False\\n        self.walk(node.left, next_parent_even, parent_even)\\n        self.walk(node.right, next_parent_even, parent_even)\\n        return\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def __init__(self):\\n        self.summary = 0\\n\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        self.walk(root, False, False)\\n        return self.summary\\n\\n    def walk(self, node: TreeNode, parent_even: bool, grand_parent_even: bool):\\n        if node is None:\\n            return\\n        if grand_parent_even:\\n            self.summary += node.val\\n        next_parent_even = True if node.val % 2 == 0 else False\\n        self.walk(node.left, next_parent_even, parent_even)\\n        self.walk(node.right, next_parent_even, parent_even)\\n        return\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483222,
                "title": "javascript-intuitive",
                "content": "```\\nfunction sumEvenGrandparent (root, grandpaEven = false, fatherEven = false) {\\n  if (!root) return 0;\\n  const isEven = root.val % 2 === 0\\n  const left = sumEvenGrandparent(root.left, fatherEven, isEven);\\n  const right = sumEvenGrandparent(root.right, fatherEven, isEven);\\n  return left + right + (grandpaEven ? root.val : 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction sumEvenGrandparent (root, grandpaEven = false, fatherEven = false) {\\n  if (!root) return 0;\\n  const isEven = root.val % 2 === 0\\n  const left = sumEvenGrandparent(root.left, fatherEven, isEven);\\n  const right = sumEvenGrandparent(root.right, fatherEven, isEven);\\n  return left + right + (grandpaEven ? root.val : 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478062,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    int sum = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        dfs(null, null, root);\\n        return sum;\\n    }\\n    void dfs(TreeNode parent, TreeNode father, TreeNode node) {\\n        if (node == null) {\\n            return;\\n        }\\n        if (parent != null && parent.val % 2 == 0) {\\n            sum += node.val;\\n        }\\n        dfs(father, node, node.left);\\n        dfs(father, node, node.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        dfs(null, null, root);\\n        return sum;\\n    }\\n    void dfs(TreeNode parent, TreeNode father, TreeNode node) {\\n        if (node == null) {\\n            return;\\n        }\\n        if (parent != null && parent.val % 2 == 0) {\\n            sum += node.val;\\n        }\\n        dfs(father, node, node.left);\\n        dfs(father, node, node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314047,
                "title": "c-2-solutions-adding-grand-child-adding-grand-parent",
                "content": "# Intuition\\nThere are 2 approaches to solve this problem - :\\n- *you can either add **grand children** of every even node* \\n- *OR you can add **grand parents*** \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach [adding Grandchildren]\\n- for every **even** node\\n- we use if statements to check if grandchildren **exists or not**, **if exist we add their values to the sum**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode *root, int &sum)\\n{\\n    if (root == NULL)\\n    {\\n        return ; \\n    }\\n\\n    if (root -> val % 2 == 0)\\n    {\\n        // sum += root -> left -> left -> val + root -> right -> right -> val + root -> left -> right -> val + root -> right -> left -> val ; \\n        if (root -> left)\\n        {\\n            if (root -> left -> left)\\n            {\\n                sum += root -> left -> left -> val ;\\n            }\\n            if (root -> left -> right)\\n            {\\n                sum += root -> left -> right -> val ; \\n            }\\n        }\\n\\n        if (root -> right)\\n        {\\n            if (root -> right -> right)\\n            {\\n                sum += root -> right -> right -> val ;\\n            }\\n            if (root -> right -> left)\\n            {\\n                sum += root -> right -> left -> val ;\\n            }\\n        }\\n    }\\n\\n    helper(root -> left , sum) ; \\n    helper(root -> right, sum) ; \\n}\\n\\n    int sumEvenGrandparent(TreeNode* root) {\\n        int sum = 0 ;\\n        helper(root, sum) ; \\n        return sum ; \\n    }\\n};\\n```\\n`code`![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/0ab33de3-3055-4350-8ea0-f08ad0c58ed2_1679198283.768887.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode *root, int &sum)\\n{\\n    if (root == NULL)\\n    {\\n        return ; \\n    }\\n\\n    if (root -> val % 2 == 0)\\n    {\\n        // sum += root -> left -> left -> val + root -> right -> right -> val + root -> left -> right -> val + root -> right -> left -> val ; \\n        if (root -> left)\\n        {\\n            if (root -> left -> left)\\n            {\\n                sum += root -> left -> left -> val ;\\n            }\\n            if (root -> left -> right)\\n            {\\n                sum += root -> left -> right -> val ; \\n            }\\n        }\\n\\n        if (root -> right)\\n        {\\n            if (root -> right -> right)\\n            {\\n                sum += root -> right -> right -> val ;\\n            }\\n            if (root -> right -> left)\\n            {\\n                sum += root -> right -> left -> val ;\\n            }\\n        }\\n    }\\n\\n    helper(root -> left , sum) ; \\n    helper(root -> right, sum) ; \\n}\\n\\n    int sumEvenGrandparent(TreeNode* root) {\\n        int sum = 0 ;\\n        helper(root, sum) ; \\n        return sum ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097173,
                "title": "java-c-100-solution-using-depth-first-search-sum-of-nodes-with-even-valued-grandparent",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n        int sum = 0;\\n        if(root->val % 2 == 0)\\n        {\\n            if(root->left !=NULL && root->left->left !=NULL)\\n                sum+=root->left->left->val;\\n            if(root->left !=NULL && root->left->right !=NULL)\\n                sum+=root->left->right->val;\\n            if(root->right !=NULL && root->right->left !=NULL)\\n                sum+=root->right->left->val;\\n            if(root->right !=NULL && root->right->right !=NULL)\\n                sum+=root->right->right->val;\\n        }\\n        sum += sumEvenGrandparent(root->left) + sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        int sum = 0;\\n        if(root.val % 2 == 0)\\n        {\\n            if(root.left !=null && root.left.left !=null)\\n                sum+=root.left.left.val;\\n            if(root.left !=null && root.left.right !=null)\\n                sum+=root.left.right.val;\\n            if(root.right !=null && root.right.left !=null)\\n                sum+=root.right.left.val;\\n            if(root.right !=null && root.right.right !=null)\\n                sum+=root.right.right.val;\\n        }\\n        sum += sumEvenGrandparent(root.left) + sumEvenGrandparent(root.right);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n        int sum = 0;\\n        if(root->val % 2 == 0)\\n        {\\n            if(root->left !=NULL && root->left->left !=NULL)\\n                sum+=root->left->left->val;\\n            if(root->left !=NULL && root->left->right !=NULL)\\n                sum+=root->left->right->val;\\n            if(root->right !=NULL && root->right->left !=NULL)\\n                sum+=root->right->left->val;\\n            if(root->right !=NULL && root->right->right !=NULL)\\n                sum+=root->right->right->val;\\n        }\\n        sum += sumEvenGrandparent(root->left) + sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        int sum = 0;\\n        if(root.val % 2 == 0)\\n        {\\n            if(root.left !=null && root.left.left !=null)\\n                sum+=root.left.left.val;\\n            if(root.left !=null && root.left.right !=null)\\n                sum+=root.left.right.val;\\n            if(root.right !=null && root.right.left !=null)\\n                sum+=root.right.left.val;\\n            if(root.right !=null && root.right.right !=null)\\n                sum+=root.right.right.val;\\n        }\\n        sum += sumEvenGrandparent(root.left) + sumEvenGrandparent(root.right);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 618680,
                "title": "c-easy-bfs-34-runtime-100-memory",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int help(TreeNode* root){\\n        return root ? root->val : 0;\\n    }\\n    \\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        \\n        queue<TreeNode*> depth;\\n        depth.push(root);\\n        int sum = 0;\\n        \\n        while(!depth.empty()){\\n            TreeNode* curr = depth.front();\\n            depth.pop();\\n            \\n            if(curr->val % 2 == 0){\\n                if(curr->left) sum += help(curr->left->left) + help(curr->left->right);\\n                if(curr->right) sum += help(curr->right->left) + help(curr->right->right);\\n            }\\n            \\n            if(curr->left) depth.push(curr->left);\\n            if(curr->right) depth.push(curr->right);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int help(TreeNode* root){\\n        return root ? root->val : 0;\\n    }\\n    \\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        \\n        queue<TreeNode*> depth;\\n        depth.push(root);\\n        int sum = 0;\\n        \\n        while(!depth.empty()){\\n            TreeNode* curr = depth.front();\\n            depth.pop();\\n            \\n            if(curr->val % 2 == 0){\\n                if(curr->left) sum += help(curr->left->left) + help(curr->left->right);\\n                if(curr->right) sum += help(curr->right->left) + help(curr->right->right);\\n            }\\n            \\n            if(curr->left) depth.push(curr->left);\\n            if(curr->right) depth.push(curr->right);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456881,
                "title": "java-dfs-easy-100-faster",
                "content": "Initialise gp(grapdparent) = -1, p(parent)  = -1\\n\\n1. At every recursive call, check the value of gp, if it is even, add it in result. \\n2. Now, while moving forward, current parent will become grandparent, and current node will become parent.\\n3. Recursively call for left and right after having null check \\n\\n```\\nclass Solution {\\n    private int result = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        \\n        dfs(root,-1,-1);\\n        return result;\\n    }\\n    \\n    public void dfs(TreeNode root, int p, int gp){\\n        \\n        if(root == null) return;\\n        \\n        if(gp % 2 == 0){\\n            result += root.val;\\n        }\\n        \\n        gp = p;\\n        p = root.val;\\n        \\n        if(root.left != null) dfs(root.left, p, gp);\\n        if(root.right != null) dfs(root.right, p, gp);\\n    }\\n}\\n```\\n\\nPlease upvote if u like!  :)",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private int result = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        \\n        dfs(root,-1,-1);\\n        return result;\\n    }\\n    \\n    public void dfs(TreeNode root, int p, int gp){\\n        \\n        if(root == null) return;\\n        \\n        if(gp % 2 == 0){\\n            result += root.val;\\n        }\\n        \\n        gp = p;\\n        p = root.val;\\n        \\n        if(root.left != null) dfs(root.left, p, gp);\\n        if(root.right != null) dfs(root.right, p, gp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361596,
                "title": "c-easy-solution-dfs-recursion",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    void sumGparent(TreeNode* child, int& sum, TreeNode* parent, TreeNode* Gparent){\\n        if(!child) return;\\n        if(Gparent) if(Gparent->val % 2 ==0) sum += child->val;\\n        sumGparent(child->left, sum, child, parent);\\n        sumGparent(child->right, sum, child, parent);\\n    }\\n    \\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root) return 0;\\n        int sum=0;\\n        sumGparent(root, sum, NULL, NULL); // (child, sum, parent, grand-parent)\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sumGparent(TreeNode* child, int& sum, TreeNode* parent, TreeNode* Gparent){\\n        if(!child) return;\\n        if(Gparent) if(Gparent->val % 2 ==0) sum += child->val;\\n        sumGparent(child->left, sum, child, parent);\\n        sumGparent(child->right, sum, child, parent);\\n    }\\n    \\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root) return 0;\\n        int sum=0;\\n        sumGparent(root, sum, NULL, NULL); // (child, sum, parent, grand-parent)\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069680,
                "title": "weeb-does-python-bfs-level-order-traversal",
                "content": "\\n\\tclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        \\n        queue = deque([(root,TreeNode(1))]) # fam this value this needs to be odd to start cuz the parent aint got no parent \\n        result = 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                curNode, parent= queue.popleft()\\n                if parent.val % 2 == 0:\\n                    result += curNode.left.val if curNode.left is not None else 0\\n                    result += curNode.right.val if curNode.right is not None else 0\\n                if curNode.left is not None:\\n                    queue.append((curNode.left,curNode))\\n                if curNode.right is not None:\\n                    queue.append((curNode.right,curNode))\\n        return result\\n# Aight homies, this time go watch ***Black Clover***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue",
                    "Iterator"
                ],
                "code": "\\n\\tclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        \\n        queue = deque([(root,TreeNode(1))]) # fam this value this needs to be odd to start cuz the parent aint got no parent \\n        result = 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                curNode, parent= queue.popleft()\\n                if parent.val % 2 == 0:\\n                    result += curNode.left.val if curNode.left is not None else 0\\n                    result += curNode.right.val if curNode.right is not None else 0\\n                if curNode.left is not None:\\n                    queue.append((curNode.left,curNode))\\n                if curNode.right is not None:\\n                    queue.append((curNode.right,curNode))\\n        return result\\n# Aight homies, this time go watch ***Black Clover***",
                "codeTag": "Java"
            },
            {
                "id": 2958630,
                "title": "easy-c-recursive-solution",
                "content": "\\n# Approach\\nThe approach is simple. We keep track of tne previos two nodes. If the value of the grandparent node is even, then we add the grandchild\\'s value. \\n\\n# Complexity\\n- Time complexity: O(n), n = number of nodes\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int getSum(TreeNode* parent, TreeNode* grandparent)\\n    {\\n        if(parent == nullptr)\\n            return 0;\\n\\n        int leftChild = getSum(parent->left, parent);\\n        int rightChild = getSum(parent->right, parent);\\n\\n        if(grandparent->val % 2 == 0 && parent->left != nullptr)\\n            leftChild += parent->left->val;\\n        if(grandparent->val % 2 == 0 && parent->right != nullptr)\\n            rightChild += parent->right->val;\\n        \\n        return leftChild + rightChild;\\n    }\\n\\n    int sumEvenGrandparent(TreeNode* node) {\\n       return getSum(node->left, node) + getSum(node->right, node);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int getSum(TreeNode* parent, TreeNode* grandparent)\\n    {\\n        if(parent == nullptr)\\n            return 0;\\n\\n        int leftChild = getSum(parent->left, parent);\\n        int rightChild = getSum(parent->right, parent);\\n\\n        if(grandparent->val % 2 == 0 && parent->left != nullptr)\\n            leftChild += parent->left->val;\\n        if(grandparent->val % 2 == 0 && parent->right != nullptr)\\n            rightChild += parent->right->val;\\n        \\n        return leftChild + rightChild;\\n    }\\n\\n    int sumEvenGrandparent(TreeNode* node) {\\n       return getSum(node->left, node) + getSum(node->right, node);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703112,
                "title": "c-bfs-iterative",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) \\n    {\\n      if(root==NULL)\\n   return 0;\\n   \\n   int sum=0;\\n   \\n   queue<TreeNode*>q;\\n   q.push(root);\\n   \\n   while(!q.empty())\\n   {\\n   \\t  int size = q.size();\\n   \\t  \\n   \\t  for(int i=0;i<size;i++)\\n   \\t  {\\n          TreeNode* temp=q.front();\\n\\t\\t  q.pop();\\n\\t\\t  \\n\\t\\t  if(temp!=NULL and (temp->val%2)==0 and temp->left!=NULL and temp->left->left!=NULL)\\n\\t\\t  {\\n\\t\\t     sum=sum+temp->left->left->val;\\t\\n          } \\t \\n          if(temp!=NULL and (temp->val%2)==0 and temp->left!=NULL and temp->left->right!=NULL)\\n          {\\n          \\t sum=sum+temp->left->right->val;\\n\\t\\t  }\\n\\t\\t  if(temp!=NULL and (temp->val%2)==0 and temp->right!=NULL and temp->right->left!=NULL)\\n\\t\\t  {\\n\\t\\t  \\tsum=sum+temp->right->left->val;\\n\\t\\t  }\\n\\t\\t  if(temp!=NULL and (temp->val%2)==0 and temp->right!=NULL and temp->right->right!=NULL)\\n\\t\\t  {\\n\\t\\t  \\tsum=sum+temp->right->right->val;\\n\\t\\t  }\\n\\t\\t  \\n\\t\\t  if(temp->left!=NULL)\\n\\t\\t  {\\n\\t\\t  \\tq.push(temp->left);\\n\\t\\t  }\\n\\t\\t  if(temp->right!=NULL)\\n\\t\\t  {\\n\\t\\t  \\tq.push(temp->right);\\n\\t\\t  }\\n      }\\n   }\\n   return sum;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) \\n    {\\n      if(root==NULL)\\n   return 0;\\n   \\n   int sum=0;\\n   \\n   queue<TreeNode*>q;\\n   q.push(root);\\n   \\n   while(!q.empty())\\n   {\\n   \\t  int size = q.size();\\n   \\t  \\n   \\t  for(int i=0;i<size;i++)\\n   \\t  {\\n          TreeNode* temp=q.front();\\n\\t\\t  q.pop();\\n\\t\\t  \\n\\t\\t  if(temp!=NULL and (temp->val%2)==0 and temp->left!=NULL and temp->left->left!=NULL)\\n\\t\\t  {\\n\\t\\t     sum=sum+temp->left->left->val;\\t\\n          } \\t \\n          if(temp!=NULL and (temp->val%2)==0 and temp->left!=NULL and temp->left->right!=NULL)\\n          {\\n          \\t sum=sum+temp->left->right->val;\\n\\t\\t  }\\n\\t\\t  if(temp!=NULL and (temp->val%2)==0 and temp->right!=NULL and temp->right->left!=NULL)\\n\\t\\t  {\\n\\t\\t  \\tsum=sum+temp->right->left->val;\\n\\t\\t  }\\n\\t\\t  if(temp!=NULL and (temp->val%2)==0 and temp->right!=NULL and temp->right->right!=NULL)\\n\\t\\t  {\\n\\t\\t  \\tsum=sum+temp->right->right->val;\\n\\t\\t  }\\n\\t\\t  \\n\\t\\t  if(temp->left!=NULL)\\n\\t\\t  {\\n\\t\\t  \\tq.push(temp->left);\\n\\t\\t  }\\n\\t\\t  if(temp->right!=NULL)\\n\\t\\t  {\\n\\t\\t  \\tq.push(temp->right);\\n\\t\\t  }\\n      }\\n   }\\n   return sum;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190307,
                "title": "faster-than-95-8-easy-12-line-code",
                "content": "gp:- stands for value of grand parent\\np:- value of parent \\n\\n```\\n    void sol(TreeNode* root, int gp,int p,int& cnt)\\n    {\\n        if(root==NULL)return ;\\n        if(gp%2==0)cnt+=root->val;\\n        sol(root->left,p,root->val,cnt);\\n        sol(root->right,p,root->val,cnt);\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        int cnt=0;\\n\\t\\t// For root node we will take -1 for both of them because root node doesn\\'t have parents\\n        sol(root,-1,-1,cnt);\\n        return cnt;\\n    }\\n```\\n**upvote if you found it useful**",
                "solutionTags": [],
                "code": "```\\n    void sol(TreeNode* root, int gp,int p,int& cnt)\\n    {\\n        if(root==NULL)return ;\\n        if(gp%2==0)cnt+=root->val;\\n        sol(root->left,p,root->val,cnt);\\n        sol(root->right,p,root->val,cnt);\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        int cnt=0;\\n\\t\\t// For root node we will take -1 for both of them because root node doesn\\'t have parents\\n        sol(root,-1,-1,cnt);\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1860868,
                "title": "c-dfs-easy-to-understand",
                "content": "**Appoarch:-**\\nThe idea is to create a dfs function with four argruments:-\\n     1. root   2. parent node  3. grandparent  4. ans\\n\\nwhile traversing to the child node make current node as a parent node and parent node as grandparent node\\n\\nif we see grandparent node is not equal to null and it is even valued,\\nthen add current node value to the ans.\\n\\n**Time Complexity:-** o(n) , since every node is visiting only once\\n\\n**Code:-**\\n\\n```\\nclass Solution {\\n    void dfs(TreeNode *root,TreeNode* parent,TreeNode* grandParent,int &ans){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(grandParent!=NULL && grandParent->val%2==0){\\n            ans+= root->val;\\n        }\\n        dfs(root->left,root,parent,ans);\\n        dfs(root->right,root,parent,ans);\\n        return;\\n    }\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root,NULL,NULL,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(TreeNode *root,TreeNode* parent,TreeNode* grandParent,int &ans){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(grandParent!=NULL && grandParent->val%2==0){\\n            ans+= root->val;\\n        }\\n        dfs(root->left,root,parent,ans);\\n        dfs(root->right,root,parent,ans);\\n        return;\\n    }\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root,NULL,NULL,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746597,
                "title": "java-easy-to-understand-explanation-solution",
                "content": "### Explanation\\nThe problem is quite logical and easy when we rephrase the problem statement.\\n> \"Sum of Node with Even-Valued Grandparent\" \\n\\ninto \\n\\n> \"Sum of **Grandchildren** of an Even-Valued Node\"\\n\\nGrandchildren of any node `root` easy to find with 2 conditions:\\n1. Parents should not be empty (`root.left != null`,  `root.right != null ` seperately).\\n2. Parents should not be a leaf node.\\n\\nThe second point above, when implemented, will make our code clumsy with too many if conditions.\\nTo avoid that, we build a simple helper function which returns 0 if a node is empty (so it does not add up to the sum).\\n```\\nint value(TreeNode root) {\\n\\treturn (root != null)? root.val : 0;\\n}\\n```\\nTime Complexity : **O(n)**\\nSpace Complexity: **O(1)**\\n> **Do try to code the problem using the above explanation before jumping to the solution :)**\\n\\n\\n### Solution\\n```\\nclass Solution {\\n    int sum;\\n    \\n    // void println(Object o) {System.out.println(o);}\\n    \\n    int value(TreeNode root) {\\n        return (root != null)? root.val: 0;\\n    }\\n    int dfs(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        if (root.val % 2 == 0) {\\n            if (root.left != null) {\\n                sum += value(root.left.left) + value(root.left.right);                \\n            }\\n            if (root.right != null) {\\n                sum += value(root.right.left) + value(root.right.right);\\n            }\\n        }\\n        \\n        dfs(root.right);\\n        dfs(root.left);\\n        return sum;   \\n    }\\n    public int sumEvenGrandparent(TreeNode root) {\\n        dfs(root);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nint value(TreeNode root) {\\n\\treturn (root != null)? root.val : 0;\\n}\\n```\n```\\nclass Solution {\\n    int sum;\\n    \\n    // void println(Object o) {System.out.println(o);}\\n    \\n    int value(TreeNode root) {\\n        return (root != null)? root.val: 0;\\n    }\\n    int dfs(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        if (root.val % 2 == 0) {\\n            if (root.left != null) {\\n                sum += value(root.left.left) + value(root.left.right);                \\n            }\\n            if (root.right != null) {\\n                sum += value(root.right.left) + value(root.right.right);\\n            }\\n        }\\n        \\n        dfs(root.right);\\n        dfs(root.left);\\n        return sum;   \\n    }\\n    public int sumEvenGrandparent(TreeNode root) {\\n        dfs(root);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714952,
                "title": "simple-bfs-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  int bfs(TreeNode* root){\\n        if(!root)return 0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int s=0;\\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i=0;i<n;i++){\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                if(temp->left){\\n                    q.push(temp->left);\\n                }\\n                if(temp->right){\\n                    q.push(temp->right);\\n                }\\n                if(temp->val % 2==0){\\n                    if(temp->left){\\n                        if(temp->left->left)s+=temp->left->left->val;\\n                        if(temp->left->right)s+=temp->left->right->val;\\n                    }\\n                    if(temp->right){\\n                        if(temp->right->left)s+=temp->right->left->val;\\n                        if(temp->right->right)s+=temp->right->right->val;\\n                    }\\n                }\\n            }\\n        }\\n        return s;\\n        \\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        return bfs(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  int bfs(TreeNode* root){\\n        if(!root)return 0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int s=0;\\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i=0;i<n;i++){\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                if(temp->left){\\n                    q.push(temp->left);\\n                }\\n                if(temp->right){\\n                    q.push(temp->right);\\n                }\\n                if(temp->val % 2==0){\\n                    if(temp->left){\\n                        if(temp->left->left)s+=temp->left->left->val;\\n                        if(temp->left->right)s+=temp->left->right->val;\\n                    }\\n                    if(temp->right){\\n                        if(temp->right->left)s+=temp->right->left->val;\\n                        if(temp->right->right)s+=temp->right->right->val;\\n                    }\\n                }\\n            }\\n        }\\n        return s;\\n        \\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        return bfs(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349049,
                "title": "java-solution-1-ms-faster-than-98-96",
                "content": "```\\n public int sumEvenGrandparent(TreeNode root) {\\n        return sumEvenGrandparent(root, null, null);\\n    }\\n        \\n    public int sumEvenGrandparent(TreeNode root, TreeNode par, TreeNode grand) {\\n        if(root == null) return 0;\\n            \\n            \\n            int left = sumEvenGrandparent(root.left, root, par);\\n            int right = sumEvenGrandparent(root.right, root, par);\\n            \\n            int sum = left + right;\\n            if(grand != null && grand.val % 2 == 0) {\\n                    sum += root.val;\\n            }\\n            \\n            return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int sumEvenGrandparent(TreeNode root) {\\n        return sumEvenGrandparent(root, null, null);\\n    }\\n        \\n    public int sumEvenGrandparent(TreeNode root, TreeNode par, TreeNode grand) {\\n        if(root == null) return 0;\\n            \\n            \\n            int left = sumEvenGrandparent(root.left, root, par);\\n            int right = sumEvenGrandparent(root.right, root, par);\\n            \\n            int sum = left + right;\\n            if(grand != null && grand.val % 2 == 0) {\\n                    sum += root.val;\\n            }\\n            \\n            return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305340,
                "title": "easy-c-solution",
                "content": "**If you like it then please upvote!**\\n```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n\\t\\n        ios::sync_with_stdio(false);           \\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n\\t\\t\\n        if(root==NULL){\\n            return 0;\\n        }\\n        if(root->left==NULL&&root->right==NULL){\\n            return 0;\\n        }\\n        int a=0 ,b=0 ,c=0 ,d=0;\\n        if(root->val%2==0){\\n            \\n            if(root->left){\\n                if(root->left->left)\\n                    a=root->left->left->val;\\n                if(root->left->right)\\n                    b = root->left->right->val;\\n            }\\n            \\n            if(root->right){\\n                if(root->right->right)\\n                    c=root->right->right->val;\\n                if(root->right->left)\\n                    d=root->right->left->val;\\n            }\\n            \\n            \\n        }\\n        \\n           int x = sumEvenGrandparent(root->left);\\n       \\n           int y = sumEvenGrandparent(root->right);\\n        return x+y+a+b+c+d;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n\\t\\n        ios::sync_with_stdio(false);           \\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n\\t\\t\\n        if(root==NULL){\\n            return 0;\\n        }\\n        if(root->left==NULL&&root->right==NULL){\\n            return 0;\\n        }\\n        int a=0 ,b=0 ,c=0 ,d=0;\\n        if(root->val%2==0){\\n            \\n            if(root->left){\\n                if(root->left->left)\\n                    a=root->left->left->val;\\n                if(root->left->right)\\n                    b = root->left->right->val;\\n            }\\n            \\n            if(root->right){\\n                if(root->right->right)\\n                    c=root->right->right->val;\\n                if(root->right->left)\\n                    d=root->right->left->val;\\n            }\\n            \\n            \\n        }\\n        \\n           int x = sumEvenGrandparent(root->left);\\n       \\n           int y = sumEvenGrandparent(root->right);\\n        return x+y+a+b+c+d;\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 1234681,
                "title": "java-beats-100-solutions-easiest-10-lines-of-code",
                "content": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root== null) return 0;\\n        dfs(root, null, null);\\n        return sum;\\n    }\\n    void dfs(TreeNode root, TreeNode parent, TreeNode grandParent){\\n        if(root == null) return;\\n        if(grandParent != null && grandParent.val %2 == 0){\\n            sum += root.val;\\n        }\\n        dfs(root.left, root, parent);\\n        dfs(root.right, root, parent);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int sum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root== null) return 0;\\n        dfs(root, null, null);\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1142355,
                "title": "simple-java-dfs-beats-99-very-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public int sumEvenGrandparent(TreeNode root) {\\n        return dfs(root, null, null);\\n    }\\n    \\n    private int dfs(TreeNode root, TreeNode parent, TreeNode grandParent) {\\n        \\n        if ( root == null ) return 0;\\n   \\n        int sum = 0;\\n        if ( grandParent != null && grandParent.val%2 == 0 ) sum = root.val;\\n        return sum + dfs(root.left, root, parent) + dfs(root.right, root, parent);\\n    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int sumEvenGrandparent(TreeNode root) {\\n        return dfs(root, null, null);\\n    }\\n    \\n    private int dfs(TreeNode root, TreeNode parent, TreeNode grandParent) {\\n        \\n        if ( root == null ) return 0;\\n   \\n        int sum = 0;\\n        if ( grandParent != null && grandParent.val%2 == 0 ) sum = root.val;\\n        return sum + dfs(root.left, root, parent) + dfs(root.right, root, parent);\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942100,
                "title": "java-fast-dfs-solution-explained-solving-for-grandparents",
                "content": "We are solving this problem from the point of view of the grandparent instead of the grandchildren. So, at every step we will see if the value of the current node is even or not. If it is even, we will call another helper method to evaluate the sum of grandschildren of the current node, if they exist. The value returned by the helper method is added to grandChildrenSum. Helper function to evaluate the sum of grandchildren\\'s values makes use of the fact that each node can have at max 4 grandchildren in a binary tree: left and right children of the left child and left and right children of the right child. So we will check for all the four grandchildren sequentially.\\n<h5>Source Code</h5>\\n\\n```\\nclass Solution {\\n    int grandchildrenSum; //class element to store the sum of eligible grandchildren\\n    public Solution(){\\n        this.grandchildrenSum = 0;\\n    }\\n    public int sumEvenGrandparent(TreeNode root) {\\n        dfs(root);\\n        return grandchildrenSum;\\n    }\\n    \\n    /*We are solving this problem from the point of view of the grandparent\\n    instead of the grandchildren. So, at every step we will see if the value of the\\n    current node is even or not. If it is even, we will call another helper method\\n    to evaluate the sum of grandschildren of the current node, if they exist. The value\\n    returned by the helper method is added to grandChildrenSum.*/\\n    \\n    private void dfs(TreeNode root){\\n        if(root == null){ //do not proceed further if a leave node has been reached\\n            return;\\n        }\\n        if(root.val % 2 == 0){ //if the value of the current node is even\\n            grandchildrenSum += this.evaluateGrandchildrenSum(root); //call the helper function\\n        }\\n        \\n        dfs(root.left); //recursively call the left child\\n        dfs(root.right);//recursively call the right child\\n    }\\n    /*Helper function to evaluate the sum of grandchildren\\'s values. We need to keep in mind\\n    the fact that each node can have at max 4 grandchildren in a binary tree: left and right\\n    children of the left child and left and right children of the right child. So we will check\\n    for all the four grandchildren sequentially. */\\n    private int evaluateGrandchildrenSum(TreeNode root){\\n        int sum = 0;\\n        if(root.left!=null){ \\n            if(root.left.left!=null){   \\n                sum = sum + root.left.left.val;\\n            }\\n            if(root.left.right!=null){\\n                sum = sum + root.left.right.val;\\n            }\\n        }\\n        \\n        if(root.right!=null){\\n            if(root.right.left!=null){\\n                sum = sum + root.right.left.val;\\n            }\\n            if(root.right.right!=null){\\n                sum = sum + root.right.right.val;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int grandchildrenSum; //class element to store the sum of eligible grandchildren\\n    public Solution(){\\n        this.grandchildrenSum = 0;\\n    }\\n    public int sumEvenGrandparent(TreeNode root) {\\n        dfs(root);\\n        return grandchildrenSum;\\n    }\\n    \\n    /*We are solving this problem from the point of view of the grandparent\\n    instead of the grandchildren. So, at every step we will see if the value of the\\n    current node is even or not. If it is even, we will call another helper method\\n    to evaluate the sum of grandschildren of the current node, if they exist. The value\\n    returned by the helper method is added to grandChildrenSum.*/\\n    \\n    private void dfs(TreeNode root){\\n        if(root == null){ //do not proceed further if a leave node has been reached\\n            return;\\n        }\\n        if(root.val % 2 == 0){ //if the value of the current node is even\\n            grandchildrenSum += this.evaluateGrandchildrenSum(root); //call the helper function\\n        }\\n        \\n        dfs(root.left); //recursively call the left child\\n        dfs(root.right);//recursively call the right child\\n    }\\n    /*Helper function to evaluate the sum of grandchildren\\'s values. We need to keep in mind\\n    the fact that each node can have at max 4 grandchildren in a binary tree: left and right\\n    children of the left child and left and right children of the right child. So we will check\\n    for all the four grandchildren sequentially. */\\n    private int evaluateGrandchildrenSum(TreeNode root){\\n        int sum = 0;\\n        if(root.left!=null){ \\n            if(root.left.left!=null){   \\n                sum = sum + root.left.left.val;\\n            }\\n            if(root.left.right!=null){\\n                sum = sum + root.left.right.val;\\n            }\\n        }\\n        \\n        if(root.right!=null){\\n            if(root.right.left!=null){\\n                sum = sum + root.right.left.val;\\n            }\\n            if(root.right.right!=null){\\n                sum = sum + root.right.right.val;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863003,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        ans = 0\\n        if not root:\\n            return ans\\n        q = collections.deque([root])\\n        while q:\\n            node = q.popleft()\\n            if node.left:\\n                q.append(node.left)\\n                if node.val % 2 == 0:\\n                    ans = ans + node.left.left.val if node.left.left else ans\\n                    ans = ans + node.left.right.val if node.left.right else ans\\n            if node.right:\\n                q.append(node.right)\\n                if node.val % 2 == 0:\\n                    ans = ans + node.right.left.val if node.right.left else ans\\n                    ans = ans + node.right.right.val if node.right.right else ans\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        ans = 0\\n        if not root:\\n            return ans\\n        q = collections.deque([root])\\n        while q:\\n            node = q.popleft()\\n            if node.left:\\n                q.append(node.left)\\n                if node.val % 2 == 0:\\n                    ans = ans + node.left.left.val if node.left.left else ans\\n                    ans = ans + node.left.right.val if node.left.right else ans\\n            if node.right:\\n                q.append(node.right)\\n                if node.val % 2 == 0:\\n                    ans = ans + node.right.left.val if node.right.left else ans\\n                    ans = ans + node.right.right.val if node.right.right else ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858844,
                "title": "simple-python-recursive-solution",
                "content": "```\\ndef sum_even_gp(root, parent, grandparent):\\n\\tif root is None:\\n\\t\\treturn 0\\n\\n\\tto_add = 0\\n\\n\\tif grandparent and (grandparent.val % 2 == 0):\\n\\t\\tto_add = root.val \\n\\n\\treturn to_add + \\n\\t\\tsum_even_gp(root.left, root, parent) + \\n\\t\\tsum_even_gp(root.right, root, parent)\\n```  \\n\\nThis can be called as: \\n\\n```\\nsum_even_gp(root, None, None)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\ndef sum_even_gp(root, parent, grandparent):\\n\\tif root is None:\\n\\t\\treturn 0\\n\\n\\tto_add = 0\\n\\n\\tif grandparent and (grandparent.val % 2 == 0):\\n\\t\\tto_add = root.val \\n\\n\\treturn to_add + \\n\\t\\tsum_even_gp(root.left, root, parent) + \\n\\t\\tsum_even_gp(root.right, root, parent)\\n```\n```\\nsum_even_gp(root, None, None)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 752479,
                "title": "c-beats-99-6",
                "content": "```\\nint sumEvenGrandparent(TreeNode* root,int p = -1,int gp = -1) {\\n        if(!root)\\n            return 0;\\n        return (gp%2==0)*(root->val) + sumEvenGrandparent(root->left,root->val,p) + sumEvenGrandparent(root->right,root->val,p);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint sumEvenGrandparent(TreeNode* root,int p = -1,int gp = -1) {\\n        if(!root)\\n            return 0;\\n        return (gp%2==0)*(root->val) + sumEvenGrandparent(root->left,root->val,p) + sumEvenGrandparent(root->right,root->val,p);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3116788,
                "title": "simple-java-solution-level-order-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public int sumEvenGrandparent(TreeNode root) {\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int sum=0;\\n        while(q.size()>0){\\n            TreeNode cur = q.remove();\\n\\n            if(cur.val%2==0){\\n                if(cur.right!=null && cur.right.left!=null){\\n                    sum += cur.right.left.val;\\n                }\\n                if(cur.right!=null && cur.right.right!=null){\\n                     sum += cur.right.right.val;\\n                }\\n                if(cur.left!=null && cur.left.left!=null){\\n                     sum += cur.left.left.val;\\n                }\\n                if(cur.left!=null && cur.left.right!=null){\\n                    sum += cur.left.right.val;\\n                }\\n               \\n            }\\n            if(cur.right!=null){\\n                q.add(cur.right);\\n            }\\n            if(cur.left!=null){\\n                q.add(cur.left);\\n            }\\n\\n\\n        }\\n        return sum;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public int sumEvenGrandparent(TreeNode root) {\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int sum=0;\\n        while(q.size()>0){\\n            TreeNode cur = q.remove();\\n\\n            if(cur.val%2==0){\\n                if(cur.right!=null && cur.right.left!=null){\\n                    sum += cur.right.left.val;\\n                }\\n                if(cur.right!=null && cur.right.right!=null){\\n                     sum += cur.right.right.val;\\n                }\\n                if(cur.left!=null && cur.left.left!=null){\\n                     sum += cur.left.left.val;\\n                }\\n                if(cur.left!=null && cur.left.right!=null){\\n                    sum += cur.left.right.val;\\n                }\\n               \\n            }\\n            if(cur.right!=null){\\n                q.add(cur.right);\\n            }\\n            if(cur.left!=null){\\n                q.add(cur.left);\\n            }\\n\\n\\n        }\\n        return sum;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051360,
                "title": "tree-preorder-traversal-beginner-friendly-c-code-o-n-time",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root)return 0;\\n        if(root->val%2==0){\\n            if(root->left){\\n                if(root->left->left)sum+=root->left->left->val;\\n                if(root->left->right)sum+=root->left->right->val;\\n            }\\n            if(root->right){\\n                if(root->right->left)sum+=root->right->left->val;\\n                if(root->right->right)sum+=root->right->right->val;\\n            }\\n        }\\n        sumEvenGrandparent(root->left);\\n        sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum=0;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root)return 0;\\n        if(root->val%2==0){\\n            if(root->left){\\n                if(root->left->left)sum+=root->left->left->val;\\n                if(root->left->right)sum+=root->left->right->val;\\n            }\\n            if(root->right){\\n                if(root->right->left)sum+=root->right->left->val;\\n                if(root->right->right)sum+=root->right->right->val;\\n            }\\n        }\\n        sumEvenGrandparent(root->left);\\n        sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996391,
                "title": "c-dfs-easiest-new-approach",
                "content": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\\n\\n---\\n# Code\\n```\\nclass Solution {\\n    int dfs(TreeNode* root, int flag1, int flag2){\\n        if(root == NULL)\\n            return 0;\\n\\n        int sum = 0;\\n        if(flag2 == 1)\\n            sum = root->val;\\n\\n        flag2 = flag1;\\n        if(root->val % 2 == 0)\\n            flag1 = 1;\\n        else\\n            flag1 = 0;\\n\\n        sum += dfs(root->left, flag1, flag2);\\n        sum += dfs(root->right, flag1, flag2);\\n\\n        return sum;\\n    }\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        return dfs(root, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\n```\\nclass Solution {\\n    int dfs(TreeNode* root, int flag1, int flag2){\\n        if(root == NULL)\\n            return 0;\\n\\n        int sum = 0;\\n        if(flag2 == 1)\\n            sum = root->val;\\n\\n        flag2 = flag1;\\n        if(root->val % 2 == 0)\\n            flag1 = 1;\\n        else\\n            flag1 = 0;\\n\\n        sum += dfs(root->left, flag1, flag2);\\n        sum += dfs(root->right, flag1, flag2);\\n\\n        return sum;\\n    }\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        return dfs(root, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809212,
                "title": "easiest-solution-in-python-step-by-step-explanation",
                "content": "# Approach\\n**Step 1:** Create a variable **sum** which will store the sum of all the nodes which are having their grandparents wih even value.\\n\\n**Step 2:** Check if the root node their is their, if it is then move ahead else return 0.\\n\\n**Step 3:** Now check if the current node value is even, and if it is even then it means we have to addup the values of grandchildren of that current node into our sum variable. So for that we will check each for the each possible grandchildren of that current node. And as we know that there can be only 4 grandchildren possible for each node, so we will check for each of them one by one and if they are present then we will add up their value to our sum.\\n\\n**Step 4:** We have to recursively call each and every node using left and right of each node. At last we will return value of sum. \\n\\n#### PLEASE UPVOTE\\u2B06 IF THIS SOLUTION HELPS YOU SOMEHOW\\uD83C\\uDF1F\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    sum=0\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        if root.val%2==0:\\n            if root.left and root.left.left:\\n                self.sum+=root.left.left.val\\n            if root.left and root.left.right:\\n                self.sum+=root.left.right.val\\n            if root.right and root.right.left:\\n                self.sum+=root.right.left.val\\n            if root.right and root.right.right:\\n                self.sum+=root.right.right.val\\n        self.sumEvenGrandparent(root.left)\\n        self.sumEvenGrandparent(root.right)\\n        return self.sum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    sum=0\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        if root.val%2==0:\\n            if root.left and root.left.left:\\n                self.sum+=root.left.left.val\\n            if root.left and root.left.right:\\n                self.sum+=root.left.right.val\\n            if root.right and root.right.left:\\n                self.sum+=root.right.left.val\\n            if root.right and root.right.right:\\n                self.sum+=root.right.right.val\\n        self.sumEvenGrandparent(root.left)\\n        self.sumEvenGrandparent(root.right)\\n        return self.sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533474,
                "title": "c-dfs-easyiundrsatnding",
                "content": "```\\nclass Solution {\\npublic:\\n    int sm =0 ;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        dfs(root, NULL, NULL);\\n        return sm;\\n    }\\n     void dfs(TreeNode* current, TreeNode* parent, TreeNode* grandParent) {\\n        if (current == NULL) return;\\n        if (grandParent != NULL && grandParent->val % 2 == 0) \\n            sm += current->val;\\n        dfs(current->left, current, parent);\\n        dfs(current->right, current, parent);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sm =0 ;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        dfs(root, NULL, NULL);\\n        return sm;\\n    }\\n     void dfs(TreeNode* current, TreeNode* parent, TreeNode* grandParent) {\\n        if (current == NULL) return;\\n        if (grandParent != NULL && grandParent->val % 2 == 0) \\n            sm += current->val;\\n        dfs(current->left, current, parent);\\n        dfs(current->right, current, parent);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302295,
                "title": "easy-js-dfs-solution",
                "content": "```\\nvar sumEvenGrandparent = function(root) {\\n    var res=0\\n    function helper(root,p,gp){\\n        if(!root) return;\\n        if(gp%2==0) res+=root.val\\n        helper(root.left,root.val,p)\\n        helper(root.right,root.val,p)\\n    }\\n    helper(root,1,1)\\n    return res\\n};\\n```",
                "solutionTags": [
                    "Oracle",
                    "JavaScript"
                ],
                "code": "```\\nvar sumEvenGrandparent = function(root) {\\n    var res=0\\n    function helper(root,p,gp){\\n        if(!root) return;\\n        if(gp%2==0) res+=root.val\\n        helper(root.left,root.val,p)\\n        helper(root.right,root.val,p)\\n    }\\n    helper(root,1,1)\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1232522,
                "title": "simple-python-solution-beats-90",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.sum = 0\\n\\n    def trav(self, root, parent, grand_parent):\\n        if grand_parent and grand_parent % 2 == 0: self.sum += root.val\\n        if root.left: self.trav(root.left, root.val, parent)\\n        if root.right: self.trav(root.right, root.val, parent)\\n\\n\\n    def sumEvenGrandparent(self, root):\\n        self.trav(root, None, None)\\n        return self.sum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.sum = 0\\n\\n    def trav(self, root, parent, grand_parent):\\n        if grand_parent and grand_parent % 2 == 0: self.sum += root.val\\n        if root.left: self.trav(root.left, root.val, parent)\\n        if root.right: self.trav(root.right, root.val, parent)\\n\\n\\n    def sumEvenGrandparent(self, root):\\n        self.trav(root, None, None)\\n        return self.sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222922,
                "title": "c-beginner-friendly-code",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n```\\nclass Solution {\\npublic:\\n     int ans=0;\\n     \\n     void help(TreeNode* root ){\\n         if(root==NULL)return;\\n         \\n         if(root->val%2==0){\\n             if(root->left && root->left->left)ans+=root->left->left->val;\\n             if(root->left && root->left->right)ans+=root->left->right->val;\\n             if(root->right && root->right->left)ans+=root->right->left->val;\\n             if(root->right && root->right->right)ans+=root->right->right->val;\\n         }\\n         \\n         help(root->left);\\n         help(root->right);\\n     }\\n     \\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root==NULL)return 0;\\n        help(root);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n     int ans=0;\\n     \\n     void help(TreeNode* root ){\\n         if(root==NULL)return;\\n         \\n         if(root->val%2==0){\\n             if(root->left && root->left->left)ans+=root->left->left->val;\\n             if(root->left && root->left->right)ans+=root->left->right->val;\\n             if(root->right && root->right->left)ans+=root->right->left->val;\\n             if(root->right && root->right->right)ans+=root->right->right->val;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 989581,
                "title": "simple-java-solution",
                "content": "```\\n int ans = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        helper(root);\\n        return ans;\\n    }\\n    \\n    private void helper(TreeNode root) {\\n        if(root != null){\\n            if(root.val % 2 == 0) {\\n                // check left child and grand child\\n                if(root.left != null){\\n                    if(root.left.left != null) {\\n                        ans += root.left.left.val;\\n                    }\\n                    if(root.left.right != null) {\\n                        ans += root.left.right.val;\\n                    }\\n                }\\n                \\n                if(root.right != null) {\\n                    if(root.right.left != null) {\\n                        ans += root.right.left.val;\\n                    }\\n                    \\n                    if(root.right.right != null) {\\n                        ans += root.right.right.val;\\n                    }\\n                }\\n            }\\n            helper(root.left);\\n            helper(root.right);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int ans = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        helper(root);\\n        return ans;\\n    }\\n    \\n    private void helper(TreeNode root) {\\n        if(root != null){\\n            if(root.val % 2 == 0) {\\n                // check left child and grand child\\n                if(root.left != null){\\n                    if(root.left.left != null) {\\n                        ans += root.left.left.val;\\n                    }\\n                    if(root.left.right != null) {\\n                        ans += root.left.right.val;\\n                    }\\n                }\\n                \\n                if(root.right != null) {\\n                    if(root.right.left != null) {\\n                        ans += root.right.left.val;\\n                    }\\n                    \\n                    if(root.right.right != null) {\\n                        ans += root.right.right.val;\\n                    }\\n                }\\n            }\\n            helper(root.left);\\n            helper(root.right);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961674,
                "title": "easy-recursive-backtracking-solution-with-comments",
                "content": "```\\nvar sumEvenGrandparent = function(root) {\\n    let sum = 0;\\n\\n    // Traverse tree recursively and store the values for\\n    // each path of the tree inside arr.\\n    const traverse = (node, level, arr) => {\\n        // Base Case\\n        if(!node) return;\\n        \\n        // Grandparents don\\'t exist for trees with less than 2 levels\\n        if(level > 1) {\\n            // If the grandparent (2 levels above current) is even\\n            if(arr[level-2] % 2 === 0) {\\n                sum += node.val;\\n            }\\n        }\\n\\n        arr.push(node.val);\\n        traverse(node.left, level + 1, arr)\\n        traverse(node.right, level + 1, arr);\\n        \\n        //Backtracking\\n        arr.pop();\\n    }\\n    \\n    traverse(root, 0, []);\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar sumEvenGrandparent = function(root) {\\n    let sum = 0;\\n\\n    // Traverse tree recursively and store the values for\\n    // each path of the tree inside arr.\\n    const traverse = (node, level, arr) => {\\n        // Base Case\\n        if(!node) return;\\n        \\n        // Grandparents don\\'t exist for trees with less than 2 levels\\n        if(level > 1) {\\n            // If the grandparent (2 levels above current) is even\\n            if(arr[level-2] % 2 === 0) {\\n                sum += node.val;\\n            }\\n        }\\n\\n        arr.push(node.val);\\n        traverse(node.left, level + 1, arr)\\n        traverse(node.right, level + 1, arr);\\n        \\n        //Backtracking\\n        arr.pop();\\n    }\\n    \\n    traverse(root, 0, []);\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 772091,
                "title": "java-simple-recursive-solution",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null)return 0;\\n        sum(root,null,null);\\n        return count;\\n    }\\n    \\n    public void sum(TreeNode root,TreeNode parent, TreeNode grandParent){\\n        if(root == null)return ;\\n        \\n        if(grandParent != null && grandParent.val %2 == 0){\\n            count += root.val;\\n        }\\n        sum(root.left,root,parent);\\n        sum(root.right,root,parent);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int count = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null)return 0;\\n        sum(root,null,null);\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 565995,
                "title": "python-solution-with-bfs",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        queue = [root]\\n        ans = 0\\n        while queue:\\n            node = queue.pop(0)\\n            if node.left:\\n                queue.append(node.left)\\n            if node.right:\\n                queue.append(node.right)\\n            if node.val % 2 == 0:\\n                if node.left:\\n                    if node.left.left:\\n                        ans += node.left.left.val\\n                    if node.left.right:\\n                        ans += node.left.right.val\\n                if node.right:\\n                    if node.right.left:\\n                        ans += node.right.left.val\\n                    if node.right.right:\\n                        ans += node.right.right.val\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        queue = [root]\\n        ans = 0\\n        while queue:\\n            node = queue.pop(0)\\n            if node.left:\\n                queue.append(node.left)\\n            if node.right:\\n                queue.append(node.right)\\n            if node.val % 2 == 0:\\n                if node.left:\\n                    if node.left.left:\\n                        ans += node.left.left.val\\n                    if node.left.right:\\n                        ans += node.left.right.val\\n                if node.right:\\n                    if node.right.left:\\n                        ans += node.right.left.val\\n                    if node.right.right:\\n                        ans += node.right.right.val\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530329,
                "title": "python3-clean-solution",
                "content": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        return self.dfs(root,False,False)\\n        \\n    def dfs(self,root,gpEven, pEven):\\n        if not root:\\n            return 0\\n        isEven = (root.val % 2 == 0)\\n        return self.dfs(root.left,pEven,isEven) + self.dfs(root.right, pEven,isEven) + (root.val if gpEven else 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        return self.dfs(root,False,False)\\n        \\n    def dfs(self,root,gpEven, pEven):\\n        if not root:\\n            return 0\\n        isEven = (root.val % 2 == 0)\\n        return self.dfs(root.left,pEven,isEven) + self.dfs(root.right, pEven,isEven) + (root.val if gpEven else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507304,
                "title": "c-readable-non-fancy-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        int sum = 0;\\n        helper(root, NULL, sum);\\n        return sum;\\n    }\\n    \\n    void helper(TreeNode* root, TreeNode* parent, int& sum) {\\n        if (root->left == NULL && root->right == NULL)\\n            return;\\n        \\n        if (parent && parent->val % 2 == 0) {\\n                sum += root->left ? root->left->val : 0;\\n                sum += root->right ? root->right->val : 0;                \\n        }\\n        \\n        if (root->left)\\n            helper(root->left, root, sum);\\n    \\n        if (root->right)\\n            helper(root->right, root, sum);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        int sum = 0;\\n        helper(root, NULL, sum);\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 505896,
                "title": "3-recursion-based-iterated-solutions-python",
                "content": "# Solution 1\\nFirst idea is to pass the list of parents to each recursive call then check of grand-parent by index:\\n\\n```Python\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode, parents: list=[]) -> int:\\n        node, s = root, 0\\n        if node:\\n            if len(parents) > 1:\\n                if parents[-2] % 2 == 0:\\n                    s += node.val\\n            s += self.sumEvenGrandparent(node.left, parents + [node.val])\\n            s += self.sumEvenGrandparent(node.right, parents + [node.val])\\n        return s\\n```\\n\\n# Solution 2\\nHowever, we only need to keep track of the parent `p` and grandparent `gp` at each node. Let\\'s initialize them for the `root` to be `1` (Odd to not effect sum calculations):\\n\\n```Python\\nclass Solution:\\n    def sumEvenGrandparent(self, root, p=1, gp=1) -> int:\\n        node, s = root, 0\\n        if node:\\n            if gp % 2 == 0:\\n                s += node.val\\n            s += self.sumEvenGrandparent(node.left, node.val, p)\\n            s += self.sumEvenGrandparent(node.right, node.val, p)\\n        return s\\n```\\n\\n# Solution 3\\nFinally, we can create a compact version of the final solution by simply calculating `s` in the last return:\\n\\n```Python\\nclass Solution:\\n    def sumEvenGrandparent(self, root, p=1, gp=1) -> int:\\n        return self.sumEvenGrandparent(root.left, root.val, p) \\\\\\n                + self.sumEvenGrandparent(root.right, root.val, p) \\\\\\n                + root.val * (gp % 2 == 0) if root else 0\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Recursion"
                ],
                "code": "```Python\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode, parents: list=[]) -> int:\\n        node, s = root, 0\\n        if node:\\n            if len(parents) > 1:\\n                if parents[-2] % 2 == 0:\\n                    s += node.val\\n            s += self.sumEvenGrandparent(node.left, parents + [node.val])\\n            s += self.sumEvenGrandparent(node.right, parents + [node.val])\\n        return s\\n```\n```Python\\nclass Solution:\\n    def sumEvenGrandparent(self, root, p=1, gp=1) -> int:\\n        node, s = root, 0\\n        if node:\\n            if gp % 2 == 0:\\n                s += node.val\\n            s += self.sumEvenGrandparent(node.left, node.val, p)\\n            s += self.sumEvenGrandparent(node.right, node.val, p)\\n        return s\\n```\n```Python\\nclass Solution:\\n    def sumEvenGrandparent(self, root, p=1, gp=1) -> int:\\n        return self.sumEvenGrandparent(root.left, root.val, p) \\\\\\n                + self.sumEvenGrandparent(root.right, root.val, p) \\\\\\n                + root.val * (gp % 2 == 0) if root else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486812,
                "title": "ruby-solution",
                "content": "```\\ndef sum_even_grandparent(root)\\n    queue = []\\n    queue << [root, nil]\\n    queue << [root.left, nil] if root.left\\n    queue << [root.right, nil] if root.right\\n    \\n    result = 0\\n    while (!queue.empty?)\\n        n, grand_n = queue.shift\\n        if grand_n && (grand_n.val % 2 == 0)\\n            result += n.val\\n        end\\n        \\n        if n.left\\n            if n.left.left\\n                queue << [n.left.left, n]\\n            end\\n            \\n            if n.left.right\\n                queue << [n.left.right, n]\\n            end\\n        end\\n        \\n        if n.right\\n            if n.right.left\\n                queue << [n.right.left, n]\\n            end\\n            \\n            if n.right.right\\n                queue << [n.right.right, n]\\n            end\\n        end\\n    end\\n    \\n    return result\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef sum_even_grandparent(root)\\n    queue = []\\n    queue << [root, nil]\\n    queue << [root.left, nil] if root.left\\n    queue << [root.right, nil] if root.right\\n    \\n    result = 0\\n    while (!queue.empty?)\\n        n, grand_n = queue.shift\\n        if grand_n && (grand_n.val % 2 == 0)\\n            result += n.val\\n        end\\n        \\n        if n.left\\n            if n.left.left\\n                queue << [n.left.left, n]\\n            end\\n            \\n            if n.left.right\\n                queue << [n.left.right, n]\\n            end\\n        end\\n        \\n        if n.right\\n            if n.right.left\\n                queue << [n.right.left, n]\\n            end\\n            \\n            if n.right.right\\n                queue << [n.right.right, n]\\n            end\\n        end\\n    end\\n    \\n    return result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 477233,
                "title": "c-bfs-with-comments",
                "content": "```\\nint sumEvenGrandparent(TreeNode* root) {\\n        \\n        // Keep track of queue of nodes\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        unordered_map<TreeNode*, bool> par;\\n        \\n        int sum = 0;\\n        \\n        while (!q.empty()) {\\n            // get nodes for current level\\n            int l = q.size();\\n            \\n            // check all nodes of current level\\n            for (int i = 0; i < l; ++i) {\\n                // get a node\\n                TreeNode *node = q.front();\\n                q.pop();\\n                \\n                // check if node value is even\\n                bool even = node->val % 2 == 0;\\n                \\n                // check if the node has children\\n                // get left child of a node\\n                if (node->left) {\\n                    // if node has left child save information about a parent\\n                    // of this node\\n                    par[node->left] = even;\\n                    q.push(node->left);\\n                    \\n                    // check if parent of parent of left child is even\\n                    // add this child value to sum\\n                    if (par[node]) {\\n                        sum += node->left->val;\\n                    }\\n                }\\n                \\n                // get right child of a node\\n                if (node->right) {\\n                    // if node has right child save information about a parent\\n                    // of this node\\n                    par[node->right] = even;\\n                    q.push(node->right);\\n                    \\n                    // check if parent of parent of right child is even\\n                    // add this child value to sum\\n                    if (par[node]) {\\n                        sum += node->right->val;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint sumEvenGrandparent(TreeNode* root) {\\n        \\n        // Keep track of queue of nodes\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        unordered_map<TreeNode*, bool> par;\\n        \\n        int sum = 0;\\n        \\n        while (!q.empty()) {\\n            // get nodes for current level\\n            int l = q.size();\\n            \\n            // check all nodes of current level\\n            for (int i = 0; i < l; ++i) {\\n                // get a node\\n                TreeNode *node = q.front();\\n                q.pop();\\n                \\n                // check if node value is even\\n                bool even = node->val % 2 == 0;\\n                \\n                // check if the node has children\\n                // get left child of a node\\n                if (node->left) {\\n                    // if node has left child save information about a parent\\n                    // of this node\\n                    par[node->left] = even;\\n                    q.push(node->left);\\n                    \\n                    // check if parent of parent of left child is even\\n                    // add this child value to sum\\n                    if (par[node]) {\\n                        sum += node->left->val;\\n                    }\\n                }\\n                \\n                // get right child of a node\\n                if (node->right) {\\n                    // if node has right child save information about a parent\\n                    // of this node\\n                    par[node->right] = even;\\n                    q.push(node->right);\\n                    \\n                    // check if parent of parent of right child is even\\n                    // add this child value to sum\\n                    if (par[node]) {\\n                        sum += node->right->val;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018070,
                "title": "simple-dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\nint sum=0;\\npublic:\\n\\n    void helper(TreeNode* root,int p){\\n        if(root==NULL){return;}\\n        if(root->left){\\n            if(p%2==0){sum+=root->left->val;}\\n            helper(root->left,root->val);\\n        }\\n        if(root->right){\\n            if(p%2==0){sum+=root->right->val;}\\n            helper(root->right,root->val);\\n        }\\n    }\\n\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root==NULL){return 0;}\\n        helper(root->left,root->val);\\n        helper(root->right,root->val);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nint sum=0;\\npublic:\\n\\n    void helper(TreeNode* root,int p){\\n        if(root==NULL){return;}\\n        if(root->left){\\n            if(p%2==0){sum+=root->left->val;}\\n            helper(root->left,root->val);\\n        }\\n        if(root->right){\\n            if(p%2==0){sum+=root->right->val;}\\n            helper(root->right,root->val);\\n        }\\n    }\\n\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root==NULL){return 0;}\\n        helper(root->left,root->val);\\n        helper(root->right,root->val);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941769,
                "title": "c-clean-and-modular-recursive-code",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int getGrandChildSum(TreeNode* root){\\n        int sum = 0;\\n        TreeNode* leftChild = root->left;\\n        TreeNode* rightChild = root->right;\\n        if(leftChild) //make sure to avoid NULL pointer exception\\n        {if(leftChild->left) sum += leftChild->left->val;\\n        if(leftChild->right) sum += leftChild->right->val;}\\n\\n        if(rightChild)\\n        {if(rightChild->left) sum += rightChild->left->val;\\n        if(rightChild->right) sum += rightChild->right->val;}\\n\\n        return sum;\\n\\n    }\\n    void traverse(TreeNode* root, int &ans){\\n        if(!root) return; //return when NULL\\n        if(root->val % 2 == 0) ans += getGrandChildSum(root);\\n        //check if root value is even and update ans\\n\\n        traverse(root->left, ans); //recurse left subtree\\n        traverse(root->right, ans); // recurse right subtree\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        int ans = 0;\\n        traverse(root, ans); //ans is pass by reference\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int getGrandChildSum(TreeNode* root){\\n        int sum = 0;\\n        TreeNode* leftChild = root->left;\\n        TreeNode* rightChild = root->right;\\n        if(leftChild) //make sure to avoid NULL pointer exception\\n        {if(leftChild->left) sum += leftChild->left->val;\\n        if(leftChild->right) sum += leftChild->right->val;}\\n\\n        if(rightChild)\\n        {if(rightChild->left) sum += rightChild->left->val;\\n        if(rightChild->right) sum += rightChild->right->val;}\\n\\n        return sum;\\n\\n    }\\n    void traverse(TreeNode* root, int &ans){\\n        if(!root) return; //return when NULL\\n        if(root->val % 2 == 0) ans += getGrandChildSum(root);\\n        //check if root value is even and update ans\\n\\n        traverse(root->left, ans); //recurse left subtree\\n        traverse(root->right, ans); // recurse right subtree\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        int ans = 0;\\n        traverse(root, ans); //ans is pass by reference\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741793,
                "title": "grand-parent-sum-easiest-approach-beats-100-java",
                "content": "# Intuition\\nYou just have to check the value of root, if it is even, then check the nullity of son and grandson, and add the values to the sum accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\n    int sum = 0;\\n    public int sumEvenGrandparent(TreeNode root){\\n        sumVal(root);\\n        return sum;\\n    }\\n\\n    public void sumVal(TreeNode root){\\n        if(root==null) return;\\n        if(root.val%2==0){\\n            if(root.left!=null && root.left.left!=null) sum += root.left.left.val;\\n            if(root.left!=null && root.left.right!=null) sum += root.left.right.val;\\n            if(root.right!=null && root.right.left!=null) sum += root.right.left.val;\\n            if(root.right!=null && root.right.right!=null) sum += root.right.right.val;\\n        }\\n        sumVal(root.left);\\n        sumVal(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    int sum = 0;\\n    public int sumEvenGrandparent(TreeNode root){\\n        sumVal(root);\\n        return sum;\\n    }\\n\\n    public void sumVal(TreeNode root){\\n        if(root==null) return;\\n        if(root.val%2==0){\\n            if(root.left!=null && root.left.left!=null) sum += root.left.left.val;\\n            if(root.left!=null && root.left.right!=null) sum += root.left.right.val;\\n            if(root.right!=null && root.right.left!=null) sum += root.right.left.val;\\n            if(root.right!=null && root.right.right!=null) sum += root.right.right.val;\\n        }\\n        sumVal(root.left);\\n        sumVal(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667399,
                "title": "javascript-simple-3-line-dfs",
                "content": "\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumEvenGrandparent = function(root) {\\n    function dfs(node, parent, grandparent){\\n        if(!node) return 0;\\n        const cur = grandparent && grandparent.val % 2 === 0 ? node.val : 0;\\n        return cur + dfs(node.left, node, parent) + dfs(node.right, node, parent);\\n    }\\n    return dfs(root, null, null)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumEvenGrandparent = function(root) {\\n    function dfs(node, parent, grandparent){\\n        if(!node) return 0;\\n        const cur = grandparent && grandparent.val % 2 === 0 ? node.val : 0;\\n        return cur + dfs(node.left, node, parent) + dfs(node.right, node, parent);\\n    }\\n    return dfs(root, null, null)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3034193,
                "title": "intuitive-approach-explained-in-details",
                "content": "# Intuition\\nTraverse the given tree and with every even node that we come across, we need to add its granchildren to a globally declared variable ```sum```.\\n\\n# Approach\\nTraverse the tree in preorder fashion but everytime you come across an even node, send its children to a function which will extract the children of the nodes sent (i.e., the grandchildren of the even node). Add their values to the ```sum``` variable.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void helper(TreeNode* root) {\\n        if (!root) \\n            return;\\n        \\n        if (root->val %2 == 0) {\\n            getChild(root->left);\\n            getChild(root->right);\\n        }\\n\\n        helper(root->left);\\n        helper(root->right);\\n    }\\n    void getChild(TreeNode* root) {\\n        if (!root)\\n            return;\\n        \\n        add(root->left);\\n        add(root->right);\\n    }\\n    void add(TreeNode* root) {\\n        if(!root)\\n            return;\\n        \\n        sum += root->val;\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```sum```\n```sum```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void helper(TreeNode* root) {\\n        if (!root) \\n            return;\\n        \\n        if (root->val %2 == 0) {\\n            getChild(root->left);\\n            getChild(root->right);\\n        }\\n\\n        helper(root->left);\\n        helper(root->right);\\n    }\\n    void getChild(TreeNode* root) {\\n        if (!root)\\n            return;\\n        \\n        add(root->left);\\n        add(root->right);\\n    }\\n    void add(TreeNode* root) {\\n        if(!root)\\n            return;\\n        \\n        sum += root->val;\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957159,
                "title": "two-solutions-bfs-dfs",
                "content": "First Solution **BFS**  ***(using queue and unorderedmap)***\\n*TC: **O(N)***\\n*SC: **O(N)***\\n\\n\\n```\\nint sumEvenGrandparent(TreeNode* root) {\\n        if(!root) return 0;\\n        int sum=0;\\n        queue<TreeNode*>q;\\n        unordered_map<TreeNode*, TreeNode*> parent;\\n        parent[root]=NULL;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* x = q.front();\\n            q.pop();\\n            TreeNode* gp=parent[parent[x]];\\n            if(gp && (gp->val) %2==0) sum+=(x->val);\\n            if(x->left) \\n            {\\n                q.push(x->left);\\n                parent[x->left]=x;\\n            }\\n            if(x->right) \\n            {\\n                q.push(x->right);\\n                parent[x->right]=x;\\n            }\\n        }\\n        return sum;\\n    }\\n```\\n\\nSecond Solution **DFS**  ***(only recursive stack space)***\\n*TC: **O(N)***\\n*SC: **O(N)***\\n\\n```\\n    int sum=0;\\n\\n    void dfs(TreeNode* root) {\\n        if(!root) return;\\n        if(!root->left && !root->right)\\n            return;\\n        if((root->val)%2==0)  {\\n            TreeNode* temp;\\n            temp=root->left;\\n            if(temp && temp->left)        sum+=temp->left->val;\\n            if(temp && temp->right)     sum+=temp->right->val;\\n            temp=root->right;\\n            if(temp && temp->left)        sum+=temp->left->val;\\n            if(temp && temp->right)      sum+=temp->right->val;\\n        }\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n\\t\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root) return 0;\\n        dfs(root);\\n        return sum;\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint sumEvenGrandparent(TreeNode* root) {\\n        if(!root) return 0;\\n        int sum=0;\\n        queue<TreeNode*>q;\\n        unordered_map<TreeNode*, TreeNode*> parent;\\n        parent[root]=NULL;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* x = q.front();\\n            q.pop();\\n            TreeNode* gp=parent[parent[x]];\\n            if(gp && (gp->val) %2==0) sum+=(x->val);\\n            if(x->left) \\n            {\\n                q.push(x->left);\\n                parent[x->left]=x;\\n            }\\n            if(x->right) \\n            {\\n                q.push(x->right);\\n                parent[x->right]=x;\\n            }\\n        }\\n        return sum;\\n    }\\n```\n```\\n    int sum=0;\\n\\n    void dfs(TreeNode* root) {\\n        if(!root) return;\\n        if(!root->left && !root->right)\\n            return;\\n        if((root->val)%2==0)  {\\n            TreeNode* temp;\\n            temp=root->left;\\n            if(temp && temp->left)        sum+=temp->left->val;\\n            if(temp && temp->right)     sum+=temp->right->val;\\n            temp=root->right;\\n            if(temp && temp->left)        sum+=temp->left->val;\\n            if(temp && temp->right)      sum+=temp->right->val;\\n        }\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n\\t\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root) return 0;\\n        dfs(root);\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887454,
                "title": "java-clearest-solution-so-far-100-faster",
                "content": "# Without global variable\\n```\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        int sum = 0;\\n        return DFS(root, null, null, sum);\\n    }\\n\\n    private int DFS(TreeNode node, TreeNode parent, TreeNode grandParent, int sum) {\\n        if(node == null)\\n            return sum;\\n        if (grandParent != null && grandParent.val % 2 == 0)\\n            sum += node.val;\\n        grandParent = parent;  parent = node;\\n        sum = DFS(node.left, parent, grandParent, sum);\\n        sum = DFS(node.right, parent, grandParent, sum);\\n        return sum;\\n    }\\n}\\n```\\n# With gloable variable\\n```\\nclass Solution {\\n    int sum =0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        return DFS(root, null, null);\\n    }\\n\\n    private int DFS(TreeNode node, TreeNode parent, TreeNode grandParent) {\\n        if(node == null)\\n            return sum;\\n        if (grandParent != null && grandParent.val % 2 == 0)\\n            sum += node.val;\\n        grandParent = parent;  parent = node;\\n        sum = DFS(node.left, parent, grandParent);\\n        sum = DFS(node.right, parent, grandParent);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        int sum = 0;\\n        return DFS(root, null, null, sum);\\n    }\\n\\n    private int DFS(TreeNode node, TreeNode parent, TreeNode grandParent, int sum) {\\n        if(node == null)\\n            return sum;\\n        if (grandParent != null && grandParent.val % 2 == 0)\\n            sum += node.val;\\n        grandParent = parent;  parent = node;\\n        sum = DFS(node.left, parent, grandParent, sum);\\n        sum = DFS(node.right, parent, grandParent, sum);\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int sum =0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        return DFS(root, null, null);\\n    }\\n\\n    private int DFS(TreeNode node, TreeNode parent, TreeNode grandParent) {\\n        if(node == null)\\n            return sum;\\n        if (grandParent != null && grandParent.val % 2 == 0)\\n            sum += node.val;\\n        grandParent = parent;  parent = node;\\n        sum = DFS(node.left, parent, grandParent);\\n        sum = DFS(node.right, parent, grandParent);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817882,
                "title": "basic-recursion-dfs-tc-o-n-sc-0-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum=0;  //global variable\\n    int sumEvenGrandparent(TreeNode* root) {\\n        \\n      if(!root) return 0;\\n       \\n        if(root->val%2==0)  // if grandparent is even\\n        {\\n           if(root->left)     // when root->left is present  , add values of grandchildren to sum if present\\n             {\\n              if(root->left->left) sum+=root->left->left->val;  \\n              if(root->left->right) sum+=root->left->right->val;\\n             }\\n           if(root->right)     // when root->right is present  , add values of grandchildren to sum if present\\n             {\\n              if(root->right->left) sum+=root->right->left->val;\\n              if(root->right->right) sum+=root->right->right->val;\\n             }\\n        }\\n        sumEvenGrandparent(root->left);  //traverse to left subtree\\n        sumEvenGrandparent(root->right); //traverse to right subtree\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;  //global variable\\n    int sumEvenGrandparent(TreeNode* root) {\\n        \\n      if(!root) return 0;\\n       \\n        if(root->val%2==0)  // if grandparent is even\\n        {\\n           if(root->left)     // when root->left is present  , add values of grandchildren to sum if present\\n             {\\n              if(root->left->left) sum+=root->left->left->val;  \\n              if(root->left->right) sum+=root->left->right->val;\\n             }\\n           if(root->right)     // when root->right is present  , add values of grandchildren to sum if present\\n             {\\n              if(root->right->left) sum+=root->right->left->val;\\n              if(root->right->right) sum+=root->right->right->val;\\n             }\\n        }\\n        sumEvenGrandparent(root->left);  //traverse to left subtree\\n        sumEvenGrandparent(root->right); //traverse to right subtree\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799782,
                "title": "java-2ms-solution-using-dfs-in-o-height-of-tree",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) \\n    {\\n        if(root==null)\\n            return 0;\\n        if(root.left==null && root.right==null)\\n            return 0;\\n        int res=0;\\n        if(root.val%2==0)\\n        {\\n            if(root.left!=null && root.left.left!=null )\\n                res+=root.left.left.val;\\n            if(root.left!=null && root.left.right!=null )\\n                res+=root.left.right.val;\\n            if(root.right!=null && root.right.left!=null )\\n                res+=root.right.left.val;\\n            if(root.right!=null && root.right.right!=null )\\n                res+=root.right.right.val;\\n        }\\n        res+=sumEvenGrandparent(root.left);\\n        res+=sumEvenGrandparent(root.right);\\n        return res;\\n        \\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) \\n    {\\n        if(root==null)\\n            return 0;\\n        if(root.left==null && root.right==null)\\n            return 0;\\n        int res=0;\\n        if(root.val%2==0)\\n        {\\n            if(root.left!=null && root.left.left!=null )\\n                res+=root.left.left.val;\\n            if(root.left!=null && root.left.right!=null )\\n                res+=root.left.right.val;\\n            if(root.right!=null && root.right.left!=null )\\n                res+=root.right.left.val;\\n            if(root.right!=null && root.right.right!=null )\\n                res+=root.right.right.val;\\n        }\\n        res+=sumEvenGrandparent(root.left);\\n        res+=sumEvenGrandparent(root.right);\\n        return res;\\n        \\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752026,
                "title": "java-fast-beats-90-solutions-easy-recursive-approach-with-comments",
                "content": "## **UPVOTE IF YOU LIKE THE SOLUTION **\\n\\n---\\nIDEA: JUST MAINTAIN TWO POINTERS AT A NODE AND IT\\'S IMMEDIATE PARENT.\\nTHE NODE\\'S CHILDREN WILL BE PARENT\\'S GRANDCHILD. SO, WE GET ALL THE THINGS WE NEED. NEXT IS JUST TRAVERSAL. FOLLOW THE COMMMENTS FOR MORE.\\n\\n```\\nclass Solution {\\n    //stores final sum\\n    int sum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        //parent of root node is null, so just pass null as grandparent\\n        traverse(root, null);\\n        return sum;\\n    }\\n    public void traverse(TreeNode parent, TreeNode grandParent){\\n        if(parent==null) return;\\n        /*  if we have a grandparent and it is even \\n    then add up values of left grandchild and right grandchild with the help of parent node*/\\n        if(grandParent!=null && grandParent.val%2==0){\\n            if(parent.left!=null) sum+= parent.left.val;\\n            if(parent.right!=null) sum+= parent.right.val;\\n        }\\n        //recursively do the same for left and right subtree\\n        traverse(parent.left, parent);\\n        traverse(parent.right, parent);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    //stores final sum\\n    int sum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        //parent of root node is null, so just pass null as grandparent\\n        traverse(root, null);\\n        return sum;\\n    }\\n    public void traverse(TreeNode parent, TreeNode grandParent){\\n        if(parent==null) return;\\n        /*  if we have a grandparent and it is even \\n    then add up values of left grandchild and right grandchild with the help of parent node*/\\n        if(grandParent!=null && grandParent.val%2==0){\\n            if(parent.left!=null) sum+= parent.left.val;\\n            if(parent.right!=null) sum+= parent.right.val;\\n        }\\n        //recursively do the same for left and right subtree\\n        traverse(parent.left, parent);\\n        traverse(parent.right, parent);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732359,
                "title": "recursive-time-complexity-o-n",
                "content": "Please upvote if you like the solution .\\n\\n```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        def helper(grandparent, parent, node):\\n            if not node:return\\n            if grandparent and grandparent.val%2 == 0:self.ans += node.val\\n            helper(parent, node, node.left)\\n            helper(parent, node, node.right)\\n        \\n        self.ans = 0\\n        helper(None, None, root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        def helper(grandparent, parent, node):\\n            if not node:return\\n            if grandparent and grandparent.val%2 == 0:self.ans += node.val\\n            helper(parent, node, node.left)\\n            helper(parent, node, node.right)\\n        \\n        self.ans = 0\\n        helper(None, None, root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697931,
                "title": "c-easy-to-understand-code-with-explanation",
                "content": "We need to keep track of three node in order to solve this problem that is `current`, `parent` and `grandParent`. While calling the `dfs` function we don\\'t know the `parent` and `grandParent` of the `current` node, so we pass `NULL`. In every step of the dfs the `current` will take `current->left` or `current->right`, `parent` will take `current` and `grandParent` will take `parent`. We also have to check whether we hit a `grandParent` whose value is a multiple of `2`. If that turns out to be true in some `dfs` call then we need to add the value of that node in our `sum` variable. \\n\\nNote: I have used `current` in place of `node` for better understanding. \\n\\n```\\nclass Solution {\\n    int sum = 0;\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        dfs(root, NULL, NULL);\\n        return sum;\\n    }\\n    \\n    void dfs(TreeNode* root, TreeNode* parent, TreeNode* grandParent){\\n        if(root == NULL) return;\\n        if(grandParent != NULL && grandParent->val % 2 == 0)\\n            sum+=root->val;\\n        dfs(root->left, root, parent);\\n        dfs(root->right, root, parent);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        dfs(root, NULL, NULL);\\n        return sum;\\n    }\\n    \\n    void dfs(TreeNode* root, TreeNode* parent, TreeNode* grandParent){\\n        if(root == NULL) return;\\n        if(grandParent != NULL && grandParent->val % 2 == 0)\\n            sum+=root->val;\\n        dfs(root->left, root, parent);\\n        dfs(root->right, root, parent);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626714,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    int count=0;\\n    public void traverse(TreeNode root,TreeNode parent,TreeNode grandparent){\\n        if(root==null)\\n            return;\\n        if(grandparent!=null && grandparent.val%2==0)\\n            count+=root.val;\\n        traverse(root.left,root,parent);\\n        traverse(root.right,root,parent);\\n        \\n    }\\n    public int sumEvenGrandparent(TreeNode root) {\\n        count=0;\\n        traverse(root,null,null);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int count=0;\\n    public void traverse(TreeNode root,TreeNode parent,TreeNode grandparent){\\n        if(root==null)\\n            return;\\n        if(grandparent!=null && grandparent.val%2==0)\\n            count+=root.val;\\n        traverse(root.left,root,parent);\\n        traverse(root.right,root,parent);\\n        \\n    }\\n    public int sumEvenGrandparent(TreeNode root) {\\n        count=0;\\n        traverse(root,null,null);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598314,
                "title": "java-dfs-100",
                "content": "```\\nclass Solution {\\n    int sum=0;\\n    private void dfs(TreeNode root, TreeNode parent, TreeNode grandparent){\\n        if(root==null) return;\\n        if(grandparent!=null){\\n            if(grandparent.val % 2 == 0){\\n                sum += root.val;\\n            }\\n        }\\n        dfs(root.left, root, parent);\\n        dfs(root.right, root, parent);\\n    }\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root, null, null);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    private void dfs(TreeNode root, TreeNode parent, TreeNode grandparent){\\n        if(root==null) return;\\n        if(grandparent!=null){\\n            if(grandparent.val % 2 == 0){\\n                sum += root.val;\\n            }\\n        }\\n        dfs(root.left, root, parent);\\n        dfs(root.right, root, parent);\\n    }\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root, null, null);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572475,
                "title": "simple-easy-c-solution-faster-than-93",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void findSum(TreeNode* root, TreeNode* parent, TreeNode* grandParent){\\n        if(!root){\\n            return;\\n        }\\n        if(grandParent){\\n            if(grandParent->val % 2 == 0){\\n                sum += root->val;\\n            }\\n        }\\n        findSum(root->left, root, parent);\\n        findSum(root->right, root, parent);\\n    }\\n    \\n    int sumEvenGrandparent(TreeNode* root) {\\n        findSum(root, NULL, NULL);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void findSum(TreeNode* root, TreeNode* parent, TreeNode* grandParent){\\n        if(!root){\\n            return;\\n        }\\n        if(grandParent){\\n            if(grandParent->val % 2 == 0){\\n                sum += root->val;\\n            }\\n        }\\n        findSum(root->left, root, parent);\\n        findSum(root->right, root, parent);\\n    }\\n    \\n    int sumEvenGrandparent(TreeNode* root) {\\n        findSum(root, NULL, NULL);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470038,
                "title": "java-recursive-solution-87-faster-dfs",
                "content": "1. Calculating sum of grandchildren if the current node\\'s value is even number, meanwhile checking for null.\\n2. Recursively applying this logic to children.\\n```\\nclass Solution {\\n    static int sumGlobal;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        sumGlobal = 0;\\n        countGrandChildren(root);\\n        return sumGlobal;\\n    }\\n    \\n    private void countGrandChildren(TreeNode node) {\\n        if (node == null || (node.left == null && node.right == null)) return;\\n        if (node.val % 2 == 0) {\\n            if (node.left != null) {\\n                if (node.left.left != null) {\\n                    sumGlobal += node.left.left.val;\\n                }\\n                if (node.left.right != null) {\\n                    sumGlobal += node.left.right.val;\\n                }\\n            }\\n            if (node.right != null) {\\n                if (node.right.left != null) {\\n                    sumGlobal += node.right.left.val;\\n                }\\n                if (node.right.right != null) {\\n                    sumGlobal += node.right.right.val;\\n                }\\n            }\\n        }\\n        countGrandChildren(node.left);\\n        countGrandChildren(node.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static int sumGlobal;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        sumGlobal = 0;\\n        countGrandChildren(root);\\n        return sumGlobal;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2249102,
                "title": "c-time-99-70-space-96-88-intutive-solution",
                "content": "![image](https://assets.leetcode.com/users/images/cebce168-fd84-4494-ad94-0f814b2f2f34_1657170587.0146947.jpeg)\\n\\n# 2 Approach Given\\n**APPROACH 1**\\nNaive Approach \\n1. Check whether the root ->val is even or not\\n2. Then run a function ( g(TreeNode * root) - in my case) which will calculate the grandchildren sum if they exists\\n3. return sum   \\n```\\nclass Solution {\\npublic:\\n    void g(TreeNode * root,int &sum,int k)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        if(k==1)\\n        {\\n            cout<<\"root ->val : \"<<root->val<<\"  \";\\n            sum+=root->val;\\n            return;\\n        }\\n        g(root->left,sum,k-1);\\n        g(root->right,sum,k-1);\\n    }\\n    int f(TreeNode * root,int &sum)\\n    {\\n        if(!root)\\n        {\\n            return 0;\\n        }\\n        if(root->val%2==0)\\n        {\\n            g(root,sum,3);\\n        }\\n        f(root->left,sum);\\n        f(root->right,sum);\\n        return sum;\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        int sum = 0;\\n        return f(root,sum);\\n        \\n    }\\n};\\n```\\n**APPROACH 2**\\n1.There are majorly 4 cases to focus upon when root->val is even\\n*  Left root is present and left->left is present\\n*  Left root is present and left->right is present\\n*  Right root is present and right->left is present\\n*  Right root is present and right->right is present\\n2. Handle each case seprately and maintain the sum  \\n3. return sum\\n```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root)\\n        {\\n            return 0;\\n        }\\n        int sum = 0;\\n        if(root->val%2==0)\\n        {\\n            if(root->left !=NULL and root->left->left!=NULL)\\n            {\\n                sum+=root->left->left->val;\\n            }\\n            if(root->left !=NULL and root->left->right!=NULL)\\n            {\\n                sum+=root->left->right->val;\\n            }\\n            if(root->right !=NULL and root->right->left!=NULL)\\n            {\\n                sum+=root->right->left->val;\\n            } \\n            if(root->right !=NULL and root->right->right!=NULL)\\n            {\\n                sum+=root->right->right->val;\\n            }            \\n        }\\n        sum+=sumEvenGrandparent(root->left); \\n        sum+=sumEvenGrandparent(root->right);\\n        return sum;    \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void g(TreeNode * root,int &sum,int k)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        if(k==1)\\n        {\\n            cout<<\"root ->val : \"<<root->val<<\"  \";\\n            sum+=root->val;\\n            return;\\n        }\\n        g(root->left,sum,k-1);\\n        g(root->right,sum,k-1);\\n    }\\n    int f(TreeNode * root,int &sum)\\n    {\\n        if(!root)\\n        {\\n            return 0;\\n        }\\n        if(root->val%2==0)\\n        {\\n            g(root,sum,3);\\n        }\\n        f(root->left,sum);\\n        f(root->right,sum);\\n        return sum;\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        int sum = 0;\\n        return f(root,sum);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root)\\n        {\\n            return 0;\\n        }\\n        int sum = 0;\\n        if(root->val%2==0)\\n        {\\n            if(root->left !=NULL and root->left->left!=NULL)\\n            {\\n                sum+=root->left->left->val;\\n            }\\n            if(root->left !=NULL and root->left->right!=NULL)\\n            {\\n                sum+=root->left->right->val;\\n            }\\n            if(root->right !=NULL and root->right->left!=NULL)\\n            {\\n                sum+=root->right->left->val;\\n            } \\n            if(root->right !=NULL and root->right->right!=NULL)\\n            {\\n                sum+=root->right->right->val;\\n            }            \\n        }\\n        sum+=sumEvenGrandparent(root->left); \\n        sum+=sumEvenGrandparent(root->right);\\n        return sum;    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2097013,
                "title": "java-easy-understanding-recursive",
                "content": "```\\nclass Solution {\\n    int sum = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        solve(root,-1,-1);\\n        return sum;\\n    }\\n    \\n    public void solve(TreeNode root,int parent,int grand){\\n        if(root == null)\\n            return;\\n        if(grand%2 == 0){\\n            sum += root.val;\\n        }\\n        \\n        solve(root.left,root.val,parent);\\n        solve(root.right,root.val,parent);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        solve(root,-1,-1);\\n        return sum;\\n    }\\n    \\n    public void solve(TreeNode root,int parent,int grand){\\n        if(root == null)\\n            return;\\n        if(grand%2 == 0){\\n            sum += root.val;\\n        }\\n        \\n        solve(root.left,root.val,parent);\\n        solve(root.right,root.val,parent);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085065,
                "title": "python-iterative-stack-easy-to-understand-o-n-time-and-o-n-space",
                "content": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        root.parent = None\\n        root.grandparent = None\\n        result = 0\\n        stack = [root]\\n        \\n        while len(stack):\\n            node = stack.pop()\\n            if node.left:\\n                node.left.parent = node\\n                node.left.grandparent = node.parent\\n                stack.append(node.left)\\n            if node.right:\\n                node.right.parent = node\\n                node.right.grandparent = node.parent\\n                stack.append(node.right)\\n            \\n            if node.grandparent and node.grandparent.val % 2 == 0:\\n                result += node.val\\n        \\n        return result\\n```\\n\\nThough there are other one-liner recursive solutions which might have better space complexity but they seem to have poor readability or difficult to understand.",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        root.parent = None\\n        root.grandparent = None\\n        result = 0\\n        stack = [root]\\n        \\n        while len(stack):\\n            node = stack.pop()\\n            if node.left:\\n                node.left.parent = node\\n                node.left.grandparent = node.parent\\n                stack.append(node.left)\\n            if node.right:\\n                node.right.parent = node\\n                node.right.grandparent = node.parent\\n                stack.append(node.right)\\n            \\n            if node.grandparent and node.grandparent.val % 2 == 0:\\n                result += node.val\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077139,
                "title": "easy-to-understand-dfs-c-soln",
                "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  int sum=0;\\n  \\n  void solve(TreeNode* root)\\n  {\\n    if(root==NULL)\\n      return;\\n    \\n    if(root->val%2==0)\\n    {\\n        if(root->left)\\n        {\\n          if(root->left->left)\\n            sum+=root->left->left->val;\\n          if(root->left->right)\\n            sum+=root->left->right->val;\\n        }\\n\\n         if(root->right)\\n        {\\n          if(root->right->left)\\n            sum+=root->right->left->val;\\n          if(root->right->right)\\n            sum+=root->right->right->val;\\n        }\\n    }\\n    \\n    solve(root->right);\\n    solve(root->left);\\n    \\n  }\\n  \\n    int sumEvenGrandparent(TreeNode* root) {\\n     solve(root);\\n      return sum;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n  int sum=0;\\n  \\n  void solve(TreeNode* root)\\n  {\\n    if(root==NULL)\\n      return;\\n    \\n    if(root->val%2==0)\\n    {\\n        if(root->left)\\n        {\\n          if(root->left->left)\\n            sum+=root->left->left->val;\\n          if(root->left->right)\\n            sum+=root->left->right->val;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2066520,
                "title": "c-recursive-short-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root,TreeNode *parent=NULL) \\n    {\\n        if(!root)return 0;\\n        int left=sumEvenGrandparent(root->left,root);\\n        int right=sumEvenGrandparent(root->right,root);\\n        int sum=0;\\n        if(parent&&parent->val%2==0)\\n        {            \\n            if(root->left)sum+=root->left->val;\\n            if(root->right)sum+= root->right->val;\\n        }\\n        return left+right+sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root,TreeNode *parent=NULL) \\n    {\\n        if(!root)return 0;\\n        int left=sumEvenGrandparent(root->left,root);\\n        int right=sumEvenGrandparent(root->right,root);\\n        int sum=0;\\n        if(parent&&parent->val%2==0)\\n        {            \\n            if(root->left)sum+=root->left->val;\\n            if(root->right)sum+= root->right->val;\\n        }\\n        return left+right+sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809108,
                "title": "sum-of-nodes-with-even-valued-grandparent-fastest-and-simple-solution-in-java",
                "content": "class Solution {\\n  public int sumEvenGrandparent(TreeNode root) {\\n    return dfs(root, 1, 1); // parent and grandparent are odd at first\\n  }\\n\\n  private int dfs(TreeNode root, int p, int gp) {\\n    if (root == null)\\n      return 0;\\n    return dfs(root.left, root.val, p) +\\n           dfs(root.right, root.val, p) +\\n           (gp % 2 == 0 ? root.val : 0);\\n  }\\n}\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n  public int sumEvenGrandparent(TreeNode root) {\\n    return dfs(root, 1, 1); // parent and grandparent are odd at first\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1763985,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        ans = 0\\n        def utility(current: TreeNode, parent=-1, grandparent=-1):\\n            nonlocal ans\\n            if current is None:\\n                return 0\\n            if grandparent % 2 == 0:\\n                ans += current.val\\n            utility(current.left, current.val, parent)\\n            utility(current.right, current.val, parent)\\n        if root.left:\\n            utility(root.left, root.val)\\n        if root.right:\\n            utility(root.right, root.val)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        ans = 0\\n        def utility(current: TreeNode, parent=-1, grandparent=-1):\\n            nonlocal ans\\n            if current is None:\\n                return 0\\n            if grandparent % 2 == 0:\\n                ans += current.val\\n            utility(current.left, current.val, parent)\\n            utility(current.right, current.val, parent)\\n        if root.left:\\n            utility(root.left, root.val)\\n        if root.right:\\n            utility(root.right, root.val)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741502,
                "title": "c-easy-beginner-friendly-dfs-solution",
                "content": "Easy Recursion solution:\\n\\nALGORITHM: We have to check whether the node is divisible by 2 or not.If yes,then we send the node to `check` function so as to return the sum of the node\\'s grandchildren.Using recursion we apply DFS to traverse through the whole tree!\\n\\nNote: I used global variable in it.\\nSOLUTION:\\n```\\nclass Solution {\\npublic:\\n    int check(TreeNode* root){\\n        int count=0;\\n        if(root==NULL)\\n            return 0;\\n        if(root->left!=NULL)\\n            count+=root->left->val;\\n        if(root->right!=NULL)\\n            count+=root->right->val;\\n        return count;\\n    }\\n    int sum=0;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        if(root->val%2==0&&(root->left!=NULL||root->right!=NULL))\\n        {\\n            sum+=check(root->left);\\n            sum+=check(root->right);\\n        }\\n        int left=sumEvenGrandparent(root->left);\\n        int right=sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n```\\nDo upvote it\\uD83D\\uDC4D\\nCheers!",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(TreeNode* root){\\n        int count=0;\\n        if(root==NULL)\\n            return 0;\\n        if(root->left!=NULL)\\n            count+=root->left->val;\\n        if(root->right!=NULL)\\n            count+=root->right->val;\\n        return count;\\n    }\\n    int sum=0;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        if(root->val%2==0&&(root->left!=NULL||root->right!=NULL))\\n        {\\n            sum+=check(root->left);\\n            sum+=check(root->right);\\n        }\\n        int left=sumEvenGrandparent(root->left);\\n        int right=sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637824,
                "title": "c-tc-90-better-sc-100-better",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint sum=0;\\n\\t\\tvoid inorder(TreeNode *root,int p,int gp){\\n\\t\\t\\tif(root){\\n\\t\\t\\t\\tif(gp%2==0)\\n\\t\\t\\t\\t\\tsum+=root->val;\\n\\t\\t\\t\\tinorder(root->left,root->val,p);\\n\\t\\t\\t\\tinorder(root->right,root->val,p);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint sumEvenGrandparent(TreeNode* root) {\\n\\t\\t\\tinorder(root,1,1);\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t**Note**-p  for parents and gp for grandparents \\uD83D\\uDE02",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint sum=0;\\n\\t\\tvoid inorder(TreeNode *root,int p,int gp){\\n\\t\\t\\tif(root){\\n\\t\\t\\t\\tif(gp%2==0)\\n\\t\\t\\t\\t\\tsum+=root->val;\\n\\t\\t\\t\\tinorder(root->left,root->val,p);\\n\\t\\t\\t\\tinorder(root->right,root->val,p);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1607713,
                "title": "java-1ms-faster-than-100-of-java-submissions-super-easy-commented-understandable",
                "content": "class Solution {\\n    int sum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root.val%2==0&&(root.left!=null||root.right!=null))//Checking for the current node if it is divisible by 2 and then checking its 4 grandparents\\n        {\\n            if(root.left!=null&&root.left.left!=null)\\n            {\\n                sum+=root.left.left.val;\\n            }\\n            if(root.left!=null&&root.left.right!=null)\\n            {\\n                sum+=root.left.right.val;\\n            }\\n            if(root.right!=null&&root.right.left!=null)\\n            {\\n                sum+=root.right.left.val;\\n            }\\n            if(root.right!=null&&root.right.right!=null)\\n            {\\n                sum+=root.right.right.val;\\n            }\\n            \\n        }\\n        if(root.left!=null)\\n        {\\n        sumEvenGrandparent(root.left);//For left Subtree\\n        }\\n        if(root.right!=null)\\n        {\\n            sumEvenGrandparent(root.right);//For right Subtree\\n        }\\n            \\n        return sum;\\n        \\n    }\\n}\\n\\nDo upvote if you like the solution",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int sum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root.val%2==0&&(root.left!=null||root.right!=null))//Checking for the current node if it is divisible by 2 and then checking its 4 grandparents\\n        {\\n            if(root.left!=null&&root.left.left!=null)\\n            {\\n                sum+=root.left.left.val;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1543749,
                "title": "c-better-than-your-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        //check node with even-valued grandparent add grandchildren value in sum if exist\\n        if(root->val % 2 == 0){\\n            if(root->left)\\n            if(root->left->left)\\n                sum += root->left->left->val;\\n            \\n            if(root->left)\\n            if(root->left->right)\\n                sum += root->left->right->val;\\n            \\n            if(root->right)\\n            if(root->right->left)\\n                sum += root->right->left->val;\\n            \\n            if(root->right)\\n            if(root->right->right)\\n                sum += root->right->right->val; \\n        }\\n        sumEvenGrandparent(root->left);\\n        sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        //check node with even-valued grandparent add grandchildren value in sum if exist\\n        if(root->val % 2 == 0){\\n            if(root->left)\\n            if(root->left->left)\\n                sum += root->left->left->val;\\n            \\n            if(root->left)\\n            if(root->left->right)\\n                sum += root->left->right->val;\\n            \\n            if(root->right)\\n            if(root->right->left)\\n                sum += root->right->left->val;\\n            \\n            if(root->right)\\n            if(root->right->right)\\n                sum += root->right->right->val; \\n        }\\n        sumEvenGrandparent(root->left);\\n        sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504770,
                "title": "c-using-queue-look-once-you-can-easily-understand-whole-code",
                "content": "int sumEvenGrandparent(TreeNode* root) {\\n     \\n        int count = 0;\\n        queue<TreeNode*>q;       \\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            \\n            if(q.front() -> val % 2 == 0){\\n                \\n                TreeNode* temp = q.front() -> left;\\n                if(temp != nullptr){\\n                    if(temp -> left != nullptr){ count += temp -> left -> val;}\\n                    \\n                    if(temp -> right != nullptr){count += temp -> right -> val;}\\n                }\\n                temp = q.front()->right;\\n                if(temp  != nullptr){\\n                    if(temp -> left != nullptr){count += temp -> left -> val;}\\n                    if(temp -> right != nullptr){count += temp -> right -> val;}\\n                }\\n            }\\n            if(q.front() -> left != nullptr){\\n                q.push(q.front() -> left);}\\n            \\n            if(q.front() -> right != nullptr){\\n                q.push(q.front() -> right);}\\n            \\n            q.pop();\\n        }\\n\\n        return count;    \\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "int sumEvenGrandparent(TreeNode* root) {\\n     \\n        int count = 0;\\n        queue<TreeNode*>q;       \\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            \\n            if(q.front() -> val % 2 == 0){\\n                \\n                TreeNode* temp = q.front() -> left;\\n                if(temp != nullptr){\\n                    if(temp -> left != nullptr){ count += temp -> left -> val;}\\n                    \\n                    if(temp -> right != nullptr){count += temp -> right -> val;}\\n                }\\n                temp = q.front()->right;\\n                if(temp  != nullptr){\\n                    if(temp -> left != nullptr){count += temp -> left -> val;}\\n                    if(temp -> right != nullptr){count += temp -> right -> val;}\\n                }\\n            }\\n            if(q.front() -> left != nullptr){\\n                q.push(q.front() -> left);}\\n            \\n            if(q.front() -> right != nullptr){\\n                q.push(q.front() -> right);}\\n            \\n            q.pop();\\n        }\\n\\n        return count;    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1452746,
                "title": "python-beats-94-dfs-simple",
                "content": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        return self.dfs(root,None,None)\\n    \\n    def dfs(self,node,parent,grandParent):\\n        if not node:\\n            return 0\\n        add=0\\n        if grandParent and grandParent.val%2==0:\\n            add=node.val\\n        return add + self.dfs(node.left,node,parent) + self.dfs(node.right,node,parent)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        return self.dfs(root,None,None)\\n    \\n    def dfs(self,node,parent,grandParent):\\n        if not node:\\n            return 0\\n        add=0\\n        if grandParent and grandParent.val%2==0:\\n            add=node.val\\n        return add + self.dfs(node.left,node,parent) + self.dfs(node.right,node,parent)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320945,
                "title": "simple-dfs-or-recursive-solution-with-and-without-static-variable-and-interview-tip-java-c",
                "content": "**Small Tip**\\n*it is never good to use static varialble in any interview.\\nAn interviewer will instanatly reject your logic if you are using a static variable\\nso try to avoid it until nothing left to do.*\\n# With Using Static Variable\\n**Java**\\n```\\nclass Solution {\\n    int sum = 0;\\n    private void helper(TreeNode root) {\\n        if (root == null) return;\\n        if ((root.val & 1) == 0) {\\n            if (root.left != null) {\\n                if (root.left.left != null) sum += root.left.left.val;\\n                if (root.left.right != null) sum += root.left.right.val;\\n            }\\n            if (root.right != null) {\\n                if (root.right.left != null) sum += root.right.left.val;\\n                if (root.right.right != null) sum += root.right.right.val;\\n            }\\n        }\\n        helper(root.left);\\n        helper(root.right);\\n    }\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if (root == null) return 0;\\n        helper(root);\\n        return sum;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void helper(TreeNode* node) {\\n        if (node == NULL) return;\\n        if (!(node->val & 1)) {\\n            if (node->left != NULL) {\\n                if (node->left->left != NULL) sum += node->left->left->val;\\n                if (node->left->right != NULL) sum += node->left->right->val;\\n            }\\n            if (node->right != NULL) {\\n                if (node->right->left != NULL) sum += node->right->left->val;\\n                if (node->right->right != NULL) sum += node->right->right->val;\\n            }\\n        }\\n        helper(node->left);\\n        helper(node->right);\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```\\n# Without Using Static Variable\\n**Java**\\n```\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if  ((root.val & 1) == 0) {\\n            if (root.left != null) {\\n                if (root.left.left != null) sum += root.left.left.val;\\n                if (root.left.right != null) sum += root.left.right.val;\\n            }\\n            if (root.right != null) {\\n                if (root.right.left != null) sum += root.right.left.val;\\n                if (root.right.right != null) sum += root.right.right.val;\\n            }\\n        }\\n        sum += sumEvenGrandparent(root.left);\\n        sum += sumEvenGrandparent(root.right);\\n        return sum;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        int sum = 0;\\n        if  ((root->val & 1) == 0) {\\n            if (root->left != NULL) {\\n                if (root->left->left != NULL) sum += root->left->left->val;\\n                if (root->left->right != NULL) sum += root->left->right->val;\\n            }\\n            if (root->right != NULL) {\\n                if (root->right->left != NULL) sum += root->right->left->val;\\n                if (root->right->right != NULL) sum += root->right->right->val;\\n            }\\n        }\\n        sum += sumEvenGrandparent(root->left);\\n        sum += sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me**\\nHappy Coding :)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    private void helper(TreeNode root) {\\n        if (root == null) return;\\n        if ((root.val & 1) == 0) {\\n            if (root.left != null) {\\n                if (root.left.left != null) sum += root.left.left.val;\\n                if (root.left.right != null) sum += root.left.right.val;\\n            }\\n            if (root.right != null) {\\n                if (root.right.left != null) sum += root.right.left.val;\\n                if (root.right.right != null) sum += root.right.right.val;\\n            }\\n        }\\n        helper(root.left);\\n        helper(root.right);\\n    }\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if (root == null) return 0;\\n        helper(root);\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void helper(TreeNode* node) {\\n        if (node == NULL) return;\\n        if (!(node->val & 1)) {\\n            if (node->left != NULL) {\\n                if (node->left->left != NULL) sum += node->left->left->val;\\n                if (node->left->right != NULL) sum += node->left->right->val;\\n            }\\n            if (node->right != NULL) {\\n                if (node->right->left != NULL) sum += node->right->left->val;\\n                if (node->right->right != NULL) sum += node->right->right->val;\\n            }\\n        }\\n        helper(node->left);\\n        helper(node->right);\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if (root == null) return 0;\\n        int sum = 0;\\n        if  ((root.val & 1) == 0) {\\n            if (root.left != null) {\\n                if (root.left.left != null) sum += root.left.left.val;\\n                if (root.left.right != null) sum += root.left.right.val;\\n            }\\n            if (root.right != null) {\\n                if (root.right.left != null) sum += root.right.left.val;\\n                if (root.right.right != null) sum += root.right.right.val;\\n            }\\n        }\\n        sum += sumEvenGrandparent(root.left);\\n        sum += sumEvenGrandparent(root.right);\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        int sum = 0;\\n        if  ((root->val & 1) == 0) {\\n            if (root->left != NULL) {\\n                if (root->left->left != NULL) sum += root->left->left->val;\\n                if (root->left->right != NULL) sum += root->left->right->val;\\n            }\\n            if (root->right != NULL) {\\n                if (root->right->left != NULL) sum += root->right->left->val;\\n                if (root->right->right != NULL) sum += root->right->right->val;\\n            }\\n        }\\n        sum += sumEvenGrandparent(root->left);\\n        sum += sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315685,
                "title": "java-recursive-solution-easy-to-understand-1ms-99-5",
                "content": "For a better understanding of the solution we can divide our solution into two parts:\\n\\n1 - In the first part, we are **traversing Inorder** in our tree and finding if there exists any even node.\\n\\n2 - After finding any even node we will search for its grandchildren, we must understand that **the node which are the grandchildren of this even node will always be two down (1 down for children and 2 down for grandchildren)**. To get the track of our moving down we are using cnt and are incrementing it by 1 as we are moving down.\\nOnce we get to know that we have moved 2 down we are adding the sum of the node.\\n\\n```\\nclass Solution {\\n    int sum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root==null)                                       // Part 1 of our solution\\n\\t\\t{                                                                   \\n            return 0;                                                  \\n        }\\n        sumEvenGrandparent(root.left);        // Traversing Inorder\\n        if(root.val%2==0)\\n        {\\n            sum = sum+getSum(0,root);       // Getting the sum of grandchildren once we get even node\\n        }\\n        sumEvenGrandparent(root.right);\\n        return sum;\\n    }\\n\\tpublic int getSum(int cnt, TreeNode root)\\n    {                                                         // Part 2 of our solution\\n        if(root==null || cnt>2)\\n        {\\n            return 0;\\n        }\\n        int ls = getSum(cnt+1,root.left);  // Incrementing Count by 1 as we are moving down\\n        int rs = getSum(cnt+1,root.right);\\n        int ts = ls+rs;\\n        if(cnt==2)                                   // Calculating the sum once our cnt becomes 2.\\n        {\\n            ts=ts+root.val;\\n        }\\n        return ts;                                   // Returning sum\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root==null)                                       // Part 1 of our solution\\n\\t\\t{                                                                   \\n            return 0;                                                  \\n        }\\n        sumEvenGrandparent(root.left);        // Traversing Inorder\\n        if(root.val%2==0)\\n        {\\n            sum = sum+getSum(0,root);       // Getting the sum of grandchildren once we get even node\\n        }\\n        sumEvenGrandparent(root.right);\\n        return sum;\\n    }\\n\\tpublic int getSum(int cnt, TreeNode root)\\n    {                                                         // Part 2 of our solution\\n        if(root==null || cnt>2)\\n        {\\n            return 0;\\n        }\\n        int ls = getSum(cnt+1,root.left);  // Incrementing Count by 1 as we are moving down\\n        int rs = getSum(cnt+1,root.right);\\n        int ts = ls+rs;\\n        if(cnt==2)                                   // Calculating the sum once our cnt becomes 2.\\n        {\\n            ts=ts+root.val;\\n        }\\n        return ts;                                   // Returning sum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301006,
                "title": "90-faster",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void solve(TreeNode* root)\\n    {\\n       if(root == NULL)\\n       {\\n           return;\\n       }\\n       if(root->val % 2 == 0)\\n       {\\n           if(root -> left != NULL)\\n           {\\n                if(root -> left -> left != NULL) \\n                {\\n                    sum += root -> left -> left -> val;\\n                }\\n                if(root -> left -> right != NULL)\\n                {\\n                    sum += root -> left -> right -> val;\\n                }\\n            }\\n            if(root -> right != NULL)\\n            {\\n                if(root -> right -> left != NULL) \\n                {\\n                    sum += root -> right -> left -> val;\\n                }\\n                if(root -> right -> right != NULL)\\n                {\\n                    sum += root -> right -> right -> val;\\n                }\\n            }\\n        }\\n        solve(root -> left);\\n        solve(root -> right);\\n    }\\n\\t\\n    int sumEvenGrandparent(TreeNode* root) {\\n        solve(root);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void solve(TreeNode* root)\\n    {\\n       if(root == NULL)\\n       {\\n           return;\\n       }\\n       if(root->val % 2 == 0)\\n       {\\n           if(root -> left != NULL)\\n           {\\n                if(root -> left -> left != NULL) \\n                {\\n                    sum += root -> left -> left -> val;\\n                }\\n                if(root -> left -> right != NULL)\\n                {\\n                    sum += root -> left -> right -> val;\\n                }\\n            }\\n            if(root -> right != NULL)\\n            {\\n                if(root -> right -> left != NULL) \\n                {\\n                    sum += root -> right -> left -> val;\\n                }\\n                if(root -> right -> right != NULL)\\n                {\\n                    sum += root -> right -> right -> val;\\n                }\\n            }\\n        }\\n        solve(root -> left);\\n        solve(root -> right);\\n    }\\n\\t\\n    int sumEvenGrandparent(TreeNode* root) {\\n        solve(root);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285487,
                "title": "c-easy-solution-with-preorder-traversal",
                "content": "I have traverse the tree with preorder traversal and updated the sum variable.I hope youlike it :)\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint sum = 0;\\n    \\n\\tvoid preordertraversal(TreeNode* root){\\n    if(root == nullptr)\\n        return;\\n    else{\\n        if(root->val % 2 == 0){\\n            if(root->left){\\n                if(root->left->left)\\n                    sum += root->left->left->val;\\n                if(root->left->right)\\n                    sum += root->left->right->val;\\n            }if(root->right){\\n                if(root->right->left)\\n                    sum += root->right->left->val;\\n                if(root->right->right)\\n                    sum += root->right->right->val;\\n            }\\n        }\\n        preordertraversal(root->left);\\n        preordertraversal(root->right);\\n    }\\n\\t}\\n\\tint sumEvenGrandparent(TreeNode* root) {\\n\\t\\t\\tpreordertraversal(root);\\n\\t\\treturn sum;       \\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint sum = 0;\\n    \\n\\tvoid preordertraversal(TreeNode* root){\\n    if(root == nullptr)\\n        return;\\n    else{\\n        if(root->val % 2 == 0){\\n            if(root->left){\\n                if(root->left->left)\\n                    sum += root->left->left->val;\\n                if(root->left->right)\\n                    sum += root->left->right->val;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1275957,
                "title": "99-30-fast-easy-to-understand-java-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static int sum =0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        \\n        sum =0;\\n        return getSum(root);\\n    }\\n    \\n    static int getSum( TreeNode root)\\n    {\\n        if(root!=null && root.val%2==0)\\n        {\\n            if(root.left!=null)\\n            {\\n                if(root.left.left!=null)\\n                {\\n                    sum = sum + root.left.left.val;\\n                }\\n                if(root.left.right!=null)\\n                {\\n                    sum = sum + root.left.right.val;\\n                }\\n            }\\n            \\n            if(root.right!=null)\\n            {\\n                if(root.right.left!=null)\\n                {\\n                    sum = sum + root.right.left.val;\\n                }\\n                if(root.right.right!=null)\\n                {\\n                    sum = sum + root.right.right.val;\\n                }\\n            }\\n    }\\n        if(root.left!=null)\\n        {\\n            getSum(root.left);\\n        }\\n        if(root.right!=null)\\n        {\\n            getSum(root.right);\\n        }\\n        \\n        return sum;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static int sum =0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        \\n        sum =0;\\n        return getSum(root);\\n    }\\n    \\n    static int getSum( TreeNode root)\\n    {\\n        if(root!=null && root.val%2==0)\\n        {\\n            if(root.left!=null)\\n            {\\n                if(root.left.left!=null)\\n                {\\n                    sum = sum + root.left.left.val;\\n                }\\n                if(root.left.right!=null)\\n                {\\n                    sum = sum + root.left.right.val;\\n                }\\n            }\\n            \\n            if(root.right!=null)\\n            {\\n                if(root.right.left!=null)\\n                {\\n                    sum = sum + root.right.left.val;\\n                }\\n                if(root.right.right!=null)\\n                {\\n                    sum = sum + root.right.right.val;\\n                }\\n            }\\n    }\\n        if(root.left!=null)\\n        {\\n            getSum(root.left);\\n        }\\n        if(root.right!=null)\\n        {\\n            getSum(root.right);\\n        }\\n        \\n        return sum;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237660,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n         transverse(root);\\n         return sum;\\n    }\\n    public void transverse(TreeNode root)\\n    {\\n        if(root==null)\\n            return ;\\n        if(root.val%2==0)//if a node is even,check if it has grandchildren\\n        {\\n            if(root.left!=null)//left side\\n            {\\n                if(root.left.left!=null)//presence of grandchildren\\n                    sum+=root.left.left.val;\\n                if(root.left.right!=null)//presence of grandchildren\\n                    sum+=root.left.right.val;\\n            }\\n            if(root.right!=null)//right side\\n            {\\n                if(root.right.left!=null)//presence of grandchildren\\n                    sum+=root.right.left.val;\\n                if(root.right.right!=null)//presence of grandchildren\\n                    sum+=root.right.right.val;\\n            }\\n        }\\n        transverse(root.left);\\n        transverse(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n         transverse(root);\\n         return sum;\\n    }\\n    public void transverse(TreeNode root)\\n    {\\n        if(root==null)\\n            return ;\\n        if(root.val%2==0)//if a node is even,check if it has grandchildren\\n        {\\n            if(root.left!=null)//left side\\n            {\\n                if(root.left.left!=null)//presence of grandchildren\\n                    sum+=root.left.left.val;\\n                if(root.left.right!=null)//presence of grandchildren\\n                    sum+=root.left.right.val;\\n            }\\n            if(root.right!=null)//right side\\n            {\\n                if(root.right.left!=null)//presence of grandchildren\\n                    sum+=root.right.left.val;\\n                if(root.right.right!=null)//presence of grandchildren\\n                    sum+=root.right.right.val;\\n            }\\n        }\\n        transverse(root.left);\\n        transverse(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234795,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int sum = 0;\\n    \\n    public int sumEvenGrandparent(TreeNode root) {\\n        solve(root);\\n        return sum;\\n    }\\n    \\n    public void solve(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n        \\n        if(root.val%2 == 0)\\n        {\\n            if(root.left != null)\\n            {\\n                if(root.left.left != null)\\n                    sum = sum + root.left.left.val;\\n                if(root.left.right != null)\\n                    sum = sum + root.left.right.val;\\n            }\\n            if(root.right != null)\\n            {\\n                if(root.right.left != null)\\n                    sum = sum + root.right.left.val;\\n                if(root.right.right != null)\\n                    sum = sum + root.right.right.val;\\n            }\\n        }\\n        \\n        solve(root.left);\\n        solve(root.right);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int sum = 0;\\n    \\n    public int sumEvenGrandparent(TreeNode root) {\\n        solve(root);\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1232451,
                "title": "simple-understandable-solution-using-c-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root) return 0;\\n        int sum = 0;\\n        calculate(NULL,NULL,root,sum);\\n        return sum;\\n        \\n    }\\n     void calculate(TreeNode* parent,TreeNode* grand,TreeNode* root,int &sum)\\n    {\\n        if(!root) return ;\\n        if(grand && grand->val % 2 ==0)\\n            sum+=root->val;\\n        calculate(root,parent,root->left,sum);\\n        calculate(root,parent,root->right,sum);\\n       \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root) return 0;\\n        int sum = 0;\\n        calculate(NULL,NULL,root,sum);\\n        return sum;\\n        \\n    }\\n     void calculate(TreeNode* parent,TreeNode* grand,TreeNode* root,int &sum)\\n    {\\n        if(!root) return ;\\n        if(grand && grand->val % 2 ==0)\\n            sum+=root->val;\\n        calculate(root,parent,root->left,sum);\\n        calculate(root,parent,root->right,sum);\\n       \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227757,
                "title": "simple-and-easy-to-understand-cpp",
                "content": "step 1. traverse the whole tree by any order \\nstep 2. if you find any node value even , just add its grand nodes ( if its not null)\\nstep 3. return sum\\n\\n\\nupvote if you get it. \\nhappy coding\\n\\n\\n```\\n /**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\n\\n  int ans = 0;\\n\\n  void traverse(TreeNode *x)\\n  {\\n\\n    if (!x)\\n      return;\\n\\n    if (x->val % 2 == 0)\\n    {\\n\\n      if (x->left)\\n      {\\n        if (x->left->left)   ans += x->left->left->val;\\n        if (x->left->right)   ans += x->left->right->val;\\n      }\\n\\n      if (x->right)\\n      {\\n        if (x->right->left)  ans += x->right->left->val;\\n        if (x->right->right)  ans += x->right->right->val;\\n      }\\n    }\\n\\n    traverse(x->left);\\n    traverse(x->right);\\n  }\\n\\npublic:\\n  int sumEvenGrandparent(TreeNode *root)\\n  {\\n\\n    traverse(root);\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n /**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\n\\n  int ans = 0;\\n\\n  void traverse(TreeNode *x)\\n  {\\n\\n    if (!x)\\n      return;\\n\\n    if (x->val % 2 == 0)\\n    {\\n\\n      if (x->left)\\n      {\\n        if (x->left->left)   ans += x->left->left->val;\\n        if (x->left->right)   ans += x->left->right->val;\\n      }\\n\\n      if (x->right)\\n      {\\n        if (x->right->left)  ans += x->right->left->val;\\n        if (x->right->right)  ans += x->right->right->val;\\n      }\\n    }\\n\\n    traverse(x->left);\\n    traverse(x->right);\\n  }\\n\\npublic:\\n  int sumEvenGrandparent(TreeNode *root)\\n  {\\n\\n    traverse(root);\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218496,
                "title": "c-easy-to-understand-dfs-solution",
                "content": "**Runtime: 32 ms**, faster than 92.60% of C++ online submissions.\\n**Memory Usage: 38.1 MB**, less than 74.42% of C++ online submissions.\\n\\n```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        int f = (root->val%2) ? 0 : 1;\\n        int s = 0;\\n        if(f) {\\n            if(root->left) {\\n                if(root->left->left)\\n                    s += root->left->left->val;\\n                if(root->left->right)\\n                    s += root->left->right->val;\\n            }\\n            if(root->right) {\\n                if(root->right->left)\\n                    s += root->right->left->val;\\n                if(root->right->right)\\n                    s += root->right->right->val;\\n            }\\n        }\\n        return s + sumEvenGrandparent(root->left) + sumEvenGrandparent(root->right);\\n    }\\n};\\n```\\nFeel free to ask any question in the comment section.",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        int f = (root->val%2) ? 0 : 1;\\n        int s = 0;\\n        if(f) {\\n            if(root->left) {\\n                if(root->left->left)\\n                    s += root->left->left->val;\\n                if(root->left->right)\\n                    s += root->left->right->val;\\n            }\\n            if(root->right) {\\n                if(root->right->left)\\n                    s += root->right->left->val;\\n                if(root->right->right)\\n                    s += root->right->right->val;\\n            }\\n        }\\n        return s + sumEvenGrandparent(root->left) + sumEvenGrandparent(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209749,
                "title": "java-easy-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int ans;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        ans = 0;\\n        dfs(root,null,null);\\n        return ans;\\n    }\\n    private void dfs(TreeNode node,TreeNode p,TreeNode gp){\\n        if(node == null) return;\\n        \\n       if(gp!=null){\\n         if(gp.val % 2 == 0) ans+=node.val;\\n       }\\n        \\n        dfs(node.left,node,p);\\n        dfs(node.right,node,p);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int ans;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        ans = 0;\\n        dfs(root,null,null);\\n        return ans;\\n    }\\n    private void dfs(TreeNode node,TreeNode p,TreeNode gp){\\n        if(node == null) return;\\n        \\n       if(gp!=null){\\n         if(gp.val % 2 == 0) ans+=node.val;\\n       }\\n        \\n        dfs(node.left,node,p);\\n        dfs(node.right,node,p);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188631,
                "title": "java-recursion",
                "content": "```\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        return getSum(root, null, null);\\n    }\\n    \\n    public int getSum(TreeNode root, TreeNode parent, TreeNode grandParent) {\\n        if (root == null) {\\n            return 0;\\n        }                \\n        \\n        int leftSum = getSum(root.left, root, parent);\\n        int rightSum = getSum(root.right, root, parent);\\n        \\n        int totalSum = leftSum + rightSum;\\n        \\n        if (grandParent != null && grandParent.val % 2 == 0) {\\n            totalSum += root.val;\\n        }\\n        \\n        return totalSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        return getSum(root, null, null);\\n    }\\n    \\n    public int getSum(TreeNode root, TreeNode parent, TreeNode grandParent) {\\n        if (root == null) {\\n            return 0;\\n        }                \\n        \\n        int leftSum = getSum(root.left, root, parent);\\n        int rightSum = getSum(root.right, root, parent);\\n        \\n        int totalSum = leftSum + rightSum;\\n        \\n        if (grandParent != null && grandParent.val % 2 == 0) {\\n            totalSum += root.val;\\n        }\\n        \\n        return totalSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165601,
                "title": "simple-java-solution-with-comments-99",
                "content": "- Create helper function to keep track of grand parent. \\n- Sum the current val if grand parent is even otherwise keep on recursing without adding the current value.\\n\\n```\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        return getSum(root, null, null);\\n    }\\n    \\n    \\n    public int getSum(TreeNode root, \\n                      TreeNode parent, \\n                      TreeNode grandParent) {\\n        \\n        \\n        if (root == null) return 0; // End condition nothing left to add\\n        \\n        \\n        if(grandParent != null && grandParent.val %2 == 0) {\\n            return root.val + getSum(root.left, root, parent) + getSum(root.right, root, parent); // If the grand parent is not null and even then add it to the sum\\n        }\\n        \\n        return getSum(root.left, root, parent) + getSum(root.right, root, parent); // if the grand parent is null or is not even do not add the node to the sum\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        return getSum(root, null, null);\\n    }\\n    \\n    \\n    public int getSum(TreeNode root, \\n                      TreeNode parent, \\n                      TreeNode grandParent) {\\n        \\n        \\n        if (root == null) return 0; // End condition nothing left to add\\n        \\n        \\n        if(grandParent != null && grandParent.val %2 == 0) {\\n            return root.val + getSum(root.left, root, parent) + getSum(root.right, root, parent); // If the grand parent is not null and even then add it to the sum\\n        }\\n        \\n        return getSum(root.left, root, parent) + getSum(root.right, root, parent); // if the grand parent is null or is not even do not add the node to the sum\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148841,
                "title": "c-dfs-easy-and-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int sumEvenGrandparent(TreeNode* root) \\n    {        \\n        solve(root);    \\n        return res;\\n    }\\n    void solve(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        if((root->val)%2 == 0)\\n        {\\n            if(root->left)\\n            {\\n                if(root->left->left)\\n                    res += root->left->left->val;\\n                if(root->left->right)\\n                    res += root->left->right->val;    \\n            }\\n            if(root->right)\\n            {\\n                if(root->right->left)\\n                    res += root->right->left->val;\\n                if(root->right->right)\\n                    res += root->right->right->val;    \\n            }\\n        }\\n        solve(root->left);\\n        solve(root->right);\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int sumEvenGrandparent(TreeNode* root) \\n    {        \\n        solve(root);    \\n        return res;\\n    }\\n    void solve(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        if((root->val)%2 == 0)\\n        {\\n            if(root->left)\\n            {\\n                if(root->left->left)\\n                    res += root->left->left->val;\\n                if(root->left->right)\\n                    res += root->left->right->val;    \\n            }\\n            if(root->right)\\n            {\\n                if(root->right->left)\\n                    res += root->right->left->val;\\n                if(root->right->right)\\n                    res += root->right->right->val;    \\n            }\\n        }\\n        solve(root->left);\\n        solve(root->right);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132430,
                "title": "python-code-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def sumEvenGrandparent(self, root):\\n        hash_map = {}\\n        hash_map[root] = -1\\n        self.createParent(root, hash_map)\\n        total = 0\\n        for i in hash_map:\\n            if hash_map[i]!=-1 and hash_map[hash_map[i]] != -1 and hash_map[hash_map[i]].val % 2 == 0:\\n                total+= i.val\\n        return total\\n        \\n        \\n    def createParent(self, root, hash_map):\\n        if root == None:\\n            return \\n        if root.left:\\n            hash_map[root.left] = root\\n        if root.right:\\n            hash_map[root.right] = root\\n            \\n        self.createParent(root.left, hash_map)\\n        self.createParent(root.right, hash_map)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def sumEvenGrandparent(self, root):\\n        hash_map = {}",
                "codeTag": "Java"
            },
            {
                "id": 1132313,
                "title": "c-easy-dfs-sliding-solution",
                "content": "```\\npublic class Solution {\\n    public int SumEvenGrandparent(TreeNode root) {\\n        return DFS(root, -1, -1);\\n    }\\n\\n    public int DFS(TreeNode node, int parent, int grandparent) {\\n        if (node == null)\\n            return 0;\\n\\n        return (grandparent % 2 == 0 ? node.val : 0) +\\n\\t\\t    DFS(node.left, node.val, parent) +\\n            DFS(node.right, node.val, parent);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int SumEvenGrandparent(TreeNode root) {\\n        return DFS(root, -1, -1);\\n    }\\n\\n    public int DFS(TreeNode node, int parent, int grandparent) {\\n        if (node == null)\\n            return 0;\\n\\n        return (grandparent % 2 == 0 ? node.val : 0) +\\n\\t\\t    DFS(node.left, node.val, parent) +\\n            DFS(node.right, node.val, parent);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131745,
                "title": "short-and-clean-java-solution",
                "content": "```\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        return helper(root, false, false);\\n    }\\n    \\n    private int helper(TreeNode root, boolean parent, boolean grandparent) {\\n        int sum = 0;\\n        if (root != null) {\\n            if (grandparent) {\\n                sum += root.val;\\n            }\\n            sum += helper(root.left, root.val % 2 == 0, parent);\\n            sum += helper(root.right, root.val % 2 == 0, parent);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        return helper(root, false, false);\\n    }\\n    \\n    private int helper(TreeNode root, boolean parent, boolean grandparent) {\\n        int sum = 0;\\n        if (root != null) {\\n            if (grandparent) {\\n                sum += root.val;\\n            }\\n            sum += helper(root.left, root.val % 2 == 0, parent);\\n            sum += helper(root.right, root.val % 2 == 0, parent);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906603,
                "title": "python-3-beats-95-dfs",
                "content": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        if not root:\\n            return \\n        \\n        self.sum=0\\n        \\n        self.dfs(root,None, None)        \\n        return self.sum\\n    \\n    def dfs(self,child, parent, grandParent):\\n        if not child:\\n            return \\n        \\n        if grandParent!= None and grandParent.val%2==0:\\n            self.sum += child.val\\n            \\n        # Child, Parent and Grand Parent\\n        self.dfs(child.left, child, parent)\\n        self.dfs(child.right, child, parent)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        if not root:\\n            return \\n        \\n        self.sum=0\\n        \\n        self.dfs(root,None, None)        \\n        return self.sum\\n    \\n    def dfs(self,child, parent, grandParent):\\n        if not child:\\n            return \\n        \\n        if grandParent!= None and grandParent.val%2==0:\\n            self.sum += child.val\\n            \\n        # Child, Parent and Grand Parent\\n        self.dfs(child.left, child, parent)\\n        self.dfs(child.right, child, parent)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894329,
                "title": "python-fast-recursive-solution",
                "content": "```\\nimport sys\\nclass Solution:\\n    ans = 0\\n    sys.setrecursionlimit(5000)\\n    \\n    def sumEvenGrandparentUtil(self, node: TreeNode, par: TreeNode, gp: TreeNode) -> None:\\n        if not node:\\n            return\\n        \\n        if gp and gp.val%2==0:\\n            self.ans += node.val\\n            \\n        if node.left:\\n            self.sumEvenGrandparentUtil(node.left, node, par)\\n        if node.right:\\n            self.sumEvenGrandparentUtil(node.right, node, par)\\n    \\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        self.sumEvenGrandparentUtil(root, None, None)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\nimport sys\\nclass Solution:\\n    ans = 0\\n    sys.setrecursionlimit(5000)\\n    \\n    def sumEvenGrandparentUtil(self, node: TreeNode, par: TreeNode, gp: TreeNode) -> None:\\n        if not node:\\n            return\\n        \\n        if gp and gp.val%2==0:\\n            self.ans += node.val\\n            \\n        if node.left:\\n            self.sumEvenGrandparentUtil(node.left, node, par)\\n        if node.right:\\n            self.sumEvenGrandparentUtil(node.right, node, par)\\n    \\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        self.sumEvenGrandparentUtil(root, None, None)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791874,
                "title": "c-dfs-approach-56-ms-solution-92-66-easy-to-understand",
                "content": "***Runtime: 56 ms, faster than 92.66% of C++ online submissions for Sum of Nodes with Even-Valued Grandparent.\\nMemory Usage: 38.1 MB, less than 87.70% of C++ online submissions for Sum of Nodes with Even-Valued Grandparent.***\\n```\\nclass Solution {\\npublic:\\n    int result = 0;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        dfs(root);\\n        return result;\\n    }\\n    void dfs(TreeNode* root){\\n        if(root){\\n            if(root->val % 2 == 0){\\n                TreeNode *lNode = root->left, *rNode = root->right;\\n                if(lNode){\\n                    result += lNode->left ? lNode->left->val : 0;\\n                    result += lNode->right ? lNode->right->val : 0;\\n                }\\n                if(rNode){\\n                    result += rNode->left ? rNode->left->val : 0;\\n                    result += rNode->right ? rNode->right->val : 0;\\n                }\\n            }\\n            dfs(root->left);\\n            dfs(root->right);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int result = 0;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        dfs(root);\\n        return result;\\n    }\\n    void dfs(TreeNode* root){\\n        if(root){\\n            if(root->val % 2 == 0){\\n                TreeNode *lNode = root->left, *rNode = root->right;\\n                if(lNode){\\n                    result += lNode->left ? lNode->left->val : 0;\\n                    result += lNode->right ? lNode->right->val : 0;\\n                }\\n                if(rNode){\\n                    result += rNode->left ? rNode->left->val : 0;\\n                    result += rNode->right ? rNode->right->val : 0;\\n                }\\n            }\\n            dfs(root->left);\\n            dfs(root->right);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777770,
                "title": "java-preorder-traversal",
                "content": "Time - O(n)\\n\\nSpace - O(h) where h = height\\n\\n```\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        int[] sum = new int[1];\\n        helper(root, -1, -1, sum);\\n        return sum[0];\\n    }\\n    \\n    void helper(TreeNode node, int parent, int grandParent, int[] sum) {\\n        if (node == null)\\n            return;\\n        \\n        if (grandParent % 2 == 0) {\\n            sum[0] += node.val;\\n        }\\n        \\n        helper(node.left, node.val, parent, sum);\\n        helper(node.right, node.val, parent, sum);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        int[] sum = new int[1];\\n        helper(root, -1, -1, sum);\\n        return sum[0];\\n    }\\n    \\n    void helper(TreeNode node, int parent, int grandParent, int[] sum) {\\n        if (node == null)\\n            return;\\n        \\n        if (grandParent % 2 == 0) {\\n            sum[0] += node.val;\\n        }\\n        \\n        helper(node.left, node.val, parent, sum);\\n        helper(node.right, node.val, parent, sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775838,
                "title": "java-1-ms-faster-than-99-57",
                "content": "```\\nclass Solution {\\n    \\n    int res = 0 ;\\n    \\n    public int sumEvenGrandparent(TreeNode root) {\\n               \\n        traverse (root, null , null );\\n        return res;\\n    }\\n    \\n    \\n    public void traverse(TreeNode node, TreeNode parentVal, TreeNode grandVal   ){\\n        \\n        \\n        if( node == null )\\n            return  ;\\n        \\n        \\n        if( grandVal != null &&  grandVal.val % 2 == 0 ){\\n            res += node.val ;\\n        }\\n        \\n        traverse(node.left , node , parentVal   );\\n        traverse(node.right , node , parentVal  );\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int res = 0 ;\\n    \\n    public int sumEvenGrandparent(TreeNode root) {\\n               \\n        traverse (root, null , null );\\n        return res;\\n    }\\n    \\n    \\n    public void traverse(TreeNode node, TreeNode parentVal, TreeNode grandVal   ){\\n        \\n        \\n        if( node == null )\\n            return  ;\\n        \\n        \\n        if( grandVal != null &&  grandVal.val % 2 == 0 ){\\n            res += node.val ;\\n        }\\n        \\n        traverse(node.left , node , parentVal   );\\n        traverse(node.right , node , parentVal  );\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742252,
                "title": "recursion-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) \\n    {\\n        if(!root)\\n            return 0;\\n        int sum=0;\\n        \\n        if(root->val%2==0)\\n        {\\n            if(root->left)\\n            {\\n                if(root->left->left) \\n                    sum += root->left->left->val;\\n                if(root->left->right) \\n                    sum += root->left->right->val;\\n            }\\n            if(root->right)\\n            {\\n                if(root->right->left) \\n                    sum += root->right->left->val;\\n                if(root->right->right) \\n                    sum += root->right->right->val;\\n            }\\n        }\\n        return sum + sumEvenGrandparent(root->left) + sumEvenGrandparent(root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumEvenGrandparent(TreeNode* root) \\n    {\\n        if(!root)\\n            return 0;\\n        int sum=0;\\n        \\n        if(root->val%2==0)\\n        {\\n            if(root->left)\\n            {\\n                if(root->left->left) \\n                    sum += root->left->left->val;\\n                if(root->left->right) \\n                    sum += root->left->right->val;\\n            }\\n            if(root->right)\\n            {\\n                if(root->right->left) \\n                    sum += root->right->left->val;\\n                if(root->right->right) \\n                    sum += root->right->right->val;\\n            }\\n        }\\n        return sum + sumEvenGrandparent(root->left) + sumEvenGrandparent(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700556,
                "title": "easy-python-dfs-4-liner-90-speed-and-memory",
                "content": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, node, parent=1, grandparent=1, total=0):\\n        if not node: return 0\\n        \\n        total = self.sumEvenGrandparent(node.left, node.val, parent, total) + self.sumEvenGrandparent(node.right, node.val, parent, total)\\n        \\n        if not grandparent % 2: total += node.val\\n        \\n        return total",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, node, parent=1, grandparent=1, total=0):\\n        if not node: return 0\\n        \\n        total = self.sumEvenGrandparent(node.left, node.val, parent, total) + self.sumEvenGrandparent(node.right, node.val, parent, total)\\n        \\n        if not grandparent % 2: total += node.val\\n        \\n        return total",
                "codeTag": "Java"
            },
            {
                "id": 667083,
                "title": "clean-iterative-recursive-solution-java",
                "content": "**Iterative solution**\\nUsing Stack of  `StackItem` class to store `parent` and `gParent` nodes\\n```\\npublic class StackItem{\\n    TreeNode node;\\n    TreeNode parent;\\n    TreeNode gParent;\\n    \\n    public StackItem(TreeNode node, TreeNode parent, TreeNode gParent){\\n        this.node = node;\\n        this.parent = parent;\\n        this.gParent = gParent;\\n    }\\n}\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null) return result;\\n\\t\\tint result = 0;\\n        Stack<StackItem> stack = new Stack<>();\\n        stack.push(new StackItem(root, null, null));\\n        while(!stack.isEmpty()){\\n            StackItem currItem = stack.pop();\\n            if(currItem.gParent!=null && currItem.gParent.val%2 ==0){\\n                result += currItem.node.val;\\n            }\\n            if(currItem.node.left!=null) stack.push(new StackItem(currItem.node.left, currItem.node, currItem.parent));\\n            if(currItem.node.right!=null) stack.push(new StackItem(currItem.node.right, currItem.node, currItem.parent));\\n            \\n        }\\n      \\n        return result;\\n    }\\n}\\n```\\n\\n**Recursive solution**\\n```\\nclass Solution {\\n    int result = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null) return result;\\n        sum(root, null, null);\\n        return result;\\n        \\n    }\\n    private int sum(TreeNode node, TreeNode parent, TreeNode gParent){\\n        if(node == null) return 0;\\n        if(gParent!=null && gParent.val %2 ==0){\\n            result +=node.val;\\n        }\\n        return sum(node.left, node, parent) + sum(node.right, node, parent);\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class StackItem{\\n    TreeNode node;\\n    TreeNode parent;\\n    TreeNode gParent;\\n    \\n    public StackItem(TreeNode node, TreeNode parent, TreeNode gParent){\\n        this.node = node;\\n        this.parent = parent;\\n        this.gParent = gParent;\\n    }\\n}\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null) return result;\\n\\t\\tint result = 0;\\n        Stack<StackItem> stack = new Stack<>();\\n        stack.push(new StackItem(root, null, null));\\n        while(!stack.isEmpty()){\\n            StackItem currItem = stack.pop();\\n            if(currItem.gParent!=null && currItem.gParent.val%2 ==0){\\n                result += currItem.node.val;\\n            }\\n            if(currItem.node.left!=null) stack.push(new StackItem(currItem.node.left, currItem.node, currItem.parent));\\n            if(currItem.node.right!=null) stack.push(new StackItem(currItem.node.right, currItem.node, currItem.parent));\\n            \\n        }\\n      \\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int result = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null) return result;\\n        sum(root, null, null);\\n        return result;\\n        \\n    }\\n    private int sum(TreeNode node, TreeNode parent, TreeNode gParent){\\n        if(node == null) return 0;\\n        if(gParent!=null && gParent.val %2 ==0){\\n            result +=node.val;\\n        }\\n        return sum(node.left, node, parent) + sum(node.right, node, parent);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640432,
                "title": "java-very-simple-solution-98-5-100-odd-even-check-using-bitwise-operator",
                "content": "```\\nclass Solution {\\n    int sum=0;\\n    void solve(TreeNode root, TreeNode p, TreeNode gp){\\n        if(root == null) return;\\n        if(gp!=null && (gp.val&1)!=1) sum+=root.val;\\n        solve(root.left,root,p);\\n        solve(root.right,root,p);\\n    }\\n    public int sumEvenGrandparent(TreeNode root) {\\n        solve(root,null,null);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    void solve(TreeNode root, TreeNode p, TreeNode gp){\\n        if(root == null) return;\\n        if(gp!=null && (gp.val&1)!=1) sum+=root.val;\\n        solve(root.left,root,p);\\n        solve(root.right,root,p);\\n    }\\n    public int sumEvenGrandparent(TreeNode root) {\\n        solve(root,null,null);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588144,
                "title": "python-recursive-intuitive",
                "content": "```\\ndef sumEvenGrandparent(self, root: TreeNode) -> int:\\n        self.ans = 0\\n        \\n        if not root:\\n            return 0\\n        \\n        def recur(root):\\n            if not root:\\n                return\\n            \\n            if root.val % 2 == 0:\\n                if root.left:\\n                    if root.left.left:\\n                        self.ans += root.left.left.val\\n                    if root.left.right:\\n                        self.ans += root.left.right.val\\n                if root.right:\\n                    if root.right.left:\\n                        self.ans += root.right.left.val\\n                    if root.right.right:\\n                        self.ans += root.right.right.val\\n            recur(root.left)\\n            recur(root.right)\\n            \\n        \\n        recur(root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef sumEvenGrandparent(self, root: TreeNode) -> int:\\n        self.ans = 0\\n        \\n        if not root:\\n            return 0\\n        \\n        def recur(root):\\n            if not root:\\n                return\\n            \\n            if root.val % 2 == 0:\\n                if root.left:\\n                    if root.left.left:\\n                        self.ans += root.left.left.val\\n                    if root.left.right:\\n                        self.ans += root.left.right.val\\n                if root.right:\\n                    if root.right.left:\\n                        self.ans += root.right.left.val\\n                    if root.right.right:\\n                        self.ans += root.right.right.val\\n            recur(root.left)\\n            recur(root.right)\\n            \\n        \\n        recur(root)\\n        return self.ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 550582,
                "title": "rust-bfs-0ms",
                "content": "The idea is straightforward, just traverse the tree, and find any node with a even-valued grandparent node `gp % 2 == 1`. \\n\\n```rust\\nimpl Solution {\\n    pub fn bfs(root: Option<Rc<RefCell<TreeNode>>>, gp: i32, p: i32)->i32 {\\n        let mut res = 0_i32; \\n        if let Some(root) = root{\\n            if gp % 2 == 0 { res += root.borrow().val ; }\\n            res += Solution::bfs(root.borrow().left.clone(), p, root.borrow().val);\\n            res += Solution::bfs(root.borrow().right.clone(), p, root.borrow().val);\\n            return res; \\n        }\\n        0 \\n    }\\n    pub fn sum_even_grandparent(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        Solution::bfs(root, 1, 1)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn bfs(root: Option<Rc<RefCell<TreeNode>>>, gp: i32, p: i32)->i32 {\\n        let mut res = 0_i32; \\n        if let Some(root) = root{\\n            if gp % 2 == 0 { res += root.borrow().val ; }\\n            res += Solution::bfs(root.borrow().left.clone(), p, root.borrow().val);\\n            res += Solution::bfs(root.borrow().right.clone(), p, root.borrow().val);\\n            return res; \\n        }\\n        0 \\n    }\\n    pub fn sum_even_grandparent(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        Solution::bfs(root, 1, 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498777,
                "title": "ruby-solution-using-bfs",
                "content": "Do a simple BFS with a queue/array, keeping track of the path to each node. If the grandparent of the current node is even, add it to the results.\\n\\n```ruby\\ndef sum_even_grandparent(root)\\n  queue = []\\n  results = 0 \\n  \\n  queue.push([root, [nil]])\\n  \\n  while queue.size > 0\\n    current = queue.shift\\n    node = current[0]\\n    path = current[1]\\n    grandparent = path[-2]\\n    \\n    if grandparent && grandparent.val % 2 == 0\\n      results += node.val\\n    end\\n    \\n    queue.push([node.left, path + [node]]) if node.left\\n    queue.push([node.right, path + [node]]) if node.right\\n  end\\n      \\n  results\\nend\\n```",
                "solutionTags": [],
                "code": "```ruby\\ndef sum_even_grandparent(root)\\n  queue = []\\n  results = 0 \\n  \\n  queue.push([root, [nil]])\\n  \\n  while queue.size > 0\\n    current = queue.shift\\n    node = current[0]\\n    path = current[1]\\n    grandparent = path[-2]\\n    \\n    if grandparent && grandparent.val % 2 == 0\\n      results += node.val\\n    end\\n    \\n    queue.push([node.left, path + [node]]) if node.left\\n    queue.push([node.right, path + [node]]) if node.right\\n  end\\n      \\n  results\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 490859,
                "title": "javascript-recursion-simple-solution-faster-than-100-less-mem-than-100-3-lines",
                "content": "```\\nvar sumEvenGrandparent = function(root, parent = null, grandparent = null) {\\n    if (root === null) return 0;\\n    const val = grandparent === null || grandparent.val % 2 !== 0 ? 0 : root.val;\\n    return val + sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar sumEvenGrandparent = function(root, parent = null, grandparent = null) {\\n    if (root === null) return 0;\\n    const val = grandparent === null || grandparent.val % 2 !== 0 ? 0 : root.val;\\n    return val + sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 490471,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null) return 0;\\n        int sum = sumEvenGrandparent(root.left) + sumEvenGrandparent(root.right);\\n        if(root.val % 2 == 0) {\\n            if(root.left != null) {\\n                sum += (root.left.left == null ? 0 : root.left.left.val);\\n                sum += (root.left.right == null ? 0 : root.left.right.val);\\n            }\\n            if(root.right != null) {\\n                sum += (root.right.left == null ? 0 : root.right.left.val);\\n                sum += (root.right.right == null ? 0 : root.right.right.val);\\n            }\\n        }\\n        \\n        return sum;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null) return 0;\\n        int sum = sumEvenGrandparent(root.left) + sumEvenGrandparent(root.right);\\n        if(root.val % 2 == 0) {\\n            if(root.left != null) {\\n                sum += (root.left.left == null ? 0 : root.left.left.val);\\n                sum += (root.left.right == null ? 0 : root.left.right.val);\\n            }\\n            if(root.right != null) {\\n                sum += (root.right.left == null ? 0 : root.right.left.val);\\n                sum += (root.right.right == null ? 0 : root.right.right.val);\\n            }\\n        }\\n        \\n        return sum;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482819,
                "title": "sum-of-nodes-with-even-valued-grandparent-in-java",
                "content": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        \\n        preorder(null,null,root);\\n        return sum;\\n    }\\n    \\n    \\n    public void preorder(TreeNode gp, TreeNode p , TreeNode c)\\n    {\\n        if(gp!=null && p!=null && c!=null && gp.val%2==0)\\n        {\\n           sum=sum+c.val;\\n        }\\n        if(c==null)\\n            return;\\n         preorder(p, c , c.left);\\n         preorder(p, c , c.right);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "class Solution {\\n    int sum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        \\n        preorder(null,null,root);\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4032896,
                "title": "easy-c-solution-with-explanation-dfs-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to keep track of grandparent of each node for that we also need parent of each node.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ninitalize grandparent(gp) and parent(p) as -1.\\n\\nfor a node its parent\\'s parent will be its grandparent. so change the gp to p and then p to nodes val so when we will go to the next node we will have its gp and p.check if gp is even and add its value to sum.\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(H)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void solve(TreeNode *root, int gp,int p){\\n        if(!root) return;\\n\\n        if(gp%2 == 0) sum += root->val;\\n        gp = p;\\n        p = root->val;\\n\\n        solve(root->left,gp,p);\\n        solve(root->right,gp,p);\\n    }\\n\\n    int sumEvenGrandparent(TreeNode* root) {\\n        int gp = -1;\\n        int p = -1;\\n\\n        solve(root,gp,p);\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void solve(TreeNode *root, int gp,int p){\\n        if(!root) return;\\n\\n        if(gp%2 == 0) sum += root->val;\\n        gp = p;\\n        p = root->val;\\n\\n        solve(root->left,gp,p);\\n        solve(root->right,gp,p);\\n    }\\n\\n    int sumEvenGrandparent(TreeNode* root) {\\n        int gp = -1;\\n        int p = -1;\\n\\n        solve(root,gp,p);\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941075,
                "title": "simple-fastest-cpp-solution-ever-bros",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint sum = 0;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        if(root->val % 2 == 0){\\n            if(root->left!=NULL && root->left->left!=NULL){\\n                sum += root->left ->left->val;\\n            }\\n            if(root->left!=NULL && root->left->right!=NULL){\\n                sum += root->left->right->val;\\n            }\\n            if(root->right!=NULL && root->right->left!=NULL){\\n                sum+=root->right->left->val;\\n            }\\n            if(root->right!=NULL && root->right->right!=NULL){\\n                sum+=root->right->right->val;\\n            }\\n        }\\n        sumEvenGrandparent(root->left);\\n        sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint sum = 0;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        if(root->val % 2 == 0){\\n            if(root->left!=NULL && root->left->left!=NULL){\\n                sum += root->left ->left->val;\\n            }\\n            if(root->left!=NULL && root->left->right!=NULL){\\n                sum += root->left->right->val;\\n            }\\n            if(root->right!=NULL && root->right->left!=NULL){\\n                sum+=root->right->left->val;\\n            }\\n            if(root->right!=NULL && root->right->right!=NULL){\\n                sum+=root->right->right->val;\\n            }\\n        }\\n        sumEvenGrandparent(root->left);\\n        sumEvenGrandparent(root->right);\\n        return sum;\\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910063,
                "title": "simplest-dfs-100-beats-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxsum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        solve(root);\\n        return maxsum;\\n        \\n    }\\n    public void solve(TreeNode root){\\n        if(root==null) return ;\\n        if(root.val%2==0){\\n            if(root.left!=null){\\n                if(root.left.left!=null) maxsum+=root.left.left.val;\\n                if(root.left.right!=null) maxsum+=root.left.right.val;\\n            }\\n            if(root.right!=null){\\n                if(root.right.left!=null) maxsum+=root.right.left.val;\\n                if(root.right.right!=null) maxsum+=root.right.right.val;\\n            }\\n            \\n        }\\n        solve(root.left);\\n        solve(root.right);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxsum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        solve(root);\\n        return maxsum;\\n        \\n    }\\n    public void solve(TreeNode root){\\n        if(root==null) return ;\\n        if(root.val%2==0){\\n            if(root.left!=null){\\n                if(root.left.left!=null) maxsum+=root.left.left.val;\\n                if(root.left.right!=null) maxsum+=root.left.right.val;\\n            }\\n            if(root.right!=null){\\n                if(root.right.left!=null) maxsum+=root.right.left.val;\\n                if(root.right.right!=null) maxsum+=root.right.right.val;\\n            }\\n            \\n        }\\n        solve(root.left);\\n        solve(root.right);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555819,
                "title": "easy-dfs-approach-by-fun2s",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int sum(TreeNode* root,int c){\\n        if(root==NULL)return 0;\\n        if(c==0)ans+=root->val;\\n        return sum(root->left,c-1)+sum(root->right,c-1);\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root)return 0;\\n        if(root->val%2==0)sum(root,2);\\n        sumEvenGrandparent(root->left);\\n        sumEvenGrandparent(root->right);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int sum(TreeNode* root,int c){\\n        if(root==NULL)return 0;\\n        if(c==0)ans+=root->val;\\n        return sum(root->left,c-1)+sum(root->right,c-1);\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        if(!root)return 0;\\n        if(root->val%2==0)sum(root,2);\\n        sumEvenGrandparent(root->left);\\n        sumEvenGrandparent(root->right);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453472,
                "title": "c-easy-solution-dfs-simple-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(TreeNode* root, int &sum){\\n        if(!root) return;\\n      //just check if root is even then check for left parent and also  check for its  children  same for right part also\\n        if(root -> val %2 == 0){\\n            if(root -> left != NULL){\\n                if(root -> left -> left != NULL) sum += root -> left -> left -> val;\\n                if(root -> left -> right != NULL) sum += root -> left-> right -> val;\\n            }\\n            if(root -> right != NULL){\\n                if(root -> right -> left != NULL) sum += root -> right -> left -> val;\\n                if(root -> right -> right != NULL) sum += root -> right -> right -> val;\\n            }\\n        }\\n        dfs(root -> left,sum);\\n        dfs(root -> right,sum);\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n       int sum = 0;\\n       dfs(root, sum);\\n       return sum; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(TreeNode* root, int &sum){\\n        if(!root) return;\\n      //just check if root is even then check for left parent and also  check for its  children  same for right part also\\n        if(root -> val %2 == 0){\\n            if(root -> left != NULL){\\n                if(root -> left -> left != NULL) sum += root -> left -> left -> val;\\n                if(root -> left -> right != NULL) sum += root -> left-> right -> val;\\n            }\\n            if(root -> right != NULL){\\n                if(root -> right -> left != NULL) sum += root -> right -> left -> val;\\n                if(root -> right -> right != NULL) sum += root -> right -> right -> val;\\n            }\\n        }\\n        dfs(root -> left,sum);\\n        dfs(root -> right,sum);\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n       int sum = 0;\\n       dfs(root, sum);\\n       return sum; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432960,
                "title": "bfs-easy-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a Family Tree object that has both parent and grandparent(gParent)\\n\\ngenerate the sum variable.\\n\\nUsing BFS, create a queue with the root object, and -1 for each parent.\\n\\nLoop through queue, if the gParent exists and is even, add to the sum, otherwise move on.\\n\\npush a new node, if it exists, set the node as left/right, the parent as the current node.val, and lastly set the grandparent as the previous parent.\\n{node: node.left, parent: node.val, gParent: parent}\\n\\nreturn the sum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\ninterface FamilyTree {\\n    node: TreeNode;\\n    parent: number;\\n    gParent: number;\\n}\\nfunction sumEvenGrandparent(root: TreeNode | null): number {\\n\\n    //currentNode, parent, gParent;\\n    //if gparent mod 2 === 0 \\n    //sum += node.val\\n\\n    const queue: FamilyTree[] = [{node: root || new TreeNode() , parent: -1, gParent: -1}];\\n\\n    let sum = 0;\\n\\n    while(queue.length){\\n        const {node, parent, gParent} = queue.shift();\\n\\n        if(gParent !== -1 && gParent % 2 === 0)\\n            sum += node.val;\\n        \\n        if(node.left)\\n            queue.push({node: node.left, parent: node.val, gParent: parent});\\n        \\n\\n        if(node.right)\\n            queue.push({node: node.right, parent: node.val, gParent: parent});\\n        \\n    }\\n\\n    return sum;\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\ninterface FamilyTree {\\n    node: TreeNode;\\n    parent: number;\\n    gParent: number;\\n}\\nfunction sumEvenGrandparent(root: TreeNode | null): number {\\n\\n    //currentNode, parent, gParent;\\n    //if gparent mod 2 === 0 \\n    //sum += node.val\\n\\n    const queue: FamilyTree[] = [{node: root || new TreeNode() , parent: -1, gParent: -1}];\\n\\n    let sum = 0;\\n\\n    while(queue.length){\\n        const {node, parent, gParent} = queue.shift();\\n\\n        if(gParent !== -1 && gParent % 2 === 0)\\n            sum += node.val;\\n        \\n        if(node.left)\\n            queue.push({node: node.left, parent: node.val, gParent: parent});\\n        \\n\\n        if(node.right)\\n            queue.push({node: node.right, parent: node.val, gParent: parent});\\n        \\n    }\\n\\n    return sum;\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345002,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        int sum = 0;\\n        if(root.val % 2 == 0)\\n        {\\n            if(root.left !=null && root.left.left !=null)\\n                sum+=root.left.left.val;\\n            if(root.left !=null && root.left.right !=null)\\n                sum+=root.left.right.val;\\n            if(root.right !=null && root.right.left !=null)\\n                sum+=root.right.left.val;\\n            if(root.right !=null && root.right.right !=null)\\n                sum+=root.right.right.val;\\n        }\\n        sum += sumEvenGrandparent(root.left) + sumEvenGrandparent(root.right);\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        int sum = 0;\\n        if(root.val % 2 == 0)\\n        {\\n            if(root.left !=null && root.left.left !=null)\\n                sum+=root.left.left.val;\\n            if(root.left !=null && root.left.right !=null)\\n                sum+=root.left.right.val;\\n            if(root.right !=null && root.right.left !=null)\\n                sum+=root.right.left.val;\\n            if(root.right !=null && root.right.right !=null)\\n                sum+=root.right.right.val;\\n        }\\n        sum += sumEvenGrandparent(root.left) + sumEvenGrandparent(root.right);\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306424,
                "title": "100-beats-pre-order-traversal-o-n-space-and-time-complexity",
                "content": "> # Approach\\nBy pre-order traversal we can explore parent node first and then its child nodes next let\\'s make this as our advantage if parent node is even then sum its grand children node values.\\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\n\\nclass Solution {\\n    static int sum = 0;\\n    public void traverse(TreeNode root){\\n        if(root!=null){\\n            if(root.val%2==0){\\n                if(root.left!=null){\\n                    TreeNode l = root.left.left , r = root.left.right;\\n                    if(l!=null) sum+=l.val;\\n                    if(r!=null) sum+=r.val;\\n                }\\n                if(root.right!=null){\\n                    TreeNode l = root.right.left , r = root.right.right;\\n                    if(l!=null) sum+=l.val;\\n                    if(r!=null) sum+=r.val;\\n                }\\n            }\\n            traverse(root.left);\\n            traverse(root.right);\\n        }\\n    }\\n    public int sumEvenGrandparent(TreeNode root) {\\n        sum = 0;\\n        traverse(root);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    static int sum = 0;\\n    public void traverse(TreeNode root){\\n        if(root!=null){\\n            if(root.val%2==0){\\n                if(root.left!=null){\\n                    TreeNode l = root.left.left , r = root.left.right;\\n                    if(l!=null) sum+=l.val;\\n                    if(r!=null) sum+=r.val;\\n                }\\n                if(root.right!=null){\\n                    TreeNode l = root.right.left , r = root.right.right;\\n                    if(l!=null) sum+=l.val;\\n                    if(r!=null) sum+=r.val;\\n                }\\n            }\\n            traverse(root.left);\\n            traverse(root.right);\\n        }\\n    }\\n    public int sumEvenGrandparent(TreeNode root) {\\n        sum = 0;\\n        traverse(root);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210077,
                "title": "easy-c-solution-100-acceptance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : traversing the tree in any one of the orders like inorder...for each even node find the respective grandchild and sum if it is present in the tree... \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void dfs(TreeNode* root){\\n        if(root!=nullptr){\\n            int t=root->val;\\n            if(t%2==0){\\n                TreeNode* r=root;\\n                if(root->left && root->left->left){\\n                    sum+=r->left->left->val;\\n                }\\n                if(r->left && r->left->right){\\n                    sum+=r->left->right->val;\\n                }\\n                if(r->right && r->right->left){\\n                    sum+=r->right->left->val;\\n                }\\n                if(r->right && r->right->right){\\n                    sum+=r->right->right->val;\\n                }\\n            }\\n            dfs(root->left);\\n            dfs(root->right);\\n        }\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        sum=0;\\n        dfs(root);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void dfs(TreeNode* root){\\n        if(root!=nullptr){\\n            int t=root->val;\\n            if(t%2==0){\\n                TreeNode* r=root;\\n                if(root->left && root->left->left){\\n                    sum+=r->left->left->val;\\n                }\\n                if(r->left && r->left->right){\\n                    sum+=r->left->right->val;\\n                }\\n                if(r->right && r->right->left){\\n                    sum+=r->right->left->val;\\n                }\\n                if(r->right && r->right->right){\\n                    sum+=r->right->right->val;\\n                }\\n            }\\n            dfs(root->left);\\n            dfs(root->right);\\n        }\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        sum=0;\\n        dfs(root);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983983,
                "title": "bfs-super-easy-for-beginners-beats-85",
                "content": "# Intuition\\nBFS to perform a calculation.\\n\\n# Approach\\nTrack nodes that are even and perform a calculation on their grand-children nodes. Return summation. \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def sumEvenGrandparent(self, root):\\n        # Node queue\\n        q = collections.deque([(root,0)])   \\n        ans = 0\\n\\n        # Iterative loop - level order (BFS)\\n        while q:                            \\n            node, cnt  = q.popleft()\\n\\n            # If true must mean parent node was an even number.\\n            # Current node (parent) to its children grandparent was indeed even.\\n            if cnt - 1 == 0: \\n                cnt -= 1\\n                if node.left:\\n                    ans += node.left.val\\n                if node.right:\\n                    ans += node.right.val\\n            \\n            # Even grandparent node here\\n            if node.val % 2 == 0: cnt = 1\\n\\n            # Append children nodes into queue with parent\\'s history (cnt)\\n            if node.left:\\n                q.append((node.left,cnt))\\n            if node.right:\\n                q.append((node.right,cnt))\\n        return ans\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def sumEvenGrandparent(self, root):\\n        # Node queue\\n        q = collections.deque([(root,0)])   \\n        ans = 0\\n\\n        # Iterative loop - level order (BFS)\\n        while q:                            \\n            node, cnt  = q.popleft()\\n\\n            # If true must mean parent node was an even number.\\n            # Current node (parent) to its children grandparent was indeed even.\\n            if cnt - 1 == 0: \\n                cnt -= 1\\n                if node.left:\\n                    ans += node.left.val\\n                if node.right:\\n                    ans += node.right.val\\n            \\n            # Even grandparent node here\\n            if node.val % 2 == 0: cnt = 1\\n\\n            # Append children nodes into queue with parent\\'s history (cnt)\\n            if node.left:\\n                q.append((node.left,cnt))\\n            if node.right:\\n                q.append((node.right,cnt))\\n        return ans\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797780,
                "title": "felt-like-preorder",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int solve(TreeNode* r)\\n    {\\n        if(!r)\\n            return 0;\\n        \\n        int sum = 0;\\n        if(r->val %2 ==0)\\n        {\\n            if(r->left && r->left->left)\\n                sum+=r->left->left->val;\\n            if(r->left && r->left->right)\\n                sum+=r->left->right->val;\\n            \\n            if(r->right && r->right->left)\\n                sum+=r->right->left->val;\\n            if(r->right && r->right->right)\\n                sum+=r->right->right->val;\\n        }\\n        \\n        sum+= (solve(r->left)+ solve(r->right));\\n        return sum;\\n    }\\n    int sumEvenGrandparent(TreeNode* r) {\\n\\n        return solve(r);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int solve(TreeNode* r)\\n    {\\n        if(!r)\\n            return 0;\\n        \\n        int sum = 0;\\n        if(r->val %2 ==0)\\n        {\\n            if(r->left && r->left->left)\\n                sum+=r->left->left->val;\\n            if(r->left && r->left->right)\\n                sum+=r->left->right->val;\\n            \\n            if(r->right && r->right->left)\\n                sum+=r->right->left->val;\\n            if(r->right && r->right->right)\\n                sum+=r->right->right->val;\\n        }\\n        \\n        sum+= (solve(r->left)+ solve(r->right));\\n        return sum;\\n    }\\n    int sumEvenGrandparent(TreeNode* r) {\\n\\n        return solve(r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721107,
                "title": "java-bfs-solution-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        bfs(root);\\n        return sum;\\n    }\\n    public void bfs(TreeNode root)\\n    {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty())\\n        {\\n            for(int i=0;i<q.size();i++)\\n            {\\n                TreeNode node = q.poll();\\n                if(node.left!=null)\\n                    q.add(node.left);\\n                if(node.right!=null)\\n                    q.add(node.right);\\n                \\n                if(node.val%2==0)\\n                {\\n                    if(node.left!=null)\\n                    {\\n                        if(node.left.left!=null)\\n                            sum+=node.left.left.val;\\n                        if(node.left.right!=null)\\n                            sum+=node.left.right.val;\\n                    }\\n                    if(node.right!=null)\\n                    {\\n                        if(node.right.left!=null)\\n                            sum+=node.right.left.val;\\n                        if(node.right.right!=null)\\n                            sum+=node.right.right.val;\\n                    }\\n                }\\n            }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        bfs(root);\\n        return sum;\\n    }\\n    public void bfs(TreeNode root)\\n    {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty())\\n        {\\n            for(int i=0;i<q.size();i++)\\n            {\\n                TreeNode node = q.poll();\\n                if(node.left!=null)\\n                    q.add(node.left);\\n                if(node.right!=null)\\n                    q.add(node.right);\\n                \\n                if(node.val%2==0)\\n                {\\n                    if(node.left!=null)\\n                    {\\n                        if(node.left.left!=null)\\n                            sum+=node.left.left.val;\\n                        if(node.left.right!=null)\\n                            sum+=node.left.right.val;\\n                    }\\n                    if(node.right!=null)\\n                    {\\n                        if(node.right.left!=null)\\n                            sum+=node.right.left.val;\\n                        if(node.right.right!=null)\\n                            sum+=node.right.right.val;\\n                    }\\n                }\\n            }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661289,
                "title": "tim-80-beats-space-90-beats-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void solve(TreeNode* root){\\n        if(root == NULL || (root->left == NULL && root->right == NULL)){\\n            return;\\n        }\\n        if(!(root->val&1)){\\n            if(root->left){\\n            if(root->left->left){\\n                sum += root->left->left->val;\\n            }if(root->left->right){\\n                sum += root->left->right->val;\\n            }}\\n            if(root->right){if(root->right->left){\\n                sum += root->right->left->val;\\n            }if(root->right->right){\\n                sum += root->right->right->val;\\n            }}\\n        }\\n        solve(root->left);        solve(root->right);\\n\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        sum = 0;\\n        solve(root);\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void solve(TreeNode* root){\\n        if(root == NULL || (root->left == NULL && root->right == NULL)){\\n            return;\\n        }\\n        if(!(root->val&1)){\\n            if(root->left){\\n            if(root->left->left){\\n                sum += root->left->left->val;\\n            }if(root->left->right){\\n                sum += root->left->right->val;\\n            }}\\n            if(root->right){if(root->right->left){\\n                sum += root->right->left->val;\\n            }if(root->right->right){\\n                sum += root->right->right->val;\\n            }}\\n        }\\n        solve(root->left);        solve(root->right);\\n\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        sum = 0;\\n        solve(root);\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634319,
                "title": "python-solution-runtime-232-ms-memory-usage-17-9-mb",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        \\n        self.sum_values = 0\\n        \\n        def _sumEvenGrandparent(root):\\n            if root:\\n                if root.val % 2 == 0:\\n                    if root.left:\\n                        if root.left.left:\\n                            self.sum_values += root.left.left.val\\n                        if root.left.right:\\n                            self.sum_values += root.left.right.val\\n                    if root.right:\\n                        if root.right.left:\\n                            self.sum_values += root.right.left.val\\n                        if root.right.right:\\n                            self.sum_values += root.right.right.val\\n                _sumEvenGrandparent(root.left)\\n                _sumEvenGrandparent(root.right)\\n        \\n        _sumEvenGrandparent(root)\\n        \\n        return self.sum_values\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        \\n        self.sum_values = 0\\n        \\n        def _sumEvenGrandparent(root):\\n            if root:\\n                if root.val % 2 == 0:\\n                    if root.left:\\n                        if root.left.left:\\n                            self.sum_values += root.left.left.val\\n                        if root.left.right:\\n                            self.sum_values += root.left.right.val\\n                    if root.right:\\n                        if root.right.left:\\n                            self.sum_values += root.right.left.val\\n                        if root.right.right:\\n                            self.sum_values += root.right.right.val\\n                _sumEvenGrandparent(root.left)\\n                _sumEvenGrandparent(root.right)\\n        \\n        _sumEvenGrandparent(root)\\n        \\n        return self.sum_values\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554102,
                "title": "java-easy-recursion",
                "content": "# Please Upvote if you liked the solution\\n\\n```\\nint res = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        gc(root);\\n        return res;\\n    }\\n    public void gc(TreeNode root){\\n        if(root == null)\\n            return;\\n        if(root.val % 2 == 0 && root.left != null){\\n            res += root.left.left != null ? root.left.left.val : 0;\\n            res += root.left.right != null ? root.left.right.val : 0;\\n        }\\n        gc(root.left);\\n        if(root.val % 2 == 0 && root.right != null){\\n            res += root.right.left != null ? root.right.left.val : 0;\\n            res += root.right.right != null ? root.right.right.val : 0;\\n        }\\n        gc(root.right);\\n    } \\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nint res = 0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        gc(root);\\n        return res;\\n    }\\n    public void gc(TreeNode root){\\n        if(root == null)\\n            return;\\n        if(root.val % 2 == 0 && root.left != null){\\n            res += root.left.left != null ? root.left.left.val : 0;\\n            res += root.left.right != null ? root.left.right.val : 0;\\n        }\\n        gc(root.left);\\n        if(root.val % 2 == 0 && root.right != null){\\n            res += root.right.left != null ? root.right.left.val : 0;\\n            res += root.right.right != null ? root.right.right.val : 0;\\n        }\\n        gc(root.right);\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524482,
                "title": "c-bfs",
                "content": "```\\n int breadthFirstSearch(TreeNode* root){\\n        \\n        int sum=0;\\n        queue<pair<int,TreeNode*>> q;\\n        q.push({0,root});\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                int grandParent=q.front().first;\\n                TreeNode* node=q.front().second;\\n                q.pop();\\n                if(grandParent>0 && grandParent%2==0)\\n                    grandParent=1;\\n                else\\n                    grandParent=0;\\n                if(node->left) {\\n                    q.push({node->val,node->left});\\n                    if(grandParent) sum+=node->left->val;\\n                }\\n                 if(node->right) {\\n                    q.push({node->val,node->right});\\n                    if(grandParent) sum+=node->right->val;\\n                }   \\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int breadthFirstSearch(TreeNode* root){\\n        \\n        int sum=0;\\n        queue<pair<int,TreeNode*>> q;\\n        q.push({0,root});\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                int grandParent=q.front().first;\\n                TreeNode* node=q.front().second;\\n                q.pop();\\n                if(grandParent>0 && grandParent%2==0)\\n                    grandParent=1;\\n                else\\n                    grandParent=0;\\n                if(node->left) {\\n                    q.push({node->val,node->left});\\n                    if(grandParent) sum+=node->left->val;\\n                }\\n                 if(node->right) {\\n                    q.push({node->val,node->right});\\n                    if(grandParent) sum+=node->right->val;\\n                }   \\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2523852,
                "title": "elegant-recursive-solution-do-what-you-think-dfs-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root){\\n        if(root==NULL)\\n            return 0;\\n        int ans = 0;\\n        if(root->val%2==0){\\n            if(root->left && root->left->left)\\n                ans+=root->left->left->val;\\n            if(root->left && root->left->right)\\n                ans+=root->left->right->val;\\n            if(root->right && root->right->right)\\n                ans+=root->right->right->val;\\n            if(root->right && root->right->left)\\n                ans+=root->right->left->val;\\n        }\\n        return ans + dfs(root->left) + dfs(root->right);\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        return dfs(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root){\\n        if(root==NULL)\\n            return 0;\\n        int ans = 0;\\n        if(root->val%2==0){\\n            if(root->left && root->left->left)\\n                ans+=root->left->left->val;\\n            if(root->left && root->left->right)\\n                ans+=root->left->right->val;\\n            if(root->right && root->right->right)\\n                ans+=root->right->right->val;\\n            if(root->right && root->right->left)\\n                ans+=root->right->left->val;\\n        }\\n        return ans + dfs(root->left) + dfs(root->right);\\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        return dfs(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513118,
                "title": "c-dfs-maintain-a-parent-variable",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void helper(TreeNode* root,int par)\\n    {\\n        if(root == NULL){\\n            return;\\n        }\\n        if(par%2==0){\\n            \\n            if(root->left)sum += root->left->val;\\n            if(root->right)sum += root->right->val;\\n        }\\n        helper(root->left,root->val);\\n        helper(root->right,root->val);\\n        \\n        \\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        \\n        helper(root,1);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void helper(TreeNode* root,int par)\\n    {\\n        if(root == NULL){\\n            return;\\n        }\\n        if(par%2==0){\\n            \\n            if(root->left)sum += root->left->val;\\n            if(root->right)sum += root->right->val;\\n        }\\n        helper(root->left,root->val);\\n        helper(root->right,root->val);\\n        \\n        \\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        \\n        helper(root,1);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485484,
                "title": "python-simple-recursion-90-fast",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        \\n        ans = 0\\n        \\n        def rec(node, parent, grandParent):\\n            nonlocal ans\\n            if node is None:\\n                return\\n            if grandParent and grandParent.val % 2 == 0:\\n                ans += node.val\\n            rec(node.left, node, parent)\\n            rec(node.right, node, parent)\\n        \\n        rec(root, None, None)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        \\n        ans = 0\\n        \\n        def rec(node, parent, grandParent):\\n            nonlocal ans\\n            if node is None:\\n                return\\n            if grandParent and grandParent.val % 2 == 0:\\n                ans += node.val\\n            rec(node.left, node, parent)\\n            rec(node.right, node, parent)\\n        \\n        rec(root, None, None)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474720,
                "title": "java-recursive-soluntion-o-n-solved",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        int ans=0;\\n        if(root==null)return ans;\\n        if(root.val%2==0) {\\n            if(root.left!=null&&root.left.left!=null) {\\n                ans+=root.left.left.val;\\n            }\\n            if(root.left!=null&&root.left.right!=null) {\\n                ans+=root.left.right.val;\\n            }\\n            if(root.right!=null&&root.right.left!=null) {\\n                ans+=root.right.left.val;\\n            }\\n            if(root.right!=null&&root.right.right!=null) {\\n                ans+=root.right.right.val;\\n            }\\n        }\\n        ans+=sumEvenGrandparent(root.left);\\n        ans+=sumEvenGrandparent(root.right);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumEvenGrandparent(TreeNode root) {\\n        int ans=0;\\n        if(root==null)return ans;\\n        if(root.val%2==0) {\\n            if(root.left!=null&&root.left.left!=null) {\\n                ans+=root.left.left.val;\\n            }\\n            if(root.left!=null&&root.left.right!=null) {\\n                ans+=root.left.right.val;\\n            }\\n            if(root.right!=null&&root.right.left!=null) {\\n                ans+=root.right.left.val;\\n            }\\n            if(root.right!=null&&root.right.right!=null) {\\n                ans+=root.right.right.val;\\n            }\\n        }\\n        ans+=sumEvenGrandparent(root.left);\\n        ans+=sumEvenGrandparent(root.right);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472935,
                "title": "easy-dfs",
                "content": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n      dfs(root);\\n        return sum;\\n    }\\n    public void dfs(TreeNode root)\\n    {\\n        if(root==null)\\n        {\\n            return;\\n        }\\n        if(root.val%2==0)\\n        {\\n            if(root.left!=null&&root.left.left!=null)\\n            {\\n                  sum += root.left.left.val;           \\n            }\\n            if(root.left!=null&&root.left.right!=null)\\n            {\\n                  sum += root.left.right.val;           \\n            }\\n            if(root.right!=null&&root.right.left!=null)\\n            {\\n                  sum += root.right.left.val;           \\n            }\\n            if(root.right!=null&&root.right.right!=null)\\n            {\\n                  sum += root.right.right.val;           \\n            }\\n        }\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumEvenGrandparent(TreeNode root) {\\n      dfs(root);\\n        return sum;\\n    }\\n    public void dfs(TreeNode root)\\n    {\\n        if(root==null)\\n        {\\n            return;\\n        }\\n        if(root.val%2==0)\\n        {\\n            if(root.left!=null&&root.left.left!=null)\\n            {\\n                  sum += root.left.left.val;           \\n            }\\n            if(root.left!=null&&root.left.right!=null)\\n            {\\n                  sum += root.left.right.val;           \\n            }\\n            if(root.right!=null&&root.right.left!=null)\\n            {\\n                  sum += root.right.left.val;           \\n            }\\n            if(root.right!=null&&root.right.right!=null)\\n            {\\n                  sum += root.right.right.val;           \\n            }\\n        }\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468586,
                "title": "c-easy-to-understand-inorder",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void solve(TreeNode*root,TreeNode*parent,TreeNode*grandParent)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        solve(root->left,root,parent);\\n        \\n        if(grandParent and grandParent->val%2==0)\\n            ans+=root->val;\\n        \\n        solve(root->right,root,parent);\\n        \\n        \\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        solve(root,NULL,NULL);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void solve(TreeNode*root,TreeNode*parent,TreeNode*grandParent)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        solve(root->left,root,parent);\\n        \\n        if(grandParent and grandParent->val%2==0)\\n            ans+=root->val;\\n        \\n        solve(root->right,root,parent);\\n        \\n        \\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        solve(root,NULL,NULL);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461334,
                "title": "javascript-recursion",
                "content": "```\\nvar sumEvenGrandparent = function(root) {\\n    let total = 0;\\n    let go = (node, pe, gpe) => {\\n        if (!node) return;\\n        if (gpe) total += node.val;\\n        let isEven = node.val % 2 === 0;\\n        go(node.left, isEven, pe);\\n        go(node.right, isEven, pe);\\n    }\\n    go(root, false, false);\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sumEvenGrandparent = function(root) {\\n    let total = 0;\\n    let go = (node, pe, gpe) => {\\n        if (!node) return;\\n        if (gpe) total += node.val;\\n        let isEven = node.val % 2 === 0;\\n        go(node.left, isEven, pe);\\n        go(node.right, isEven, pe);\\n    }\\n    go(root, false, false);\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2412741,
                "title": "c-simple-bfs-easy-to-understand",
                "content": "Understand Points To Solve Question\\n1. if node value is even than we check that it have grand kid or not\\n2. if node is odd value than we just add it\\'s existing child to queue for further operation\\n3. if node has evenvalue than we add its every grandchild (if exist) value to answer\\n4. every node have only 4 grandchild exist left and right child of root\\'s left child and root\\'s right child\\n\\n\\n![image](https://assets.leetcode.com/users/images/a41515d2-67df-4479-89dc-fbd1a9f5d3ea_1660246395.6111116.png)\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "Understand Points To Solve Question\\n1. if node value is even than we check that it have grand kid or not\\n2. if node is odd value than we just add it\\'s existing child to queue for further operation\\n3. if node has evenvalue than we add its every grandchild (if exist) value to answer\\n4. every node have only 4 grandchild exist left and right child of root\\'s left child and root\\'s right child\\n\\n\\n![image](https://assets.leetcode.com/users/images/a41515d2-67df-4479-89dc-fbd1a9f5d3ea_1660246395.6111116.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2403275,
                "title": "dfs-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    int sum = 0;\\n    \\n    public int sumEvenGrandparent(TreeNode root) {\\n        \\n        dfs(root, null, null);\\n        return sum;\\n    }\\n    \\n    public void dfs(TreeNode root, TreeNode parent, TreeNode gparent) {\\n        if (root == null) return;\\n        \\n        if (gparent != null && gparent.val % 2 == 0) {\\n            sum += root.val;\\n        }\\n        \\n        if (root.left != null) {\\n            dfs(root.left, root, parent);\\n        }\\n        \\n        if (root.right != null) {\\n            dfs(root.right, root, parent);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int sum = 0;\\n    \\n    public int sumEvenGrandparent(TreeNode root) {\\n        \\n        dfs(root, null, null);\\n        return sum;\\n    }\\n    \\n    public void dfs(TreeNode root, TreeNode parent, TreeNode gparent) {\\n        if (root == null) return;\\n        \\n        if (gparent != null && gparent.val % 2 == 0) {\\n            sum += root.val;\\n        }\\n        \\n        if (root.left != null) {\\n            dfs(root.left, root, parent);\\n        }\\n        \\n        if (root.right != null) {\\n            dfs(root.right, root, parent);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354321,
                "title": "c-simple-recursion-o-n",
                "content": "``` \\nint check(TreeNode* root, bool &parent, bool &gparent)\\n    {\\n        if(root==NULL) return 0;\\n        bool curr = false;\\n        if(root->val%2==0) curr = true;\\n        int sum = check(root->left, curr, parent);\\n        sum+=check(root->right, curr, parent);\\n        return gparent == false ? sum : sum+root->val;\\n        \\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        bool f1 = false, f2= false;\\n       return check(root, f1, f2);\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "``` \\nint check(TreeNode* root, bool &parent, bool &gparent)\\n    {\\n        if(root==NULL) return 0;\\n        bool curr = false;\\n        if(root->val%2==0) curr = true;\\n        int sum = check(root->left, curr, parent);\\n        sum+=check(root->right, curr, parent);\\n        return gparent == false ? sum : sum+root->val;\\n        \\n    }\\n    int sumEvenGrandparent(TreeNode* root) {\\n        bool f1 = false, f2= false;\\n       return check(root, f1, f2);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2331024,
                "title": "easy-to-understand-c-better-than-one-liner-self-explainatory",
                "content": "class Solution {\\npublic:\\n    \\n    int sum=0;\\n    \\n    void util(TreeNode* root){\\n        if(root==NULL) return;\\n        if(root->val%2==0){\\n            if(root->left!=NULL){\\n                if(root->left->left!=NULL) sum+=root->left->left->val;\\n                if(root->left->right!=NULL) sum+=root->left->right->val;\\n            }\\n            \\n            if(root->right!=NULL){\\n                if(root->right->left!=NULL) sum+=root->right->left->val;\\n                if(root->right->right!=NULL) sum+=root->right->right->val;\\n            }\\n            \\n        }\\n        \\n        util(root->left);\\n        util(root->right);\\n        \\n    }\\n    \\n    int sumEvenGrandparent(TreeNode* root) {\\n        util(root);  \\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int sum=0;\\n    \\n    void util(TreeNode* root){\\n        if(root==NULL) return;\\n        if(root->val%2==0){\\n            if(root->left!=NULL){\\n                if(root->left->left!=NULL) sum+=root->left->left->val;\\n                if(root->left->right!=NULL) sum+=root->left->right->val;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2329403,
                "title": "easiest-solution-to-understand-beats-90-beginner-dfs-solution",
                "content": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        evenGrandParent = []\\n        \\n        def dfs(node, parent=None, grandParent=None):\\n            if node is None:\\n                return\\n            \\n            if grandParent and grandParent % 2 == 0:\\n                nonlocal evenGrandParent\\n                evenGrandParent.append(node.val)\\n            \\n            dfs(node.right, node.val, parent)\\n            dfs(node.left, node.val, parent)\\n        \\n        \\n        dfs(root)\\n        \\n        return sum(evenGrandParent)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        evenGrandParent = []\\n        \\n        def dfs(node, parent=None, grandParent=None):\\n            if node is None:\\n                return\\n            \\n            if grandParent and grandParent % 2 == 0:\\n                nonlocal evenGrandParent\\n                evenGrandParent.append(node.val)\\n            \\n            dfs(node.right, node.val, parent)\\n            dfs(node.left, node.val, parent)\\n        \\n        \\n        dfs(root)\\n        \\n        return sum(evenGrandParent)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297418,
                "title": "c-simple-recursive",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int ans;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        dfs(root,NULL,NULL);\\n        return ans;\\n    }\\n    void dfs(TreeNode *root, TreeNode *par, TreeNode *gpar) {\\n        if (!root) return;\\n        dfs(root->left, root, par);\\n        dfs(root->right, root, par);\\n        if (gpar) ans += (root->val * (gpar->val % 2 == 0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int ans;\\n    int sumEvenGrandparent(TreeNode* root) {\\n        dfs(root,NULL,NULL);\\n        return ans;\\n    }\\n    void dfs(TreeNode *root, TreeNode *par, TreeNode *gpar) {\\n        if (!root) return;\\n        dfs(root->left, root, par);\\n        dfs(root->right, root, par);\\n        if (gpar) ans += (root->val * (gpar->val % 2 == 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290046,
                "title": "dfs-7-lines-of-code-2ms-detailed-explanation-java-python",
                "content": "# Idea\\nWhile processing any node we only care about 3 things :-\\n1. If the current node is even -> Then we tell our children that their parent is even.\\n2. If the current node\\'s parent is even -> Then we tell our children that their grand-parent is even.\\n3. If the current node\\'s grand-parent is even -> We include our value in the total sum, don\\'t need to tell our children about anything here.\\n\\nTo communicate these three things we just need to pass 3 variables in our recursive dfs function call :-\\n1. Current node to be processed (TreeNode)\\n2. If parent was even (Boolean)\\n3. If grand parent was even (Boolean)\\n\\nInitial call will be made on the root node and both it\\'s grand-parent and parent are **not** even (as they do not exist).\\n\\n**Time Complexity - O(N) {For processing each node}\\nSpace Complexity - O(H) {Height of the Tree/recursion call stack}**\\n\\nImplementing this in java takes only 7 lines of actual code\\n\\n**Java Solution**\\n```\\nclass Solution {\\n    int result = 0;\\n    \\n    public int sumEvenGrandparent(TreeNode root) {\\n        dfs(root, false, false);\\n        return this.result;\\n    }\\n    \\n    public void dfs(TreeNode node, boolean grandParentisEven, boolean ParentisEven){\\n        \\n        if(node==null) return;\\n        \\n        if(grandParentisEven) this.result += node.val;\\n        \\n\\t\\t//if parent is even we are telling our children that their grand parent is even\\n\\t\\t//if we are even we are telling our children that their parent is even\\n        dfs(node.left, ParentisEven, node.val%2==0);\\n        dfs(node.right, ParentisEven, node.val%2==0);\\n    }\\n}\\n```\\n\\n**Python Solution**\\n```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        \\n        result = 0\\n        \\n        def dfs(node, grandParentIsEven, ParentIsEven):\\n            nonlocal result\\n            if node==None:\\n                return\\n            if grandParentIsEven:\\n                result += node.val\\n            dfs(node.left, ParentIsEven, node.val%2==0)\\n            dfs(node.right, ParentIsEven, node.val%2==0)\\n        \\n        dfs(root, False, False)\\n        return result\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n    \\n    public int sumEvenGrandparent(TreeNode root) {\\n        dfs(root, false, false);\\n        return this.result;\\n    }\\n    \\n    public void dfs(TreeNode node, boolean grandParentisEven, boolean ParentisEven){\\n        \\n        if(node==null) return;\\n        \\n        if(grandParentisEven) this.result += node.val;\\n        \\n\\t\\t//if parent is even we are telling our children that their grand parent is even\\n\\t\\t//if we are even we are telling our children that their parent is even\\n        dfs(node.left, ParentisEven, node.val%2==0);\\n        dfs(node.right, ParentisEven, node.val%2==0);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        \\n        result = 0\\n        \\n        def dfs(node, grandParentIsEven, ParentIsEven):\\n            nonlocal result\\n            if node==None:\\n                return\\n            if grandParentIsEven:\\n                result += node.val\\n            dfs(node.left, ParentIsEven, node.val%2==0)\\n            dfs(node.right, ParentIsEven, node.val%2==0)\\n        \\n        dfs(root, False, False)\\n        return result\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574196,
                "content": [
                    {
                        "username": "jakemraz",
                        "content": "[50,null,54,98,6,null,null,null,34]\\n\\nHow can \\'null\\' has children 98 and 6?\\nI think it doesn\\'t make sense.\\n\\nHow do you think of this?\\n\\nTest case says it\\'s expected output is 138"
                    },
                    {
                        "username": "chickooo",
                        "content": "Create the tree from left to right with each node having only 2 child nodes.\n\nIn your case tree looks like this:\n\n```\n        50\n      /    \\\n     _      54\n          /    \\\n       '98'     '6'\n                  \\\n                  '34'\n```\n\ntherefore total is 98 + 6 + 34 = 138"
                    },
                    {
                        "username": "Piyush_Patil917",
                        "content": "98 is left child of 54, use tree visualizer in the console for better understanding"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "When I see it initially feels like a  difficult one .. \\nGood tree question \\nUse DFS wisely\\uD83D\\uDE4C"
                    },
                    {
                        "username": "tusharsaxena803",
                        "content": "The hint is pretty much the solution. \\n"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "if you are struggling with this and are frustrated with the *this is easy* comments, don\\'t worry, you\\'re doing good. As for a tip for this problem, just code out the brute force (in a DFS) thats in your head. Code out exactly how you are solving this in your head. If you\\'re still stuck, I have a solution posted with 100% Beats"
                    },
                    {
                        "username": "user5410Mr",
                        "content": " i think you need this:- \\nfirst  prev , grandParent =  null;\\n \\ninside the traversal function;-\\ngrandParent = prev;\\nprev = root;"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am pissed, has 85% acceptance rate, 50% people in discussion calling it easy and its been 5 minutes and I can\\'t figure out how to do BFS on this because of the 2 and 7"
                    },
                    {
                        "username": "alice0217",
                        "content": "Don\\'t know if you have figured it out but if you want to use BFS, you can put root into the queue if it\\'s not null. Process the queue if it\\'s not empty. For every node, if the value is even, add its grandchildren\\'s values (left.left.val, left.right.val, right.left.val, and right.right.val, just remember to check null). Then, no matter if the node\\'s value is even or odd, add its left and right subtree to the queue and it will do the same thing. "
                    },
                    {
                        "username": "District_12",
                        "content": "How is right most node with a value of 5 has the same even-valued grandparent as red nodes?"
                    },
                    {
                        "username": "Movsar",
                        "content": "because it\\'s grandparent is 8"
                    },
                    {
                        "username": "Aviral_3",
                        "content": "How to solve it iteratively"
                    },
                    {
                        "username": "Plasticc",
                        "content": "Recursion is effectively just iteration with a stack. Your call stack for the example would look something like this in a dfs solution:\\n\\ndfs(n=6, p=null, gp=null)\\ndfs(n=7, p=6, gp=null)\\ndfs(n=7, p=7, gp=6)\\n\\nSo start with a stack that\\'s just tuples of the same state, i.e. for the root it\\'s (root, null, null), then in your iterative loop you just pop a node off and then do your math and then push the children on the stack: (node.left, node, parent) and (node.right, node, parent)."
                    },
                    {
                        "username": "venkatsc",
                        "content": "Do BFS traversal and sum?\n\n<pre>\n public int sumEvenGrandparent(TreeNode root) {\n    int sum = 0;\n    List<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n      int size = queue.size();\n      while (size-- > 0) {\n        TreeNode node = queue.remove(0);\n        if (node.val % 2 == 0) {\n          if (node.left != null && node.left.left != null)\n            sum += node.left.left.val;\n          if (node.left != null && node.left.right != null)\n            sum += node.left.right.val;\n          if (node.right != null && node.right.left != null)\n            sum += node.right.left.val;\n          if (node.right != null && node.right.right != null)\n            sum += node.right.right.val;\n        }\n        if (node.left != null) {\n          queue.add(node.left);\n        }\n        if (node.right != null) {\n          queue.add(node.right);\n        }\n      }\n    }\n    return sum;\n  }\n</pre>"
                    },
                    {
                        "username": "geekyshark",
                        "content": "If this ain\\'t marked easy, i don\\'t know what will"
                    }
                ]
            },
            {
                "id": 1993156,
                "content": [
                    {
                        "username": "jakemraz",
                        "content": "[50,null,54,98,6,null,null,null,34]\\n\\nHow can \\'null\\' has children 98 and 6?\\nI think it doesn\\'t make sense.\\n\\nHow do you think of this?\\n\\nTest case says it\\'s expected output is 138"
                    },
                    {
                        "username": "chickooo",
                        "content": "Create the tree from left to right with each node having only 2 child nodes.\n\nIn your case tree looks like this:\n\n```\n        50\n      /    \\\n     _      54\n          /    \\\n       '98'     '6'\n                  \\\n                  '34'\n```\n\ntherefore total is 98 + 6 + 34 = 138"
                    },
                    {
                        "username": "Piyush_Patil917",
                        "content": "98 is left child of 54, use tree visualizer in the console for better understanding"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "When I see it initially feels like a  difficult one .. \\nGood tree question \\nUse DFS wisely\\uD83D\\uDE4C"
                    },
                    {
                        "username": "tusharsaxena803",
                        "content": "The hint is pretty much the solution. \\n"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "if you are struggling with this and are frustrated with the *this is easy* comments, don\\'t worry, you\\'re doing good. As for a tip for this problem, just code out the brute force (in a DFS) thats in your head. Code out exactly how you are solving this in your head. If you\\'re still stuck, I have a solution posted with 100% Beats"
                    },
                    {
                        "username": "user5410Mr",
                        "content": " i think you need this:- \\nfirst  prev , grandParent =  null;\\n \\ninside the traversal function;-\\ngrandParent = prev;\\nprev = root;"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am pissed, has 85% acceptance rate, 50% people in discussion calling it easy and its been 5 minutes and I can\\'t figure out how to do BFS on this because of the 2 and 7"
                    },
                    {
                        "username": "alice0217",
                        "content": "Don\\'t know if you have figured it out but if you want to use BFS, you can put root into the queue if it\\'s not null. Process the queue if it\\'s not empty. For every node, if the value is even, add its grandchildren\\'s values (left.left.val, left.right.val, right.left.val, and right.right.val, just remember to check null). Then, no matter if the node\\'s value is even or odd, add its left and right subtree to the queue and it will do the same thing. "
                    },
                    {
                        "username": "District_12",
                        "content": "How is right most node with a value of 5 has the same even-valued grandparent as red nodes?"
                    },
                    {
                        "username": "Movsar",
                        "content": "because it\\'s grandparent is 8"
                    },
                    {
                        "username": "Aviral_3",
                        "content": "How to solve it iteratively"
                    },
                    {
                        "username": "Plasticc",
                        "content": "Recursion is effectively just iteration with a stack. Your call stack for the example would look something like this in a dfs solution:\\n\\ndfs(n=6, p=null, gp=null)\\ndfs(n=7, p=6, gp=null)\\ndfs(n=7, p=7, gp=6)\\n\\nSo start with a stack that\\'s just tuples of the same state, i.e. for the root it\\'s (root, null, null), then in your iterative loop you just pop a node off and then do your math and then push the children on the stack: (node.left, node, parent) and (node.right, node, parent)."
                    },
                    {
                        "username": "venkatsc",
                        "content": "Do BFS traversal and sum?\n\n<pre>\n public int sumEvenGrandparent(TreeNode root) {\n    int sum = 0;\n    List<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n      int size = queue.size();\n      while (size-- > 0) {\n        TreeNode node = queue.remove(0);\n        if (node.val % 2 == 0) {\n          if (node.left != null && node.left.left != null)\n            sum += node.left.left.val;\n          if (node.left != null && node.left.right != null)\n            sum += node.left.right.val;\n          if (node.right != null && node.right.left != null)\n            sum += node.right.left.val;\n          if (node.right != null && node.right.right != null)\n            sum += node.right.right.val;\n        }\n        if (node.left != null) {\n          queue.add(node.left);\n        }\n        if (node.right != null) {\n          queue.add(node.right);\n        }\n      }\n    }\n    return sum;\n  }\n</pre>"
                    },
                    {
                        "username": "geekyshark",
                        "content": "If this ain\\'t marked easy, i don\\'t know what will"
                    }
                ]
            },
            {
                "id": 2062970,
                "content": [
                    {
                        "username": "jakemraz",
                        "content": "[50,null,54,98,6,null,null,null,34]\\n\\nHow can \\'null\\' has children 98 and 6?\\nI think it doesn\\'t make sense.\\n\\nHow do you think of this?\\n\\nTest case says it\\'s expected output is 138"
                    },
                    {
                        "username": "chickooo",
                        "content": "Create the tree from left to right with each node having only 2 child nodes.\n\nIn your case tree looks like this:\n\n```\n        50\n      /    \\\n     _      54\n          /    \\\n       '98'     '6'\n                  \\\n                  '34'\n```\n\ntherefore total is 98 + 6 + 34 = 138"
                    },
                    {
                        "username": "Piyush_Patil917",
                        "content": "98 is left child of 54, use tree visualizer in the console for better understanding"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "When I see it initially feels like a  difficult one .. \\nGood tree question \\nUse DFS wisely\\uD83D\\uDE4C"
                    },
                    {
                        "username": "tusharsaxena803",
                        "content": "The hint is pretty much the solution. \\n"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "if you are struggling with this and are frustrated with the *this is easy* comments, don\\'t worry, you\\'re doing good. As for a tip for this problem, just code out the brute force (in a DFS) thats in your head. Code out exactly how you are solving this in your head. If you\\'re still stuck, I have a solution posted with 100% Beats"
                    },
                    {
                        "username": "user5410Mr",
                        "content": " i think you need this:- \\nfirst  prev , grandParent =  null;\\n \\ninside the traversal function;-\\ngrandParent = prev;\\nprev = root;"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am pissed, has 85% acceptance rate, 50% people in discussion calling it easy and its been 5 minutes and I can\\'t figure out how to do BFS on this because of the 2 and 7"
                    },
                    {
                        "username": "alice0217",
                        "content": "Don\\'t know if you have figured it out but if you want to use BFS, you can put root into the queue if it\\'s not null. Process the queue if it\\'s not empty. For every node, if the value is even, add its grandchildren\\'s values (left.left.val, left.right.val, right.left.val, and right.right.val, just remember to check null). Then, no matter if the node\\'s value is even or odd, add its left and right subtree to the queue and it will do the same thing. "
                    },
                    {
                        "username": "District_12",
                        "content": "How is right most node with a value of 5 has the same even-valued grandparent as red nodes?"
                    },
                    {
                        "username": "Movsar",
                        "content": "because it\\'s grandparent is 8"
                    },
                    {
                        "username": "Aviral_3",
                        "content": "How to solve it iteratively"
                    },
                    {
                        "username": "Plasticc",
                        "content": "Recursion is effectively just iteration with a stack. Your call stack for the example would look something like this in a dfs solution:\\n\\ndfs(n=6, p=null, gp=null)\\ndfs(n=7, p=6, gp=null)\\ndfs(n=7, p=7, gp=6)\\n\\nSo start with a stack that\\'s just tuples of the same state, i.e. for the root it\\'s (root, null, null), then in your iterative loop you just pop a node off and then do your math and then push the children on the stack: (node.left, node, parent) and (node.right, node, parent)."
                    },
                    {
                        "username": "venkatsc",
                        "content": "Do BFS traversal and sum?\n\n<pre>\n public int sumEvenGrandparent(TreeNode root) {\n    int sum = 0;\n    List<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n      int size = queue.size();\n      while (size-- > 0) {\n        TreeNode node = queue.remove(0);\n        if (node.val % 2 == 0) {\n          if (node.left != null && node.left.left != null)\n            sum += node.left.left.val;\n          if (node.left != null && node.left.right != null)\n            sum += node.left.right.val;\n          if (node.right != null && node.right.left != null)\n            sum += node.right.left.val;\n          if (node.right != null && node.right.right != null)\n            sum += node.right.right.val;\n        }\n        if (node.left != null) {\n          queue.add(node.left);\n        }\n        if (node.right != null) {\n          queue.add(node.right);\n        }\n      }\n    }\n    return sum;\n  }\n</pre>"
                    },
                    {
                        "username": "geekyshark",
                        "content": "If this ain\\'t marked easy, i don\\'t know what will"
                    }
                ]
            },
            {
                "id": 2058218,
                "content": [
                    {
                        "username": "jakemraz",
                        "content": "[50,null,54,98,6,null,null,null,34]\\n\\nHow can \\'null\\' has children 98 and 6?\\nI think it doesn\\'t make sense.\\n\\nHow do you think of this?\\n\\nTest case says it\\'s expected output is 138"
                    },
                    {
                        "username": "chickooo",
                        "content": "Create the tree from left to right with each node having only 2 child nodes.\n\nIn your case tree looks like this:\n\n```\n        50\n      /    \\\n     _      54\n          /    \\\n       '98'     '6'\n                  \\\n                  '34'\n```\n\ntherefore total is 98 + 6 + 34 = 138"
                    },
                    {
                        "username": "Piyush_Patil917",
                        "content": "98 is left child of 54, use tree visualizer in the console for better understanding"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "When I see it initially feels like a  difficult one .. \\nGood tree question \\nUse DFS wisely\\uD83D\\uDE4C"
                    },
                    {
                        "username": "tusharsaxena803",
                        "content": "The hint is pretty much the solution. \\n"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "if you are struggling with this and are frustrated with the *this is easy* comments, don\\'t worry, you\\'re doing good. As for a tip for this problem, just code out the brute force (in a DFS) thats in your head. Code out exactly how you are solving this in your head. If you\\'re still stuck, I have a solution posted with 100% Beats"
                    },
                    {
                        "username": "user5410Mr",
                        "content": " i think you need this:- \\nfirst  prev , grandParent =  null;\\n \\ninside the traversal function;-\\ngrandParent = prev;\\nprev = root;"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am pissed, has 85% acceptance rate, 50% people in discussion calling it easy and its been 5 minutes and I can\\'t figure out how to do BFS on this because of the 2 and 7"
                    },
                    {
                        "username": "alice0217",
                        "content": "Don\\'t know if you have figured it out but if you want to use BFS, you can put root into the queue if it\\'s not null. Process the queue if it\\'s not empty. For every node, if the value is even, add its grandchildren\\'s values (left.left.val, left.right.val, right.left.val, and right.right.val, just remember to check null). Then, no matter if the node\\'s value is even or odd, add its left and right subtree to the queue and it will do the same thing. "
                    },
                    {
                        "username": "District_12",
                        "content": "How is right most node with a value of 5 has the same even-valued grandparent as red nodes?"
                    },
                    {
                        "username": "Movsar",
                        "content": "because it\\'s grandparent is 8"
                    },
                    {
                        "username": "Aviral_3",
                        "content": "How to solve it iteratively"
                    },
                    {
                        "username": "Plasticc",
                        "content": "Recursion is effectively just iteration with a stack. Your call stack for the example would look something like this in a dfs solution:\\n\\ndfs(n=6, p=null, gp=null)\\ndfs(n=7, p=6, gp=null)\\ndfs(n=7, p=7, gp=6)\\n\\nSo start with a stack that\\'s just tuples of the same state, i.e. for the root it\\'s (root, null, null), then in your iterative loop you just pop a node off and then do your math and then push the children on the stack: (node.left, node, parent) and (node.right, node, parent)."
                    },
                    {
                        "username": "venkatsc",
                        "content": "Do BFS traversal and sum?\n\n<pre>\n public int sumEvenGrandparent(TreeNode root) {\n    int sum = 0;\n    List<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n      int size = queue.size();\n      while (size-- > 0) {\n        TreeNode node = queue.remove(0);\n        if (node.val % 2 == 0) {\n          if (node.left != null && node.left.left != null)\n            sum += node.left.left.val;\n          if (node.left != null && node.left.right != null)\n            sum += node.left.right.val;\n          if (node.right != null && node.right.left != null)\n            sum += node.right.left.val;\n          if (node.right != null && node.right.right != null)\n            sum += node.right.right.val;\n        }\n        if (node.left != null) {\n          queue.add(node.left);\n        }\n        if (node.right != null) {\n          queue.add(node.right);\n        }\n      }\n    }\n    return sum;\n  }\n</pre>"
                    },
                    {
                        "username": "geekyshark",
                        "content": "If this ain\\'t marked easy, i don\\'t know what will"
                    }
                ]
            },
            {
                "id": 2056042,
                "content": [
                    {
                        "username": "jakemraz",
                        "content": "[50,null,54,98,6,null,null,null,34]\\n\\nHow can \\'null\\' has children 98 and 6?\\nI think it doesn\\'t make sense.\\n\\nHow do you think of this?\\n\\nTest case says it\\'s expected output is 138"
                    },
                    {
                        "username": "chickooo",
                        "content": "Create the tree from left to right with each node having only 2 child nodes.\n\nIn your case tree looks like this:\n\n```\n        50\n      /    \\\n     _      54\n          /    \\\n       '98'     '6'\n                  \\\n                  '34'\n```\n\ntherefore total is 98 + 6 + 34 = 138"
                    },
                    {
                        "username": "Piyush_Patil917",
                        "content": "98 is left child of 54, use tree visualizer in the console for better understanding"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "When I see it initially feels like a  difficult one .. \\nGood tree question \\nUse DFS wisely\\uD83D\\uDE4C"
                    },
                    {
                        "username": "tusharsaxena803",
                        "content": "The hint is pretty much the solution. \\n"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "if you are struggling with this and are frustrated with the *this is easy* comments, don\\'t worry, you\\'re doing good. As for a tip for this problem, just code out the brute force (in a DFS) thats in your head. Code out exactly how you are solving this in your head. If you\\'re still stuck, I have a solution posted with 100% Beats"
                    },
                    {
                        "username": "user5410Mr",
                        "content": " i think you need this:- \\nfirst  prev , grandParent =  null;\\n \\ninside the traversal function;-\\ngrandParent = prev;\\nprev = root;"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am pissed, has 85% acceptance rate, 50% people in discussion calling it easy and its been 5 minutes and I can\\'t figure out how to do BFS on this because of the 2 and 7"
                    },
                    {
                        "username": "alice0217",
                        "content": "Don\\'t know if you have figured it out but if you want to use BFS, you can put root into the queue if it\\'s not null. Process the queue if it\\'s not empty. For every node, if the value is even, add its grandchildren\\'s values (left.left.val, left.right.val, right.left.val, and right.right.val, just remember to check null). Then, no matter if the node\\'s value is even or odd, add its left and right subtree to the queue and it will do the same thing. "
                    },
                    {
                        "username": "District_12",
                        "content": "How is right most node with a value of 5 has the same even-valued grandparent as red nodes?"
                    },
                    {
                        "username": "Movsar",
                        "content": "because it\\'s grandparent is 8"
                    },
                    {
                        "username": "Aviral_3",
                        "content": "How to solve it iteratively"
                    },
                    {
                        "username": "Plasticc",
                        "content": "Recursion is effectively just iteration with a stack. Your call stack for the example would look something like this in a dfs solution:\\n\\ndfs(n=6, p=null, gp=null)\\ndfs(n=7, p=6, gp=null)\\ndfs(n=7, p=7, gp=6)\\n\\nSo start with a stack that\\'s just tuples of the same state, i.e. for the root it\\'s (root, null, null), then in your iterative loop you just pop a node off and then do your math and then push the children on the stack: (node.left, node, parent) and (node.right, node, parent)."
                    },
                    {
                        "username": "venkatsc",
                        "content": "Do BFS traversal and sum?\n\n<pre>\n public int sumEvenGrandparent(TreeNode root) {\n    int sum = 0;\n    List<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n      int size = queue.size();\n      while (size-- > 0) {\n        TreeNode node = queue.remove(0);\n        if (node.val % 2 == 0) {\n          if (node.left != null && node.left.left != null)\n            sum += node.left.left.val;\n          if (node.left != null && node.left.right != null)\n            sum += node.left.right.val;\n          if (node.right != null && node.right.left != null)\n            sum += node.right.left.val;\n          if (node.right != null && node.right.right != null)\n            sum += node.right.right.val;\n        }\n        if (node.left != null) {\n          queue.add(node.left);\n        }\n        if (node.right != null) {\n          queue.add(node.right);\n        }\n      }\n    }\n    return sum;\n  }\n</pre>"
                    },
                    {
                        "username": "geekyshark",
                        "content": "If this ain\\'t marked easy, i don\\'t know what will"
                    }
                ]
            },
            {
                "id": 2026251,
                "content": [
                    {
                        "username": "jakemraz",
                        "content": "[50,null,54,98,6,null,null,null,34]\\n\\nHow can \\'null\\' has children 98 and 6?\\nI think it doesn\\'t make sense.\\n\\nHow do you think of this?\\n\\nTest case says it\\'s expected output is 138"
                    },
                    {
                        "username": "chickooo",
                        "content": "Create the tree from left to right with each node having only 2 child nodes.\n\nIn your case tree looks like this:\n\n```\n        50\n      /    \\\n     _      54\n          /    \\\n       '98'     '6'\n                  \\\n                  '34'\n```\n\ntherefore total is 98 + 6 + 34 = 138"
                    },
                    {
                        "username": "Piyush_Patil917",
                        "content": "98 is left child of 54, use tree visualizer in the console for better understanding"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "When I see it initially feels like a  difficult one .. \\nGood tree question \\nUse DFS wisely\\uD83D\\uDE4C"
                    },
                    {
                        "username": "tusharsaxena803",
                        "content": "The hint is pretty much the solution. \\n"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "if you are struggling with this and are frustrated with the *this is easy* comments, don\\'t worry, you\\'re doing good. As for a tip for this problem, just code out the brute force (in a DFS) thats in your head. Code out exactly how you are solving this in your head. If you\\'re still stuck, I have a solution posted with 100% Beats"
                    },
                    {
                        "username": "user5410Mr",
                        "content": " i think you need this:- \\nfirst  prev , grandParent =  null;\\n \\ninside the traversal function;-\\ngrandParent = prev;\\nprev = root;"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am pissed, has 85% acceptance rate, 50% people in discussion calling it easy and its been 5 minutes and I can\\'t figure out how to do BFS on this because of the 2 and 7"
                    },
                    {
                        "username": "alice0217",
                        "content": "Don\\'t know if you have figured it out but if you want to use BFS, you can put root into the queue if it\\'s not null. Process the queue if it\\'s not empty. For every node, if the value is even, add its grandchildren\\'s values (left.left.val, left.right.val, right.left.val, and right.right.val, just remember to check null). Then, no matter if the node\\'s value is even or odd, add its left and right subtree to the queue and it will do the same thing. "
                    },
                    {
                        "username": "District_12",
                        "content": "How is right most node with a value of 5 has the same even-valued grandparent as red nodes?"
                    },
                    {
                        "username": "Movsar",
                        "content": "because it\\'s grandparent is 8"
                    },
                    {
                        "username": "Aviral_3",
                        "content": "How to solve it iteratively"
                    },
                    {
                        "username": "Plasticc",
                        "content": "Recursion is effectively just iteration with a stack. Your call stack for the example would look something like this in a dfs solution:\\n\\ndfs(n=6, p=null, gp=null)\\ndfs(n=7, p=6, gp=null)\\ndfs(n=7, p=7, gp=6)\\n\\nSo start with a stack that\\'s just tuples of the same state, i.e. for the root it\\'s (root, null, null), then in your iterative loop you just pop a node off and then do your math and then push the children on the stack: (node.left, node, parent) and (node.right, node, parent)."
                    },
                    {
                        "username": "venkatsc",
                        "content": "Do BFS traversal and sum?\n\n<pre>\n public int sumEvenGrandparent(TreeNode root) {\n    int sum = 0;\n    List<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n      int size = queue.size();\n      while (size-- > 0) {\n        TreeNode node = queue.remove(0);\n        if (node.val % 2 == 0) {\n          if (node.left != null && node.left.left != null)\n            sum += node.left.left.val;\n          if (node.left != null && node.left.right != null)\n            sum += node.left.right.val;\n          if (node.right != null && node.right.left != null)\n            sum += node.right.left.val;\n          if (node.right != null && node.right.right != null)\n            sum += node.right.right.val;\n        }\n        if (node.left != null) {\n          queue.add(node.left);\n        }\n        if (node.right != null) {\n          queue.add(node.right);\n        }\n      }\n    }\n    return sum;\n  }\n</pre>"
                    },
                    {
                        "username": "geekyshark",
                        "content": "If this ain\\'t marked easy, i don\\'t know what will"
                    }
                ]
            },
            {
                "id": 1799307,
                "content": [
                    {
                        "username": "jakemraz",
                        "content": "[50,null,54,98,6,null,null,null,34]\\n\\nHow can \\'null\\' has children 98 and 6?\\nI think it doesn\\'t make sense.\\n\\nHow do you think of this?\\n\\nTest case says it\\'s expected output is 138"
                    },
                    {
                        "username": "chickooo",
                        "content": "Create the tree from left to right with each node having only 2 child nodes.\n\nIn your case tree looks like this:\n\n```\n        50\n      /    \\\n     _      54\n          /    \\\n       '98'     '6'\n                  \\\n                  '34'\n```\n\ntherefore total is 98 + 6 + 34 = 138"
                    },
                    {
                        "username": "Piyush_Patil917",
                        "content": "98 is left child of 54, use tree visualizer in the console for better understanding"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "When I see it initially feels like a  difficult one .. \\nGood tree question \\nUse DFS wisely\\uD83D\\uDE4C"
                    },
                    {
                        "username": "tusharsaxena803",
                        "content": "The hint is pretty much the solution. \\n"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "if you are struggling with this and are frustrated with the *this is easy* comments, don\\'t worry, you\\'re doing good. As for a tip for this problem, just code out the brute force (in a DFS) thats in your head. Code out exactly how you are solving this in your head. If you\\'re still stuck, I have a solution posted with 100% Beats"
                    },
                    {
                        "username": "user5410Mr",
                        "content": " i think you need this:- \\nfirst  prev , grandParent =  null;\\n \\ninside the traversal function;-\\ngrandParent = prev;\\nprev = root;"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am pissed, has 85% acceptance rate, 50% people in discussion calling it easy and its been 5 minutes and I can\\'t figure out how to do BFS on this because of the 2 and 7"
                    },
                    {
                        "username": "alice0217",
                        "content": "Don\\'t know if you have figured it out but if you want to use BFS, you can put root into the queue if it\\'s not null. Process the queue if it\\'s not empty. For every node, if the value is even, add its grandchildren\\'s values (left.left.val, left.right.val, right.left.val, and right.right.val, just remember to check null). Then, no matter if the node\\'s value is even or odd, add its left and right subtree to the queue and it will do the same thing. "
                    },
                    {
                        "username": "District_12",
                        "content": "How is right most node with a value of 5 has the same even-valued grandparent as red nodes?"
                    },
                    {
                        "username": "Movsar",
                        "content": "because it\\'s grandparent is 8"
                    },
                    {
                        "username": "Aviral_3",
                        "content": "How to solve it iteratively"
                    },
                    {
                        "username": "Plasticc",
                        "content": "Recursion is effectively just iteration with a stack. Your call stack for the example would look something like this in a dfs solution:\\n\\ndfs(n=6, p=null, gp=null)\\ndfs(n=7, p=6, gp=null)\\ndfs(n=7, p=7, gp=6)\\n\\nSo start with a stack that\\'s just tuples of the same state, i.e. for the root it\\'s (root, null, null), then in your iterative loop you just pop a node off and then do your math and then push the children on the stack: (node.left, node, parent) and (node.right, node, parent)."
                    },
                    {
                        "username": "venkatsc",
                        "content": "Do BFS traversal and sum?\n\n<pre>\n public int sumEvenGrandparent(TreeNode root) {\n    int sum = 0;\n    List<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n      int size = queue.size();\n      while (size-- > 0) {\n        TreeNode node = queue.remove(0);\n        if (node.val % 2 == 0) {\n          if (node.left != null && node.left.left != null)\n            sum += node.left.left.val;\n          if (node.left != null && node.left.right != null)\n            sum += node.left.right.val;\n          if (node.right != null && node.right.left != null)\n            sum += node.right.left.val;\n          if (node.right != null && node.right.right != null)\n            sum += node.right.right.val;\n        }\n        if (node.left != null) {\n          queue.add(node.left);\n        }\n        if (node.right != null) {\n          queue.add(node.right);\n        }\n      }\n    }\n    return sum;\n  }\n</pre>"
                    },
                    {
                        "username": "geekyshark",
                        "content": "If this ain\\'t marked easy, i don\\'t know what will"
                    }
                ]
            },
            {
                "id": 1737174,
                "content": [
                    {
                        "username": "jakemraz",
                        "content": "[50,null,54,98,6,null,null,null,34]\\n\\nHow can \\'null\\' has children 98 and 6?\\nI think it doesn\\'t make sense.\\n\\nHow do you think of this?\\n\\nTest case says it\\'s expected output is 138"
                    },
                    {
                        "username": "chickooo",
                        "content": "Create the tree from left to right with each node having only 2 child nodes.\n\nIn your case tree looks like this:\n\n```\n        50\n      /    \\\n     _      54\n          /    \\\n       '98'     '6'\n                  \\\n                  '34'\n```\n\ntherefore total is 98 + 6 + 34 = 138"
                    },
                    {
                        "username": "Piyush_Patil917",
                        "content": "98 is left child of 54, use tree visualizer in the console for better understanding"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "When I see it initially feels like a  difficult one .. \\nGood tree question \\nUse DFS wisely\\uD83D\\uDE4C"
                    },
                    {
                        "username": "tusharsaxena803",
                        "content": "The hint is pretty much the solution. \\n"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "if you are struggling with this and are frustrated with the *this is easy* comments, don\\'t worry, you\\'re doing good. As for a tip for this problem, just code out the brute force (in a DFS) thats in your head. Code out exactly how you are solving this in your head. If you\\'re still stuck, I have a solution posted with 100% Beats"
                    },
                    {
                        "username": "user5410Mr",
                        "content": " i think you need this:- \\nfirst  prev , grandParent =  null;\\n \\ninside the traversal function;-\\ngrandParent = prev;\\nprev = root;"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am pissed, has 85% acceptance rate, 50% people in discussion calling it easy and its been 5 minutes and I can\\'t figure out how to do BFS on this because of the 2 and 7"
                    },
                    {
                        "username": "alice0217",
                        "content": "Don\\'t know if you have figured it out but if you want to use BFS, you can put root into the queue if it\\'s not null. Process the queue if it\\'s not empty. For every node, if the value is even, add its grandchildren\\'s values (left.left.val, left.right.val, right.left.val, and right.right.val, just remember to check null). Then, no matter if the node\\'s value is even or odd, add its left and right subtree to the queue and it will do the same thing. "
                    },
                    {
                        "username": "District_12",
                        "content": "How is right most node with a value of 5 has the same even-valued grandparent as red nodes?"
                    },
                    {
                        "username": "Movsar",
                        "content": "because it\\'s grandparent is 8"
                    },
                    {
                        "username": "Aviral_3",
                        "content": "How to solve it iteratively"
                    },
                    {
                        "username": "Plasticc",
                        "content": "Recursion is effectively just iteration with a stack. Your call stack for the example would look something like this in a dfs solution:\\n\\ndfs(n=6, p=null, gp=null)\\ndfs(n=7, p=6, gp=null)\\ndfs(n=7, p=7, gp=6)\\n\\nSo start with a stack that\\'s just tuples of the same state, i.e. for the root it\\'s (root, null, null), then in your iterative loop you just pop a node off and then do your math and then push the children on the stack: (node.left, node, parent) and (node.right, node, parent)."
                    },
                    {
                        "username": "venkatsc",
                        "content": "Do BFS traversal and sum?\n\n<pre>\n public int sumEvenGrandparent(TreeNode root) {\n    int sum = 0;\n    List<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n      int size = queue.size();\n      while (size-- > 0) {\n        TreeNode node = queue.remove(0);\n        if (node.val % 2 == 0) {\n          if (node.left != null && node.left.left != null)\n            sum += node.left.left.val;\n          if (node.left != null && node.left.right != null)\n            sum += node.left.right.val;\n          if (node.right != null && node.right.left != null)\n            sum += node.right.left.val;\n          if (node.right != null && node.right.right != null)\n            sum += node.right.right.val;\n        }\n        if (node.left != null) {\n          queue.add(node.left);\n        }\n        if (node.right != null) {\n          queue.add(node.right);\n        }\n      }\n    }\n    return sum;\n  }\n</pre>"
                    },
                    {
                        "username": "geekyshark",
                        "content": "If this ain\\'t marked easy, i don\\'t know what will"
                    }
                ]
            },
            {
                "id": 1999018,
                "content": [
                    {
                        "username": "jakemraz",
                        "content": "[50,null,54,98,6,null,null,null,34]\\n\\nHow can \\'null\\' has children 98 and 6?\\nI think it doesn\\'t make sense.\\n\\nHow do you think of this?\\n\\nTest case says it\\'s expected output is 138"
                    },
                    {
                        "username": "chickooo",
                        "content": "Create the tree from left to right with each node having only 2 child nodes.\n\nIn your case tree looks like this:\n\n```\n        50\n      /    \\\n     _      54\n          /    \\\n       '98'     '6'\n                  \\\n                  '34'\n```\n\ntherefore total is 98 + 6 + 34 = 138"
                    },
                    {
                        "username": "Piyush_Patil917",
                        "content": "98 is left child of 54, use tree visualizer in the console for better understanding"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "When I see it initially feels like a  difficult one .. \\nGood tree question \\nUse DFS wisely\\uD83D\\uDE4C"
                    },
                    {
                        "username": "tusharsaxena803",
                        "content": "The hint is pretty much the solution. \\n"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "if you are struggling with this and are frustrated with the *this is easy* comments, don\\'t worry, you\\'re doing good. As for a tip for this problem, just code out the brute force (in a DFS) thats in your head. Code out exactly how you are solving this in your head. If you\\'re still stuck, I have a solution posted with 100% Beats"
                    },
                    {
                        "username": "user5410Mr",
                        "content": " i think you need this:- \\nfirst  prev , grandParent =  null;\\n \\ninside the traversal function;-\\ngrandParent = prev;\\nprev = root;"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am pissed, has 85% acceptance rate, 50% people in discussion calling it easy and its been 5 minutes and I can\\'t figure out how to do BFS on this because of the 2 and 7"
                    },
                    {
                        "username": "alice0217",
                        "content": "Don\\'t know if you have figured it out but if you want to use BFS, you can put root into the queue if it\\'s not null. Process the queue if it\\'s not empty. For every node, if the value is even, add its grandchildren\\'s values (left.left.val, left.right.val, right.left.val, and right.right.val, just remember to check null). Then, no matter if the node\\'s value is even or odd, add its left and right subtree to the queue and it will do the same thing. "
                    },
                    {
                        "username": "District_12",
                        "content": "How is right most node with a value of 5 has the same even-valued grandparent as red nodes?"
                    },
                    {
                        "username": "Movsar",
                        "content": "because it\\'s grandparent is 8"
                    },
                    {
                        "username": "Aviral_3",
                        "content": "How to solve it iteratively"
                    },
                    {
                        "username": "Plasticc",
                        "content": "Recursion is effectively just iteration with a stack. Your call stack for the example would look something like this in a dfs solution:\\n\\ndfs(n=6, p=null, gp=null)\\ndfs(n=7, p=6, gp=null)\\ndfs(n=7, p=7, gp=6)\\n\\nSo start with a stack that\\'s just tuples of the same state, i.e. for the root it\\'s (root, null, null), then in your iterative loop you just pop a node off and then do your math and then push the children on the stack: (node.left, node, parent) and (node.right, node, parent)."
                    },
                    {
                        "username": "venkatsc",
                        "content": "Do BFS traversal and sum?\n\n<pre>\n public int sumEvenGrandparent(TreeNode root) {\n    int sum = 0;\n    List<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n      int size = queue.size();\n      while (size-- > 0) {\n        TreeNode node = queue.remove(0);\n        if (node.val % 2 == 0) {\n          if (node.left != null && node.left.left != null)\n            sum += node.left.left.val;\n          if (node.left != null && node.left.right != null)\n            sum += node.left.right.val;\n          if (node.right != null && node.right.left != null)\n            sum += node.right.left.val;\n          if (node.right != null && node.right.right != null)\n            sum += node.right.right.val;\n        }\n        if (node.left != null) {\n          queue.add(node.left);\n        }\n        if (node.right != null) {\n          queue.add(node.right);\n        }\n      }\n    }\n    return sum;\n  }\n</pre>"
                    },
                    {
                        "username": "geekyshark",
                        "content": "If this ain\\'t marked easy, i don\\'t know what will"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Minimum Time to Finish All Jobs",
        "question_content": "<p>You are given an integer array <code>jobs</code>, where <code>jobs[i]</code> is the amount of time it takes to complete the <code>i<sup>th</sup></code> job.</p>\n\n<p>There are <code>k</code> workers that you can assign jobs to. Each job should be assigned to <strong>exactly</strong> one worker. The <strong>working time</strong> of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the <strong>maximum working time</strong> of any worker is <strong>minimized</strong>.</p>\n\n<p><em>Return the <strong>minimum</strong> possible <strong>maximum working time</strong> of any assignment. </em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> jobs = [3,2,3], k = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> By assigning each person one job, the maximum time is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> jobs = [1,2,4,7,8], k = 2\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> Assign the jobs the following way:\nWorker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)\nWorker 2: 4, 7 (working time = 4 + 7 = 11)\nThe maximum working time is 11.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= jobs.length &lt;= 12</code></li>\n\t<li><code>1 &lt;= jobs[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1009817,
                "title": "one-branch-cutting-trick-to-solve-three-leetcode-questions",
                "content": "\\nIt is easy to get TLE, so how should we cut some branches and speed up the searching process?\\nWe use an array of length n to record the workload assigned to each worker.\\n\\nThe core idea is that assume at certain point of dfs searching, \\nwe have the following workload for 10 workers,\\nworkers = [10, 5, 5, 5, 5, 5, 5, 5, 5, 5]\\n\\nif we want to assign the current task jobs[curr] to someone,\\nit makes no difference if we assign it to any worker whose current workload is 5.\\nTherefore we can use a set named seen to store searched workload such that we only search 5 once.\\n\\nThere is also another branch cutting step, if the total workload is already larger than self.res,\\nwe can exit the dfs search, too.\\n\\nAnother trick is to reverse sort all the jobs so that we are more likely to exit earlier.\\n\\nTwo other similar questions are \\nhttps://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\n\\n\\n\\n# this question\\n    class Solution:\\n        def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n            workers = [0]*k\\n            \\n            self.res = sys.maxsize\\n            # jobs.sort(reverse = True)\\n            def dfs(curr):\\n                if curr == len(jobs):\\n                    self.res = min(self.res, max(workers))\\n                    return\\n                \\n                seen = set() # record searched workload of workers\\n                for i in range(k):\\n                    if workers[i] in seen: continue # if we have searched the workload of 5, skip it.\\n                    if workers[i] + jobs[curr] >= self.res: continue # another branch cutting\\n                    seen.add(workers[i])\\n                    workers[i] += jobs[curr]\\n                    dfs(curr+1)\\n                    workers[i] -= jobs[curr]\\n            \\n            dfs(0)\\n            return self.res\\n                \\n\\n# 473. Matchsticks to Square\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\n\\n    class Solution:\\n        def makesquare(self, nums):\\n            if len(nums) < 4 or sum(nums) % 4 != 0 or max(nums) > sum(nums) // 4:\\n                return False\\n            target = sum(nums)//4\\n    \\n            nums.sort(reverse = True)\\n            edge = [0]*4\\n    \\n            def dfs(index):\\n                if index == len(nums):\\n                    return True\\n                seen = [] # record the searched matchstick lengths\\n                for i in range(4):\\n                    if edge[i] in seen: continue\\n                    if edge[i] + nums[index] <= target:\\n                        seen.append(edge[i])\\n                        edge[i] += nums[index]\\n                        if dfs(index + 1):\\n                            return True\\n                        edge[i] -= nums[index]\\n                return False\\n    \\n            return dfs(0)\\n    \\n# 698. Partition to K Equal Sum Subsets\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/        \\n\\n    class Solution:\\n        def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\\n            if len(nums) < k or sum(nums) % k != 0 or max(nums) > sum(nums) // k:\\n                return False\\n            target = sum(nums)//k\\n    \\n            nums.sort(reverse = True)\\n            edge = [0]*k\\n    \\n            def dfs(index):\\n                if index == len(nums):\\n                    return True\\n                seen = [] # record the searched summ\\n                for i in range(k):\\n                    if edge[i] in seen: continue\\n                    if edge[i] + nums[index] <= target:\\n                        seen.append(edge[i])\\n                        edge[i] += nums[index]\\n                        if dfs(index + 1):\\n                            return True\\n                        edge[i] -= nums[index]\\n                return False\\n    \\n            return dfs(0)",
                "solutionTags": [],
                "code": "\\nIt is easy to get TLE, so how should we cut some branches and speed up the searching process?\\nWe use an array of length n to record the workload assigned to each worker.\\n\\nThe core idea is that assume at certain point of dfs searching, \\nwe have the following workload for 10 workers,\\nworkers = [10, 5, 5, 5, 5, 5, 5, 5, 5, 5]\\n\\nif we want to assign the current task jobs[curr] to someone,\\nit makes no difference if we assign it to any worker whose current workload is 5.\\nTherefore we can use a set named seen to store searched workload such that we only search 5 once.\\n\\nThere is also another branch cutting step, if the total workload is already larger than self.res,\\nwe can exit the dfs search, too.\\n\\nAnother trick is to reverse sort all the jobs so that we are more likely to exit earlier.\\n\\nTwo other similar questions are \\nhttps://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\n\\n\\n\\n# this question\\n    class Solution:\\n        def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n            workers = [0]*k\\n            \\n            self.res = sys.maxsize\\n            # jobs.sort(reverse = True)\\n            def dfs(curr):\\n                if curr == len(jobs):\\n                    self.res = min(self.res, max(workers))\\n                    return\\n                \\n                seen = set() # record searched workload of workers\\n                for i in range(k):\\n                    if workers[i] in seen: continue # if we have searched the workload of 5, skip it.\\n                    if workers[i] + jobs[curr] >= self.res: continue # another branch cutting\\n                    seen.add(workers[i])\\n                    workers[i] += jobs[curr]\\n                    dfs(curr+1)\\n                    workers[i] -= jobs[curr]\\n            \\n            dfs(0)\\n            return self.res\\n                \\n\\n# 473. Matchsticks to Square\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\n\\n    class Solution:\\n        def makesquare(self, nums):\\n            if len(nums) < 4 or sum(nums) % 4 != 0 or max(nums) > sum(nums) // 4:\\n                return False\\n            target = sum(nums)//4\\n    \\n            nums.sort(reverse = True)\\n            edge = [0]*4\\n    \\n            def dfs(index):\\n                if index == len(nums):\\n                    return True\\n                seen = [] # record the searched matchstick lengths\\n                for i in range(4):\\n                    if edge[i] in seen: continue\\n                    if edge[i] + nums[index] <= target:\\n                        seen.append(edge[i])\\n                        edge[i] += nums[index]\\n                        if dfs(index + 1):\\n                            return True\\n                        edge[i] -= nums[index]\\n                return False\\n    \\n            return dfs(0)\\n    \\n# 698. Partition to K Equal Sum Subsets\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/        \\n\\n    class Solution:\\n        def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\\n            if len(nums) < k or sum(nums) % k != 0 or max(nums) > sum(nums) // k:\\n                return False\\n            target = sum(nums)//k\\n    \\n            nums.sort(reverse = True)\\n            edge = [0]*k\\n    \\n            def dfs(index):\\n                if index == len(nums):\\n                    return True\\n                seen = [] # record the searched summ\\n                for i in range(k):\\n                    if edge[i] in seen: continue\\n                    if edge[i] + nums[index] <= target:\\n                        seen.append(edge[i])\\n                        edge[i] += nums[index]\\n                        if dfs(index + 1):\\n                            return True\\n                        edge[i] -= nums[index]\\n                return False\\n    \\n            return dfs(0)",
                "codeTag": "Java"
            },
            {
                "id": 1010057,
                "title": "java-python-binary-search-100",
                "content": "# **Solution 1: DFS**\\nOptimization 1:\\nwe assign the most time consuming job first.\\n\\nOptimization 2:\\nAssign a job to totally free worker only once.\\n\\nOptimization 3:\\nUpdate the res and don\\'t go forward if work load already >= result\\n\\n**Python**\\n```py\\n    def minimumTimeRequired(self, A, k):\\n        n = len(A)\\n        A.sort(reverse=True) # opt 1\\n        self.res = sum(A)\\n        count = [0] * k\\n\\n        def dfs(i):\\n            if i == n:\\n                self.res = min(self.res, max(count))\\n                return\\n            for j in xrange(k):\\n                if count[j] + A[i] < self.res: # opt 3\\n                    count[j] += A[i]\\n                    dfs(i + 1)\\n                    count[j] -= A[i]\\n                if count[j] == 0: break # opt 2\\n            return False\\n        dfs(0)\\n        return self.res\\n```\\n<br>\\n\\n# **Solution 2: Bianry search**\\nThe problem of the first solution,\\nis that the upper bound reduce not quick enough.\\nApply binary search, to reduce the upper bound more quickly.\\n\\n**Java**\\nall by @blackspinner\\n```java\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        Arrays.sort(jobs);\\n        int n = jobs.length;\\n        int left = jobs[n - 1];\\n        int right = jobs[n - 1] * n;\\n        while (left < right) {\\n            int[] cap = new int[k];\\n            int mid = left + (right - left) / 2;\\n            Arrays.fill(cap, mid);\\n            if (dfs(jobs, cap, n - 1, k, mid)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    private boolean dfs(int[] jobs, int[] cap, int i, int k, int x) {\\n        if (i == -1) {\\n            return true;\\n        }\\n        for (int j = 0; j < k; j++) {\\n            if (cap[j] >= jobs[i]) {\\n                cap[j] -= jobs[i];\\n                if (dfs(jobs, cap, i - 1, k, x)) {\\n                    return true;\\n                }\\n                cap[j] += jobs[i];\\n            }\\n            if (cap[j] == x) {\\n                break;\\n            }\\n        }\\n        return false;\\n    }\\n```\\n**Python, 24ms:**\\n```py\\n    def minimumTimeRequired(self, A, k):\\n        n = len(A)\\n        A.sort(reverse=True) # opt 1\\n\\n        def dfs(i):\\n            if i == n: return True # opt 3\\n            for j in xrange(k):\\n                if cap[j] >= A[i]:\\n                    cap[j] -= A[i]\\n                    if dfs(i + 1): return True\\n                    cap[j] += A[i]\\n                if cap[j] == x: break # opt 2\\n            return False\\n\\n        # binary search\\n        left, right = max(A), sum(A)\\n        while left < right:\\n            x = (left + right) / 2\\n            cap = [x] * k\\n            if dfs(0):\\n                right = x\\n            else:\\n                left = x + 1\\n        return left\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def minimumTimeRequired(self, A, k):\\n        n = len(A)\\n        A.sort(reverse=True) # opt 1\\n        self.res = sum(A)\\n        count = [0] * k\\n\\n        def dfs(i):\\n            if i == n:\\n                self.res = min(self.res, max(count))\\n                return\\n            for j in xrange(k):\\n                if count[j] + A[i] < self.res: # opt 3\\n                    count[j] += A[i]\\n                    dfs(i + 1)\\n                    count[j] -= A[i]\\n                if count[j] == 0: break # opt 2\\n            return False\\n        dfs(0)\\n        return self.res\\n```\n```java\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        Arrays.sort(jobs);\\n        int n = jobs.length;\\n        int left = jobs[n - 1];\\n        int right = jobs[n - 1] * n;\\n        while (left < right) {\\n            int[] cap = new int[k];\\n            int mid = left + (right - left) / 2;\\n            Arrays.fill(cap, mid);\\n            if (dfs(jobs, cap, n - 1, k, mid)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    private boolean dfs(int[] jobs, int[] cap, int i, int k, int x) {\\n        if (i == -1) {\\n            return true;\\n        }\\n        for (int j = 0; j < k; j++) {\\n            if (cap[j] >= jobs[i]) {\\n                cap[j] -= jobs[i];\\n                if (dfs(jobs, cap, i - 1, k, x)) {\\n                    return true;\\n                }\\n                cap[j] += jobs[i];\\n            }\\n            if (cap[j] == x) {\\n                break;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```py\\n    def minimumTimeRequired(self, A, k):\\n        n = len(A)\\n        A.sort(reverse=True) # opt 1\\n\\n        def dfs(i):\\n            if i == n: return True # opt 3\\n            for j in xrange(k):\\n                if cap[j] >= A[i]:\\n                    cap[j] -= A[i]\\n                    if dfs(i + 1): return True\\n                    cap[j] += A[i]\\n                if cap[j] == x: break # opt 2\\n            return False\\n\\n        # binary search\\n        left, right = max(A), sum(A)\\n        while left < right:\\n            x = (left + right) / 2\\n            cap = [x] * k\\n            if dfs(0):\\n                right = x\\n            else:\\n                left = x + 1\\n        return left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1009785,
                "title": "c-dp-with-explanation",
                "content": "We can use bitmap to represent a subset of the jobs. Define `dp[i][b]` as the answer for assigning a subset `b` of the jobs to `i` workers, and `sum[b]` as the total working time of the subset `b`. Then we have `dp[i][b] = min{max(dp[i-1][tb], sum[b-tb]) where tb is a subset of b}`, i.e, by enumerating how we are going to assign the jobs to the first of the `i` workers and the rest `i-1` workers.\\n\\nTime complexity: O(3^n*n)  (See https://cp-algorithms.com/algebra/all-submasks.html for analysis).\\n\\ncode:\\n```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        const int n = jobs.size();\\n        \\n        vector<int> sums(1<<n);\\n        for (int b = 0; b < (1<<n); ++b) {\\n            for (int i = 0; i < n; ++i) {\\n                if ((1<<i) & b) sums[b] += jobs[i]; \\n            }    \\n        }\\n        \\n        vector<vector<int>> dp(k+1, vector<int>(1<<n));\\n        for (int b = 0; b < (1<<n); ++b) dp[1][b] = sums[b];\\n        for (int i = 2; i <= k; ++i) {\\n            for (int b = 1; b < (1<<n); ++b) {\\n                dp[i][b] = dp[i-1][b];\\n                for (int tb = b; tb; tb = (tb-1)&b) {\\n                    dp[i][b] = min(dp[i][b], max(sums[tb], dp[i-1][b-tb]));\\n                }\\n            }\\n        }\\n        return dp[k][(1<<n)-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        const int n = jobs.size();\\n        \\n        vector<int> sums(1<<n);\\n        for (int b = 0; b < (1<<n); ++b) {\\n            for (int i = 0; i < n; ++i) {\\n                if ((1<<i) & b) sums[b] += jobs[i]; \\n            }    \\n        }\\n        \\n        vector<vector<int>> dp(k+1, vector<int>(1<<n));\\n        for (int b = 0; b < (1<<n); ++b) dp[1][b] = sums[b];\\n        for (int i = 2; i <= k; ++i) {\\n            for (int b = 1; b < (1<<n); ++b) {\\n                dp[i][b] = dp[i-1][b];\\n                for (int tb = b; tb; tb = (tb-1)&b) {\\n                    dp[i][b] = min(dp[i][b], max(sums[tb], dp[i-1][b-tb]));\\n                }\\n            }\\n        }\\n        return dp[k][(1<<n)-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009768,
                "title": "c-0ms-use-greedy-to-prune",
                "content": "This is multi-knapsack problem, which is NP-complete. Thus, the tight constraint (`k <= 12`).\\n\\nSo, we need to do the full search, but we can speed it up a little:\\n- Track the current best result and use it to prune.\\n- If two or more workers have the same working time, we only need to consider one of them.\\n\\nThe last optimization helps a lot, and we can just use a hash set to track the working time. \\n\\n> Update. I originally had the sorting but later removed as the solution got accepted without it. \\n\\nIn order to prune more efficiently, we can sort the jobs in the descending order, and calculate a greedy result, which should be a great start.\\n\\n```cpp\\nint worker[12] = {}, res = 0;\\nint dfs(vector<int>& jobs, int i, int k, int cur) {\\n    if (cur >= res)\\n        return res;\\n    if (i == jobs.size())\\n        return res = cur;\\n    unordered_set<int> workTime;\\n    for (auto j = 0; j < k; ++j) {\\n        if (!workTime.insert(worker[j]).second)\\n            continue;\\n        worker[j] += jobs[i];\\n        dfs(jobs, i + 1, k, max(cur, worker[j]));\\n        worker[j] -= jobs[i];\\n    }\\n    return res;\\n}\\nint minimumTimeRequired(vector<int>& jobs, int k) {\\n    if (k == jobs.size())\\n        return *max_element(begin(jobs), end(jobs));\\n    sort(begin(jobs), end(jobs), greater<int>());\\n    for (int i = 0; i < jobs.size(); i += k)\\n        res += jobs[i];\\n    return dfs(jobs, 0, k, 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint worker[12] = {}, res = 0;\\nint dfs(vector<int>& jobs, int i, int k, int cur) {\\n    if (cur >= res)\\n        return res;\\n    if (i == jobs.size())\\n        return res = cur;\\n    unordered_set<int> workTime;\\n    for (auto j = 0; j < k; ++j) {\\n        if (!workTime.insert(worker[j]).second)\\n            continue;\\n        worker[j] += jobs[i];\\n        dfs(jobs, i + 1, k, max(cur, worker[j]));\\n        worker[j] -= jobs[i];\\n    }\\n    return res;\\n}\\nint minimumTimeRequired(vector<int>& jobs, int k) {\\n    if (k == jobs.size())\\n        return *max_element(begin(jobs), end(jobs));\\n    sort(begin(jobs), end(jobs), greater<int>());\\n    for (int i = 0; i < jobs.size(); i += k)\\n        res += jobs[i];\\n    return dfs(jobs, 0, k, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1010451,
                "title": "python-2-solutions-o-2-n-n-log-m-and-o-3-n-k-explained",
                "content": "Not the fastest solution in python, but I think it is clean and it is easy to estimate its complexity.\\n\\nLet us try to answer the following question first: given `basket` : working time for each worker, question is if we can allocate workers in such way, that each of them spend `<= basket` time. For example, if we have `jobs = [1, 2, 3, 5, 7]`, and `basket = 8`, then we can allocate workers as `[1, 7], [3, 5], [2]` and we need at least `3` workers here.\\n\\nLet `dfs(mask, basket)` be function with parameters:\\n1. `mask` is binary mask of already used jobs\\n2. `basket` is how many time each of workers can spend\\n3. Answer will be tuple of numbers: first one is `minimum number of workers` and second one is how much time last worker already spent.\\n\\nLet us discuss, how this function works in more details:\\n1. If `mask = 0`, then we can state that we need at least `1` worker and he spent `0` time.\\n2. For each `j in range(N)`, if we have this job inside bitmask, we look at all `dfs(mask - (1 << j), basket)`. We need to add jub number `j` now. If it happen, that we can not allocate it to the last worker, we need to hire one more worker. If we can, we allocate job to him.\\n3. Finaly, we return `min` over all possible last jobs we can make.\\n\\n**Why this is working**. It is similar to Travelling Salesman Problem (TSP). It is also similar to problem **698** Partition to K Equal Sum Subsets. Idea is that it is always enough to have only bitmask of already visited jobs, not order.\\n\\nSo far we are able to answer question: given `basket`, how many workers we need to hire to finish all jobs. We need to find minimum value of `basket`, such that there will be `k` workers enough. Ideal choice here is binary search.\\n\\n**Complexity**: we have `2^n` masks and `O(n)` transitions from one mask, so complexity of one run of `dfs` for given `basket` is `O(n*2^n)`. We run it `O(log M)` times, where `M` is sum of all `jobs`, so final time complexity is `2^n*n*log(M)`. Space complexity in given code is `2^n*log(M)`, which can be easily reduced to `2^n`.\\n\\n**Further thought** As far as I aware, there is also `O(k*3^n)` complexity solution, I will code it later, but I think it will give TLE in python. There are also a lot of dfs solution with different pruning techniques, that are pretty good and working 5-50 times faster, depending on how you prune, but will you be able to explain complexity of those solution to interviewer?\\n\\n```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs, k):\\n        N = len(jobs)\\n        \\n        @lru_cache(None)\\n        def dfs(mask, basket):\\n            if mask == 0: return (1, 0)\\n            ans = (float(\"inf\"), float(\"inf\"))\\n            for j in range(N):\\n                if mask & (1<<j):\\n                    pieces, last = dfs(mask - (1 << j), basket)\\n                    full = (last + jobs[j] > basket)\\n                    ans = min(ans, (pieces + full, jobs[j] + (1-full)*last))  \\n            return ans \\n\\n        beg, end = max(jobs), sum(jobs)\\n        while beg < end:\\n            mid = (beg + end)//2\\n            if dfs((1<<N) - 1, mid)[0] >= k + 1:\\n                beg = mid + 1\\n            else:\\n                end = mid\\n        \\n        return beg\\n```\\n\\n#### Solution 2\\nWe can also work with submasks: let the state be `mask` of available jobs and `k` is index of person. Then each time when we choose new person we need to look at all possible submasks. However we need to be careful and use a bit of prunning: without it in python we will get TLE: we check `if cost[submask] >= ret: continue`, that is do early stopping if cost of submask is more than score of mask, we do not consider this option.\\n\\n#### Complexity\\nTime complexity is `O(3^n * m)`, space complexity is `O(2^n * m)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minimumTimeRequired(self, jobs, k):\\n        n = len(jobs)\\n        cost = [0]*(1<<n)\\n        for mask, j in product(range(1<<n), range(n)):\\n            cost[mask] += jobs[j] * ((mask >> j) & 1)\\n        \\n        @lru_cache(None)\\n        def dp(mask, k):\\n            if k == 1:\\n                return cost[mask]\\n            submask, ret = mask, cost[mask]\\n            while (submask-1) & mask:\\n                submask = (submask-1) & mask\\n                if cost[submask] >= ret: continue\\n                ret = min(ret, max(cost[submask], dp(mask^submask, k-1)))\\n                \\n            return ret\\n        \\n        return dp((1<<n) - 1, k)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs, k):\\n        N = len(jobs)\\n        \\n        @lru_cache(None)\\n        def dfs(mask, basket):\\n            if mask == 0: return (1, 0)\\n            ans = (float(\"inf\"), float(\"inf\"))\\n            for j in range(N):\\n                if mask & (1<<j):\\n                    pieces, last = dfs(mask - (1 << j), basket)\\n                    full = (last + jobs[j] > basket)\\n                    ans = min(ans, (pieces + full, jobs[j] + (1-full)*last))  \\n            return ans \\n\\n        beg, end = max(jobs), sum(jobs)\\n        while beg < end:\\n            mid = (beg + end)//2\\n            if dfs((1<<N) - 1, mid)[0] >= k + 1:\\n                beg = mid + 1\\n            else:\\n                end = mid\\n        \\n        return beg\\n```\n```python\\nclass Solution:\\n    def minimumTimeRequired(self, jobs, k):\\n        n = len(jobs)\\n        cost = [0]*(1<<n)\\n        for mask, j in product(range(1<<n), range(n)):\\n            cost[mask] += jobs[j] * ((mask >> j) & 1)\\n        \\n        @lru_cache(None)\\n        def dp(mask, k):\\n            if k == 1:\\n                return cost[mask]\\n            submask, ret = mask, cost[mask]\\n            while (submask-1) & mask:\\n                submask = (submask-1) & mask\\n                if cost[submask] >= ret: continue\\n                ret = min(ret, max(cost[submask], dp(mask^submask, k-1)))\\n                \\n            return ret\\n        \\n        return dp((1<<n) - 1, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155726,
                "title": "explanation-thought-process-algorithm-javascript-backtracking",
                "content": "\\n`Approach 1:` Backtracking.\\n`Intuition`: \\n- Like classic backtracking algorithms, we will try `different combinations of sum` but this time instead of one combination sum we need \"k\" combination sums. \\n\\n- Let\\'s say, we will use `k` buckets to have different combination-sums using the numbers from our input array. During recursion, everytime we would have used all our numbers from input array to populate our buckets, we will note down the value of our \"max-filled\" bucket. \\n\\n-  In the end we will chose the minimum of those max values as our result.\\n\\n`Algorithm: ` \\n- Sort the input array (Ascending or descending)\\n\\n- Invoke the backtracking function with an index(first or last) for your input array\\n\\n- Set the base condition for the recursive backtracking function as, either when the index is less than zero or when the index is greater than the entire length of your input array, choose one!\\n\\n- Within the recursive function, populate the buckets(say, an empty array).\\n\\n- To speed up, Prune! What do I mean? I mean, Insert the logic for avoiding unnecesary depth/stacks of recursive tree, when you know that a specific step is not going to lead to your answer. For this question, if any step is not leading us to \"minimum\"..i.e, If addition of any number in the bucket is making the max go above the previous min value, let\\'s just discard it right away. \\n\\n- Hope this explanation helps or saves someone\\'s time! (\\xAC\\u203F\\xAC)\\n\\n\\n\\n```\\nconst minimumTimeRequired = function(jobs, k) {\\n\\n    jobs.sort((a,b)=>a-b); \\n    let result = Infinity;  \\n    let lastJobIndex = jobs.length-1; \\n    if(jobs.length === k) return jobs[lastJobIndex];\\n    const workersArray = new Array(k).fill(0);      // Creating Buckets\\n    \\n    function backtrack(lastJobIndex,workersArray){\\n        if(lastJobIndex < 0){\\n            result = Math.min(result, Math.max(...workersArray));\\n            return;\\n        }\\n        if(Math.max(...workersArray) >= result) return;     // Pruning\\n        for(let currentIndex = 0; currentIndex <  workersArray.length; currentIndex++){  \\n            if (currentIndex > 0 && workersArray[currentIndex] === workersArray[currentIndex-1]) continue;     // Pruning\\n            workersArray[currentIndex] += jobs[lastJobIndex];\\n            backtrack(lastJobIndex-1,workersArray);\\n            workersArray[currentIndex] -= jobs[lastJobIndex];\\n        }\\n    }\\n    backtrack(lastJobIndex, workersArray);\\n    return result\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/a5aa198e-745a-440a-8e92-3353b4ce8e66_1621880159.912241.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nconst minimumTimeRequired = function(jobs, k) {\\n\\n    jobs.sort((a,b)=>a-b); \\n    let result = Infinity;  \\n    let lastJobIndex = jobs.length-1; \\n    if(jobs.length === k) return jobs[lastJobIndex];\\n    const workersArray = new Array(k).fill(0);      // Creating Buckets\\n    \\n    function backtrack(lastJobIndex,workersArray){\\n        if(lastJobIndex < 0){\\n            result = Math.min(result, Math.max(...workersArray));\\n            return;\\n        }\\n        if(Math.max(...workersArray) >= result) return;     // Pruning\\n        for(let currentIndex = 0; currentIndex <  workersArray.length; currentIndex++){  \\n            if (currentIndex > 0 && workersArray[currentIndex] === workersArray[currentIndex-1]) continue;     // Pruning\\n            workersArray[currentIndex] += jobs[lastJobIndex];\\n            backtrack(lastJobIndex-1,workersArray);\\n            workersArray[currentIndex] -= jobs[lastJobIndex];\\n        }\\n    }\\n    backtrack(lastJobIndex, workersArray);\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009828,
                "title": "simple-python-using-partition-to-k-equal-sum-subsets",
                "content": "This code basically reuses the exact code from [#698 Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/).\\n\\nThe basic idea is you binary search for a target answer while using the bucket method to see if it\\'s possible.\\nSince we want to find the lowest/leftmost possible answer, we use lo + hi >> 1, and lo = mid + 1\\n\\nOptimizations:\\n1) Place the larger numbers first, as smaller numbers could be placed into a lot of buckets\\n2) If filling it in this bucket doesnt work, then nothing will work. This is bc we fill previous buckets before trying the next\\n\\n```\\ndef minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        jobs.sort(reverse=True) # optimization (1)\\n        \\n        def possible(target, buckets, idx):\\n            if idx == len(jobs):\\n                return True\\n            for i in range(len(buckets)):\\n                buckets[i] += jobs[idx]\\n                if buckets[i] <= target and possible(target, buckets, idx+1):\\n                    return True\\n                buckets[i] -= jobs[idx]\\n                if buckets[i] == 0: # optimization (2)\\n                    break\\n            return False  \\n        \\n        lo = max(jobs)\\n        hi = sum(jobs)\\n        while lo < hi:\\n            mid = lo + hi >> 1\\n            b = [0] * k\\n            if not possible(mid, b, 0):\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        jobs.sort(reverse=True) # optimization (1)\\n        \\n        def possible(target, buckets, idx):\\n            if idx == len(jobs):\\n                return True\\n            for i in range(len(buckets)):\\n                buckets[i] += jobs[idx]\\n                if buckets[i] <= target and possible(target, buckets, idx+1):\\n                    return True\\n                buckets[i] -= jobs[idx]\\n                if buckets[i] == 0: # optimization (2)\\n                    break\\n            return False  \\n        \\n        lo = max(jobs)\\n        hi = sum(jobs)\\n        while lo < hi:\\n            mid = lo + hi >> 1\\n            b = [0] * k\\n            if not possible(mid, b, 0):\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1014262,
                "title": "c-binary-search-4ms",
                "content": "Similar to this question: https://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nWe can translate this question to:\\n\\nVerify a given working time limit for every worker, so that all the jobs can be successfully assigned. \\nWe need to find the min possible solution of the above working time limit.\\n\\nObviously, every worker has to be assigned for at least one job, so the lower bound is the most time consuming job\\nand the upper bound can be set to the sum of all jobs. Then we can do a binary search on working time limit.\\n\\nWe use dfs to verify whether a working time limit is valid, the idea is almost the same as  https://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int sum = 0;\\n        for(int j:jobs)\\n            sum += j;\\n        sort(jobs.begin(),jobs.end(),greater<int>());\\n        int l = jobs[0], r = sum;\\n        while(l<r){\\n            int mid = (l+r)>>1;\\n            vector<int> worker(k,0);\\n            if(dfs(jobs,worker,0,mid))\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n    bool dfs(vector<int>& jobs, vector<int>& worker, int step, int target){\\n        if(step>=jobs.size())\\n            return true;\\n        int cur = jobs[step];\\n        // assign cur to worker i \\n        for(int i=0;i<worker.size();i++){\\n            if(worker[i] + cur <= target){\\n                worker[i] += cur;\\n                if(dfs(jobs,worker,step+1,target))\\n                    return true;\\n                worker[i] -= cur;\\n            }\\n            if(worker[i]==0)\\n                break;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int sum = 0;\\n        for(int j:jobs)\\n            sum += j;\\n        sort(jobs.begin(),jobs.end(),greater<int>());\\n        int l = jobs[0], r = sum;\\n        while(l<r){\\n            int mid = (l+r)>>1;\\n            vector<int> worker(k,0);\\n            if(dfs(jobs,worker,0,mid))\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n    bool dfs(vector<int>& jobs, vector<int>& worker, int step, int target){\\n        if(step>=jobs.size())\\n            return true;\\n        int cur = jobs[step];\\n        // assign cur to worker i \\n        for(int i=0;i<worker.size();i++){\\n            if(worker[i] + cur <= target){\\n                worker[i] += cur;\\n                if(dfs(jobs,worker,step+1,target))\\n                    return true;\\n                worker[i] -= cur;\\n            }\\n            if(worker[i]==0)\\n                break;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287005,
                "title": "explanation-c-beats-91-53",
                "content": "####  **LOGIC**\\n- It is a backtracking problem where we have to try different combinations of given N numbers to fill all K buckets.\\n- Once we\\'re done filling all the K buckets with these numbers, we need to find the bucket which has maximum sum. This sum is a vaild answer or not ? To check this:\\n- We have to store the minimum of all such sum after trying out all combinations.\\n- Each number is going to be in one of the given K buckets, i.e. no number left unused.\\n#### **ALGORITHM**\\n- Sort the jobs vector in descending order.\\n- Create a backtracking function with arguments (jobIndex, totalWorkers, JobVector).\\n- Create a workTime vector of size K to track the time taken by j th worker to finish his/her assigned jobs.\\n- Base case: when jobIndex == JobVector.size() , i.e. all the jobs has been completed so our answer is going to be min(globeAns, currentCombinationAnswer)\\n- currentCombinationAnswer is *max_element(workTime.begin(),workTime.end())\\n- **Now the important part:** To avoid TLE we\\'ll do 2-3 lines of modification in our backtracking function.\\n- Modification 1 : If **globeAns <= max_element(workTime.begin(),workTime.end())** at any recurring state then we can return because it ain\\'t going to give us an optimal answer, as workTime of some workers is exceeding our previous minimal answer.\\n- Modification 2 : if **workTime[j]  >= workTime[j - 1] for all j > 0** , then we should avoid adding newJob to **j th worker**  , we\\'ll continue in this case as it\\'s not optimal to add to workTime[j] as it\\'s already bigger.\\n- These modifications going to cut off all unnecessary recursion calls.\\n- else we\\'ll simply take **ith job** for the current worker and call a DFS for (jobIndex + 1, totalWorkers, JobVector) and **backtrack by removing ith job** from the current worker\\'s workTime cell.\\n\\n#### **CODE**\\n\\n    int ans = INT_MAX;\\n    vector<int>work;\\n    void solveBackTrack(int i,int k,int n,vector<int>&jobs){\\n        if(i == n){\\n            int maxi = *max_element(work.begin(),work.end());\\n            ans = min(ans,maxi);\\n            return ;\\n        }\\n\\n        if(*max_element(work.begin(),work.end()) >= ans)\\n            return;\\n        for(int j = 0; j < k; j++){\\n            if(j > 0 and work[j] >= work[j - 1])continue;\\n            work[j] += jobs[i];\\n            solveBackTrack(i+1,k,n,jobs);\\n            work[j] -= jobs[i];\\n        }\\n        return ;\\n    }\\n    \\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(jobs.begin(),jobs.end(),greater<int>());\\n        int n = jobs.size();\\n        if(n == k)return jobs[0];\\n        work.resize(k,0);\\n        solveBackTrack(0,k,n,jobs);\\n        return ans;\\n    }\\n\\t\\n\\t **(^_^)**\\t",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "####  **LOGIC**\\n- It is a backtracking problem where we have to try different combinations of given N numbers to fill all K buckets.\\n- Once we\\'re done filling all the K buckets with these numbers, we need to find the bucket which has maximum sum. This sum is a vaild answer or not ? To check this:\\n- We have to store the minimum of all such sum after trying out all combinations.\\n- Each number is going to be in one of the given K buckets, i.e. no number left unused.\\n#### **ALGORITHM**\\n- Sort the jobs vector in descending order.\\n- Create a backtracking function with arguments (jobIndex, totalWorkers, JobVector).\\n- Create a workTime vector of size K to track the time taken by j th worker to finish his/her assigned jobs.\\n- Base case: when jobIndex == JobVector.size() , i.e. all the jobs has been completed so our answer is going to be min(globeAns, currentCombinationAnswer)\\n- currentCombinationAnswer is *max_element(workTime.begin(),workTime.end())\\n- **Now the important part:** To avoid TLE we\\'ll do 2-3 lines of modification in our backtracking function.\\n- Modification 1 : If **globeAns <= max_element(workTime.begin(),workTime.end())** at any recurring state then we can return because it ain\\'t going to give us an optimal answer, as workTime of some workers is exceeding our previous minimal answer.\\n- Modification 2 : if **workTime[j]  >= workTime[j - 1] for all j > 0** , then we should avoid adding newJob to **j th worker**  , we\\'ll continue in this case as it\\'s not optimal to add to workTime[j] as it\\'s already bigger.\\n- These modifications going to cut off all unnecessary recursion calls.\\n- else we\\'ll simply take **ith job** for the current worker and call a DFS for (jobIndex + 1, totalWorkers, JobVector) and **backtrack by removing ith job** from the current worker\\'s workTime cell.\\n\\n#### **CODE**\\n\\n    int ans = INT_MAX;\\n    vector<int>work;\\n    void solveBackTrack(int i,int k,int n,vector<int>&jobs){\\n        if(i == n){\\n            int maxi = *max_element(work.begin(),work.end());\\n            ans = min(ans,maxi);\\n            return ;\\n        }\\n\\n        if(*max_element(work.begin(),work.end()) >= ans)\\n            return;\\n        for(int j = 0; j < k; j++){\\n            if(j > 0 and work[j] >= work[j - 1])continue;\\n            work[j] += jobs[i];\\n            solveBackTrack(i+1,k,n,jobs);\\n            work[j] -= jobs[i];\\n        }\\n        return ;\\n    }\\n    \\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(jobs.begin(),jobs.end(),greater<int>());\\n        int n = jobs.size();\\n        if(n == k)return jobs[0];\\n        work.resize(k,0);\\n        solveBackTrack(0,k,n,jobs);\\n        return ans;\\n    }\\n\\t\\n\\t **(^_^)**\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1009917,
                "title": "clean-java",
                "content": "credit to @sirius84\\nthanks @noexcuses for correcting time complexity\\n\\nprune1: when we have current woker sum of jobs more than the global max, we stop\\nprune2: when we assign a new job to several wokers who has same work load, we only need to pick one, and stop others recursive call.\\nprune3: sort and start from big task then smaller one, we can stop ealier based on prune1\\n\\nsince N is small as 12, worst case O(k*n!), but there could be some closer time estimation.\\neach task can have n * (n - 1) * (n - 2)...* 2 * 1\\n\\n```   \\nclass Solution {\\n    int res = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        Arrays.sort(jobs);\\n        dfs(jobs, jobs.length - 1, new int[k]);\\n        return res;\\n    }\\n    \\n    private void dfs(int[] jobs, int pos, int[] sum) {\\n        if (pos < 0) {\\n            res = Math.min(res, Arrays.stream(sum).max().getAsInt());\\n            return;\\n        }\\n        if (Arrays.stream(sum).max().getAsInt() >= res) return;           //prune1\\n        for (int i = 0; i < sum.length; i++) {\\n            if (i > 0 && sum[i] == sum[i - 1]) continue;                  //prune2\\n            sum[i] += jobs[pos];\\n            dfs(jobs, pos - 1, sum);\\n            sum[i] -= jobs[pos];\\n        }\\n    }\\n}\\n```\\n\\nthanks to @iceeo, we don\\'t need to get he max everytime\\n```\\nclass Solution {\\n    private int res = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        dfs(jobs, new int[k], jobs.length - 1, 0);\\n        return res;\\n    }\\n    private void dfs(int[] jobs, int[] workers, int pos, int curMax) {\\n        if (pos == -1) {\\n            res = Math.min(curMax, res);\\n            return;\\n        }\\n        if (curMax > res) return;\\n        for (int i = 0; i < workers.length; i++) {\\n            if (i > 0 && workers[i] == workers[i - 1]) continue; //reduce duplicate call\\n            workers[i] += jobs[pos];\\n            dfs(jobs, workers, pos - 1, Math.max(curMax, workers[i]));\\n            workers[i] -= jobs[pos];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```   \\nclass Solution {\\n    int res = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        Arrays.sort(jobs);\\n        dfs(jobs, jobs.length - 1, new int[k]);\\n        return res;\\n    }\\n    \\n    private void dfs(int[] jobs, int pos, int[] sum) {\\n        if (pos < 0) {\\n            res = Math.min(res, Arrays.stream(sum).max().getAsInt());\\n            return;\\n        }\\n        if (Arrays.stream(sum).max().getAsInt() >= res) return;           //prune1\\n        for (int i = 0; i < sum.length; i++) {\\n            if (i > 0 && sum[i] == sum[i - 1]) continue;                  //prune2\\n            sum[i] += jobs[pos];\\n            dfs(jobs, pos - 1, sum);\\n            sum[i] -= jobs[pos];\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int res = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        dfs(jobs, new int[k], jobs.length - 1, 0);\\n        return res;\\n    }\\n    private void dfs(int[] jobs, int[] workers, int pos, int curMax) {\\n        if (pos == -1) {\\n            res = Math.min(curMax, res);\\n            return;\\n        }\\n        if (curMax > res) return;\\n        for (int i = 0; i < workers.length; i++) {\\n            if (i > 0 && workers[i] == workers[i - 1]) continue; //reduce duplicate call\\n            workers[i] += jobs[pos];\\n            dfs(jobs, workers, pos - 1, Math.max(curMax, workers[i]));\\n            workers[i] -= jobs[pos];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010349,
                "title": "c-simple-and-intitutive-solution-using-dp-with-bitmask-with-explaination-and-intitution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>result;\\n    int dp[1<<12+5][13];  // first parameter is mask and second corresponds to how many workers have been given work\\n    int dfs(int mask,int i,int k,int n)\\n    {\\n        if(i==k ) // if we gave work to all workers\\n        {\\n            if(mask==(1<<n)-1)   // if all work has been assigned then its valid \\n            {\\n                return 0;\\n            } \\n            else\\n            {\\n                return INT_MAX;  // just return INT_MAX as this path is not valid\\n            }\\n          \\n        }\\n        if(dp[mask][i] != -1)\\n        {\\n            return dp[mask][i];\\n        }\\n        int notaken = 0;   // corresponds to all bits with have not been assigned \\n        int ans = INT_MAX;\\n        for(int j = 0;j<n;j++)\\n        {\\n            if(((1<<j)&mask)==0)  \\n            {\\n                notaken += (1<<j);     \\n            }\\n        }\\n              int s = notaken;  \\n               while (s > 0) {   // trick to generate submasks\\n              ans = min(ans,max(result[s],dfs((mask|s),i+1,k,n)));    // first taking maximum from the path and the minmum of all maximums from path \\n              s = (s-1) & notaken;\\n      }\\n        return dp[mask][i] = ans;  // storing \\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        memset(dp,-1,sizeof(dp));\\n         int n = jobs.size();\\n         result.resize((1<<n));\\n         fill(result.begin(),result.end(),0);\\n         for(int i = 0;i<(1<<n);i++)    // storing for particular subset of work\\n        {\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(((1<<j)&i))\\n                {\\n                    result[i] += jobs[j];\\n                }\\n            }\\n        }\\n       return dfs(0,0,k,n);\\n    }\\n};\\n```\\n**Intiution**\\nYou want to find the minmum of total time (maximum sum of work time assigned to worker)\\nif you store subsets of work and how many workers have been assigned the work \\ndp[mask][i]  corresponds to the minimum anwer with mask of work already assignned among i people\\n**Explaination**\\nLets supose it has tree depth corresponds to how many workers have been assigned work. if you are at particular node you will take maximum ( of all path ) and then take minmum from the maximum of all path and store at that node\\n      (Node)\\n\\t  a1  a2 a3   ....   ak corresponds to all path  b1 b2...... bk be maximum from all paths\\n\\t  take minimum(b1,b2..............bk)\\n\\t  that is stored in particular start if you again arrived at this state ( with subset of work and number of workers assign ) you can use this state.\\n\\t  **Topics to learn from this solution**\\n\\t  1 how to generate submasks\\n\\t  2 thinkway of recussion and memoization\\n\\t  3 bitmasking (as  n was very smmall)\\n**please reply how was my explaination this was my first explaination of solution and also suggestions**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>result;\\n    int dp[1<<12+5][13];  // first parameter is mask and second corresponds to how many workers have been given work\\n    int dfs(int mask,int i,int k,int n)\\n    {\\n        if(i==k ) // if we gave work to all workers\\n        {\\n            if(mask==(1<<n)-1)   // if all work has been assigned then its valid \\n            {\\n                return 0;\\n            } \\n            else\\n            {\\n                return INT_MAX;  // just return INT_MAX as this path is not valid\\n            }\\n          \\n        }\\n        if(dp[mask][i] != -1)\\n        {\\n            return dp[mask][i];\\n        }\\n        int notaken = 0;   // corresponds to all bits with have not been assigned \\n        int ans = INT_MAX;\\n        for(int j = 0;j<n;j++)\\n        {\\n            if(((1<<j)&mask)==0)  \\n            {\\n                notaken += (1<<j);     \\n            }\\n        }\\n              int s = notaken;  \\n               while (s > 0) {   // trick to generate submasks\\n              ans = min(ans,max(result[s],dfs((mask|s),i+1,k,n)));    // first taking maximum from the path and the minmum of all maximums from path \\n              s = (s-1) & notaken;\\n      }\\n        return dp[mask][i] = ans;  // storing \\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        memset(dp,-1,sizeof(dp));\\n         int n = jobs.size();\\n         result.resize((1<<n));\\n         fill(result.begin(),result.end(),0);\\n         for(int i = 0;i<(1<<n);i++)    // storing for particular subset of work\\n        {\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(((1<<j)&i))\\n                {\\n                    result[i] += jobs[j];\\n                }\\n            }\\n        }\\n       return dfs(0,0,k,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009870,
                "title": "java-backtrack-with-prune-and-optimization",
                "content": "Optimization:\\n1. Sort\\n2. Prune\\n3. Avoid same assignment for different workers \\n```\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        Arrays.sort(jobs);\\n        \\n        int n = jobs.length;\\n        \\n        if (k >= n) return jobs[n - 1];\\n        \\n        min = Integer.MAX_VALUE;\\n        \\n        dfs(jobs, n - 1, new int[k]);\\n        \\n        return min;\\n    }\\n    \\n    int min;\\n    \\n    private void dfs(int[] jobs, int i, int[] curMax) {\\n        if (i == -1) {\\n            int max = findMax(curMax);\\n            min = Math.min(min, max);\\n            return;\\n        }\\n        \\n        if (findMax(curMax) >= min) return;\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        \\n        for(int j = 0; j < curMax.length; j ++) {\\n            if (visited.contains(curMax[j])) continue;\\n            visited.add(curMax[j]);\\n            curMax[j] += jobs[i];\\n            dfs(jobs, i - 1, curMax);\\n            curMax[j] -= jobs[i];\\n        }\\n    }\\n    \\n    private int findMax(int[] curMax) {\\n        int max = 0;\\n        \\n        for(int i : curMax) max = Math.max(max, i);\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        Arrays.sort(jobs);\\n        \\n        int n = jobs.length;\\n        \\n        if (k >= n) return jobs[n - 1];\\n        \\n        min = Integer.MAX_VALUE;\\n        \\n        dfs(jobs, n - 1, new int[k]);\\n        \\n        return min;\\n    }\\n    \\n    int min;\\n    \\n    private void dfs(int[] jobs, int i, int[] curMax) {\\n        if (i == -1) {\\n            int max = findMax(curMax);\\n            min = Math.min(min, max);\\n            return;\\n        }\\n        \\n        if (findMax(curMax) >= min) return;\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        \\n        for(int j = 0; j < curMax.length; j ++) {\\n            if (visited.contains(curMax[j])) continue;\\n            visited.add(curMax[j]);\\n            curMax[j] += jobs[i];\\n            dfs(jobs, i - 1, curMax);\\n            curMax[j] -= jobs[i];\\n        }\\n    }\\n    \\n    private int findMax(int[] curMax) {\\n        int max = 0;\\n        \\n        for(int i : curMax) max = Math.max(max, i);\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438422,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    static bool comp(int &a, int &b)\\n    {\\n        return a > b;\\n    }\\n    int ans = INT_MAX;\\n    void dfs(vector<int> &vis, int idx, vector<int> &jobs, int k)\\n    {\\n        if(idx == jobs.size())\\n        {\\n            int val = 0;\\n            for(int i = 0; i < k; i++)\\n            {\\n                val = max(val, vis[i]);\\n            }\\n            ans = min(ans,val);\\n            return;\\n        }\\n        for(int i = 0; i < k; i++)\\n        {\\n            if(i > 0 && vis[i] >= vis[i - 1])\\n                continue;\\n            if(vis[i]+jobs[idx] >= ans)\\n                continue;\\n            vis[i] += jobs[idx];\\n            dfs(vis, idx+1, jobs, k);\\n            vis[i] -= jobs[idx];\\n        }\\n        return;\\n    }\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(jobs.begin(), jobs.end(), comp);\\n        vector<int> vis(k+1,0);\\n        dfs(vis, 0, jobs, k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    static bool comp(int &a, int &b)\\n    {\\n        return a > b;\\n    }\\n    int ans = INT_MAX;\\n    void dfs(vector<int> &vis, int idx, vector<int> &jobs, int k)\\n    {\\n        if(idx == jobs.size())\\n        {\\n            int val = 0;\\n            for(int i = 0; i < k; i++)\\n            {\\n                val = max(val, vis[i]);\\n            }\\n            ans = min(ans,val);\\n            return;\\n        }\\n        for(int i = 0; i < k; i++)\\n        {\\n            if(i > 0 && vis[i] >= vis[i - 1])\\n                continue;\\n            if(vis[i]+jobs[idx] >= ans)\\n                continue;\\n            vis[i] += jobs[idx];\\n            dfs(vis, idx+1, jobs, k);\\n            vis[i] -= jobs[idx];\\n        }\\n        return;\\n    }\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(jobs.begin(), jobs.end(), comp);\\n        vector<int> vis(k+1,0);\\n        dfs(vis, 0, jobs, k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010013,
                "title": "java-dfs-memo",
                "content": "```\\nclass Solution {\\n    int dp[][];\\n    int k;int n;\\n    int A[];\\n    public int minimumTimeRequired(int[] A, int k) {\\n        this.A=A;\\n        n=A.length;\\n        this.k=k;\\n        int state=(1<<n)-1;\\n        dp=new int[k][state+10];\\n        for(int i=0;i<dp.length;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        int res=dfs(0,state);\\n        return res;\\n    }\\n    \\n    \\n    public int dfs(int index,int state){\\n        if(index>=k){\\n            if(state==0)return 0;\\n            else return 100000000;\\n        }\\n        if(state==0)return 0;\\n        if(dp[index][state]!=-1)return dp[index][state]; \\n        int res=Integer.MAX_VALUE;\\n        \\n        for(int i=1;i<=(state);i++){\\n            if(((i&state)!=i)||(i|state)!=state)continue;\\n            int sum=0;\\n            int newstate=state;\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))!=0){\\n                    sum+=A[j];\\n                    newstate=newstate^(1<<j);\\n                }\\n            }\\n            if(sum<=res){\\n                res=Math.min(res,Math.max(sum,dfs(index+1,newstate)));\\n            }   \\n        }\\n        dp[index][state]=res;\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[][];\\n    int k;int n;\\n    int A[];\\n    public int minimumTimeRequired(int[] A, int k) {\\n        this.A=A;\\n        n=A.length;\\n        this.k=k;\\n        int state=(1<<n)-1;\\n        dp=new int[k][state+10];\\n        for(int i=0;i<dp.length;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        int res=dfs(0,state);\\n        return res;\\n    }\\n    \\n    \\n    public int dfs(int index,int state){\\n        if(index>=k){\\n            if(state==0)return 0;\\n            else return 100000000;\\n        }\\n        if(state==0)return 0;\\n        if(dp[index][state]!=-1)return dp[index][state]; \\n        int res=Integer.MAX_VALUE;\\n        \\n        for(int i=1;i<=(state);i++){\\n            if(((i&state)!=i)||(i|state)!=state)continue;\\n            int sum=0;\\n            int newstate=state;\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))!=0){\\n                    sum+=A[j];\\n                    newstate=newstate^(1<<j);\\n                }\\n            }\\n            if(sum<=res){\\n                res=Math.min(res,Math.max(sum,dfs(index+1,newstate)));\\n            }   \\n        }\\n        dp[index][state]=res;\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148585,
                "title": "c-very-easy-same-as-k-subset-partition-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&nums,vector<long long>&vec,int step,long long val)\\n    {\\n        if(step>=nums.size()) return true;\\n        long long cur=nums[step];\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(cur+vec[i]<=val)\\n            {\\n                vec[i]+=cur;\\n                if(check(nums,vec,step+1,val)) return true;\\n                vec[i]-=cur;\\n            }\\n            if(vec[i]==0) break;\\n        }\\n        return false;\\n    }\\n    int minimumTimeRequired(vector<int>& nums, int k) {\\n        long long l=*max_element(nums.begin(),nums.end());\\n        long long r=accumulate(nums.begin(),nums.end(),0);\\n        while(l<r)\\n        {\\n            long long mid=(l+r)/2;\\n            vector<long long>vec(k,0);\\n            if(check(nums,vec,0,mid))\\n            {\\n                r=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&nums,vector<long long>&vec,int step,long long val)\\n    {\\n        if(step>=nums.size()) return true;\\n        long long cur=nums[step];\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(cur+vec[i]<=val)\\n            {\\n                vec[i]+=cur;\\n                if(check(nums,vec,step+1,val)) return true;\\n                vec[i]-=cur;\\n            }\\n            if(vec[i]==0) break;\\n        }\\n        return false;\\n    }\\n    int minimumTimeRequired(vector<int>& nums, int k) {\\n        long long l=*max_element(nums.begin(),nums.end());\\n        long long r=accumulate(nums.begin(),nums.end(),0);\\n        while(l<r)\\n        {\\n            long long mid=(l+r)/2;\\n            vector<long long>vec(k,0);\\n            if(check(nums,vec,0,mid))\\n            {\\n                r=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012972,
                "title": "rust-recursion-with-optimizations-0ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn minimum_time_required(mut jobs: Vec<i32>, k: i32) -> i32 {\\n        jobs.sort_by_key(|&x| std::cmp::Reverse(x));\\n        let mut workers = vec![0; k as usize];\\n        min_time_iter(&jobs, &mut workers, 0, 0, std::i32::MAX).unwrap()\\n    }\\n}\\n\\n/// # Arguments\\n/// * `jobs` - current slice of jobs, we will try to assign `jobs[0]` to some worker\\n/// * `workers` - mutable slice of each worker total job time\\n/// * `k` - count of currently assigned robots\\n/// * `max` - current maximum job time for a worker\\n/// * `best` - current best time found before \\npub fn min_time_iter(jobs: &[i32], workers: &mut [i32], k: usize, max: i32, best: i32) -> Option<i32> {\\n    if jobs.is_empty() { return Some(max); }\\n    if max > best { return None; }\\n    (0..(k + 1).min(workers.len())).rev().scan(best, |b, i| {\\n        workers[i] += jobs[0];\\n        let res = min_time_iter(&jobs[1..], workers, k.max(i + 1), workers[i].max(max), *b);\\n        workers[i] -= jobs[0];\\n        *b = res.filter(|r| r < b).unwrap_or(*b);\\n        Some(res)\\n    }).flatten().min()\\n}\\n```\\n\\nHere we just traverse all possible possible assignments using following optimizations:\\n1. Jobs are sorted in the reversed order for better distribution\\n2. We keep track on the current best time and give up when the some worker exceeds it",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn minimum_time_required(mut jobs: Vec<i32>, k: i32) -> i32 {\\n        jobs.sort_by_key(|&x| std::cmp::Reverse(x));\\n        let mut workers = vec![0; k as usize];\\n        min_time_iter(&jobs, &mut workers, 0, 0, std::i32::MAX).unwrap()\\n    }\\n}\\n\\n/// # Arguments\\n/// * `jobs` - current slice of jobs, we will try to assign `jobs[0]` to some worker\\n/// * `workers` - mutable slice of each worker total job time\\n/// * `k` - count of currently assigned robots\\n/// * `max` - current maximum job time for a worker\\n/// * `best` - current best time found before \\npub fn min_time_iter(jobs: &[i32], workers: &mut [i32], k: usize, max: i32, best: i32) -> Option<i32> {\\n    if jobs.is_empty() { return Some(max); }\\n    if max > best { return None; }\\n    (0..(k + 1).min(workers.len())).rev().scan(best, |b, i| {\\n        workers[i] += jobs[0];\\n        let res = min_time_iter(&jobs[1..], workers, k.max(i + 1), workers[i].max(max), *b);\\n        workers[i] -= jobs[0];\\n        *b = res.filter(|r| r < b).unwrap_or(*b);\\n        Some(res)\\n    }).flatten().min()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1011837,
                "title": "my-java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    int result = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int length = jobs.length;\\n        Arrays.sort(jobs);\\n        backtrack(jobs, length - 1, new int [k]);\\n        return result;\\n    }\\n    \\n    public void backtrack(int [] jobs, int current, int [] workers) {\\n        if (current < 0) {\\n            result = Math.min(result, Arrays.stream(workers).max().getAsInt());\\n            return;\\n        }\\n        \\n        if (Arrays.stream(workers).max().getAsInt() >=  result)\\n            return;\\n        for (int i=0; i<workers.length; i++) {\\n            if (i > 0 && workers[i] == workers[i-1])\\n                continue;\\n            // make choice\\n            workers[i] += jobs[current];\\n            // backtrack\\n            backtrack(jobs, current-1, workers);\\n            // undo the choice\\n            workers[i] -= jobs[current];\\n        }\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int result = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int length = jobs.length;\\n        Arrays.sort(jobs);\\n        backtrack(jobs, length - 1, new int [k]);\\n        return result;\\n    }\\n    \\n    public void backtrack(int [] jobs, int current, int [] workers) {\\n        if (current < 0) {\\n            result = Math.min(result, Arrays.stream(workers).max().getAsInt());\\n            return;\\n        }\\n        \\n        if (Arrays.stream(workers).max().getAsInt() >=  result)\\n            return;\\n        for (int i=0; i<workers.length; i++) {\\n            if (i > 0 && workers[i] == workers[i-1])\\n                continue;\\n            // make choice\\n            workers[i] += jobs[current];\\n            // backtrack\\n            backtrack(jobs, current-1, workers);\\n            // undo the choice\\n            workers[i] -= jobs[current];\\n        }\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009859,
                "title": "python3-backtracking",
                "content": "**Algo**\\nHere, we simply try out all possibilities but eliminate those that are apparently a waste of time. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        jobs.sort(reverse=True)\\n        \\n        def fn(i):\\n            \"\"\"Assign jobs to worker and find minimum time.\"\"\"\\n            nonlocal ans \\n            if i == len(jobs): ans = max(time)\\n            else: \\n                for kk in range(k): \\n                    if not kk or time[kk-1] > time[kk]: \\n                        time[kk] += jobs[i]\\n                        if max(time) < ans: fn(i+1)\\n                        time[kk] -= jobs[i]\\n            \\n        ans = inf\\n        time = [0]*k\\n        fn(0)\\n        return ans \\n```\\n\\n**Updated** \\nI was previously using `time[kk-1] > time[kk]` as the criterion to prune the backtracking tree which turns out to be incorrect. The condition is updated to `time[kk-1] != time[kk]`. In the meantime, the initial sorting was removed as it is useless. \\n```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        \\n        def fn(i):\\n            \"\"\"Assign jobs to worker and find minimum time.\"\"\"\\n            nonlocal ans \\n            if i == len(jobs): ans = max(time)\\n            else: \\n                for kk in range(k): \\n                    if not kk or time[kk-1] != time[kk]: \\n                        time[kk] += jobs[i]\\n                        if max(time) < ans: fn(i+1)\\n                        time[kk] -= jobs[i]\\n            \\n        ans = inf\\n        time = [0]*k\\n        fn(0)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        jobs.sort(reverse=True)\\n        \\n        def fn(i):\\n            \"\"\"Assign jobs to worker and find minimum time.\"\"\"\\n            nonlocal ans \\n            if i == len(jobs): ans = max(time)\\n            else: \\n                for kk in range(k): \\n                    if not kk or time[kk-1] > time[kk]: \\n                        time[kk] += jobs[i]\\n                        if max(time) < ans: fn(i+1)\\n                        time[kk] -= jobs[i]\\n            \\n        ans = inf\\n        time = [0]*k\\n        fn(0)\\n        return ans \\n```\n```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        \\n        def fn(i):\\n            \"\"\"Assign jobs to worker and find minimum time.\"\"\"\\n            nonlocal ans \\n            if i == len(jobs): ans = max(time)\\n            else: \\n                for kk in range(k): \\n                    if not kk or time[kk-1] != time[kk]: \\n                        time[kk] += jobs[i]\\n                        if max(time) < ans: fn(i+1)\\n                        time[kk] -= jobs[i]\\n            \\n        ans = inf\\n        time = [0]*k\\n        fn(0)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564970,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Backtracking && Binary Search***\\n\\n* ***Time Complexity :- O(K ^ N * log(high - low))***\\n\\n* ***Space Complexity :- O(K * log(high - low))***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(vector<int>& arr, int i, int n, int mid, vector<int>& worker, int k)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n            return true;\\n        \\n        // assign the curr_work to the workers which can do the curr_work\\n        \\n        for(int j = 0; j < k; j++)\\n        {\\n            if(worker[j] + arr[i] <= mid)\\n            {\\n                worker[j] += arr[i];\\n                \\n                if(is_possible(arr, i + 1, n, mid, worker, k))\\n                    return true;\\n                \\n                worker[j] -= arr[i];\\n            }\\n            \\n            // if any of the worker doesn\\'t get any job then this combination will not produce optimal result\\n            \\n            if(worker[j] == 0)\\n                break;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int minimumTimeRequired(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n        // sort the array in descending order\\n        \\n        sort(arr.begin(), arr.end(), greater<int> ());\\n        \\n        int mini = INT_MAX;\\n        \\n        // apply binary search on search space {low, high}\\n        \\n        int low = *max_element(arr.begin(), arr.end());\\n            \\n        int high = 0;\\n            \\n        for(int i = 0; i < n; i++)\\n        {\\n            high += arr[i];\\n        }\\n            \\n        int ans = -1;\\n        \\n        // for every mid, distribute the works into k worker then take min. of ans\\n            \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            vector<int> worker(k, 0);\\n                \\n            if(is_possible(arr, 0, n, mid, worker, k))\\n            {\\n                ans = mid;\\n                    \\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n            \\n        mini = min(mini, ans); \\n        \\n        return mini;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Backtracking",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(vector<int>& arr, int i, int n, int mid, vector<int>& worker, int k)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n            return true;\\n        \\n        // assign the curr_work to the workers which can do the curr_work\\n        \\n        for(int j = 0; j < k; j++)\\n        {\\n            if(worker[j] + arr[i] <= mid)\\n            {\\n                worker[j] += arr[i];\\n                \\n                if(is_possible(arr, i + 1, n, mid, worker, k))\\n                    return true;\\n                \\n                worker[j] -= arr[i];\\n            }\\n            \\n            // if any of the worker doesn\\'t get any job then this combination will not produce optimal result\\n            \\n            if(worker[j] == 0)\\n                break;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int minimumTimeRequired(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n        // sort the array in descending order\\n        \\n        sort(arr.begin(), arr.end(), greater<int> ());\\n        \\n        int mini = INT_MAX;\\n        \\n        // apply binary search on search space {low, high}\\n        \\n        int low = *max_element(arr.begin(), arr.end());\\n            \\n        int high = 0;\\n            \\n        for(int i = 0; i < n; i++)\\n        {\\n            high += arr[i];\\n        }\\n            \\n        int ans = -1;\\n        \\n        // for every mid, distribute the works into k worker then take min. of ans\\n            \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            vector<int> worker(k, 0);\\n                \\n            if(is_possible(arr, 0, n, mid, worker, k))\\n            {\\n                ans = mid;\\n                    \\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n            \\n        mini = min(mini, ans); \\n        \\n        return mini;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042898,
                "title": "most-performant-c-so-far-beats-100-runtime-99-memory",
                "content": "Well, admittedly, this title *might* be a little click bait, but not completely : )\\nThis code has the best run time 0 ms, which beats 100% submissions; And average 4 ms, still beats 96% (just like all others who claims 0ms C++, the average is actually always 4ms)\\nBut this one has also the best memory 7.2MB, which beats 99.6% submissions, average 7.4MB, still beats 96%; \\n\\nI don\\'t use fancy tricks, like not assigning work to the same load again, or sort your jobs first or use a result from greedy algo to prune etc. I don\\'t use any of them because the code itself is already efficient enought so that the overhead of introducing new datastructure (a map) or algorithm (sort) actually slows it down (because I tested). Of course, if the data set goes bigger, you can add those tricks to this code, since this code is already very peformant without these optimizations, I\\'d say it has more optimization potentials than those who used up all the tricks to ge this same performance;\\n\\nThe only two tricks I used;\\n* Prune with best result so far;\\n* Assign the jobs to workers more efficiently (I will elaborate later)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& inputJobs, int k) {\\n        jobs = move(inputJobs);\\n        totalWorkers = k;\\n        workLoad.resize(jobs.size());\\n        search(-1, 0);\\n        return minLoad;\\n    }\\n    \\nprivate:\\n    vector<int> workLoad, jobs;\\n    int minLoad = INT_MAX, currentMax = 0, totalWorkers = 0;\\n    void search(int rightMostSlot, int current) {\\n        if (current >= jobs.size()) {\\n            minLoad = min(minLoad, currentMax);\\n            return;\\n        }\\n        for (int i =  min(rightMostSlot + 1, totalWorkers - 1) ; i >= 0; -- i) {\\n            int oldMax = currentMax;\\n            workLoad[i] += jobs[current];\\n            currentMax = max(workLoad[i], currentMax);\\n            if (currentMax < minLoad) \\n                search(max(i, rightMostSlot), current + 1  );\\n            workLoad[i] -= jobs[current];\\n            currentMax = oldMax;\\n        }\\n    }\\n};\\n```\\n\\nAbout the second bullet, the obversation is that:\\nDoes it matter if you assign the job0 to worker0, or worker1 or worker2 or workerK first? \\nNo, it doesn\\'t, so you really can just always assign job0 to worker0 and get the same reasult;\\n\\nThen same question;\\nAfter you assign job0 to worker0, does it matter\\n* if you assign job1 to worker0 and worker1?\\n* if you assign job1 to worker1 and worker2?\\n\\nThe answer to first question is yes, because worker0 has some work, and worker1 doesn\\'t have any;\\nThe answer to the seond question is no, because worker1 and worker2, worker3 ... workerK are all empty, you can just always choose worker1 in this case;\\n\\nSo instead of we always check K workers, we check 1, 2, 3, 4, 5, ... , K position at each round. \\n\\nThat\\'s not the end though, let\\'s go back to the first question:\\nAfter you assign job0 to worker0, does it matter if you assign job1 to worker0 and worker1?\\n Yes, it does, but which one do you prefer (assign first)? Because we prune with the running minimum, so we want to get the minimum result early on, that means, we prefer to assign job1 to worker1, because we spread out the job wider so the chance of getting the minimum early on is higher. So you would like to assign to the empty slot first; This the only trick I used differently from other solutions I saw, but it worked well.\\n \\nNote: in this algo, I don\\'t care whether two workers have same load or not (you can add the opimitzation if you like), because it can reach 0ms even without caring it already.\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& inputJobs, int k) {\\n        jobs = move(inputJobs);\\n        totalWorkers = k;\\n        workLoad.resize(jobs.size());\\n        search(-1, 0);\\n        return minLoad;\\n    }\\n    \\nprivate:\\n    vector<int> workLoad, jobs;\\n    int minLoad = INT_MAX, currentMax = 0, totalWorkers = 0;\\n    void search(int rightMostSlot, int current) {\\n        if (current >= jobs.size()) {\\n            minLoad = min(minLoad, currentMax);\\n            return;\\n        }\\n        for (int i =  min(rightMostSlot + 1, totalWorkers - 1) ; i >= 0; -- i) {\\n            int oldMax = currentMax;\\n            workLoad[i] += jobs[current];\\n            currentMax = max(workLoad[i], currentMax);\\n            if (currentMax < minLoad) \\n                search(max(i, rightMostSlot), current + 1  );\\n            workLoad[i] -= jobs[current];\\n            currentMax = oldMax;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009804,
                "title": "c-clean-code-using-submask-enumeration-o-k-3-n-time-complexity",
                "content": "More information about submask enumeration: https://cp-algorithms.com/algebra/all-submasks.html\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& dp, int k, int bm, vector<int>& cost)\\n    {\\n        if (!bm) return 0;\\n        if (!~k) return INT_MAX;\\n        if (~dp[bm][k]) return dp[bm][k];\\n        int ret = INT_MAX;\\n        for (int s = bm; s; s = (s-1) & bm) ret = min(ret, max(cost[s], helper(dp, k-1, s ^ bm, cost)));\\n        return dp[bm][k] = ret;\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size(), sum;\\n        vector<vector<int>> dp(1 << n, vector<int>(k, -1));\\n        vector<int> cost;\\n        for (int i = 0; i < (1 << n); i++)\\n        {\\n            sum = 0;\\n            for (int j = 0; j < n; j++) if (i & (1 << j)) sum += jobs[j];\\n            cost.push_back(sum);\\n        }\\n        return helper(dp, k-1, (1 << n) - 1, cost); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& dp, int k, int bm, vector<int>& cost)\\n    {\\n        if (!bm) return 0;\\n        if (!~k) return INT_MAX;\\n        if (~dp[bm][k]) return dp[bm][k];\\n        int ret = INT_MAX;\\n        for (int s = bm; s; s = (s-1) & bm) ret = min(ret, max(cost[s], helper(dp, k-1, s ^ bm, cost)));\\n        return dp[bm][k] = ret;\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size(), sum;\\n        vector<vector<int>> dp(1 << n, vector<int>(k, -1));\\n        vector<int> cost;\\n        for (int i = 0; i < (1 << n); i++)\\n        {\\n            sum = 0;\\n            for (int j = 0; j < n; j++) if (i & (1 << j)) sum += jobs[j];\\n            cost.push_back(sum);\\n        }\\n        return helper(dp, k-1, (1 << n) - 1, cost); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610524,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find(vector<int>&nums,vector<int>&sum,int index,int mid)\\n    {\\n        if(index>nums.size())\\n        {\\n            return false;\\n        }\\n        if(index==nums.size())\\n        {\\n            return true;\\n        }\\n        for(int i=0;i<sum.size();i++)\\n        {\\n            sum[i]+=nums[index];\\n            if(sum[i]<=mid&&find(nums,sum,index+1,mid))\\n            {\\n                return true;\\n            }\\n            sum[i]-=nums[index];\\n            if(sum[i]==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    int minimumTimeRequired(vector<int>&nums, int k) \\n    {\\n        int n=nums.size();\\n        int l=*max_element(nums.begin(),nums.end());\\n        int r=accumulate(nums.begin(),nums.end(),0);\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            vector<int>sum(k,0);\\n            if(find(nums,sum,0,mid))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find(vector<int>&nums,vector<int>&sum,int index,int mid)\\n    {\\n        if(index>nums.size())\\n        {\\n            return false;\\n        }\\n        if(index==nums.size())\\n        {\\n            return true;\\n        }\\n        for(int i=0;i<sum.size();i++)\\n        {\\n            sum[i]+=nums[index];\\n            if(sum[i]<=mid&&find(nums,sum,index+1,mid))\\n            {\\n                return true;\\n            }\\n            sum[i]-=nums[index];\\n            if(sum[i]==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    int minimumTimeRequired(vector<int>&nums, int k) \\n    {\\n        int n=nums.size();\\n        int l=*max_element(nums.begin(),nums.end());\\n        int r=accumulate(nums.begin(),nums.end(),0);\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            vector<int>sum(k,0);\\n            if(find(nums,sum,0,mid))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479535,
                "title": "bitmask-dp-o-2-2n",
                "content": "```\\n#define ll long long int\\nclass Solution {\\n    vector<ll> dp[13],sum;\\n    int pw2[13],msk;\\n    int n;\\npublic:\\n    ll solver(int mask,int k,vector<int>& a){\\n        if(mask==0)\\n            return 0;\\n        \\n        if(k==1)\\n            return dp[k][mask]=sum[mask];\\n        \\n        if(dp[k][mask]!=-1)\\n            return dp[k][mask];\\n        \\n\\t\\t//choosing a submask for current mask\\n        ll ct=0,nxt=INT_MAX;\\n        for(int j=mask; j; j=(j-1)&mask)\\n\\t\\t\\tif((j&mask)==j)\\n                nxt=min(nxt,max(sum[j],solver(mask^j,k-1,a))); // max of curr or from remainig workers\\n        \\n        return dp[k][mask]=nxt;\\n    }\\n    \\n    int minimumTimeRequired(vector<int>& a, int k) {\\n        n=a.size();\\n        \\n        pw2[0]=1;\\n        for(int i=1;i<13;i++)\\n            pw2[i]=pw2[i-1]<<1;\\n        \\n        for(int i=0;i<13;i++)\\n            dp[i].resize(10+(1<<n),-1);\\n        \\n        msk=-1+(1<<n);\\n        \\n\\t\\t// sums corresponding to each bitmask\\n\\t\\tsum.resize(msk+10,0);\\n        \\n        for(int i=1;i<=msk;i++){\\n            ll ct=0;\\n            for(int j=0;j<n;j++)\\n                if(pw2[j]&i)\\n                    ct+=a[j];\\n            sum[i]=ct;    \\n        }\\n\\t\\t\\n        return solver(msk,k,a);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\n    vector<ll> dp[13],sum;\\n    int pw2[13],msk;\\n    int n;\\npublic:\\n    ll solver(int mask,int k,vector<int>& a){\\n        if(mask==0)\\n            return 0;\\n        \\n        if(k==1)\\n            return dp[k][mask]=sum[mask];\\n        \\n        if(dp[k][mask]!=-1)\\n            return dp[k][mask];\\n        \\n\\t\\t//choosing a submask for current mask\\n        ll ct=0,nxt=INT_MAX;\\n        for(int j=mask; j; j=(j-1)&mask)\\n\\t\\t\\tif((j&mask)==j)\\n                nxt=min(nxt,max(sum[j],solver(mask^j,k-1,a))); // max of curr or from remainig workers\\n        \\n        return dp[k][mask]=nxt;\\n    }\\n    \\n    int minimumTimeRequired(vector<int>& a, int k) {\\n        n=a.size();\\n        \\n        pw2[0]=1;\\n        for(int i=1;i<13;i++)\\n            pw2[i]=pw2[i-1]<<1;\\n        \\n        for(int i=0;i<13;i++)\\n            dp[i].resize(10+(1<<n),-1);\\n        \\n        msk=-1+(1<<n);\\n        \\n\\t\\t// sums corresponding to each bitmask\\n\\t\\tsum.resize(msk+10,0);\\n        \\n        for(int i=1;i<=msk;i++){\\n            ll ct=0;\\n            for(int j=0;j<n;j++)\\n                if(pw2[j]&i)\\n                    ct+=a[j];\\n            sum[i]=ct;    \\n        }\\n\\t\\t\\n        return solver(msk,k,a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010378,
                "title": "c-backtracking-with-pruning",
                "content": "class Solution\\n{\\n\\n    int ans = INT_MAX;\\npublic:\\n\\n    void backtrack(vector<int> &jobs, int idx, vector<int> worker)\\n    {\\n        if(idx == jobs.size())\\n        {\\n            ans = min(ans, *max_element(begin(worker), end(worker)));\\n            return;\\n        }\\n        \\n        sort(begin(worker),end(worker));\\n     \\n        for(int i = 0; i < worker.size(); i++)\\n        {\\n            if(i > 0 and worker[i] == worker[i-1])\\n                continue;\\n            \\n            if(worker[i] + jobs[idx] >= ans)\\n                continue;\\n            \\n            worker[i] += jobs[idx];\\n            \\n            backtrack(jobs, idx+1, worker);\\n            \\n            worker[i] -= jobs[idx];\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k)\\n    {\\n        if(k == 1)\\n            return accumulate(begin(jobs),end(jobs),0);\\n        \\n        if(k == jobs.size())\\n        return *max_element(begin(jobs),end(jobs));\\n        \\n        sort(jobs.rbegin(), jobs.rend());\\n        vector<int> worker(k);\\n        \\n        backtrack(jobs,0,worker);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\n\\n    int ans = INT_MAX;\\npublic:\\n\\n    void backtrack(vector<int> &jobs, int idx, vector<int> worker)\\n    {\\n        if(idx == jobs.size())\\n        {\\n            ans = min(ans, *max_element(begin(worker), end(worker)));\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1010271,
                "title": "java-clean-and-simple-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int left = 0;\\n        int right = 0;\\n        for (int n : jobs) {\\n            left = Math.max(left, n);\\n            right += n;\\n        }\\n        int res = right;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (helper(jobs, new int[k], 0, mid)) {\\n                res = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    boolean helper(int[] jobs, int[] groups, int index, int threshold) {\\n        if (index == jobs.length) {\\n            return true;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < groups.length; i++) {\\n            if (!set.add(groups[i])) {\\n                continue;\\n            }\\n            if (groups[i] + jobs[index] <= threshold) {\\n                groups[i] += jobs[index];\\n                if (helper(jobs, groups, index+1, threshold)) {\\n                    return true;\\n                }\\n                groups[i] -= jobs[index];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int left = 0;\\n        int right = 0;\\n        for (int n : jobs) {\\n            left = Math.max(left, n);\\n            right += n;\\n        }\\n        int res = right;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (helper(jobs, new int[k], 0, mid)) {\\n                res = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    boolean helper(int[] jobs, int[] groups, int index, int threshold) {\\n        if (index == jobs.length) {\\n            return true;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < groups.length; i++) {\\n            if (!set.add(groups[i])) {\\n                continue;\\n            }\\n            if (groups[i] + jobs[index] <= threshold) {\\n                groups[i] += jobs[index];\\n                if (helper(jobs, groups, index+1, threshold)) {\\n                    return true;\\n                }\\n                groups[i] -= jobs[index];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009964,
                "title": "python-backtracking-pruning-is",
                "content": "Kept on getting TLE during the competition. :P Also tried a greedy approach that won\\'t work. The concept I was thinking about was distributing the work as evenly as possible.\\n\\nA simple backtracking approach passes the tests:\\n\\n```\\nclass Solution:\\n    \\n    def dfs(self, pos: int, jobs: List[int], workers: List[int]) -> int:\\n        if pos >= len(jobs):\\n            return max(workers)\\n        \\n        mn = float(\"inf\")\\n        # we keep track of visited here to skip workers\\n        # with the same current value of assigned work\\n\\t\\t# this is an important step in pruning the number\\n\\t\\t# of workers to explore\\n        visited = set()\\n        for widx in range(len(workers)):\\n            \\n            if workers[widx] in visited:\\n                continue\\n            visited.add(workers[widx])\\n            \\n            # try this worker\\n            workers[widx] += jobs[pos]\\n            \\n            if max(workers) < mn:\\n                # if it\\'s better than our previous proceed\\n                res = self.dfs(pos+1, jobs, workers)\\n                mn = min(mn, res)\\n            \\n            # backtrack\\n            workers[widx] -= jobs[pos]\\n        \\n        return mn\\n        \\n    \\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n\\t    # sorting the jobs means that highest value jobs are assigned first\\n\\t\\t# and more computations can be skipped by pruning\\n        jobs.sort(reverse=True)\\n        return self.dfs(0, jobs, [0] * k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def dfs(self, pos: int, jobs: List[int], workers: List[int]) -> int:\\n        if pos >= len(jobs):\\n            return max(workers)\\n        \\n        mn = float(\"inf\")\\n        # we keep track of visited here to skip workers\\n        # with the same current value of assigned work\\n\\t\\t# this is an important step in pruning the number\\n\\t\\t# of workers to explore\\n        visited = set()\\n        for widx in range(len(workers)):\\n            \\n            if workers[widx] in visited:\\n                continue\\n            visited.add(workers[widx])\\n            \\n            # try this worker\\n            workers[widx] += jobs[pos]\\n            \\n            if max(workers) < mn:\\n                # if it\\'s better than our previous proceed\\n                res = self.dfs(pos+1, jobs, workers)\\n                mn = min(mn, res)\\n            \\n            # backtrack\\n            workers[widx] -= jobs[pos]\\n        \\n        return mn\\n        \\n    \\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n\\t    # sorting the jobs means that highest value jobs are assigned first\\n\\t\\t# and more computations can be skipped by pruning\\n        jobs.sort(reverse=True)\\n        return self.dfs(0, jobs, [0] * k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009899,
                "title": "c-easy-to-understand-code-simple-backtracking-and-pruning",
                "content": "- We are cutting the recursion with following techniques:\\n\\t- Using a set to maintain the worker[i] which was already seen before like if the current load distribution is [1,2,2,2,2,2] and we have already done backtracking for 2, we need not do it for other 2\\'s.\\n\\t- Apart from this, we can stop the recursion if any worker\\'s work load is greater than the current answer.\\n\\n```\\nclass Solution {\\n    int answer;\\n    void minimumTimeRequiredHelper(vector<int>& jobs, int index, int n, int k,\\n                                  vector<int>& workersMap) {\\n        if (index == n) {\\n            int temp = INT_MIN;\\n            for (auto& val : workersMap) {\\n                temp = max(temp, val);\\n            }\\n            answer = min(temp, answer);\\n            return;\\n        }\\n        \\n        unordered_set<int> seen;\\n        for (int i = 0; i < k; i++) {\\n            if (seen.find(workersMap[i]) != seen.end()) continue;\\n            if (workersMap[i] + jobs[index] > answer) continue;\\n            seen.insert(workersMap[i]);\\n            workersMap[i] = workersMap[i] + jobs[index];\\n            minimumTimeRequiredHelper(jobs, index + 1, n, k, workersMap);\\n            workersMap[i] = workersMap[i] - jobs[index];\\n        }\\n    }\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size();\\n        vector<int> workersMap(k, 0);\\n        answer = INT_MAX;\\n        minimumTimeRequiredHelper(jobs, 0, n, k, workersMap);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int answer;\\n    void minimumTimeRequiredHelper(vector<int>& jobs, int index, int n, int k,\\n                                  vector<int>& workersMap) {\\n        if (index == n) {\\n            int temp = INT_MIN;\\n            for (auto& val : workersMap) {\\n                temp = max(temp, val);\\n            }\\n            answer = min(temp, answer);\\n            return;\\n        }\\n        \\n        unordered_set<int> seen;\\n        for (int i = 0; i < k; i++) {\\n            if (seen.find(workersMap[i]) != seen.end()) continue;\\n            if (workersMap[i] + jobs[index] > answer) continue;\\n            seen.insert(workersMap[i]);\\n            workersMap[i] = workersMap[i] + jobs[index];\\n            minimumTimeRequiredHelper(jobs, index + 1, n, k, workersMap);\\n            workersMap[i] = workersMap[i] - jobs[index];\\n        }\\n    }\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size();\\n        vector<int> workersMap(k, 0);\\n        answer = INT_MAX;\\n        minimumTimeRequiredHelper(jobs, 0, n, k, workersMap);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009880,
                "title": "java-bitmask-dp",
                "content": "Since the array size is no more than 12, we can use the bitmask to cover all different job assignment cases for one worker. Use an array cost to store the time for each assignment. \\nDefine a 2-D array dp[1<<n][k] where dp[i][j] means the minimal cost of job assigment i on (j+1) workers. So dp[:][0] equals to cost. Then the transformation function should be \\n- If dp[i | j][l] is not updated yet, dp[i | j][l] = Max(dp[i][l-1], cost[l]) where (i & j) == 0. \\n- If dp[i | j][l] is already updated, dp[i | j][l] = Min(dp[i | j][l], Max(dp[i][l-1], cost[l])) where (i & j) == 0. \\n- Here (i & j) == 0 is to ensure the two assignment cases are not overlapping then the new case (i | j) can be seperately given to two workers.\\n\\n```java\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int n = jobs.length;\\n        int[] cost = new int[1 << n];\\n        \\n        for (int i = 1; i < (1 << n); ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if ((i & (1 << j)) != 0) {\\n                    cost[i] += jobs[j];\\n                }\\n            }\\n        }\\n        \\n        int[][] dp = new int[1 << n][k];\\n        for (int i = 0; i < (1<<n); ++i) {\\n            dp[i][0] = cost[i];\\n        }\\n        \\n        for (int j = 1; j < k; ++j) {\\n            for (int i = 0; i < (1<<n); ++i) {\\n                for (int l = 0; l < (1<<n); ++l) {\\n                    if ((i & l) == 0) {\\n                        if (dp[i | l][j] == 0) \\n                            dp[i | l][j] = Math.max(dp[i][j-1], cost[l]);\\n                        else\\n                            dp[i | l][j] = Math.min(dp[i | l][j], Math.max(dp[i][j-1], cost[l]));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[(1 << n) - 1][k-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int n = jobs.length;\\n        int[] cost = new int[1 << n];\\n        \\n        for (int i = 1; i < (1 << n); ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if ((i & (1 << j)) != 0) {\\n                    cost[i] += jobs[j];\\n                }\\n            }\\n        }\\n        \\n        int[][] dp = new int[1 << n][k];\\n        for (int i = 0; i < (1<<n); ++i) {\\n            dp[i][0] = cost[i];\\n        }\\n        \\n        for (int j = 1; j < k; ++j) {\\n            for (int i = 0; i < (1<<n); ++i) {\\n                for (int l = 0; l < (1<<n); ++l) {\\n                    if ((i & l) == 0) {\\n                        if (dp[i | l][j] == 0) \\n                            dp[i | l][j] = Math.max(dp[i][j-1], cost[l]);\\n                        else\\n                            dp[i | l][j] = Math.min(dp[i | l][j], Math.max(dp[i][j-1], cost[l]));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[(1 << n) - 1][k-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009854,
                "title": "javascript-easy-to-understand-code-backtracking",
                "content": "```\\nvar minimumTimeRequired = function (A, k) {\\n  const N = A.length;\\n  let res = Infinity;\\n  const worker = Array(k).fill(0);\\n\\u200B\\n  const dfs = (idx = 0) => {\\n    if (idx === N) {\\n      res = Math.min(res, Math.max(...worker));\\n      return;\\n    }\\n\\u200B\\n    for (let i = 0; i < k; i++) {\\n      if (worker[i] + A[idx] > res) continue;\\n      worker[i] += A[idx];\\n      dfs(idx + 1);\\n      worker[i] -= A[idx];\\n      if (!worker[i]) break;\\n    }\\n  };\\n  dfs();\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumTimeRequired = function (A, k) {\\n  const N = A.length;\\n  let res = Infinity;\\n  const worker = Array(k).fill(0);\\n\\u200B\\n  const dfs = (idx = 0) => {\\n    if (idx === N) {\\n      res = Math.min(res, Math.max(...worker));\\n      return;\\n    }\\n\\u200B\\n    for (let i = 0; i < k; i++) {\\n      if (worker[i] + A[idx] > res) continue;\\n      worker[i] += A[idx];\\n      dfs(idx + 1);\\n      worker[i] -= A[idx];\\n      if (!worker[i]) break;\\n    }\\n  };\\n  dfs();\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3792844,
                "title": "beats-100-simplest-and-best-solution-ever-existed",
                "content": "# Intuition\\nsimple brute force with some minute optimisations.\\n\\n# Approach\\nRead the code you will get it.\\n\\n# Complexity\\n- Time complexity:\\n    Homework\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int index, int n, vector<int> &jobs, vector<int> &dp, int &ans){\\n        if(index == n){\\n            ans = min(ans, *max_element(dp.begin(), dp.end()));\\n            return;\\n        }\\n\\n        if(*max_element(dp.begin(),dp.end()) >= ans)\\n            return;\\n\\n        for(int i = 0; i < dp.size(); i++){\\n            if(i > 0 and dp[i] >= dp[i - 1])continue;\\n            dp[i] += jobs[index];\\n            solve(index + 1, n, jobs, dp, ans);\\n            dp[i] -= jobs[index];\\n        }\\n\\n\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int> dp(k);\\n        int ans = INT_MAX;\\n        int n = jobs.size();\\n        sort(jobs.begin(),jobs.end(),greater<int>());\\n        solve(0, n, jobs, dp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int index, int n, vector<int> &jobs, vector<int> &dp, int &ans){\\n        if(index == n){\\n            ans = min(ans, *max_element(dp.begin(), dp.end()));\\n            return;\\n        }\\n\\n        if(*max_element(dp.begin(),dp.end()) >= ans)\\n            return;\\n\\n        for(int i = 0; i < dp.size(); i++){\\n            if(i > 0 and dp[i] >= dp[i - 1])continue;\\n            dp[i] += jobs[index];\\n            solve(index + 1, n, jobs, dp, ans);\\n            dp[i] -= jobs[index];\\n        }\\n\\n\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int> dp(k);\\n        int ans = INT_MAX;\\n        int n = jobs.size();\\n        sort(jobs.begin(),jobs.end(),greater<int>());\\n        solve(0, n, jobs, dp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217052,
                "title": "c-solution-dp-with-bit-masking",
                "content": "```\\nclass Solution {\\nprivate:\\n    //dp table defined by two variables:-\\n    //k->the current worker\\n    //mask->bitmask which stores the jobs that have already been assigned\\n    vector<vector<int>>mem;\\n    //stores the time it takes to complete various configurations of jobs\\n    vector<int>time;\\n    int jobTime(vector<int>&jobs,int mask){\\n        int ans=0;\\n        while(mask){\\n            int pos=log2(mask&(-mask));\\n            mask-=mask&(-mask);\\n            ans+=jobs[pos];\\n        }\\n        return ans;\\n    }\\n    int solve(vector<int>&jobs,int k,int mask){\\n        int n=jobs.size();\\n        if(mask==(1<<n)-1){\\n            return 0;\\n        } else if(k==0){\\n            return INT_MAX;\\n        } else if(mem[k][mask]!=-1){\\n            return mem[k][mask];\\n        } else {\\n            int ans=INT_MAX;\\n            //finding the remaining jobs that have not been assigned to any worker\\n            int remainingJobs=((1<<n)-1)^mask;\\n            //iterate through the subsets of these available jobs and assign each of them to the \\n            //current worker, and store the minimum out of all these.\\n            for(int submask=remainingJobs;submask>0;submask=(submask-1)&remainingJobs){\\n                ans=min(ans,max(time[submask],solve(jobs,k-1,mask|submask)));\\n            }\\n            return mem[k][mask]=ans;\\n        }\\n    }\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n=jobs.size();\\n        time=vector<int>(1<<n,0);\\n        for(int mask=0;mask<(1<<n);mask++){\\n            time[mask]=jobTime(jobs,mask);\\n        }\\n        mem=vector<vector<int>>(k+1,vector<int>(1<<n,-1));\\n        return solve(jobs,k,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\nprivate:\\n    //dp table defined by two variables:-\\n    //k->the current worker\\n    //mask->bitmask which stores the jobs that have already been assigned\\n    vector<vector<int>>mem;\\n    //stores the time it takes to complete various configurations of jobs\\n    vector<int>time;\\n    int jobTime(vector<int>&jobs,int mask){\\n        int ans=0;\\n        while(mask){\\n            int pos=log2(mask&(-mask));\\n            mask-=mask&(-mask);\\n            ans+=jobs[pos];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1757820,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ok(int max_Time,int job_id,vector<int>& jobs,int k,vector<int>& workers){\\n        if(job_id==jobs.size()){\\n            return true;\\n        }\\n        for(int i=0;i<k;i++){\\n            if(workers[i]+jobs[job_id]<=max_Time){\\n                workers[i] += jobs[job_id];\\n                if(ok(max_Time,job_id+1,jobs,k,workers)){\\n                    return true;\\n                }\\n                workers[i] -= jobs[job_id];\\n            }\\n            if(workers[i]==0){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int> workers(k);\\n        sort(jobs.rbegin(),jobs.rend());\\n        int l = *max_element(jobs.begin(),jobs.end()),r = accumulate(jobs.begin(),jobs.end(),0),ans = r;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            fill(workers.begin(),workers.end(),0);\\n            if(ok(mid,0,jobs,k,workers)){\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ok(int max_Time,int job_id,vector<int>& jobs,int k,vector<int>& workers){\\n        if(job_id==jobs.size()){\\n            return true;\\n        }\\n        for(int i=0;i<k;i++){\\n            if(workers[i]+jobs[job_id]<=max_Time){\\n                workers[i] += jobs[job_id];\\n                if(ok(max_Time,job_id+1,jobs,k,workers)){\\n                    return true;\\n                }\\n                workers[i] -= jobs[job_id];\\n            }\\n            if(workers[i]==0){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int> workers(k);\\n        sort(jobs.rbegin(),jobs.rend());\\n        int l = *max_element(jobs.begin(),jobs.end()),r = accumulate(jobs.begin(),jobs.end(),0),ans = r;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            fill(workers.begin(),workers.end(),0);\\n            if(ok(mid,0,jobs,k,workers)){\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462937,
                "title": "backtracking-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void backtrack(int i,vector<int>&w,vector<int>&jobs,int x){\\n        if(i==jobs.size()){\\n            int k=INT_MIN;\\n            for(auto a:w) k=max(a,k);\\n            ans=min(ans,k);\\n            return;\\n        }\\n        if(x!=0){\\n        for(int j=i;j<w.size();j++){\\n           int k=INT_MIN;\\n           for(auto a:w) k=max(k,a);\\n           if(k<ans){\\n                w[j]+=jobs[i];\\n                backtrack(i+1,w,jobs,x-1);\\n                w[j]-=jobs[i];\\n            }\\n        }}\\n       else if(x==0){\\n        for(int j=0;j<w.size();j++){\\n           int k=INT_MIN;\\n           for(auto a:w) k=max(k,a);\\n           if(k<ans){\\n                w[j]+=jobs[i];\\n                backtrack(i+1,w,jobs,0);\\n                w[j]-=jobs[i];\\n            }\\n        }\\n    }\\n        return;\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int>w(k,0);\\n        sort(jobs.begin(), jobs.end(), greater<int>());\\n        backtrack(0,w,jobs,k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void backtrack(int i,vector<int>&w,vector<int>&jobs,int x){\\n        if(i==jobs.size()){\\n            int k=INT_MIN;\\n            for(auto a:w) k=max(a,k);\\n            ans=min(ans,k);\\n            return;\\n        }\\n        if(x!=0){\\n        for(int j=i;j<w.size();j++){\\n           int k=INT_MIN;\\n           for(auto a:w) k=max(k,a);\\n           if(k<ans){\\n                w[j]+=jobs[i];\\n                backtrack(i+1,w,jobs,x-1);\\n                w[j]-=jobs[i];\\n            }\\n        }}\\n       else if(x==0){\\n        for(int j=0;j<w.size();j++){\\n           int k=INT_MIN;\\n           for(auto a:w) k=max(k,a);\\n           if(k<ans){\\n                w[j]+=jobs[i];\\n                backtrack(i+1,w,jobs,0);\\n                w[j]-=jobs[i];\\n            }\\n        }\\n    }\\n        return;\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int>w(k,0);\\n        sort(jobs.begin(), jobs.end(), greater<int>());\\n        backtrack(0,w,jobs,k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010006,
                "title": "no-pruning-clean-java-top-down-dp-o-k-3-n",
                "content": "Pruning might pass OJ but its complexity is hard to justify. This is a dp problem\\nFor a given state\\n(person, available jobs)\\nWe assign a subset of those jobs to the person. Enumerating the SUBSET of all subsets is O(3^n), and we do it on all the workers. Note we are using a lookup table to accelerate subset sum calculation. There is no need to do it again and again in recursion\\n```\\n  class Solution {\\n    private int[] lookup;\\n    private Integer[][] dp;\\n    public int minimumTimeRequired(int[] a, int k) {\\n        int n = a.length;\\n        lookup = new int[1<<n];\\n        // for every subset, calculate the sum\\n        for(int i=0; i<1<<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(((i>>j)&1)==1){\\n                    lookup[i] += a[j];\\n                }\\n            }\\n        }\\n        dp = new Integer[k][1<<n];\\n        return domin(a, k, 0, (1<<n)-1);\\n    }\\n    \\n    private int Max = 1000000000;\\n    \\n    // st is the mask for tasks waiting to be assigned. at the beginning it\\'s all 1 meaning all are waiting ot be assigned\\n    private int domin(int[] a, int k, int i, int st){\\n        int n = a.length;\\n        if(i==k){\\n            return (st==0)? 0: Max;  \\n\\t\\t\\t// only vaid when all tasks are assigned\\n        }\\n        if(dp[i][st]!= null){\\n            return dp[i][st];\\n        }\\n        int res = Max;\\n        // this is to enumerate all possible subsets of st\\n        for(int sub=st; sub>0; sub = ((sub-1) & st)){            \\n            // excluding sub, st now remains st-sub for the next worker to pick\\n            int laterres = domin(a, k, i+1, st-sub);\\n            int cur = lookup[sub];\\n            int curres = Math.max(cur, laterres);\\n            res = Math.min(res, curres);\\n        }\\n        dp[i][st] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n  class Solution {\\n    private int[] lookup;\\n    private Integer[][] dp;\\n    public int minimumTimeRequired(int[] a, int k) {\\n        int n = a.length;\\n        lookup = new int[1<<n];\\n        // for every subset, calculate the sum\\n        for(int i=0; i<1<<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(((i>>j)&1)==1){\\n                    lookup[i] += a[j];\\n                }\\n            }\\n        }\\n        dp = new Integer[k][1<<n];\\n        return domin(a, k, 0, (1<<n)-1);\\n    }\\n    \\n    private int Max = 1000000000;\\n    \\n    // st is the mask for tasks waiting to be assigned. at the beginning it\\'s all 1 meaning all are waiting ot be assigned\\n    private int domin(int[] a, int k, int i, int st){\\n        int n = a.length;\\n        if(i==k){\\n            return (st==0)? 0: Max;  \\n\\t\\t\\t// only vaid when all tasks are assigned\\n        }\\n        if(dp[i][st]!= null){\\n            return dp[i][st];\\n        }\\n        int res = Max;\\n        // this is to enumerate all possible subsets of st\\n        for(int sub=st; sub>0; sub = ((sub-1) & st)){            \\n            // excluding sub, st now remains st-sub for the next worker to pick\\n            int laterres = domin(a, k, i+1, st-sub);\\n            int cur = lookup[sub];\\n            int curres = Math.max(cur, laterres);\\n            res = Math.min(res, curres);\\n        }\\n        dp[i][st] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716520,
                "title": "simple-binary-search-bitmask-dp-solution",
                "content": "# Intuition\\nBinary search over time and make a function to find number of workers needed to complete all jobs within a given time. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search over time and make a function to find minimum number of workers needed to complete all jobs within a given time using bitmask-dp if number of worker is less than k change high to mid else change low to mid. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n ;\\n    int fun(int x , int k , vector<int>& jobs){\\n        vector<pair<int,int>> dp((1<<n),{n+1,0}) ;\\n        dp[0]={1,0} ;\\n        for(int mask=0 ; mask<(1<<n) ; mask++){\\n            for(int j=0 ; j<n ; j++){\\n                if(jobs[j]>x) return 0 ;\\n                if((mask&(1<<j))==0){\\n                    int worker=dp[mask].first , time=dp[mask].second ;\\n                    if(time+jobs[j]<=x){\\n                        dp[(mask|(1<<j))]=min(dp[(mask|(1<<j))],{worker,time+jobs[j]}) ;\\n                    }\\n                    else{\\n                        dp[(mask|(1<<j))]=min(dp[(mask|(1<<j))],{worker+1,jobs[j]}) ;\\n                    }\\n                }\\n            }\\n        }\\n        if(dp[(1<<n)-1].first<=k) return 1 ;\\n        return 0 ;\\n    }\\n\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        n=jobs.size() ;\\n        int hi=0 , lwo=0 ;\\n        for(auto d:jobs) hi+=d ;\\n        while(hi-lwo>1){\\n            int mid=(hi+lwo)/2 ;\\n            if(fun(mid,k,jobs)) hi=mid ;\\n            else lwo=mid ;\\n        }\\n        if(fun(lwo,k,jobs)) return lwo ;\\n        return hi ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n ;\\n    int fun(int x , int k , vector<int>& jobs){\\n        vector<pair<int,int>> dp((1<<n),{n+1,0}) ;\\n        dp[0]={1,0} ;\\n        for(int mask=0 ; mask<(1<<n) ; mask++){\\n            for(int j=0 ; j<n ; j++){\\n                if(jobs[j]>x) return 0 ;\\n                if((mask&(1<<j))==0){\\n                    int worker=dp[mask].first , time=dp[mask].second ;\\n                    if(time+jobs[j]<=x){\\n                        dp[(mask|(1<<j))]=min(dp[(mask|(1<<j))],{worker,time+jobs[j]}) ;\\n                    }\\n                    else{\\n                        dp[(mask|(1<<j))]=min(dp[(mask|(1<<j))],{worker+1,jobs[j]}) ;\\n                    }\\n                }\\n            }\\n        }\\n        if(dp[(1<<n)-1].first<=k) return 1 ;\\n        return 0 ;\\n    }\\n\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        n=jobs.size() ;\\n        int hi=0 , lwo=0 ;\\n        for(auto d:jobs) hi+=d ;\\n        while(hi-lwo>1){\\n            int mid=(hi+lwo)/2 ;\\n            if(fun(mid,k,jobs)) hi=mid ;\\n            else lwo=mid ;\\n        }\\n        if(fun(lwo,k,jobs)) return lwo ;\\n        return hi ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703126,
                "title": "same-code-as-2305-fair-distribution-of-cookies",
                "content": "refer for the code :\\nhttps://leetcode.com/problems/fair-distribution-of-cookies/discuss/3703131/Easy-C++-oror-Backtracking-oror-Beats-100-oror-same-code-solves-another-HardProblem\\n```\\nclass Solution {\\npublic:\\n    int unfairness=INT_MAX;\\n    \\n    void sol(int i, vector<int>& nums, vector<int>& ans, int k){\\n        int n=nums.size();\\n        if(i==n){\\n            int max_cookie = *max_element(ans.begin(),ans.end());\\n            unfairness=min(unfairness,max_cookie);\\n            return ;\\n        }\\n        unordered_set<int> vis;\\n        for(int j=0;j<k;j++){\\n\\t\\t\\tif(vis.count( ans[j] )) continue;\\n\\t\\t\\tvis.insert( ans[j] );\\n            ans[j]+=nums[i];\\n            if(*max_element(ans.begin(),ans.end())<unfairness){\\n            sol(i+1,nums,ans,k);}\\n            ans[j]-=nums[i];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n=cookies.size();\\n        vector<int>ans(n,0);\\n        sol(0,cookies,ans,k);\\n        return unfairness;\\n    }\\n    int minimumTimeRequired(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end() , greater<int>());\\n        return distributeCookies(nums,k);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/2c43efc0-003a-4273-a8e3-346fded19a32_1688643693.65213.jpeg)\\n\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unfairness=INT_MAX;\\n    \\n    void sol(int i, vector<int>& nums, vector<int>& ans, int k){\\n        int n=nums.size();\\n        if(i==n){\\n            int max_cookie = *max_element(ans.begin(),ans.end());\\n            unfairness=min(unfairness,max_cookie);\\n            return ;\\n        }\\n        unordered_set<int> vis;\\n        for(int j=0;j<k;j++){\\n\\t\\t\\tif(vis.count( ans[j] )) continue;\\n\\t\\t\\tvis.insert( ans[j] );\\n            ans[j]+=nums[i];\\n            if(*max_element(ans.begin(),ans.end())<unfairness){\\n            sol(i+1,nums,ans,k);}\\n            ans[j]-=nums[i];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n=cookies.size();\\n        vector<int>ans(n,0);\\n        sol(0,cookies,ans,k);\\n        return unfairness;\\n    }\\n    int minimumTimeRequired(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end() , greater<int>());\\n        return distributeCookies(nums,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698784,
                "title": "c-binary-search-backtracking",
                "content": "The solution to this problem is the same as:\\n[473. Matchsticks to Square](https://leetcode.com/problems/matchsticks-to-square/description/), [Solution Here](https://leetcode.com/problems/matchsticks-to-square/solutions/2701070/c-same-as-1986-minimum-number-of-work-sessions-to-finish-the-tasks/).\\n[698. Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/solutions/), [Solotion Here](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/solutions/2705299/c-backtracking/).\\n[1986. Minimum Number of Work Sessions to Finish the Tasks](https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/description/), [Solution Here](https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/solutions/2700323/c-binary-search-backtracking-beats-97/).\\n[2305. Fair Distribution of Cookies](https://leetcode.com/problems/fair-distribution-of-cookies/description/), [Solotion Here](https://leetcode.com/problems/fair-distribution-of-cookies/solutions/2632745/c-solution-backtracking-dfs-bit-mask/).\\n\\n![\\u622A\\u5C4F2022-10-13 22.17.22.png](https://assets.leetcode.com/users/images/3ca92e0e-63cf-45b8-8e35-cded39dca8e2_1665670657.007896.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int minimumTimeRequired(vector<int> jobs, const int k) {\\n        const int n = size(jobs);\\n        int h = reduce(begin(jobs), end(jobs));\\n        int l = *max_element(begin(jobs), end(jobs));\\n        sort(begin(jobs), end(jobs), greater());\\n        vector<int> dist(k, 0);\\n\\n        function<bool(int, int)> isPossible = [&] (int i, int limit) {\\n            if (i == n)\\n                return true;\\n            for (int j = 0; j < k; ++j) {\\n                if (dist[j] + jobs[i] <= limit) {\\n                    dist[j] += jobs[i];\\n                    if (isPossible(i + 1, limit)) {\\n                        dist[j] -= jobs[i];\\n                        return true;\\n                    }\\n                    dist[j] -= jobs[i];\\n                }\\n                if (!dist[j])\\n                    break;\\n            }\\n            return false;\\n        };\\n\\n        while (l < h)\\n            if (int m = ((h - l) >> 1) + l;\\n                isPossible(0, m))\\n                h = m;\\n            else\\n                l = m + 1;\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int minimumTimeRequired(vector<int> jobs, const int k) {\\n        const int n = size(jobs);\\n        int h = reduce(begin(jobs), end(jobs));\\n        int l = *max_element(begin(jobs), end(jobs));\\n        sort(begin(jobs), end(jobs), greater());\\n        vector<int> dist(k, 0);\\n\\n        function<bool(int, int)> isPossible = [&] (int i, int limit) {\\n            if (i == n)\\n                return true;\\n            for (int j = 0; j < k; ++j) {\\n                if (dist[j] + jobs[i] <= limit) {\\n                    dist[j] += jobs[i];\\n                    if (isPossible(i + 1, limit)) {\\n                        dist[j] -= jobs[i];\\n                        return true;\\n                    }\\n                    dist[j] -= jobs[i];\\n                }\\n                if (!dist[j])\\n                    break;\\n            }\\n            return false;\\n        };\\n\\n        while (l < h)\\n            if (int m = ((h - l) >> 1) + l;\\n                isPossible(0, m))\\n                h = m;\\n            else\\n                l = m + 1;\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301288,
                "title": "c-dp-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int res = INT_MAX;\\n        int len = pow(2, jobs.size()); //length of all possible combinations\\n\\n        //here dp[i][j] is what time is needed for i forkers to finish j work\\n\\t\\tvector<vector<int>> dp(k, vector<int>(len, 1717171717171717));\\n        \\n        for(int i = 0; i < len; i++){       \\n            int sum = 0;\\n            for(int j = 0; j < jobs.size(); j++){\\n                if(i & (1 << j)) sum += jobs[j];\\n            }\\n\\t\\t\\t// minimum time to finish i work if we had 1 worker\\n            dp[0][i] = sum;\\n        }\\n        \\n        for(int t = 1; t < k; t++){\\n            for(int i = 0; i < len; i++){\\n                for(int j = i; j; j = (j-1)&i){\\n\\t\\t\\t\\t\\t//with this (j) loop we iterate through all possible submasks (for 101, submasks are 100, 001)\\n                    dp[t][i] = min(dp[t][i], max(dp[t-1][j], dp[0][j ^ i]));\\n\\t\\t\\t\\t\\t// dp[t][i] will be updated if we can do job 100 with t - 1 workers and 001 with 1 worker\\n\\t\\t\\t\\t\\t// in a fewer time rather than current value\\n                }\\n            }   \\n        }\\n        //and we return minimum time for k workers to do all work\\n        return dp[k-1][len-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int res = INT_MAX;\\n        int len = pow(2, jobs.size()); //length of all possible combinations\\n\\n        //here dp[i][j] is what time is needed for i forkers to finish j work\\n\\t\\tvector<vector<int>> dp(k, vector<int>(len, 1717171717171717));\\n        \\n        for(int i = 0; i < len; i++){       \\n            int sum = 0;\\n            for(int j = 0; j < jobs.size(); j++){\\n                if(i & (1 << j)) sum += jobs[j];\\n            }\\n\\t\\t\\t// minimum time to finish i work if we had 1 worker\\n            dp[0][i] = sum;\\n        }\\n        \\n        for(int t = 1; t < k; t++){\\n            for(int i = 0; i < len; i++){\\n                for(int j = i; j; j = (j-1)&i){\\n\\t\\t\\t\\t\\t//with this (j) loop we iterate through all possible submasks (for 101, submasks are 100, 001)\\n                    dp[t][i] = min(dp[t][i], max(dp[t-1][j], dp[0][j ^ i]));\\n\\t\\t\\t\\t\\t// dp[t][i] will be updated if we can do job 100 with t - 1 workers and 001 with 1 worker\\n\\t\\t\\t\\t\\t// in a fewer time rather than current value\\n                }\\n            }   \\n        }\\n        //and we return minimum time for k workers to do all work\\n        return dp[k-1][len-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266761,
                "title": "minimum-time-to-finish-all-jobs-solution-c-backtracking",
                "content": "Below is the code with proper comments, feel free to comments if not understood.\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& jobs, vector<int>& temp, int index, int m, int& ans){\\n        // base case\\n        if(index>=jobs.size()){\\n            ans = min(ans, m);\\n            return ;\\n        }\\n        \\n        // another corner case - to reduce  redundant calls\\n        // when our m exceeds the previous min value at any pt of time we shall return\\n        // without going deeper since addition of values will only increase m\\n        if(m>=ans) return ;\\n        \\n        for(int i=0; i<temp.size(); i++){\\n            // if at any pt. we have same values in temp[i] and temp[i-1] then we\\n            // should not repeat the process of adding, [repeated calls].\\n            if(i>0 && temp[i]==temp[i-1]) continue;\\n\\n            temp[i] += jobs[index];\\n            int t = m;\\n            m = max(m, temp[i]);\\n            solve(jobs, temp, index+1, m, ans);\\n            m = t;\\n            temp[i] -= jobs[index];\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int> temp(k, 0);\\n        int m = INT_MIN;\\n        int ans = INT_MAX;\\n        // sorting in reverse order as we are taking the max of the array which, we will get\\n        // by taking larger nos. in faster time\\n        sort(jobs.rbegin(), jobs.rend());\\n        solve(jobs, temp, 0, m, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& jobs, vector<int>& temp, int index, int m, int& ans){\\n        // base case\\n        if(index>=jobs.size()){\\n            ans = min(ans, m);\\n            return ;\\n        }\\n        \\n        // another corner case - to reduce  redundant calls\\n        // when our m exceeds the previous min value at any pt of time we shall return\\n        // without going deeper since addition of values will only increase m\\n        if(m>=ans) return ;\\n        \\n        for(int i=0; i<temp.size(); i++){\\n            // if at any pt. we have same values in temp[i] and temp[i-1] then we\\n            // should not repeat the process of adding, [repeated calls].\\n            if(i>0 && temp[i]==temp[i-1]) continue;\\n\\n            temp[i] += jobs[index];\\n            int t = m;\\n            m = max(m, temp[i]);\\n            solve(jobs, temp, index+1, m, ans);\\n            m = t;\\n            temp[i] -= jobs[index];\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int> temp(k, 0);\\n        int m = INT_MIN;\\n        int ans = INT_MAX;\\n        // sorting in reverse order as we are taking the max of the array which, we will get\\n        // by taking larger nos. in faster time\\n        sort(jobs.rbegin(), jobs.rend());\\n        solve(jobs, temp, 0, m, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255841,
                "title": "python-implementation-of-the-theoretically-optimal-o-3-n-solution",
                "content": "Here\\'s an implementation in python of the theoretically optimal solution in O(3^N). All the other posted python solutions at this time are not theoretically optimal and just implement backtracking with different pruning techniques to fit the time limit.\\n\\nI struggled a bit to get the solution to fit into the time limit as well (despite earlier versions being theorically optimal). The most helpful optimizations were:\\n1. Precompute the 2^N costs of assigning a set of jobs to any worker (aka `worker_cost` below).\\n2. Use `worker_state = (worker_state - 1) & state` trick to iterate through the eligible substates for a given state. The intuition behind this trick is that `worker_state - 1` will flip the rightmost bit of 1 to 0 and all the following 0 bits to 1 (and keep preceding bits unchanged). By applying the `&` operation against the original `state` we keep just the following bits which are valid as part of `state` (`& state` ensures we select a subset of bits of `state` for the substate `worker_state`).\\n\\n```\\nclass Solution:    \\n    def minimumTimeRequired(self, jobs: List[int], num_workers: int) -> int:\\n        n = len(jobs)\\n        worker_cost = [0] * (1 << n)\\n        for state in range(1 << n):\\n            for i in range(n):\\n                if state & (1 << i):\\n                    worker_cost[state] += jobs[i]\\n                    \\n        @functools.cache\\n        def compute_time(state: int, curr_workers: int) -> int:\\n            if curr_workers == 1:\\n                return worker_cost[state]\\n            \\n            best = float(\"inf\")\\n            worker_state = state\\n            while worker_state:\\n                if worker_cost[worker_state] < best:\\n                    best = min(best, max(compute_time(state ^ worker_state, curr_workers - 1), worker_cost[worker_state]))\\n                worker_state = (worker_state - 1) & state\\n            \\n            return best\\n            \\n        return compute_time((1 << n) - 1, num_workers)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:    \\n    def minimumTimeRequired(self, jobs: List[int], num_workers: int) -> int:\\n        n = len(jobs)\\n        worker_cost = [0] * (1 << n)\\n        for state in range(1 << n):\\n            for i in range(n):\\n                if state & (1 << i):\\n                    worker_cost[state] += jobs[i]\\n                    \\n        @functools.cache\\n        def compute_time(state: int, curr_workers: int) -> int:\\n            if curr_workers == 1:\\n                return worker_cost[state]\\n            \\n            best = float(\"inf\")\\n            worker_state = state\\n            while worker_state:\\n                if worker_cost[worker_state] < best:\\n                    best = min(best, max(compute_time(state ^ worker_state, curr_workers - 1), worker_cost[worker_state]))\\n                worker_state = (worker_state - 1) & state\\n            \\n            return best\\n            \\n        return compute_time((1 << n) - 1, num_workers)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808503,
                "title": "java-two-methods-1ms-10ms-with-very-detailed-explanation",
                "content": "\\nMethod 1:\\n1ms\\n\\nthinking process:\\n1) vanilla backtracking will encouter TLE, how to make it faster? first of all, we can check before recursing if the working time is already larger than result, then no need to go into the recursion. This is a simple improvement, but not enough yet.\\n2) how about stopping recursion sooner for the unsuitable scenarios?\\n3) if reach optimal solution faster, so the result will be updated to a small value, and anything max > result will no longer be considered\\n\\n (4&5 corresponding to \" if (used < k) \" part in the code)\\n4. logically, we should try to assign the jobs to workers \"equally\" to make the max total working time smaller\\n5. therefore for recursion, prioritize giving tasks to people who are free right now.  (the \"used\" variable in my code)\\n\\n(6&7 corresponding to \" for (int i = 0; i < used; i++)  \" part in the code)\\n6. if after giving any free worker a job, still not finish all jobs, then iterate through normal cases (worker index from 0 to k -1).\\n7. in case of backtracking, for example workers ABC, when C get backtracked, loop will consider 2 cases(A,B) now rather than all 3 cases, but immediately in the next recursiong call, C will be used.  Again, the idea is that we are trying to assign the jobs to workers \"equally\" \\n\\n```\\nclass Solution {\\n    int result = Integer.MAX_VALUE;\\n    int[] working_time;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        working_time = new int[k];\\n        dfs(jobs, 0, 0, k,0);\\n        return result;\\n    }\\n    public void dfs(int[] jobs, int job_index, int max, int k, int used) {\\n        if (max >= result){\\n            return;\\n        }\\n        if (job_index == jobs.length ) {\\n            result = max;\\n            return;\\n        }\\n        if (used < k) {\\n            if (working_time[used] + jobs[job_index] < result) {\\n                working_time[used] += jobs[job_index];            \\n                dfs(jobs, job_index + 1, Math.max(max, working_time[used]), k, used + 1);\\n                working_time[used] -= jobs[job_index];\\n            }\\n        }\\n        for (int i = 0; i < used; i++) {\\n            if (working_time[i] + jobs[job_index] < result) {\\n                working_time[i] += jobs[job_index];\\n                dfs(jobs, job_index + 1, Math.max(max, working_time[i]), k, used);\\n                working_time[i] -= jobs[job_index];\\n            }\\n        }\\n    }\\n}\\n```\\n\\n\\n\\nMethod 2:\\n10ms\\n\\nkey insight: hashset for same layer to track what numbers have been considered already to avoid duplicates.\\nTo understand it, think about if  two or more workers have the same total working time right now, does it matter who you assign the job to? No, because the recursion will be the same (mirroring each other), so let\\'s not waste computing power here.\\n\\n\\n```\\n\\nclass Solution {\\n    int result = Integer.MAX_VALUE;\\n    int[] working_time;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        working_time = new int[k];\\n        dfs(jobs, 0, 0, k);\\n        return result;\\n    }\\n    public void dfs(int[] jobs, int job_index, int max, int k) {\\n        if (max >= result){\\n            return;\\n        }\\n        if (job_index == jobs.length) {\\n            result = max;\\n            return;\\n        }\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < k; i++) {\\n            working_time[i] += jobs[job_index];\\n            if (working_time[i] < result && !set.contains(working_time[i])) {\\n                set.add(working_time[i]);\\n                dfs(jobs, job_index + 1, Math.max(max, working_time[i]), k);\\n            }       \\n            working_time[i] -= jobs[job_index];\\n        }\\n    }\\n}\\n```\\n\\nImportant takeaway from this question is proper branch cutting technique :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int result = Integer.MAX_VALUE;\\n    int[] working_time;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        working_time = new int[k];\\n        dfs(jobs, 0, 0, k,0);\\n        return result;\\n    }\\n    public void dfs(int[] jobs, int job_index, int max, int k, int used) {\\n        if (max >= result){\\n            return;\\n        }\\n        if (job_index == jobs.length ) {\\n            result = max;\\n            return;\\n        }\\n        if (used < k) {\\n            if (working_time[used] + jobs[job_index] < result) {\\n                working_time[used] += jobs[job_index];            \\n                dfs(jobs, job_index + 1, Math.max(max, working_time[used]), k, used + 1);\\n                working_time[used] -= jobs[job_index];\\n            }\\n        }\\n        for (int i = 0; i < used; i++) {\\n            if (working_time[i] + jobs[job_index] < result) {\\n                working_time[i] += jobs[job_index];\\n                dfs(jobs, job_index + 1, Math.max(max, working_time[i]), k, used);\\n                working_time[i] -= jobs[job_index];\\n            }\\n        }\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    int result = Integer.MAX_VALUE;\\n    int[] working_time;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        working_time = new int[k];\\n        dfs(jobs, 0, 0, k);\\n        return result;\\n    }\\n    public void dfs(int[] jobs, int job_index, int max, int k) {\\n        if (max >= result){\\n            return;\\n        }\\n        if (job_index == jobs.length) {\\n            result = max;\\n            return;\\n        }\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < k; i++) {\\n            working_time[i] += jobs[job_index];\\n            if (working_time[i] < result && !set.contains(working_time[i])) {\\n                set.add(working_time[i]);\\n                dfs(jobs, job_index + 1, Math.max(max, working_time[i]), k);\\n            }       \\n            working_time[i] -= jobs[job_index];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220522,
                "title": "swift-binary-search-and-dfs-100",
                "content": "Sorting the jobs in descending order isn\\'t necessary, however it greatly reduces the runtime by preventing extra work from being done in the ***isValid*** function. We greedily give each worker the most workload that can be done during the time frame, **workload + jobs[n] > time**  before we give the next job to the next worker.\\n\\n```\\nclass Solution {\\n    /*\\n    Task:   \\n        1. Sort the jobs in descending order. Why? \\n    \\n        2. Perform Binary search where the low will be the maximum job time in the array and high will be the total sum of all jobs\\n    \\n            I. The mid will be the amount of time allocated for workers to do as many jobs as needed (maximum working time). \\n    \\n            II. If the worker can\\'t do the job, we check if the next worker can do it. If a worker is assigned the job, we check if this leads to all jobs being finished. We backtrack whenever we fail to finish all jobs and check if the next worker can do it.\\n    \\n            II. If the time given is enough for all k workers to finish all jobs, we reduce the time to find the next shortest time (minimum possible maximum working time).\\n    \\n            III. Otherwise, the time is not enough and there will be a worker who will not be able to finish the remaining jobs, workers[index] == 0. Without this condition, you\\'ll get an infinite loop. \\n    */\\n    \\n    func minimumTimeRequired(_ jobs: [Int], _ k: Int) -> Int {\\n        var jobs = jobs.sorted { $0 > $1 }   \\n        var low = jobs.max()!\\n        var high = jobs.reduce(0,+) \\n        \\n        while low < high {\\n            \\n            let mid = low + (high - low)/2\\n            \\n            // How much time a worker spends on 1 or many jobs\\n            var workers: [Int] = Array(repeating: 0, count:k)\\n            if !isValid(jobs, &workers, mid, 0) {\\n                low = mid + 1\\n            } else {\\n                high = mid\\n            }\\n        }\\n        return low\\n    }\\n    \\n    func isValid(_ jobs: [Int], _ workers: inout [Int], _ time: Int, _ n: Int) -> Bool {\\n        if n == jobs.count { return true }\\n        \\n        for index in 0..<workers.count {\\n            let workload = workers[index]\\n                        \\n            // Worker will not be able to do this job, try the next worker\\n            if workload + jobs[n] > time { continue }\\n            \\n            // Give this worker this job \\n            workers[index] += jobs[n]\\n            \\n            if isValid(jobs, &workers, time, n+1) {\\n                return true\\n            }\\n                \\n            // Backtrack, giving this job to this worker didn\\'t complete all jobs\\n            workers[index] -= jobs[n]\\n            \\n            // A worker wasn\\'t able to complete the remaining jobs due to insufficient time\\n            if workers[index] == 0 { return false } \\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    Task:   \\n        1. Sort the jobs in descending order. Why? \\n    \\n        2. Perform Binary search where the low will be the maximum job time in the array and high will be the total sum of all jobs\\n    \\n            I. The mid will be the amount of time allocated for workers to do as many jobs as needed (maximum working time). \\n    \\n            II. If the worker can\\'t do the job, we check if the next worker can do it. If a worker is assigned the job, we check if this leads to all jobs being finished. We backtrack whenever we fail to finish all jobs and check if the next worker can do it.\\n    \\n            II. If the time given is enough for all k workers to finish all jobs, we reduce the time to find the next shortest time (minimum possible maximum working time).\\n    \\n            III. Otherwise, the time is not enough and there will be a worker who will not be able to finish the remaining jobs, workers[index] == 0. Without this condition, you\\'ll get an infinite loop. \\n    */\\n    \\n    func minimumTimeRequired(_ jobs: [Int], _ k: Int) -> Int {\\n        var jobs = jobs.sorted { $0 > $1 }   \\n        var low = jobs.max()!\\n        var high = jobs.reduce(0,+) \\n        \\n        while low < high {\\n            \\n            let mid = low + (high - low)/2\\n            \\n            // How much time a worker spends on 1 or many jobs\\n            var workers: [Int] = Array(repeating: 0, count:k)\\n            if !isValid(jobs, &workers, mid, 0) {\\n                low = mid + 1\\n            } else {\\n                high = mid\\n            }\\n        }\\n        return low\\n    }\\n    \\n    func isValid(_ jobs: [Int], _ workers: inout [Int], _ time: Int, _ n: Int) -> Bool {\\n        if n == jobs.count { return true }\\n        \\n        for index in 0..<workers.count {\\n            let workload = workers[index]\\n                        \\n            // Worker will not be able to do this job, try the next worker\\n            if workload + jobs[n] > time { continue }\\n            \\n            // Give this worker this job \\n            workers[index] += jobs[n]\\n            \\n            if isValid(jobs, &workers, time, n+1) {\\n                return true\\n            }\\n                \\n            // Backtrack, giving this job to this worker didn\\'t complete all jobs\\n            workers[index] -= jobs[n]\\n            \\n            // A worker wasn\\'t able to complete the remaining jobs due to insufficient time\\n            if workers[index] == 0 { return false } \\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010041,
                "title": "java-20-ms-100-fastest-dfs-code-optimization-explained",
                "content": "After combine optimization ideas from discussion, I am able to get 20ms 100%.  Other comparable submissions are using dp (which is not as intuitive :) )\\n\\n1.  add a cutoff which is sum/k -- if a worker already has sum/k, it shouldn\\'t take more job\\n2.  if two or more workers have the same load, only need to try one worker.\\n3.  calculate maxInAssignment when doing dfs instead of at the end when all assigned (saving time to get max from assignment when k is big). \\n\\n\\n```\\nclass Solution {\\n    int result;\\n    int cutoff;\\n    \\n    public int minimumTimeRequired(int[] jobs, int k) {        \\n                \\n        int sum = 0;\\n        for (int job : jobs){\\n            sum += job;\\n        }\\n        cutoff = sum/k;\\n\\n        result = Integer.MAX_VALUE;\\n        dfs(jobs, n - 1, assignment, jobs[n-1]);\\n        return result;\\n    }\\n    \\n    private void dfs(int[] jobs, int idx, int[] assignment, int maxInAssignment){              \\n        \\n        if (idx < 0){            \\n            result = Math.min(result, maxInAssignment);\\n            return;\\n        }\\n        \\n        for (int i=0; i<assignment.length; i++){        \\n            if (assignment[i] > cutoff)  continue;            \\n            if (i>0 && assignment[i] == assignment[i-1]) continue;\\n            \\n            assignment[i] += jobs[idx];                       \\n            dfs(jobs, idx-1, assignment, Math.max(maxInAssignment,assignment[i]));\\n            assignment[i] -= jobs[idx];            \\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    int result;\\n    int cutoff;\\n    \\n    public int minimumTimeRequired(int[] jobs, int k) {        \\n                \\n        int sum = 0;\\n        for (int job : jobs){\\n            sum += job;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1009923,
                "title": "go-backtracking-easy-to-understand-beats-100",
                "content": "```go\\nconst MaxInt = int(^uint(0) >> 1)\\n\\nfunc minimumTimeRequired(jobs []int, k int) int {\\n    var backtrack func(int)\\n    ans, workers := MaxInt, make([]int, k)\\n    \\n    sort.Sort(sort.Reverse(sort.IntSlice(jobs)))\\n    \\n    backtrack = func (i int) {\\n        if i == len(jobs) {\\n            ans = MaxEl(workers)\\n        } else {\\n            for j := 0; j < k; j++ {\\n                if j == 0 || workers[j - 1] > workers[j] {\\n                    workers[j] += jobs[i]\\n\\n                    if MaxEl(workers) < ans {\\n                        backtrack(i + 1)\\n                    }\\n\\n                    workers[j] -= jobs[i]\\n                }\\n            }\\n        }\\n    }\\n    \\n    backtrack(0)\\n    \\n    return ans\\n}\\n\\nfunc MaxEl(ar []int) int {\\n    ans := 0\\n    \\n    for _, el := range ar {\\n        if el > ans {\\n            ans = el\\n        }\\n    }\\n    \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```go\\nconst MaxInt = int(^uint(0) >> 1)\\n\\nfunc minimumTimeRequired(jobs []int, k int) int {\\n    var backtrack func(int)\\n    ans, workers := MaxInt, make([]int, k)\\n    \\n    sort.Sort(sort.Reverse(sort.IntSlice(jobs)))\\n    \\n    backtrack = func (i int) {\\n        if i == len(jobs) {\\n            ans = MaxEl(workers)\\n        } else {\\n            for j := 0; j < k; j++ {\\n                if j == 0 || workers[j - 1] > workers[j] {\\n                    workers[j] += jobs[i]\\n\\n                    if MaxEl(workers) < ans {\\n                        backtrack(i + 1)\\n                    }\\n\\n                    workers[j] -= jobs[i]\\n                }\\n            }\\n        }\\n    }\\n    \\n    backtrack(0)\\n    \\n    return ans\\n}\\n\\nfunc MaxEl(ar []int) int {\\n    ans := 0\\n    \\n    for _, el := range ar {\\n        if el > ans {\\n            ans = el\\n        }\\n    }\\n    \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009891,
                "title": "java-dfs-pruning-100",
                "content": "```\\nclass Solution {\\n    private int answer = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        //strategy: DFS + Pruning\\n        dfs(jobs, new int[k], 0, 0);\\n        return answer;\\n    }\\n    private void dfs(int[] jobs, int[] worker, int index, int max) {\\n        //already found a better solution or reached end\\n        if (max >= answer || index == jobs.length) {\\n            answer = Math.min(answer, max);\\n            return;\\n        }\\n        //keep track of the previous work time so that our array isn\\'t a permutation of another seen state\\n        int prev = -1;\\n        for (int i = 0; i < worker.length; i++) {\\n            //don\\'t give this time to curr worker because it would be a permutation of the prev state\\n            if (worker[i] == prev) {\\n                continue;\\n            }\\n            //add to curr worker time\\n            worker[i] += jobs[index];\\n            //continue to recurse\\n            //update max time\\n            dfs(jobs, worker, index + 1, Math.max(max, worker[i]));\\n            //reset\\n            worker[i] -= jobs[index];\\n            //update prev\\n            prev = worker[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int answer = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        //strategy: DFS + Pruning\\n        dfs(jobs, new int[k], 0, 0);\\n        return answer;\\n    }\\n    private void dfs(int[] jobs, int[] worker, int index, int max) {\\n        //already found a better solution or reached end\\n        if (max >= answer || index == jobs.length) {\\n            answer = Math.min(answer, max);\\n            return;\\n        }\\n        //keep track of the previous work time so that our array isn\\'t a permutation of another seen state\\n        int prev = -1;\\n        for (int i = 0; i < worker.length; i++) {\\n            //don\\'t give this time to curr worker because it would be a permutation of the prev state\\n            if (worker[i] == prev) {\\n                continue;\\n            }\\n            //add to curr worker time\\n            worker[i] += jobs[index];\\n            //continue to recurse\\n            //update max time\\n            dfs(jobs, worker, index + 1, Math.max(max, worker[i]));\\n            //reset\\n            worker[i] -= jobs[index];\\n            //update prev\\n            prev = worker[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009886,
                "title": "java-binary-search-dfs",
                "content": "The maximum you can assign is the sum (k = 1) and the minumum possible value is max of all values (k = n). This is a standard binary search pattern. Mine was TLE during the contest, with looking at other\\'s optimization method, I was able to figure out that i need to prune the equal group such that it can avoid TLE...\\n```\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int n = jobs.length;\\n        int sum = 0;\\n        int max = 0;\\n        Arrays.sort(jobs);\\n        for(int i = 0; i < n; i++){\\n            sum += jobs[i];\\n            max = Math.max(max, jobs[i]);\\n        }\\n        int l = max, r = sum;\\n        while(l < r){\\n            int m = l + (r - l) / 2;\\n            int[] groups = new int[k];\\n            if(canPartition(jobs, groups, m, n - 1)) r = m;\\n            else l = m + 1;\\n        }\\n        return(l);\\n    }\\n    \\n    private boolean canPartition(int[] jobs, int[] groups, int val, int end){\\n        if(end < 0) return(true);\\n        int k = groups.length;\\n        Set<Integer> seen = new HashSet<>();\\n        for(int i = 0; i < k; i++){\\n            int gnum = groups[i];\\n            if(seen.contains(gnum)) continue;\\n            seen.add(gnum);\\n            if(gnum + jobs[end] <= val){\\n                groups[i] += jobs[end];\\n                if(canPartition(jobs, groups, val, end - 1)) return(true);\\n                groups[i] -= jobs[end];\\n            }\\n        }\\n        return(false);\\n        \\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int n = jobs.length;\\n        int sum = 0;\\n        int max = 0;\\n        Arrays.sort(jobs);\\n        for(int i = 0; i < n; i++){\\n            sum += jobs[i];\\n            max = Math.max(max, jobs[i]);\\n        }\\n        int l = max, r = sum;\\n        while(l < r){\\n            int m = l + (r - l) / 2;\\n            int[] groups = new int[k];\\n            if(canPartition(jobs, groups, m, n - 1)) r = m;\\n            else l = m + 1;\\n        }\\n        return(l);\\n    }\\n    \\n    private boolean canPartition(int[] jobs, int[] groups, int val, int end){\\n        if(end < 0) return(true);\\n        int k = groups.length;\\n        Set<Integer> seen = new HashSet<>();\\n        for(int i = 0; i < k; i++){\\n            int gnum = groups[i];\\n            if(seen.contains(gnum)) continue;\\n            seen.add(gnum);\\n            if(gnum + jobs[end] <= val){\\n                groups[i] += jobs[end];\\n                if(canPartition(jobs, groups, val, end - 1)) return(true);\\n                groups[i] -= jobs[end];\\n            }\\n        }\\n        return(false);\\n        \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705816,
                "title": "simple-backtracking-java-solution",
                "content": "# Approach\\nTry and distribute all jobs among all k workers and find the minimum of maxmimum work which can be distributed by backtracking. Since we have to asisgn some work to every worker, as soon as we try to assign a worker no work, we break and stop traversing in that path.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(k^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k) + O(n)$$ recursive stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    void rec(int ix, int[] jobs, int k, int[] dist, HashSet<Integer> assigned){\\n        if(ix == jobs.length){\\n            int max = 0;\\n            for(int job: dist){\\n                max = Math.max(max, job);\\n            }\\n            ans = Math.min(ans, max);\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            if(i!=0 && dist[i] == dist[i-1]) continue;\\n            dist[i] += jobs[ix];\\n            rec(ix+1, jobs, k, dist, assigned);\\n            dist[i] -= jobs[ix];\\n            if(dist[i] == 0) break;\\n        }\\n    }\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        rec(0, jobs, k, new int[k], new HashSet<Integer>());\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    void rec(int ix, int[] jobs, int k, int[] dist, HashSet<Integer> assigned){\\n        if(ix == jobs.length){\\n            int max = 0;\\n            for(int job: dist){\\n                max = Math.max(max, job);\\n            }\\n            ans = Math.min(ans, max);\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            if(i!=0 && dist[i] == dist[i-1]) continue;\\n            dist[i] += jobs[ix];\\n            rec(ix+1, jobs, k, dist, assigned);\\n            dist[i] -= jobs[ix];\\n            if(dist[i] == 0) break;\\n        }\\n    }\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        rec(0, jobs, k, new int[k], new HashSet<Integer>());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703314,
                "title": "same-code-2305-fair-distribution-of-cookies-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>bucket;\\n    int ans;\\n    void backtracking(vector<int>& jobs, int k, int jobNumber){\\n        //base case\\n        if(jobNumber==jobs.size())\\n        {\\n            int maxx=INT_MIN;\\n            for(int i=0;i<k;i++)\\n            {\\n                maxx=max(maxx,bucket[i]);\\n            }\\n            ans=min(ans,maxx);\\n            return;\\n        }\\n\\n        unordered_set<int>vis;\\n        for(int j=0;j<k;j++)\\n        {\\n            if(vis.find( bucket[j] ) != vis.end()) continue;\\n            if (bucket[j] + jobs[jobNumber] >= ans) continue;\\n\\t\\t\\tvis.insert( bucket[j] );\\n            bucket[j]+=jobs[jobNumber];\\n            backtracking(jobs, k, jobNumber+1);\\n            bucket[j]-=jobs[jobNumber];\\n        }\\n    }\\n\\n\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        bucket.resize(k,0);\\n        ans=INT_MAX;\\n        backtracking(jobs,k,0);\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>bucket;\\n    int ans;\\n    void backtracking(vector<int>& jobs, int k, int jobNumber){\\n        //base case\\n        if(jobNumber==jobs.size())\\n        {\\n            int maxx=INT_MIN;\\n            for(int i=0;i<k;i++)\\n            {\\n                maxx=max(maxx,bucket[i]);\\n            }\\n            ans=min(ans,maxx);\\n            return;\\n        }\\n\\n        unordered_set<int>vis;\\n        for(int j=0;j<k;j++)\\n        {\\n            if(vis.find( bucket[j] ) != vis.end()) continue;\\n            if (bucket[j] + jobs[jobNumber] >= ans) continue;\\n\\t\\t\\tvis.insert( bucket[j] );\\n            bucket[j]+=jobs[jobNumber];\\n            backtracking(jobs, k, jobNumber+1);\\n            bucket[j]-=jobs[jobNumber];\\n        }\\n    }\\n\\n\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        bucket.resize(k,0);\\n        ans=INT_MAX;\\n        backtracking(jobs,k,0);\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835211,
                "title": "java-backtracking-pruning-with-resonable-explanation",
                "content": "```\\n/**\\nSome tricks to make backtrack faster:\\n1. one trick is to reverse sort all the jobs so that we are more likely to exit earlier.\\n   (from https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1009817/One-branch-cutting-trick-to-solve-three-LeetCode-questions)\\n\\n2. If any worker has more working time than current best result, stop backtracking.\\n   \\n3. If worker i and worker j have the same amount of time, assign a new job to i and to j will make no difference on the final result.\\n   Say, we have k workers, and we are assigning the first job to some worker. At the begining, they all have 0 working time.\\n   So there is no difference to assign the first job to any of the workers.\\n*/\\n\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        // one trick is to reverse sort all the jobs so that we are more likely to exit earlier.\\n        // https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1009817/One-branch-cutting-trick-to-solve-three-LeetCode-questions\\n        sortInDesc(jobs);\\n        \\n        int sum = 0;\\n        for (int job : jobs) {\\n            sum += job;\\n        }\\n        \\n        int[] res = new int[] {sum};\\n        \\n        int[] workerToTime = new int[k];\\n        \\n        backtrack(0, jobs, 0, workerToTime, res, k);\\n        \\n        return res[0];\\n    }\\n    \\n    private void backtrack(int jobId, int[] jobs, int startingWorkerIdx, int[] workerToTime, int[] res, int k) {\\n        int jobCnt = jobs.length;\\n        \\n        // finish all work\\n        if (jobId == jobCnt) {\\n            int maxTime = 0;\\n            for (int time : workerToTime) {\\n                maxTime = Math.max(maxTime, time);\\n            }\\n            res[0] = Math.min(res[0], maxTime);\\n            return;\\n        }\\n        \\n        Set<Integer> seenWorkTime = new HashSet<>();\\n        \\n        // arrange jobs[jobId] to some worker\\n        for (int i = 0; i < k; i++) {\\n            \\n            // int workerIdx = (startingWorkerIdx + i) % k;\\n            int workerIdx = i;\\n            \\n            // some woker already spends more than re[0] time to finish ones work\\n            if (workerToTime[workerIdx] >= res[0]) {\\n                return;\\n            }\\n            \\n            // if previous worker\\'s time is the same as the current worker\\'s, then assign jobs[jobId] to\\n            // current job will lead to the same final result\\n            if (i != 0 && workerToTime[i] == workerToTime[i - 1]) {\\n                continue;\\n            }\\n            \\n            workerToTime[workerIdx] += jobs[jobId];\\n            backtrack(jobId + 1, jobs, startingWorkerIdx + 1, workerToTime, res, k);\\n            workerToTime[workerIdx] -= jobs[jobId];\\n        }\\n    }\\n    \\n    private void sortInDesc(int[] nums) {\\n        int len = nums.length;\\n        \\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < len / 2; i++) {\\n            int temp = nums[i];\\n            nums[i] = nums[len - 1 - i];\\n            nums[len - 1 - i] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n/**\\nSome tricks to make backtrack faster:\\n1. one trick is to reverse sort all the jobs so that we are more likely to exit earlier.\\n   (from https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1009817/One-branch-cutting-trick-to-solve-three-LeetCode-questions)\\n\\n2. If any worker has more working time than current best result, stop backtracking.\\n   \\n3. If worker i and worker j have the same amount of time, assign a new job to i and to j will make no difference on the final result.\\n   Say, we have k workers, and we are assigning the first job to some worker. At the begining, they all have 0 working time.\\n   So there is no difference to assign the first job to any of the workers.\\n*/\\n\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        // one trick is to reverse sort all the jobs so that we are more likely to exit earlier.\\n        // https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1009817/One-branch-cutting-trick-to-solve-three-LeetCode-questions\\n        sortInDesc(jobs);\\n        \\n        int sum = 0;\\n        for (int job : jobs) {\\n            sum += job;\\n        }\\n        \\n        int[] res = new int[] {sum};\\n        \\n        int[] workerToTime = new int[k];\\n        \\n        backtrack(0, jobs, 0, workerToTime, res, k);\\n        \\n        return res[0];\\n    }\\n    \\n    private void backtrack(int jobId, int[] jobs, int startingWorkerIdx, int[] workerToTime, int[] res, int k) {\\n        int jobCnt = jobs.length;\\n        \\n        // finish all work\\n        if (jobId == jobCnt) {\\n            int maxTime = 0;\\n            for (int time : workerToTime) {\\n                maxTime = Math.max(maxTime, time);\\n            }\\n            res[0] = Math.min(res[0], maxTime);\\n            return;\\n        }\\n        \\n        Set<Integer> seenWorkTime = new HashSet<>();\\n        \\n        // arrange jobs[jobId] to some worker\\n        for (int i = 0; i < k; i++) {\\n            \\n            // int workerIdx = (startingWorkerIdx + i) % k;\\n            int workerIdx = i;\\n            \\n            // some woker already spends more than re[0] time to finish ones work\\n            if (workerToTime[workerIdx] >= res[0]) {\\n                return;\\n            }\\n            \\n            // if previous worker\\'s time is the same as the current worker\\'s, then assign jobs[jobId] to\\n            // current job will lead to the same final result\\n            if (i != 0 && workerToTime[i] == workerToTime[i - 1]) {\\n                continue;\\n            }\\n            \\n            workerToTime[workerIdx] += jobs[jobId];\\n            backtrack(jobId + 1, jobs, startingWorkerIdx + 1, workerToTime, res, k);\\n            workerToTime[workerIdx] -= jobs[jobId];\\n        }\\n    }\\n    \\n    private void sortInDesc(int[] nums) {\\n        int len = nums.length;\\n        \\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < len / 2; i++) {\\n            int temp = nums[i];\\n            nums[i] = nums[len - 1 - i];\\n            nums[len - 1 - i] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443887,
                "title": "c-two-solutions-binary-search-backtracking-must-do-question",
                "content": "\\n\\n\\n## Binary Search + Backtracking \\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    bool func(vector<int> &nums , int k , ll val , vector<ll> &dp , int i )\\n    {\\n        if(i>=nums.size())\\n        {\\n            return true;\\n        }\\n        ll curr_val=nums[i];\\n        \\n        for(int j=0;j<k;j++)\\n        {\\n            if(curr_val + dp[j] <= val)\\n            {\\n                dp[j]+=curr_val;\\n                 if( func(nums , k , val , dp , i+1))\\n                   return true;\\n                dp[j]-=curr_val;\\n            }\\n            \\n            if(dp[j]==0)\\n            {\\n                // as the jth worker do not do any task having 0 working time\\n                // so its not possible as each of k workers should do some work\\n                // as per the question , we have to divide into k partition \\n                return false;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    int minimumTimeRequired(vector<int>& nums, int k) {\\n  \\n        ll l=*max_element(nums.begin() , nums.end()) , r=1e9;\\n        \\n        ll ans=-1;\\n        \\n      // Here Mid is the the minimised maximum value for working time .\\n        \\n        while(l<=r)\\n        {\\n            ll mid=(l + (r-l)/2);\\n            \\n             vector<ll> dp(k , 0);\\n            \\n            if(func(nums , k , mid , dp , 0))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```\\n\\n##  Piles of size K forming using Backtracking \\n\\n```\\n    ll ans=INT_MAX;\\n    \\n    void func(vector<int> &nums , int k , int i , vector<int> &dp)\\n    {\\n        \\n        if(i>=nums.size())\\n        {\\n            ll v=*max_element(dp.begin() , dp.end());\\n            \\n            ans=min(ans , v);\\n            \\n            return ;\\n        }\\n          \\n        ll val=*max_element(dp.begin() , dp.end());\\n        \\n        if(val>=ans)\\n        {\\n            return ;\\n        }\\n        \\n        for(int j=0;j<k;j++)\\n        {\\n            \\n            if(j>0 && dp[j]>=dp[j-1])\\n            {\\n                // Not adding more working to it , as it is already bigger than previous \\n                \\n                // it is not optimal , so we do to next workers , & if not available\\n                \\n                // return to previous recursive call \\n                \\n                continue;\\n            }\\n            \\n            dp[j]+=nums[i];\\n            func(nums , k , i+1 , dp);\\n            dp[j]-=nums[i];\\n        }\\n    }\\n    \\n    \\n     int minimumTimeRequired(vector<int>& nums, int k) {\\n         \\n         // This is a backtracking based solution where , we are \\n         \\n         // dividing the values into k piles \\n         \\n         // & then find out the minimised max sum value of working time \\n         \\n            \\n         vector<int> dp(k , 0);\\n         \\n         sort(nums.begin() , nums.end() , greater<int>());\\n         \\n         func(nums , k , 0 , dp);\\n         \\n         return ans;\\n         \\n         \\n     }\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    bool func(vector<int> &nums , int k , ll val , vector<ll> &dp , int i )\\n    {\\n        if(i>=nums.size())\\n        {\\n            return true;\\n        }\\n        ll curr_val=nums[i];\\n        \\n        for(int j=0;j<k;j++)\\n        {\\n            if(curr_val + dp[j] <= val)\\n            {\\n                dp[j]+=curr_val;\\n                 if( func(nums , k , val , dp , i+1))\\n                   return true;\\n                dp[j]-=curr_val;\\n            }\\n            \\n            if(dp[j]==0)\\n            {\\n                // as the jth worker do not do any task having 0 working time\\n                // so its not possible as each of k workers should do some work\\n                // as per the question , we have to divide into k partition \\n                return false;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    int minimumTimeRequired(vector<int>& nums, int k) {\\n  \\n        ll l=*max_element(nums.begin() , nums.end()) , r=1e9;\\n        \\n        ll ans=-1;\\n        \\n      // Here Mid is the the minimised maximum value for working time .\\n        \\n        while(l<=r)\\n        {\\n            ll mid=(l + (r-l)/2);\\n            \\n             vector<ll> dp(k , 0);\\n            \\n            if(func(nums , k , mid , dp , 0))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```\n```\\n    ll ans=INT_MAX;\\n    \\n    void func(vector<int> &nums , int k , int i , vector<int> &dp)\\n    {\\n        \\n        if(i>=nums.size())\\n        {\\n            ll v=*max_element(dp.begin() , dp.end());\\n            \\n            ans=min(ans , v);\\n            \\n            return ;\\n        }\\n          \\n        ll val=*max_element(dp.begin() , dp.end());\\n        \\n        if(val>=ans)\\n        {\\n            return ;\\n        }\\n        \\n        for(int j=0;j<k;j++)\\n        {\\n            \\n            if(j>0 && dp[j]>=dp[j-1])\\n            {\\n                // Not adding more working to it , as it is already bigger than previous \\n                \\n                // it is not optimal , so we do to next workers , & if not available\\n                \\n                // return to previous recursive call \\n                \\n                continue;\\n            }\\n            \\n            dp[j]+=nums[i];\\n            func(nums , k , i+1 , dp);\\n            dp[j]-=nums[i];\\n        }\\n    }\\n    \\n    \\n     int minimumTimeRequired(vector<int>& nums, int k) {\\n         \\n         // This is a backtracking based solution where , we are \\n         \\n         // dividing the values into k piles \\n         \\n         // & then find out the minimised max sum value of working time \\n         \\n            \\n         vector<int> dp(k , 0);\\n         \\n         sort(nums.begin() , nums.end() , greater<int>());\\n         \\n         func(nums , k , 0 , dp);\\n         \\n         return ans;\\n         \\n         \\n     }\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319662,
                "title": "three-approaches-only-1-doesn-t-give-tle",
                "content": "1st approach: Try assigning jobs to each worker and backtrack. Optimise by assigning free worker job only once which saves computation on permutation of same subset since alll workers are identical\\n\\n2nd approach[TLE]: Try making subset of jobs one by one such that each subset total time is not greater than maxtime\\n\\n3rd approach[TLE]: Apply DP where state is number of workers i.e. the subset of jobs that we can make such that each subset total time is not greater than maxtime and binary mask to keep track of used jobs. Final ans will be dp[K][(1<<n)-1] which indicates whether its possible to have K subset using all the jobs such that each of subset total time <= maxtime\\n\\n```\\nclass Solution {\\npublic:\\n    int n, fmask;\\n    vector<int>subsetTime;\\n    bool check(int index, vector<int>& jobs, vector<int>& time, int k, int maxtime){\\n        if(index == jobs.size())\\n            return true;\\n        \\n        for(int i=0; i<k; i++){\\n            if(jobs[index] + time[i] > maxtime)\\n                continue;\\n            time[i] += jobs[index];\\n            if(check(index+1, jobs, time, k, maxtime))\\n                return true;\\n            time[i] -= jobs[index];\\n            if(time[i]==0)\\n                break;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool checksubset(int index, int mask, int time, int cnt, int maxtime, int k, vector<int>& jobs){\\n        if(cnt>k)\\n            return false;\\n        if(mask == fmask)\\n            return true;\\n        \\n        for(int i=index; i<jobs.size(); i++){\\n            if(time + jobs[i]>maxtime){\\n                if(checksubset(0, mask|(1<<i), jobs[i], cnt+1, maxtime, k, jobs))\\n                    return true;\\n            }\\n            else{\\n                if(checksubset(index+1, mask|(1<<i), time + jobs[i], cnt, maxtime, k , jobs))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    void computeSubsetTime(vector<int>& jobs){\\n        for(int mask = 1; mask<=fmask; mask++){\\n            for(int i=0; i<n; i++){\\n                if(mask&(1<<i))\\n                    subsetTime[mask] += jobs[i];\\n            }\\n        }\\n    }\\n    \\n    bool checkdp(vector<int>& jobs, int K, int maxtime){\\n        \\n        vector<vector<bool>>dp(K+1, vector<bool>(fmask+1, false));\\n        \\n        dp[0][0] = true;\\n        for(int i=1; i<= K; i++){\\n            for(int mask = 1; mask<=fmask; mask++){\\n                if(subsetTime[mask]<=maxtime)\\n                    dp[i][mask] = dp[i-1][0];\\n                for(int submask = mask; submask > 0; submask = (submask-1)&mask){\\n                    int rem = mask - submask;\\n                    if(subsetTime[rem]<=maxtime){\\n                        dp[i][mask] = dp[i][mask] | dp[i-1][submask];\\n                    }\\n                    if(dp[i][mask])\\n                        break;\\n                }\\n            }\\n        }\\n        return dp[K][fmask];\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(begin(jobs), end(jobs), greater<int>());\\n        \\n        n = jobs.size();\\n        fmask = (1<<n) -1;\\n        \\n        int total = accumulate(begin(jobs), end(jobs), 0);\\n        int mintime = *max_element(begin(jobs), end(jobs));\\n        \\n        int l = mintime, r= total, ans=-1;\\n        vector<int>time(k,0);\\n        subsetTime.assign(fmask+1, 0);\\n        \\n        computeSubsetTime(jobs);\\n            \\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            \\n            if(checkdp(jobs, k, mid)){\\n                ans = mid;\\n                r = mid-1;\\n                //fill(begin(time), end(time), 0);\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Binary Tree",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, fmask;\\n    vector<int>subsetTime;\\n    bool check(int index, vector<int>& jobs, vector<int>& time, int k, int maxtime){\\n        if(index == jobs.size())\\n            return true;\\n        \\n        for(int i=0; i<k; i++){\\n            if(jobs[index] + time[i] > maxtime)\\n                continue;\\n            time[i] += jobs[index];\\n            if(check(index+1, jobs, time, k, maxtime))\\n                return true;\\n            time[i] -= jobs[index];\\n            if(time[i]==0)\\n                break;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool checksubset(int index, int mask, int time, int cnt, int maxtime, int k, vector<int>& jobs){\\n        if(cnt>k)\\n            return false;\\n        if(mask == fmask)\\n            return true;\\n        \\n        for(int i=index; i<jobs.size(); i++){\\n            if(time + jobs[i]>maxtime){\\n                if(checksubset(0, mask|(1<<i), jobs[i], cnt+1, maxtime, k, jobs))\\n                    return true;\\n            }\\n            else{\\n                if(checksubset(index+1, mask|(1<<i), time + jobs[i], cnt, maxtime, k , jobs))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    void computeSubsetTime(vector<int>& jobs){\\n        for(int mask = 1; mask<=fmask; mask++){\\n            for(int i=0; i<n; i++){\\n                if(mask&(1<<i))\\n                    subsetTime[mask] += jobs[i];\\n            }\\n        }\\n    }\\n    \\n    bool checkdp(vector<int>& jobs, int K, int maxtime){\\n        \\n        vector<vector<bool>>dp(K+1, vector<bool>(fmask+1, false));\\n        \\n        dp[0][0] = true;\\n        for(int i=1; i<= K; i++){\\n            for(int mask = 1; mask<=fmask; mask++){\\n                if(subsetTime[mask]<=maxtime)\\n                    dp[i][mask] = dp[i-1][0];\\n                for(int submask = mask; submask > 0; submask = (submask-1)&mask){\\n                    int rem = mask - submask;\\n                    if(subsetTime[rem]<=maxtime){\\n                        dp[i][mask] = dp[i][mask] | dp[i-1][submask];\\n                    }\\n                    if(dp[i][mask])\\n                        break;\\n                }\\n            }\\n        }\\n        return dp[K][fmask];\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(begin(jobs), end(jobs), greater<int>());\\n        \\n        n = jobs.size();\\n        fmask = (1<<n) -1;\\n        \\n        int total = accumulate(begin(jobs), end(jobs), 0);\\n        int mintime = *max_element(begin(jobs), end(jobs));\\n        \\n        int l = mintime, r= total, ans=-1;\\n        vector<int>time(k,0);\\n        subsetTime.assign(fmask+1, 0);\\n        \\n        computeSubsetTime(jobs);\\n            \\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            \\n            if(checkdp(jobs, k, mid)){\\n                ans = mid;\\n                r = mid-1;\\n                //fill(begin(time), end(time), 0);\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266554,
                "title": "java-bottom-up-1d-dp-with-comments",
                "content": "I don\\'t see any bottom-up DP here. I am providing one.\\n\\n#### It is slow! (AC at 750ms)\\nYes, I know. Bottom-up DP will search all paths, hence slower, but it is nice to code it out at least.\\n\\n#### Let m = jobs.length\\n#### Time Complexity O(3^m * k)\\n#### Space Complexity O(3^m)\\n```Java\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int N = 1 << jobs.length, INF = (int)2e9;\\n        int[] dp = new int[N];\\n        Arrays.fill(dp, INF);\\n        dp[N-1]=0;\\n        for (int i = 0; i < k; i++){ // for each worker, we do ...\\n            int[] next = new int[N];\\n            Arrays.fill(next, INF);\\n            for (int j = 0; j < N; j++){ // for all possible jobs config\\n                for (int m = j; m > 0 && dp[j]!=INF; m = (m-1)&j){ // if it is valid, then loop through its submask\\n                    if (Integer.bitCount(j)-Integer.bitCount(m)<k-i-1){ // optimization \\n                        continue;\\n                    }\\n                    int sum = 0;\\n                    for (int s = 0; s < jobs.length; s++){ // add all the jobs \\n                        if ((m&1<<s)>0){\\n                            sum += jobs[s];\\n                        }\\n                    }\\n                    int res = Math.max(sum, dp[j]); // choose the max \\n                    next[j^m]=Math.min(res, next[j^m]); // choose the min\\n                }\\n            }\\n            dp=next;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int N = 1 << jobs.length, INF = (int)2e9;\\n        int[] dp = new int[N];\\n        Arrays.fill(dp, INF);\\n        dp[N-1]=0;\\n        for (int i = 0; i < k; i++){ // for each worker, we do ...\\n            int[] next = new int[N];\\n            Arrays.fill(next, INF);\\n            for (int j = 0; j < N; j++){ // for all possible jobs config\\n                for (int m = j; m > 0 && dp[j]!=INF; m = (m-1)&j){ // if it is valid, then loop through its submask\\n                    if (Integer.bitCount(j)-Integer.bitCount(m)<k-i-1){ // optimization \\n                        continue;\\n                    }\\n                    int sum = 0;\\n                    for (int s = 0; s < jobs.length; s++){ // add all the jobs \\n                        if ((m&1<<s)>0){\\n                            sum += jobs[s];\\n                        }\\n                    }\\n                    int res = Math.max(sum, dp[j]); // choose the max \\n                    next[j^m]=Math.min(res, next[j^m]); // choose the min\\n                }\\n            }\\n            dp=next;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142655,
                "title": "java-binary-search-and-backtracking-with-easy-explanation",
                "content": "The code below explains it clearly with comments written alongside them\\n```\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        // Applying binary search on maximum working time\\n        \\n        // Lowest working time is maximum amount of time for each job\\n        int low = getMax(jobs); \\n                                                       \\n        // Highest working time is sum of all time for all jobs\\n        int high = getSum(jobs);\\n        \\n        int ans = low;\\n        while (low<=high) {\\n            int mid = low + (high-low)/2;\\n            \\n            if (isPossible(jobs,new int[k],0,mid)) {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private int getMax(int[] nums) {\\n        int max = nums[0];\\n        for (int i=1,size=nums.length;i<size;i++) {\\n            max = Math.max(max,nums[i]);\\n        }\\n        return max;\\n    }\\n    \\n    private int getSum(int[] nums) {\\n        int sum=0;\\n        for (int i=0,size=nums.length;i<size;i++) {\\n            sum += nums[i];\\n        }\\n        return sum;\\n    }\\n    \\n    // Returns true if it is possible to allot the given jobs to all the k workers\\n    // if the maximum working time of each worker is given\\n    // The alloted array represents the amount of time of job alloted to each worker\\n    // i.e alloted[i] represents amount of time of job alloted to ith worker\\n    private boolean isPossible(int[] jobs,int[] alloted,int index,int maxTime) {\\n        int availableWorkers = alloted.length;\\n        \\n        if (index==jobs.length)\\n            return true;\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for (int i=0;i<availableWorkers;i++) {\\n            // Do not permute the same alloted time on every worker\\n            // If checked once, leave the others\\n            if ( !set.contains(alloted[i]) ) {\\n                set.add(alloted[i]);\\n                \\n                if (alloted[i]+jobs[index] <= maxTime) {\\n                    alloted[i] += jobs[index];\\n                    if (isPossible(jobs,alloted,index+1,maxTime))\\n                        return true;\\n                    alloted[i] -= jobs[index];\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        // Applying binary search on maximum working time\\n        \\n        // Lowest working time is maximum amount of time for each job\\n        int low = getMax(jobs); \\n                                                       \\n        // Highest working time is sum of all time for all jobs\\n        int high = getSum(jobs);\\n        \\n        int ans = low;\\n        while (low<=high) {\\n            int mid = low + (high-low)/2;\\n            \\n            if (isPossible(jobs,new int[k],0,mid)) {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private int getMax(int[] nums) {\\n        int max = nums[0];\\n        for (int i=1,size=nums.length;i<size;i++) {\\n            max = Math.max(max,nums[i]);\\n        }\\n        return max;\\n    }\\n    \\n    private int getSum(int[] nums) {\\n        int sum=0;\\n        for (int i=0,size=nums.length;i<size;i++) {\\n            sum += nums[i];\\n        }\\n        return sum;\\n    }\\n    \\n    // Returns true if it is possible to allot the given jobs to all the k workers\\n    // if the maximum working time of each worker is given\\n    // The alloted array represents the amount of time of job alloted to each worker\\n    // i.e alloted[i] represents amount of time of job alloted to ith worker\\n    private boolean isPossible(int[] jobs,int[] alloted,int index,int maxTime) {\\n        int availableWorkers = alloted.length;\\n        \\n        if (index==jobs.length)\\n            return true;\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for (int i=0;i<availableWorkers;i++) {\\n            // Do not permute the same alloted time on every worker\\n            // If checked once, leave the others\\n            if ( !set.contains(alloted[i]) ) {\\n                set.add(alloted[i]);\\n                \\n                if (alloted[i]+jobs[index] <= maxTime) {\\n                    alloted[i] += jobs[index];\\n                    if (isPossible(jobs,alloted,index+1,maxTime))\\n                        return true;\\n                    alloted[i] -= jobs[index];\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905387,
                "title": "c-multi-knapsack",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int find(int n){\\n        int re = 0;\\n        while(n){ n = n&(n-1); re++;}\\n        return re;\\n    }\\n    int dfs(vector<int>& nums,vector<vector<int>> &dp,int n,int k){\\n        if(dp[n][k]!=-1) return dp[n][k];\\n        int l = find(n), re = INT_MAX;\\n        if(k==1){\\n           re = 0;\\n           for(int j = 13; j>=0;j--){\\n             if(n&(1<<j)) re+=nums[j];\\n           }\\n            return dp[n][k] = re;\\n        }\\n        for(int i = n; i>0; i = n&(i-1)){  \\n            if(l-find(i)>=k-1){\\n                int sum = 0;\\n                for(int j = 13; j>=0;j--){\\n                    if(i&(1<<j)) sum+=nums[j];\\n                }\\n                sum = max(sum,dfs(nums,dp,n^i,k-1));\\n                re = min(re,sum);\\n            }\\n        }\\n        return dp[n][k] = re;\\n    }\\n    int minimumTimeRequired(vector<int>& nums, int k) {\\n        n = nums.size();\\n        n = (1<<n)-1;\\n        vector<vector<int>> dp(n+2,vector<int>(k+1,-1));\\n        return dfs(nums,dp,n,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int find(int n){\\n        int re = 0;\\n        while(n){ n = n&(n-1); re++;}\\n        return re;\\n    }\\n    int dfs(vector<int>& nums,vector<vector<int>> &dp,int n,int k){\\n        if(dp[n][k]!=-1) return dp[n][k];\\n        int l = find(n), re = INT_MAX;\\n        if(k==1){\\n           re = 0;\\n           for(int j = 13; j>=0;j--){\\n             if(n&(1<<j)) re+=nums[j];\\n           }\\n            return dp[n][k] = re;\\n        }\\n        for(int i = n; i>0; i = n&(i-1)){  \\n            if(l-find(i)>=k-1){\\n                int sum = 0;\\n                for(int j = 13; j>=0;j--){\\n                    if(i&(1<<j)) sum+=nums[j];\\n                }\\n                sum = max(sum,dfs(nums,dp,n^i,k-1));\\n                re = min(re,sum);\\n            }\\n        }\\n        return dp[n][k] = re;\\n    }\\n    int minimumTimeRequired(vector<int>& nums, int k) {\\n        n = nums.size();\\n        n = (1<<n)-1;\\n        vector<vector<int>> dp(n+2,vector<int>(k+1,-1));\\n        return dfs(nums,dp,n,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898647,
                "title": "c-solution-using-dp-and-bit-masking",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size(), m = 1 << n;\\n        int dp[k + 1][m + 1];\\n        for (int i = 0; i <= k; i++) {\\n            for (int j = 0; j < m; j++) dp[i][j] = INT_MAX;\\n        }\\n        dp[0][0] = 0;\\n        for (int i = 0; i < (1 << n); i++) {\\n            int mask = 1, c = 0;\\n            dp[1][i] = 0;\\n            while(mask < m) {\\n                if (mask & i) {\\n                    dp[1][i] += jobs[c];\\n                }\\n                c++;\\n                mask = mask << 1;\\n            }\\n        }\\n        for (int i = 2; i <= k; i++) {\\n            for (int j = 0; j < m; j++) {\\n                for (int mask = j; mask; mask = (mask - 1) & j) {\\n                    if ((mask & j) == mask) {\\n                        int x = j - mask;\\n                        int z = max(dp[i - 1][x], dp[1][mask]);\\n                        dp[i][j] = min(z, dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[k][m - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size(), m = 1 << n;\\n        int dp[k + 1][m + 1];\\n        for (int i = 0; i <= k; i++) {\\n            for (int j = 0; j < m; j++) dp[i][j] = INT_MAX;\\n        }\\n        dp[0][0] = 0;\\n        for (int i = 0; i < (1 << n); i++) {\\n            int mask = 1, c = 0;\\n            dp[1][i] = 0;\\n            while(mask < m) {\\n                if (mask & i) {\\n                    dp[1][i] += jobs[c];\\n                }\\n                c++;\\n                mask = mask << 1;\\n            }\\n        }\\n        for (int i = 2; i <= k; i++) {\\n            for (int j = 0; j < m; j++) {\\n                for (int mask = j; mask; mask = (mask - 1) & j) {\\n                    if ((mask & j) == mask) {\\n                        int x = j - mask;\\n                        int z = max(dp[i - 1][x], dp[1][mask]);\\n                        dp[i][j] = min(z, dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[k][m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871569,
                "title": "python-backtrack-with-early-pruning-beats-95-65",
                "content": "Based on @lee215 \\'s solution, optimizaition 4 & 5 is added:\\nOptimization 4:\\nJob havind same completing time with previous job only assigned after it.\\nOptimization 5:\\nIf we sort jobs first, then max(jobs[0], sum(jobs[-(n-k+1):])) is the upper bound of result, which means assigning smallest (n - k + 1) jobs to one worker, and other k - 1 jobs to k - 1 workers.\\nWith those addinational 2 optimizations, runtime reduces from 45ms to 24ms\\n```\\nclass Solution(object):\\n    def minimumTimeRequired(self, jobs, k):\\n        \"\"\"\\n        :type jobs: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        def backtrack(cur, i, pre):\\n            if cur >= self.mn:  # opt.3\\n                return\\n            if i == n:\\n                self.mn = cur\\n                return\\n            for j in range(0 if i == 0 or jobs[i] != jobs[i - 1] else pre, k):  # Opt.4\\n                arr[j] += jobs[i]\\n                backtrack(max(cur, arr[j]), i + 1, j)\\n                arr[j] -= jobs[i]\\n                if arr[j] == 0:  # Opt.2\\n                    break\\n\\n        jobs.sort(reverse=True)  # Opt.1\\n        arr = [0] * k\\n        n = len(jobs)\\n        self.mn = max(sum(jobs[-(n-k+1):]), jobs[0])  # Opt.5\\n        backtrack(0, 0, -1)\\n        return self.mn\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minimumTimeRequired(self, jobs, k):\\n        \"\"\"\\n        :type jobs: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        def backtrack(cur, i, pre):\\n            if cur >= self.mn:  # opt.3\\n                return\\n            if i == n:\\n                self.mn = cur\\n                return\\n            for j in range(0 if i == 0 or jobs[i] != jobs[i - 1] else pre, k):  # Opt.4\\n                arr[j] += jobs[i]\\n                backtrack(max(cur, arr[j]), i + 1, j)\\n                arr[j] -= jobs[i]\\n                if arr[j] == 0:  # Opt.2\\n                    break\\n\\n        jobs.sort(reverse=True)  # Opt.1\\n        arr = [0] * k\\n        n = len(jobs)\\n        self.mn = max(sum(jobs[-(n-k+1):]), jobs[0])  # Opt.5\\n        backtrack(0, 0, -1)\\n        return self.mn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715384,
                "title": "binary-search-recursion-fully-explained-with-intuition-c",
                "content": "Hey all!\\nThe first thought that comes to the mind on seeing this question is obviously binary search, which comes by seeing the statement **minimum possible maximum working time**. Now we need to device the way to do the binary search.\\nFor starters we need to decide the search space, i.e. high and low.\\nThe lowest possible maximum working time of a single worker can be the max of all given times in jobs.\\nThe highest possible maximum working time of a single worker can be (max of all given times in jobs) * (size of jobs)\\n\\nNote : the high isn\\'t theorytically possible to reach (except when all of the job timings are same) but we can define a clear search space using it, binary search is smart enough to figure that out.\\n\\nNow we need to create a condition such that it will help the binary search decide whether a particular mid can be the answer or not.\\nWe take a vector of size k (denoting k workers), each with max allocated working time as mid.\\nUsing recursion we try alloting each job to each worker and removing that much time from that worker, and try allocating the next job and so on.\\nIf all jobs allocated return true, else we backtrack and try out the next job and so on.....\\n\\nNow when we find a mid that completely allocates all jobs to the workers than this is a viable answer and we continue our search in a smaller half to find if a smaller mid that can completely allocate all the jobs, if a particular mid isn\\'t able to allocate than we search in the bigger half, this is how we find the **minimum** possible **maximum working time**.\\n\\nTo optimize our searching process we sort the given jobs vector in descending order, so that the largest time taking job is assigned first and then we continue if remaining time is big enough to fit the next job or we return false.\\n\\n```\\nclass Solution {\\nprivate:\\n    // recursion to try out all possible arrangements\\n    bool isPossible(vector<int>& jobs, vector<int> &times, int ind, int mid, int k, int n){\\n        if(ind==n) return true;\\n        for(int i=0;i<k;i++){\\n\\t\\t\\t// if current job time is less than time available of current worker\\n            if(jobs[ind]<=times[i]){\\n\\t\\t\\t\\t// remove the used up time in this job from the current worker\\n                times[i] -= jobs[ind];\\n\\t\\t\\t\\t// check for the remaining jobs with the remaining work hours of all workers\\n                if(isPossible(jobs,times,ind+1,mid,k,n)) return true;\\n\\t\\t\\t\\t// backtrack\\n                times[i] += jobs[ind];\\n            }\\n            // if the current time isn\\'t used in any of the jobs \\n            // all the way down to the last job available then\\n            // what\\'s the purpose of trying out the next jobs?\\n            if(times[i]==mid) return false;\\n        }\\n        return false;\\n    }\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size();\\n        sort(jobs.begin(),jobs.end(),greater());\\n        int low = jobs[0], high = n*jobs[0], ans = -1;\\n        \\n        // binary search\\n        while(low<=high){\\n            int mid = (low+high)>>1;\\n            vector<int> allotedTime(k,mid);\\n            bool ans = isPossible(jobs,allotedTime,0,mid,k,n);\\n            if(ans){\\n\\t\\t\\t\\t// viable answer\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```\\nTime complexity : nlogn+(k^n)*logn ~ O((k^n)*logn)\\nSpace complexity : O(n) (recursive stack space)",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // recursion to try out all possible arrangements\\n    bool isPossible(vector<int>& jobs, vector<int> &times, int ind, int mid, int k, int n){\\n        if(ind==n) return true;\\n        for(int i=0;i<k;i++){\\n\\t\\t\\t// if current job time is less than time available of current worker\\n            if(jobs[ind]<=times[i]){\\n\\t\\t\\t\\t// remove the used up time in this job from the current worker\\n                times[i] -= jobs[ind];\\n\\t\\t\\t\\t// check for the remaining jobs with the remaining work hours of all workers\\n                if(isPossible(jobs,times,ind+1,mid,k,n)) return true;\\n\\t\\t\\t\\t// backtrack\\n                times[i] += jobs[ind];\\n            }\\n            // if the current time isn\\'t used in any of the jobs \\n            // all the way down to the last job available then\\n            // what\\'s the purpose of trying out the next jobs?\\n            if(times[i]==mid) return false;\\n        }\\n        return false;\\n    }\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size();\\n        sort(jobs.begin(),jobs.end(),greater());\\n        int low = jobs[0], high = n*jobs[0], ans = -1;\\n        \\n        // binary search\\n        while(low<=high){\\n            int mid = (low+high)>>1;\\n            vector<int> allotedTime(k,mid);\\n            bool ans = isPossible(jobs,allotedTime,0,mid,k,n);\\n            if(ans){\\n\\t\\t\\t\\t// viable answer\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369973,
                "title": "dp-bitmask-solutions-top-down-and-bottom-up",
                "content": "```\\n# each worker gets a subset of tasks\\n# remaining subproblem = bitmask of remaining tasks, k-1\\n# enumerate all subsets for each worker ;)\\n# make sure no intersection with already selected\\n\\n\\nclass Solution:\\n    def minimumTimeRequiredTLE(self, jobs: List[int], k: int) -> int:\\n        # each worker gets a subset of tasks\\n        # remaining subproblem = bitmask of remaining tasks, k-1\\n        # enumerate all subsets for each worker ;)\\n        # make sure no intersection with already selected\\n        n = len(jobs)\\n\\n        subset_sums = [0] * (1<<(n+1))\\n        for subset_mask in range(1<<(n+1)):\\n            for job in range(n):\\n                if subset_mask >> job & 1:\\n                    subset_sums[subset_mask] += jobs[job]\\n        \\n        @functools.cache\\n        def dp(picked, k):\\n            n = len(jobs)\\n            # return 0 if No job remaining AND No person remaining\\n            if k == 0 and picked+1 == 1<<(n+1): \\n                return 0 \\n            elif k == 0 or picked+1 == 1<<(n+1): \\n                return math.inf\\n            \\n            res = math.inf\\n            for pick in range(1<<(n+1)):\\n                if pick & picked == 0: # no intersection(picked again)\\n                    # now assign remaining workers\\n                    res = min(res, max(subset_sums[pick], dp(picked | pick, k-1)))\\n            \\n            return res\\n        \\n        return dp(0,k)\\n    \\n    \\n    # other method from https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1009785/C%2B%2B-DP-with-explanation\\n\\t# submasks optimization\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        n = len(jobs)\\n\\n        subset_sums = [0] * (1<<(n))\\n        for subset_mask in range(1<<(n)):\\n            for job in range(n):\\n                if subset_mask >> job & 1:\\n                    subset_sums[subset_mask] += jobs[job]\\n        \\n        # lets go bottom up\\n        dp = [[0]*(k+1) for _ in range(1<<n)]\\n        \\n        # base case\\n        for pick in range(1<<n): dp[pick][1] = subset_sums[pick]\\n            \\n        # recurance relation k depends on k-1 so k++\\n        for kk in range(2,k+1):\\n            for available in range(1, 1<<n):\\n                dp[available][kk] = dp[available][kk-1] # worker picks nothing...\\n                pick = available\\n                while pick > 0:\\n                    dp[available][kk] = min(dp[available][kk], max(subset_sums[pick],dp[available^pick][kk-1]))\\n                    pick = (pick-1) & available\\n\\n        return dp[(1<<n)-1][k]\\n\"\"\"\\n\\n[46,13,54,51,38,49,54,67,26,78,33]\\n10\\n\"\"\"\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\n# each worker gets a subset of tasks\\n# remaining subproblem = bitmask of remaining tasks, k-1\\n# enumerate all subsets for each worker ;)\\n# make sure no intersection with already selected\\n\\n\\nclass Solution:\\n    def minimumTimeRequiredTLE(self, jobs: List[int], k: int) -> int:\\n        # each worker gets a subset of tasks\\n        # remaining subproblem = bitmask of remaining tasks, k-1\\n        # enumerate all subsets for each worker ;)\\n        # make sure no intersection with already selected\\n        n = len(jobs)\\n\\n        subset_sums = [0] * (1<<(n+1))\\n        for subset_mask in range(1<<(n+1)):\\n            for job in range(n):\\n                if subset_mask >> job & 1:\\n                    subset_sums[subset_mask] += jobs[job]\\n        \\n        @functools.cache\\n        def dp(picked, k):\\n            n = len(jobs)\\n            # return 0 if No job remaining AND No person remaining\\n            if k == 0 and picked+1 == 1<<(n+1): \\n                return 0 \\n            elif k == 0 or picked+1 == 1<<(n+1): \\n                return math.inf\\n            \\n            res = math.inf\\n            for pick in range(1<<(n+1)):\\n                if pick & picked == 0: # no intersection(picked again)\\n                    # now assign remaining workers\\n                    res = min(res, max(subset_sums[pick], dp(picked | pick, k-1)))\\n            \\n            return res\\n        \\n        return dp(0,k)\\n    \\n    \\n    # other method from https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1009785/C%2B%2B-DP-with-explanation\\n\\t# submasks optimization\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        n = len(jobs)\\n\\n        subset_sums = [0] * (1<<(n))\\n        for subset_mask in range(1<<(n)):\\n            for job in range(n):\\n                if subset_mask >> job & 1:\\n                    subset_sums[subset_mask] += jobs[job]\\n        \\n        # lets go bottom up\\n        dp = [[0]*(k+1) for _ in range(1<<n)]\\n        \\n        # base case\\n        for pick in range(1<<n): dp[pick][1] = subset_sums[pick]\\n            \\n        # recurance relation k depends on k-1 so k++\\n        for kk in range(2,k+1):\\n            for available in range(1, 1<<n):\\n                dp[available][kk] = dp[available][kk-1] # worker picks nothing...\\n                pick = available\\n                while pick > 0:\\n                    dp[available][kk] = min(dp[available][kk], max(subset_sums[pick],dp[available^pick][kk-1]))\\n                    pick = (pick-1) & available\\n\\n        return dp[(1<<n)-1][k]\\n\"\"\"\\n\\n[46,13,54,51,38,49,54,67,26,78,33]\\n10\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159975,
                "title": "dp-with-bitmask-subset-decomposition-o-3-n-k-c",
                "content": "``dp[mask][i]``  represents the minimum maximum value we can get with all the jobs set in mask will be completed by i people\\n\\nNow to get the transitions what we can do is \\n for gettting dp[mask][i] we will iterate over all the subsets of mask and try to assign that subset to current worker that is ith worker and the remaining jobs between all the i-1 workers \\n So the transitions will be\\n \\n ``dp[mask][i]=min(dp[mask][i],max(result[submask],dp[mask^submask][i-1]))`` ove all subsets of mask\\n \\n here   submask jobs will be given to current worker and the remaining which is mask^submask will be assigned in an optimmal  manner  between  i-1 workers \\n\\n```\\n\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n=jobs.size();\\n        vector<vector<int>> dp((1<<n),vector<int>(k,0));\\n        vector<int> result((1<<n),0);\\n         for(int i = 0;i<(1<<n);i++)    \\n        {\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(((1<<j)&i))\\n                {\\n                    result[i] += jobs[j];\\n                }\\n            }\\n        }\\n        for (int i = 0; i < (1<<n); ++i) {\\n            dp[i][0] = result[i];\\n        }\\n        \\n        for(int i=1;i<k;++i){\\n            for(int mask=0;mask<(1<<n);++mask){\\n                dp[mask][i]=dp[mask][i-1];\\n                for(int submask=mask;submask;submask=(submask-1)&mask){\\n                    dp[mask][i]=min(dp[mask][i],max(result[submask],dp[mask^submask][i-1]));\\n                }\\n                //cout<<dp[mask][i]<<\"   \";\\n                    \\n            }\\n           // cout<<endl;\\n        }\\n        \\n        return dp[(1<<n)-1][k-1];\\n        \\n    }\\n};\\n```\\nThis is called submask decomposition when ever the question  wants to group things  optimally we can try this\\n\\nother problem of same type\\nhttps://leetcode.com/problems/distribute-repeating-integers/",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n=jobs.size();\\n        vector<vector<int>> dp((1<<n),vector<int>(k,0));\\n        vector<int> result((1<<n),0);\\n         for(int i = 0;i<(1<<n);i++)    \\n        {\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(((1<<j)&i))\\n                {\\n                    result[i] += jobs[j];\\n                }\\n            }\\n        }\\n        for (int i = 0; i < (1<<n); ++i) {\\n            dp[i][0] = result[i];\\n        }\\n        \\n        for(int i=1;i<k;++i){\\n            for(int mask=0;mask<(1<<n);++mask){\\n                dp[mask][i]=dp[mask][i-1];\\n                for(int submask=mask;submask;submask=(submask-1)&mask){\\n                    dp[mask][i]=min(dp[mask][i],max(result[submask],dp[mask^submask][i-1]));\\n                }\\n                //cout<<dp[mask][i]<<\"   \";\\n                    \\n            }\\n           // cout<<endl;\\n        }\\n        \\n        return dp[(1<<n)-1][k-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1023855,
                "title": "java-solution-that-beats-95-runtime",
                "content": "```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        //sort the jobs so that the worker with the maximum workload will be taken first\\n\\t\\t// this will help to terminate early\\n        //Arrays.sort(jobs); // sorting is an optimization to consider\\n        // recurse from the worker who is having maximum work load\\n        recurse(jobs, jobs.length - 1, new int[k]);\\n        // return the minimum working time\\n        return min;\\n    }\\n    \\n    protected void recurse(int[] jobs, int index, int[] sum){\\n        \\n        // get the maximum total from the sum\\n        int max = getMax(sum);\\n        // if the sum of work time exceeds then return\\n        if (max >= min)\\n            return;\\n        \\n        // if the index is going negative, update the minimum maximum from the sum\\n        if (index < 0){\\n            min = Math.min(min,max);\\n            return;\\n        }\\n        \\n        for (int i=0;i<sum.length;i++){\\n            //if the sum is equal then continue and do not recurse\\n            // recurse only for distinct sum\\n            if (i > 0 && sum[i] == sum[i-1])\\n                continue;\\n            // choose\\n            sum[i] += jobs[index];\\n            // explore further\\n            recurse(jobs, index - 1, sum);\\n            //unchoose\\n            sum[i] -= jobs[index];\\n        }   \\n    }\\n    \\n    protected int getMax(int[] sum){\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<sum.length;i++)\\n            max = Math.max(max, sum[i]);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        //sort the jobs so that the worker with the maximum workload will be taken first\\n\\t\\t// this will help to terminate early\\n        //Arrays.sort(jobs); // sorting is an optimization to consider\\n        // recurse from the worker who is having maximum work load\\n        recurse(jobs, jobs.length - 1, new int[k]);\\n        // return the minimum working time\\n        return min;\\n    }\\n    \\n    protected void recurse(int[] jobs, int index, int[] sum){\\n        \\n        // get the maximum total from the sum\\n        int max = getMax(sum);\\n        // if the sum of work time exceeds then return\\n        if (max >= min)\\n            return;\\n        \\n        // if the index is going negative, update the minimum maximum from the sum\\n        if (index < 0){\\n            min = Math.min(min,max);\\n            return;\\n        }\\n        \\n        for (int i=0;i<sum.length;i++){\\n            //if the sum is equal then continue and do not recurse\\n            // recurse only for distinct sum\\n            if (i > 0 && sum[i] == sum[i-1])\\n                continue;\\n            // choose\\n            sum[i] += jobs[index];\\n            // explore further\\n            recurse(jobs, index - 1, sum);\\n            //unchoose\\n            sum[i] -= jobs[index];\\n        }   \\n    }\\n    \\n    protected int getMax(int[] sum){\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<sum.length;i++)\\n            max = Math.max(max, sum[i]);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014490,
                "title": "fixing-answer-upper-bound-to-be-max-sum-jobs-k-2-max-jobs-works",
                "content": "Here is my code which got accepted. I am using a set to get record of previous distribution values present.\\n```\\nclass Solution {\\npublic:\\n    \\n    int res;\\n    \\n    void dfs(vector<int>& jobs, vector<int>& ppl,int j,int k){\\n        set<int> s;\\n        int n=jobs.size();\\n        if(j==n){\\n            int temp=0;\\n            for(int i=0;i<k;i++){\\n                temp=max(temp,ppl[i]);\\n            }\\n            res=min(res,temp);\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            if(s.find(ppl[i])!=s.end()){\\n                continue;\\n            }\\n            s.insert(ppl[i]);\\n            if(ppl[i]+jobs[j]>res)\\n                continue;\\n            ppl[i]+=jobs[j];\\n            dfs(jobs,ppl,j+1,k);\\n            ppl[i]-=jobs[j];\\n        }\\n        return;\\n    }\\n    \\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n=jobs.size();\\n        res=0;\\n        sort(jobs.begin(),jobs.end());\\n        res=jobs[n-1];\\n        if(n==k){\\n            return res;\\n        }\\n        res=0;\\n        for(int i=0;i<n;i++){\\n            res+=jobs[i];\\n        }\\n        res=max(res,2*(res/k));\\n        vector<int> ppl(k,0);\\n        dfs(jobs,ppl,0,k);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int res;\\n    \\n    void dfs(vector<int>& jobs, vector<int>& ppl,int j,int k){\\n        set<int> s;\\n        int n=jobs.size();\\n        if(j==n){\\n            int temp=0;\\n            for(int i=0;i<k;i++){\\n                temp=max(temp,ppl[i]);\\n            }\\n            res=min(res,temp);\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            if(s.find(ppl[i])!=s.end()){\\n                continue;\\n            }\\n            s.insert(ppl[i]);\\n            if(ppl[i]+jobs[j]>res)\\n                continue;\\n            ppl[i]+=jobs[j];\\n            dfs(jobs,ppl,j+1,k);\\n            ppl[i]-=jobs[j];\\n        }\\n        return;\\n    }\\n    \\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n=jobs.size();\\n        res=0;\\n        sort(jobs.begin(),jobs.end());\\n        res=jobs[n-1];\\n        if(n==k){\\n            return res;\\n        }\\n        res=0;\\n        for(int i=0;i<n;i++){\\n            res+=jobs[i];\\n        }\\n        res=max(res,2*(res/k));\\n        vector<int> ppl(k,0);\\n        dfs(jobs,ppl,0,k);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012232,
                "title": "assign-one-each-followed-by-backtrack",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(jobs.begin(),jobs.end(),greater<int>());\\n        if(k==jobs.size())return jobs[0];\\n        vector<int> people(k,0);\\n        int ma=INT_MIN;\\n        for(auto i=0;i<k;i++){people[i]+=jobs[i];ma=max(ma,people[i]);}\\n        f(jobs,people,k,ma);\\n        return ans;\\n    }\\n    void f(vector<int>& jobs,vector<int> people,int idx,int max_score){\\n        if(idx==jobs.size()){ans=min(ans,max_score);return;}\\n        for(auto i=0;i<people.size();i++){\\n            people[i]+=jobs[idx];\\n            f(jobs,people,idx+1,max(people[i],max_score));\\n            people[i]-=jobs[idx];\\n        }\\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(jobs.begin(),jobs.end(),greater<int>());\\n        if(k==jobs.size())return jobs[0];\\n        vector<int> people(k,0);\\n        int ma=INT_MIN;\\n        for(auto i=0;i<k;i++){people[i]+=jobs[i];ma=max(ma,people[i]);}\\n        f(jobs,people,k,ma);\\n        return ans;\\n    }\\n    void f(vector<int>& jobs,vector<int> people,int idx,int max_score){\\n        if(idx==jobs.size()){ans=min(ans,max_score);return;}\\n        for(auto i=0;i<people.size();i++){\\n            people[i]+=jobs[idx];\\n            f(jobs,people,idx+1,max(people[i],max_score));\\n            people[i]-=jobs[idx];\\n        }\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010340,
                "title": "c-two-solutions-dfs-and-bit-mask",
                "content": "**Solution1: DFS**\\n```csharp\\npublic int MinimumTimeRequired(int[] jobs, int k)\\n{\\n\\tint[] workers = new int[k];\\n\\tint result = int.MaxValue;\\n\\tdfs(0, jobs, workers, ref result);\\n\\treturn result;\\n}\\n\\nprivate void dfs(int current, int[] jobs, int[] workers, ref int result)\\n{\\n\\tif (current == jobs.Length)\\n\\t{\\n\\t\\tresult = Math.Min(result, workers.Max());\\n\\t\\treturn;\\n\\t}\\n\\n\\tHashSet<int> visited = new HashSet<int>();\\n\\n\\tfor (int i = 0; i < workers.Length; i++)\\n\\t{\\n\\t\\tif (!visited.Add(workers[i]))\\n\\t\\t{\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (workers[i] + jobs[current] >= result)\\n\\t\\t{\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tworkers[i] += jobs[current];\\n\\n\\t\\tdfs(current + 1, jobs, workers, ref result);\\n\\n\\t\\tworkers[i] -= jobs[current];\\n\\t}\\n}\\n```\\n\\n**Solution2: Bit Mask (slower than DFS)**\\n\\n```csharp\\npublic int MinimumTimeRequired(int[] jobs, int k)\\n{\\n\\tint ways = (1 << jobs.Length);\\n\\tint allJobsDone = ways - 1;\\n\\tint[,] d = new int[ways, k];\\n\\n\\tfor (int i = 0; i < ways; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < k; j++)\\n\\t\\t{\\n\\t\\t\\td[i, j] = int.MinValue;\\n\\t\\t}\\n\\t}\\n\\n\\tint result = helper(d, jobs, 0, 0, k, allJobsDone);\\n\\treturn result;\\n}\\n\\nprivate int helper(int[,] d, int[] jobs, int mask, int current, int k, int allJobsDone)\\n{\\n\\tif (current == k)\\n\\t{\\n\\t\\tif (mask == allJobsDone)\\n\\t\\t{\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn int.MaxValue;\\n\\t\\t}\\n\\t}\\n\\n\\telse if (d[mask, current] >= 0)\\n\\t{\\n\\t\\treturn d[mask, current];\\n\\t}\\n\\n\\tint result = int.MaxValue;\\n\\tList<int> remainingJobsIndices = new List<int>();\\n\\tfor (int j = 0; j < jobs.Length; j++)\\n\\t{\\n\\t\\tif ((mask & (1 << j)) == 0)\\n\\t\\t{\\n\\t\\t\\tremainingJobsIndices.Add(j);\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int i = 1; i < (1 << remainingJobsIndices.Count); i++)\\n\\t{\\n\\t\\tint nextMask = mask;\\n\\t\\tint time = 0;\\n\\n\\t\\tfor (int j = 0; j < remainingJobsIndices.Count; j++)\\n\\t\\t{\\n\\t\\t\\tif ((i & (1 << j)) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextMask |= (1 << remainingJobsIndices[j]);\\n\\t\\t\\t\\ttime += jobs[remainingJobsIndices[j]];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(time > result)\\n\\t\\t{\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tint next = helper(d, jobs, nextMask, current + 1, k, allJobsDone);\\n\\t\\tnext = Math.Max(next, time);\\n\\t\\tresult = Math.Min(result, next);           \\n\\t}\\n\\n\\td[mask, current] = result;\\n\\treturn result;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinimumTimeRequired(int[] jobs, int k)\\n{\\n\\tint[] workers = new int[k];\\n\\tint result = int.MaxValue;\\n\\tdfs(0, jobs, workers, ref result);\\n\\treturn result;\\n}\\n\\nprivate void dfs(int current, int[] jobs, int[] workers, ref int result)\\n{\\n\\tif (current == jobs.Length)\\n\\t{\\n\\t\\tresult = Math.Min(result, workers.Max());\\n\\t\\treturn;\\n\\t}\\n\\n\\tHashSet<int> visited = new HashSet<int>();\\n\\n\\tfor (int i = 0; i < workers.Length; i++)\\n\\t{\\n\\t\\tif (!visited.Add(workers[i]))\\n\\t\\t{\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (workers[i] + jobs[current] >= result)\\n\\t\\t{\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tworkers[i] += jobs[current];\\n\\n\\t\\tdfs(current + 1, jobs, workers, ref result);\\n\\n\\t\\tworkers[i] -= jobs[current];\\n\\t}\\n}\\n```\n```csharp\\npublic int MinimumTimeRequired(int[] jobs, int k)\\n{\\n\\tint ways = (1 << jobs.Length);\\n\\tint allJobsDone = ways - 1;\\n\\tint[,] d = new int[ways, k];\\n\\n\\tfor (int i = 0; i < ways; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < k; j++)\\n\\t\\t{\\n\\t\\t\\td[i, j] = int.MinValue;\\n\\t\\t}\\n\\t}\\n\\n\\tint result = helper(d, jobs, 0, 0, k, allJobsDone);\\n\\treturn result;\\n}\\n\\nprivate int helper(int[,] d, int[] jobs, int mask, int current, int k, int allJobsDone)\\n{\\n\\tif (current == k)\\n\\t{\\n\\t\\tif (mask == allJobsDone)\\n\\t\\t{\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn int.MaxValue;\\n\\t\\t}\\n\\t}\\n\\n\\telse if (d[mask, current] >= 0)\\n\\t{\\n\\t\\treturn d[mask, current];\\n\\t}\\n\\n\\tint result = int.MaxValue;\\n\\tList<int> remainingJobsIndices = new List<int>();\\n\\tfor (int j = 0; j < jobs.Length; j++)\\n\\t{\\n\\t\\tif ((mask & (1 << j)) == 0)\\n\\t\\t{\\n\\t\\t\\tremainingJobsIndices.Add(j);\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int i = 1; i < (1 << remainingJobsIndices.Count); i++)\\n\\t{\\n\\t\\tint nextMask = mask;\\n\\t\\tint time = 0;\\n\\n\\t\\tfor (int j = 0; j < remainingJobsIndices.Count; j++)\\n\\t\\t{\\n\\t\\t\\tif ((i & (1 << j)) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnextMask |= (1 << remainingJobsIndices[j]);\\n\\t\\t\\t\\ttime += jobs[remainingJobsIndices[j]];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(time > result)\\n\\t\\t{\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tint next = helper(d, jobs, nextMask, current + 1, k, allJobsDone);\\n\\t\\tnext = Math.Max(next, time);\\n\\t\\tresult = Math.Min(result, next);           \\n\\t}\\n\\n\\td[mask, current] = result;\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1010297,
                "title": "c-back-tracking-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint ans = 0;\\n\\t\\tint N = 0;\\n\\t\\tvoid DFS(int index, int curMax,vector<int>& workers, vector<int>& jobs){\\n\\t\\t\\tif( index >= N){\\n\\t\\t\\t\\tans = min(curMax, ans);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t// truncate the unnecessary branch\\n\\t\\t\\tif( curMax >= ans ) return; // if bigger or equal to current maximum, then skip\\n\\t\\t\\tunordered_set<int> S; // skip the redundant duplicate branch\\n\\t\\t\\tfor( int i = 0; i < workers.size(); i++ ){\\n\\t\\t\\t\\t// skip if it already appeared\\n\\t\\t\\t\\tif(S.count( workers[i] )) continue;\\n\\t\\t\\t\\tS.insert( workers[i] );\\n\\t\\t\\t\\tworkers[i] += jobs[index];\\n\\t\\t\\t\\tDFS( index + 1, max(curMax, workers[i]), workers, jobs );\\n\\t\\t\\t\\tworkers[i] -= jobs[index];\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint minimumTimeRequired(vector<int>& jobs, int k) {\\n\\t\\t\\tfor(int job : jobs) this->ans += job;\\n\\t\\t\\tthis->N = jobs.size();\\n\\t\\t\\tvector<int> workers(k,0);\\n\\t\\t\\tDFS( 0, 0, workers, jobs );\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint ans = 0;\\n\\t\\tint N = 0;\\n\\t\\tvoid DFS(int index, int curMax,vector<int>& workers, vector<int>& jobs){\\n\\t\\t\\tif( index >= N){\\n\\t\\t\\t\\tans = min(curMax, ans);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1010214,
                "title": "python3-backtracking",
                "content": "**Algorithm**\\n\\nBrute Force backtracking but first preassigned jobs to workers who do not have job\\n\\n**Code**\\n\\n```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        self.ans = 1<<32\\n        jobs.sort(reverse = True)\\n        def backtrack(i,cur):\\n            if i == len(jobs):\\n                self.ans = min(self.ans,max(cur))\\n                return\\n            for j in range(k):\\n                cur[j] += jobs[i]\\n                backtrack(i+1,cur)\\n                cur[j] -= jobs[i]\\n            return\\n        cur = [0 for _ in range(k)]\\n        i = 0\\n\\t\\t\\n        while i < len(cur) and i < len(jobs):\\n            cur[i] += jobs[i]\\n            i += 1\\n        backtrack(i,cur)\\n        return self.ans",
                "solutionTags": [],
                "code": "**Algorithm**\\n\\nBrute Force backtracking but first preassigned jobs to workers who do not have job\\n\\n**Code**\\n\\n```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        self.ans = 1<<32\\n        jobs.sort(reverse = True)\\n        def backtrack(i,cur):\\n            if i == len(jobs):\\n                self.ans = min(self.ans,max(cur))\\n                return\\n            for j in range(k):\\n                cur[j] += jobs[i]\\n                backtrack(i+1,cur)\\n                cur[j] -= jobs[i]\\n            return\\n        cur = [0 for _ in range(k)]\\n        i = 0\\n\\t\\t\\n        while i < len(cur) and i < len(jobs):\\n            cur[i] += jobs[i]\\n            i += 1\\n        backtrack(i,cur)\\n        return self.ans",
                "codeTag": "Java"
            },
            {
                "id": 1010206,
                "title": "c-20-ms",
                "content": "1. first make a good guess and prune.\\n2. prune duplicate worker\\n```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(jobs.begin(), jobs.end(), greater<>());\\n        if(k == jobs.size()) return jobs[0];\\n        vector<int> workers(k);\\n        res = firstGuess(jobs, k);\\n        dfs(jobs, workers, 0, 0);\\n        return res;\\n    }\\n    \\n    void dfs(const vector<int>& jobs, vector<int>& workers, int i, int cur){\\n        if(i == jobs.size()){\\n            res = cur;\\n            return;\\n        }\\n        set<int> visited;\\n        for(auto& worker : workers){\\n            if(worker + jobs[i] > res) continue;\\n            if(!visited.insert(worker).second) continue;\\n            worker += jobs[i];\\n            dfs(jobs, workers, i+1, max(cur, worker));\\n            worker -= jobs[i];\\n        }\\n    }\\n    \\n    int firstGuess(vector<int>& jobs, int k){\\n        priority_queue<int, vector<int>, greater<int>> q;\\n        for(int i=0;i<k;i++) q.push(0);\\n        for(auto job:jobs){\\n            auto worker = q.top(); q.pop();\\n            q.push(worker + job);\\n        }\\n        while(q.size() > 1) q.pop();\\n        return q.top();\\n    }\\n    \\n    int res;\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(jobs.begin(), jobs.end(), greater<>());\\n        if(k == jobs.size()) return jobs[0];\\n        vector<int> workers(k);\\n        res = firstGuess(jobs, k);\\n        dfs(jobs, workers, 0, 0);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1010146,
                "title": "java-1ms",
                "content": "```\\nclass Solution {\\n    int limit;\\n\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        Arrays.sort(jobs);\\n        int[] buffer = new int[jobs.length];\\n\\n        for (int i = jobs.length - 1; i >= 0; i -= k) {\\n            limit += jobs[i];\\n        }\\n        buffer[0] = jobs[jobs.length - 1];\\n        return next(jobs, k, jobs.length - 1, buffer, buffer[0]);\\n    }\\n\\n    int next(int[] jobs, int k, int index, int current[], int mmax) {\\n        if (index == 0) {\\n            return mmax;\\n        }\\n\\n        int inc = jobs[index - 1];\\n        for (int i = 0; i < k; i++) {\\n            if ((i > 0 && current[i] == current[i - 1]) || (current[i] + inc > limit)) {\\n                continue;\\n            }\\n            current[i] += inc;\\n            int val = next(jobs, k, index - 1, current, Math.max(mmax, current[i]));\\n            limit = Math.min(val, limit);\\n            current[i] -= inc;\\n        }\\n        return limit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int limit;\\n\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        Arrays.sort(jobs);\\n        int[] buffer = new int[jobs.length];\\n\\n        for (int i = jobs.length - 1; i >= 0; i -= k) {\\n            limit += jobs[i];\\n        }\\n        buffer[0] = jobs[jobs.length - 1];\\n        return next(jobs, k, jobs.length - 1, buffer, buffer[0]);\\n    }\\n\\n    int next(int[] jobs, int k, int index, int current[], int mmax) {\\n        if (index == 0) {\\n            return mmax;\\n        }\\n\\n        int inc = jobs[index - 1];\\n        for (int i = 0; i < k; i++) {\\n            if ((i > 0 && current[i] == current[i - 1]) || (current[i] + inc > limit)) {\\n                continue;\\n            }\\n            current[i] += inc;\\n            int val = next(jobs, k, index - 1, current, Math.max(mmax, current[i]));\\n            limit = Math.min(val, limit);\\n            current[i] -= inc;\\n        }\\n        return limit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009997,
                "title": "java-dfs-3-optimizations-6ms-100",
                "content": "**Basic flow**: use array `workers` of size `k` to track the working time of each worker; **DFS** all possiblilities.\\n\\nAdditional optimizations to speed up:\\n1.  once any `workers[wi] >= best solution so far`, stop\\n2.  in each DFS call, don\\'t try on workers with same working time (use Set `visited`)\\n3.  [**Very effective**] arrange the way of assigning `jobs` to `workers ` so that the first trial produces a much lower upper bound of `res`. This can be done by automatically shifting `wi` according to `jobs` index `i`\\n\\n\\n```\\nclass Solution {\\n  public int minimumTimeRequired(int[] jobs, int k) {\\n    int[] res = {Integer.MAX_VALUE};\\n    dfs(jobs, jobs.length - 1, new int[k], res);\\n    return res[0];\\n  }\\n\\n  private void dfs(int[] jobs, int i, int[] workers, int[] res) {\\n    if (i < 0) {\\n      res[0] = Math.min(res[0], Arrays.stream(workers).max().getAsInt());\\n      return;\\n    }\\n\\n    Set<Integer> visited = new HashSet<>();\\n    for (int j = 0; j < workers.length; j++) {\\n      int wi = (j + i) % workers.length;\\n      if (!visited.contains(workers[wi]) && workers[wi] + jobs[i] < res[0]) {\\n        visited.add(workers[wi]);\\n        workers[wi] += jobs[i];\\n        dfs(jobs, i - 1, workers, res);\\n        workers[wi] -= jobs[i];\\n      }\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int minimumTimeRequired(int[] jobs, int k) {\\n    int[] res = {Integer.MAX_VALUE};\\n    dfs(jobs, jobs.length - 1, new int[k], res);\\n    return res[0];\\n  }\\n\\n  private void dfs(int[] jobs, int i, int[] workers, int[] res) {\\n    if (i < 0) {\\n      res[0] = Math.min(res[0], Arrays.stream(workers).max().getAsInt());\\n      return;\\n    }\\n\\n    Set<Integer> visited = new HashSet<>();\\n    for (int j = 0; j < workers.length; j++) {\\n      int wi = (j + i) % workers.length;\\n      if (!visited.contains(workers[wi]) && workers[wi] + jobs[i] < res[0]) {\\n        visited.add(workers[wi]);\\n        workers[wi] += jobs[i];\\n        dfs(jobs, i - 1, workers, res);\\n        workers[wi] -= jobs[i];\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009868,
                "title": "go-javascript-backtracking",
                "content": "```go\\nimport \"math\"\\n\\nfunc minimumTimeRequired(jobTimes []int, k int) int {\\n    if len(jobTimes) <= k {\\n        return maxValue(jobTimes)\\n    }\\n    \\n    timesWorkersWorked := make([]int, k)\\n    minTimeRequired := math.MaxInt32\\n    getMinTimeRequired(k, 0, &minTimeRequired, &timesWorkersWorked, &jobTimes)\\n    return minTimeRequired\\n}\\n\\nfunc getMinTimeRequired(k, jobTimeIdx int, minTimeRequired *int, timesWorkersWorked, jobTimes *[]int) {\\n    if jobTimeIdx == len(*jobTimes) {\\n        // if we assigned all the jobs, see if we have a better result\\n        timeRequired := maxValue(*timesWorkersWorked)\\n        if timeRequired < *minTimeRequired {\\n            *minTimeRequired = timeRequired\\n        }\\n        return\\n    }\\n    \\n    workDuration := (*jobTimes)[jobTimeIdx]\\n\\n    for worker := 0; worker < k; worker++ {\\n        (*timesWorkersWorked)[worker] += workDuration\\n\\n        // if this combination is has a chance of decreasing our\\n        // answer, try it, otherwise skip it to save on time.\\n        if ((*timesWorkersWorked)[worker] <= *minTimeRequired) {\\n            getMinTimeRequired(k, jobTimeIdx + 1, minTimeRequired, timesWorkersWorked, jobTimes)\\n        }\\n        (*timesWorkersWorked)[worker] -= workDuration\\n\\n        // We want to minimize the width of the tree\\n        // so if the worker has gotten their first job\\n        // don\\'t try any workers after this worker.\\n        // All other workers after this worker will be 0 as well\\n        // so the combination is exactly the same.\\n        if (*timesWorkersWorked)[worker] == 0 {\\n            break\\n        }\\n    }\\n}\\n\\nfunc maxValue(timeWorked []int) int {\\n    minTimeWorked := 0\\n    for _, val := range timeWorked {\\n        if val > minTimeWorked {\\n            minTimeWorked = val\\n        }\\n    }\\n    return minTimeWorked\\n}\\n```\\n```javascript\\n/////////////////////////////////////////\\n/////////////////////////////////////////\\n/////////////////////////////////////////\\n/////////////////////////////////////////\\n/////////////////////////////////////////\\nvar minimumTimeRequired = function (jobs, k) {\\n    if (jobs.length <= k) {\\n        return Math.max(...jobs);\\n    }\\n\\n    // create a store to hold the number of hours each worker worked\\n    const workers = new Array(k).fill(0);\\n\\n    let minLongestWorkingTime = Infinity;\\n    const dfs = (i) => {\\n        if (i === jobs.length) {\\n            // if we assigned all the jobs, see if we have a better result\\n            minLongestWorkingTime = Math.min(minLongestWorkingTime, \\n                                             Math.max(...workers));\\n            return\\n        }\\n        const lengthOfWork = jobs[i]\\n\\n        for (let worker = 0; worker < k; worker++) {\\n            workers[worker] += lengthOfWork\\n            \\n            // if this combination is has a chance of decreasing our\\n            // answer, try it, otherwise skip it to save on time.\\n            if (workers[worker] <= minLongestWorkingTime) {\\n                dfs(i + 1)\\n            }\\n            workers[worker] -= lengthOfWork\\n            \\n            // We want to minimize the width of the tree\\n            // so if the worker has gotten their first job\\n            // don\\'t try any workers after this worker.\\n            // All other workers after this worker will be 0 as well\\n            // so the combination is exactly the same.\\n            if (workers[worker] === 0) break;\\n        }\\n    }\\n\\n    dfs(0);\\n    return minLongestWorkingTime;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Go",
                    "Backtracking"
                ],
                "code": "```go\\nimport \"math\"\\n\\nfunc minimumTimeRequired(jobTimes []int, k int) int {\\n    if len(jobTimes) <= k {\\n        return maxValue(jobTimes)\\n    }\\n    \\n    timesWorkersWorked := make([]int, k)\\n    minTimeRequired := math.MaxInt32\\n    getMinTimeRequired(k, 0, &minTimeRequired, &timesWorkersWorked, &jobTimes)\\n    return minTimeRequired\\n}\\n\\nfunc getMinTimeRequired(k, jobTimeIdx int, minTimeRequired *int, timesWorkersWorked, jobTimes *[]int) {\\n    if jobTimeIdx == len(*jobTimes) {\\n        // if we assigned all the jobs, see if we have a better result\\n        timeRequired := maxValue(*timesWorkersWorked)\\n        if timeRequired < *minTimeRequired {\\n            *minTimeRequired = timeRequired\\n        }\\n        return\\n    }\\n    \\n    workDuration := (*jobTimes)[jobTimeIdx]\\n\\n    for worker := 0; worker < k; worker++ {\\n        (*timesWorkersWorked)[worker] += workDuration\\n\\n        // if this combination is has a chance of decreasing our\\n        // answer, try it, otherwise skip it to save on time.\\n        if ((*timesWorkersWorked)[worker] <= *minTimeRequired) {\\n            getMinTimeRequired(k, jobTimeIdx + 1, minTimeRequired, timesWorkersWorked, jobTimes)\\n        }\\n        (*timesWorkersWorked)[worker] -= workDuration\\n\\n        // We want to minimize the width of the tree\\n        // so if the worker has gotten their first job\\n        // don\\'t try any workers after this worker.\\n        // All other workers after this worker will be 0 as well\\n        // so the combination is exactly the same.\\n        if (*timesWorkersWorked)[worker] == 0 {\\n            break\\n        }\\n    }\\n}\\n\\nfunc maxValue(timeWorked []int) int {\\n    minTimeWorked := 0\\n    for _, val := range timeWorked {\\n        if val > minTimeWorked {\\n            minTimeWorked = val\\n        }\\n    }\\n    return minTimeWorked\\n}\\n```\n```javascript\\n/////////////////////////////////////////\\n/////////////////////////////////////////\\n/////////////////////////////////////////\\n/////////////////////////////////////////\\n/////////////////////////////////////////\\nvar minimumTimeRequired = function (jobs, k) {\\n    if (jobs.length <= k) {\\n        return Math.max(...jobs);\\n    }\\n\\n    // create a store to hold the number of hours each worker worked\\n    const workers = new Array(k).fill(0);\\n\\n    let minLongestWorkingTime = Infinity;\\n    const dfs = (i) => {\\n        if (i === jobs.length) {\\n            // if we assigned all the jobs, see if we have a better result\\n            minLongestWorkingTime = Math.min(minLongestWorkingTime, \\n                                             Math.max(...workers));\\n            return\\n        }\\n        const lengthOfWork = jobs[i]\\n\\n        for (let worker = 0; worker < k; worker++) {\\n            workers[worker] += lengthOfWork\\n            \\n            // if this combination is has a chance of decreasing our\\n            // answer, try it, otherwise skip it to save on time.\\n            if (workers[worker] <= minLongestWorkingTime) {\\n                dfs(i + 1)\\n            }\\n            workers[worker] -= lengthOfWork\\n            \\n            // We want to minimize the width of the tree\\n            // so if the worker has gotten their first job\\n            // don\\'t try any workers after this worker.\\n            // All other workers after this worker will be 0 as well\\n            // so the combination is exactly the same.\\n            if (workers[worker] === 0) break;\\n        }\\n    }\\n\\n    dfs(0);\\n    return minLongestWorkingTime;\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1009769,
                "title": "easy-bitmask-dp",
                "content": "**DP State**: \\n ```\\n\\tdp[i][mask]= The minimum Maximum working time of the first i people, \\n\\t\\t\\t\\t\\t if their selection corresponds to mask (aka which items are selected)\\n```\\n**Recurrence**:\\n        *curmask*: the mask of the i-th person (which items he selected)\\n        *prevmask*: the cumulative mask of the previous i-1 persons\\n```        \\ndp[i][curmask | prevmask]=Math.min(\\n\\t\\t\\t\\t\\t\\t\\t\\tdp[i][curmask | prevmask], \\n\\t\\t\\t\\t\\t\\t\\t\\tMath.max(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdp[i-1][prevmask],   //so either the maximum time belongs to some previous person\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmaskSum[curmask]     // or the i-th person, so the sum of his jobs is considered\\n\\t\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t   )\\n```\\n**Implementation:**\\n```\\nvar minimumTimeRequired = function(jobs, k) {\\n    let n=jobs.length, maskSum=[...Array(1<<n)].map(d=>0)\\n    for(let mask=0;mask<(1<<n);mask++)  //pre-store the sums of every mask\\n        for(let i=0;i<n;i++)\\n            maskSum[mask]+=Number(((1<<i) & mask)!=0)*jobs[i]\\n    let dp=[...Array(k+1)].map(d=>[...Array(1<<n)].map(d=>Infinity))\\n    dp[0][0]=0\\n    for(let i=1;i<=k;i++) //for each new person\\n        for(let curmask=0;curmask<(1<<n);curmask++) //guess what his mask can be, what items can he select\\n            for(let prevmask=0;prevmask<(1<<n);prevmask++) // but also, guess what the previous i-1 persons took already\\n                if((curmask&prevmask)===0) //obviously, 2 people can\\'t take the same job\\n                    dp[i][curmask|prevmask]=Math.min(dp[i][curmask|prevmask],Math.max(dp[i-1][prevmask],maskSum[curmask]))\\n    return dp[k][(1<<n) -1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n\\tdp[i][mask]= The minimum Maximum working time of the first i people, \\n\\t\\t\\t\\t\\t if their selection corresponds to mask (aka which items are selected)\\n```\n```        \\ndp[i][curmask | prevmask]=Math.min(\\n\\t\\t\\t\\t\\t\\t\\t\\tdp[i][curmask | prevmask], \\n\\t\\t\\t\\t\\t\\t\\t\\tMath.max(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdp[i-1][prevmask],   //so either the maximum time belongs to some previous person\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmaskSum[curmask]     // or the i-th person, so the sum of his jobs is considered\\n\\t\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t   )\\n```\n```\\nvar minimumTimeRequired = function(jobs, k) {\\n    let n=jobs.length, maskSum=[...Array(1<<n)].map(d=>0)\\n    for(let mask=0;mask<(1<<n);mask++)  //pre-store the sums of every mask\\n        for(let i=0;i<n;i++)\\n            maskSum[mask]+=Number(((1<<i) & mask)!=0)*jobs[i]\\n    let dp=[...Array(k+1)].map(d=>[...Array(1<<n)].map(d=>Infinity))\\n    dp[0][0]=0\\n    for(let i=1;i<=k;i++) //for each new person\\n        for(let curmask=0;curmask<(1<<n);curmask++) //guess what his mask can be, what items can he select\\n            for(let prevmask=0;prevmask<(1<<n);prevmask++) // but also, guess what the previous i-1 persons took already\\n                if((curmask&prevmask)===0) //obviously, 2 people can\\'t take the same job\\n                    dp[i][curmask|prevmask]=Math.min(dp[i][curmask|prevmask],Math.max(dp[i-1][prevmask],maskSum[curmask]))\\n    return dp[k][(1<<n) -1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089383,
                "title": "typescript-dfs-time-o-k-2-n-space-o-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(k*2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Typescript\\nfunction minimumTimeRequired(jobs: number[], k: number): number {\\n    return helper(jobs, [], Infinity, 0, jobs.length, k);\\n};\\n\\nfunction helper(jobs: number[], workers: number[], min: number, max: number, J: number, W: number): number {\\n\\n    // All workers used \\n    // OR min surpassed\\n    if (W < 0 || max >= min) {\\n        return min;\\n    }\\n\\n    // All jobs used\\n    if (J <= 0) {\\n        return max;\\n    }\\n\\n    // Get the current job\\n    const job = jobs[--J];\\n\\n    // Add job to existing worker\\n    const N = workers.length;\\n    for (let j = 0; j < N; ++j) {\\n        workers[j] += job;\\n        min = helper(jobs, workers, min, Math.max(max, workers[j]), J, W);\\n        workers[j] -= job;\\n    }\\n\\n    // Add job to new worker\\n    workers.push(job);\\n    min = helper(jobs, workers, min, Math.max(max, job), J, W - 1);\\n    workers.pop();\\n    \\n    return min;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Depth-First Search"
                ],
                "code": "```Typescript\\nfunction minimumTimeRequired(jobs: number[], k: number): number {\\n    return helper(jobs, [], Infinity, 0, jobs.length, k);\\n};\\n\\nfunction helper(jobs: number[], workers: number[], min: number, max: number, J: number, W: number): number {\\n\\n    // All workers used \\n    // OR min surpassed\\n    if (W < 0 || max >= min) {\\n        return min;\\n    }\\n\\n    // All jobs used\\n    if (J <= 0) {\\n        return max;\\n    }\\n\\n    // Get the current job\\n    const job = jobs[--J];\\n\\n    // Add job to existing worker\\n    const N = workers.length;\\n    for (let j = 0; j < N; ++j) {\\n        workers[j] += job;\\n        min = helper(jobs, workers, min, Math.max(max, workers[j]), J, W);\\n        workers[j] -= job;\\n    }\\n\\n    // Add job to new worker\\n    workers.push(job);\\n    min = helper(jobs, workers, min, Math.max(max, job), J, W - 1);\\n    workers.pop();\\n    \\n    return min;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084561,
                "title": "binary-search-and-backtracking-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nSorting -> O(nlogn) where n is the length of jobs\\n\\n- Space complexity:\\n Workers -> O(k)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumTimeRequired(int[] jobs, int k) {\\n        Array.Sort(jobs);\\n        int left = jobs.Max();\\n        int right = jobs.Sum();\\n\\n        while(left< right){\\n            var mid = left+ (right-left)/2;\\n            if(CanAssign(jobs,0,k,mid)){\\n                right = mid;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    private bool CanAssign(int[] jobs, int index, int k, int maxTime){\\n        var workers = new int[k];\\n        return BackTrack( jobs, index, workers, maxTime);\\n    }\\n    private bool BackTrack(int[] jobs, int index, int[] workers, int maxTime){\\n        if(index == jobs.Length){\\n            return true;\\n        }\\n\\n        for(var i = 0; i<workers.Length; i++){\\n            if(workers[i]+jobs[index]<= maxTime){\\n                workers[i]+=jobs[index];\\n                if(BackTrack(jobs,index+1,workers,maxTime)){\\n                    return true;\\n                }\\n                workers[i]-=jobs[index];\\n            }\\n            if(workers[i]==0 || workers[i]+jobs[index]== maxTime){\\n                break;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumTimeRequired(int[] jobs, int k) {\\n        Array.Sort(jobs);\\n        int left = jobs.Max();\\n        int right = jobs.Sum();\\n\\n        while(left< right){\\n            var mid = left+ (right-left)/2;\\n            if(CanAssign(jobs,0,k,mid)){\\n                right = mid;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    private bool CanAssign(int[] jobs, int index, int k, int maxTime){\\n        var workers = new int[k];\\n        return BackTrack( jobs, index, workers, maxTime);\\n    }\\n    private bool BackTrack(int[] jobs, int index, int[] workers, int maxTime){\\n        if(index == jobs.Length){\\n            return true;\\n        }\\n\\n        for(var i = 0; i<workers.Length; i++){\\n            if(workers[i]+jobs[index]<= maxTime){\\n                workers[i]+=jobs[index];\\n                if(BackTrack(jobs,index+1,workers,maxTime)){\\n                    return true;\\n                }\\n                workers[i]-=jobs[index];\\n            }\\n            if(workers[i]==0 || workers[i]+jobs[index]== maxTime){\\n                break;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078289,
                "title": "96-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void f(int ind, vector<int> &jobs, vector<int> &time, int &ans){\\n        int n = jobs.size();\\n        int k = time.size();\\n        if(ind==n){\\n            ans = min(ans,*max_element(time.begin(),time.end()));\\n            return;\\n        }\\n        \\n        if(*max_element(time.begin(),time.end()) >= ans)\\n            return;\\n        // int ans = 1e9+1;\\n        for(int i=0; i<k; ++i){\\n            if(i>0 && time[i]==time[i-1]) continue;\\n            time[i]+=jobs[ind];\\n            // ans = min(ans, f(ind+1,jobs,time));\\n            f(ind+1, jobs, time, ans);\\n            time[i]-=jobs[ind];\\n        }\\n\\n        // return ans;\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int> time(k,0);\\n        int ans = 1e9+1;\\n        sort(jobs.begin(),jobs.end(), greater<int>());\\n        f(0,jobs,time,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(int ind, vector<int> &jobs, vector<int> &time, int &ans){\\n        int n = jobs.size();\\n        int k = time.size();\\n        if(ind==n){\\n            ans = min(ans,*max_element(time.begin(),time.end()));\\n            return;\\n        }\\n        \\n        if(*max_element(time.begin(),time.end()) >= ans)\\n            return;\\n        // int ans = 1e9+1;\\n        for(int i=0; i<k; ++i){\\n            if(i>0 && time[i]==time[i-1]) continue;\\n            time[i]+=jobs[ind];\\n            // ans = min(ans, f(ind+1,jobs,time));\\n            f(ind+1, jobs, time, ans);\\n            time[i]-=jobs[ind];\\n        }\\n\\n        // return ans;\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int> time(k,0);\\n        int ans = 1e9+1;\\n        sort(jobs.begin(),jobs.end(), greater<int>());\\n        f(0,jobs,time,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976317,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minimumTimeRequired(std::vector<int>& jobs, int k) {\\n    int ans = accumulate(jobs.begin(), jobs.end(), 0);\\n    vector<int> times(k);\\n\\n    sort(jobs.rbegin(), jobs.rend());\\n    dfs(jobs, 0, times, ans);\\n    return ans;\\n  }\\n\\n private:\\n  void dfs(const vector<int>& jobs, int s, vector<int>& times, int& ans) {\\n    if (s == jobs.size()) {\\n      ans = min(ans, *max_element(times.begin(), times.end()));\\n      return;\\n    }\\n    for (int i = 0; i < times.size(); ++i) {\\n      if (times[i] + jobs[s] >= ans)\\n        continue;\\n      times[i] += jobs[s];\\n      dfs(jobs, s + 1, times, ans);\\n      times[i] -= jobs[s];\\n      if (times[i] == 0)\\n        return;\\n    }\\n  };\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minimumTimeRequired(std::vector<int>& jobs, int k) {\\n    int ans = accumulate(jobs.begin(), jobs.end(), 0);\\n    vector<int> times(k);\\n\\n    sort(jobs.rbegin(), jobs.rend());\\n    dfs(jobs, 0, times, ans);\\n    return ans;\\n  }\\n\\n private:\\n  void dfs(const vector<int>& jobs, int s, vector<int>& times, int& ans) {\\n    if (s == jobs.size()) {\\n      ans = min(ans, *max_element(times.begin(), times.end()));\\n      return;\\n    }\\n    for (int i = 0; i < times.size(); ++i) {\\n      if (times[i] + jobs[s] >= ans)\\n        continue;\\n      times[i] += jobs[s];\\n      dfs(jobs, s + 1, times, ans);\\n      times[i] -= jobs[s];\\n      if (times[i] == 0)\\n        return;\\n    }\\n  };\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951978,
                "title": "c-backtracking-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    void distribute(vector<int>& cookies, int index, int k, vector<int>& sum, int& m)\\n    {\\n        if(index == cookies.size())\\n        {\\n            int temp = 0;\\n            for(auto i : sum)\\n                temp = max(temp, i);\\n            m = min(m, temp);\\n            return;\\n        }\\n\\n        for(int c = 0; c<k; c++)\\n        {\\n            if(cookies[index] + sum[c] < m)\\n            {\\n            sum[c]+= cookies[index]; \\n            distribute(cookies, index + 1, k, sum, m);\\n            sum[c]-= cookies[index];\\n            if(sum[c] == 0)\\n                break;\\n            }\\n        }\\n\\n    }\\n\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int>sum(k, 0);\\n        int m= 1e8;\\n        distribute(jobs, 0, k, sum, m);\\n        return m; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void distribute(vector<int>& cookies, int index, int k, vector<int>& sum, int& m)\\n    {\\n        if(index == cookies.size())\\n        {\\n            int temp = 0;\\n            for(auto i : sum)\\n                temp = max(temp, i);\\n            m = min(m, temp);\\n            return;\\n        }\\n\\n        for(int c = 0; c<k; c++)\\n        {\\n            if(cookies[index] + sum[c] < m)\\n            {\\n            sum[c]+= cookies[index]; \\n            distribute(cookies, index + 1, k, sum, m);\\n            sum[c]-= cookies[index];\\n            if(sum[c] == 0)\\n                break;\\n            }\\n        }\\n\\n    }\\n\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int>sum(k, 0);\\n        int m= 1e8;\\n        distribute(jobs, 0, k, sum, m);\\n        return m; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890374,
                "title": "submask-of-a-mask-o-3-n-bitmask",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        // dp[i][mask] : i workers and mask assigned;\\n        int n = jobs.size();\\n        vector<int> sum((1<<n));\\n        for(int i=0;i<(1<<n);i++){\\n            sum[i] = 0;\\n            for(int j=0;j<n;j++){\\n                if(((1<<j)&i)){\\n                    sum[i] += jobs[j];\\n                }\\n            }\\n        }\\n        vector<vector<int>> dp(k+1, vector<int>((1<<n), INT_MAX));\\n        for(int mask=0;mask<(1<<n);mask++){\\n            dp[1][mask] = sum[mask];\\n        }\\n        for(int i=2;i<=k;i++){\\n            for(int mask=0;mask<(1<<n);mask++){\\n                // dp[i][mask] ??\\n                for(int s=mask;s;s=(s-1)&mask){\\n                    dp[i][mask] = min(dp[i][mask], max(sum[s], dp[i-1][mask - s]));\\n                }\\n            }\\n        }\\n        return dp[k][(1<<n)-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        // dp[i][mask] : i workers and mask assigned;\\n        int n = jobs.size();\\n        vector<int> sum((1<<n));\\n        for(int i=0;i<(1<<n);i++){\\n            sum[i] = 0;\\n            for(int j=0;j<n;j++){\\n                if(((1<<j)&i)){\\n                    sum[i] += jobs[j];\\n                }\\n            }\\n        }\\n        vector<vector<int>> dp(k+1, vector<int>((1<<n), INT_MAX));\\n        for(int mask=0;mask<(1<<n);mask++){\\n            dp[1][mask] = sum[mask];\\n        }\\n        for(int i=2;i<=k;i++){\\n            for(int mask=0;mask<(1<<n);mask++){\\n                // dp[i][mask] ??\\n                for(int s=mask;s;s=(s-1)&mask){\\n                    dp[i][mask] = min(dp[i][mask], max(sum[s], dp[i-1][mask - s]));\\n                }\\n            }\\n        }\\n        return dp[k][(1<<n)-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864784,
                "title": "19ms-python-backtracking",
                "content": "Backtracking got TLE very easily. So pruning is needed.\\n\\n1) When the previous worker\\'s time is 0, we stop the backtracking, since we have already tried all the **following** possiblities on the previous worker.\\n2) When current max is greater than res, stop the backtracking. There is no way we can get a smaller res.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumTimeRequired(self, jobs, k):\\n        \"\"\"\\n        :type jobs: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def helper(i, cmax):\\n\\n            if i == leng:\\n                res[0] = min(res[0], cmax)\\n                return\\n\\n            t = jobs[i]\\n            for j in range(k):\\n\\n                ### pruning 1\\n                if j > 0 and w[j - 1] == 0:\\n                    break\\n\\n                w[j] += t\\n\\n                ### pruning 2\\n                if max(cmax, w[j]) < res[0]:\\n                    helper(i + 1, max(cmax, w[j]))\\n\\n                w[j] -= t\\n\\n        \\n        leng = len(jobs)\\n        jobs.sort(reverse = True)\\n        \\n        ### this one can be further optimized, I guess\\n        res = [10**9]\\n        \\n        w = [0] * k\\n        helper(0, 0)\\n        return res[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumTimeRequired(self, jobs, k):\\n        \"\"\"\\n        :type jobs: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n\\n        def helper(i, cmax):\\n\\n            if i == leng:\\n                res[0] = min(res[0], cmax)\\n                return\\n\\n            t = jobs[i]\\n            for j in range(k):\\n\\n                ### pruning 1\\n                if j > 0 and w[j - 1] == 0:\\n                    break\\n\\n                w[j] += t\\n\\n                ### pruning 2\\n                if max(cmax, w[j]) < res[0]:\\n                    helper(i + 1, max(cmax, w[j]))\\n\\n                w[j] -= t\\n\\n        \\n        leng = len(jobs)\\n        jobs.sort(reverse = True)\\n        \\n        ### this one can be further optimized, I guess\\n        res = [10**9]\\n        \\n        w = [0] * k\\n        helper(0, 0)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829821,
                "title": "6-line-code-binary-search-simplest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool find(vector<int>& nums, vector<int>& sum, int index, int mid) {\\n        if (index == nums.size()) return true;\\n        \\n        for (int i = 0; i < sum.size(); i++) {\\n            if (sum[i] + nums[index] <= mid) {\\n                sum[i] += nums[index];\\n                \\n                if (find(nums, sum, index + 1, mid)) {\\n                    return true;\\n                }\\n                sum[i] -= nums[index];\\n            }\\n            if (sum[i] == 0) break;\\n        }\\n        \\n        return false;\\n    }\\n\\n    int minimumTimeRequired(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int l = *max_element(nums.begin(), nums.end());\\n        int r = accumulate(nums.begin(), nums.end(), 0);\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (l <= r) {\\n            int mid = (l + r) / 2;\\n            vector<int> sum(k, 0);\\n            \\n            if (find(nums, sum, 0, mid)) {\\n                ans = mid;\\n                r = mid - 1;\\n            } \\n            else l = mid + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Backtracking",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool find(vector<int>& nums, vector<int>& sum, int index, int mid) {\\n        if (index == nums.size()) return true;\\n        \\n        for (int i = 0; i < sum.size(); i++) {\\n            if (sum[i] + nums[index] <= mid) {\\n                sum[i] += nums[index];\\n                \\n                if (find(nums, sum, index + 1, mid)) {\\n                    return true;\\n                }\\n                sum[i] -= nums[index];\\n            }\\n            if (sum[i] == 0) break;\\n        }\\n        \\n        return false;\\n    }\\n\\n    int minimumTimeRequired(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int l = *max_element(nums.begin(), nums.end());\\n        int r = accumulate(nums.begin(), nums.end(), 0);\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (l <= r) {\\n            int mid = (l + r) / 2;\\n            vector<int> sum(k, 0);\\n            \\n            if (find(nums, sum, 0, mid)) {\\n                ans = mid;\\n                r = mid - 1;\\n            } \\n            else l = mid + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819577,
                "title": "4-optimizations-that-can-be-made-beats-99-53-in-runtime",
                "content": "![image.png](https://assets.leetcode.com/users/images/20196ceb-fe85-47ad-8d67-2e08edeb58b4_1690381542.951078.png)\\n\\n# Approach\\nThis can be done by as a brute-force search with early termination. We find that the naive solution will TLE and certain optimisations are necessary.\\n\\nThis solution acts as a summary of the optimisations I found and collated here. In particular, I will talk about 4 of these optimisations.\\n\\n1. The first job has to always be assigned to someone, so why not just immediately assign it to the first worker. This reduces the search space from $2^n$ to $2^{n-1}$ as we only have to assign the remaining $n-1$ tasks.\\n2. Determine an upperbound of the time taken. With an upperbound in time, we can terminate the search earlier. So how can we find such an upperbound? A greedy approach comes to mind. We can repeatedly assign jobs with decreasing job times to the worker with the least amount of time.\\n3. As we perform search, we can prune our search by ensuring at no point in the search does our maxtime exceed our current best time. \\n4. As explained very well by **lichuan199010** in his solution found [here](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/solutions/1009817/one-branch-cutting-trick-to-solve-three-leetcode-questions/), we can also remember that we have tried to add a job to an earlier worker with the same time, and hence its futile to redo the search, allowing us to skip the worker.\\n\\nDo try to implement these 4 optimisations and you will find a drastic decrease in your runtime. \\n\\nYou can find the python code below.\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, i, jobs, curr):\\n        if i >= len(jobs):\\n            self.ans = min(self.ans, max(curr))\\n            return\\n        seen = set()\\n        for wi in range(len(curr)):\\n            if curr[wi] in seen:\\n                continue\\n            seen.add(curr[wi])\\n            curr[wi] += jobs[i]\\n            if max(curr) < self.ans:\\n                self.search(i+1, jobs, curr)\\n            curr[wi] -= jobs[i]\\n        \\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        # 4 Optimisations to be made\\n        # -> Upperbound with greedy fill, early exit\\n        # -> If we added current job to a worker of same size before, skip\\n        # -> If exceed ans, dont go any further\\n        # -> Someone has to take the first job, assign it to first person\\n        jobs.sort(reverse=True)\\n        greedy = [0] * k\\n        for j in jobs:\\n            m = greedy[0]\\n            heapq.heappushpop(greedy, m+j)\\n        self.ans = max(greedy)\\n        curr = [0] * k\\n        curr[0] = jobs[0]\\n        self.search(1, jobs, curr)\\n        return self.ans\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, i, jobs, curr):\\n        if i >= len(jobs):\\n            self.ans = min(self.ans, max(curr))\\n            return\\n        seen = set()\\n        for wi in range(len(curr)):\\n            if curr[wi] in seen:\\n                continue\\n            seen.add(curr[wi])\\n            curr[wi] += jobs[i]\\n            if max(curr) < self.ans:\\n                self.search(i+1, jobs, curr)\\n            curr[wi] -= jobs[i]\\n        \\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        # 4 Optimisations to be made\\n        # -> Upperbound with greedy fill, early exit\\n        # -> If we added current job to a worker of same size before, skip\\n        # -> If exceed ans, dont go any further\\n        # -> Someone has to take the first job, assign it to first person\\n        jobs.sort(reverse=True)\\n        greedy = [0] * k\\n        for j in jobs:\\n            m = greedy[0]\\n            heapq.heappushpop(greedy, m+j)\\n        self.ans = max(greedy)\\n        curr = [0] * k\\n        curr[0] = jobs[0]\\n        self.search(1, jobs, curr)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798882,
                "title": "binary-search-dfs-trimming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        jobs.sort(reverse = True)\\n        plan, n = [0] * k, len(jobs)\\n        def dfs(curJobs, limit): # cookies\\n            if curJobs == n:\\n                return True\\n            flag = 0 # trim for first have jobs from no jobs of anyone\\n            for i in range(k): # children\\n                if plan[i] + jobs[curJobs] > limit:\\n                    continue\\n                if plan[i] == 0:\\n                    if flag == 1: continue\\n                    flag = 1\\n                plan[i] += jobs[curJobs]\\n                if dfs(curJobs + 1, limit):\\n                    return True\\n                plan[i] -= jobs[curJobs]\\n            return False\\n        l, r = max(jobs), sum(jobs)\\n        while l < r:\\n            for i in range(k):\\n                plan[i] = 0\\n            m = l + (r - l) // 2\\n            if dfs(0, m):\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        jobs.sort(reverse = True)\\n        plan, n = [0] * k, len(jobs)\\n        def dfs(curJobs, limit): # cookies\\n            if curJobs == n:\\n                return True\\n            flag = 0 # trim for first have jobs from no jobs of anyone\\n            for i in range(k): # children\\n                if plan[i] + jobs[curJobs] > limit:\\n                    continue\\n                if plan[i] == 0:\\n                    if flag == 1: continue\\n                    flag = 1\\n                plan[i] += jobs[curJobs]\\n                if dfs(curJobs + 1, limit):\\n                    return True\\n                plan[i] -= jobs[curJobs]\\n            return False\\n        l, r = max(jobs), sum(jobs)\\n        while l < r:\\n            for i in range(k):\\n                plan[i] = 0\\n            m = l + (r - l) // 2\\n            if dfs(0, m):\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779930,
                "title": "backtracking-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& jobs, int k, int pos, vector<int>& workerTime, int& res, int& zero_count){\\n        if(jobs.size() - pos < zero_count) return;\\n        if(*max_element(workerTime.begin(), workerTime.end()) > res)\\n          return;\\n        if(pos == jobs.size()){\\n            int t = *max_element(workerTime.begin(), workerTime.end());\\n            res = min(res, t);\\n            return;\\n        }\\n        for(int i=0; i<k; i++){\\n            //\\n            if(i > 0 && workerTime[i] == workerTime[i-1]) continue;\\n            zero_count += (workerTime[i] == 0 ? -1 : 0);\\n            workerTime[i] += jobs[pos];\\n            solve(jobs, k, pos+1, workerTime, res, zero_count);\\n            workerTime[i] -= jobs[pos];\\n            zero_count += (workerTime[i] == 0);\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int> workerTime(k, 0);\\n        int res = INT_MAX;\\n        int zero_count = k;\\n        solve(jobs, k, 0, workerTime, res, zero_count);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& jobs, int k, int pos, vector<int>& workerTime, int& res, int& zero_count){\\n        if(jobs.size() - pos < zero_count) return;\\n        if(*max_element(workerTime.begin(), workerTime.end()) > res)\\n          return;\\n        if(pos == jobs.size()){\\n            int t = *max_element(workerTime.begin(), workerTime.end());\\n            res = min(res, t);\\n            return;\\n        }\\n        for(int i=0; i<k; i++){\\n            //\\n            if(i > 0 && workerTime[i] == workerTime[i-1]) continue;\\n            zero_count += (workerTime[i] == 0 ? -1 : 0);\\n            workerTime[i] += jobs[pos];\\n            solve(jobs, k, pos+1, workerTime, res, zero_count);\\n            workerTime[i] -= jobs[pos];\\n            zero_count += (workerTime[i] == 0);\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int> workerTime(k, 0);\\n        int res = INT_MAX;\\n        int zero_count = k;\\n        solve(jobs, k, 0, workerTime, res, zero_count);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749935,
                "title": "my-solutions",
                "content": "**1. Use the DP**\\n```\\n/**\\n * Time Complexity: O(k * (3 ^ n_jobs))\\n * Space Complexity: O(2 ^ n_jobs)\\n * where `n_jobs` is the length of the vector `jobs`\\n */\\nclass Solution {\\n public:\\n  int minimumTimeRequired(const vector<int> &jobs, const int k) {\\n    constexpr int range = 2;\\n    const int n_jobs = static_cast<int>(jobs.size());\\n    const int job_layouts = 1 << n_jobs;\\n    \\n    uint32_t times[job_layouts];\\n    memset(times, 0, sizeof(times));\\n    for (int job = 0; job < n_jobs; ++job) {\\n      const int bound = 1 << job;\\n      for (int sub_jobs = 0; sub_jobs < bound; ++sub_jobs) {\\n        times[sub_jobs | bound] = times[sub_jobs] + jobs[job];\\n      }\\n    }\\n    \\n    /**\\n     * dp[workers][job_set] stands for the minimum possible maximum working time\\n     * of `workers` workers when jobs represented by `job_set` are assigned to\\n     * these `workers` workers\\n     */\\n    uint32_t dp[range][job_layouts];\\n    memset(dp, -1, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    for (int job_layout = 0; job_layout < job_layouts; ++job_layout) {\\n      dp[previous][job_layout] = times[job_layout];\\n    }\\n    \\n    for (int i = 1; i < k; ++i) {\\n      for (int job_layout = 0; job_layout < job_layouts; ++job_layout) {\\n        for (int sub_job = job_layout; sub_job > 0; sub_job = (sub_job - 1) & job_layout) {\\n          dp[current][job_layout] = min(dp[current][job_layout],\\n                                        max(times[sub_job], dp[previous][job_layout ^ sub_job]));\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], -1, sizeof(dp[current]));\\n    }\\n    \\n    return dp[previous][job_layouts - 1];\\n  }\\n};\\n```\\n**2. Use the DFS with the pruning**\\n```\\nclass Solution {\\n public:\\n  int minimumTimeRequired(vector<int> &jobs, int k) {\\n    const int n_jobs = static_cast<int>(jobs.size());\\n    if (n_jobs == k) {\\n      // assign exactly one job to one worker\\n      return *max_element(jobs.begin(), jobs.end());\\n    }\\n    \\n    sort(jobs.begin(), jobs.end(), greater<>{});   // it\\'s very important\\n    int workers[k];\\n    memset(workers, 0, sizeof(workers));\\n    int ret = numeric_limits<int>::max();\\n    dfs(jobs, k, 0, workers, 0, ret);\\n    return ret;\\n  }\\n  \\n private:\\n  void dfs(const vector<int> &jobs, const int k, const int i_job, int *workers, const int current, int &result) {\\n    if (current >= result) {\\n      return;\\n    }\\n    \\n    const int n_jobs = static_cast<int>(jobs.size());\\n    if (i_job == n_jobs) {\\n      result = current;\\n      return;\\n    }\\n    \\n    int worker_indices[k];\\n    iota(worker_indices, worker_indices + k, 0);\\n    sort(worker_indices, worker_indices + k, [workers](const int lhs, const int rhs) -> bool {\\n      return workers[lhs] < workers[rhs];\\n    });\\n    for (int i_worker = 0; i_worker < k; ++i_worker) {\\n      int &worker = workers[worker_indices[i_worker]];\\n      if (i_worker > 0 && worker == workers[worker_indices[i_worker - 1]]) {\\n        continue;\\n      }\\n      worker += jobs[i_job];\\n      dfs(jobs, k, i_job + 1, workers, max(current, worker), result);\\n      worker -= jobs[i_job];\\n    }\\n  }\\n};\\n```\\n**3. Use the binary search**\\n```\\nclass Solution {\\n public:\\n  int minimumTimeRequired(vector<int> &jobs, int k) {\\n    const int n_jobs = static_cast<int>(jobs.size());\\n    if (n_jobs == k) {\\n      // assign exactly one job to one worker\\n      return *max_element(jobs.begin(), jobs.end());\\n    }\\n    \\n    sort(jobs.begin(), jobs.end(), greater<>{});\\n    int low = jobs.back();\\n    int high = accumulate(jobs.begin(), jobs.end(), 0);\\n    int workers[k];\\n    while (low < high) {\\n      const int mid = low + (high - low) / 2;\\n      memset(workers, 0, sizeof(workers));\\n      if (dfs(jobs, 0, workers, k, mid, 0)) {\\n        high = mid;\\n      } else {\\n        low = mid + 1;\\n      }\\n    }\\n    return high;\\n  }\\n  \\n private:\\n  bool dfs(const vector<int> &jobs, const int i_job, int *workers, const int k, const int bound, const int current_max) {\\n    const int n_jobs = static_cast<int>(jobs.size());\\n    if (i_job == n_jobs) {\\n      return true;\\n    }\\n    \\n    int worker_indices[k];\\n    iota(worker_indices, worker_indices + k, 0);\\n    sort(worker_indices, worker_indices + k, [workers](const int lhs, const int rhs) -> bool {\\n      return workers[lhs] < workers[rhs];\\n    });\\n    for (int i_worker = 0; i_worker < k; ++i_worker) {\\n      int &worker = workers[worker_indices[i_worker]];\\n      if (i_worker > 0 && worker == workers[worker_indices[i_worker - 1]]) {\\n        continue;\\n      }\\n      worker += jobs[i_job];\\n      const int next_max = max(current_max, worker);\\n      if (next_max <= bound && dfs(jobs, i_job + 1, workers, k, bound, next_max)) {\\n        return true;\\n      }\\n      worker -= jobs[i_job];\\n    }\\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(k * (3 ^ n_jobs))\\n * Space Complexity: O(2 ^ n_jobs)\\n * where `n_jobs` is the length of the vector `jobs`\\n */\\nclass Solution {\\n public:\\n  int minimumTimeRequired(const vector<int> &jobs, const int k) {\\n    constexpr int range = 2;\\n    const int n_jobs = static_cast<int>(jobs.size());\\n    const int job_layouts = 1 << n_jobs;\\n    \\n    uint32_t times[job_layouts];\\n    memset(times, 0, sizeof(times));\\n    for (int job = 0; job < n_jobs; ++job) {\\n      const int bound = 1 << job;\\n      for (int sub_jobs = 0; sub_jobs < bound; ++sub_jobs) {\\n        times[sub_jobs | bound] = times[sub_jobs] + jobs[job];\\n      }\\n    }\\n    \\n    /**\\n     * dp[workers][job_set] stands for the minimum possible maximum working time\\n     * of `workers` workers when jobs represented by `job_set` are assigned to\\n     * these `workers` workers\\n     */\\n    uint32_t dp[range][job_layouts];\\n    memset(dp, -1, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    for (int job_layout = 0; job_layout < job_layouts; ++job_layout) {\\n      dp[previous][job_layout] = times[job_layout];\\n    }\\n    \\n    for (int i = 1; i < k; ++i) {\\n      for (int job_layout = 0; job_layout < job_layouts; ++job_layout) {\\n        for (int sub_job = job_layout; sub_job > 0; sub_job = (sub_job - 1) & job_layout) {\\n          dp[current][job_layout] = min(dp[current][job_layout],\\n                                        max(times[sub_job], dp[previous][job_layout ^ sub_job]));\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], -1, sizeof(dp[current]));\\n    }\\n    \\n    return dp[previous][job_layouts - 1];\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  int minimumTimeRequired(vector<int> &jobs, int k) {\\n    const int n_jobs = static_cast<int>(jobs.size());\\n    if (n_jobs == k) {\\n      // assign exactly one job to one worker\\n      return *max_element(jobs.begin(), jobs.end());\\n    }\\n    \\n    sort(jobs.begin(), jobs.end(), greater<>{});   // it\\'s very important\\n    int workers[k];\\n    memset(workers, 0, sizeof(workers));\\n    int ret = numeric_limits<int>::max();\\n    dfs(jobs, k, 0, workers, 0, ret);\\n    return ret;\\n  }\\n  \\n private:\\n  void dfs(const vector<int> &jobs, const int k, const int i_job, int *workers, const int current, int &result) {\\n    if (current >= result) {\\n      return;\\n    }\\n    \\n    const int n_jobs = static_cast<int>(jobs.size());\\n    if (i_job == n_jobs) {\\n      result = current;\\n      return;\\n    }\\n    \\n    int worker_indices[k];\\n    iota(worker_indices, worker_indices + k, 0);\\n    sort(worker_indices, worker_indices + k, [workers](const int lhs, const int rhs) -> bool {\\n      return workers[lhs] < workers[rhs];\\n    });\\n    for (int i_worker = 0; i_worker < k; ++i_worker) {\\n      int &worker = workers[worker_indices[i_worker]];\\n      if (i_worker > 0 && worker == workers[worker_indices[i_worker - 1]]) {\\n        continue;\\n      }\\n      worker += jobs[i_job];\\n      dfs(jobs, k, i_job + 1, workers, max(current, worker), result);\\n      worker -= jobs[i_job];\\n    }\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  int minimumTimeRequired(vector<int> &jobs, int k) {\\n    const int n_jobs = static_cast<int>(jobs.size());\\n    if (n_jobs == k) {\\n      // assign exactly one job to one worker\\n      return *max_element(jobs.begin(), jobs.end());\\n    }\\n    \\n    sort(jobs.begin(), jobs.end(), greater<>{});\\n    int low = jobs.back();\\n    int high = accumulate(jobs.begin(), jobs.end(), 0);\\n    int workers[k];\\n    while (low < high) {\\n      const int mid = low + (high - low) / 2;\\n      memset(workers, 0, sizeof(workers));\\n      if (dfs(jobs, 0, workers, k, mid, 0)) {\\n        high = mid;\\n      } else {\\n        low = mid + 1;\\n      }\\n    }\\n    return high;\\n  }\\n  \\n private:\\n  bool dfs(const vector<int> &jobs, const int i_job, int *workers, const int k, const int bound, const int current_max) {\\n    const int n_jobs = static_cast<int>(jobs.size());\\n    if (i_job == n_jobs) {\\n      return true;\\n    }\\n    \\n    int worker_indices[k];\\n    iota(worker_indices, worker_indices + k, 0);\\n    sort(worker_indices, worker_indices + k, [workers](const int lhs, const int rhs) -> bool {\\n      return workers[lhs] < workers[rhs];\\n    });\\n    for (int i_worker = 0; i_worker < k; ++i_worker) {\\n      int &worker = workers[worker_indices[i_worker]];\\n      if (i_worker > 0 && worker == workers[worker_indices[i_worker - 1]]) {\\n        continue;\\n      }\\n      worker += jobs[i_job];\\n      const int next_max = max(current_max, worker);\\n      if (next_max <= bound && dfs(jobs, i_job + 1, workers, k, bound, next_max)) {\\n        return true;\\n      }\\n      worker -= jobs[i_job];\\n    }\\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725689,
                "title": "beats-100-solution-using-binary-search-backtracing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool is(int ind,vector <int> &jobs,vector <int> &workers,int mid)\\n{\\n    if(ind==jobs.size()) return true;\\n\\n    for(int i=0;i<workers.size();i++)\\n    {\\n        if(workers[i]>=jobs[ind])\\n        {\\n            workers[i]-=jobs[ind];\\n            if(is(ind+1,jobs,workers,mid))\\n            return true;\\n            workers[i]+=jobs[ind];\\n        }\\n       if(workers[i]==mid) return false;\\n    }\\n    return false;\\n}\\nbool check(int mid,vector <int> &jobs,int k)\\n{\\n    vector <int> workers(k,mid);\\n    return is(0,jobs,workers,mid);\\n}\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(jobs.begin(),jobs.end(),greater<int>());\\n        int low = 0,high = 1e9;\\n        while(low<=high)\\n        {\\n            int mid = (low+high)>>1;\\n            if(check(mid,jobs,k)) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool is(int ind,vector <int> &jobs,vector <int> &workers,int mid)\\n{\\n    if(ind==jobs.size()) return true;\\n\\n    for(int i=0;i<workers.size();i++)\\n    {\\n        if(workers[i]>=jobs[ind])\\n        {\\n            workers[i]-=jobs[ind];\\n            if(is(ind+1,jobs,workers,mid))\\n            return true;\\n            workers[i]+=jobs[ind];\\n        }\\n       if(workers[i]==mid) return false;\\n    }\\n    return false;\\n}\\nbool check(int mid,vector <int> &jobs,int k)\\n{\\n    vector <int> workers(k,mid);\\n    return is(0,jobs,workers,mid);\\n}\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(jobs.begin(),jobs.end(),greater<int>());\\n        int low = 0,high = 1e9;\\n        while(low<=high)\\n        {\\n            int mid = (low+high)>>1;\\n            if(check(mid,jobs,k)) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711437,
                "title": "python-beats-100-runtime-and-memory",
                "content": "![image.png](https://assets.leetcode.com/users/images/4de8f0de-c038-47cd-84d3-192e16700b89_1688366758.3590784.png)\\n\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumTimeRequired(self, jobs, k):\\n        \"\"\"\\n        :type jobs: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if(k == 1):\\n            return sum(jobs)\\n        jobs.sort(reverse=True)\\n        start = 1\\n        end = sum(jobs)\\n        \\n        while(start < end):\\n            st = [0]*k\\n            mid = start + (end - start)/2\\n            if(self.dfs(jobs, k, 0, st, mid)):\\n                end = mid\\n            else:\\n                start = mid + 1\\n        \\n        return start\\n\\n\\n\\n\\n    def dfs(self, jobs, k, curr, st, limit):\\n        if(curr == len(jobs)):\\n            return True\\n        else:\\n            flag = 0 \\n            for i in range(0, k):\\n                if(st[i] == 0):\\n                    if(flag):\\n                        continue\\n                    flag = 1\\n                    \\n                if(st[i] + jobs[curr] > limit):\\n                    continue\\n                st[i] += jobs[curr]\\n                if(self.dfs(jobs, k, curr+1, st, limit)):\\n                    return True\\n                st[i] -= jobs[curr]    \\n            \\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumTimeRequired(self, jobs, k):\\n        \"\"\"\\n        :type jobs: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if(k == 1):\\n            return sum(jobs)\\n        jobs.sort(reverse=True)\\n        start = 1\\n        end = sum(jobs)\\n        \\n        while(start < end):\\n            st = [0]*k\\n            mid = start + (end - start)/2\\n            if(self.dfs(jobs, k, 0, st, mid)):\\n                end = mid\\n            else:\\n                start = mid + 1\\n        \\n        return start\\n\\n\\n\\n\\n    def dfs(self, jobs, k, curr, st, limit):\\n        if(curr == len(jobs)):\\n            return True\\n        else:\\n            flag = 0 \\n            for i in range(0, k):\\n                if(st[i] == 0):\\n                    if(flag):\\n                        continue\\n                    flag = 1\\n                    \\n                if(st[i] + jobs[curr] > limit):\\n                    continue\\n                st[i] += jobs[curr]\\n                if(self.dfs(jobs, k, curr+1, st, limit)):\\n                    return True\\n                st[i] -= jobs[curr]    \\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705432,
                "title": "c-solution-0ms-solution-beats-100-both-time-and-space-complexity",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void backtracking(vector<int>& jobs, int num, int& ans, int k, vector<int>& count){\\n        if(num == jobs.size()){\\n            int maxi = *max_element(count.begin(), count.end());\\n            ans = min(ans, maxi);\\n            return;\\n        }\\n        if(*max_element(count.begin(), count.end()) >= ans) return;\\n\\n        for(int i = 0 ; i < k ; i++){\\n            count[i] += jobs[num];\\n            backtracking(jobs, num+1, ans, k, count);\\n            count[i] -= jobs[num];\\n            if(count[i] == 0) break;\\n        }\\n    }\\n\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(jobs.begin(), jobs.end(), greater<int>());\\n        int ans = INT_MAX;\\n        vector<int> count(k);\\n\\n        backtracking(jobs, 0, ans, k, count);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void backtracking(vector<int>& jobs, int num, int& ans, int k, vector<int>& count){\\n        if(num == jobs.size()){\\n            int maxi = *max_element(count.begin(), count.end());\\n            ans = min(ans, maxi);\\n            return;\\n        }\\n        if(*max_element(count.begin(), count.end()) >= ans) return;\\n\\n        for(int i = 0 ; i < k ; i++){\\n            count[i] += jobs[num];\\n            backtracking(jobs, num+1, ans, k, count);\\n            count[i] -= jobs[num];\\n            if(count[i] == 0) break;\\n        }\\n    }\\n\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(jobs.begin(), jobs.end(), greater<int>());\\n        int ans = INT_MAX;\\n        vector<int> count(k);\\n\\n        backtracking(jobs, 0, ans, k, count);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703754,
                "title": "c-simple-solution-using-backtracking",
                "content": "# Complexity\\n- Time complexity: \\n \\n1. Sorting the jobs vector takes O(n log n) time, where n is the number of jobs.\\n2. The solve function is called recursively for each possible assignment of jobs to workers. In the worst case, each job can be assigned to any worker, resulting in k^n possible combinations. Therefore, the time complexity of the solve function is O(k^n).\\n3. Inside the solve function, finding the maximum element in the v vector takes O(k) time.\\nOverall, the time complexity of the code is O(n log n + k^n).\\n\\n\\n- Space complexity:\\n\\n1. The solve function uses recursion, which requires additional space on the call stack. The maximum depth of the recursion is equal to the number of jobs, n. Therefore, the space complexity of the solve function is O(n).\\n2. The v vector has a size of k and is used to represent the current assignment of jobs to workers. Therefore, the space complexity of the v vector is O(k).\\nOverall, the space complexity of the code is O(n + k).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint ans=INT_MAX;\\nvoid solve(vector<int>&c,vector<int>&v,int i){\\n    if(i==c.size()){\\n        int temp=*max_element(v.begin(),v.end());\\n        ans=min(ans,temp);\\n        return;\\n    }\\n    if(*max_element(v.begin(),v.end())>=ans)return;\\n    //If array contains any number greater than ans then it can\\'t contribute to answer\\n    for(int j=0;j<v.size();j++){\\n        if(j>0 && v[j]>=v[j-1])continue;\\n    //If v[j]>=v[j-1] then it is not optimal to add in already greater value\\n        v[j]+=c[i];\\n        solve(c,v,i+1);\\n        v[j]-=c[i];\\n    }\\n}\\n   \\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int>v(k);\\n        sort(jobs.rbegin(),jobs.rend());\\n        solve(jobs,v,0);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans=INT_MAX;\\nvoid solve(vector<int>&c,vector<int>&v,int i){\\n    if(i==c.size()){\\n        int temp=*max_element(v.begin(),v.end());\\n        ans=min(ans,temp);\\n        return;\\n    }\\n    if(*max_element(v.begin(),v.end())>=ans)return;\\n    //If array contains any number greater than ans then it can\\'t contribute to answer\\n    for(int j=0;j<v.size();j++){\\n        if(j>0 && v[j]>=v[j-1])continue;\\n    //If v[j]>=v[j-1] then it is not optimal to add in already greater value\\n        v[j]+=c[i];\\n        solve(c,v,i+1);\\n        v[j]-=c[i];\\n    }\\n}\\n   \\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int>v(k);\\n        sort(jobs.rbegin(),jobs.rend());\\n        solve(jobs,v,0);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703603,
                "title": "find-minimum-time-to-finish-all-jobs-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nk^(cookies.size())\\n\\n- Space complexity:\\no(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long ans=INT_MAX;\\n    void fun(int index,vector<int>&jobs, vector<int>&dp,int k){\\n     \\n     if(index>=jobs.size())///able\\n     {\\n         long long temp=*max_element(dp.begin(),dp.end());\\n         if(temp<ans)ans=temp;\\n         return;\\n     }\\n\\n     for(int i=0;i<k;i++){\\n         if(i>0 && dp[i]>=dp[i-1])\\n            {continue;}///important condition\\n         dp[i]=dp[i]+jobs[index];\\n         fun(index+1,jobs,dp,k);\\n         dp[i]=dp[i]-jobs[index];\\n     }\\n\\n\\n    }\\n    \\n    \\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        \\n        int index=0;\\n        vector<int>dp(k,0);\\n        sort(jobs.begin() , jobs.end() , greater<int>());\\n        fun(index,jobs,dp,k);\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long ans=INT_MAX;\\n    void fun(int index,vector<int>&jobs, vector<int>&dp,int k){\\n     \\n     if(index>=jobs.size())///able\\n     {\\n         long long temp=*max_element(dp.begin(),dp.end());\\n         if(temp<ans)ans=temp;\\n         return;\\n     }\\n\\n     for(int i=0;i<k;i++){\\n         if(i>0 && dp[i]>=dp[i-1])\\n            {continue;}///important condition\\n         dp[i]=dp[i]+jobs[index];\\n         fun(index+1,jobs,dp,k);\\n         dp[i]=dp[i]-jobs[index];\\n     }\\n\\n\\n    }\\n    \\n    \\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        \\n        int index=0;\\n        vector<int>dp(k,0);\\n        sort(jobs.begin() , jobs.end() , greater<int>());\\n        fun(index,jobs,dp,k);\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698663,
                "title": "begineers-friendly-c-easy-to-understand",
                "content": "\\n# CODE\\n```\\nclass Solution {\\npublic:\\n    void solve(int i, int &ans, int k, vector<int> &temp, vector<int> &jobs){\\n        if(i == temp.size()){\\n            ans = min(ans, *max_element(temp.begin(), temp.end()));\\n            return;\\n        }\\n\\n        if(*max_element(temp.begin(), temp.end()) >= ans)\\n        return;\\n\\n        for(int j = 0; j < k; j++){\\n\\n            if(j > 0 && temp[j] == temp[j-1])\\n            continue;\\n\\n            temp[j] += jobs[i];\\n            solve(i+1, ans, k, temp, jobs);\\n            temp[j] -= jobs[i];\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size();\\n        vector<int> temp(n, 0);\\n        int ans = INT_MAX;\\n\\n        solve(0, ans, k, temp, jobs);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i, int &ans, int k, vector<int> &temp, vector<int> &jobs){\\n        if(i == temp.size()){\\n            ans = min(ans, *max_element(temp.begin(), temp.end()));\\n            return;\\n        }\\n\\n        if(*max_element(temp.begin(), temp.end()) >= ans)\\n        return;\\n\\n        for(int j = 0; j < k; j++){\\n\\n            if(j > 0 && temp[j] == temp[j-1])\\n            continue;\\n\\n            temp[j] += jobs[i];\\n            solve(i+1, ans, k, temp, jobs);\\n            temp[j] -= jobs[i];\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size();\\n        vector<int> temp(n, 0);\\n        int ans = INT_MAX;\\n\\n        solve(0, ans, k, temp, jobs);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616621,
                "title": "greedy-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll ans;\\n    ll helper(vector<int> &A,vector<ll> &workers,ll k,ll p,ll curr){\\n        if(curr>ans)\\n         return ans;\\n        if(p==A.size())\\n         return ans = curr;\\n        unordered_set<ll> seen;\\n        for(int i=0;i<k;i++){\\n            if(seen.find(workers[i])!=seen.end()) continue;\\n            seen.insert(workers[i]);\\n            workers[i]+=A[p];\\n            helper(A,workers,k,p+1,max(curr,workers[i]));\\n            workers[i]-=A[p];\\n        }\\n        return ans;\\n\\n    }\\n    ll minimumTimeRequired(vector<int>& jobs, ll k) {\\n        if(k==jobs.size())\\n           return *max_element(jobs.begin(),jobs.end());\\n        ans = LLONG_MAX;\\n        vector<ll> workers(k,0);\\n        sort(jobs.begin(),jobs.end(),greater<int>());\\n        return helper(jobs,workers,k,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll ans;\\n    ll helper(vector<int> &A,vector<ll> &workers,ll k,ll p,ll curr){\\n        if(curr>ans)\\n         return ans;\\n        if(p==A.size())\\n         return ans = curr;\\n        unordered_set<ll> seen;\\n        for(int i=0;i<k;i++){\\n            if(seen.find(workers[i])!=seen.end()) continue;\\n            seen.insert(workers[i]);\\n            workers[i]+=A[p];\\n            helper(A,workers,k,p+1,max(curr,workers[i]));\\n            workers[i]-=A[p];\\n        }\\n        return ans;\\n\\n    }\\n    ll minimumTimeRequired(vector<int>& jobs, ll k) {\\n        if(k==jobs.size())\\n           return *max_element(jobs.begin(),jobs.end());\\n        ans = LLONG_MAX;\\n        vector<ll> workers(k,0);\\n        sort(jobs.begin(),jobs.end(),greater<int>());\\n        return helper(jobs,workers,k,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578406,
                "title": "java-easy-solution-using-binarysearch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic int minimumTimeRequired(int[] jobs, int k) {\\n    int left = 0;\\n    int right = 0;\\n    for (int job : jobs) {\\n        left = Math.max(left, job);\\n        right += job;\\n    }\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n        if (isPossible(jobs, k, mid)) {\\n            right = mid;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n\\n    return left;\\n}\\n\\nprivate boolean isPossible(int[] jobs, int k, int maxTime) {\\n    int[] workers = new int[k];\\n    return backtrack(jobs, workers, 0, maxTime);\\n}\\n\\nprivate boolean backtrack(int[] jobs, int[] workers, int index, int maxTime) {\\n    if (index == jobs.length) {\\n        return true;\\n    }\\n\\n    for (int i = 0; i < workers.length; i++) {\\n        if (workers[i] + jobs[index] <= maxTime) {\\n            workers[i] += jobs[index];\\n            if (backtrack(jobs, workers, index + 1, maxTime)) {\\n                return true;\\n            }\\n            workers[i] -= jobs[index];\\n        }\\n\\n        if (workers[i] == 0 || workers[i] + jobs[index] == maxTime) {\\n            break;\\n        }\\n    }\\n\\n    return false;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int minimumTimeRequired(int[] jobs, int k) {\\n    int left = 0;\\n    int right = 0;\\n    for (int job : jobs) {\\n        left = Math.max(left, job);\\n        right += job;\\n    }\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n        if (isPossible(jobs, k, mid)) {\\n            right = mid;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n\\n    return left;\\n}\\n\\nprivate boolean isPossible(int[] jobs, int k, int maxTime) {\\n    int[] workers = new int[k];\\n    return backtrack(jobs, workers, 0, maxTime);\\n}\\n\\nprivate boolean backtrack(int[] jobs, int[] workers, int index, int maxTime) {\\n    if (index == jobs.length) {\\n        return true;\\n    }\\n\\n    for (int i = 0; i < workers.length; i++) {\\n        if (workers[i] + jobs[index] <= maxTime) {\\n            workers[i] += jobs[index];\\n            if (backtrack(jobs, workers, index + 1, maxTime)) {\\n                return true;\\n            }\\n            workers[i] -= jobs[index];\\n        }\\n\\n        if (workers[i] == 0 || workers[i] + jobs[index] == maxTime) {\\n            break;\\n        }\\n    }\\n\\n    return false;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521729,
                "title": "backtrack-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        jobs.sort(reverse=True)\\n        def backtrack(i, curr_time):\\n            nonlocal ans\\n            if curr_time >= ans:\\n                return ans\\n\\n            if i == len(jobs):\\n                ans = min(curr_time, ans)\\n                return\\n            \\n            for j in range(k):\\n                if j > 0 and t[j] == t[j - 1]:\\n                    continue\\n                t[j] += jobs[i]\\n                backtrack(i + 1, max(curr_time, t[j]))\\n                t[j] -= jobs[i]\\n\\n        t = [0] * k\\n        ans = float(\\'inf\\')\\n        backtrack(0, 0)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        jobs.sort(reverse=True)\\n        def backtrack(i, curr_time):\\n            nonlocal ans\\n            if curr_time >= ans:\\n                return ans\\n\\n            if i == len(jobs):\\n                ans = min(curr_time, ans)\\n                return\\n            \\n            for j in range(k):\\n                if j > 0 and t[j] == t[j - 1]:\\n                    continue\\n                t[j] += jobs[i]\\n                backtrack(i + 1, max(curr_time, t[j]))\\n                t[j] -= jobs[i]\\n\\n        t = [0] * k\\n        ans = float(\\'inf\\')\\n        backtrack(0, 0)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333353,
                "title": "backtracking-solution-with-optimisation-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    int ans = Integer.MAX_VALUE;\\n\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int n = jobs.length;\\n        int[] works = new int[n];\\n\\n        //sorting in descending order\\n        for (int i = 0; i < jobs.length; i++) {     \\n            for (int j = i+1; j < jobs.length; j++) {     \\n               if(jobs[i] < jobs[j]) {    \\n                   int temp = jobs[i];    \\n                   jobs[i] = jobs[j];    \\n                   jobs[j] = temp;    \\n               }     \\n            }     \\n        }    \\n\\n\\n        if(n == k)\\n            return jobs[0];\\n\\n        int idx =0;\\n\\n        solve(idx, k, n, jobs, works);\\n\\n        return ans;\\n    }\\n\\n\\n    public void solve(int idx, int k,  int n, int[] jobs, int[] works)\\n    {\\n        if(idx == n)\\n        {\\n            ans = Math.min(greatest(works), ans);\\n            return;\\n        }\\n\\n        if(greatest(works)>= ans)\\n            return;\\n        \\n        for(int i = 0; i < k ; i++)\\n        {\\n            if(i>0 && works[i] == works[i-1])\\n                continue;\\n\\n            works[i] += jobs[idx];\\n            solve(idx+1,k,n,jobs,works);\\n            works[i] -= jobs[idx];\\n        }\\n    }\\n\\n    //To find greatest element in an array\\n    public int greatest(int[] arr)\\n    {\\n        int i;\\n        int max = arr[0];\\n         \\n        for (i = 1; i < arr.length; i++)\\n            if (arr[i] > max)\\n                max = arr[i];\\n         \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int ans = Integer.MAX_VALUE;\\n\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int n = jobs.length;\\n        int[] works = new int[n];\\n\\n        //sorting in descending order\\n        for (int i = 0; i < jobs.length; i++) {     \\n            for (int j = i+1; j < jobs.length; j++) {     \\n               if(jobs[i] < jobs[j]) {    \\n                   int temp = jobs[i];    \\n                   jobs[i] = jobs[j];    \\n                   jobs[j] = temp;    \\n               }     \\n            }     \\n        }    \\n\\n\\n        if(n == k)\\n            return jobs[0];\\n\\n        int idx =0;\\n\\n        solve(idx, k, n, jobs, works);\\n\\n        return ans;\\n    }\\n\\n\\n    public void solve(int idx, int k,  int n, int[] jobs, int[] works)\\n    {\\n        if(idx == n)\\n        {\\n            ans = Math.min(greatest(works), ans);\\n            return;\\n        }\\n\\n        if(greatest(works)>= ans)\\n            return;\\n        \\n        for(int i = 0; i < k ; i++)\\n        {\\n            if(i>0 && works[i] == works[i-1])\\n                continue;\\n\\n            works[i] += jobs[idx];\\n            solve(idx+1,k,n,jobs,works);\\n            works[i] -= jobs[idx];\\n        }\\n    }\\n\\n    //To find greatest element in an array\\n    public int greatest(int[] arr)\\n    {\\n        int i;\\n        int max = arr[0];\\n         \\n        for (i = 1; i < arr.length; i++)\\n            if (arr[i] > max)\\n                max = arr[i];\\n         \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328598,
                "title": "backtracking-with-easy-explaination",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    long long ans = INT_MAX;\\n    void fun(vector<int>& jobs,vector<long long>& dp,int i,int k)\\n    {\\n        if(i == jobs.size() )\\n        {\\n        \\n            long long current = 0, check = 1;\\n            for(auto x : dp)\\n            {\\n                if(x == 0)\\n                {\\n                    // checking if this partition is valid\\n                    // if any worker gets 0 job time then its not valid.\\n                    check = 0;\\n                    break ;\\n\\n                }\\n                else\\n              {\\n                     current = max( current,x);\\n              }\\n            }\\n\\n            if(check)\\n            {\\n                ans = min(ans, current);\\n            }\\n\\n            return ;\\n\\n        }\\n        long long y = 0;\\n        for(int j=0;j<k;j++)\\n        {\\n            if(dp[j]+jobs[i] > ans)\\n            {\\n                continue;\\n            }\\n            if(j>0 and dp[j] == dp[j-1])\\n            {\\n               // optimization for the distribution x,y,z, 0(j-1) , 0(j), a,b,c ;\\n               // becoz this case have to be rejected \\n                continue;\\n            }\\n            dp[j] += jobs[i];\\n            \\n            fun(jobs,dp,i+1,k);\\n            dp[j] -= jobs[i];\\n            \\n        }\\n    }\\n\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<long long> dp(k,0);\\n        fun(jobs,dp,0,k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    long long ans = INT_MAX;\\n    void fun(vector<int>& jobs,vector<long long>& dp,int i,int k)\\n    {\\n        if(i == jobs.size() )\\n        {\\n        \\n            long long current = 0, check = 1;\\n            for(auto x : dp)\\n            {\\n                if(x == 0)\\n                {\\n                    // checking if this partition is valid\\n                    // if any worker gets 0 job time then its not valid.\\n                    check = 0;\\n                    break ;\\n\\n                }\\n                else\\n              {\\n                     current = max( current,x);\\n              }\\n            }\\n\\n            if(check)\\n            {\\n                ans = min(ans, current);\\n            }\\n\\n            return ;\\n\\n        }\\n        long long y = 0;\\n        for(int j=0;j<k;j++)\\n        {\\n            if(dp[j]+jobs[i] > ans)\\n            {\\n                continue;\\n            }\\n            if(j>0 and dp[j] == dp[j-1])\\n            {\\n               // optimization for the distribution x,y,z, 0(j-1) , 0(j), a,b,c ;\\n               // becoz this case have to be rejected \\n                continue;\\n            }\\n            dp[j] += jobs[i];\\n            \\n            fun(jobs,dp,i+1,k);\\n            dp[j] -= jobs[i];\\n            \\n        }\\n    }\\n\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<long long> dp(k,0);\\n        fun(jobs,dp,0,k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289876,
                "title": "bitmask-dp-and-subset-sum-o-k-3-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n    int n=jobs.size();\\n    vector<int>subset(1<<n);\\n\\n    for(int mask=0;mask<(1<<n);mask++)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mask&(1<<i))\\n            {\\n                subset[mask]+=jobs[i];\\n            }\\n        }\\n    }\\n    int inf=1e9;\\n    vector<vector<int>>dp(k+1,vector<int>(1<<n,inf));\\n\\n    // dp[i][mask] -> answer for this mask for i people\\n\\n    // dp[i][mask] ->min of dp[i][mask]  , max(subset[submask] , dp[i-1][mask^submask])\\n    // for each mask , we are extracting the answer from its submask\\n    dp[0][0]=0;\\n\\n\\n\\n    for(int i=1;i<=k;i++)\\n    {\\n        for(int mask=1;mask<(1<<n);mask++)\\n        {\\n            int submask=mask;\\n            for(submask;submask>0;submask=(submask-1)&mask)\\n            {\\n                dp[i][mask]=min(dp[i][mask],max(subset[submask],dp[i-1][mask^submask]));\\n            }\\n        }\\n    }\\n\\n    return dp[k][(1<<n)-1];\\n\\n    }\\n};\\n```\\n# Code Space optimized\\n```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n    int n=jobs.size();\\n    vector<int>subset(1<<n);\\n\\n    for(int mask=0;mask<(1<<n);mask++)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mask&(1<<i))\\n            {\\n                subset[mask]+=jobs[i];\\n            }\\n        }\\n    }\\n    int inf=1e9;\\n    vector<int>prev(1<<n,inf);\\n    // vector<vector<int>>dp(k+1,vector<int>(1<<n,inf));\\n\\n    // dp[i][mask] -> answer for this mask for i people\\n\\n    // dp[i][mask] ->min of dp[i][mask]  max(subset[submask] , dp[i-1][mask^submask])\\n\\n    prev[0]=0;\\n\\n\\n    for(int i=1;i<=k;i++)\\n    {\\n        vector<int>curr(1<<n,inf);\\n        for(int mask=1;mask<(1<<n);mask++)\\n        {\\n            int submask=mask;\\n            for(submask;submask>0;submask=(submask-1)&mask)\\n            {\\n                curr[mask]=min(curr[mask],max(subset[submask],prev[mask^submask]));\\n            }\\n        }\\n        prev=curr;\\n    }\\n\\n    return prev[(1<<n)-1];\\n\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n    int n=jobs.size();\\n    vector<int>subset(1<<n);\\n\\n    for(int mask=0;mask<(1<<n);mask++)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mask&(1<<i))\\n            {\\n                subset[mask]+=jobs[i];\\n            }\\n        }\\n    }\\n    int inf=1e9;\\n    vector<vector<int>>dp(k+1,vector<int>(1<<n,inf));\\n\\n    // dp[i][mask] -> answer for this mask for i people\\n\\n    // dp[i][mask] ->min of dp[i][mask]  , max(subset[submask] , dp[i-1][mask^submask])\\n    // for each mask , we are extracting the answer from its submask\\n    dp[0][0]=0;\\n\\n\\n\\n    for(int i=1;i<=k;i++)\\n    {\\n        for(int mask=1;mask<(1<<n);mask++)\\n        {\\n            int submask=mask;\\n            for(submask;submask>0;submask=(submask-1)&mask)\\n            {\\n                dp[i][mask]=min(dp[i][mask],max(subset[submask],dp[i-1][mask^submask]));\\n            }\\n        }\\n    }\\n\\n    return dp[k][(1<<n)-1];\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n    int n=jobs.size();\\n    vector<int>subset(1<<n);\\n\\n    for(int mask=0;mask<(1<<n);mask++)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mask&(1<<i))\\n            {\\n                subset[mask]+=jobs[i];\\n            }\\n        }\\n    }\\n    int inf=1e9;\\n    vector<int>prev(1<<n,inf);\\n    // vector<vector<int>>dp(k+1,vector<int>(1<<n,inf));\\n\\n    // dp[i][mask] -> answer for this mask for i people\\n\\n    // dp[i][mask] ->min of dp[i][mask]  max(subset[submask] , dp[i-1][mask^submask])\\n\\n    prev[0]=0;\\n\\n\\n    for(int i=1;i<=k;i++)\\n    {\\n        vector<int>curr(1<<n,inf);\\n        for(int mask=1;mask<(1<<n);mask++)\\n        {\\n            int submask=mask;\\n            for(submask;submask>0;submask=(submask-1)&mask)\\n            {\\n                curr[mask]=min(curr[mask],max(subset[submask],prev[mask^submask]));\\n            }\\n        }\\n        prev=curr;\\n    }\\n\\n    return prev[(1<<n)-1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249888,
                "title": "c-easiest-solution-using-recursion-and-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int k,vector<int>&jobs , vector<int>&work,int &ans,int n){\\n        //base case\\n        if(i==n){\\n            ans = min(*max_element(work.begin(),work.end()),ans);\\n            return;\\n        }\\n\\n        for(int j = 0;j<k;j++){\\n            //optimization\\n            if(j>0 && work[j]==work[j-1]){\\n                continue;\\n            }\\n            //action\\n            work[j]  = work[j]+jobs[i];\\n\\n            //recursive call\\n            solve(i+1,k,jobs,work,ans,n);\\n\\n            //backtrack\\n\\n            work[j] = work[j]-jobs[i];\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int index = 0;\\n        sort(jobs.begin(),jobs.end(),greater<int>());\\n        //make a vector for worker\\n        vector<int>work(k,0);\\n        int ans = INT_MAX;\\n        int n = jobs.size();\\n        if(n==k){\\n            return jobs[0];\\n        }\\n        solve(index,k,jobs,work,ans,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int k,vector<int>&jobs , vector<int>&work,int &ans,int n){\\n        //base case\\n        if(i==n){\\n            ans = min(*max_element(work.begin(),work.end()),ans);\\n            return;\\n        }\\n\\n        for(int j = 0;j<k;j++){\\n            //optimization\\n            if(j>0 && work[j]==work[j-1]){\\n                continue;\\n            }\\n            //action\\n            work[j]  = work[j]+jobs[i];\\n\\n            //recursive call\\n            solve(i+1,k,jobs,work,ans,n);\\n\\n            //backtrack\\n\\n            work[j] = work[j]-jobs[i];\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int index = 0;\\n        sort(jobs.begin(),jobs.end(),greater<int>());\\n        //make a vector for worker\\n        vector<int>work(k,0);\\n        int ans = INT_MAX;\\n        int n = jobs.size();\\n        if(n==k){\\n            return jobs[0];\\n        }\\n        solve(index,k,jobs,work,ans,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199728,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_time_required(jobs: Vec<i32>, k: i32) -> i32 {\\n        fn check(jobs: &[i32], k: i32, limit: i32) -> bool {\\n            let mut workloads = vec![0; k as usize];\\n            backtrack(jobs, &mut workloads, 0, limit)\\n        }\\n\\n        fn backtrack(jobs: &[i32], workloads: &mut [i32], i: usize, limit: i32) -> bool {\\n            if i >= jobs.len() {\\n                return true;\\n            }\\n            let cur = jobs[i];\\n            for j in 0..workloads.len() {\\n                if workloads[j] + cur <= limit {\\n                    workloads[j] += cur;\\n                    if backtrack(jobs, workloads, i + 1, limit) {\\n                        return true;\\n                    }\\n                    workloads[j] -= cur;\\n                }\\n                if workloads[j] == 0 || workloads[j] + cur == limit {\\n                    break;\\n                }\\n            }\\n            false\\n        }\\n\\n        let mut jobs = jobs;\\n        jobs.sort();\\n        let mut left = jobs.iter().sum::<i32>() / k;\\n        let mut right = jobs.iter().sum::<i32>();\\n        while left < right {\\n            let mid = (left + right) / 2;\\n            if check(&jobs, k, mid) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_time_required(jobs: Vec<i32>, k: i32) -> i32 {\\n        fn check(jobs: &[i32], k: i32, limit: i32) -> bool {\\n            let mut workloads = vec![0; k as usize];\\n            backtrack(jobs, &mut workloads, 0, limit)\\n        }\\n\\n        fn backtrack(jobs: &[i32], workloads: &mut [i32], i: usize, limit: i32) -> bool {\\n            if i >= jobs.len() {\\n                return true;\\n            }\\n            let cur = jobs[i];\\n            for j in 0..workloads.len() {\\n                if workloads[j] + cur <= limit {\\n                    workloads[j] += cur;\\n                    if backtrack(jobs, workloads, i + 1, limit) {\\n                        return true;\\n                    }\\n                    workloads[j] -= cur;\\n                }\\n                if workloads[j] == 0 || workloads[j] + cur == limit {\\n                    break;\\n                }\\n            }\\n            false\\n        }\\n\\n        let mut jobs = jobs;\\n        jobs.sort();\\n        let mut left = jobs.iter().sum::<i32>() / k;\\n        let mut right = jobs.iter().sum::<i32>();\\n        while left < right {\\n            let mid = (left + right) / 2;\\n            if check(&jobs, k, mid) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        left\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2851286,
                "title": "python-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs, k):\\n        if k == len(jobs):\\n            return max(jobs)\\n    \\n        self.min_val = float(\"inf\")\\n\\n        def backtrack(idx,ans):\\n            if idx == len(jobs):\\n                self.min_val = min(self.min_val,max(ans))\\n                return\\n\\n            seen = set()\\n\\n            for i in range(k):\\n                if ans[i] in seen: continue\\n                if ans[i] + jobs[idx] >= self.min_val: continue\\n                seen.add(ans[i])\\n\\n                ans[i] += jobs[idx]\\n                backtrack(idx+1,ans)\\n                ans[i] -= jobs[idx]\\n\\n        backtrack(0,[0]*k)\\n\\n        return self.min_val\\n\\n        \\n\\n        \\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs, k):\\n        if k == len(jobs):\\n            return max(jobs)\\n    \\n        self.min_val = float(\"inf\")\\n\\n        def backtrack(idx,ans):\\n            if idx == len(jobs):\\n                self.min_val = min(self.min_val,max(ans))\\n                return\\n\\n            seen = set()\\n\\n            for i in range(k):\\n                if ans[i] in seen: continue\\n                if ans[i] + jobs[idx] >= self.min_val: continue\\n                seen.add(ans[i])\\n\\n                ans[i] += jobs[idx]\\n                backtrack(idx+1,ans)\\n                ans[i] -= jobs[idx]\\n\\n        backtrack(0,[0]*k)\\n\\n        return self.min_val\\n\\n        \\n\\n        \\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805105,
                "title": "java-backtrack-detailed-comments",
                "content": "```\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        // sort in descending order\\n        // https://stackoverflow.com/questions/1694751/java-array-sort-descending\\n        sortArrayInDesc(jobs);\\n        \\n        int jobCnt = jobs.length;\\n        if (jobCnt == k) {\\n            return jobs[0];\\n        }\\n        \\n        int[] res = new int[] {Integer.MAX_VALUE};\\n        \\n        // key: worker index\\n        // value: the total time of jobs assigned to worker i\\n        int[] workerToTime = new int[k];\\n        \\n        Map<Integer, Set<Integer>> workerToJobs = new HashMap<>();\\n        for (int i = 0; i < k; i++) {\\n            workerToJobs.put(i, new HashSet<>());\\n        }\\n        \\n        backtrack(0, 0, workerToTime, jobs, k, res);\\n        \\n        return res[0];\\n    }\\n    \\n    private void backtrack(int jobIndex, int workerIndex, int[] workerToTime, int[] jobs, int k, int[] res) {\\n        int jobCnt = jobs.length;\\n        \\n        // if all jobs are done\\n        if (jobIndex == jobCnt) {\\n            // find the maximum value among workerToTime\\n            int maxWorkTime = 0;\\n            for (int time : workerToTime) {\\n                maxWorkTime = Math.max(maxWorkTime, time);\\n            }\\n            res[0] = Math.min(maxWorkTime, res[0]);\\n            return;\\n        }\\n        \\n        // if not all jobs are done, assign job to workers\\n        int maxWorkTime = 0;\\n        \\n        // prune\\n        // if the current total working time workerToTime[i]\\n        // for some woker i is already graeter than res[0],\\n        // stop here\\n        for (int time : workerToTime) {\\n            maxWorkTime = Math.max(maxWorkTime, time);\\n            if (maxWorkTime > res[0]) {\\n                return;\\n            }\\n        }\\n        \\n        for (int i = 0; i < k; i++) {\\n            int curJob = jobs[jobIndex];\\n            \\n            // prune\\n            // if the previous worker has exactly the same amount of time as the current\\'s,\\n            // it indicates that the following search process will be the same for him,\\n            // so no need to start the search from current worker again\\n            if (i > 0 && workerToTime[i] == workerToTime[i - 1]) {\\n                // System.out.println(\"pruning...\");\\n                continue;\\n            }\\n            \\n            // assign current job to worker i\\n            workerToTime[i] += curJob;\\n            backtrack(jobIndex + 1, workerIndex + 1, workerToTime, jobs, k, res);\\n            workerToTime[i] -= curJob;\\n        }\\n    }\\n    \\n    /**\\n    * Sort given integer array in descending order.\\n    */\\n    private void sortArrayInDesc(int[] arr) {\\n        Arrays.sort(arr);\\n        int len = arr.length;\\n        for (int i = 0; i < len / 2; i++) {\\n            int temp = arr[i];\\n            arr[i] = arr[len - 1 - i];\\n            arr[len - 1 - i] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        // sort in descending order\\n        // https://stackoverflow.com/questions/1694751/java-array-sort-descending\\n        sortArrayInDesc(jobs);\\n        \\n        int jobCnt = jobs.length;\\n        if (jobCnt == k) {\\n            return jobs[0];\\n        }\\n        \\n        int[] res = new int[] {Integer.MAX_VALUE};\\n        \\n        // key: worker index\\n        // value: the total time of jobs assigned to worker i\\n        int[] workerToTime = new int[k];\\n        \\n        Map<Integer, Set<Integer>> workerToJobs = new HashMap<>();\\n        for (int i = 0; i < k; i++) {\\n            workerToJobs.put(i, new HashSet<>());\\n        }\\n        \\n        backtrack(0, 0, workerToTime, jobs, k, res);\\n        \\n        return res[0];\\n    }\\n    \\n    private void backtrack(int jobIndex, int workerIndex, int[] workerToTime, int[] jobs, int k, int[] res) {\\n        int jobCnt = jobs.length;\\n        \\n        // if all jobs are done\\n        if (jobIndex == jobCnt) {\\n            // find the maximum value among workerToTime\\n            int maxWorkTime = 0;\\n            for (int time : workerToTime) {\\n                maxWorkTime = Math.max(maxWorkTime, time);\\n            }\\n            res[0] = Math.min(maxWorkTime, res[0]);\\n            return;\\n        }\\n        \\n        // if not all jobs are done, assign job to workers\\n        int maxWorkTime = 0;\\n        \\n        // prune\\n        // if the current total working time workerToTime[i]\\n        // for some woker i is already graeter than res[0],\\n        // stop here\\n        for (int time : workerToTime) {\\n            maxWorkTime = Math.max(maxWorkTime, time);\\n            if (maxWorkTime > res[0]) {\\n                return;\\n            }\\n        }\\n        \\n        for (int i = 0; i < k; i++) {\\n            int curJob = jobs[jobIndex];\\n            \\n            // prune\\n            // if the previous worker has exactly the same amount of time as the current\\'s,\\n            // it indicates that the following search process will be the same for him,\\n            // so no need to start the search from current worker again\\n            if (i > 0 && workerToTime[i] == workerToTime[i - 1]) {\\n                // System.out.println(\"pruning...\");\\n                continue;\\n            }\\n            \\n            // assign current job to worker i\\n            workerToTime[i] += curJob;\\n            backtrack(jobIndex + 1, workerIndex + 1, workerToTime, jobs, k, res);\\n            workerToTime[i] -= curJob;\\n        }\\n    }\\n    \\n    /**\\n    * Sort given integer array in descending order.\\n    */\\n    private void sortArrayInDesc(int[] arr) {\\n        Arrays.sort(arr);\\n        int len = arr.length;\\n        for (int i = 0; i < len / 2; i++) {\\n            int temp = arr[i];\\n            arr[i] = arr[len - 1 - i];\\n            arr[len - 1 - i] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790907,
                "title": "dfs-use-greedy-to-cut-off-bad-branch-ac-but-tle-with-custom-test",
                "content": "I did a trick with k = n and k = n-1, then manage to pass some big test. But still, my main implementation got flaw and TLE.\\nMy approach is traverse all possibility with DFS, cut off some branch that can not lead to better result. Not sure why it\\'s TLE. Any guidance is much appreciated.\\n```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        // AC but still bad implementation, TLE with this test\\n        // [10001,10002,10003,10004,10005,10006,10007,10008,10009,10010,10011,1000000]\\n        // 10\\n        int n = jobs.size();\\n        if(k == n) {\\n            return *max_element(jobs.begin(), jobs.end());\\n        }\\n        if(k == n-1) {\\n            sort(jobs.begin(), jobs.end());\\n            int min_pair = jobs[0] + jobs[1];\\n            int max_job = jobs[n-1];\\n            return max(min_pair, max_job);\\n        }\\n        typedef pair<int, vector<int>> state;\\n        vector<int> cost(n+1, 1e9);\\n        stack<state> q;\\n        vector<int> workers(k,0);\\n        q.emplace(0, workers);\\n        map<state, bool> vis;\\n        while(!q.empty()) {\\n            vector<int> w;\\n            int u;\\n            tie(u, w) = q.top();\\n            if(vis[q.top()]) {\\n                q.pop();\\n                continue;\\n            }\\n            vis[q.top()] = true;\\n            q.pop();\\n            int next = w[k-1];\\n            if(next >= cost[n]) {\\n                continue;\\n            }\\n            cost[u] = next;\\n            int v = u+1;\\n            if(v > n) {\\n                continue;\\n            }\\n            for(int i = w.size()-1;i>=0;i--) {\\n                vector<int> nextw = w;\\n                nextw[i] += jobs[v-1];\\n                sort(nextw.begin(), nextw.end());\\n                q.emplace(v, nextw);\\n            }\\n        }\\n        return cost[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        // AC but still bad implementation, TLE with this test\\n        // [10001,10002,10003,10004,10005,10006,10007,10008,10009,10010,10011,1000000]\\n        // 10\\n        int n = jobs.size();\\n        if(k == n) {\\n            return *max_element(jobs.begin(), jobs.end());\\n        }\\n        if(k == n-1) {\\n            sort(jobs.begin(), jobs.end());\\n            int min_pair = jobs[0] + jobs[1];\\n            int max_job = jobs[n-1];\\n            return max(min_pair, max_job);\\n        }\\n        typedef pair<int, vector<int>> state;\\n        vector<int> cost(n+1, 1e9);\\n        stack<state> q;\\n        vector<int> workers(k,0);\\n        q.emplace(0, workers);\\n        map<state, bool> vis;\\n        while(!q.empty()) {\\n            vector<int> w;\\n            int u;\\n            tie(u, w) = q.top();\\n            if(vis[q.top()]) {\\n                q.pop();\\n                continue;\\n            }\\n            vis[q.top()] = true;\\n            q.pop();\\n            int next = w[k-1];\\n            if(next >= cost[n]) {\\n                continue;\\n            }\\n            cost[u] = next;\\n            int v = u+1;\\n            if(v > n) {\\n                continue;\\n            }\\n            for(int i = w.size()-1;i>=0;i--) {\\n                vector<int> nextw = w;\\n                nextw[i] += jobs[v-1];\\n                sort(nextw.begin(), nextw.end());\\n                q.emplace(v, nextw);\\n            }\\n        }\\n        return cost[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634914,
                "title": "early-breaking-based-on-distribution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void solve(vector<int> &jobs,int ind,vector<int> &v){\\n        if(ind==jobs.size()){\\n            int ma=0;\\n            for(auto &it:v){\\n                if(it!=0){\\n                    ma=max(ma,it);\\n                }\\n            }\\n            ans=min(ans,ma);\\n            return ;\\n        }\\n        \\n        for(int i=0;i<v.size();i++){\\n            if(v[i]+jobs[ind]>ans){\\n                continue ;\\n            }    // if at any time assigned work is greater than known answer dont assign..\\n            v[i]+=jobs[ind];\\n        \\n            solve(jobs,ind+1,v);\\n            v[i]-=jobs[ind];\\n            \\n            if(v[i]==0){\\n                return ;\\n            }  // for distribution once v[i]==0 , return \\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int> v(k,0);\\n        solve(jobs,0,v);\\n        return ans;\\n    }\\n};`\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void solve(vector<int> &jobs,int ind,vector<int> &v){\\n        if(ind==jobs.size()){\\n            int ma=0;\\n            for(auto &it:v){\\n                if(it!=0){\\n                    ma=max(ma,it);\\n                }\\n            }\\n            ans=min(ans,ma);\\n            return ;\\n        }\\n        \\n        for(int i=0;i<v.size();i++){\\n            if(v[i]+jobs[ind]>ans){\\n                continue ;\\n            }    // if at any time assigned work is greater than known answer dont assign..\\n            v[i]+=jobs[ind];\\n        \\n            solve(jobs,ind+1,v);\\n            v[i]-=jobs[ind];\\n            \\n            if(v[i]==0){\\n                return ;\\n            }  // for distribution once v[i]==0 , return \\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int> v(k,0);\\n        solve(jobs,0,v);\\n        return ans;\\n    }\\n};`\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627136,
                "title": "simple-short-solution",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll n;\\n    vi(vi(ll))dp;\\n    vi(ll)cost;\\n    ll getCost(const vi(int)&v, ll bm){\\n        ll ans=0;\\n        for(ll i=0;i<n;++i){\\n            if((bm>>i)&1){\\n                ans+=v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    ll func(const vi(int)&v, ll bm, ll k){\\n        if(bm==0){\\n            return 0;\\n        }\\n        if(k<1){\\n            return LLONG_MAX;\\n        }\\n        ll&ans=dp[bm][k];\\n        if(ans==-1){\\n            ans=LLONG_MAX;\\n            for(ll it=bm;;it=(it-1)&bm){\\n                ans=min(ans, max(cost[bm^it], func(v, it, k-1)));\\n                if(it<1){\\n                    break;\\n                }   \\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumTimeRequired(vector<int>&v, int k) {\\n        n=v.size();\\n        cost.assign(1<<n, 0);\\n        for(ll bm=0;bm<(1<<n);++bm){\\n            cost[bm]=getCost(v, bm);\\n        }\\n        dp.assign(1<<n, vi(ll)(k+1, -1));\\n        return func(v, (1<<n)-1, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll n;\\n    vi(vi(ll))dp;\\n    vi(ll)cost;\\n    ll getCost(const vi(int)&v, ll bm){\\n        ll ans=0;\\n        for(ll i=0;i<n;++i){\\n            if((bm>>i)&1){\\n                ans+=v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    ll func(const vi(int)&v, ll bm, ll k){\\n        if(bm==0){\\n            return 0;\\n        }\\n        if(k<1){\\n            return LLONG_MAX;\\n        }\\n        ll&ans=dp[bm][k];\\n        if(ans==-1){\\n            ans=LLONG_MAX;\\n            for(ll it=bm;;it=(it-1)&bm){\\n                ans=min(ans, max(cost[bm^it], func(v, it, k-1)));\\n                if(it<1){\\n                    break;\\n                }   \\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumTimeRequired(vector<int>&v, int k) {\\n        n=v.size();\\n        cost.assign(1<<n, 0);\\n        for(ll bm=0;bm<(1<<n);++bm){\\n            cost[bm]=getCost(v, bm);\\n        }\\n        dp.assign(1<<n, vi(ll)(k+1, -1));\\n        return func(v, (1<<n)-1, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607590,
                "title": "binarysearch-brute-force-optimisation-explained-python",
                "content": "```\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        #Similar Problems\\n        #this problem is exactly same as Fair distribution of cookies, except here k can go up to 12\\n        #Minimum incompatibility is basically the same problem aswell\\n\\t\\t#partition to  k equal sum subset\\n\\t\\t#matchsitcks to squate\\n\\t\\t#this solution takes around 4000ms, I recommend you checkout binary search solution (below) its even better!\\n        \\n        #min working time is acheived when the load is distributed evenly amongst k workers\\n        #you can check all combinations with simple brute force, but Time->O(k^n)\\n        #but you can do prunning to really avoid any duplicates and make significant gains\\n        \\n        #also these gains would be even more significant if you sort the jobs, this way shorter answer is reached first\\n        jobs.sort()\\n        n = len(jobs)\\n        ans = math.inf\\n        def distribute(index, c_max):\\n            nonlocal ans\\n            \\n            if index == n:\\n                ans = c_max\\n                return\\n            \\n\\t\\t\\tseen = set()\\n            for b_i in range(k):\\n                #1. no point creating making another call if it doesnt lead to a better answer \\n                #2. if current bag is in seen it will lead to same answer, \\n                # i.e same bags but different arrangement eg [5,3,0] or [3,5,0]\\n                # with this trick you can avoid both repeated index distribution eg (0,1,2) & (0, 2, 1), these numbers are indices\\n                # if there are repeated values in array eg jobs=[3,2,3], you can avoid (3,5,0) & (5,3,0) aswell\\n                if bags[b_i] in seen: continue\\n                seen.add(bags[b_i])\\n                if bags[b_i] + jobs[index] < ans:\\n                    bags[b_i] += jobs[index]\\n                    distribute(index+1, max(c_max, bags[b_i]))\\n                    bags[b_i] -= jobs[index]\\n                \\n        bags = [0]*k\\n\\t\\t# distribute(0, 0)\\n        # return ans\\n        \\n\\t\\t#Binary Search Solution is much faster\\n        #the recussive code is basically the same but you binary search b/w max(jobs) and sum(jobs) and treat that value as the answer\\n        #you also reverse sort, because that works better when you are trying to break max_capacity\\n        jobs = jobs[::-1]\\n        def dfs(index, max_capacity):\\n            if index == n: return True\\n            for b_i in range(k):\\n                if bags[b_i] + jobs[index] <= max_capacity and (not b_i or bags[b_i]!=bags[b_i-1]):\\n                    bags[b_i] += jobs[index]\\n                    if dfs(index + 1, max_capacity):\\n                        bags[b_i] -= jobs[index]\\n                        return True\\n                    bags[b_i] -= jobs[index]\\n            return False\\n\\n        # binary search\\n        left, right = jobs[0], sum(jobs)\\n        while left < right:\\n            x = (left + right)//2\\n            if dfs(0, x):\\n                right = x\\n            else:\\n                left = x + 1\\n        return left\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Backtracking"
                ],
                "code": "```\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        #Similar Problems\\n        #this problem is exactly same as Fair distribution of cookies, except here k can go up to 12\\n        #Minimum incompatibility is basically the same problem aswell\\n\\t\\t#partition to  k equal sum subset\\n\\t\\t#matchsitcks to squate\\n\\t\\t#this solution takes around 4000ms, I recommend you checkout binary search solution (below) its even better!\\n        \\n        #min working time is acheived when the load is distributed evenly amongst k workers\\n        #you can check all combinations with simple brute force, but Time->O(k^n)\\n        #but you can do prunning to really avoid any duplicates and make significant gains\\n        \\n        #also these gains would be even more significant if you sort the jobs, this way shorter answer is reached first\\n        jobs.sort()\\n        n = len(jobs)\\n        ans = math.inf\\n        def distribute(index, c_max):\\n            nonlocal ans\\n            \\n            if index == n:\\n                ans = c_max\\n                return\\n            \\n\\t\\t\\tseen = set()\\n            for b_i in range(k):\\n                #1. no point creating making another call if it doesnt lead to a better answer \\n                #2. if current bag is in seen it will lead to same answer, \\n                # i.e same bags but different arrangement eg [5,3,0] or [3,5,0]\\n                # with this trick you can avoid both repeated index distribution eg (0,1,2) & (0, 2, 1), these numbers are indices\\n                # if there are repeated values in array eg jobs=[3,2,3], you can avoid (3,5,0) & (5,3,0) aswell\\n                if bags[b_i] in seen: continue\\n                seen.add(bags[b_i])\\n                if bags[b_i] + jobs[index] < ans:\\n                    bags[b_i] += jobs[index]\\n                    distribute(index+1, max(c_max, bags[b_i]))\\n                    bags[b_i] -= jobs[index]\\n                \\n        bags = [0]*k\\n\\t\\t# distribute(0, 0)\\n        # return ans\\n        \\n\\t\\t#Binary Search Solution is much faster\\n        #the recussive code is basically the same but you binary search b/w max(jobs) and sum(jobs) and treat that value as the answer\\n        #you also reverse sort, because that works better when you are trying to break max_capacity\\n        jobs = jobs[::-1]\\n        def dfs(index, max_capacity):\\n            if index == n: return True\\n            for b_i in range(k):\\n                if bags[b_i] + jobs[index] <= max_capacity and (not b_i or bags[b_i]!=bags[b_i-1]):\\n                    bags[b_i] += jobs[index]\\n                    if dfs(index + 1, max_capacity):\\n                        bags[b_i] -= jobs[index]\\n                        return True\\n                    bags[b_i] -= jobs[index]\\n            return False\\n\\n        # binary search\\n        left, right = jobs[0], sum(jobs)\\n        while left < right:\\n            x = (left + right)//2\\n            if dfs(0, x):\\n                right = x\\n            else:\\n                left = x + 1\\n        return left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2566322,
                "title": "full-easiest-explanation-simple-backtracking",
                "content": "**Just Understand the Simple Logic **\\nhttps://www.youtube.com/watch?v=jBHZR_21YDE\\n\\n\\n\\nEasy Code -->\\n\\n\\'\\'\\'\\n          \\n    class Solution {\\n    int min=Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        backtraking(jobs,0,new int[k]);\\n        return min;\\n    }\\n    public void backtraking(int[]jobs,int j,int[] sum){\\n        int max=getmax(sum);\\n             \\n\\n        if(max>=min)\\n            return;\\n        if(j==jobs.length){\\n            min=Math.min(max,min);\\n            return;\\n        }\\n        for(int i=0;i<sum.length;i++){\\n            if(i>0 && sum[i]==sum[i-1])\\n                continue;\\n            sum[i]+=jobs[j];\\n            backtraking(jobs,j+1,sum);\\n            sum[i]-=jobs[j];\\n        }\\n    }\\n    public int getmax(int[] sum){\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<sum.length;i++)\\n            max = Math.max(max, sum[i]);\\n           return max;\\n      } \\n    }\\n\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    int min=Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        backtraking(jobs,0,new int[k]);\\n        return min;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2559874,
                "title": "c-binary-search-and-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int> &parSum, vector<int> &jobs, int index, int k, int target){\\n        if(index == jobs.size())\\n            return true;\\n        for(int i=0;i<k;i++){\\n            if(parSum[i] + jobs[index] <= target){\\n                parSum[i] += jobs[index];\\n                if(isPossible(parSum, jobs, index + 1, k, target))\\n                    return true;\\n                parSum[i]-=jobs[index];\\n                }\\n            if(parSum[i] == 0)\\n                return false; \\n        }\\n        return false;\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int l = *max_element(jobs.begin(), jobs.end());\\n        int r = accumulate(jobs.begin(), jobs.end(), 0);\\n        int result = 0;\\n        while(l<=r){\\n            int mid = (l + r)/2;\\n            vector<int> parSum(k,0);\\n            if(isPossible(parSum, jobs, 0, k, mid)){\\n                result = mid;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int> &parSum, vector<int> &jobs, int index, int k, int target){\\n        if(index == jobs.size())\\n            return true;\\n        for(int i=0;i<k;i++){\\n            if(parSum[i] + jobs[index] <= target){\\n                parSum[i] += jobs[index];\\n                if(isPossible(parSum, jobs, index + 1, k, target))\\n                    return true;\\n                parSum[i]-=jobs[index];\\n                }\\n            if(parSum[i] == 0)\\n                return false; \\n        }\\n        return false;\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int l = *max_element(jobs.begin(), jobs.end());\\n        int r = accumulate(jobs.begin(), jobs.end(), 0);\\n        int result = 0;\\n        while(l<=r){\\n            int mid = (l + r)/2;\\n            vector<int> parSum(k,0);\\n            if(isPossible(parSum, jobs, 0, k, mid)){\\n                result = mid;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535353,
                "title": "go-0ms-beats-100-backtracking-explanation",
                "content": "Standard exhaustive search using backtracking. \\nGenerate all possible tasks distribution among workers and compare with previous best result\\nOptimizations: \\n1. If current distribution assign to any worker tasks with total time > best result, then stop handling this distribution\\n2. Sort jobs in reverse order to prune more combinations ASAP\\n```\\nconst MaxInt = int(^uint(0) >> 1)\\n\\nfunc minimumTimeRequired(jobs []int, k int) int {\\n\\tn := len(jobs)\\n\\tresult := MaxInt\\n\\tsort.Sort(sort.Reverse(sort.IntSlice(jobs)))\\n\\tworkerTimes := make([]int, k)\\n\\t\\n\\tvar backtrack func(pos int, curMax int) \\n\\n\\tbacktrack = func(pos int, curMax int) {\\n\\t\\tif pos == n {\\n\\t\\t\\tif result > curMax {\\n\\t\\t\\t\\tresult = curMax\\n\\t\\t\\t}\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tjobDuration := jobs[pos]\\n\\t\\tuniqueWorkerTimes := make(map[int]bool)\\n\\t\\tfor i:=0; i<k; i++ {\\n\\t\\t\\tif _, ok := uniqueWorkerTimes[workerTimes[i]]; ok {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tuniqueWorkerTimes[workerTimes[i]] = true\\n\\t\\t\\tworkerTimes[i] += jobDuration\\n\\t\\t\\toldCurMax := curMax\\n\\t\\t\\tif curMax < workerTimes[i] {\\n\\t\\t\\t\\tcurMax = workerTimes[i]\\n\\t\\t\\t}\\n\\t\\t\\tif curMax < result {\\n\\t\\t\\t\\tbacktrack(pos+1, curMax)\\n\\t\\t\\t}\\n\\t\\t\\tworkerTimes[i] -= jobDuration\\n\\t\\t\\tcurMax = oldCurMax\\n\\t\\t}\\n\\n\\t}\\n\\n\\tbacktrack(0, 0)\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nconst MaxInt = int(^uint(0) >> 1)\\n\\nfunc minimumTimeRequired(jobs []int, k int) int {\\n\\tn := len(jobs)\\n\\tresult := MaxInt\\n\\tsort.Sort(sort.Reverse(sort.IntSlice(jobs)))\\n\\tworkerTimes := make([]int, k)\\n\\t\\n\\tvar backtrack func(pos int, curMax int) \\n\\n\\tbacktrack = func(pos int, curMax int) {\\n\\t\\tif pos == n {\\n\\t\\t\\tif result > curMax {\\n\\t\\t\\t\\tresult = curMax\\n\\t\\t\\t}\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tjobDuration := jobs[pos]\\n\\t\\tuniqueWorkerTimes := make(map[int]bool)\\n\\t\\tfor i:=0; i<k; i++ {\\n\\t\\t\\tif _, ok := uniqueWorkerTimes[workerTimes[i]]; ok {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tuniqueWorkerTimes[workerTimes[i]] = true\\n\\t\\t\\tworkerTimes[i] += jobDuration\\n\\t\\t\\toldCurMax := curMax\\n\\t\\t\\tif curMax < workerTimes[i] {\\n\\t\\t\\t\\tcurMax = workerTimes[i]\\n\\t\\t\\t}\\n\\t\\t\\tif curMax < result {\\n\\t\\t\\t\\tbacktrack(pos+1, curMax)\\n\\t\\t\\t}\\n\\t\\t\\tworkerTimes[i] -= jobDuration\\n\\t\\t\\tcurMax = oldCurMax\\n\\t\\t}\\n\\n\\t}\\n\\n\\tbacktrack(0, 0)\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2522448,
                "title": "golang-backtracking-with-pruning",
                "content": "Referenced https://www.youtube.com/watch?v=Be4s1gRx7Vc\\n```\\nfunc minimumTimeRequired(jobs []int, k int) int {\\n\\tminWorkingTime := math.MaxInt32\\n\\tbacktrack(jobs, 0, 0, make([]int, k), &minWorkingTime)\\n\\treturn minWorkingTime\\n}\\n\\nfunc backtrack(jobs []int, jobIndex int, curMax int, workers []int, minWorkingTime *int) {\\n    if jobIndex == len(jobs) {\\n        *minWorkingTime = min(*minWorkingTime, curMax)\\n        return\\n    }\\n    \\n    uniqueWorkingTimes := make(map[int]struct{})\\n    for i := 0; i < len(workers); i++ {\\n        if _, ok := uniqueWorkingTimes[workers[i]]; !ok {\\n            uniqueWorkingTimes[workers[i]] = struct{}{}\\n            workers[i] += jobs[jobIndex]\\n            backtrack(jobs, jobIndex+1, max(curMax, workers[i]), workers, minWorkingTime)\\n            workers[i] -= jobs[jobIndex]\\n        }\\n    }\\n}\\n\\nfunc max(values ...int) int {\\n\\tmaxValue := 0\\n\\tfor _, v := range values {\\n\\t\\tif v > maxValue {\\n\\t\\t\\tmaxValue = v\\n\\t\\t}\\n\\t}\\n\\treturn maxValue\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt32\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumTimeRequired(jobs []int, k int) int {\\n\\tminWorkingTime := math.MaxInt32\\n\\tbacktrack(jobs, 0, 0, make([]int, k), &minWorkingTime)\\n\\treturn minWorkingTime\\n}\\n\\nfunc backtrack(jobs []int, jobIndex int, curMax int, workers []int, minWorkingTime *int) {\\n    if jobIndex == len(jobs) {\\n        *minWorkingTime = min(*minWorkingTime, curMax)\\n        return\\n    }\\n    \\n    uniqueWorkingTimes := make(map[int]struct{})\\n    for i := 0; i < len(workers); i++ {\\n        if _, ok := uniqueWorkingTimes[workers[i]]; !ok {\\n            uniqueWorkingTimes[workers[i]] = struct{}{}\\n            workers[i] += jobs[jobIndex]\\n            backtrack(jobs, jobIndex+1, max(curMax, workers[i]), workers, minWorkingTime)\\n            workers[i] -= jobs[jobIndex]\\n        }\\n    }\\n}\\n\\nfunc max(values ...int) int {\\n\\tmaxValue := 0\\n\\tfor _, v := range values {\\n\\t\\tif v > maxValue {\\n\\t\\t\\tmaxValue = v\\n\\t\\t}\\n\\t}\\n\\treturn maxValue\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt32\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2354475,
                "title": "the-most-important-concept-for-dp",
                "content": "```\\nbool check(vector<int>&nums,vector<int>&vec,int step,long long val)\\n    {\\n        if(step==nums.size()) return true;\\n        int cur=nums[step];\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(cur+vec[i]<=val)\\n            {\\n                vec[i]+=cur;\\n                if(check(nums,vec,step+1,val)) return true;\\n                vec[i]-=cur;\\n            }\\n            \\n            \\n//VERY VERY IMPORTANT ---> line below is the most important line . Jab 0 hai to koi na koi subset me jaake ans anaa hi chiye nahi ara to ans not possible hai mere bhai\\n            if(vec[i]==0)  \\n                break;\\n        }\\n        return false;\\n    }\\n    int minimumTimeRequired(vector<int>& nums, int k) {\\n        \\n        int maxEle=0,sum=0;\\n        for(auto i:nums)\\n        {\\n            maxEle=max(maxEle,i);\\n            sum+=i;\\n        }\\n        \\n        //minimum of the maximum time would be when every worker does one work one worker will have the arr[i] which have max work so start=max(arr[i]) SAME AS BOOK ALLOCATION\\n        //end sum of all works if there is only 1 worker thats the case\\n        \\n        int start=maxEle,end=sum,ans;\\n        while(start<=end)\\n        {\\n            int mid=(start+end)/2;\\n            vector<int>vec(k,0);\\n            if(check(nums,vec,0,mid))\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else\\n                start=mid+1;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nbool check(vector<int>&nums,vector<int>&vec,int step,long long val)\\n    {\\n        if(step==nums.size()) return true;\\n        int cur=nums[step];\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(cur+vec[i]<=val)\\n            {\\n                vec[i]+=cur;\\n                if(check(nums,vec,step+1,val)) return true;\\n                vec[i]-=cur;\\n            }\\n            \\n            \\n//VERY VERY IMPORTANT ---> line below is the most important line . Jab 0 hai to koi na koi subset me jaake ans anaa hi chiye nahi ara to ans not possible hai mere bhai\\n            if(vec[i]==0)  \\n                break;\\n        }\\n        return false;\\n    }\\n    int minimumTimeRequired(vector<int>& nums, int k) {\\n        \\n        int maxEle=0,sum=0;\\n        for(auto i:nums)\\n        {\\n            maxEle=max(maxEle,i);\\n            sum+=i;\\n        }\\n        \\n        //minimum of the maximum time would be when every worker does one work one worker will have the arr[i] which have max work so start=max(arr[i]) SAME AS BOOK ALLOCATION\\n        //end sum of all works if there is only 1 worker thats the case\\n        \\n        int start=maxEle,end=sum,ans;\\n        while(start<=end)\\n        {\\n            int mid=(start+end)/2;\\n            vector<int>vec(k,0);\\n            if(check(nums,vec,0,mid))\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else\\n                start=mid+1;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2322143,
                "title": "java-branch-bound-solution",
                "content": "```\\nclass Solution {\\n    \\n    class Result {\\n        int value;\\n        public Result() {\\n            this.value = Integer.MAX_VALUE;\\n        }\\n        \\n        public void setValue(int val) {\\n            this.value = Math.min(this.value, val);\\n        }\\n    }\\n    \\n    private void branchAndBound(int[] jobs, int[] sums, int index, int k, int sum, Result bound) {\\n        if(index == jobs.length) {\\n            bound.setValue(sum);\\n            return;\\n        }\\n        if(sum >= bound.value) return;\\n        int jobTime = jobs[index];\\n        for(int i = 0; i < k; i++) {\\n            if(i > 0 && sums[i] == sums[i - 1]) continue;\\n            sums[i] += jobTime;\\n            sum = maxOf(sums);\\n            branchAndBound(jobs, sums, index + 1, k, sum, bound);\\n            sums[i] -= jobTime;\\n        }\\n    }\\n    \\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        Arrays.sort(jobs);\\n        Result result = new Result();\\n        int[] sums = new int[k];\\n        branchAndBound(jobs, sums, 0, k, 0, result);\\n        return result.value;\\n    }\\n    \\n    private int maxOf(int[] arr) {\\n        int maxVal = 0;\\n        for(int i : arr) {\\n            maxVal = Math.max(i, maxVal);\\n        }\\n        return maxVal;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Result {\\n        int value;\\n        public Result() {\\n            this.value = Integer.MAX_VALUE;\\n        }\\n        \\n        public void setValue(int val) {\\n            this.value = Math.min(this.value, val);\\n        }\\n    }\\n    \\n    private void branchAndBound(int[] jobs, int[] sums, int index, int k, int sum, Result bound) {\\n        if(index == jobs.length) {\\n            bound.setValue(sum);\\n            return;\\n        }\\n        if(sum >= bound.value) return;\\n        int jobTime = jobs[index];\\n        for(int i = 0; i < k; i++) {\\n            if(i > 0 && sums[i] == sums[i - 1]) continue;\\n            sums[i] += jobTime;\\n            sum = maxOf(sums);\\n            branchAndBound(jobs, sums, index + 1, k, sum, bound);\\n            sums[i] -= jobTime;\\n        }\\n    }\\n    \\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        Arrays.sort(jobs);\\n        Result result = new Result();\\n        int[] sums = new int[k];\\n        branchAndBound(jobs, sums, 0, k, 0, result);\\n        return result.value;\\n    }\\n    \\n    private int maxOf(int[] arr) {\\n        int maxVal = 0;\\n        for(int i : arr) {\\n            maxVal = Math.max(i, maxVal);\\n        }\\n        return maxVal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120411,
                "title": "dp-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,k,dp[13][(1<<13)],un[(1<<13)];\\n    \\n    int sol(int i,int mask,vector<int> &jb)\\n    {\\n        if(mask==((1<<n)-1)) return 0;\\n        if(i==k) return 1e9;\\n        \\n        int ans=dp[i][mask];\\n        if(ans!=-1) return ans;\\n        ans=1e9;\\n        \\n        int nwmask=0;\\n        for(int j=0;j<n;j++)\\n            if((mask & (1<<j))==0)\\n                nwmask|=(1<<j);\\n        \\n        for(int nw=nwmask;nw;nw=(nw-1)&nwmask)\\n            if((mask & nw)==0)\\n                ans=min(ans,max(un[nw],sol(i+1,mask|nw,jb)));\\n        \\n        return dp[i][mask]=ans;\\n    }\\n    \\n    int minimumTimeRequired(vector<int>& jb, int kk) \\n    {\\n        n=jb.size(),k=kk;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            int sm=0;\\n            for(int j=0;j<n;j++)\\n                if(i & (1<<j))\\n                    sm+=jb[j];\\n            un[i]=sm;\\n        }\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return sol(0,0,jb);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,k,dp[13][(1<<13)],un[(1<<13)];\\n    \\n    int sol(int i,int mask,vector<int> &jb)\\n    {\\n        if(mask==((1<<n)-1)) return 0;\\n        if(i==k) return 1e9;\\n        \\n        int ans=dp[i][mask];\\n        if(ans!=-1) return ans;\\n        ans=1e9;\\n        \\n        int nwmask=0;\\n        for(int j=0;j<n;j++)\\n            if((mask & (1<<j))==0)\\n                nwmask|=(1<<j);\\n        \\n        for(int nw=nwmask;nw;nw=(nw-1)&nwmask)\\n            if((mask & nw)==0)\\n                ans=min(ans,max(un[nw],sol(i+1,mask|nw,jb)));\\n        \\n        return dp[i][mask]=ans;\\n    }\\n    \\n    int minimumTimeRequired(vector<int>& jb, int kk) \\n    {\\n        n=jb.size(),k=kk;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            int sm=0;\\n            for(int j=0;j<n;j++)\\n                if(i & (1<<j))\\n                    sm+=jb[j];\\n            un[i]=sm;\\n        }\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return sol(0,0,jb);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087628,
                "title": "c-solution-with-high-level-explanation",
                "content": "High level code:\\n\\n```\\nfunction checkWorkers(current job, max_time)\\n{\\n\\tif(max_time < final_result)\\n\\t{\\n\\t\\tFor each worker in workers\\n\\t\\t{\\n\\t\\t\\tif(previous worker has same time as current) then\\n\\t\\t\\t\\tskip this worker\\n\\t\\t\\tendif\\n\\t\\t\\t\\n\\t\\t\\tPick current job for worker\\n\\t\\t\\t\\n\\t\\t\\t if more jobs available then\\n\\t\\t\\t\\tcall checkWorkers() sending the following parameters:\\n\\t\\t\\t\\t\\t 1 - max time including worker time after job picked\\n\\t\\t\\t\\t\\t 2-  next job\\n\\n\\t\\t\\telse\\n\\t\\t\\t\\tcompare new max time with the final_result (minimum reached)\\n\\n\\t\\t\\tendif\\n\\n\\t\\t\\tRelieve worker from picked job because other workers will pick the same job\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n\\nExample input: [2, 3, 4] k = 2\\nExpected Output: 5\\n\\nDebug steps:\\n![image](https://assets.leetcode.com/users/images/f88d2063-4f53-454c-b761-5c138234e119_1653833803.0145204.png)\\n\\n\\n\\n\\n\\n\\n.\\n.\\n.\\n\\n\\nC++ code:\\n\\n```\\nclass Solution {\\nprivate:\\n        int result = INT_MAX;\\npublic:\\n\\n    void checkWorkers(vector<int>& jobs, vector<int>& workers, int currentMax, int currentJobIndex)\\n    {\\n        if(currentMax >= result) return;\\n        \\n        for(int i = 0 ; i < workers.size() ; i++)\\n        {\\n            if (i > 0 && workers[i] == workers[i - 1]) continue;\\n\\n            workers[i] += jobs[currentJobIndex];\\n            if(currentJobIndex < jobs.size() - 1)\\n            {\\n                checkWorkers(jobs, workers, max(currentMax, workers[i]), currentJobIndex + 1);\\n            }\\n            else\\n            {\\n                result = min(result, max(currentMax, workers[i]));\\n            }\\n\\n            workers[i] -= jobs[currentJobIndex];\\n        }\\n\\n    }\\n\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        \\n        if(k == jobs.size()) return *max_element(begin(jobs), end(jobs));\\n        \\n        if(k == 1) return accumulate(jobs.begin(), jobs.end(), 0);\\n        \\n        vector<int> workers(k, 0);\\n        \\n        checkWorkers(jobs, workers, 0, 0);\\n\\n        return result;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nfunction checkWorkers(current job, max_time)\\n{\\n\\tif(max_time < final_result)\\n\\t{\\n\\t\\tFor each worker in workers\\n\\t\\t{\\n\\t\\t\\tif(previous worker has same time as current) then\\n\\t\\t\\t\\tskip this worker\\n\\t\\t\\tendif\\n\\t\\t\\t\\n\\t\\t\\tPick current job for worker\\n\\t\\t\\t\\n\\t\\t\\t if more jobs available then\\n\\t\\t\\t\\tcall checkWorkers() sending the following parameters:\\n\\t\\t\\t\\t\\t 1 - max time including worker time after job picked\\n\\t\\t\\t\\t\\t 2-  next job\\n\\n\\t\\t\\telse\\n\\t\\t\\t\\tcompare new max time with the final_result (minimum reached)\\n\\n\\t\\t\\tendif\\n\\n\\t\\t\\tRelieve worker from picked job because other workers will pick the same job\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nclass Solution {\\nprivate:\\n        int result = INT_MAX;\\npublic:\\n\\n    void checkWorkers(vector<int>& jobs, vector<int>& workers, int currentMax, int currentJobIndex)\\n    {\\n        if(currentMax >= result) return;\\n        \\n        for(int i = 0 ; i < workers.size() ; i++)\\n        {\\n            if (i > 0 && workers[i] == workers[i - 1]) continue;\\n\\n            workers[i] += jobs[currentJobIndex];\\n            if(currentJobIndex < jobs.size() - 1)\\n            {\\n                checkWorkers(jobs, workers, max(currentMax, workers[i]), currentJobIndex + 1);\\n            }\\n            else\\n            {\\n                result = min(result, max(currentMax, workers[i]));\\n            }\\n\\n            workers[i] -= jobs[currentJobIndex];\\n        }\\n\\n    }\\n\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        \\n        if(k == jobs.size()) return *max_element(begin(jobs), end(jobs));\\n        \\n        if(k == 1) return accumulate(jobs.begin(), jobs.end(), 0);\\n        \\n        vector<int> workers(k, 0);\\n        \\n        checkWorkers(jobs, workers, 0, 0);\\n\\n        return result;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077686,
                "title": "this-problem-has-practical-value-in-real-world",
                "content": "this problem has practical value in real-world.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1977281,
                "title": "hoc5-joy-coding-2022",
                "content": "Please post your solution. Joy!!!",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1878400,
                "title": "c-o-k-3-n-solution-dp",
                "content": "k is no of workers\\nn is no of the jobs\\n\\naxll[mask]=sum of time of ith(job as ) set bit\\n\\ndp[i][mask]=upto ith person ,we have assigned jobs which are set bit in mask and have min time .\\n\\ntransition ,\\nfor every j as a submask of mask;\\ndp[i][mask]=min( max(dp[i -1][mask^j]  ,  axll[j] )   ,   dp[i][mask]);\\n// we are assigning submask of job to ith person\\n\\nfor each  person it will 3^(n);\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "k is no of workers\\nn is no of the jobs\\n\\naxll[mask]=sum of time of ith(job as ) set bit\\n\\ndp[i][mask]=upto ith person ,we have assigned jobs which are set bit in mask and have min time .\\n\\ntransition ,\\nfor every j as a submask of mask;\\ndp[i][mask]=min( max(dp[i -1][mask^j]  ,  axll[j] )   ,   dp[i][mask]);\\n// we are assigning submask of job to ith person\\n\\nfor each  person it will 3^(n);\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1782774,
                "title": "time-limit-exceed",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    void find(vector<int>&jobs,int i,int k, vector<int>&worker,int n){\\n        if(i==n){\\n            int temp = worker[0];\\n            for(int l=0;l<k;l++)temp = max(temp,worker[l]);\\n            ans = min(ans,temp);\\n            return;\\n        }\\n        unordered_map<int,int>m;\\n        for(int j=0;j<k;j++){\\n            if(worker[j]>ans)continue;\\n            if(m.count(worker[j]))continue;\\n            m[worker[j]]++;\\n            worker[j]+=jobs[i];\\n            find(jobs,i+1,k,worker,n);\\n            worker[j]-=jobs[i];\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n       // start with brute force and then improve\\n        vector<int>worker(k,0);\\n        ans = INT_MAX;\\n        find(jobs,0,k,worker,jobs.size());\\n        return ans;   \\n    }\\n};\\n\\ndon\\'t know why it\\'s showing TLE , any idea?",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ans;\\n    void find(vector<int>&jobs,int i,int k, vector<int>&worker,int n){\\n        if(i==n){\\n            int temp = worker[0];\\n            for(int l=0;l<k;l++)temp = max(temp,worker[l]);\\n            ans = min(ans,temp);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1726043,
                "title": "golang-bfs-solution",
                "content": "```go\\nfunc minimumTimeRequired(jobs []int, k int) int {\\n\\tminRequired := math.MaxInt32\\n\\tsort.Ints(jobs)\\n\\tdfs(jobs, 0, k, 0, k, make([]int, k), &minRequired)\\n\\treturn minRequired\\n}\\n\\nfunc dfs(jobs []int, jobIndex, workerSize, curMaxRequired, freeWorker int, requires []int, minRequired *int) {\\n\\tif jobIndex == len(jobs) {\\n\\t\\t*minRequired = min(*minRequired, max(requires...))\\n\\t\\treturn\\n\\t}\\n\\tif len(jobs) - jobIndex == freeWorker {\\n\\t\\t// dispatch res jobs to freeWorkers\\n\\t\\tif curMaxRequiredTemp := max(curMaxRequired, jobs[len(jobs)-1]); curMaxRequiredTemp < *minRequired {\\n\\t\\t\\t*minRequired = curMaxRequiredTemp\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\tfor workerIndex := 0; workerIndex < len(requires); workerIndex++ {\\n\\t\\t// jobIndex should greater or equal workerIndex\\n\\t\\tif jobIndex < workerIndex {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t// already greater or equal *minRequired, skip\\n\\t\\tif requires[workerIndex]+jobs[jobIndex] > curMaxRequired {\\n\\t\\t\\tif requires[workerIndex]+jobs[jobIndex] >= *minRequired {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif requires[workerIndex] == 0 {\\n\\t\\t\\tfreeWorker--\\n\\t\\t}\\n\\t\\trequires[workerIndex] += jobs[jobIndex]\\n\\t\\tdfs(jobs, jobIndex+1, workerSize, max(curMaxRequired, requires[workerIndex]), freeWorker, requires, minRequired)\\n\\t\\trequires[workerIndex] -= jobs[jobIndex]\\n\\t\\tif requires[workerIndex] == 0 {\\n\\t\\t\\tfreeWorker++\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc max(values ...int) int {\\n\\tmaxValue := math.MinInt64\\n\\tfor _, v := range values {\\n\\t\\tif v > maxValue {\\n\\t\\t\\tmaxValue = v\\n\\t\\t}\\n\\t}\\n\\treturn maxValue\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```go\\nfunc minimumTimeRequired(jobs []int, k int) int {\\n\\tminRequired := math.MaxInt32\\n\\tsort.Ints(jobs)\\n\\tdfs(jobs, 0, k, 0, k, make([]int, k), &minRequired)\\n\\treturn minRequired\\n}\\n\\nfunc dfs(jobs []int, jobIndex, workerSize, curMaxRequired, freeWorker int, requires []int, minRequired *int) {\\n\\tif jobIndex == len(jobs) {\\n\\t\\t*minRequired = min(*minRequired, max(requires...))\\n\\t\\treturn\\n\\t}\\n\\tif len(jobs) - jobIndex == freeWorker {\\n\\t\\t// dispatch res jobs to freeWorkers\\n\\t\\tif curMaxRequiredTemp := max(curMaxRequired, jobs[len(jobs)-1]); curMaxRequiredTemp < *minRequired {\\n\\t\\t\\t*minRequired = curMaxRequiredTemp\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\tfor workerIndex := 0; workerIndex < len(requires); workerIndex++ {\\n\\t\\t// jobIndex should greater or equal workerIndex\\n\\t\\tif jobIndex < workerIndex {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t// already greater or equal *minRequired, skip\\n\\t\\tif requires[workerIndex]+jobs[jobIndex] > curMaxRequired {\\n\\t\\t\\tif requires[workerIndex]+jobs[jobIndex] >= *minRequired {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif requires[workerIndex] == 0 {\\n\\t\\t\\tfreeWorker--\\n\\t\\t}\\n\\t\\trequires[workerIndex] += jobs[jobIndex]\\n\\t\\tdfs(jobs, jobIndex+1, workerSize, max(curMaxRequired, requires[workerIndex]), freeWorker, requires, minRequired)\\n\\t\\trequires[workerIndex] -= jobs[jobIndex]\\n\\t\\tif requires[workerIndex] == 0 {\\n\\t\\t\\tfreeWorker++\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc max(values ...int) int {\\n\\tmaxValue := math.MinInt64\\n\\tfor _, v := range values {\\n\\t\\tif v > maxValue {\\n\\t\\t\\tmaxValue = v\\n\\t\\t}\\n\\t}\\n\\treturn maxValue\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1703021,
                "title": "python-heap-backtrace-99-runtime",
                "content": "```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        n = len(jobs)\\n        if k == n:\\n            return max(jobs)\\n        jobs.sort(reverse=True)\\n        if k > n //2:\\n            # 2k - n workers will be assigned with one job(the most largest ones).\\n            # The rest workers may get one or more jobs.\\n            # This will reduce number of jobs and k, and make backtrace(...) faster\\n            return max(jobs[0], self.minimumTimeRequired(jobs[2*k-n:], n-k))\\n\\n        # This heap is not necessary, but it will make self.res very close to the final result,\\n        # and significantly reduce the running time for backtrace(...)\\n        heap = jobs[:k]\\n        heapify(heap)\\n        for i in range(k, n):\\n            heappush(heap, heappop(heap) + jobs[i])\\n        \\n        self.res = max(heap)\\n        \\n        cur = [0] * k\\n        def backtrace(index: int):\\n            if index == n:\\n                self.res = max(cur)\\n                return\\n            for i in range(k):\\n                if cur[i] + jobs[index] >= self.res:\\n                    # Worker i won\\'t take more than self.res.\\n                    continue\\n                cur[i] += jobs[index]\\n                backtrace(index+1)\\n                cur[i] -= jobs[index]\\n                if cur[i] == 0:\\n                    # At least assign one job to worker i.\\n                    break\\n        backtrace(0)\\n        return self.res\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        n = len(jobs)\\n        if k == n:\\n            return max(jobs)\\n        jobs.sort(reverse=True)\\n        if k > n //2:\\n            # 2k - n workers will be assigned with one job(the most largest ones).\\n            # The rest workers may get one or more jobs.\\n            # This will reduce number of jobs and k, and make backtrace(...) faster\\n            return max(jobs[0], self.minimumTimeRequired(jobs[2*k-n:], n-k))\\n\\n        # This heap is not necessary, but it will make self.res very close to the final result,\\n        # and significantly reduce the running time for backtrace(...)\\n        heap = jobs[:k]\\n        heapify(heap)\\n        for i in range(k, n):\\n            heappush(heap, heappop(heap) + jobs[i])\\n        \\n        self.res = max(heap)\\n        \\n        cur = [0] * k\\n        def backtrace(index: int):\\n            if index == n:\\n                self.res = max(cur)\\n                return\\n            for i in range(k):\\n                if cur[i] + jobs[index] >= self.res:\\n                    # Worker i won\\'t take more than self.res.\\n                    continue\\n                cur[i] += jobs[index]\\n                backtrace(index+1)\\n                cur[i] -= jobs[index]\\n                if cur[i] == 0:\\n                    # At least assign one job to worker i.\\n                    break\\n        backtrace(0)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672391,
                "title": "java-backtraking-solution",
                "content": "```\\nclass Solution {\\n    int min=Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        backtraking(jobs,jobs.length-1,new int[k]);\\n        return min;\\n    }\\n    public void backtraking(int[]jobs,int j,int[] sum){\\n        int max=getmax(sum);\\n        if(max>=min)\\n            return;\\n        if(j<0){\\n            min=Math.min(max,min);\\n            return;\\n        }\\n        for(int i=0;i<sum.length;i++){\\n            if(i>0 && sum[i]==sum[i-1])\\n                continue;\\n            sum[i]+=jobs[j];\\n            backtraking(jobs,j-1,sum);\\n            sum[i]-=jobs[j];\\n        }\\n    }\\n    public int getmax(int[] sum){\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<sum.length;i++)\\n            max = Math.max(max, sum[i]);\\n        return max;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int min=Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        backtraking(jobs,jobs.length-1,new int[k]);\\n        return min;\\n    }\\n    public void backtraking(int[]jobs,int j,int[] sum){\\n        int max=getmax(sum);\\n        if(max>=min)\\n            return;\\n        if(j<0){\\n            min=Math.min(max,min);\\n            return;\\n        }\\n        for(int i=0;i<sum.length;i++){\\n            if(i>0 && sum[i]==sum[i-1])\\n                continue;\\n            sum[i]+=jobs[j];\\n            backtraking(jobs,j-1,sum);\\n            sum[i]-=jobs[j];\\n        }\\n    }\\n    public int getmax(int[] sum){\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<sum.length;i++)\\n            max = Math.max(max, sum[i]);\\n        return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658137,
                "title": "100-c-backtracking-with-pruning",
                "content": "```\\nstruct Node\\n{\\n\\tint key;\\n\\tstruct Node *left;\\n\\tstruct Node *right;\\n\\tint height;\\n};\\n\\nint max(int a, int b);\\n\\nint height(struct Node *N)\\n{\\n\\tif (N == NULL)\\n\\t\\treturn 0;\\n\\treturn N->height;\\n}\\n\\nstruct Node* newNode(int key)\\n{\\n\\tstruct Node* node = (struct Node*)\\n\\t\\t\\t\\t\\t\\tmalloc(sizeof(struct Node));\\n\\tnode->key = key;\\n\\tnode->left = NULL;\\n\\tnode->right = NULL;\\n\\tnode->height = 1; // new node is initially added at leaf\\n\\treturn(node);\\n}\\n\\nstruct Node *rightRotate(struct Node *y)\\n{\\n\\tstruct Node *x = y->left;\\n\\tstruct Node *T2 = x->right;\\n\\n\\t// Perform rotation\\n\\tx->right = y;\\n\\ty->left = T2;\\n\\n\\t// Update heights\\n\\ty->height = max(height(y->left), height(y->right))+1;\\n\\tx->height = max(height(x->left), height(x->right))+1;\\n\\n\\t// Return new root\\n\\treturn x;\\n}\\n\\nstruct Node *leftRotate(struct Node *x)\\n{\\n\\tstruct Node *y = x->right;\\n\\tstruct Node *T2 = y->left;\\n\\n\\t// Perform rotation\\n\\ty->left = x;\\n\\tx->right = T2;\\n\\n\\t// Update heights\\n\\tx->height = max(height(x->left), height(x->right))+1;\\n\\ty->height = max(height(y->left), height(y->right))+1;\\n\\n\\t// Return new root\\n\\treturn y;\\n}\\n\\nint getBalance(struct Node *N)\\n{\\n\\tif (N == NULL)\\n\\t\\treturn 0;\\n\\treturn height(N->left) - height(N->right);\\n}\\n\\nstruct Node* insert(struct Node* node, int key)\\n{\\n\\t/* 1. Perform the normal BST insertion */\\n\\tif (node == NULL)\\n\\t\\treturn(newNode(key));\\n\\n\\tif (key < node->key)\\n\\t\\tnode->left = insert(node->left, key);\\n\\telse if (key > node->key)\\n\\t\\tnode->right = insert(node->right, key);\\n\\telse // Equal keys are not allowed in BST\\n\\t\\treturn node;\\n\\n\\t/* 2. Update height of this ancestor node */\\n\\tnode->height = 1 + max(height(node->left),\\n\\t\\t\\t\\t\\t\\theight(node->right));\\n\\n\\t/* 3. Get the balance factor of this ancestor\\n\\t\\tnode to check whether this node became\\n\\t\\tunbalanced */\\n\\tint balance = getBalance(node);\\n\\n\\t// If this node becomes unbalanced, then\\n\\t// there are 4 cases\\n\\n\\t// Left Left Case\\n\\tif (balance > 1 && key < node->left->key)\\n\\t\\treturn rightRotate(node);\\n\\n\\t// Right Right Case\\n\\tif (balance < -1 && key > node->right->key)\\n\\t\\treturn leftRotate(node);\\n\\n\\t// Left Right Case\\n\\tif (balance > 1 && key > node->left->key)\\n\\t{\\n\\t\\tnode->left = leftRotate(node->left);\\n\\t\\treturn rightRotate(node);\\n\\t}\\n\\n\\t// Right Left Case\\n\\tif (balance < -1 && key < node->right->key)\\n\\t{\\n\\t\\tnode->right = rightRotate(node->right);\\n\\t\\treturn leftRotate(node);\\n\\t}\\n\\n\\t/* return the (unchanged) node pointer */\\n\\treturn node;\\n}\\n\\nbool check(struct Node* root, int val)\\n{\\n    if(root == NULL)\\n        return false;\\n    else\\n    {\\n        if(root->key == val)\\n            return true;\\n        else if(root->key < val)\\n            return check(root->right, val);\\n        else\\n            return check(root->left, val);\\n    }\\n}\\n\\nint max(int a, int b)\\n{\\n    return (a > b)? a: b;\\n}\\n\\nint min(int a, int b)\\n{\\n    return -max(-a, -b);\\n}\\n\\nvoid assign(int* assignments, int id, int* jobs, int k, int* ans)\\n{\\n    int i;\\n    if(id == -1)\\n    {\\n        int ret = INT_MIN;\\n        for(i = 0; i < k; i++)\\n            ret = max(ret, assignments[i]);\\n        *ans = min(*ans, ret);\\n        return;\\n    }\\n    else\\n    {\\n        struct Node* root = NULL;\\n        for(i = 0; i < k; i++)\\n        {\\n            assignments[i] += jobs[id];\\n            if(check(root, assignments[i]))\\n            {\\n                assignments[i] -= jobs[id];\\n                continue;\\n            }\\n            root = insert(root, assignments[i]);\\n            if(assignments[i] < *ans)\\n                assign(assignments, id - 1, jobs, k, ans);\\n            assignments[i] -= jobs[id];\\n        }\\n    }\\n}\\n\\nint comparator(const void* a, const void* b)\\n{\\n    return *((int*)a) - *((int*)b);\\n}\\n\\nint helper(int* jobs, int jobsSize, int k)\\n{\\n    int* assignments = (int*)calloc(k, sizeof(int));\\n    int i = jobsSize - 1, dir = -1;\\n    \\n    while(i >= 0)\\n    {\\n        int j = max(i - k + 1, 0);\\n        if(dir == -1)\\n        {\\n            int l, size = i - j + 1;\\n            for(l = 0; l < size; l++)\\n                assignments[l] += jobs[i - l];\\n        }\\n        else\\n        {\\n            int l, size = i - j + 1;\\n            for(l = 0; l < size; l++)\\n                assignments[size - 1 - l] += jobs[i - l];\\n        }\\n        i = j - 1;\\n        dir *= -1;\\n    }\\n    \\n    int ans = assignments[0];\\n    for(i = 1; i < k; i++)\\n        ans = max(ans, assignments[i]);\\n    \\n    return ans;\\n}\\n\\nint minimumTimeRequired(int* jobs, int jobsSize, int k)\\n{\\n    qsort(jobs, jobsSize, sizeof(int), comparator);\\n    int i;\\n    \\n    int ans = helper(jobs, jobsSize, k);\\n    int* assignments = (int*)calloc(k, sizeof(int));\\n   \\n    assign(assignments, jobsSize - 1, jobs, k, &ans);\\n    return ans;\\n}\\n\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nstruct Node\\n{\\n\\tint key;\\n\\tstruct Node *left;\\n\\tstruct Node *right;\\n\\tint height;\\n};\\n\\nint max(int a, int b);\\n\\nint height(struct Node *N)\\n{\\n\\tif (N == NULL)\\n\\t\\treturn 0;\\n\\treturn N->height;\\n}\\n\\nstruct Node* newNode(int key)\\n{\\n\\tstruct Node* node = (struct Node*)\\n\\t\\t\\t\\t\\t\\tmalloc(sizeof(struct Node));\\n\\tnode->key = key;\\n\\tnode->left = NULL;\\n\\tnode->right = NULL;\\n\\tnode->height = 1; // new node is initially added at leaf\\n\\treturn(node);\\n}\\n\\nstruct Node *rightRotate(struct Node *y)\\n{\\n\\tstruct Node *x = y->left;\\n\\tstruct Node *T2 = x->right;\\n\\n\\t// Perform rotation\\n\\tx->right = y;\\n\\ty->left = T2;\\n\\n\\t// Update heights\\n\\ty->height = max(height(y->left), height(y->right))+1;\\n\\tx->height = max(height(x->left), height(x->right))+1;\\n\\n\\t// Return new root\\n\\treturn x;\\n}\\n\\nstruct Node *leftRotate(struct Node *x)\\n{\\n\\tstruct Node *y = x->right;\\n\\tstruct Node *T2 = y->left;\\n\\n\\t// Perform rotation\\n\\ty->left = x;\\n\\tx->right = T2;\\n\\n\\t// Update heights\\n\\tx->height = max(height(x->left), height(x->right))+1;\\n\\ty->height = max(height(y->left), height(y->right))+1;\\n\\n\\t// Return new root\\n\\treturn y;\\n}\\n\\nint getBalance(struct Node *N)\\n{\\n\\tif (N == NULL)\\n\\t\\treturn 0;\\n\\treturn height(N->left) - height(N->right);\\n}\\n\\nstruct Node* insert(struct Node* node, int key)\\n{\\n\\t/* 1. Perform the normal BST insertion */\\n\\tif (node == NULL)\\n\\t\\treturn(newNode(key));\\n\\n\\tif (key < node->key)\\n\\t\\tnode->left = insert(node->left, key);\\n\\telse if (key > node->key)\\n\\t\\tnode->right = insert(node->right, key);\\n\\telse // Equal keys are not allowed in BST\\n\\t\\treturn node;\\n\\n\\t/* 2. Update height of this ancestor node */\\n\\tnode->height = 1 + max(height(node->left),\\n\\t\\t\\t\\t\\t\\theight(node->right));\\n\\n\\t/* 3. Get the balance factor of this ancestor\\n\\t\\tnode to check whether this node became\\n\\t\\tunbalanced */\\n\\tint balance = getBalance(node);\\n\\n\\t// If this node becomes unbalanced, then\\n\\t// there are 4 cases\\n\\n\\t// Left Left Case\\n\\tif (balance > 1 && key < node->left->key)\\n\\t\\treturn rightRotate(node);\\n\\n\\t// Right Right Case\\n\\tif (balance < -1 && key > node->right->key)\\n\\t\\treturn leftRotate(node);\\n\\n\\t// Left Right Case\\n\\tif (balance > 1 && key > node->left->key)\\n\\t{\\n\\t\\tnode->left = leftRotate(node->left);\\n\\t\\treturn rightRotate(node);\\n\\t}\\n\\n\\t// Right Left Case\\n\\tif (balance < -1 && key < node->right->key)\\n\\t{\\n\\t\\tnode->right = rightRotate(node->right);\\n\\t\\treturn leftRotate(node);\\n\\t}\\n\\n\\t/* return the (unchanged) node pointer */\\n\\treturn node;\\n}\\n\\nbool check(struct Node* root, int val)\\n{\\n    if(root == NULL)\\n        return false;\\n    else\\n    {\\n        if(root->key == val)\\n            return true;\\n        else if(root->key < val)\\n            return check(root->right, val);\\n        else\\n            return check(root->left, val);\\n    }\\n}\\n\\nint max(int a, int b)\\n{\\n    return (a > b)? a: b;\\n}\\n\\nint min(int a, int b)\\n{\\n    return -max(-a, -b);\\n}\\n\\nvoid assign(int* assignments, int id, int* jobs, int k, int* ans)\\n{\\n    int i;\\n    if(id == -1)\\n    {\\n        int ret = INT_MIN;\\n        for(i = 0; i < k; i++)\\n            ret = max(ret, assignments[i]);\\n        *ans = min(*ans, ret);\\n        return;\\n    }\\n    else\\n    {\\n        struct Node* root = NULL;\\n        for(i = 0; i < k; i++)\\n        {\\n            assignments[i] += jobs[id];\\n            if(check(root, assignments[i]))\\n            {\\n                assignments[i] -= jobs[id];\\n                continue;\\n            }\\n            root = insert(root, assignments[i]);\\n            if(assignments[i] < *ans)\\n                assign(assignments, id - 1, jobs, k, ans);\\n            assignments[i] -= jobs[id];\\n        }\\n    }\\n}\\n\\nint comparator(const void* a, const void* b)\\n{\\n    return *((int*)a) - *((int*)b);\\n}\\n\\nint helper(int* jobs, int jobsSize, int k)\\n{\\n    int* assignments = (int*)calloc(k, sizeof(int));\\n    int i = jobsSize - 1, dir = -1;\\n    \\n    while(i >= 0)\\n    {\\n        int j = max(i - k + 1, 0);\\n        if(dir == -1)\\n        {\\n            int l, size = i - j + 1;\\n            for(l = 0; l < size; l++)\\n                assignments[l] += jobs[i - l];\\n        }\\n        else\\n        {\\n            int l, size = i - j + 1;\\n            for(l = 0; l < size; l++)\\n                assignments[size - 1 - l] += jobs[i - l];\\n        }\\n        i = j - 1;\\n        dir *= -1;\\n    }\\n    \\n    int ans = assignments[0];\\n    for(i = 1; i < k; i++)\\n        ans = max(ans, assignments[i]);\\n    \\n    return ans;\\n}\\n\\nint minimumTimeRequired(int* jobs, int jobsSize, int k)\\n{\\n    qsort(jobs, jobsSize, sizeof(int), comparator);\\n    int i;\\n    \\n    int ans = helper(jobs, jobsSize, k);\\n    int* assignments = (int*)calloc(k, sizeof(int));\\n   \\n    assign(assignments, jobsSize - 1, jobs, k, &ans);\\n    return ans;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1495384,
                "title": "ruby-100-100",
                "content": "```\\n# @param {Integer[]} jobs\\n# @param {Integer} k\\n# @return {Integer}\\ndef minimum_time_required(jobs, k)\\n  a = Array.new(k, 0)\\n  jobs.sort.reverse_each do |j|\\n    a[a.index(a.min)] += j\\n  end\\n  upper = a.max\\n  start = Array.new(k, 0)\\n  b = [start]\\n  jobs.each do |j|\\n    b = b.flat_map do |hist|\\n      hist.each_with_index.filter_map do |sz, i|\\n        sz += j\\n        next nil if sz >= upper\\n        t = hist.dup\\n        t[i] = sz\\n        t.sort\\n      end\\n    end.sort.uniq\\n  end\\n  b.map(&:max).min || upper\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} jobs\\n# @param {Integer} k\\n# @return {Integer}\\ndef minimum_time_required(jobs, k)\\n  a = Array.new(k, 0)\\n  jobs.sort.reverse_each do |j|\\n    a[a.index(a.min)] += j\\n  end\\n  upper = a.max\\n  start = Array.new(k, 0)\\n  b = [start]\\n  jobs.each do |j|\\n    b = b.flat_map do |hist|\\n      hist.each_with_index.filter_map do |sz, i|\\n        sz += j\\n        next nil if sz >= upper\\n        t = hist.dup\\n        t[i] = sz\\n        t.sort\\n      end\\n    end.sort.uniq\\n  end\\n  b.map(&:max).min || upper\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1494282,
                "title": "simple-but-somewhat-optimized-backtracking-solution-beating-95",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int const k) {\\n        k_ = k;\\n        numJobs_ = jobs.size();\\n\\t\\t// Optimization 1: try assigning jobs to workers in descending order\\n        sort(jobs.begin(), jobs.end(), greater<int>());\\n        jobs_ = jobs.data();\\n        workers_.resize(numJobs_);\\n        findOptimalAssignment(0);\\n        return minTime_;\\n    }\\nprivate:\\n    void findOptimalAssignment(int const job_idx) const {\\n        int max_time = workers_[0];\\n        for (int k = 1; k < k_; ++k) max_time = max(max_time, workers_[k]);\\n        if (job_idx == numJobs_) {\\n            minTime_ = min(minTime_, max_time);\\n        } else if (max_time < minTime_) {\\n            // Optimization 2: if the current solution is already sub-optimal, then stop\\n\\t\\t\\t// searching further along the current path.\\n            unordered_map<int, int> ws;\\n            ws.reserve(k_);\\n            for (int k = 0; k < k_; ++k) ws.emplace(workers_[k], k);\\n            // Optimization 3: if 2 workers have the exact same amount of workload, then\\n            // it won\\'t make a difference which one gets assigned the current job, so, just\\n            // try one of them and skip the rest.\\n            for (auto const& p : ws) {\\n                auto const k = p.second;\\n                auto& w = workers_[k];\\n                w += jobs_[job_idx];\\n                if (w < minTime_)\\n                    findOptimalAssignment(job_idx + 1);\\n                w -= jobs_[job_idx];\\n            }\\n        }\\n    }\\n    int k_{0};\\n    int numJobs_{0};\\n    int const* jobs_{nullptr};\\n    mutable int minTime_{numeric_limits<int>::max()};\\n    mutable vector<int> workers_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int const k) {\\n        k_ = k;\\n        numJobs_ = jobs.size();\\n\\t\\t// Optimization 1: try assigning jobs to workers in descending order\\n        sort(jobs.begin(), jobs.end(), greater<int>());\\n        jobs_ = jobs.data();\\n        workers_.resize(numJobs_);\\n        findOptimalAssignment(0);\\n        return minTime_;\\n    }\\nprivate:\\n    void findOptimalAssignment(int const job_idx) const {\\n        int max_time = workers_[0];\\n        for (int k = 1; k < k_; ++k) max_time = max(max_time, workers_[k]);\\n        if (job_idx == numJobs_) {\\n            minTime_ = min(minTime_, max_time);\\n        } else if (max_time < minTime_) {\\n            // Optimization 2: if the current solution is already sub-optimal, then stop\\n\\t\\t\\t// searching further along the current path.\\n            unordered_map<int, int> ws;\\n            ws.reserve(k_);\\n            for (int k = 0; k < k_; ++k) ws.emplace(workers_[k], k);\\n            // Optimization 3: if 2 workers have the exact same amount of workload, then\\n            // it won\\'t make a difference which one gets assigned the current job, so, just\\n            // try one of them and skip the rest.\\n            for (auto const& p : ws) {\\n                auto const k = p.second;\\n                auto& w = workers_[k];\\n                w += jobs_[job_idx];\\n                if (w < minTime_)\\n                    findOptimalAssignment(job_idx + 1);\\n                w -= jobs_[job_idx];\\n            }\\n        }\\n    }\\n    int k_{0};\\n    int numJobs_{0};\\n    int const* jobs_{nullptr};\\n    mutable int minTime_{numeric_limits<int>::max()};\\n    mutable vector<int> workers_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451811,
                "title": "javascript-2-solutions-dfs-memorization-dfs-memorization-binary-search",
                "content": "**1. DFS + Memorization**\\n```\\nvar minimumTimeRequired = function(jobs, k) {\\n    jobs.sort((b, a) => a - b);\\n\\n    let minWorkTime = Infinity,\\n        dp = Array(k).fill(0);\\n\\n    const dfs = (idx, max) => {\\n        if (max >= minWorkTime) {\\n            return;\\n        }\\n\\n        if (jobs.length === idx) {\\n            minWorkTime = max;\\n            return;\\n        }\\n\\n        let set = new Set();\\n\\n        for (let i = 0; i < k; i++) {\\n            if (set.has(dp[i]))\\n                continue;\\n            set.add(dp[i]);\\n            dp[i] += jobs[idx];\\n            dfs(idx + 1, Math.max(max, dp[i]));\\n            dp[i] -= jobs[idx];\\n        }\\n    };\\n    \\n    dfs(0, jobs[0]);\\n\\n    return minWorkTime;\\n};\\n```\\n**2. DFS + Memorization + Binary Search**\\n```\\nvar minimumTimeRequired = function(jobs, k) {\\n    jobs.sort((b, a) => a - b);\\n\\n    let l = jobs[0], r = jobs.reduce((acc, cur) => acc + cur),\\n        dp = Array(k);\\n\\n    const dfs = (idx) => {\\n        if (jobs.length === idx) {\\n            return true;\\n        }\\n\\n        let set = new Set();\\n\\n        for (let i = 0; i < k; i++) {\\n            if (set.has(dp[i]))\\n\\t\\t\\t\\tcontinue;\\n            set.add(dp[i]);\\n\\n            if (dp[i] >= jobs[idx]) {                \\n                dp[i] -= jobs[idx];\\n                if (dfs(idx + 1))\\n                    return true;\\n                dp[i] += jobs[idx];\\n            }\\n        }\\n\\n        return false;\\n    };\\n    \\n    while (l < r) {\\n        const mid = Math.trunc((l + r) / 2);\\n        dp.fill(mid);\\n        if (dfs(0))\\n            r = mid;\\n        else l = mid + 1;\\n    }\\n\\n    return l;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minimumTimeRequired = function(jobs, k) {\\n    jobs.sort((b, a) => a - b);\\n\\n    let minWorkTime = Infinity,\\n        dp = Array(k).fill(0);\\n\\n    const dfs = (idx, max) => {\\n        if (max >= minWorkTime) {\\n            return;\\n        }\\n\\n        if (jobs.length === idx) {\\n            minWorkTime = max;\\n            return;\\n        }\\n\\n        let set = new Set();\\n\\n        for (let i = 0; i < k; i++) {\\n            if (set.has(dp[i]))\\n                continue;\\n            set.add(dp[i]);\\n            dp[i] += jobs[idx];\\n            dfs(idx + 1, Math.max(max, dp[i]));\\n            dp[i] -= jobs[idx];\\n        }\\n    };\\n    \\n    dfs(0, jobs[0]);\\n\\n    return minWorkTime;\\n};\\n```\n```\\nvar minimumTimeRequired = function(jobs, k) {\\n    jobs.sort((b, a) => a - b);\\n\\n    let l = jobs[0], r = jobs.reduce((acc, cur) => acc + cur),\\n        dp = Array(k);\\n\\n    const dfs = (idx) => {\\n        if (jobs.length === idx) {\\n            return true;\\n        }\\n\\n        let set = new Set();\\n\\n        for (let i = 0; i < k; i++) {\\n            if (set.has(dp[i]))\\n\\t\\t\\t\\tcontinue;\\n            set.add(dp[i]);\\n\\n            if (dp[i] >= jobs[idx]) {                \\n                dp[i] -= jobs[idx];\\n                if (dfs(idx + 1))\\n                    return true;\\n                dp[i] += jobs[idx];\\n            }\\n        }\\n\\n        return false;\\n    };\\n    \\n    while (l < r) {\\n        const mid = Math.trunc((l + r) / 2);\\n        dp.fill(mid);\\n        if (dfs(0))\\n            r = mid;\\n        else l = mid + 1;\\n    }\\n\\n    return l;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1444548,
                "title": "weak-testcases",
                "content": "Weak Testcases\\n\\nEven if I\\'m not sorting array it is Accepting.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    int result = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int length = jobs.length;\\n        //Arrays.sort(jobs);\\n        backtrack(jobs, length - 1, new int [k]);\\n        return result;\\n    }\\n    \\n    public void backtrack(int [] jobs, int current, int [] workers) {\\n        if (current < 0) {\\n            result = Math.min(result, Arrays.stream(workers).max().getAsInt());\\n            return;\\n        }\\n        \\n        if (Arrays.stream(workers).max().getAsInt() >=  result)\\n            return;\\n        for (int i=0; i<workers.length; i++) {\\n            if (i > 0 && workers[i-1] == workers[i])\\n                continue;\\n            // make choice\\n            workers[i] += jobs[current];\\n            // backtrack\\n            backtrack(jobs, current-1, workers);\\n            // undo the choice\\n            workers[i] -= jobs[current];\\n        }\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int result = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int length = jobs.length;\\n        //Arrays.sort(jobs);\\n        backtrack(jobs, length - 1, new int [k]);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1248590,
                "title": "50-faster-solution",
                "content": "java code is:\\n# \\n```\\nclass Solution {\\n    int min=Integer.MAX_VALUE;\\n    void find(int i,int jobs[],int arr[],int max){\\n        if(i>=jobs.length)min=Math.min(min,max);\\n        if(max>=min)return ;\\n        // to Avoid same assignment for different workers\\n        Set<Integer>set=new HashSet<>();\\n        for(int k=0;k<arr.length;k++){\\n            if(!set.add(arr[k]))continue;\\n            arr[k]+=jobs[i];\\n            find(i+1,jobs,arr,Math.max(max,arr[k]));\\n            arr[k]-=jobs[i];\\n        }\\n        return ;\\n    }\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        Arrays.sort(jobs);\\n        if(k>=jobs.length)return jobs[jobs.length-1];\\n         find(0,jobs,new int[k],0);\\n        return min;\\n    }\\n}\\n```\\n**Please,Upvote if this is helpful**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int min=Integer.MAX_VALUE;\\n    void find(int i,int jobs[],int arr[],int max){\\n        if(i>=jobs.length)min=Math.min(min,max);\\n        if(max>=min)return ;\\n        // to Avoid same assignment for different workers\\n        Set<Integer>set=new HashSet<>();\\n        for(int k=0;k<arr.length;k++){\\n            if(!set.add(arr[k]))continue;\\n            arr[k]+=jobs[i];\\n            find(i+1,jobs,arr,Math.max(max,arr[k]));\\n            arr[k]-=jobs[i];\\n        }\\n        return ;\\n    }\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        Arrays.sort(jobs);\\n        if(k>=jobs.length)return jobs[jobs.length-1];\\n         find(0,jobs,new int[k],0);\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247601,
                "title": "two-codes-dp-solution-and-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> times;\\n    int L;\\n    int K;\\n    int inf = 12*1e7+1;\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        L = jobs.size();\\n        K = k;\\n        int len = (1<<L);\\n\\n        times.resize(len, 0);\\n        for(int i = 0; i < len; i++)\\n            for(int j = 0; j < L; j++)\\n                if((i >> j) & 1)\\n                    times[i] += jobs[j];\\n        \\n        vector<vector<int> > dp(K+1, vector<int>(len, inf));\\n        dp[0][0] = 0;\\n        // for(int n = 1; n <= K; n++)\\n        //     for(int i = 0; i < len; i++)\\n        //         // for(auto j: subsets[i])\\n        //         for(int j = 0; j < len; j++) if(i & j == 0)\\n        //             dp[n][i|j] = min(dp[n][i|j], max(dp[n-1][i], times[j]) );\\n        dp[0][0] = 0; for(int i = 0; i < len; i++) dp[1][i] = times[i];\\n        for(int n = 2; n <= K; n++)\\n            for(int i = 1; i < len; i++)\\n                for(int si = i; si; si = (si-1)&i)\\n                    dp[n][i] = min(dp[n][i], max(dp[n-1][i-si], times[si]));\\n        return dp[K][len-1];\\n    }\\n    \\n    int ans;\\n    vector<int> load;\\n    vector<int> jobss;\\n    bool dfs(int i){\\n        if(i == L){\\n            int x = 0;\\n            for(auto l: load) x = max(x, l);\\n            ans = min(ans, x);\\n            return true;\\n        }\\n        for(int j = 0; j < K; j++){\\n            if(jobss[i] + load[j] < ans){\\n                load[j] += jobss[i];\\n                dfs(i+1);\\n                load[j] -= jobss[i];\\n            }\\n            if(load[j] == 0) break;\\n        }\\n        return false;\\n    }\\n    int minimumTimeRequired2(vector<int>& jobs, int k) {\\n        L = jobs.size(); K = k;\\n        sort(jobs.begin(), jobs.end());\\n        reverse(jobs.begin(), jobs.end());\\n        jobss = jobs;\\n        ans = 0; for(auto j: jobs) ans += j;\\n        load.resize(K, 0);\\n        dfs(0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> times;\\n    int L;\\n    int K;\\n    int inf = 12*1e7+1;\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        L = jobs.size();\\n        K = k;\\n        int len = (1<<L);\\n\\n        times.resize(len, 0);\\n        for(int i = 0; i < len; i++)\\n            for(int j = 0; j < L; j++)\\n                if((i >> j) & 1)\\n                    times[i] += jobs[j];\\n        \\n        vector<vector<int> > dp(K+1, vector<int>(len, inf));\\n        dp[0][0] = 0;\\n        // for(int n = 1; n <= K; n++)\\n        //     for(int i = 0; i < len; i++)\\n        //         // for(auto j: subsets[i])\\n        //         for(int j = 0; j < len; j++) if(i & j == 0)\\n        //             dp[n][i|j] = min(dp[n][i|j], max(dp[n-1][i], times[j]) );\\n        dp[0][0] = 0; for(int i = 0; i < len; i++) dp[1][i] = times[i];\\n        for(int n = 2; n <= K; n++)\\n            for(int i = 1; i < len; i++)\\n                for(int si = i; si; si = (si-1)&i)\\n                    dp[n][i] = min(dp[n][i], max(dp[n-1][i-si], times[si]));\\n        return dp[K][len-1];\\n    }\\n    \\n    int ans;\\n    vector<int> load;\\n    vector<int> jobss;\\n    bool dfs(int i){\\n        if(i == L){\\n            int x = 0;\\n            for(auto l: load) x = max(x, l);\\n            ans = min(ans, x);\\n            return true;\\n        }\\n        for(int j = 0; j < K; j++){\\n            if(jobss[i] + load[j] < ans){\\n                load[j] += jobss[i];\\n                dfs(i+1);\\n                load[j] -= jobss[i];\\n            }\\n            if(load[j] == 0) break;\\n        }\\n        return false;\\n    }\\n    int minimumTimeRequired2(vector<int>& jobs, int k) {\\n        L = jobs.size(); K = k;\\n        sort(jobs.begin(), jobs.end());\\n        reverse(jobs.begin(), jobs.end());\\n        jobss = jobs;\\n        ans = 0; for(auto j: jobs) ans += j;\\n        load.resize(K, 0);\\n        dfs(0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162489,
                "title": "scala-backtracking-recursion",
                "content": "```\\n\\tvar min = Int.MaxValue\\n    def minimumTimeRequired(jobs: Array[Int], k: Int): Int = {\\n        min = Int.MaxValue\\n        val map = Array.ofDim[Int](k)\\n        getMinWorkingTime(0,jobs,k,map)\\n        min\\n    }\\n    \\n    \\n    def getMinWorkingTime(index:Int,jobs: Array[Int], k: Int,map:Array[Int]): Unit = {\\n        if(index == jobs.length){\\n            min = scala.math.min(min,map.max)    \\n        } else {\\n                val processed = Set[Int]()\\n                (0 until k).foreach{ worker =>\\n                    if(!processed.contains(map(worker)) && map(worker)+jobs(index) <= min) {\\n                        processed.add(map(worker))\\n                        map(worker) += jobs(index)\\n                        getMinWorkingTime(index+1,jobs,k,map)\\n                        map(worker) -= jobs(index)    \\n                    }\\n                }\\n        }\\n        \\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n\\tvar min = Int.MaxValue\\n    def minimumTimeRequired(jobs: Array[Int], k: Int): Int = {\\n        min = Int.MaxValue\\n        val map = Array.ofDim[Int](k)\\n        getMinWorkingTime(0,jobs,k,map)\\n        min\\n    }\\n    \\n    \\n    def getMinWorkingTime(index:Int,jobs: Array[Int], k: Int,map:Array[Int]): Unit = {\\n        if(index == jobs.length){\\n            min = scala.math.min(min,map.max)    \\n        } else {\\n                val processed = Set[Int]()\\n                (0 until k).foreach{ worker =>\\n                    if(!processed.contains(map(worker)) && map(worker)+jobs(index) <= min) {\\n                        processed.add(map(worker))\\n                        map(worker) += jobs(index)\\n                        getMinWorkingTime(index+1,jobs,k,map)\\n                        map(worker) -= jobs(index)    \\n                    }\\n                }\\n        }\\n        \\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1082948,
                "title": "java-simple-branch-and-bound",
                "content": "```\\n\\tpublic int minimumTimeRequired(int[] jobs, int k) {\\n        if(jobs.length==1) return jobs[0];\\n        if(jobs.length==2){\\n            if(k==2) return Math.max(jobs[0],jobs[1]);\\n            return jobs[0]+jobs[1];\\n        }\\n        if(k==jobs.length){\\n            int oneMax= jobs[0];\\n            for(int num: jobs) oneMax= Math.max(oneMax,num);\\n            return oneMax;\\n        }\\n        Arrays.sort(jobs);\\n        long[] max= new long[1];\\n        for(int num: jobs) max[0]+= num;\\n        if(k==1) return (int)max[0];\\n        max[0]-= jobs[0];\\n        if(k>2) max[0]-= jobs[1];\\n        long[] workersTime= new long[k];\\n        long currMax= 0;\\n        calculateMinTime(jobs,max,workersTime,0,currMax);\\n        return (int)max[0];\\n    }\\n    public void calculateMinTime(int[] jobs,long[] max,long[] workersTime,int jobIndex,long currMax){\\n        for(int i=0; i<workersTime.length; i++){\\n            //It doesnot matter which worker gets max time jobs\\n            if(jobIndex+1==i) return;   //Most important for bounding branches\\n            if(workersTime[i]+jobs[jobIndex]>=max[0]) continue;\\n            if(jobIndex==jobs.length-1){\\n                max[0]= Math.max(currMax,workersTime[i]+jobs[jobIndex]);\\n                continue;\\n            }\\n            workersTime[i]+= jobs[jobIndex];\\n            calculateMinTime(jobs,max,workersTime,jobIndex+1,Math.max(currMax,workersTime[i]));\\n            workersTime[i]-= jobs[jobIndex];\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minimumTimeRequired(int[] jobs, int k) {\\n        if(jobs.length==1) return jobs[0];\\n        if(jobs.length==2){\\n            if(k==2) return Math.max(jobs[0],jobs[1]);\\n            return jobs[0]+jobs[1];\\n        }\\n        if(k==jobs.length){\\n            int oneMax= jobs[0];\\n            for(int num: jobs) oneMax= Math.max(oneMax,num);\\n            return oneMax;\\n        }\\n        Arrays.sort(jobs);\\n        long[] max= new long[1];\\n        for(int num: jobs) max[0]+= num;\\n        if(k==1) return (int)max[0];\\n        max[0]-= jobs[0];\\n        if(k>2) max[0]-= jobs[1];\\n        long[] workersTime= new long[k];\\n        long currMax= 0;\\n        calculateMinTime(jobs,max,workersTime,0,currMax);\\n        return (int)max[0];\\n    }\\n    public void calculateMinTime(int[] jobs,long[] max,long[] workersTime,int jobIndex,long currMax){\\n        for(int i=0; i<workersTime.length; i++){\\n            //It doesnot matter which worker gets max time jobs\\n            if(jobIndex+1==i) return;   //Most important for bounding branches\\n            if(workersTime[i]+jobs[jobIndex]>=max[0]) continue;\\n            if(jobIndex==jobs.length-1){\\n                max[0]= Math.max(currMax,workersTime[i]+jobs[jobIndex]);\\n                continue;\\n            }\\n            workersTime[i]+= jobs[jobIndex];\\n            calculateMinTime(jobs,max,workersTime,jobIndex+1,Math.max(currMax,workersTime[i]));\\n            workersTime[i]-= jobs[jobIndex];\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1076952,
                "title": "dfs-with-greedy-as-upper-bound",
                "content": "greedy is upper bound of optimal.\\nuse it as pruning boundary for dfs.  break dfs when its cost goes higher than upper bound\\n```\\nclass Solution {\\npublic:\\n    int findmin(vector<int>& bucket){\\n        int minw = bucket[0];\\n        int minid = 0;\\n        for(int i=1; i< bucket.size();i++){\\n            if (bucket[i] < minw){\\n                minw = bucket[i];\\n                minid = i;\\n            }\\n        }\\n        return minid;\\n    }\\n    int dfs(int j, int k, int maxlimit, int curmax, vector<int> bucket, vector<int>&jobs){\\n        int jw = jobs[j];\\n        int bwei = bucket[k];\\n        if(bwei+jw > maxlimit) {\\n            return maxlimit+1;\\n        }\\n        if (j==jobs.size()-1){\\n            bucket[k] = bwei+jw;\\n            if(curmax < bucket[k]) curmax = bucket[k];\\n            if(maxlimit > curmax) maxlimit = curmax;\\n            return curmax;\\n        }\\n        bucket[k] = bwei+jw;\\n        if(curmax < bucket[k]) curmax = bucket[k];\\n        auto retw = maxlimit;\\n        \\n        bool b0flag = false;\\n        for(int i =0; i<bucket.size(); i++){\\n            if(b0flag && bucket[i]==0) continue;\\n            if(bucket[i]==0) b0flag = true;\\n            auto tmpw = dfs(j+1, i, maxlimit, curmax, bucket, jobs);\\n            if(tmpw < retw) retw = tmpw;\\n        }\\n        //printf(\"j=%d, k=%d, retw=%d\\\\n\", j, k, retw);\\n        bucket[k] = bwei;\\n        return retw;\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(jobs.begin(), jobs.end(), [](int a, int b){return a>b;});\\n        vector<int> bucket1;\\n        for(int i=0;i<k;i++) bucket1.push_back(0);\\n        \\n        for(auto j : jobs){\\n            auto buckid = findmin(bucket1);\\n            bucket1[buckid] += j;\\n        }\\n        \\n        int maxw = 0;\\n        for(auto b : bucket1){\\n            if (b>maxw) maxw=b;\\n        }\\n        \\n        \\n        vector<int> bucket;\\n        for(int i=0; i<k;i++) bucket.push_back(0);\\n        int res = 1e9;\\n        res = dfs(0, 0, maxw, 0, bucket, jobs);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findmin(vector<int>& bucket){\\n        int minw = bucket[0];\\n        int minid = 0;\\n        for(int i=1; i< bucket.size();i++){\\n            if (bucket[i] < minw){\\n                minw = bucket[i];\\n                minid = i;\\n            }\\n        }\\n        return minid;\\n    }\\n    int dfs(int j, int k, int maxlimit, int curmax, vector<int> bucket, vector<int>&jobs){\\n        int jw = jobs[j];\\n        int bwei = bucket[k];\\n        if(bwei+jw > maxlimit) {\\n            return maxlimit+1;\\n        }\\n        if (j==jobs.size()-1){\\n            bucket[k] = bwei+jw;\\n            if(curmax < bucket[k]) curmax = bucket[k];\\n            if(maxlimit > curmax) maxlimit = curmax;\\n            return curmax;\\n        }\\n        bucket[k] = bwei+jw;\\n        if(curmax < bucket[k]) curmax = bucket[k];\\n        auto retw = maxlimit;\\n        \\n        bool b0flag = false;\\n        for(int i =0; i<bucket.size(); i++){\\n            if(b0flag && bucket[i]==0) continue;\\n            if(bucket[i]==0) b0flag = true;\\n            auto tmpw = dfs(j+1, i, maxlimit, curmax, bucket, jobs);\\n            if(tmpw < retw) retw = tmpw;\\n        }\\n        //printf(\"j=%d, k=%d, retw=%d\\\\n\", j, k, retw);\\n        bucket[k] = bwei;\\n        return retw;\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        sort(jobs.begin(), jobs.end(), [](int a, int b){return a>b;});\\n        vector<int> bucket1;\\n        for(int i=0;i<k;i++) bucket1.push_back(0);\\n        \\n        for(auto j : jobs){\\n            auto buckid = findmin(bucket1);\\n            bucket1[buckid] += j;\\n        }\\n        \\n        int maxw = 0;\\n        for(auto b : bucket1){\\n            if (b>maxw) maxw=b;\\n        }\\n        \\n        \\n        vector<int> bucket;\\n        for(int i=0; i<k;i++) bucket.push_back(0);\\n        int res = 1e9;\\n        res = dfs(0, 0, maxw, 0, bucket, jobs);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065633,
                "title": "just-dfs-with-backtracking-c-with-pruning",
                "content": "The essence of this question to avoid TLE is that, \\n1. we dont care which idle worker is assigned the task. As long as an idle worker is assgiend by a task, then we break \\n1. as long as the remained idle work numbers are >= remained unassigned jobs, then we play greedily to assign each remained task to each idle worker\\n\\n```\\n    class Solution {\\n\\n    int min_res{INT_MAX};\\n    int max_job{0};\\n    void f(int idx, vector<int> *vec, vector<int> *jobs, int min, int used)\\n    {\\n        \\n        if (idx == jobs->size())\\n        {\\n            this->min_res = std::min(min, this->min_res);\\n            return;\\n        }\\n        if (jobs->size() - idx <= vec->size() - used)\\n        {\\n    \\n            f(jobs->size(), vec, jobs, std::max(min, this->max_job), used);\\n            return;\\n        }\\n\\n        const int& cv = jobs->at(idx);\\n        for (int i = 0; i < vec->size(); i++)\\n        {\\n            vec->at(i) += cv;\\n            f(idx + 1, vec, jobs, std::max(min, vec->at(i)), (vec->at(i) == cv) ? used + 1 : used);\\n            vec->at(i) -= cv;\\n             if(vec->at(i)==0) break;\\n        }\\n    }\\n\\npublic:\\n    int minimumTimeRequired(vector<int> &jobs, int k)\\n    {\\n        if (k == 0)\\n            return this->min_res;\\n        this->max_job = *(std::max_element(jobs.begin(), jobs.end()));\\n        if (k == 1)\\n            return std::accumulate(jobs.begin(), jobs.end(), 0);\\n     \\n  \\n        vector<int> vec(k, 0);\\n        f(0, &vec, &jobs, 0, 0);\\n        return this->min_res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    class Solution {\\n\\n    int min_res{INT_MAX};\\n    int max_job{0};\\n    void f(int idx, vector<int> *vec, vector<int> *jobs, int min, int used)\\n    {\\n        \\n        if (idx == jobs->size())\\n        {\\n            this->min_res = std::min(min, this->min_res);\\n            return;\\n        }\\n        if (jobs->size() - idx <= vec->size() - used)\\n        {\\n    \\n            f(jobs->size(), vec, jobs, std::max(min, this->max_job), used);\\n            return;\\n        }\\n\\n        const int& cv = jobs->at(idx);\\n        for (int i = 0; i < vec->size(); i++)\\n        {\\n            vec->at(i) += cv;\\n            f(idx + 1, vec, jobs, std::max(min, vec->at(i)), (vec->at(i) == cv) ? used + 1 : used);\\n            vec->at(i) -= cv;\\n             if(vec->at(i)==0) break;\\n        }\\n    }\\n\\npublic:\\n    int minimumTimeRequired(vector<int> &jobs, int k)\\n    {\\n        if (k == 0)\\n            return this->min_res;\\n        this->max_job = *(std::max_element(jobs.begin(), jobs.end()));\\n        if (k == 1)\\n            return std::accumulate(jobs.begin(), jobs.end(), 0);\\n     \\n  \\n        vector<int> vec(k, 0);\\n        f(0, &vec, &jobs, 0, 0);\\n        return this->min_res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030557,
                "title": "simpliest-java-solution-2ms",
                "content": "```\\nAlgorithm idea:\\n1. Backtracking\\n2. Reverse Sorting\\n3. Minimising calls using what we have already seen\\n```class Solution {\\n    int[] DP;\\n    int Min;\\n    boolean Reached;\\n\\t//Use this boolean variable so that I can avoid going deeper into calls which will DEFINITELY be not my answer.\\n\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        DP = new int[k];\\n        Min = Integer.MAX_VALUE;\\n        Reached = false;\\n        Arrays.sort(jobs);\\n\\t\\t//Why reverse??\\n\\t\\t//So that the worst case is reached sooner than later, \\n\\t\\t//the worker who takes the most time will be identified first and that will reduce the number of calls by using a boolean\\n        int j=jobs.length-1;\\n        int i=0;\\n        while(i<=j){\\n            int temp = jobs[i];\\n            jobs[i] = jobs[j];\\n            jobs[j] = temp;\\n            i++;\\n            j--;\\n        }\\n        Recur(jobs,0,k,Integer.MIN_VALUE);\\n        return Min;\\n        \\n    }\\n    \\n    \\n    public void Recur(int[] jobs,int index,int k,int Max){\\n        if(jobs.length>index){\\n            int val = jobs[index];\\n            HashMap<Integer,Integer> Map = new HashMap<>(); //even if you dont use it your solution will be accepted but takes 1000 ms.\\n            for(int i=0;i<k;i++){\\n                if(Map.containsKey(DP[i])) continue; //Adding val to a DP[i] value previous seen just repeats the same call, so it is not required!\\n                Map.put(DP[i],1);\\n                DP[i]=DP[i]+val;\\n                \\n                int temp = Max;\\n                if(Max<DP[i]){\\n                    temp = Max;\\n                    Max = DP[i];\\n                }\\n                \\n                if(Reached && Max>=Min){\\n\\t\\t\\t\\t//If the max higher than the minimum value we already have so it cannot be our answer.\\n                    if(Max == DP[i]){\\n                        Max = temp;\\n                    }\\n                    DP[i]=DP[i]-val; \\n                }\\n                else{\\n                    Recur(jobs,index+1,k,Max);\\n                    if(Max == DP[i]){\\n                        Max = temp;\\n                    }\\n                    DP[i]=DP[i]-val;\\n                }\\n                 \\n            }\\n        }\\n        else if(index==jobs.length){\\n            Min = Math.min(Min,Max);\\n            Reached = true;\\n            return;\\n        }\\n        return;\\n    }\\n}\\nIntuition: Side k is small, I thought backtracking should work out but I believe there are better answers out there.",
                "solutionTags": [],
                "code": "```\\nAlgorithm idea:\\n1. Backtracking\\n2. Reverse Sorting\\n3. Minimising calls using what we have already seen\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1023057,
                "title": "record-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    static int clz(int a){\\n        int zeros = 0;\\n        zeros += !(a & 0xffff0000) << 4;\\n        zeros += !((a << zeros) & 0xff000000) << 3;\\n        zeros += !((a << zeros) & 0xf0000000) << 2;\\n        zeros += !((a << zeros) & 0xc0000000) << 1;\\n        zeros += !((a << zeros) & 0x80000000);\\n        return zeros;\\n    }\\n    \\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size();\\n        int dp[k + 1][1 << n];\\n        dp[1][0] = 0;\\n        for(int i = 1; i < (1 << n); i++){\\n            int lz = clz(i);\\n            int set = (0x80000000 >> lz) ^ i;\\n            dp[1][i] = dp[1][set] + jobs[31 - lz];\\n        }\\n        \\n        for(int i = 2; i <= k; i++){\\n            for(int j = -1, minval = INT_MAX; ++j < (1 << n); minval = INT_MAX){\\n                for(int z = j; z; z = (z - 1) & j)\\n                    minval = min(minval, max(dp[i - 1][z], dp[1][j ^ z]));\\n                dp[i][j] = minval;\\n            }\\n        }\\n        return dp[k][(1 << n) - 1];\\n    }\\n};\\n```\\n\\nBetter way to count leading zeros\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size();\\n        int dp[k + 1][1 << n];\\n        dp[1][0] = 0;\\n        for(int i = 1, lz = 32; i < (1 << n); i++){\\n            lz -= (i & -i) == i;\\n            int set = (0x80000000 >> lz) ^ i;\\n            dp[1][i] = dp[1][set] + jobs[31 - lz];\\n        }\\n        \\n        for(int i = 2; i <= k; i++){\\n            for(int j = -1, minval = INT_MAX; ++j < (1 << n); minval = INT_MAX){\\n                for(int z = j; z; z = (z - 1) & j)\\n                    minval = min(minval, max(dp[i - 1][z], dp[1][j ^ z]));\\n                dp[i][j] = minval;\\n            }\\n        }\\n        return dp[k][(1 << n) - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static int clz(int a){\\n        int zeros = 0;\\n        zeros += !(a & 0xffff0000) << 4;\\n        zeros += !((a << zeros) & 0xff000000) << 3;\\n        zeros += !((a << zeros) & 0xf0000000) << 2;\\n        zeros += !((a << zeros) & 0xc0000000) << 1;\\n        zeros += !((a << zeros) & 0x80000000);\\n        return zeros;\\n    }\\n    \\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size();\\n        int dp[k + 1][1 << n];\\n        dp[1][0] = 0;\\n        for(int i = 1; i < (1 << n); i++){\\n            int lz = clz(i);\\n            int set = (0x80000000 >> lz) ^ i;\\n            dp[1][i] = dp[1][set] + jobs[31 - lz];\\n        }\\n        \\n        for(int i = 2; i <= k; i++){\\n            for(int j = -1, minval = INT_MAX; ++j < (1 << n); minval = INT_MAX){\\n                for(int z = j; z; z = (z - 1) & j)\\n                    minval = min(minval, max(dp[i - 1][z], dp[1][j ^ z]));\\n                dp[i][j] = minval;\\n            }\\n        }\\n        return dp[k][(1 << n) - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size();\\n        int dp[k + 1][1 << n];\\n        dp[1][0] = 0;\\n        for(int i = 1, lz = 32; i < (1 << n); i++){\\n            lz -= (i & -i) == i;\\n            int set = (0x80000000 >> lz) ^ i;\\n            dp[1][i] = dp[1][set] + jobs[31 - lz];\\n        }\\n        \\n        for(int i = 2; i <= k; i++){\\n            for(int j = -1, minval = INT_MAX; ++j < (1 << n); minval = INT_MAX){\\n                for(int z = j; z; z = (z - 1) & j)\\n                    minval = min(minval, max(dp[i - 1][z], dp[1][j ^ z]));\\n                dp[i][j] = minval;\\n            }\\n        }\\n        return dp[k][(1 << n) - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015896,
                "title": "c-using-backtracking-3-prunes-4-ms",
                "content": "```\\nclass Solution {\\n    int s = 0;\\n    int worker = 0;\\n    int ans = INT_MAX;\\n    \\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        s = jobs.size();\\n        worker = k;\\n        \\n        // Assigning time taking jobs first\\n        // Prune 1\\n        sort(jobs.begin(), jobs.end(), greater<int>());\\n        \\n        // for each job we have k options to choose from\\n        vector<int> w(worker, 0);\\n        wrapper(jobs, 0, w);\\n        \\n        return ans;\\n    }\\n    \\n    void wrapper(vector<int>& jobs, int jobNum, vector<int>& w) {\\n        \\n        if(jobNum == s) {\\n            \\n            // Update the ans\\n            int k = INT_MIN;\\n            for(auto a: w) k = max(a, k);\\n            ans = min(ans, k);\\n            return;\\n            \\n        } else {\\n           \\n            for(int i = 0; i<worker; i++) {\\n                \\n                // Prune 3\\n                // Dont go forward if the work load >= current ans\\n\\t\\t\\t\\t// If two or more workers have the same working time, we only need to consider one of them\\n                int k = INT_MIN;\\n                for(auto a: w) k = max(a, k);\\n                \\n                if(k < ans) {\\n                    w[i] += jobs[jobNum];\\n                    wrapper(jobs, jobNum+1, w);\\n                    w[i] -= jobs[jobNum];\\n                }\\n                \\n                // Prune 2\\n                // Assign a task to a totally free worker only once\\n                if(w[i] == 0) break; \\n            }\\n        }\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    int s = 0;\\n    int worker = 0;\\n    int ans = INT_MAX;\\n    \\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        s = jobs.size();\\n        worker = k;\\n        \\n        // Assigning time taking jobs first\\n        // Prune 1\\n        sort(jobs.begin(), jobs.end(), greater<int>());\\n        \\n        // for each job we have k options to choose from\\n        vector<int> w(worker, 0);\\n        wrapper(jobs, 0, w);\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1014823,
                "title": "can-anyone-optimize-my-code-i-am-getting-tle-even-using-dp-with-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[13][1<<12];\\n    int sum[1<<12];\\n    int n;\\n    int solve(vector<int> &jobs,int k,int mask,int x)\\n    {\\n        if(x>k && mask==0)\\n            return 0;\\n        if(mask==0 && x<=k)\\n            return -1;\\n        if(mask!=0 && x>k)\\n            return INT_MAX;\\n        if(dp[x][mask]!=-1)\\n            return dp[x][mask];\\n        int ans=INT_MAX;\\n        for(int b=1;b<(1<<n);b++)\\n        {\\n            if((b&mask)==b)\\n            {\\n\\t\\t\\t    sum[b]=0;\\n                for(int i=0;i<n;i++)\\n               {\\n                   if((1<<i) &b)\\n                    sum[b]+=jobs[i];\\n                }\\n                int ret=max(sum[b],solve(jobs,k,(mask^b),x+1));\\n                ans=min(ans,ret);\\n            }\\n        }\\n        dp[x][mask]=ans;\\n        return ans;\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        memset(dp,-1,sizeof dp);\\n        n=jobs.size();\\n        int ans=solve(jobs,k,(1<<n)-1,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[13][1<<12];\\n    int sum[1<<12];\\n    int n;\\n    int solve(vector<int> &jobs,int k,int mask,int x)\\n    {\\n        if(x>k && mask==0)\\n            return 0;\\n        if(mask==0 && x<=k)\\n            return -1;\\n        if(mask!=0 && x>k)\\n            return INT_MAX;\\n        if(dp[x][mask]!=-1)\\n            return dp[x][mask];\\n        int ans=INT_MAX;\\n        for(int b=1;b<(1<<n);b++)\\n        {\\n            if((b&mask)==b)\\n            {\\n\\t\\t\\t    sum[b]=0;\\n                for(int i=0;i<n;i++)\\n               {\\n                   if((1<<i) &b)\\n                    sum[b]+=jobs[i];\\n                }\\n                int ret=max(sum[b],solve(jobs,k,(mask^b),x+1));\\n                ans=min(ans,ret);\\n            }\\n        }\\n        dp[x][mask]=ans;\\n        return ans;\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        memset(dp,-1,sizeof dp);\\n        n=jobs.size();\\n        int ans=solve(jobs,k,(1<<n)-1,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014440,
                "title": "python-simple-dp-dfs-without-binary-search-56ms",
                "content": "Idea 1: Use the sorted work distribution as the key to store the result in a cache. And skip the search if certain combination has been searched. For example, `{worker_A = 3, worker_B = 4}` is the same as `{worker_A = 4, worker_B = 3}`.\\nIdea 2: Skip the search when the job you add to worker x will make it exceed the current known best minimum time spent.\\n```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        self.jobs = sorted(jobs, reverse=True)\\n        self.workers = k\\n        self.cache = set()\\n        self.min_time = sum(jobs)\\n        self.n_jobs = len(jobs)\\n        self.dfs([0,] * k, 0)\\n        return self.min_time\\n\\n    def dfs(self, occupy, i_job):\\n        if i_job == self.n_jobs:\\n            self.min_time = min(max(occupy), self.min_time)\\n            return \\n\\t\\t# same combination won\\'t be search again\\n        occupy = sorted(occupy)\\n        key = tuple(occupy + [i_job])\\n        if key in self.cache:\\n            return\\n\\t\\t# search all possible workers\\n        job_time = self.jobs[i_job]\\n        for i in range(self.workers):\\n\\t\\t    # skip cases that are worse than current known minimum\\n            if occupy[i] + job_time < self.min_time:\\n                occupy[i] += job_time\\n                self.dfs(occupy, i_job + 1)\\n                occupy[i] -= job_time\\n        self.cache.add(key)\\n        return\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        self.jobs = sorted(jobs, reverse=True)\\n        self.workers = k\\n        self.cache = set()\\n        self.min_time = sum(jobs)\\n        self.n_jobs = len(jobs)\\n        self.dfs([0,] * k, 0)\\n        return self.min_time\\n\\n    def dfs(self, occupy, i_job):\\n        if i_job == self.n_jobs:\\n            self.min_time = min(max(occupy), self.min_time)\\n            return \\n\\t\\t# same combination won\\'t be search again\\n        occupy = sorted(occupy)\\n        key = tuple(occupy + [i_job])\\n        if key in self.cache:\\n            return\\n\\t\\t# search all possible workers\\n        job_time = self.jobs[i_job]\\n        for i in range(self.workers):\\n\\t\\t    # skip cases that are worse than current known minimum\\n            if occupy[i] + job_time < self.min_time:\\n                occupy[i] += job_time\\n                self.dfs(occupy, i_job + 1)\\n                occupy[i] -= job_time\\n        self.cache.add(key)\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012143,
                "title": "javascript-dp-mask-with-binary-search",
                "content": "```\\nlet sum, mask, n;\\nconst minimumTimeRequired = (jobs, k) => {\\n    n = jobs.length;\\n    mask = 1 << n;\\n    sum = Array(mask).fill(0);\\n    for (let i = 1; i < mask; i++) {\\n        sum[i] = sum[i & i - 1] + jobs[numberOfTrailingZeros(i)];\\n    }\\n\\t/* OR\\n\\tfor (let s = 0; s < mask; s++) {\\n        for (let i = 0; i < n; i++) {\\n            if ((s >> i) & 1) {\\n                sum[s] += jobs[i];\\n            }\\n        }\\n    }\\n\\t*/\\n    let low = 0;\\n    let high = 1e9;\\n    while (high - low > 1) {\\n        let m = high + low >> 1;\\n        if (ok(m, k)) {\\n            high = m;\\n        } else {\\n            low = m;\\n        }\\n    }\\n    return high;\\n};\\n\\nconst ok = (m, k) => {\\n    let dp = Array(mask).fill(1e9 - 1);\\n    dp[0] = 0;\\n    for (let i = 1; i < mask; i++) {\\n        for (let j = i; j > 0; j = j - 1 & i) {\\n            if (sum[j] <= m) {\\n                dp[i] = Math.min(dp[i], dp[i ^ j] + 1);\\n            }\\n        }\\n    }\\n    return dp[mask - 1] <= k;\\n};\\n\\n// From Java Interger Class\\nconst numberOfTrailingZeros = (i) => {\\n    let y;\\n    if (i == 0) return 32;\\n    let n = 31;\\n    y = i << 16; if (y != 0) { n = n - 16; i = y; }\\n    y = i << 8; if (y != 0) { n = n - 8; i = y; }\\n    y = i << 4; if (y != 0) { n = n - 4; i = y; }\\n    y = i << 2; if (y != 0) { n = n - 2; i = y; }\\n    return n - ((i << 1) >>> 31);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet sum, mask, n;\\nconst minimumTimeRequired = (jobs, k) => {\\n    n = jobs.length;\\n    mask = 1 << n;\\n    sum = Array(mask).fill(0);\\n    for (let i = 1; i < mask; i++) {\\n        sum[i] = sum[i & i - 1] + jobs[numberOfTrailingZeros(i)];\\n    }\\n\\t/* OR\\n\\tfor (let s = 0; s < mask; s++) {\\n        for (let i = 0; i < n; i++) {\\n            if ((s >> i) & 1) {\\n                sum[s] += jobs[i];\\n            }\\n        }\\n    }\\n\\t*/\\n    let low = 0;\\n    let high = 1e9;\\n    while (high - low > 1) {\\n        let m = high + low >> 1;\\n        if (ok(m, k)) {\\n            high = m;\\n        } else {\\n            low = m;\\n        }\\n    }\\n    return high;\\n};\\n\\nconst ok = (m, k) => {\\n    let dp = Array(mask).fill(1e9 - 1);\\n    dp[0] = 0;\\n    for (let i = 1; i < mask; i++) {\\n        for (let j = i; j > 0; j = j - 1 & i) {\\n            if (sum[j] <= m) {\\n                dp[i] = Math.min(dp[i], dp[i ^ j] + 1);\\n            }\\n        }\\n    }\\n    return dp[mask - 1] <= k;\\n};\\n\\n// From Java Interger Class\\nconst numberOfTrailingZeros = (i) => {\\n    let y;\\n    if (i == 0) return 32;\\n    let n = 31;\\n    y = i << 16; if (y != 0) { n = n - 16; i = y; }\\n    y = i << 8; if (y != 0) { n = n - 8; i = y; }\\n    y = i << 4; if (y != 0) { n = n - 4; i = y; }\\n    y = i << 2; if (y != 0) { n = n - 2; i = y; }\\n    return n - ((i << 1) >>> 31);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1011252,
                "title": "bfs-dfs-with-pruning-on-repeat",
                "content": "This is the basic BFS with DFS inside, but DFS can still take too long.\\nI apply a pruning in this this: \\n1) for each piece of work, you only want to assign it once to thea worker with a given remaining capacity (similar to Optimization #2 in https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1010057/Python-Binary-search-24ms)\\n2) using capacity to existing early so that the DFS will not get too far\\n\\n```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        maxt = sum(jobs)\\n        jobs.sort(reverse=True)\\n        print(jobs)\\n        \\n        def dfs(h, i, cap):\\n            if i == len(jobs): return True\\n            job = jobs[i]\\n            for j in range(k):\\n                prev_j = h.index(h[j]) # avoid repeated work\\n                if prev_j == j and h[j] + job <= cap:\\n                    h[j] += job\\n                    x = dfs(h, i+1, cap)\\n                    if x:\\n                        return True\\n                    h[j] -= job\\n            return False\\n            \\n        def can_do(cap):\\n            h = [0] * k \\n            return dfs(h, 0, cap)\\n        \\n        left = max(jobs)-1\\n        right = sum(jobs)\\n        while left < right:\\n            mid = (left+right)//2\\n            # print(\"mid:\", mid)\\n            if can_do(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        maxt = sum(jobs)\\n        jobs.sort(reverse=True)\\n        print(jobs)\\n        \\n        def dfs(h, i, cap):\\n            if i == len(jobs): return True\\n            job = jobs[i]\\n            for j in range(k):\\n                prev_j = h.index(h[j]) # avoid repeated work\\n                if prev_j == j and h[j] + job <= cap:\\n                    h[j] += job\\n                    x = dfs(h, i+1, cap)\\n                    if x:\\n                        return True\\n                    h[j] -= job\\n            return False\\n            \\n        def can_do(cap):\\n            h = [0] * k \\n            return dfs(h, 0, cap)\\n        \\n        left = max(jobs)-1\\n        right = sum(jobs)\\n        while left < right:\\n            mid = (left+right)//2\\n            # print(\"mid:\", mid)\\n            if can_do(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010277,
                "title": "heap-based-solution-48-56-passed-can-someone-help",
                "content": "```import heapq\\nimport sys\\n\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        jobs_new = [-1*a for a in jobs]\\n        heapq.heapify(jobs_new)\\n        \\n        times = [0]*k\\n        \\n        while (len(jobs_new) != 0):\\n            curr_job = -1*heapq.heappop(jobs_new)\\n            min_w = sys.maxsize\\n            min_ind = -1\\n            for i in range(k):\\n                w = times[i]\\n                if w < min_w:\\n                    min_w = w\\n                    min_ind = i\\n            \\n            times[min_ind] += curr_job\\n        \\n        return max(times)\\n\\t\\t\\n\\t```\\n\\t\\n\\tSo I have this code that uses heap and works for most of the test cases. But not sure how I would fix it work for all. Can someone help?",
                "solutionTags": [],
                "code": "```import heapq\\nimport sys\\n\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        jobs_new = [-1*a for a in jobs]\\n        heapq.heapify(jobs_new)\\n        \\n        times = [0]*k\\n        \\n        while (len(jobs_new) != 0):\\n            curr_job = -1*heapq.heappop(jobs_new)\\n            min_w = sys.maxsize\\n            min_ind = -1\\n            for i in range(k):\\n                w = times[i]\\n                if w < min_w:\\n                    min_w = w\\n                    min_ind = i\\n            \\n            times[min_ind] += curr_job\\n        \\n        return max(times)\\n\\t\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1010276,
                "title": "c-concise-dp-with-bit-subset-trick",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int a[13][1<<12]{};\\n        for(int i = 1; i < 13; i++) for(auto& x : a[i]) x = INT_MAX;\\n        a[1][0] = 0;\\n        for(int i = 0; i < jobs.size(); i++) a[1][1 << i] = jobs[i];\\n        for(int i = 1; i <= k; i++) {\\n            for(int j = 1; j < (1 << jobs.size()); j++) {\\n                if(i == 1) a[i][j] = a[i][j - (j & -j)] + a[i][j & -j];\\n                else\\n                    for(int k = j; k; k = (k - 1)&j) {\\n                        a[i][j] = min(a[i][j], max(a[1][k], a[i - 1][j - k]));\\n                    }\\n            }\\n        }\\n        return a[k][(1<<jobs.size()) - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int a[13][1<<12]{};\\n        for(int i = 1; i < 13; i++) for(auto& x : a[i]) x = INT_MAX;\\n        a[1][0] = 0;\\n        for(int i = 0; i < jobs.size(); i++) a[1][1 << i] = jobs[i];\\n        for(int i = 1; i <= k; i++) {\\n            for(int j = 1; j < (1 << jobs.size()); j++) {\\n                if(i == 1) a[i][j] = a[i][j - (j & -j)] + a[i][j & -j];\\n                else\\n                    for(int k = j; k; k = (k - 1)&j) {\\n                        a[i][j] = min(a[i][j], max(a[1][k], a[i - 1][j - k]));\\n                    }\\n            }\\n        }\\n        return a[k][(1<<jobs.size()) - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010218,
                "title": "bitmask-dp",
                "content": "```\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int n = jobs.length, mask = 1<<n, vals[] = new int[mask], dp[];\\n        for(int picks = 1; picks < mask; ++picks){\\n            vals[picks] = vals[picks^(picks&-picks)]+jobs[(31-Integer.numberOfLeadingZeros(picks&-picks))];\\n        }\\n        dp = vals;\\n        for(int i = 1; i < k; ++i){\\n            var nextDp = new int[mask];\\n            Arrays.fill(nextDp,Integer.MAX_VALUE);\\n            for(int todo = 1; todo < mask; ++todo){\\n                for(int beforePick = todo; beforePick > 0; beforePick = todo&(beforePick-1)){\\n                    int pick = todo^beforePick;\\n                    nextDp[todo] = Math.min(nextDp[todo],Math.max(vals[pick],dp[beforePick]));\\n                }\\n            }\\n            dp = nextDp;\\n        }\\n        return dp[mask-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        int n = jobs.length, mask = 1<<n, vals[] = new int[mask], dp[];\\n        for(int picks = 1; picks < mask; ++picks){\\n            vals[picks] = vals[picks^(picks&-picks)]+jobs[(31-Integer.numberOfLeadingZeros(picks&-picks))];\\n        }\\n        dp = vals;\\n        for(int i = 1; i < k; ++i){\\n            var nextDp = new int[mask];\\n            Arrays.fill(nextDp,Integer.MAX_VALUE);\\n            for(int todo = 1; todo < mask; ++todo){\\n                for(int beforePick = todo; beforePick > 0; beforePick = todo&(beforePick-1)){\\n                    int pick = todo^beforePick;\\n                    nextDp[todo] = Math.min(nextDp[todo],Math.max(vals[pick],dp[beforePick]));\\n                }\\n            }\\n            dp = nextDp;\\n        }\\n        return dp[mask-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010192,
                "title": "easy-c-solution-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int res=INT_MAX;\\n    \\n    int solve(vector<int>&a,int k,vector<int>&v,int i){\\n          \\n            \\n        if(i==a.size()){\\n            int val=0;\\n            for(int j=0;j<k;j++){\\n                val=max(val,v[j]);\\n            }\\n            res=val;\\n            return val;\\n        }\\n        \\n        int ans=INT_MAX;\\n        unordered_set<int>vis;\\n        for(int j=0;j<k;j++){\\n            if(!vis.insert(v[j]).second)continue;\\n            v[j]+=a[i];\\n            if(v[j]>=res){\\n                v[j]-=a[i];\\n                continue;\\n            }\\n            ans=min(ans,solve(a,k,v,i+1));\\n            v[j]-=a[i];\\n        }\\n        return ans;\\n    }\\n    \\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int>v(k,0);\\n        return solve(jobs,k,v,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int res=INT_MAX;\\n    \\n    int solve(vector<int>&a,int k,vector<int>&v,int i){\\n          \\n            \\n        if(i==a.size()){\\n            int val=0;\\n            for(int j=0;j<k;j++){\\n                val=max(val,v[j]);\\n            }\\n            res=val;\\n            return val;\\n        }\\n        \\n        int ans=INT_MAX;\\n        unordered_set<int>vis;\\n        for(int j=0;j<k;j++){\\n            if(!vis.insert(v[j]).second)continue;\\n            v[j]+=a[i];\\n            if(v[j]>=res){\\n                v[j]-=a[i];\\n                continue;\\n            }\\n            ans=min(ans,solve(a,k,v,i+1));\\n            v[j]-=a[i];\\n        }\\n        return ans;\\n    }\\n    \\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        vector<int>v(k,0);\\n        return solve(jobs,k,v,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010187,
                "title": "python-place-largest-k-th-jobs-into-k-buckets-80ms",
                "content": "Here, the idea is first place the largest k-jobs into k-buckets and then place remaining jobs into any of these buckets to get the minimum possible value.\\n\\nAlso, here, optWork is for pruning. The intuition behind this is, we get the average work for each worker and then try to assign him work just around that average. Once the work is larger than the average, stop adding work to that worker.\\n\\n### code\\n\\nclass Solution:\\n  def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n    totalSum = sum(jobs)\\n    if k == 1:\\n      return totalSum\\n    jobs.sort()\\n    curWorksDone = jobs[-k:]\\n    jobs = jobs[:-k]\\n    N = len(jobs)\\n    \\n    optWork = totalSum/k\\n    visited = [False for _ in range(N)]\\n    \\n    def func(index, curWorksDone):\\n      if index >= N:\\n        return max(curWorksDone)\\n      \\n      ret = math.inf\\n      for itr in range(k):\\n        if curWorksDone[itr] < optWork:\\n          curWorksDone[itr] += jobs[index]\\n          ret = min(ret, func(index + 1, curWorksDone))\\n          curWorksDone[itr] -= jobs[index]\\n      return ret\\n    \\n    \\n    return func(0, curWorksDone)",
                "solutionTags": [],
                "code": "Here, the idea is first place the largest k-jobs into k-buckets and then place remaining jobs into any of these buckets to get the minimum possible value.\\n\\nAlso, here, optWork is for pruning. The intuition behind this is, we get the average work for each worker and then try to assign him work just around that average. Once the work is larger than the average, stop adding work to that worker.\\n\\n### code\\n\\nclass Solution:\\n  def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n    totalSum = sum(jobs)\\n    if k == 1:\\n      return totalSum\\n    jobs.sort()\\n    curWorksDone = jobs[-k:]\\n    jobs = jobs[:-k]\\n    N = len(jobs)\\n    \\n    optWork = totalSum/k\\n    visited = [False for _ in range(N)]\\n    \\n    def func(index, curWorksDone):\\n      if index >= N:\\n        return max(curWorksDone)\\n      \\n      ret = math.inf\\n      for itr in range(k):\\n        if curWorksDone[itr] < optWork:\\n          curWorksDone[itr] += jobs[index]\\n          ret = min(ret, func(index + 1, curWorksDone))\\n          curWorksDone[itr] -= jobs[index]\\n      return ret\\n    \\n    \\n    return func(0, curWorksDone)",
                "codeTag": "Java"
            },
            {
                "id": 1010172,
                "title": "working-python-solution-with-dfs-backtracking",
                "content": "The whole idea builds on an assumption that the largest k numbers will be in seperate groups. And the rest is simple dfs backtracking.\\n\\n\\n```\\nfrom sys import maxsize\\nclass Solution(object):\\n    current_max = None\\n    def minimumTimeRequired(self, jobs, k):\\n        \"\"\"\\n        :type jobs: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        sorted_jobs = sorted(jobs, reverse = True)\\n        \\n        self.current_max = maxsize\\n        \\n        res = []\\n        for i in range(k):\\n            res.append(sorted_jobs[i])\\n            \\n        self.dfs(k, sorted_jobs, res, k)\\n        \\n        return self.current_max\\n    \\n    \\n    def dfs(self, index, sorted_jobs, res, k):\\n        if index > len(sorted_jobs)-1:\\n            self.current_max = min(self.current_max, max(res))\\n            return\\n        \\n        for i in range(len(res)):\\n            if res[i] + sorted_jobs[index] < self.current_max:\\n                res[i] += sorted_jobs[index]\\n                self.dfs(index+1, sorted_jobs, res, k)\\n                res[i] -= sorted_jobs[index]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sys import maxsize\\nclass Solution(object):\\n    current_max = None\\n    def minimumTimeRequired(self, jobs, k):\\n        \"\"\"\\n        :type jobs: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        sorted_jobs = sorted(jobs, reverse = True)\\n        \\n        self.current_max = maxsize\\n        \\n        res = []\\n        for i in range(k):\\n            res.append(sorted_jobs[i])\\n            \\n        self.dfs(k, sorted_jobs, res, k)\\n        \\n        return self.current_max\\n    \\n    \\n    def dfs(self, index, sorted_jobs, res, k):\\n        if index > len(sorted_jobs)-1:\\n            self.current_max = min(self.current_max, max(res))\\n            return\\n        \\n        for i in range(len(res)):\\n            if res[i] + sorted_jobs[index] < self.current_max:\\n                res[i] += sorted_jobs[index]\\n                self.dfs(index+1, sorted_jobs, res, k)\\n                res[i] -= sorted_jobs[index]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010118,
                "title": "beats-100-python-at-post",
                "content": "It\\'s the same question as last week contest hard problem, just use backtrack and prune\\n```\\n\\n# load local leetcode lib\\nimport pathlib\\nlc_lib_path = pathlib.Path(\\'../lc_lib.py\\')\\nif lc_lib_path.exists():\\n    import sys\\n    sys.path.insert(0, \\'..\\')\\n    from lc_lib import *\\n\\nold_print = print\\ndef print(*args, **kwargs):\\n    if lc_lib_path.exists():\\n        old_print(*args, **kwargs)\\n\\nfrom sortedcontainers import SortedList, SortedDict, SortedSet\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        jobs.sort(reverse=True)\\n        n = len(jobs)\\n        work_times = [0]*k\\n        one_worker_max_time = sum(jobs[:(n//k)+1])\\n\\n        result = float(\\'inf\\')\\n        def dfs(i, cur_res):\\n            nonlocal result\\n            if i==n:\\n                result = min(result, cur_res)\\n                return\\n\\n            if cur_res>=result:\\n                return\\n\\n            job = jobs[i]\\n            for j in range(k):\\n                if (j>0 and work_times[j]==work_times[j-1]) or work_times[j]+job>one_worker_max_time:\\n                    continue\\n                work_times[j] += job\\n                dfs(i+1, max(cur_res, work_times[j]))\\n                work_times[j] -= job\\n\\n        dfs(0, 0)\\n        return result\\n\\nif __name__==\\'__main__\\':\\n    if lc_lib_path.exists():\\n        s = Solution()\\n\\n        jobs = [38,49,91,59,14,76,84]\\n        k = 3\\n        r = s.minimumTimeRequired(jobs,k)\\n        print(r)  # 140\\n        print(\\'-\\'*30)\\n\\n        jobs = [254,256,256,254,251,256,254,253,255,251,251,255]\\n        k = 10\\n        r = s.minimumTimeRequired(jobs,k)\\n        print(r)  # 140\\n        print(\\'-\\'*30)\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n# load local leetcode lib\\nimport pathlib\\nlc_lib_path = pathlib.Path(\\'../lc_lib.py\\')\\nif lc_lib_path.exists():\\n    import sys\\n    sys.path.insert(0, \\'..\\')\\n    from lc_lib import *\\n\\nold_print = print\\ndef print(*args, **kwargs):\\n    if lc_lib_path.exists():\\n        old_print(*args, **kwargs)\\n\\nfrom sortedcontainers import SortedList, SortedDict, SortedSet\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        jobs.sort(reverse=True)\\n        n = len(jobs)\\n        work_times = [0]*k\\n        one_worker_max_time = sum(jobs[:(n//k)+1])\\n\\n        result = float(\\'inf\\')\\n        def dfs(i, cur_res):\\n            nonlocal result\\n            if i==n:\\n                result = min(result, cur_res)\\n                return\\n\\n            if cur_res>=result:\\n                return\\n\\n            job = jobs[i]\\n            for j in range(k):\\n                if (j>0 and work_times[j]==work_times[j-1]) or work_times[j]+job>one_worker_max_time:\\n                    continue\\n                work_times[j] += job\\n                dfs(i+1, max(cur_res, work_times[j]))\\n                work_times[j] -= job\\n\\n        dfs(0, 0)\\n        return result\\n\\nif __name__==\\'__main__\\':\\n    if lc_lib_path.exists():\\n        s = Solution()\\n\\n        jobs = [38,49,91,59,14,76,84]\\n        k = 3\\n        r = s.minimumTimeRequired(jobs,k)\\n        print(r)  # 140\\n        print(\\'-\\'*30)\\n\\n        jobs = [254,256,256,254,251,256,254,253,255,251,251,255]\\n        k = 10\\n        r = s.minimumTimeRequired(jobs,k)\\n        print(r)  # 140\\n        print(\\'-\\'*30)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010092,
                "title": "c-without-dp-but-clever-trick-faster-than-100-c-solution",
                "content": "Here basically we have to divide the array into `k` parts such that the sum of each part is minimized.\\n**My Approach:-** Make a vector of vector whose size will be `k` which will represent the element in the i\\'th part . Sort the array in non decreasing order and allocate one element from back of the array to each part( the `for` loop in the `minimumTimeRequired` is doing this). In the same `for` loop in which we are giving one large element to one part we are just removing that element from the `jobs` which will reduce the size of `jobs`. Now we can easily apply recursion without TLE.\\nHope it helps.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>v;\\n    int ans=INT_MAX;\\n    void rec(vector<int>&job,int i=0){\\n       \\n        if(i==job.size()){\\n            int t=0;\\n            for(int j=0;j<v.size();j++){\\n                int temp=0;\\n                for(auto x:v[j]){\\n                    temp+=x;\\n                }\\n                t = max(t,temp);\\n            }\\n            ans = min(ans,t);\\n            return;\\n        }\\n        for(int j=0;j<v.size();j++){\\n            v[j].push_back(job[i]);\\n            rec(job,i+1);\\n            v[j].pop_back();\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size();\\n        sort(jobs.begin(),jobs.end());\\n        v = vector<vector<int>>(k);\\n        int j=n-1;\\n        for(int i=0;i<k;i++){\\n            v[i].push_back(jobs[j]);\\n            jobs.pop_back();\\n            j--;\\n        }\\n        rec(jobs);\\n        return ans;\\n    }\\n};\\n```\\n\\nHere is the more optimized code faster than 100% C++ Solution\\n```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    int ans=INT_MAX;\\n    void rec(vector<int>&job,int i=0){\\n        if(i==job.size()){\\n            // int t=0;\\n            auto it = *max_element(v.begin(),v.end());\\n            ans = min(ans,it);\\n            return;\\n        }\\n        for(int j=0;j<v.size();j++){\\n            v[j]+=(job[i]);\\n            if(v[j]<ans)\\n            rec(job,i+1);\\n            v[j]-=job[i];\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size();\\n        sort(jobs.begin(),jobs.end());\\n        v = vector<int>(k);\\n        if(n<=k){\\n            return *max_element(jobs.begin(),jobs.end());\\n        }\\n        int j=n-1;\\n        \\n        for(int i=0;i<k;i++){\\n            v[i]=(jobs[j]);\\n            jobs.pop_back();\\n            j--;\\n        }\\n        rec(jobs);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>v;\\n    int ans=INT_MAX;\\n    void rec(vector<int>&job,int i=0){\\n       \\n        if(i==job.size()){\\n            int t=0;\\n            for(int j=0;j<v.size();j++){\\n                int temp=0;\\n                for(auto x:v[j]){\\n                    temp+=x;\\n                }\\n                t = max(t,temp);\\n            }\\n            ans = min(ans,t);\\n            return;\\n        }\\n        for(int j=0;j<v.size();j++){\\n            v[j].push_back(job[i]);\\n            rec(job,i+1);\\n            v[j].pop_back();\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size();\\n        sort(jobs.begin(),jobs.end());\\n        v = vector<vector<int>>(k);\\n        int j=n-1;\\n        for(int i=0;i<k;i++){\\n            v[i].push_back(jobs[j]);\\n            jobs.pop_back();\\n            j--;\\n        }\\n        rec(jobs);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    int ans=INT_MAX;\\n    void rec(vector<int>&job,int i=0){\\n        if(i==job.size()){\\n            // int t=0;\\n            auto it = *max_element(v.begin(),v.end());\\n            ans = min(ans,it);\\n            return;\\n        }\\n        for(int j=0;j<v.size();j++){\\n            v[j]+=(job[i]);\\n            if(v[j]<ans)\\n            rec(job,i+1);\\n            v[j]-=job[i];\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) {\\n        int n = jobs.size();\\n        sort(jobs.begin(),jobs.end());\\n        v = vector<int>(k);\\n        if(n<=k){\\n            return *max_element(jobs.begin(),jobs.end());\\n        }\\n        int j=n-1;\\n        \\n        for(int i=0;i<k;i++){\\n            v[i]=(jobs[j]);\\n            jobs.pop_back();\\n            j--;\\n        }\\n        rec(jobs);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010071,
                "title": "c-backtracking-with-trimming-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int result=2147483647;\\n    int total[12]={0};\\n    void dfs(vector<int>& jobs,int index,int k)\\n    {\\n        if(index==jobs.size())\\n        {\\n            int current=0;\\n            for(int i=0;i<k;i++) current=max(current,total[i]);            \\n            result=min(result,current);\\n            return;\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            total[i]+=jobs[index];\\n            if(total[i]<result) dfs(jobs,index+1,k);\\n            //if total[i]>=result, then this will definitely not be the solution            \\n            total[i]-=jobs[index];\\n            if(total[i]==0) break;\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) \\n    {\\n        dfs(jobs,0,k);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int result=2147483647;\\n    int total[12]={0};\\n    void dfs(vector<int>& jobs,int index,int k)\\n    {\\n        if(index==jobs.size())\\n        {\\n            int current=0;\\n            for(int i=0;i<k;i++) current=max(current,total[i]);            \\n            result=min(result,current);\\n            return;\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            total[i]+=jobs[index];\\n            if(total[i]<result) dfs(jobs,index+1,k);\\n            //if total[i]>=result, then this will definitely not be the solution            \\n            total[i]-=jobs[index];\\n            if(total[i]==0) break;\\n        }\\n    }\\n    int minimumTimeRequired(vector<int>& jobs, int k) \\n    {\\n        dfs(jobs,0,k);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010023,
                "title": "c-backtracking-with-pruning",
                "content": "```\\n    public class Solution\\n    {\\n        int res = int.MaxValue;\\n        public int MinimumTimeRequired(int[] jobs, int k)\\n        {\\n            DFS(jobs, jobs.Length - 1, new int[k], 0);\\n            return res;\\n        }\\n        \\n        private void DFS(int[] jobs, int idx, int[] sum, int max)\\n        {\\n            if (idx < 0)\\n            {\\n                res = Math.Min(res, max);\\n                return;\\n            }\\n            if (max >= res) return;\\n            for (int i = 0; i < sum.Length; i++)\\n            {\\n                if (i > 0 && sum[i - 1] == 0) continue;\\n                sum[i] += jobs[idx];\\n                DFS(jobs, idx - 1, sum, Math.Max(max, sum[i]));\\n                sum[i] -= jobs[idx];\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        int res = int.MaxValue;\\n        public int MinimumTimeRequired(int[] jobs, int k)\\n        {\\n            DFS(jobs, jobs.Length - 1, new int[k], 0);\\n            return res;\\n        }\\n        \\n        private void DFS(int[] jobs, int idx, int[] sum, int max)\\n        {\\n            if (idx < 0)\\n            {\\n                res = Math.Min(res, max);\\n                return;\\n            }\\n            if (max >= res) return;\\n            for (int i = 0; i < sum.Length; i++)\\n            {\\n                if (i > 0 && sum[i - 1] == 0) continue;\\n                sum[i] += jobs[idx];\\n                DFS(jobs, idx - 1, sum, Math.Max(max, sum[i]));\\n                sum[i] -= jobs[idx];\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009995,
                "title": "c-backtracking-easy-to-understand-code",
                "content": "```\\n/*\\nBrute force: k^n\\n*/\\nclass Solution {\\npublic:\\n    int best = INT_MAX;\\n    int k;\\n    \\n    int minimumTimeRequired(vector<int>& jobs, int k_) {\\n        k = k_;\\n        vector<int> workerLoad(k, 0);        \\n        helper(0, workerLoad, jobs);\\n        return best;\\n    }\\n    \\n    void helper(int jobIdx, vector<int>& workerLoad, const vector<int>& jobs) {\\n                \\n        // base case\\n        int maxLoad = *max_element(workerLoad.begin(), workerLoad.end());\\n        if (jobIdx == jobs.size()) {            \\n            if (maxLoad < best)\\n                best = maxLoad;\\n            \\n            return;\\n        }\\n        \\n        // Pruning\\n        if (maxLoad > best) return;\\n        \\n        // General case\\n        // Try assigning jobIdx to one of the k workers\\n\\t\\t// But first sort the worker ids by their workload so that\\n\\t\\t// we can skip trying assigning load to a worker with the same\\n\\t\\t// workload as the previous worker.\\n        vector<int> workers(k);\\n        for (int w = 0; w < k; w++) workers[w] = w;\\n        sort(workers.begin(), workers.end(),\\n            [&workerLoad](const int w1, const int w2) {\\n               return workerLoad[w1] < workerLoad[w2]; \\n            });\\n        \\n\\t\\t// Try assigning jobIdx to one of the k workers\\n        for (int j = 0; j < k; j++) {\\n            int worker = workers[j];\\n            if (j > 0) {\\n                int prevWorker = workers[j-1];\\n                 if(workerLoad[worker] == workerLoad[prevWorker]) continue;\\n            }\\n            workerLoad[worker] += jobs[jobIdx];\\n            helper(jobIdx+1, workerLoad, jobs);\\n            workerLoad[worker] -= jobs[jobIdx];\\n        }\\n    }\\n};\\n\\n/*\\nAttempt at DP:\\n[1,2,4,7,8,5,4,3], k = 3\\n 1 2 3 1 2\\n\\nn/k     0   1    2\\n0       0   0   0\\n1       1   0   0\\n2       1   2   0\\n3       1   2   4\\n4       8   2   4\\n5       8   10  4   \\n6\\n...\\n(Doesnt seem possible to do DP)\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nBrute force: k^n\\n*/\\nclass Solution {\\npublic:\\n    int best = INT_MAX;\\n    int k;\\n    \\n    int minimumTimeRequired(vector<int>& jobs, int k_) {\\n        k = k_;\\n        vector<int> workerLoad(k, 0);        \\n        helper(0, workerLoad, jobs);\\n        return best;\\n    }\\n    \\n    void helper(int jobIdx, vector<int>& workerLoad, const vector<int>& jobs) {\\n                \\n        // base case\\n        int maxLoad = *max_element(workerLoad.begin(), workerLoad.end());\\n        if (jobIdx == jobs.size()) {            \\n            if (maxLoad < best)\\n                best = maxLoad;\\n            \\n            return;\\n        }\\n        \\n        // Pruning\\n        if (maxLoad > best) return;\\n        \\n        // General case\\n        // Try assigning jobIdx to one of the k workers\\n\\t\\t// But first sort the worker ids by their workload so that\\n\\t\\t// we can skip trying assigning load to a worker with the same\\n\\t\\t// workload as the previous worker.\\n        vector<int> workers(k);\\n        for (int w = 0; w < k; w++) workers[w] = w;\\n        sort(workers.begin(), workers.end(),\\n            [&workerLoad](const int w1, const int w2) {\\n               return workerLoad[w1] < workerLoad[w2]; \\n            });\\n        \\n\\t\\t// Try assigning jobIdx to one of the k workers\\n        for (int j = 0; j < k; j++) {\\n            int worker = workers[j];\\n            if (j > 0) {\\n                int prevWorker = workers[j-1];\\n                 if(workerLoad[worker] == workerLoad[prevWorker]) continue;\\n            }\\n            workerLoad[worker] += jobs[jobIdx];\\n            helper(jobIdx+1, workerLoad, jobs);\\n            workerLoad[worker] -= jobs[jobIdx];\\n        }\\n    }\\n};\\n\\n/*\\nAttempt at DP:\\n[1,2,4,7,8,5,4,3], k = 3\\n 1 2 3 1 2\\n\\nn/k     0   1    2\\n0       0   0   0\\n1       1   0   0\\n2       1   2   0\\n3       1   2   4\\n4       8   2   4\\n5       8   10  4   \\n6\\n...\\n(Doesnt seem possible to do DP)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009981,
                "title": "accepted-c-dp-solution",
                "content": "```\\n    public class Solution\\n    {\\n\\n        public int MinimumTimeRequired(int[] jobs, int k)\\n        {\\n            int[,] dp = new int[1 << jobs.Length, k + 1];\\n\\n            int[] sums = new int[1 << jobs.Length];\\n            IList<int>[] mask2Candidates = new IList<int>[1 << jobs.Length];\\n\\n            for (int i = 0; i < 1 << jobs.Length; i++)\\n            {\\n                mask2Candidates[i] = new List<int>();\\n\\n                for (int j = 0; j < 1 << jobs.Length; j++)\\n                {\\n                    if ((i & j) == 0)\\n                    {\\n                        mask2Candidates[i].Add(j);\\n                    }\\n                }\\n            }\\n\\n            for (int i = 0; i < 1 << jobs.Length; i++)\\n            {\\n                for (int j = 0; j < jobs.Length; j++)\\n                {\\n                    if ((i & (1 << j)) != 0)\\n                    {\\n                        sums[i] += jobs[j];\\n                    }\\n                }\\n            }\\n\\n            for (int i = 0; i < 1 << jobs.Length; i++)\\n            {\\n                for (int j = 0; j <= k; j++)\\n                {\\n                    dp[i, j] = int.MaxValue;\\n                }\\n            }\\n\\n            for (int i = 0; i <= k; i++)\\n            {\\n                dp[(1 << jobs.Length) - 1, i] = 0;\\n            }\\n\\n            for (int remainingWorkers = 1; remainingWorkers <= k; remainingWorkers++)\\n            {\\n                for (int assignedJobs = 0; assignedJobs < 1 << jobs.Length; assignedJobs++)\\n                {\\n                    var ignore = dp[assignedJobs, remainingWorkers - 1];\\n                    dp[assignedJobs, remainingWorkers] = Math.Min(dp[assignedJobs, remainingWorkers], ignore);\\n\\n                    for (int l = 0; l < mask2Candidates[assignedJobs].Count; l++)\\n                    {\\n                        var m = mask2Candidates[assignedJobs][l];\\n                        var next = dp[assignedJobs | m, remainingWorkers - 1];\\n                        dp[assignedJobs, remainingWorkers] = Math.Min(dp[assignedJobs, remainingWorkers], Math.Max(sums[m], next));\\n                    }\\n                }\\n            }\\n\\n            return dp[0, k];\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public class Solution\\n    {\\n\\n        public int MinimumTimeRequired(int[] jobs, int k)\\n        {\\n            int[,] dp = new int[1 << jobs.Length, k + 1];\\n\\n            int[] sums = new int[1 << jobs.Length];\\n            IList<int>[] mask2Candidates = new IList<int>[1 << jobs.Length];\\n\\n            for (int i = 0; i < 1 << jobs.Length; i++)\\n            {\\n                mask2Candidates[i] = new List<int>();\\n\\n                for (int j = 0; j < 1 << jobs.Length; j++)\\n                {\\n                    if ((i & j) == 0)\\n                    {\\n                        mask2Candidates[i].Add(j);\\n                    }\\n                }\\n            }\\n\\n            for (int i = 0; i < 1 << jobs.Length; i++)\\n            {\\n                for (int j = 0; j < jobs.Length; j++)\\n                {\\n                    if ((i & (1 << j)) != 0)\\n                    {\\n                        sums[i] += jobs[j];\\n                    }\\n                }\\n            }\\n\\n            for (int i = 0; i < 1 << jobs.Length; i++)\\n            {\\n                for (int j = 0; j <= k; j++)\\n                {\\n                    dp[i, j] = int.MaxValue;\\n                }\\n            }\\n\\n            for (int i = 0; i <= k; i++)\\n            {\\n                dp[(1 << jobs.Length) - 1, i] = 0;\\n            }\\n\\n            for (int remainingWorkers = 1; remainingWorkers <= k; remainingWorkers++)\\n            {\\n                for (int assignedJobs = 0; assignedJobs < 1 << jobs.Length; assignedJobs++)\\n                {\\n                    var ignore = dp[assignedJobs, remainingWorkers - 1];\\n                    dp[assignedJobs, remainingWorkers] = Math.Min(dp[assignedJobs, remainingWorkers], ignore);\\n\\n                    for (int l = 0; l < mask2Candidates[assignedJobs].Count; l++)\\n                    {\\n                        var m = mask2Candidates[assignedJobs][l];\\n                        var next = dp[assignedJobs | m, remainingWorkers - 1];\\n                        dp[assignedJobs, remainingWorkers] = Math.Min(dp[assignedJobs, remainingWorkers], Math.Max(sums[m], next));\\n                    }\\n                }\\n            }\\n\\n            return dp[0, k];\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009978,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    int result = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n         helper(jobs,k,0,new int[k]);\\n         return result;\\n    }\\n    \\n    \\n    private int helper(int[] jobs, int k,int idx,int[] workerTime){\\n       if(idx == jobs.length){\\n           int maxTime = 0;\\n           for(int time : workerTime){\\n               maxTime = Math.max(maxTime,time);\\n           }\\n           return maxTime;\\n       }\\n       \\n       int minTime = Integer.MAX_VALUE; \\n       HashSet<Integer> visited = new HashSet();\\n       for(int i = 0 ; i < k ;i++){\\n           \\n           //Already used with worker with the same working time\\n           if (!visited.add(workerTime[i])) continue;\\n           workerTime[i] += jobs[idx];\\n           \\n           //Already found the better result\\n           if(workerTime[i] < result){\\n             minTime = Math.min(minTime,helper(jobs,k,idx + 1,workerTime));    \\n           }\\n           workerTime[i] -= jobs[idx];\\n       } \\n       \\n       result = Math.min(result,minTime);       \\n       return minTime;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int result = Integer.MAX_VALUE;\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n         helper(jobs,k,0,new int[k]);\\n         return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1009937,
                "title": "java-easy-solution-dfs",
                "content": "1, Sort all the jobs.\\n2. Put the largetst k jobs for k workers, each one gets one\\n3. For the rest of the jobs use DFS to brutal force the best result\\n\\n```\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        Arrays.sort(jobs);\\n        int[] worker = new int[k];\\n        for(int i = 0; i < k; i++){\\n            worker[i] = jobs[jobs.length - i - 1];\\n        }\\n        return helper(jobs, worker, 0, jobs.length - k);\\n    }\\n    \\n    private int helper(int[] jobs, int[] worker, int index, int stop){\\n        if (index == stop){\\n            int max = Integer.MIN_VALUE;\\n            for(int i : worker) max = Math.max(max, i);\\n            return max;\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < worker.length; i++){\\n            int[] next = worker.clone();\\n            next[i] += jobs[index];\\n            min = Math.min(min, helper(jobs, next, index + 1, stop));\\n        }\\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumTimeRequired(int[] jobs, int k) {\\n        Arrays.sort(jobs);\\n        int[] worker = new int[k];\\n        for(int i = 0; i < k; i++){\\n            worker[i] = jobs[jobs.length - i - 1];\\n        }\\n        return helper(jobs, worker, 0, jobs.length - k);\\n    }\\n    \\n    private int helper(int[] jobs, int[] worker, int index, int stop){\\n        if (index == stop){\\n            int max = Integer.MIN_VALUE;\\n            for(int i : worker) max = Math.max(max, i);\\n            return max;\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < worker.length; i++){\\n            int[] next = worker.clone();\\n            next[i] += jobs[index];\\n            min = Math.min(min, helper(jobs, next, index + 1, stop));\\n        }\\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009934,
                "title": "python-prune-with-greedy-derived-upper-bound-memoization-100ms",
                "content": "First use a greedy algorithm to obtain an upper bound. \\n\\nThen search with memoization.\\n* Only the ordering of the job duration distribution matters, hence the sorting. \\n\\n```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        import functools\\n        import heapq\\n                    \\n        hpq = []\\n        jobs = sorted(jobs, reverse=True)\\n        for val in jobs:\\n            if len(hpq) < k:\\n                heapq.heappush(hpq, val)\\n            else:\\n                heapq.heappush(hpq, heapq.heappop(hpq) + val)\\n        \\n        upper_bound = heapq.nlargest(1, hpq)[0]\\n        \\n        @functools.lru_cache(None)\\n        def find(idx, curr_histo) -> int:\\n            if idx == len(jobs):\\n                return max(curr_histo)\\n            \\n            curr = jobs[idx]\\n            def iter_next():\\n                yield upper_bound\\n                for i in range(k):\\n                    if curr_histo[i] + curr > upper_bound:\\n                        continue\\n                    histo = list(curr_histo)\\n                    histo = sorted(histo[:i] + [histo[i] + curr] + histo[(i + 1):])\\n                    yield find(idx + 1, tuple(histo))\\n                    \\n            return min(iter_next())\\n        \\n        histo = [0] * k\\n        return find(0, tuple(histo))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        import functools\\n        import heapq\\n                    \\n        hpq = []\\n        jobs = sorted(jobs, reverse=True)\\n        for val in jobs:\\n            if len(hpq) < k:\\n                heapq.heappush(hpq, val)\\n            else:\\n                heapq.heappush(hpq, heapq.heappop(hpq) + val)\\n        \\n        upper_bound = heapq.nlargest(1, hpq)[0]\\n        \\n        @functools.lru_cache(None)\\n        def find(idx, curr_histo) -> int:\\n            if idx == len(jobs):\\n                return max(curr_histo)\\n            \\n            curr = jobs[idx]\\n            def iter_next():\\n                yield upper_bound\\n                for i in range(k):\\n                    if curr_histo[i] + curr > upper_bound:\\n                        continue\\n                    histo = list(curr_histo)\\n                    histo = sorted(histo[:i] + [histo[i] + curr] + histo[(i + 1):])\\n                    yield find(idx + 1, tuple(histo))\\n                    \\n            return min(iter_next())\\n        \\n        histo = [0] * k\\n        return find(0, tuple(histo))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568506,
                "content": [
                    {
                        "username": "db99",
                        "content": "Why is leetcode giving this sort of questions whose time complexity in worst case is exponential but with some optimisation all test case are passing .\\nIn both biweekly contest and weekly contest leetcode gave this type of question.\\nWeekly : [1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/http://)\\nBiweekly : [1718. Construct the Lexicographically Largest Valid Sequence](https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/http://)"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "I believe Leetcode gives because interviewers give. \\nAnd interviewers give because it is usual for R&D lab engineers to face problems of NP/exponential/worse types, and on interview they want to test how an interviewee approaches to such kind of problems. "
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "this question is similar(same as) to \nhttps://leetcode.com/problems/fair-distribution-of-cookies/\nProblem no : 2305"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "But it seems that this one has much stricter time constraint? I use my code from 2305 (96%, 48ms) and got a TLE at this one..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Not just similar, but exactly the same, just wrapped in different words."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "I wonder if  we can memoize it without Bitmask??"
                    },
                    {
                        "username": "arghyadas",
                        "content": "How is this question different from BookAllocation problem? When I use book allocation solution, it gives wrong answer"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Here contiguous allocation is not necessary,, unlike book allocation."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "It is similar to fair distribution of cookies https://leetcode.com/problems/fair-distribution-of-cookies/description/"
                    }
                ]
            },
            {
                "id": 1951110,
                "content": [
                    {
                        "username": "db99",
                        "content": "Why is leetcode giving this sort of questions whose time complexity in worst case is exponential but with some optimisation all test case are passing .\\nIn both biweekly contest and weekly contest leetcode gave this type of question.\\nWeekly : [1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/http://)\\nBiweekly : [1718. Construct the Lexicographically Largest Valid Sequence](https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/http://)"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "I believe Leetcode gives because interviewers give. \\nAnd interviewers give because it is usual for R&D lab engineers to face problems of NP/exponential/worse types, and on interview they want to test how an interviewee approaches to such kind of problems. "
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "this question is similar(same as) to \nhttps://leetcode.com/problems/fair-distribution-of-cookies/\nProblem no : 2305"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "But it seems that this one has much stricter time constraint? I use my code from 2305 (96%, 48ms) and got a TLE at this one..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Not just similar, but exactly the same, just wrapped in different words."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "I wonder if  we can memoize it without Bitmask??"
                    },
                    {
                        "username": "arghyadas",
                        "content": "How is this question different from BookAllocation problem? When I use book allocation solution, it gives wrong answer"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Here contiguous allocation is not necessary,, unlike book allocation."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "It is similar to fair distribution of cookies https://leetcode.com/problems/fair-distribution-of-cookies/description/"
                    }
                ]
            },
            {
                "id": 2045017,
                "content": [
                    {
                        "username": "db99",
                        "content": "Why is leetcode giving this sort of questions whose time complexity in worst case is exponential but with some optimisation all test case are passing .\\nIn both biweekly contest and weekly contest leetcode gave this type of question.\\nWeekly : [1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/http://)\\nBiweekly : [1718. Construct the Lexicographically Largest Valid Sequence](https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/http://)"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "I believe Leetcode gives because interviewers give. \\nAnd interviewers give because it is usual for R&D lab engineers to face problems of NP/exponential/worse types, and on interview they want to test how an interviewee approaches to such kind of problems. "
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "this question is similar(same as) to \nhttps://leetcode.com/problems/fair-distribution-of-cookies/\nProblem no : 2305"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "But it seems that this one has much stricter time constraint? I use my code from 2305 (96%, 48ms) and got a TLE at this one..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Not just similar, but exactly the same, just wrapped in different words."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "I wonder if  we can memoize it without Bitmask??"
                    },
                    {
                        "username": "arghyadas",
                        "content": "How is this question different from BookAllocation problem? When I use book allocation solution, it gives wrong answer"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Here contiguous allocation is not necessary,, unlike book allocation."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "It is similar to fair distribution of cookies https://leetcode.com/problems/fair-distribution-of-cookies/description/"
                    }
                ]
            },
            {
                "id": 1719521,
                "content": [
                    {
                        "username": "db99",
                        "content": "Why is leetcode giving this sort of questions whose time complexity in worst case is exponential but with some optimisation all test case are passing .\\nIn both biweekly contest and weekly contest leetcode gave this type of question.\\nWeekly : [1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/http://)\\nBiweekly : [1718. Construct the Lexicographically Largest Valid Sequence](https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/http://)"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "I believe Leetcode gives because interviewers give. \\nAnd interviewers give because it is usual for R&D lab engineers to face problems of NP/exponential/worse types, and on interview they want to test how an interviewee approaches to such kind of problems. "
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "this question is similar(same as) to \nhttps://leetcode.com/problems/fair-distribution-of-cookies/\nProblem no : 2305"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "But it seems that this one has much stricter time constraint? I use my code from 2305 (96%, 48ms) and got a TLE at this one..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Not just similar, but exactly the same, just wrapped in different words."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "I wonder if  we can memoize it without Bitmask??"
                    },
                    {
                        "username": "arghyadas",
                        "content": "How is this question different from BookAllocation problem? When I use book allocation solution, it gives wrong answer"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Here contiguous allocation is not necessary,, unlike book allocation."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "It is similar to fair distribution of cookies https://leetcode.com/problems/fair-distribution-of-cookies/description/"
                    }
                ]
            }
        ]
    }
]