[
    {
        "title": "Maximal Rectangle",
        "question_content": "Given a rows x cols&nbsp;binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n&nbsp;\nExample 1:\n\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\nExplanation: The maximal rectangle is shown in the above picture.\n\nExample 2:\n\nInput: matrix = [[\"0\"]]\nOutput: 0\n\nExample 3:\n\nInput: matrix = [[\"1\"]]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\trows == matrix.length\n\tcols == matrix[i].length\n\t1 <= row, cols <= 200\n\tmatrix[i][j] is '0' or '1'.",
        "solutions": [
            {
                "id": 29054,
                "title": "share-my-dp-solution",
                "content": "The DP solution proceeds row by row, starting from the first row. Let the maximal rectangle area at row i and column j be computed by [right(i,j) - left(i,j)]*height(i,j).\\n\\nAll the 3 variables left, right, and height can be determined by the information from previous row, and also information from the current row. So it can be regarded as a DP solution. The transition equations are:\\n\\n> left(i,j) = max(left(i-1,j), cur_left), cur_left can be determined from the current row\\n\\n> right(i,j) = min(right(i-1,j), cur_right), cur_right can be determined from the current row \\n\\n> height(i,j) = height(i-1,j) + 1,  if matrix[i][j]=='1'; \\n\\n> height(i,j) = 0,  if matrix[i][j]=='0'\\n\\n\\n\\nThe code is as below. The loops can be combined for speed but I separate them for more clarity of the algorithm.\\n\\n    class Solution {public:\\n    int maximalRectangle(vector<vector<char> > &matrix) {\\n        if(matrix.empty()) return 0;\\n        const int m = matrix.size();\\n        const int n = matrix[0].size();\\n        int left[n], right[n], height[n];\\n        fill_n(left,n,0); fill_n(right,n,n); fill_n(height,n,0);\\n        int maxA = 0;\\n        for(int i=0; i<m; i++) {\\n            int cur_left=0, cur_right=n; \\n            for(int j=0; j<n; j++) { // compute height (can do this from either side)\\n                if(matrix[i][j]=='1') height[j]++; \\n                else height[j]=0;\\n            }\\n            for(int j=0; j<n; j++) { // compute left (from left to right)\\n                if(matrix[i][j]=='1') left[j]=max(left[j],cur_left);\\n                else {left[j]=0; cur_left=j+1;}\\n            }\\n            // compute right (from right to left)\\n            for(int j=n-1; j>=0; j--) {\\n                if(matrix[i][j]=='1') right[j]=min(right[j],cur_right);\\n                else {right[j]=n; cur_right=j;}    \\n            }\\n            // compute the area of rectangle (can do this from either side)\\n            for(int j=0; j<n; j++)\\n                maxA = max(maxA,(right[j]-left[j])*height[j]);\\n        }\\n        return maxA;\\n    }\\n};\\n\\n\\nIf you think this algorithm is not easy to understand, you can try this example:\\n\\n    0 0 0 1 0 0 0 \\n    0 0 1 1 1 0 0 \\n    0 1 1 1 1 1 0\\n\\nThe vector \"left\" and \"right\" from row 0 to row 2 are as follows\\n\\nrow 0:\\n \\n\\n    l: 0 0 0 3 0 0 0\\n    r: 7 7 7 4 7 7 7\\n\\nrow 1:\\n\\n    l: 0 0 2 3 2 0 0\\n    r: 7 7 5 4 5 7 7 \\n\\nrow 2:\\n\\n    l: 0 1 2 3 2 1 0\\n    r: 7 6 5 4 5 6 7\\n\\nThe vector \"left\" is computing the left boundary. Take (i,j)=(1,3) for example. On current row 1, the left boundary is at j=2. However, because matrix[1][3] is 1, you need to consider the left boundary on previous row as well, which is 3. So the real left boundary at (1,3) is 3. \\n\\nI hope this additional explanation makes things clearer.",
                "solutionTags": [],
                "code": "class Solution {public:\\n    int maximalRectangle(vector<vector<char> > &matrix) {\\n        if(matrix.empty()) return 0;\\n        const int m = matrix.size();\\n        const int n = matrix[0].size();\\n        int left[n], right[n], height[n];\\n        fill_n(left,n,0); fill_n(right,n,n); fill_n(height,n,0);\\n        int maxA = 0;\\n        for(int i=0; i<m; i++) {\\n            int cur_left=0, cur_right=n; \\n            for(int j=0; j<n; j++) { // compute height (can do this from either side)\\n                if(matrix[i][j]=='1') height[j]++; \\n                else height[j]=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 29064,
                "title": "a-o-n-2-solution-based-on-largest-rectangle-in-histogram",
                "content": "This question is similar as [\\\\[Largest Rectangle in Histogram\\\\]][1]:\\n\\nYou can maintain a row length of Integer array H recorded its height of '1's, and scan and update row by row to find out the largest rectangle of each row.\\n\\nFor each row, if matrix[row][i] == '1'. H[i] +=1, or reset the H[i] to zero.\\nand accroding the algorithm of [Largest Rectangle in Histogram], to update the maximum area.\\n\\n    public class Solution {\\n        public int maximalRectangle(char[][] matrix) {\\n            if (matrix==null||matrix.length==0||matrix[0].length==0)\\n                return 0;\\n            int cLen = matrix[0].length;    // column length\\n            int rLen = matrix.length;       // row length\\n            // height array \\n            int[] h = new int[cLen+1];\\n            h[cLen]=0;\\n            int max = 0;\\n            \\n            \\n            for (int row=0;row<rLen;row++) {\\n                Stack<Integer> s = new Stack<Integer>();\\n                for (int i=0;i<cLen+1;i++) {\\n                    if (i<cLen)\\n                        if(matrix[row][i]=='1')\\n                            h[i]+=1;\\n                        else h[i]=0;\\n                    \\n                    if (s.isEmpty()||h[s.peek()]<=h[i])\\n                        s.push(i);\\n                    else {\\n                        while(!s.isEmpty()&&h[i]<h[s.peek()]){\\n                            int top = s.pop();\\n                            int area = h[top]*(s.isEmpty()?i:(i-s.peek()-1));\\n                            if (area>max)\\n                                max = area;\\n                        }\\n                        s.push(i);\\n                    }\\n                }\\n            }\\n            return max;\\n        }\\n    }\\n\\n  [1]: http://oj.leetcode.com/problems/largest-rectangle-in-histogram/",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maximalRectangle(char[][] matrix) {\\n            if (matrix==null||matrix.length==0||matrix[0].length==0)\\n                return 0;\\n            int cLen = matrix[0].length;    // column length\\n            int rLen = matrix.length;       // row length\\n            // height array \\n            int[] h = new int[cLen+1];\\n            h[cLen]=0;\\n            int max = 0;\\n            \\n            \\n            for (int row=0;row<rLen;row++) {\\n                Stack<Integer> s = new Stack<Integer>();\\n                for (int i=0;i<cLen+1;i++) {\\n                    if (i<cLen)\\n                        if(matrix[row][i]=='1')\\n                            h[i]+=1;\\n                        else h[i]=0;\\n                    \\n                    if (s.isEmpty()||h[s.peek()]<=h[i])\\n                        s.push(i);\\n                    else {\\n                        while(!s.isEmpty()&&h[i]<h[s.peek()]){\\n                            int top = s.pop();\\n                            int area = h[top]*(s.isEmpty()?i:(i-s.peek()-1));\\n                            if (area>max)\\n                                max = area;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 29065,
                "title": "ac-python-dp-solutioin-120ms-based-on-largest-rectangle-in-histogram",
                "content": "    def maximalRectangle(self, matrix):\\n        if not matrix or not matrix[0]:\\n            return 0\\n        n = len(matrix[0])\\n        height = [0] * (n + 1)\\n        ans = 0\\n        for row in matrix:\\n            for i in xrange(n):\\n                height[i] = height[i] + 1 if row[i] == '1' else 0\\n            stack = [-1]\\n            for i in xrange(n + 1):\\n                while height[i] < height[stack[-1]]:\\n                    h = height[stack.pop()]\\n                    w = i - 1 - stack[-1]\\n                    ans = max(ans, h * w)\\n                stack.append(i)\\n        return ans\\n\\n    # 65 / 65 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 120 ms\\n    # 100%\\n\\nThe solution is based on [largest rectangle in histogram][1] solution. Every row in the matrix is viewed as the ground with some buildings on it. The building height is the count of consecutive 1s from that row to above rows. The rest is then the same as [this solution for largest rectangle in histogram][2]\\n\\n\\n  [1]: https://leetcode.com/problems/largest-rectangle-in-histogram/\\n  [2]: https://leetcode.com/discuss/65647/ac-python-clean-solution-using-stack-76ms",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    def maximalRectangle(self, matrix):\\n        if not matrix or not matrix[0]:\\n            return 0\\n        n = len(matrix[0])\\n        height = [0] * (n + 1)\\n        ans = 0\\n        for row in matrix:\\n            for i in xrange(n):\\n                height[i] = height[i] + 1 if row[i] == '1' else 0\\n            stack = [-1]\\n            for i in xrange(n + 1):\\n                while height[i] < height[stack[-1]]:\\n                    h = height[stack.pop()]\\n                    w = i - 1 - stack[-1]\\n                    ans = max(ans, h * w)\\n                stack.append(i)\\n        return ans\\n\\n    # 65 / 65 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 120 ms\\n    # 100%\\n\\nThe solution is based on [largest rectangle in histogram][1] solution. Every row in the matrix is viewed as the ground with some buildings on it. The building height is the count of consecutive 1s from that row to above rows. The rest is then the same as [this solution for largest rectangle in histogram][2]\\n\\n\\n  [1]: https://leetcode.com/problems/largest-rectangle-in-histogram/\\n  [2]: https://leetcode.com/discuss/65647/ac-python-clean-solution-using-stack-76ms",
                "codeTag": "Python3"
            },
            {
                "id": 29055,
                "title": "my-java-solution-based-on-maximum-rectangle-in-histogram-with-explanation",
                "content": "We can apply the maximum in histogram in each row of the 2D matrix. What we need is to maintain an int array for each row, which represent for the height of the histogram.\\n\\nPlease refer to https://leetcode.com/problems/largest-rectangle-in-histogram/      first.\\n\\n\\nSuppose there is a 2D matrix like\\n\\n1 1 0 1 0 1\\n\\n0 1 0 0 1 1\\n\\n1 1 1 1 0 1\\n\\n1 1 1 1 0 1\\n\\n\\nFirst initiate the height array as 1 1 0 1 0 1, which is just a copy of the first row. Then we can easily calculate the max area is 2.\\n\\nThen update the array. We scan the second row, when the matrix[1][i] is 0, set the height[i] to 0; else height[i] += 1, which means the height has increased by 1. So the height array again becomes 0 2 0 0 1 2. The max area now is also 2.\\n\\nApply the same method until we scan the whole matrix. the last height arrays is 2 4 2 2 0 4, so the max area has been found as 2 * 4 = 8.\\n\\nThen reason we scan the whole matrix is that the maximum value may appear in any row of the height.\\n\\n\\nCode as follows: \\n\\n    public class Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;\\n        \\n        int[] height = new int[matrix[0].length];\\n        for(int i = 0; i < matrix[0].length; i ++){\\n            if(matrix[0][i] == '1') height[i] = 1;\\n        }\\n        int result = largestInLine(height);\\n        for(int i = 1; i < matrix.length; i ++){\\n            resetHeight(matrix, height, i);\\n            result = Math.max(result, largestInLine(height));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void resetHeight(char[][] matrix, int[] height, int idx){\\n        for(int i = 0; i < matrix[0].length; i ++){\\n            if(matrix[idx][i] == '1') height[i] += 1;\\n            else height[i] = 0;\\n        }\\n    }    \\n    \\n    public int largestInLine(int[] height) {\\n        if(height == null || height.length == 0) return 0;\\n        int len = height.length;\\n        Stack<Integer> s = new Stack<Integer>();\\n        int maxArea = 0;\\n        for(int i = 0; i <= len; i++){\\n            int h = (i == len ? 0 : height[i]);\\n            if(s.isEmpty() || h >= height[s.peek()]){\\n                s.push(i);\\n            }else{\\n                int tp = s.pop();\\n                maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek()));\\n                i--;\\n            }\\n        }\\n        return maxArea;\\n    }\\n    \\n\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;\\n        \\n        int[] height = new int[matrix[0].length];\\n        for(int i = 0; i < matrix[0].length; i ++){\\n            if(matrix[0][i] == '1') height[i] = 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1604254,
                "title": "c-simple-solution-w-explanation-optimizations-from-brute-force-to-dp",
                "content": "We are given a matrix `M` and required to find the area of largest rectangle having all `\"1\"` within it.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force)***\\n\\nThe most brute force way of solving this problem would be to simply consider each and every possible rectangle and consider the maximal out of the rectangles which only consists of `1` in them\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        for(int start_i = 0; start_i < m; start_i++) \\n            for(int start_j = 0; start_j < n; start_j++) \\n                for(int end_i = start_i; end_i < m; end_i++) \\n                    for(int end_j = start_j; end_j < n; end_j++) {\\n                        bool allOnes = true;\\n                        for(int i = start_i; i <= end_i && allOnes; i++) \\n                            for(int j = start_j; j <= end_j && allOnes; j++) \\n                                if(M[i][j] != \\'1\\') allOnes = false;                           \\n                        ans = max(ans, allOnes * (end_i - start_i + 1) * (end_j - start_j + 1));\\n                    }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O((MN)<sup>3</sup>)</code>\\n***Space Complexity :*** <code>O(1)</code>\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (Optimized Brute-Force)***\\n\\nInstead of forming every rectangle, then checking validity of rectangle, we can optimize the brute-force by only considering valid rectangles. For this, we can start from every cell and consider valid rectangle starting from that cell. \\n* Let the current cell be at `(i, j)`.\\n* We first consider `i`th row and find maximum column length of 1s starting from `M[i][j]`.\\n* Then move to `i+1`th row and find maximum column length of 1s starting from `M[i+1][j]`. Take minimum of all lengths and find the area and keep updating max area.\\n* Continue similar process till you reach last row and then repeat the process for all other cells as well.\\n* Finally return maximum area found from all valid rectangles.\\n\\nThe below image illustrates the process for first two cells of the grid -\\n\\n<img src=\"https://assets.leetcode.com/users/images/6a6c48d6-32be-4a61-8408-309b3217cb3c_1638279969.659467.png\" />\\n\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) \\n                for(int row = i, colLen = n, col; row < m && M[row][j] == \\'1\\'; row++) {\\n                    for(col = j; col < n && M[row][col] == \\'1\\'; col++);\\n                    colLen = min(colLen, col-j);\\n                    ans = max(ans, (row-i+1) * colLen);\\n                }\\n            \\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O((MN)<sup>2</sup>)</code>\\n***Space Complexity :*** <code>O(1)</code>\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Pre-compute consecutive 1s to the right / DP)***\\n\\nWe can improve previous solution if we pre-compute the maximum number of 1s to the right of each cell. This will allow us to save save the iteration for finding maximum column length of 1s starting from `M[i][j]` in the previous solution. After a pre-computation which requires `O(MN)` time, we can compute the maximum column length in just `O(1)` essentially eliminating a loop from above solution.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        vector<vector<short>> dp(m+1, vector<short>(n+1));\\n        for(int i = m-1; ~i; i--) \\n            for(int j = n-1; ~j; j--) \\n                dp[i][j] = M[i][j] == \\'1\\' ? dp[i][j+1] + 1 : 0;\\n                    \\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) \\n                for(int row = i, colLen = n; row < m && M[row][j] == \\'1\\'; row++)\\n                    ans = max(ans, (row-i+1) * (colLen = min(colLen, dp[row][j]*1)));\\n                    \\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(M<sup>2</sup>N)</code>\\n***Space Complexity :*** <code>O(MN)</code>\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Pre-compute consecutive 1s to right + number of rows above & below having atleast same number of consecutive 1s / DP)***\\n\\nWe can eliminate one more loop in the above solution before we arrive at the optimal solution. In previous approach, we pre-computed the number of consecutive 1s to the right of each cell (referred as `dp[i][j]` henceforth) allowing us to eliminate iterate whole columns for each row. But, still we required to iterate from each row till bottom because we didnt know if other rows below had smaller `dp[i][j]` and thus we had to keep adjusting `colLen` to hold minimum `dp[i][j]` checking for each row till the bottom.\\n\\nTo avoid this, we can take a slightly different approach and only **check the consecutive number of rows above and below, that have the same or greater `dp[i][j]`**. This ensures that using the current cell, we can form a rectangle of width `dp[i][j]` and use current row + number of rows above & below having same or greater `dp[i][j]`. We must note that this approach ensures that we only considering maximal area rectangle having width `dp[i][j]`, for each cell under consideration, since we are also using the max possible height for that width.\\n\\n**Computing `up` and `down`:**\\n\\nNow, the only thing remaining is how to calculate number of rows above and below having atleast `dp[i][j]`. This can be calculated from `dp` using a monotonic stack. For this, we compute two matrices `up` and `down` where `up[i][j]` will denote consecutive number of rows above `i` (and including current)  having corresponding value of `dp` for each row as atleast `dp[i][j]` and similarly `down[i][j]` denotes consecutive number of rows below `j` (and including current) each having corresponding value of `dp` for each rows as atleast equal to `dp[i][j]`.\\n\\nFor calculating `up` matrix- \\n1. We iterate from 1st row till last row. \\n2. Each time, we get a row having `dp[i][j] >= dp[s.top()][j]`, we push it into stack. \\n3. If we get a row having `dp[i][j] < dp[s.top()][j]`, we pop from stack until we find row index in stack having atleast `dp[i][j]`. This helps maintain the monotonous stack. \\n4. At each iteration, the value of `up[i][j]` is equal to `i-s.top()` (current row - row index on top of stack having atleast `dp[i][j]` for that row), i.e, number of consecutive rows above having atleast `dp[i][j]`.\\n\\nWe follow a similar approach for `down` as well.\\n\\n\\n(*PS:* This approach\\'s logic seems to be similar to other solutions based on largest rectangle in histogram, but with different implementation. Since my brute-force approaches were based on this, I have kept it same. The only difference is that for each cell, I have just used width and calculated `up` & `down` having same width instead of using height and calculating `left` & `right` having same height.)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        vector<vector<short>> dp(m+1, vector<short>(n+1)), up(m, vector<short>(n,1)), down(up);\\n        for(int i = m-1; ~i; i--) \\n            for(int j = n-1; ~j; j--) \\n                dp[i][j] = M[i][j] == \\'1\\' ? dp[i][j+1] + 1 : 0;\\n        \\n        stack<int> s;\\n        for(int j = 0; j < n; j++) {\\n            s = stack<int>();\\n            for(int i = 0; i < m; i++) {\\n                while(size(s) && dp[s.top()][j] >= dp[i][j]) s.pop();\\n                up[i][j] = i - (size(s) ? s.top() : -1);\\n                s.push(i);\\n            }\\n            s = stack<int>();\\n            for(int i = m-1; ~i; i--) {\\n                while(size(s) && dp[s.top()][j] >= dp[i][j]) s.pop();\\n                down[i][j] = (size(s) ? s.top() : m) - i;\\n                s.push(i);\\n            }            \\n        }\\n\\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) \\n                ans = max(ans, dp[i][j] * (up[i][j]+down[i][j]-1));\\n                    \\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(MN)</code>\\n***Space Complexity :*** <code>O(MN)</code>\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        for(int start_i = 0; start_i < m; start_i++) \\n            for(int start_j = 0; start_j < n; start_j++) \\n                for(int end_i = start_i; end_i < m; end_i++) \\n                    for(int end_j = start_j; end_j < n; end_j++) {\\n                        bool allOnes = true;\\n                        for(int i = start_i; i <= end_i && allOnes; i++) \\n                            for(int j = start_j; j <= end_j && allOnes; j++) \\n                                if(M[i][j] != \\'1\\') allOnes = false;                           \\n                        ans = max(ans, allOnes * (end_i - start_i + 1) * (end_j - start_j + 1));\\n                    }\\n\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) \\n                for(int row = i, colLen = n, col; row < m && M[row][j] == \\'1\\'; row++) {\\n                    for(col = j; col < n && M[row][col] == \\'1\\'; col++);\\n                    colLen = min(colLen, col-j);\\n                    ans = max(ans, (row-i+1) * colLen);\\n                }\\n            \\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        vector<vector<short>> dp(m+1, vector<short>(n+1));\\n        for(int i = m-1; ~i; i--) \\n            for(int j = n-1; ~j; j--) \\n                dp[i][j] = M[i][j] == \\'1\\' ? dp[i][j+1] + 1 : 0;\\n                    \\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) \\n                for(int row = i, colLen = n; row < m && M[row][j] == \\'1\\'; row++)\\n                    ans = max(ans, (row-i+1) * (colLen = min(colLen, dp[row][j]*1)));\\n                    \\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        vector<vector<short>> dp(m+1, vector<short>(n+1)), up(m, vector<short>(n,1)), down(up);\\n        for(int i = m-1; ~i; i--) \\n            for(int j = n-1; ~j; j--) \\n                dp[i][j] = M[i][j] == \\'1\\' ? dp[i][j+1] + 1 : 0;\\n        \\n        stack<int> s;\\n        for(int j = 0; j < n; j++) {\\n            s = stack<int>();\\n            for(int i = 0; i < m; i++) {\\n                while(size(s) && dp[s.top()][j] >= dp[i][j]) s.pop();\\n                up[i][j] = i - (size(s) ? s.top() : -1);\\n                s.push(i);\\n            }\\n            s = stack<int>();\\n            for(int i = m-1; ~i; i--) {\\n                while(size(s) && dp[s.top()][j] >= dp[i][j]) s.pop();\\n                down[i][j] = (size(s) ? s.top() : m) - i;\\n                s.push(i);\\n            }            \\n        }\\n\\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) \\n                ans = max(ans, dp[i][j] * (up[i][j]+down[i][j]-1));\\n                    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122456,
                "title": "easiest-solution-build-on-top-of-leetcode84",
                "content": "```\\npublic int maximalRectangle(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        // for each cell with value=1, we look upward (north), the number of continuous \\'1\\' is the height of cell\\n        int[] heights = new int[matrix[0].length];\\n        int maxArea=-1;\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j]==\\'0\\'){\\n                    heights[j] = 0;\\n                } else {\\n                    heights[j] ++;\\n                }\\n            }            \\n            int area = yourLeetCode84Method(heights);\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maximalRectangle(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        // for each cell with value=1, we look upward (north), the number of continuous \\'1\\' is the height of cell\\n        int[] heights = new int[matrix[0].length];\\n        int maxArea=-1;\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j]==\\'0\\'){\\n                    heights[j] = 0;\\n                } else {\\n                    heights[j] ++;\\n                }\\n            }            \\n            int area = yourLeetCode84Method(heights);\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29094,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "This problem is similar to [maximal square](https://discuss.leetcode.com/topic/55063/evolve-from-brute-force-to-dp) but much more difficult.\\n1. brute force O(n^6), count each rectangle\\n```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty()) return 0;\\n        int r = matrix.size(), c = matrix[0].size(), area = 0;\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++) { //each start point (i,j)\\n                if(matrix[i][j]=='0') continue;\\n                for(int p=i;p<r;p++)\\n                    for(int q=j;q<c;q++) { // each end point (p,q)\\n                        if(matrix[p][q]=='0') continue;\\n                        bool ones = 1;\\n                        for(int x=i;x<=p;x++) {   //check if the rectangle contains all 1s\\n                            for(int y=j;y<=q;y++) \\n                                if(matrix[x][y] == '0') {\\n                                    ones = 0;\\n                                    break;\\n                                }\\n                            if(!ones) break;\\n                        }\\n                        if(ones) area = max(area, (p-i+1)*(q-j+1));\\n                    }\\n            }\\n        return area;\\n    }\\n```\\n2. O(n^4), whether a rectangle contains all 1s can be determined incrementally from the previous rectangle\\n```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty()) return 0;\\n        int r = matrix.size(), c = matrix[0].size(), area = 0;\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++) {\\n                vector<vector<bool>> dp(r,vector<bool>(c));\\n                for(int p=i;p<r;p++)\\n                    for(int q=j;q<c;q++) {\\n                        dp[p][q] = matrix[p][q]=='1';\\n                        if(p>i) dp[p][q] = dp[p][q] & dp[p-1][q];\\n                        if(q>j) dp[p][q] = dp[p][q] & dp[p][q-1];\\n                        if(dp[p][q]) area=max(area,(p-i+1)*(q-j+1));\\n                        else break;\\n                    }\\n            }\\n        return area;\\n    }\\n```\\n3. O(n^3), for a start/end point, we do not need to consider all end/start points, we only need to consider points that connect to the start/end point by all 1s. We use a 2d array to cache number of consecutive 1s to the left of each point. Then for a point, we can determine its maximal rectangles in linear time. [The idea is from @uniqueness ](https://discuss.leetcode.com/topic/1122/my-o-n-3-solution-for-your-reference).\\n```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int r = matrix.size();\\n        if (!r) return 0;\\n        int c = matrix[0].size(), area = 0;\\n        vector<vector<int>> ones(r,vector<int>(c));\\n        for(int i=0;i<r;i++) \\n            for(int j=0;j<c;j++) {\\n                if(matrix[i][j]=='0') continue;\\n                int w = ones[i][j] = (j?ones[i][j-1]:0) + 1;\\n                for(int k=i; k>=0; k--) {\\n                    w = min(ones[k][j],w);\\n                    area = max(area,w*(i-k+1));\\n                }\\n            }\\n        return area;\\n    }\\n```\\n4. O(n^2) dp. The optimal solution does not check a rectangle by start/end point. Given a point (i, j), it computes the left boundary, right boundary of the maximal rectangle with height(i,j) incrementally in constant time. [The idea is from @morrischen2008](https://discuss.leetcode.com/topic/6650/share-my-dp-solution).\\n```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int r = matrix.size();\\n        if (!r) return 0;\\n        int c = matrix[0].size(), area = 0;\\n        vector<int> left(c), right(c,c), height(c);\\n        for(int i=0;i<r;i++) { \\n            int cur = 0;\\n            for(int j=0;j<c;j++)\\n                if(matrix[i][j]=='0') {\\n                    height[j] = left[j] = 0;\\n                    cur = j+1; //left boundary of current row\\n                } else {\\n                    left[j] = max(left[j],cur);  //left boundary for height[j]\\n                    height[j]++;\\n                }\\n            cur = c;\\n            for(int j=c-1;j>=0;j--) {\\n                if (matrix[i][j]=='0') cur = j;\\n                right[j] = matrix[i][j]=='0'? c:min(right[j],cur);\\n                area = max(height[j]*(right[j]-left[j]),area);\\n            }\\n        }\\n        return area;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty()) return 0;\\n        int r = matrix.size(), c = matrix[0].size(), area = 0;\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++) { //each start point (i,j)\\n                if(matrix[i][j]=='0') continue;\\n                for(int p=i;p<r;p++)\\n                    for(int q=j;q<c;q++) { // each end point (p,q)\\n                        if(matrix[p][q]=='0') continue;\\n                        bool ones = 1;\\n                        for(int x=i;x<=p;x++) {   //check if the rectangle contains all 1s\\n                            for(int y=j;y<=q;y++) \\n                                if(matrix[x][y] == '0') {\\n                                    ones = 0;\\n                                    break;\\n                                }\\n                            if(!ones) break;\\n                        }\\n                        if(ones) area = max(area, (p-i+1)*(q-j+1));\\n                    }\\n            }\\n        return area;\\n    }\\n```\n```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty()) return 0;\\n        int r = matrix.size(), c = matrix[0].size(), area = 0;\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++) {\\n                vector<vector<bool>> dp(r,vector<bool>(c));\\n                for(int p=i;p<r;p++)\\n                    for(int q=j;q<c;q++) {\\n                        dp[p][q] = matrix[p][q]=='1';\\n                        if(p>i) dp[p][q] = dp[p][q] & dp[p-1][q];\\n                        if(q>j) dp[p][q] = dp[p][q] & dp[p][q-1];\\n                        if(dp[p][q]) area=max(area,(p-i+1)*(q-j+1));\\n                        else break;\\n                    }\\n            }\\n        return area;\\n    }\\n```\n```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int r = matrix.size();\\n        if (!r) return 0;\\n        int c = matrix[0].size(), area = 0;\\n        vector<vector<int>> ones(r,vector<int>(c));\\n        for(int i=0;i<r;i++) \\n            for(int j=0;j<c;j++) {\\n                if(matrix[i][j]=='0') continue;\\n                int w = ones[i][j] = (j?ones[i][j-1]:0) + 1;\\n                for(int k=i; k>=0; k--) {\\n                    w = min(ones[k][j],w);\\n                    area = max(area,w*(i-k+1));\\n                }\\n            }\\n        return area;\\n    }\\n```\n```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int r = matrix.size();\\n        if (!r) return 0;\\n        int c = matrix[0].size(), area = 0;\\n        vector<int> left(c), right(c,c), height(c);\\n        for(int i=0;i<r;i++) { \\n            int cur = 0;\\n            for(int j=0;j<c;j++)\\n                if(matrix[i][j]=='0') {\\n                    height[j] = left[j] = 0;\\n                    cur = j+1; //left boundary of current row\\n                } else {\\n                    left[j] = max(left[j],cur);  //left boundary for height[j]\\n                    height[j]++;\\n                }\\n            cur = c;\\n            for(int j=c-1;j>=0;j--) {\\n                if (matrix[i][j]=='0') cur = j;\\n                right[j] = matrix[i][j]=='0'? c:min(right[j],cur);\\n                area = max(height[j]*(right[j]-left[j]),area);\\n            }\\n        }\\n        return area;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29059,
                "title": "sharing-my-straightforward-c-solution-with-o-n-2-time-with-explanation",
                "content": "    int maximalRectangle(vector<vector<char> > &matrix) {\\n        if(matrix.empty()){\\n            return 0;\\n        }\\n        int maxRec = 0;\\n        vector<int> height(matrix[0].size(), 0);\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j++){\\n                if(matrix[i][j] == '0'){\\n                    height[j] = 0;\\n                }\\n                else{\\n                    height[j]++;\\n                }\\n            }\\n            maxRec = max(maxRec, largestRectangleArea(height));\\n        }\\n        return maxRec;\\n    }\\n    \\n    int largestRectangleArea(vector<int> &height) {\\n        stack<int> s;\\n        height.push_back(0);\\n        int maxSize = 0;\\n        for(int i = 0; i < height.size(); i++){\\n            if(s.empty() || height[i] >= height[s.top()]){\\n                s.push(i);\\n            }\\n            else{\\n                int temp = height[s.top()];\\n                s.pop();\\n                maxSize = max(maxSize, temp * (s.empty() ? i : i - 1 - s.top()));\\n                i--;\\n            }\\n        }\\n        return maxSize;\\n    }\\n\\nIn order to solve this problem, I use the solution from \"Largest Rectangle in Histogram\". \\n\\nNow I assume you already know how to solve \"Largest Rectangle in Histogram\".\\n\\nWe can regard a matrix as many histograms. For example, given a matrix below:\\n\\n1 0 1 0\\n\\n0 1 0 1\\n\\n0 1 1 0\\n\\n1 0 1 0\\n\\n1 0 1 1\\n\\nFrom top to bottom, we can find these histograms:\\n\\nNumber 1: 1 0 1 0\\n\\nNumber 2: 0 1 0 1\\n\\nNumber 3: 0 2 1 0\\n\\nNumber 4: 1 0 2 0\\n\\nNumber 5: 2 0 3 1\\n\\nPass all of these histograms to the function which can solve \"Largest Rectangle in Histogram\". And then find the maximum one. \\n\\nFinally, we get the answer.",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int maximalRectangle(vector<vector<char> > &matrix) {\\n        if(matrix.empty()){\\n            return 0;\\n        }\\n        int maxRec = 0;\\n        vector<int> height(matrix[0].size(), 0);\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j++){\\n                if(matrix[i][j] == '0'){\\n                    height[j] = 0;\\n                }\\n                else{\\n                    height[j]++;\\n                }\\n            }\\n            maxRec = max(maxRec, largestRectangleArea(height));\\n        }\\n        return maxRec;\\n    }\\n    \\n    int largestRectangleArea(vector<int> &height) {\\n        stack<int> s;\\n        height.push_back(0);\\n        int maxSize = 0;\\n        for(int i = 0; i < height.size(); i++){\\n            if(s.empty() || height[i] >= height[s.top()]){\\n                s.push(i);\\n            }\\n            else{\\n                int temp = height[s.top()];\\n                s.pop();\\n                maxSize = max(maxSize, temp * (s.empty() ? i : i - 1 - s.top()));\\n                i--;\\n            }\\n        }\\n        return maxSize;\\n    }\\n\\nIn order to solve this problem, I use the solution from \"Largest Rectangle in Histogram\". \\n\\nNow I assume you already know how to solve \"Largest Rectangle in Histogram\".\\n\\nWe can regard a matrix as many histograms. For example, given a matrix below:\\n\\n1 0 1 0\\n\\n0 1 0 1\\n\\n0 1 1 0\\n\\n1 0 1 0\\n\\n1 0 1 1\\n\\nFrom top to bottom, we can find these histograms:\\n\\nNumber 1: 1 0 1 0\\n\\nNumber 2: 0 1 0 1\\n\\nNumber 3: 0 2 1 0\\n\\nNumber 4: 1 0 2 0\\n\\nNumber 5: 2 0 3 1\\n\\nPass all of these histograms to the function which can solve \"Largest Rectangle in Histogram\". And then find the maximum one. \\n\\nFinally, we get the answer.",
                "codeTag": "Unknown"
            },
            {
                "id": 872089,
                "title": "easy-c-soln-based-on-largest-histogram",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};\\n\\n/*\\n\\n2 0 2 1 1 \\n\\n3 1 3 2 2 \\n\\n\\nAlgorithm Outline:\\nlargestArea()\\n\\n        |\\n    |   |       |\\n|   |   |   |   |\\n\\n1   2   3   1   2   -> 5\\n0   1   2   3   4   -> index\\n\\n1. stack\\n2. iterate, check when value is less that top\\n3. While less than top, area = height of bar * distance from i (anchor)\\n4. Add to stack\\n5. Check while stack not empty\\n6. Return max_area\\n\\nmain()\\n1. Calculate histogra array for each row\\n2. Check largest area in that row\\n3. Return ans\\n\\n\\nHorizontal - can check length\\nVerticle - Keep height of each column top to bottum\\n\\ncalculate area for each histogram in each row \\n\\n1 0 1 0 0   -> 1\\n1 0 1 1 1   -> 3\\n1 1 1 1 1   -> 6\\n1 0 1 1 1\\n\\n*/\\n```\\nI appreciate your upvote !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};\\n\\n/*\\n\\n2 0 2 1 1 \\n\\n3 1 3 2 2 \\n\\n\\nAlgorithm Outline:\\nlargestArea()\\n\\n        |\\n    |   |       |\\n|   |   |   |   |\\n\\n1   2   3   1   2   -> 5\\n0   1   2   3   4   -> index\\n\\n1. stack\\n2. iterate, check when value is less that top\\n3. While less than top, area = height of bar * distance from i (anchor)\\n4. Add to stack\\n5. Check while stack not empty\\n6. Return max_area\\n\\nmain()\\n1. Calculate histogra array for each row\\n2. Check largest area in that row\\n3. Return ans\\n\\n\\nHorizontal - can check length\\nVerticle - Keep height of each column top to bottum\\n\\ncalculate area for each histogram in each row \\n\\n1 0 1 0 0   -> 1\\n1 0 1 1 1   -> 3\\n1 1 1 1 1   -> 6\\n1 0 1 1 1\\n\\n*/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1603766,
                "title": "python-o-mn-solution-explained",
                "content": "There is dp `O(n^2m^2)` solution. We can do better, with `O(nm*min(m,n))` complexity, if we use dynamic programming and keep two tables: `h[i][j]` is the largest `L`, such that all elements in `A[i:i+L-1][j] = 1`, and similar `w[i][j]`. Then we go through our original table `A` and we can calculate for `A[i][j]` the largest subarray that has `A[i][j]` as its bottom-left corner, it can be done with `O(n)` iterations.\\n\\nFinally, there is very smart way with complexity `O(nm)`, using problem **0084**. Indeed, for each row we can evaluate our skyline heights, given previous row in `O(m)` and do it `n` times. Additional complexity is `O(m)`, because actually we need to keep only one row at at time.\\n\\n#### Complexity\\nIt is `O(nm)` for time and `O(m)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maximalRectangle(self, matrix):\\n        def hist(heights):\\n            stack, ans = [], 0\\n            for i, h in enumerate(heights + [0]):\\n                while stack and heights[stack[-1]] >= h:\\n                    H = heights[stack.pop()]\\n                    W = i if not stack else i-stack[-1]-1\\n                    ans = max(ans, H*W)\\n                stack.append(i)\\n            return ans\\n        \\n        if not matrix or not matrix[0]: return 0\\n        m, n, ans = len(matrix[0]), len(matrix), 0\\n        row = [0]*m\\n        for i in range(n):\\n            for j in range(m):\\n                row[j] = 0 if matrix[i][j] == \"0\" else row[j] + 1\\n            ans = max(ans, hist(row))\\n            \\n        return ans\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**\\n",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def maximalRectangle(self, matrix):\\n        def hist(heights):\\n            stack, ans = [], 0\\n            for i, h in enumerate(heights + [0]):\\n                while stack and heights[stack[-1]] >= h:\\n                    H = heights[stack.pop()]\\n                    W = i if not stack else i-stack[-1]-1\\n                    ans = max(ans, H*W)\\n                stack.append(i)\\n            return ans\\n        \\n        if not matrix or not matrix[0]: return 0\\n        m, n, ans = len(matrix[0]), len(matrix), 0\\n        row = [0]*m\\n        for i in range(n):\\n            for j in range(m):\\n                row[j] = 0 if matrix[i][j] == \"0\" else row[j] + 1\\n            ans = max(ans, hist(row))\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255410,
                "title": "python-based-on-maximum-rectangle-in-histogram-clean-concise",
                "content": "**Idea**\\n- Sub problem of this problem is: [84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\\n- So, instead of solving sub-matrix problems, we can change to solve by sub-array problems.\\n\\n```python\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if len(matrix) == 0: return 0\\n        m, n = len(matrix), len(matrix[0])\\n        dp = [0] * n\\n        maxArea = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if matrix[r][c] == \"1\":\\n                    dp[c] += 1\\n                else:\\n                    dp[c] = 0\\n            maxArea = max(maxArea, self.maxRectangleInHistogram(dp))\\n        return maxArea\\n\\n    def maxRectangleInHistogram(self, heights):  # O(N)\\n        n = len(heights)\\n        st = [-1]\\n        maxArea = 0\\n        for i in range(n):\\n            while st[-1] != -1 and heights[st[-1]] >= heights[i]:\\n                currentHeight = heights[st.pop()]\\n                currentWidth = i - st[-1] - 1\\n                maxArea = max(maxArea, currentWidth * currentHeight)\\n            st.append(i)\\n        while st[-1] != -1:\\n            currentHeight = heights[st.pop()]\\n            currentWidth = n - st[-1] - 1\\n            maxArea = max(maxArea, currentWidth * currentHeight)\\n        return maxArea\\n```\\n\\nComplexity:\\n- Time: `O(R * C)`\\n- Space: `O(C)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if len(matrix) == 0: return 0\\n        m, n = len(matrix), len(matrix[0])\\n        dp = [0] * n\\n        maxArea = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if matrix[r][c] == \"1\":\\n                    dp[c] += 1\\n                else:\\n                    dp[c] = 0\\n            maxArea = max(maxArea, self.maxRectangleInHistogram(dp))\\n        return maxArea\\n\\n    def maxRectangleInHistogram(self, heights):  # O(N)\\n        n = len(heights)\\n        st = [-1]\\n        maxArea = 0\\n        for i in range(n):\\n            while st[-1] != -1 and heights[st[-1]] >= heights[i]:\\n                currentHeight = heights[st.pop()]\\n                currentWidth = i - st[-1] - 1\\n                maxArea = max(maxArea, currentWidth * currentHeight)\\n            st.append(i)\\n        while st[-1] != -1:\\n            currentHeight = heights[st.pop()]\\n            currentWidth = n - st[-1] - 1\\n            maxArea = max(maxArea, currentWidth * currentHeight)\\n        return maxArea\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254705,
                "title": "dp-thinking-process",
                "content": "\\n> **How can we identify a rectangle?**\\nThe point on the top-left corner and the point on te bottom-right corner.\\n```\\nFor each possible top-left\\n  For each possible bottom-right\\n    Check if matrix is made of 1s\\n\\t  If valid, we calculate area and update maxArea\\n```\\n\\n> **How can we check if matrix with top-left (i, j) and bottome-right(x, y) is made of 1s?**\\n> In Brute Force, we check each cells in matrix, that takes O(n^2) time complexity\\n> To optimize, we observe that, \\n```\\nwith (i, j) as  top-left, rectangle with (x, y) as bottom-right is valid if \\n  matrix[x][y] is 1\\n  && rectangle with (x, y - 1) as bottom-right is valid\\n  && rectangle with (x - 1, y) as bottom-right is valid\\n```\\n> We build an array isValid to save states. That takes O(1) time complexity.\\n****\\n```\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0) return 0;\\n        \\n        int rows = matrix.length, cols = matrix[0].length, maxArea = 0;\\n        // For each point topleft\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                // Construt isValid\\n                boolean[][] isValid = new boolean[rows][cols];\\n                // For each point bottom right \\n                for (int x = i; x < rows; x++) {\\n                    for (int y = j; y < cols; y++) {\\n                        if (matrix[x][y] != \\'1\\') continue;\\n                        // Check if valid matrix\\n                        isValid[x][y] = true;\\n                        if (x > i) isValid[x][y] = isValid[x][y] && isValid[x - 1][y];\\n                        if (y > j) isValid[x][y] = isValid[x][y] && isValid[x][y - 1];\\n                        // If valid, calculate area and update max\\n                        if (isValid[x][y]) {\\n                            int area = (x - i + 1) * (y - j + 1);\\n                            maxArea = Math.max(maxArea, area);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nFor each possible top-left\\n  For each possible bottom-right\\n    Check if matrix is made of 1s\\n\\t  If valid, we calculate area and update maxArea\\n```\n```\\nwith (i, j) as  top-left, rectangle with (x, y) as bottom-right is valid if \\n  matrix[x][y] is 1\\n  && rectangle with (x, y - 1) as bottom-right is valid\\n  && rectangle with (x - 1, y) as bottom-right is valid\\n```\n```\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0) return 0;\\n        \\n        int rows = matrix.length, cols = matrix[0].length, maxArea = 0;\\n        // For each point topleft\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                // Construt isValid\\n                boolean[][] isValid = new boolean[rows][cols];\\n                // For each point bottom right \\n                for (int x = i; x < rows; x++) {\\n                    for (int y = j; y < cols; y++) {\\n                        if (matrix[x][y] != \\'1\\') continue;\\n                        // Check if valid matrix\\n                        isValid[x][y] = true;\\n                        if (x > i) isValid[x][y] = isValid[x][y] && isValid[x - 1][y];\\n                        if (y > j) isValid[x][y] = isValid[x][y] && isValid[x][y - 1];\\n                        // If valid, calculate area and update max\\n                        if (isValid[x][y]) {\\n                            int area = (x - i + 1) * (y - j + 1);\\n                            maxArea = Math.max(maxArea, area);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1603593,
                "title": "java-detailed-explanation-easy-approach-o-row-col",
                "content": "```\\nIntuition :\\n1) Pick one row\\n2) Do summation of each index till that row\\n\\t\\ti) if any index value is 0 then put 0 else previous summation + 1 \\n3) Pass this array to get max area (84. Largest Rectangle in Historgram)\\n4) Update max area\\n\\n84. Largest Rectangle in Histogram\\nIntuition :\\n1) Max area will always have atleast one full bar height on any index\\n2) Find largest rectangle including each bar one by one.\\n\\ta) For each bar, We have to find it\\'s left limit & right limit (to know the maximum width)\\n\\tb) Find it\\'s left limit (where we find any index\\'s value is smaller than current index in left side array of curr index)\\n\\tc) Find it\\'s right limit (where we find any index\\'s value is smaller than current index in right side array of curr index\\n3) Take the maximum of all the max area found by each bar.\\n4) calculate area\\n\\t\\twidth * height\\nwhere width = right limit - left limit + 1\\nheight = curr index\\'s value\\n5) Update max area & return it\\n```\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length == 0)  return 0;\\n        int maxArea = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[] dp = new int[col];\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                dp[j] = matrix[i][j] == \\'1\\' ? dp[j]+1 : 0;\\n            }\\n            //treating dp[j] as histogram, solving max area problem there and updating the max area\\n            maxArea = Math.max(maxArea, findMaxAreaInHistogram(dp));\\n        }\\n        return maxArea;\\n    }\\n\\t//84. Largest Rectangle in Histogram code\\n    public int findMaxAreaInHistogram(int[] dp){\\n        int len = dp.length;\\n        int maxArea = 0;\\n        int[] left = new int[len];\\n        int[] right = new int[len];\\n        Stack<Integer> stack = new Stack<>();\\n        //traversing left to right, finding left limit\\n        for(int i=0;i<len;i++){\\n            if(stack.isEmpty()){\\n                stack.push(i);\\n                left[i] = 0;\\n            }else{\\n                while(!stack.isEmpty() && dp[stack.peek()] >= dp[i])\\n                    stack.pop();\\n                left[i] = stack.isEmpty() ? 0 : stack.peek()+1;\\n                stack.push(i);\\n            }\\n        }\\n        //doing empty to stack\\n        while(!stack.isEmpty())\\n            stack.pop();\\n        \\n        //traversing right to left, find right limit\\n        for(int i=len-1;i>=0;i--){\\n            if(stack.isEmpty()){\\n                stack.push(len-1);\\n                right[i] = len - 1;\\n            }else{\\n                while(!stack.isEmpty() && dp[stack.peek()] >= dp[i])\\n                    stack.pop();\\n                right[i] = stack.isEmpty() ? len-1 : stack.peek()-1;\\n                stack.push(i);\\n            }\\n        }\\n        //traversing the array , caculating area\\n        int[] area = new int[len];\\n        for(int i=0;i<len;i++){\\n            area[i] = (right[i] - left[i] + 1) * dp[i];\\n            maxArea = Math.max(maxArea, area[i]);\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nIntuition :\\n1) Pick one row\\n2) Do summation of each index till that row\\n\\t\\ti) if any index value is 0 then put 0 else previous summation + 1 \\n3) Pass this array to get max area (84. Largest Rectangle in Historgram)\\n4) Update max area\\n\\n84. Largest Rectangle in Histogram\\nIntuition :\\n1) Max area will always have atleast one full bar height on any index\\n2) Find largest rectangle including each bar one by one.\\n\\ta) For each bar, We have to find it\\'s left limit & right limit (to know the maximum width)\\n\\tb) Find it\\'s left limit (where we find any index\\'s value is smaller than current index in left side array of curr index)\\n\\tc) Find it\\'s right limit (where we find any index\\'s value is smaller than current index in right side array of curr index\\n3) Take the maximum of all the max area found by each bar.\\n4) calculate area\\n\\t\\twidth * height\\nwhere width = right limit - left limit + 1\\nheight = curr index\\'s value\\n5) Update max area & return it\\n```\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length == 0)  return 0;\\n        int maxArea = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[] dp = new int[col];\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                dp[j] = matrix[i][j] == \\'1\\' ? dp[j]+1 : 0;\\n            }\\n            //treating dp[j] as histogram, solving max area problem there and updating the max area\\n            maxArea = Math.max(maxArea, findMaxAreaInHistogram(dp));\\n        }\\n        return maxArea;\\n    }\\n\\t//84. Largest Rectangle in Histogram code\\n    public int findMaxAreaInHistogram(int[] dp){\\n        int len = dp.length;\\n        int maxArea = 0;\\n        int[] left = new int[len];\\n        int[] right = new int[len];\\n        Stack<Integer> stack = new Stack<>();\\n        //traversing left to right, finding left limit\\n        for(int i=0;i<len;i++){\\n            if(stack.isEmpty()){\\n                stack.push(i);\\n                left[i] = 0;\\n            }else{\\n                while(!stack.isEmpty() && dp[stack.peek()] >= dp[i])\\n                    stack.pop();\\n                left[i] = stack.isEmpty() ? 0 : stack.peek()+1;\\n                stack.push(i);\\n            }\\n        }\\n        //doing empty to stack\\n        while(!stack.isEmpty())\\n            stack.pop();\\n        \\n        //traversing right to left, find right limit\\n        for(int i=len-1;i>=0;i--){\\n            if(stack.isEmpty()){\\n                stack.push(len-1);\\n                right[i] = len - 1;\\n            }else{\\n                while(!stack.isEmpty() && dp[stack.peek()] >= dp[i])\\n                    stack.pop();\\n                right[i] = stack.isEmpty() ? len-1 : stack.peek()-1;\\n                stack.push(i);\\n            }\\n        }\\n        //traversing the array , caculating area\\n        int[] area = new int[len];\\n        for(int i=0;i<len;i++){\\n            area[i] = (right[i] - left[i] + 1) * dp[i];\\n            maxArea = Math.max(maxArea, area[i]);\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29140,
                "title": "pyrhon-o-n-2-solution-based-on-largest-rectangle-in-histogram",
                "content": "    class Solution:\\n    # @param matrix, a list of lists of 1 length string\\n    # @return an integer\\n    def maximalRectangle(self, matrix):\\n        if not matrix:\\n            return 0\\n        h, w = len(matrix), len(matrix[0])\\n        m = [[0]*w for _ in range(h)]\\n        for j in range(h):\\n            for i in range(w):\\n                if matrix[j][i] == '1':\\n                    m[j][i] = m[j-1][i] + 1\\n        return max(self.largestRectangleArea(row) for row in m)\\n\\n    def largestRectangleArea(self, height):\\n        height.append(0)\\n        stack, size = [], 0\\n        for i in range(len(height)):\\n            while stack and height[stack[-1]] > height[i]:\\n                h = height[stack.pop()]\\n                w = i if not stack else i-stack[-1]-1\\n                size = max(size, h*w)\\n            stack.append(i)\\n        return size\\n\\nm is every row height, it is easy to convert this to Largest Rectangle in Histogram",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param matrix, a list of lists of 1 length string\\n    # @return an integer\\n    def maximalRectangle(self, matrix):\\n        if not matrix:\\n            return 0\\n        h, w = len(matrix), len(matrix[0])\\n        m = [[0]*w for _ in range(h)]\\n        for j in range(h):\\n            for i in range(w):\\n                if matrix[j][i] == '1':\\n                    m[j][i] = m[j-1][i] + 1\\n        return max(self.largestRectangleArea(row) for row in m)\\n\\n    def largestRectangleArea(self, height):\\n        height.append(0)\\n        stack, size = [], 0\\n        for i in range(len(height)):\\n            while stack and height[stack[-1]] > height[i]:\\n                h = height[stack.pop()]\\n                w = i if not stack else i-stack[-1]-1\\n                size = max(size, h*w)\\n            stack.append(i)\\n        return size\\n\\nm is every row height, it is easy to convert this to Largest Rectangle in Histogram",
                "codeTag": "Java"
            },
            {
                "id": 29172,
                "title": "my-o-n-3-solution-for-your-reference",
                "content": "    class Solution {\\n    public:\\n        int maximalRectangle(vector<vector<char> > &matrix) {\\n            int num_i=matrix.size();\\n            if (num_i==0) return 0;\\n            int num_j=matrix[0].size();\\n            if (num_j==0) return 0;\\n            vector<vector<int>> max_x(num_i,vector<int>(num_j,0));  //number of consecutive 1s to the left of matrix[i][j], including itself\\n    \\n            int area=0;\\n            for (int i=0;i<num_i;i++){\\n                for (int j=0;j<num_j;j++){\\n                    if (matrix[i][j]=='1'){\\n                        if (j==0) max_x[i][j]=1;\\n                        else max_x[i][j]=max_x[i][j-1]+1;\\n                        int y=1;\\n                        int x=num_j;\\n                        while((i-y+1>=0)&&(matrix[i-y+1][j]=='1')){\\n                            x=min(x, max_x[i-y+1][j]);\\n                            area=max(area,x*y);\\n                            y++;\\n                        } \\n                    }\\n                }\\n            }\\n            \\n    \\n            \\n            return area;\\n            \\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maximalRectangle(vector<vector<char> > &matrix) {\\n            int num_i=matrix.size();\\n            if (num_i==0) return 0;\\n            int num_j=matrix[0].size();\\n            if (num_j==0) return 0;\\n            vector<vector<int>> max_x(num_i,vector<int>(num_j,0));  //number of consecutive 1s to the left of matrix[i][j], including itself\\n    \\n            int area=0;\\n            for (int i=0;i<num_i;i++){\\n                for (int j=0;j<num_j;j++){\\n                    if (matrix[i][j]=='1'){\\n                        if (j==0) max_x[i][j]=1;\\n                        else max_x[i][j]=max_x[i][j-1]+1;\\n                        int y=1;\\n                        int x=num_j;\\n                        while((i-y+1>=0)&&(matrix[i-y+1][j]=='1')){\\n                            x=min(x, max_x[i-y+1][j]);\\n                            area=max(area,x*y);\\n                            y++;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1603962,
                "title": "c-2-solutions-better-to-optimal-with-explanation-easy-to-understand",
                "content": "## Approach 1\\n\\n```\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n//base cases\\n        int n = matrix.size();\\n        if(n == 0) return 0;\\n        int m = matrix[0].size();\\n        if(n + m == 2) return matrix.front().front() == \\'1\\';\\n\\t\\t\\n\\t\\t//dp to store max number of adjacent 1s on left for each matrix[ i ][ j ]\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(matrix[i-1][j-1] != \\'0\\')\\n                  dp[i][j] = 1 + dp[i][j-1];\\n                // cout<<dp[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        \\n\\t\\t\\n\\t\\t//variable to store answer\\n        int area = 0;\\n\\t\\t\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n\\t\\t\\t//variable to store current width of rectangle of size 1 * dp[i][j]\\n                int width = dp[i][j];\\n                int k = i-1;\\n                int height = 1;\\n                area = max(area,width * height);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//now we\\'ll start moving upwards as long as we are inside the matrix\\n\\t\\t\\t\\t//ans change the height ans width accordingly to find the largest\\n\\t\\t\\t\\t//area which can be achieved including current element\\n\\t\\t\\t\\t//height always increases as we go up, width of rectangle till that height changes\\n\\t\\t\\t\\t//to minimum no. of left 1s for every upward element\\n                while(k > 0 and dp[k][j] > 0)\\n                {\\n                    height++;\\n                    width = min(width,dp[k--][j]);\\n\\t\\t\\t\\t\\t//for every acceptable height, we check if it can be our answer\\n                    area = max(width * height,area);\\n                }\\n            }\\n        }\\n        \\n        return area;\\n    }\\n```\\n\\n**Time Complexity :** O(n * m * n)\\n**Space Complexity :** O(n * m)\\n\\n## Approach 2\\n\\nThe second method utilizes the concept of the [Largest Reactangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/) to compute the largest rectangle for a given row efficiently.\\n\\n```\\n//code to find largest rectangle in histogram\\nint largestRectangle(vector<int> &dp)\\n    {\\n        stack<int> st;\\n        st.push(-1);\\n        int max_area = 0;\\n        for(int i=0;i<=dp.size();i++)\\n        {\\n            int val = (i == dp.size()) ? -1 : dp[i];\\n            while(st.top() != -1 and dp[st.top()] > val)\\n            {\\n                int height = dp[st.top()];\\n                st.pop();\\n                int width = i - st.top() - 1;\\n                max_area = max(max_area,width * height);\\n            }\\n            st.push(i);\\n        }\\n        return max_area;\\n    }\\n\\t\\n\\tint maximalRectangle(vector<vector<char>>& matrix) {\\n\\t\\t//base cases\\n        int n = matrix.size();\\n        if(n == 0) return 0;\\n        int m = matrix[0].size();\\n        if(n + m == 2) return matrix[0][0] == \\'1\\';\\n        \\n\\t\\t//program to calculate maximum height for current element\\n        vector<int> dp(m,0);\\n        \\n        int res = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n\\t\\t\\t\\t//if current 0 then total height is 0 else increase the previous height\\n                if(matrix[i][j] == \\'0\\') dp[j] = 0;\\n                else dp[j]++;\\n            }\\n            res = max(res,largestRectangle(dp));\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\n**Time Complexity :** O(n * (m + n) )\\n**Space Complexity :** O(n + n) [dp array + stack to find largest rectangle]\\n\\nDO upvote, if it helped you :)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n//base cases\\n        int n = matrix.size();\\n        if(n == 0) return 0;\\n        int m = matrix[0].size();\\n        if(n + m == 2) return matrix.front().front() == \\'1\\';\\n\\t\\t\\n\\t\\t//dp to store max number of adjacent 1s on left for each matrix[ i ][ j ]\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(matrix[i-1][j-1] != \\'0\\')\\n                  dp[i][j] = 1 + dp[i][j-1];\\n                // cout<<dp[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        \\n\\t\\t\\n\\t\\t//variable to store answer\\n        int area = 0;\\n\\t\\t\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n\\t\\t\\t//variable to store current width of rectangle of size 1 * dp[i][j]\\n                int width = dp[i][j];\\n                int k = i-1;\\n                int height = 1;\\n                area = max(area,width * height);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//now we\\'ll start moving upwards as long as we are inside the matrix\\n\\t\\t\\t\\t//ans change the height ans width accordingly to find the largest\\n\\t\\t\\t\\t//area which can be achieved including current element\\n\\t\\t\\t\\t//height always increases as we go up, width of rectangle till that height changes\\n\\t\\t\\t\\t//to minimum no. of left 1s for every upward element\\n                while(k > 0 and dp[k][j] > 0)\\n                {\\n                    height++;\\n                    width = min(width,dp[k--][j]);\\n\\t\\t\\t\\t\\t//for every acceptable height, we check if it can be our answer\\n                    area = max(width * height,area);\\n                }\\n            }\\n        }\\n        \\n        return area;\\n    }\\n```\n```\\n//code to find largest rectangle in histogram\\nint largestRectangle(vector<int> &dp)\\n    {\\n        stack<int> st;\\n        st.push(-1);\\n        int max_area = 0;\\n        for(int i=0;i<=dp.size();i++)\\n        {\\n            int val = (i == dp.size()) ? -1 : dp[i];\\n            while(st.top() != -1 and dp[st.top()] > val)\\n            {\\n                int height = dp[st.top()];\\n                st.pop();\\n                int width = i - st.top() - 1;\\n                max_area = max(max_area,width * height);\\n            }\\n            st.push(i);\\n        }\\n        return max_area;\\n    }\\n\\t\\n\\tint maximalRectangle(vector<vector<char>>& matrix) {\\n\\t\\t//base cases\\n        int n = matrix.size();\\n        if(n == 0) return 0;\\n        int m = matrix[0].size();\\n        if(n + m == 2) return matrix[0][0] == \\'1\\';\\n        \\n\\t\\t//program to calculate maximum height for current element\\n        vector<int> dp(m,0);\\n        \\n        int res = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n\\t\\t\\t\\t//if current 0 then total height is 0 else increase the previous height\\n                if(matrix[i][j] == \\'0\\') dp[j] = 0;\\n                else dp[j]++;\\n            }\\n            res = max(res,largestRectangle(dp));\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1603612,
                "title": "python3-dynamic-programming-explained",
                "content": "First, we form an auxiliary matrix `dp` storing the number of consecutive \"1\"s on the left side of the corresponding slot at the input matrix. Then we iterate slots of the `dp` upwards and find all possible rectangles that can be formed having the current slot as the right bottom angle. The first possible rectangle area is equal to `dp[i][j] * 1`. We go up and check whether the above slot can form a rectangle with the current one and if yes, the rectangle area will be equal to `min(dp[i][j], dp[i - 1][j]) * 2`, and so on. The maximum value is our result.\\n\\nTime: **O(rows*cols * rows)**  - because when searching for a max rectangle using our `dp`, in worst case we have to scan all rows up to the first one for every slot\\nSpace: **O(rows*cols)** - for an aux matrix\\n\\nRuntime: 420 ms, faster than **20.81%** of Python3 online submissions for Maximal Rectangle.\\nMemory Usage: 15.6 MB, less than **21.06%** of Python3 online submissions for Maximal Rectangle.\\n\\n```\\nclass Solution:\\n    def maximalRectangle(self, m: List[List[str]]) -> int:\\n        rows = len(m)\\n        if not rows:\\n            return 0\\n        \\n        cols = len(m[0])\\n        \\n        dp = [[0] * cols for _ in range(rows)]\\n\\n        for i in range(rows): # fill dp, value = number of 1s on the left side\\n            acc = 0\\n            \\n            for j in range(cols):\\n                if m[i][j] == \"1\":\\n                    acc += 1\\n                else:\\n                    acc = 0\\n                    \\n                dp[i][j] = acc\\n                \\n        res = 0\\n        \\n        for i in reversed(range(rows)):\\n            for j in reversed(range(cols)):\\n                bSide, rSide = dp[i][j], 0 # bottom and right side\\n                k = i\\n                \\n                while k > -1 and dp[k][j]:  # iterate all possible rectangles\\n                    bSide = min(bSide, dp[k][j])\\n                    rSide += 1\\n\\n                    res = max(res, bSide * rSide)\\n                    \\n                    k -= 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, m: List[List[str]]) -> int:\\n        rows = len(m)\\n        if not rows:\\n            return 0\\n        \\n        cols = len(m[0])\\n        \\n        dp = [[0] * cols for _ in range(rows)]\\n\\n        for i in range(rows): # fill dp, value = number of 1s on the left side\\n            acc = 0\\n            \\n            for j in range(cols):\\n                if m[i][j] == \"1\":\\n                    acc += 1\\n                else:\\n                    acc = 0\\n                    \\n                dp[i][j] = acc\\n                \\n        res = 0\\n        \\n        for i in reversed(range(rows)):\\n            for j in reversed(range(cols)):\\n                bSide, rSide = dp[i][j], 0 # bottom and right side\\n                k = i\\n                \\n                while k > -1 and dp[k][j]:  # iterate all possible rectangles\\n                    bSide = min(bSide, dp[k][j])\\n                    rSide += 1\\n\\n                    res = max(res, bSide * rSide)\\n                    \\n                    k -= 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749853,
                "title": "easy-solution-c",
                "content": "**Tabulation code : Dynamic Programming** : Idea behind this\\nTaking a small refernce from largest rectangle area Question , where we have to calculate largest area possible by using stack approach. We can boil down this problem in sub - problem that are related to the largest rectangle area problem . where in this we traverse this matrix for every value of j from 0 to m , if the matrix value at that particular is 1 then we just increment the height vector that we have consider. at each traversal of i we calculate the area at the last from the refrence question . calculate the max at the last.\\n\\n```\\n// Maximal Rectangle\\n    // tab\\n        class Solution {\\n        public:\\n            int largestRectangleArea(vector < int > & histo) {\\n            stack < int > st;\\n            int maxA = 0;\\n            int n = histo.size();\\n            for (int i = 0; i <= n; i++) {\\n                while (!st.empty() && (i == n || histo[st.top()] >= histo[i])) {\\n                int height = histo[st.top()];\\n                st.pop();\\n                int width;\\n                if (st.empty())\\n                    width = i;\\n                else\\n                    width = i - st.top() - 1;\\n                maxA = max(maxA, width * height);\\n                }\\n                st.push(i);\\n            }\\n            return maxA;\\n            }\\n            int maximalRectangle(vector<vector<char>>& matrix) {\\n                int maxiArea = 0, n = matrix.size(), m = matrix[0].size();\\n                vector<int> height(m,0);\\n                \\n                for(int i=0;i<n;i++){\\n                    for(int j=0;j<m;j++){\\n                        if(matrix[i][j] == \\'1\\') height[j]++;\\n                        else height[j] = 0;\\n                    }   \\n                    int area = largestRectangleArea(height);\\n                    maxiArea = max(maxiArea,area);\\n                }\\n                return maxiArea;\\n            }\\n        };\\n```\\n<br>\\n<div>Happy Coding</div>\\nPlease do upvote this post. \\n\\n![image](https://assets.leetcode.com/users/images/5ce11bf6-0db9-4239-bbb9-dfe5d76443f3_1666346629.9681695.gif)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n// Maximal Rectangle\\n    // tab\\n        class Solution {\\n        public:\\n            int largestRectangleArea(vector < int > & histo) {\\n            stack < int > st;\\n            int maxA = 0;\\n            int n = histo.size();\\n            for (int i = 0; i <= n; i++) {\\n                while (!st.empty() && (i == n || histo[st.top()] >= histo[i])) {\\n                int height = histo[st.top()];\\n                st.pop();\\n                int width;\\n                if (st.empty())\\n                    width = i;\\n                else\\n                    width = i - st.top() - 1;\\n                maxA = max(maxA, width * height);\\n                }\\n                st.push(i);\\n            }\\n            return maxA;\\n            }\\n            int maximalRectangle(vector<vector<char>>& matrix) {\\n                int maxiArea = 0, n = matrix.size(), m = matrix[0].size();\\n                vector<int> height(m,0);\\n                \\n                for(int i=0;i<n;i++){\\n                    for(int j=0;j<m;j++){\\n                        if(matrix[i][j] == \\'1\\') height[j]++;\\n                        else height[j] = 0;\\n                    }   \\n                    int area = largestRectangleArea(height);\\n                    maxiArea = max(maxiArea,area);\\n                }\\n                return maxiArea;\\n            }\\n        };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519263,
                "title": "java-tc-o-rc-sc-o-min-r-c-optimal-stack-solution",
                "content": "```java\\n/**\\n * This solution is converting the input matrix row by row (OR column by column)\\n * to Largest Rectangle in a Histogram.\\n *\\n * For each row (OR column) cumulative height is calculated. Then use stack to\\n * save the increasing height index.\\n *\\n * Time Complexity: O(R * C). Each element is added to stack once and popped\\n * from stack once.\\n *\\n * Space Complexity: O(min(R,C)). We will either store a row or a column\\n *\\n * R = Number of rows in the matrix. C = Number of columns in the matrix.\\n */\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input matrix is null\");\\n        }\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n\\n        if (cols < rows) {\\n            return maximalRectangleHelper(matrix, rows, cols, true);\\n        } else {\\n            return maximalRectangleHelper(matrix, cols, rows, false);\\n        }\\n    }\\n\\n    private int maximalRectangleHelper(char[][] matrix, int big, int small, boolean isColsSmall) {\\n        int[] heights = new int[small];\\n        int largestRectangle = 0;\\n        for (int i = 0; i < big; i++) {\\n            Deque<Integer> stack = new ArrayDeque<>();\\n            for (int j = 0; j <= small; j++) {\\n                if (j < small) {\\n                    if (isColsSmall) {\\n                        heights[j] = matrix[i][j] == \\'0\\' ? 0 : heights[j] + 1;\\n                    } else {\\n                        heights[j] = matrix[j][i] == \\'0\\' ? 0 : heights[j] + 1;\\n                    }\\n\\n                }\\n                while (!stack.isEmpty() && (j == small || heights[stack.peek()] >= heights[j])) {\\n                    int h = heights[stack.pop()];\\n                    int left = stack.isEmpty() ? -1 : stack.peek();\\n                    largestRectangle = Math.max(largestRectangle, (j - 1 - left) * h);\\n                }\\n                stack.push(j);\\n            }\\n        }\\n        return largestRectangle;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other similar question on LeetCode:\\n- [84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1519257/Java-or-TC:-O(N)-or-SC:-O(N)-or-Optimal-Stack-solution)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * This solution is converting the input matrix row by row (OR column by column)\\n * to Largest Rectangle in a Histogram.\\n *\\n * For each row (OR column) cumulative height is calculated. Then use stack to\\n * save the increasing height index.\\n *\\n * Time Complexity: O(R * C). Each element is added to stack once and popped\\n * from stack once.\\n *\\n * Space Complexity: O(min(R,C)). We will either store a row or a column\\n *\\n * R = Number of rows in the matrix. C = Number of columns in the matrix.\\n */\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input matrix is null\");\\n        }\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n\\n        if (cols < rows) {\\n            return maximalRectangleHelper(matrix, rows, cols, true);\\n        } else {\\n            return maximalRectangleHelper(matrix, cols, rows, false);\\n        }\\n    }\\n\\n    private int maximalRectangleHelper(char[][] matrix, int big, int small, boolean isColsSmall) {\\n        int[] heights = new int[small];\\n        int largestRectangle = 0;\\n        for (int i = 0; i < big; i++) {\\n            Deque<Integer> stack = new ArrayDeque<>();\\n            for (int j = 0; j <= small; j++) {\\n                if (j < small) {\\n                    if (isColsSmall) {\\n                        heights[j] = matrix[i][j] == \\'0\\' ? 0 : heights[j] + 1;\\n                    } else {\\n                        heights[j] = matrix[j][i] == \\'0\\' ? 0 : heights[j] + 1;\\n                    }\\n\\n                }\\n                while (!stack.isEmpty() && (j == small || heights[stack.peek()] >= heights[j])) {\\n                    int h = heights[stack.pop()];\\n                    int left = stack.isEmpty() ? -1 : stack.peek();\\n                    largestRectangle = Math.max(largestRectangle, (j - 1 - left) * h);\\n                }\\n                stack.push(j);\\n            }\\n        }\\n        return largestRectangle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407011,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# My youtube channel - KeetCode(Ex-Amazon)\\nI create 142 videos for leetcode questions as of April 10, 2023. I believe my channel helps you prepare for the coming technical interviews. Please subscribe my channel!\\n\\n### Please subscribe my channel - KeetCode(Ex-Amazon) from here.\\n\\n**I created a video for this question. I believe you can understand easily with visualization.** \\n\\n**Largest Color Value in a Directed Graph video**\\nhttps://qr.paps.jp/asEvO\\n\\n**My youtube channel - KeetCode(Ex-Amazon)**\\nhttps://qr.paps.jp/q2r7Z\\n\\n\\n![FotoJet (38).jpg](https://assets.leetcode.com/users/images/9b0c0cf7-7e85-4976-b69e-41f4a3fa14d9_1680906259.8040502.jpeg)\\n\\n\\n---\\n\\n\\n\\n# Approach\\n1. Check if the input matrix is empty, if it is return 0.\\n\\n2. Determine the number of columns in the matrix (n) by getting the length of the first row of the matrix.\\n\\n3. Create a list called heights, with n+1 elements, and initialize each element to 0.\\n\\n4. Create a variable called max_area and initialize it to 0.\\n\\n5. For each row in the matrix, do the following:\\n    - Iterate through each column in the row, and update the corresponding height in the \"heights\" list.\\n    - If the character in the matrix is \"1\", increment the corresponding height in the \"heights\" list by 1, otherwise set it to 0.\\n\\n6. Create an empty stack and add -1 to it.\\n\\n7. For each element in the \"heights\" list, do the following:\\n    - Compare the current height to the height of the top element in the stack.\\n    - If the current height is less than the height of the top element of the stack, do the following:\\n        - Pop the top element of the stack and calculate the area of the rectangle formed by the popped height.\\n        - Calculate the width of the rectangle by subtracting the index of the current element from the index of the new top element of the stack.\\n        - Calculate the area of the rectangle by multiplying the height and width.\\n        - Update the maximum area seen so far if the area of the current rectangle is larger than the current maximum.\\n    - Append the index of the current element to the stack.\\n\\n8. Return the maximum area seen so far.\\n\\n# Complexity\\n- Time complexity:  O(m*n)\\nm is the number of rows in the input matrix and n is the number of columns. This is because we have to iterate through each element in the matrix at least once, and the time it takes to process each element is constant.\\n\\n- Space complexity: O(n)\\nn is the number of columns in the matrix. This is because we are creating a \"heights\" list with n+1 elements, and a stack that could have up to n+1 elements. The rest of the variables used in the algorithm are constants and do not contribute significantly to the space complexity.\\n\\n# Python\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        \\n        n = len(matrix[0])\\n        heights = [0] * (n + 1)\\n        max_area = 0\\n\\n        for row in matrix:\\n            for i in range(n):\\n                heights[i] = heights[i] + 1 if row[i] == \"1\" else 0\\n            \\n            stack = [-1]\\n            for i in range(n + 1):\\n                while heights[i] < heights[stack[-1]]:\\n                    h = heights[stack.pop()]\\n                    w = i - stack[-1] - 1\\n                    max_area = max(max_area, h * w)\\n                \\n                stack.append(i)\\n        \\n        return max_area\\n```\\n\\n# JavaScript\\n```\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nvar maximalRectangle = function(matrix) {\\n    if (!matrix.length) {\\n        return 0;\\n    }\\n    \\n    const n = matrix[0].length;\\n    const heights = new Array(n + 1).fill(0);\\n    let maxArea = 0;\\n    \\n    for (let row of matrix) {\\n        for (let i = 0; i < n; i++) {\\n            heights[i] = row[i] === \\'1\\' ? heights[i] + 1 : 0;\\n        }\\n        \\n        const stack = [-1];\\n        for (let i = 0; i < n + 1; i++) {\\n            while (heights[i] < heights[stack[stack.length - 1]]) {\\n                const h = heights[stack.pop()];\\n                const w = i - stack[stack.length - 1] - 1;\\n                maxArea = Math.max(maxArea, h * w);\\n            }\\n            stack.push(i);\\n        }\\n    }\\n    \\n    return maxArea;    \\n};\\n```\\n\\n# Java\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix == null || matrix.length == 0) {\\n            return 0;\\n        }\\n        \\n        int n = matrix[0].length;\\n        int[] heights = new int[n + 1];\\n        int maxArea = 0;\\n        \\n        for (char[] row : matrix) {\\n            for (int i = 0; i < n; i++) {\\n                heights[i] = row[i] == \\'1\\' ? heights[i] + 1 : 0;\\n            }\\n            \\n            Stack<Integer> stack = new Stack<>();\\n            stack.push(-1);\\n            for (int i = 0; i < n + 1; i++) {\\n                while (stack.peek() != -1 && heights[i] < heights[stack.peek()]) {\\n                    int h = heights[stack.pop()];\\n                    int w = i - stack.peek() - 1;\\n                    maxArea = Math.max(maxArea, h * w);\\n                }\\n                stack.push(i);\\n            }\\n        }\\n        \\n        return maxArea;        \\n    }\\n}\\n```\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) {\\n            return 0;\\n        }\\n        \\n        int n = matrix[0].size();\\n        vector<int> heights(n + 1);\\n        int maxArea = 0;\\n        \\n        for (auto row : matrix) {\\n            for (int i = 0; i < n; i++) {\\n                heights[i] = row[i] == \\'1\\' ? heights[i] + 1 : 0;\\n            }\\n            \\n            stack<int> st;\\n            st.push(-1);\\n            for (int i = 0; i < n + 1; i++) {\\n                while (st.top() != -1 && heights[i] < heights[st.top()]) {\\n                    int h = heights[st.top()];\\n                    st.pop();\\n                    int w = i - st.top() - 1;\\n                    maxArea = max(maxArea, h * w);\\n                }\\n                st.push(i);\\n            }\\n        }\\n        \\n        return maxArea;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        \\n        n = len(matrix[0])\\n        heights = [0] * (n + 1)\\n        max_area = 0\\n\\n        for row in matrix:\\n            for i in range(n):\\n                heights[i] = heights[i] + 1 if row[i] == \"1\" else 0\\n            \\n            stack = [-1]\\n            for i in range(n + 1):\\n                while heights[i] < heights[stack[-1]]:\\n                    h = heights[stack.pop()]\\n                    w = i - stack[-1] - 1\\n                    max_area = max(max_area, h * w)\\n                \\n                stack.append(i)\\n        \\n        return max_area\\n```\n```\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nvar maximalRectangle = function(matrix) {\\n    if (!matrix.length) {\\n        return 0;\\n    }\\n    \\n    const n = matrix[0].length;\\n    const heights = new Array(n + 1).fill(0);\\n    let maxArea = 0;\\n    \\n    for (let row of matrix) {\\n        for (let i = 0; i < n; i++) {\\n            heights[i] = row[i] === \\'1\\' ? heights[i] + 1 : 0;\\n        }\\n        \\n        const stack = [-1];\\n        for (let i = 0; i < n + 1; i++) {\\n            while (heights[i] < heights[stack[stack.length - 1]]) {\\n                const h = heights[stack.pop()];\\n                const w = i - stack[stack.length - 1] - 1;\\n                maxArea = Math.max(maxArea, h * w);\\n            }\\n            stack.push(i);\\n        }\\n    }\\n    \\n    return maxArea;    \\n};\\n```\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix == null || matrix.length == 0) {\\n            return 0;\\n        }\\n        \\n        int n = matrix[0].length;\\n        int[] heights = new int[n + 1];\\n        int maxArea = 0;\\n        \\n        for (char[] row : matrix) {\\n            for (int i = 0; i < n; i++) {\\n                heights[i] = row[i] == \\'1\\' ? heights[i] + 1 : 0;\\n            }\\n            \\n            Stack<Integer> stack = new Stack<>();\\n            stack.push(-1);\\n            for (int i = 0; i < n + 1; i++) {\\n                while (stack.peek() != -1 && heights[i] < heights[stack.peek()]) {\\n                    int h = heights[stack.pop()];\\n                    int w = i - stack.peek() - 1;\\n                    maxArea = Math.max(maxArea, h * w);\\n                }\\n                stack.push(i);\\n            }\\n        }\\n        \\n        return maxArea;        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) {\\n            return 0;\\n        }\\n        \\n        int n = matrix[0].size();\\n        vector<int> heights(n + 1);\\n        int maxArea = 0;\\n        \\n        for (auto row : matrix) {\\n            for (int i = 0; i < n; i++) {\\n                heights[i] = row[i] == \\'1\\' ? heights[i] + 1 : 0;\\n            }\\n            \\n            stack<int> st;\\n            st.push(-1);\\n            for (int i = 0; i < n + 1; i++) {\\n                while (st.top() != -1 && heights[i] < heights[st.top()]) {\\n                    int h = heights[st.top()];\\n                    st.pop();\\n                    int w = i - st.top() - 1;\\n                    maxArea = max(maxArea, h * w);\\n                }\\n                st.push(i);\\n            }\\n        }\\n        \\n        return maxArea;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 644117,
                "title": "using-max-area-of-histofgram",
                "content": "This guy deserves an appluase for a fabulous explanation ! (video in Hindi)\\n\\nhttps://www.youtube.com/watch?v=St0Jf_VmG_g&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&index=8\\n\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        if not matrix:\\n            return 0\\n        \\n        prev = [0]*len(matrix[0])\\n        max_area = 0\\n        for row in matrix:\\n            curr_row = [int(i) for i in row]\\n            for j in range (len(curr_row)):\\n                curr_row[j] = curr_row[j] + prev[j] if curr_row[j] !=0 else 0\\n            max_area = max(max_area, self.largestRectangleArea(curr_row))\\n            prev = curr_row\\n            \\n        return max_area\\n                \\n            \\n    \\n    #largest ares of a histogram !!\\n    def largestRectangleArea(self, heights):      \\n\\n        def get_small_r(heights):\\n            stack_r = []\\n            sm_r = [0] * len(heights)\\n            for j in range(len(heights) - 1, -1 , -1):\\n\\n                while stack_r and heights[stack_r[-1]] >= heights[j]:\\n                    stack_r.pop()\\n\\n                if(not stack_r):\\n                    sm_r[j] = -1\\n                else:\\n                    sm_r[j] = stack_r[-1]\\n                stack_r.append(j) \\n            return sm_r\\n\\n        def get_small_l(heights):\\n            stack_l = []\\n            sm_l = [None] * len(heights)\\n            for j in range(len(heights)):\\n                while stack_l and heights[stack_l[-1]] >= heights[j]:\\n                    stack_l.pop()\\n                if(not stack_l):\\n                    sm_l[j] = -1\\n                else:\\n                    sm_l[j] = stack_l[-1]\\n                stack_l.append(j) \\n            return sm_l\\n\\n        max_area = 0\\n        stack_l = get_small_l(heights)\\n        stack_r = get_small_r(heights)\\n        \\n        for j in range (len(heights)):\\n            l = j - stack_l[j] -1 if stack_l[j] != -1 else j\\n            r = stack_r[j] -1 -j  if stack_r[j] != -1 else len(heights) - j -1\\n            t = 1 + l + r \\n            max_area = max(max_area,   heights[j] *t )\\n        return max_area\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        if not matrix:\\n            return 0\\n        \\n        prev = [0]*len(matrix[0])\\n        max_area = 0\\n        for row in matrix:\\n            curr_row = [int(i) for i in row]\\n            for j in range (len(curr_row)):\\n                curr_row[j] = curr_row[j] + prev[j] if curr_row[j] !=0 else 0\\n            max_area = max(max_area, self.largestRectangleArea(curr_row))\\n            prev = curr_row\\n            \\n        return max_area\\n                \\n            \\n    \\n    #largest ares of a histogram !!\\n    def largestRectangleArea(self, heights):      \\n\\n        def get_small_r(heights):\\n            stack_r = []\\n            sm_r = [0] * len(heights)\\n            for j in range(len(heights) - 1, -1 , -1):\\n\\n                while stack_r and heights[stack_r[-1]] >= heights[j]:\\n                    stack_r.pop()\\n\\n                if(not stack_r):\\n                    sm_r[j] = -1\\n                else:\\n                    sm_r[j] = stack_r[-1]\\n                stack_r.append(j) \\n            return sm_r\\n\\n        def get_small_l(heights):\\n            stack_l = []\\n            sm_l = [None] * len(heights)\\n            for j in range(len(heights)):\\n                while stack_l and heights[stack_l[-1]] >= heights[j]:\\n                    stack_l.pop()\\n                if(not stack_l):\\n                    sm_l[j] = -1\\n                else:\\n                    sm_l[j] = stack_l[-1]\\n                stack_l.append(j) \\n            return sm_l\\n\\n        max_area = 0\\n        stack_l = get_small_l(heights)\\n        stack_r = get_small_r(heights)\\n        \\n        for j in range (len(heights)):\\n            l = j - stack_l[j] -1 if stack_l[j] != -1 else j\\n            r = stack_r[j] -1 -j  if stack_r[j] != -1 else len(heights) - j -1\\n            t = 1 + l + r \\n            max_area = max(max_area,   heights[j] *t )\\n        return max_area\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584368,
                "title": "c-20ms-99-simple-easy-small-commented",
                "content": "\\n![image](https://assets.leetcode.com/users/images/3dd5e53c-fa9c-4ad9-b765-67145629724c_1637224731.3485026.png)\\n\\n\\n**General idea : do precalculating contigious ones (vertical and horizontal)**\\n\\nRuntime: 20 ms, faster than 98.92% of C++ online submissions for Maximal Rectangle.\\nMemory Usage: 12.1 MB, less than 53.69% of C++ online submissions for Maximal Rectangle.\\n```\\nclass Solution {\\npublic:\\n  int maximalRectangle(vector<vector<char>>& matrix) {\\n    if(matrix.empty()) return 0;\\n    int y = matrix.size(), x = matrix[0].size(), answer = 0;\\n    vector<vector<int>> a(y,vector<int>(x)), b(y,vector<int>(x));\\n    \\n    for(int j = 0; j != x; j++)\\n      for(int i = y - 1, k = 0; i >= 0; i--)\\n        if(matrix[i][j] == \\'1\\') a[i][j] = ++k;\\n        else a[i][j] = k = 0;\\n      \\n    for(int i = 0; i != y; i++)\\n      for(int j = x - 1, k = 0; j >= 0; j--)\\n        if(matrix[i][j] == \\'1\\') b[i][j] = ++k;\\n        else b[i][j] = k = 0;\\n    \\n    for(int i = 0; i != y; i++)\\n      for(int j = 0; j != x; j++){\\n        int Y = a[i][j], X = b[i][j];\\n        for(int w = j + 1, lim = j + X; w < lim; w++)\\n          if(Y > a[i][w]) {answer = max(answer, Y * (w - j)); Y = a[i][w];}\\n        \\n        answer = max(answer, Y * X);\\n      }\\n            \\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maximalRectangle(vector<vector<char>>& matrix) {\\n    if(matrix.empty()) return 0;\\n    int y = matrix.size(), x = matrix[0].size(), answer = 0;\\n    vector<vector<int>> a(y,vector<int>(x)), b(y,vector<int>(x));\\n    \\n    for(int j = 0; j != x; j++)\\n      for(int i = y - 1, k = 0; i >= 0; i--)\\n        if(matrix[i][j] == \\'1\\') a[i][j] = ++k;\\n        else a[i][j] = k = 0;\\n      \\n    for(int i = 0; i != y; i++)\\n      for(int j = x - 1, k = 0; j >= 0; j--)\\n        if(matrix[i][j] == \\'1\\') b[i][j] = ++k;\\n        else b[i][j] = k = 0;\\n    \\n    for(int i = 0; i != y; i++)\\n      for(int j = 0; j != x; j++){\\n        int Y = a[i][j], X = b[i][j];\\n        for(int w = j + 1, lim = j + X; w < lim; w++)\\n          if(Y > a[i][w]) {answer = max(answer, Y * (w - j)); Y = a[i][w];}\\n        \\n        answer = max(answer, Y * X);\\n      }\\n            \\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385631,
                "title": "variation-of-mah-c-a-bit-long-but-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\t\\tvector<int> NSL(vector<int> heights){ // Function to find indices of next smallest left element\\n        vector<int> left;\\n        stack<pair<int,int>> st;\\n        for(int i=0;i<heights.size();i++){\\n            if(st.empty())\\n                left.push_back(-1);\\n            else if(!st.empty() && st.top().first<heights[i])\\n                left.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first>=heights[i]){\\n                while(!st.empty() && st.top().first>=heights[i])\\n                    st.pop();\\n                if(st.empty())\\n                    left.push_back(-1);\\n                else \\n                    left.push_back(st.top().second);\\n            }\\n            st.push({heights[i],i});\\n        }\\n        return left;\\n    }\\n    vector<int> NSR(vector<int> heights){  // Function to find indices of next smallest right element\\n        vector<int> right;\\n        stack<pair<int,int>> st;\\n        for(int i=heights.size()-1;i>=0;i--){\\n            if(st.empty())\\n                right.push_back(heights.size());\\n            else if(!st.empty() && st.top().first<heights[i])\\n                right.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first>=heights[i]){\\n                while(!st.empty() && st.top().first>=heights[i])\\n                    st.pop();\\n                if(st.empty())\\n                    right.push_back(heights.size());\\n                else \\n                    right.push_back(st.top().second);\\n            }\\n            st.push({heights[i],i});\\n        }\\n        reverse(right.begin(),right.end());\\n        return right;\\n    }\\n    int MAH(vector<int>& heights) {  //Function to find maximum area of histogram\\n        vector<int> right;\\n        vector<int> left;\\n        \\n        right=NSR(heights);\\n        left=NSL(heights);\\n        \\n        vector<int> width;\\n        int mx=0;\\n        for(int i=0;i<left.size();i++){\\n            width.push_back(right[i]-left[i]-1);\\n        }\\n        \\n        for(int i=0;i<heights.size();i++){\\n            mx=max(mx,heights[i]*width[i]);\\n        }\\n        \\n        return mx;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {  // Finally......our required Maximal Rectangle Function\\n        int n=matrix.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]-\\'0\\');\\n        }\\n        int mx= MAH(v);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==\\'0\\')\\n                    v[j]=0;\\n                else\\n                    v[j]=v[j]+(matrix[i][j]-\\'0\\');\\n            }\\n            mx=max(mx,MAH(v));\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\tvector<int> NSL(vector<int> heights){ // Function to find indices of next smallest left element\\n        vector<int> left;\\n        stack<pair<int,int>> st;\\n        for(int i=0;i<heights.size();i++){\\n            if(st.empty())\\n                left.push_back(-1);\\n            else if(!st.empty() && st.top().first<heights[i])\\n                left.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first>=heights[i]){\\n                while(!st.empty() && st.top().first>=heights[i])\\n                    st.pop();\\n                if(st.empty())\\n                    left.push_back(-1);\\n                else \\n                    left.push_back(st.top().second);\\n            }\\n            st.push({heights[i],i});\\n        }\\n        return left;\\n    }\\n    vector<int> NSR(vector<int> heights){  // Function to find indices of next smallest right element\\n        vector<int> right;\\n        stack<pair<int,int>> st;\\n        for(int i=heights.size()-1;i>=0;i--){\\n            if(st.empty())\\n                right.push_back(heights.size());\\n            else if(!st.empty() && st.top().first<heights[i])\\n                right.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first>=heights[i]){\\n                while(!st.empty() && st.top().first>=heights[i])\\n                    st.pop();\\n                if(st.empty())\\n                    right.push_back(heights.size());\\n                else \\n                    right.push_back(st.top().second);\\n            }\\n            st.push({heights[i],i});\\n        }\\n        reverse(right.begin(),right.end());\\n        return right;\\n    }\\n    int MAH(vector<int>& heights) {  //Function to find maximum area of histogram\\n        vector<int> right;\\n        vector<int> left;\\n        \\n        right=NSR(heights);\\n        left=NSL(heights);\\n        \\n        vector<int> width;\\n        int mx=0;\\n        for(int i=0;i<left.size();i++){\\n            width.push_back(right[i]-left[i]-1);\\n        }\\n        \\n        for(int i=0;i<heights.size();i++){\\n            mx=max(mx,heights[i]*width[i]);\\n        }\\n        \\n        return mx;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {  // Finally......our required Maximal Rectangle Function\\n        int n=matrix.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]-\\'0\\');\\n        }\\n        int mx= MAH(v);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==\\'0\\')\\n                    v[j]=0;\\n                else\\n                    v[j]=v[j]+(matrix[i][j]-\\'0\\');\\n            }\\n            mx=max(mx,MAH(v));\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255610,
                "title": "java-simple-detailed-explanation-histogram-approach-o-n-2",
                "content": "**Note:**\\nIf you haven\\'t solved the [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram) problem, I\\'d highly recommend to solve that first. You can check my detailed explanation for the same [here](https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1255567/Java-or-Explanation-or-Stack-approach).\\n\\nApproach:\\n1. The idea here is to break the problem in parts. We see each set of rows as a histogram, and evaluate the height of the building considering row in consideration/iteration currently as the base, and evaluating the maximum area using above mentioned **Histogram** approach.\\n2. Then we continue to next row and consider the imaginary histogram with this row as base, and again evaluate the maximum area in this histogram.\\n3. Similarly, we do the above at each row, and keep updating the **maxArea** and have the max. rectangle area at the end.\\n\\nFor example, if the matrix is:\\n1 0 1 0 0\\n1 0 1 1 1\\n1 1 1 1 1\\n1 0 0 1 0\\n\\n**Round-1:**\\nWe consider row-1. Histogram at this point is, `1 0 1 0 0`.\\nHere, `heights[0] = [1,0,1,0,0]`.\\n\\n**Round-2:**\\nWe consider row-1 and row-2.\\nSo now, histogram is of max. height 2, and buildings are like:\\n`1 0 1 0 0`\\n`1 0 1 1 1`\\nSo, here, `heights[1] = [2 0 2 1 1]`.\\n\\nSimilarly, at next levels,\\n`heights[3] = [3 1 3 2 2]`\\n`heights[4] = [4 0 0 3 0]`\\n\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0)\\n            return 0;\\n        int m = matrix.length, n = matrix[0].length;\\n        int[] heights = new int[n];\\n        int maxArea = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (matrix[i][j] == \\'0\\')\\n                    heights[j] = 0;\\n                if (matrix[i][j] == \\'1\\')\\n                    heights[j] += 1;\\n            }\\n            maxArea = Math.max(maxArea, largestRectangleArea(heights));\\n        }\\n        return maxArea;\\n    }\\n\\n    private int largestRectangleArea(int[] heights) {\\n        Stack<int[]> stack = new Stack<>();\\n        int maxArea = 0;\\n\\n        for (int i = 0; i < heights.length; i++) {\\n            int[] block = new int[]{i, heights[i]};\\n            while (!stack.isEmpty() && stack.peek()[1] > heights[i]) {\\n                block = stack.pop();\\n                maxArea = Math.max(maxArea, block[1] * (i - block[0]));\\n                block[1] = heights[i];\\n            }\\n            stack.push(block);\\n        }\\n        while (!stack.isEmpty()) {\\n            int[] block = stack.pop();\\n            maxArea = Math.max(maxArea, block[1] * (heights.length - block[0]));\\n        }\\n        return maxArea;\\n    }\\n}\\n```\\n\\n-------------------------------------------------------------------------------------------\\nHope this helps! Please let me know if something isn\\'t clear/missing. I\\'ll try to improve.\\n\\nAlso, please upvote this if you find this useful. Happy Coding!!",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0)\\n            return 0;\\n        int m = matrix.length, n = matrix[0].length;\\n        int[] heights = new int[n];\\n        int maxArea = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (matrix[i][j] == \\'0\\')\\n                    heights[j] = 0;\\n                if (matrix[i][j] == \\'1\\')\\n                    heights[j] += 1;\\n            }\\n            maxArea = Math.max(maxArea, largestRectangleArea(heights));\\n        }\\n        return maxArea;\\n    }\\n\\n    private int largestRectangleArea(int[] heights) {\\n        Stack<int[]> stack = new Stack<>();\\n        int maxArea = 0;\\n\\n        for (int i = 0; i < heights.length; i++) {\\n            int[] block = new int[]{i, heights[i]};\\n            while (!stack.isEmpty() && stack.peek()[1] > heights[i]) {\\n                block = stack.pop();\\n                maxArea = Math.max(maxArea, block[1] * (i - block[0]));\\n                block[1] = heights[i];\\n            }\\n            stack.push(block);\\n        }\\n        while (!stack.isEmpty()) {\\n            int[] block = stack.pop();\\n            maxArea = Math.max(maxArea, block[1] * (heights.length - block[0]));\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 403093,
                "title": "java-simple-dp-solution-with-state-table",
                "content": "DP State\\n```\\n1 0 1 0 0      1 0 1 0 0\\n1 0 1 1 1  =>  2 0 2 1 1\\n1 1 1 1 1  =>  3 1 3 2 2\\n1 0 0 1 0      4 0 0 3 0\\n```\\nFind the **max area** row by row, as we can see `3 1 3 2 2` contains the **max area**.\\n\\n```java\\nclass Solution {\\n  public int maximalRectangle(char[][] matrix) {\\n    if (matrix.length <= 0) return 0;\\n    int n = matrix.length;\\n    int m = matrix[0].length;\\n    int[][] dp = new int[n][m];\\n    int maxArea = 0;\\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < m; j++) {\\n        if (i == 0)\\n\\t\\t  dp[i][j] = matrix[i][j] == \\'1\\' ? 1 : 0;\\n        else\\n\\t\\t  dp[i][j] = matrix[i][j] == \\'1\\' ? (dp[i-1][j] + 1) : 0;\\n        int min = dp[i][j];\\n        for (int k = j; k >= 0; k--) {\\n          if (min == 0) break;\\n          if (dp[i][k] < min) min = dp[i][k];\\n          maxArea = Math.max(maxArea, min * (j - k + 1));\\n        }\\n      }\\n    }\\n    return maxArea;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n1 0 1 0 0      1 0 1 0 0\\n1 0 1 1 1  =>  2 0 2 1 1\\n1 1 1 1 1  =>  3 1 3 2 2\\n1 0 0 1 0      4 0 0 3 0\\n```\n```java\\nclass Solution {\\n  public int maximalRectangle(char[][] matrix) {\\n    if (matrix.length <= 0) return 0;\\n    int n = matrix.length;\\n    int m = matrix[0].length;\\n    int[][] dp = new int[n][m];\\n    int maxArea = 0;\\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < m; j++) {\\n        if (i == 0)\\n\\t\\t  dp[i][j] = matrix[i][j] == \\'1\\' ? 1 : 0;\\n        else\\n\\t\\t  dp[i][j] = matrix[i][j] == \\'1\\' ? (dp[i-1][j] + 1) : 0;\\n        int min = dp[i][j];\\n        for (int k = j; k >= 0; k--) {\\n          if (min == 0) break;\\n          if (dp[i][k] < min) min = dp[i][k];\\n          maxArea = Math.max(maxArea, min * (j - k + 1));\\n        }\\n      }\\n    }\\n    return maxArea;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29080,
                "title": "my-solution-on-java-using-dp",
                "content": "Open matrix from top to the bottom line by line, counting height of each column. Then check for each  column (only if it wasn't counted already) how many times it appears to the right and to the left.  Area = (left+right)*height. Just pick the max one. Pretty fast\\n\\n    public class Solution {\\n        public int maximalRectangle(char[][] matrix) {\\n            int area = 0, new_area, r, l;\\n            if(matrix.length > 0){\\n                int[] line = new int[matrix[0].length];\\n                boolean[] is_processed = new boolean[matrix[0].length];\\n                for(int i = 0; i < matrix.length; i++){\\n                    for(int j = 0; j < matrix[i].length; j++){\\n                        if (matrix[i][j] == '1') {\\n                            line[j]++;\\n                            is_processed[j] = false;\\n                        } else {\\n                            line[j] = 0;\\n                            is_processed[j] = true;\\n                        }\\n                    }\\n                    for(int j = 0; j < matrix[i].length; j++){\\n                        if(is_processed[j]) continue;\\n                        r = l = 1;\\n                        while((j + r < line.length)&&(line[j + r] >= line[j])){\\n                            if(line[j + r] == line[j]) is_processed[j + r] = true;\\n                            r++;\\n                        }\\n                        while((j - l >= 0)&&(line[j - l] >= line[j])) l++;\\n                        new_area = (r + l - 1)*line[j];\\n                        if (new_area > area) area = new_area;\\n                    }\\n                }\\n            } return area;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maximalRectangle(char[][] matrix) {\\n            int area = 0, new_area, r, l;\\n            if(matrix.length > 0){\\n                int[] line = new int[matrix[0].length];\\n                boolean[] is_processed = new boolean[matrix[0].length];\\n                for(int i = 0; i < matrix.length; i++){\\n                    for(int j = 0; j < matrix[i].length; j++){\\n                        if (matrix[i][j] == '1') {\\n                            line[j]++;\\n                            is_processed[j] = false;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1921903,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n\\tfunc maximalRectangle(_ matrix: [[Character]]) -> Int {\\n        if matrix.count == 0 || matrix[0].count == 0 { return 0 }\\n        var max = 0\\n\\n        for i in 0..<matrix.count {\\n            for j in 0..<matrix[0].count {\\n                let area = helper(matrix, i, j, matrix.count,  matrix[0].count)\\n                max = max > area ? max : area\\n            }\\n        }\\n        \\n        return max\\n    }\\n\\n\\n    func helper(_ matrix: [[Character]], _ i: Int, _ j: Int, _ maxI: Int, _ maxJ: Int) -> Int {\\n        if matrix[i][j] == \"0\" || maxI == i || maxJ == j { return 0 }\\n        var x = -1\\n        var y = -1\\n\\n        loop: \\n        for row in i..<maxI {\\n            for col in j..<maxJ {\\n                if matrix[row][col] == \"0\" {\\n                    x = row\\n                    y = col\\n                    break loop\\n                }\\n            }\\n        }\\n        \\n        if x >= 0 {\\n            return max(helper(matrix, i, j, x, maxJ), helper(matrix, i, j, maxI, y))\\n        } else {\\n            return (maxI - i) * (maxJ - j)\\n        } \\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\tfunc maximalRectangle(_ matrix: [[Character]]) -> Int {\\n        if matrix.count == 0 || matrix[0].count == 0 { return 0 }\\n        var max = 0\\n\\n        for i in 0..<matrix.count {\\n            for j in 0..<matrix[0].count {\\n                let area = helper(matrix, i, j, matrix.count,  matrix[0].count)\\n                max = max > area ? max : area\\n            }\\n        }\\n        \\n        return max\\n    }\\n\\n\\n    func helper(_ matrix: [[Character]], _ i: Int, _ j: Int, _ maxI: Int, _ maxJ: Int) -> Int {\\n        if matrix[i][j] == \"0\" || maxI == i || maxJ == j { return 0 }\\n        var x = -1\\n        var y = -1\\n\\n        loop: \\n        for row in i..<maxI {\\n            for col in j..<maxJ {\\n                if matrix[row][col] == \"0\" {\\n                    x = row\\n                    y = col\\n                    break loop\\n                }\\n            }\\n        }\\n        \\n        if x >= 0 {\\n            return max(helper(matrix, i, j, x, maxJ), helper(matrix, i, j, maxI, y))\\n        } else {\\n            return (maxI - i) * (maxJ - j)\\n        } \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705081,
                "title": "c-dp-stack-o-n-faster-than-90",
                "content": "```\\nclass Solution {\\npublic:\\n    int getarea(vector<vector<int>>&dp , int row , int n)\\n    {\\n        \\n        vector<int> pre(n) ; \\n        pre[0] = -1 ;\\n        vector<int> next(n) ;\\n        next[n-1] = n ; \\n        stack<int> s ; \\n        s.push(0) ; \\n        \\n        for(int i = 1 ; i<n ; i++)\\n        {\\n            if(dp[row][s.top()] < dp[row][i]) \\n            {\\n                pre[i] = s.top() ; \\n                s.push(i) ; \\n            }\\n            else\\n            {\\n                while(!s.empty() && dp[row][s.top()] >= dp[row][i]) \\n                {\\n                    s.pop() ; \\n                }\\n                if(s.empty())\\n                {\\n                    pre[i] = -1 ; \\n                    s.push(i) ;\\n                }\\n                else\\n                {\\n                    pre[i] = s.top() ; \\n                    s.push(i) ; \\n                }\\n            }\\n        }\\n        // s.clear() ; \\n        while(!s.empty()) s.pop() ; \\n        \\n        s.push(n-1) ; \\n        for(int i = n-2 ; i>=0 ; i--)\\n        {\\n            if(dp[row][s.top()] < dp[row][i]) \\n            {\\n                next[i] = s.top() ; \\n                s.push(i) ; \\n            }\\n            else\\n            {\\n                while(!s.empty() && dp[row][s.top()] >= dp[row][i]) \\n                {\\n                    s.pop() ; \\n                }\\n                if(s.empty())\\n                {\\n                    s.push(i) ;\\n                    next[i] = n ; \\n                }\\n                else\\n                {\\n                    next[i] = s.top() ; \\n                    s.push(i) ; \\n                }\\n            }\\n        }\\n        int ans = INT_MIN ; \\n        int area ; \\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            area = ( next[i] - pre[i] - 1) * dp[row][i] ; \\n            ans = max(ans , area) ; \\n        }\\n        return ans ; \\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        int n = matrix.size() ; \\n        int m = matrix[0].size() ; \\n        vector<vector<int>> dp(n , vector<int> (m)) ; \\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                if(i == 0)\\n                {\\n                    if(matrix[i][j] == \\'0\\') dp[i][j] = 0 ;\\n                    else dp[i][j] = 1 ; \\n                    continue ;  \\n                }\\n                if(matrix[i][j] == \\'0\\') dp[i][j] = 0 ; \\n                else dp[i][j] = dp[i-1][j] + 1 ; \\n            }\\n        }\\n        int ans = INT_MIN ; \\n        \\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int area = getarea(dp , i , m ) ; \\n            ans = max(ans , area) ;\\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getarea(vector<vector<int>>&dp , int row , int n)\\n    {\\n        \\n        vector<int> pre(n) ; \\n        pre[0] = -1 ;\\n        vector<int> next(n) ;\\n        next[n-1] = n ; \\n        stack<int> s ; \\n        s.push(0) ; \\n        \\n        for(int i = 1 ; i<n ; i++)\\n        {\\n            if(dp[row][s.top()] < dp[row][i]) \\n            {\\n                pre[i] = s.top() ; \\n                s.push(i) ; \\n            }\\n            else\\n            {\\n                while(!s.empty() && dp[row][s.top()] >= dp[row][i]) \\n                {\\n                    s.pop() ; \\n                }\\n                if(s.empty())\\n                {\\n                    pre[i] = -1 ; \\n                    s.push(i) ;\\n                }\\n                else\\n                {\\n                    pre[i] = s.top() ; \\n                    s.push(i) ; \\n                }\\n            }\\n        }\\n        // s.clear() ; \\n        while(!s.empty()) s.pop() ; \\n        \\n        s.push(n-1) ; \\n        for(int i = n-2 ; i>=0 ; i--)\\n        {\\n            if(dp[row][s.top()] < dp[row][i]) \\n            {\\n                next[i] = s.top() ; \\n                s.push(i) ; \\n            }\\n            else\\n            {\\n                while(!s.empty() && dp[row][s.top()] >= dp[row][i]) \\n                {\\n                    s.pop() ; \\n                }\\n                if(s.empty())\\n                {\\n                    s.push(i) ;\\n                    next[i] = n ; \\n                }\\n                else\\n                {\\n                    next[i] = s.top() ; \\n                    s.push(i) ; \\n                }\\n            }\\n        }\\n        int ans = INT_MIN ; \\n        int area ; \\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            area = ( next[i] - pre[i] - 1) * dp[row][i] ; \\n            ans = max(ans , area) ; \\n        }\\n        return ans ; \\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        int n = matrix.size() ; \\n        int m = matrix[0].size() ; \\n        vector<vector<int>> dp(n , vector<int> (m)) ; \\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                if(i == 0)\\n                {\\n                    if(matrix[i][j] == \\'0\\') dp[i][j] = 0 ;\\n                    else dp[i][j] = 1 ; \\n                    continue ;  \\n                }\\n                if(matrix[i][j] == \\'0\\') dp[i][j] = 0 ; \\n                else dp[i][j] = dp[i-1][j] + 1 ; \\n            }\\n        }\\n        int ans = INT_MIN ; \\n        \\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int area = getarea(dp , i , m ) ; \\n            ans = max(ans , area) ;\\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239576,
                "title": "c-based-on-largest-rectangle-in-histogram",
                "content": "```\\nint maxHistogram(vector<int>& heights)\\n    {\\n        heights.push_back(0);\\n        int n = heights.size();\\n        stack<int> st;\\n        int res = 0;\\n        \\n        int i = 0;\\n        while(i < n)\\n        {\\n            if(st.empty() || heights[i] >= heights[st.top()])\\n              st.push(i++);\\n            else\\n             {\\n                 int top = st.top();\\n                 st.pop();\\n                 res = max(res, heights[top] * (st.empty() ? i : i - st.top() - 1));\\n             }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) \\n    {\\n        if(matrix.empty())\\n            return 0;\\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int res = 0;\\n        \\n        vector<int> height(n, 0);\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(matrix[i][j] == \\'1\\')\\n                    height[j]++;\\n                else\\n                    height[j] = 0;\\n            }\\n            \\n            res = max(res, maxHistogram(height));\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nint maxHistogram(vector<int>& heights)\\n    {\\n        heights.push_back(0);\\n        int n = heights.size();\\n        stack<int> st;\\n        int res = 0;\\n        \\n        int i = 0;\\n        while(i < n)\\n        {\\n            if(st.empty() || heights[i] >= heights[st.top()])\\n              st.push(i++);\\n            else\\n             {\\n                 int top = st.top();\\n                 st.pop();\\n                 res = max(res, heights[top] * (st.empty() ? i : i - st.top() - 1));\\n             }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) \\n    {\\n        if(matrix.empty())\\n            return 0;\\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int res = 0;\\n        \\n        vector<int> height(n, 0);\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(matrix[i][j] == \\'1\\')\\n                    height[j]++;\\n                else\\n                    height[j] = 0;\\n            }\\n            \\n            res = max(res, maxHistogram(height));\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29122,
                "title": "step-by-step-thoughts-on-the-problem",
                "content": "Just like my previous post of the largest area under the histogram.\\n\\nWe can solve this problem by solve level by level and the sub-problem is just the largest rectangle under the histogram.\\n\\nCode:\\n\\n    class Solution {\\n    public:\\n        int maximalRectangle(vector<vector<char>>& matrix) {\\n            /** largest rectangle based solution **/\\n            if(matrix.size()<=0 || matrix[0].size()<=0)\\n                return 0;\\n            int m=matrix.size();\\n            int n=matrix[0].size()+1;\\n            int h=0, w=0, result=0;\\n            vector<int> height(n, 0);\\n            for(int i=0; i<m; i++){\\n                stack<int> s;\\n                for(int j=0; j<n; j++){\\n                    /** update the current row ended height array **/\\n                    if(j<n-1){\\n                        if(matrix[i][j]=='1')  height[j]+=1;\\n                        else height[j]=0;\\n                    }\\n                    /** use the histogram-max-rectangle-module **/\\n                    while(!s.empty() && height[s.top()]>=height[j]){\\n                        h=height[s.top()];\\n                        s.pop();\\n                        w=s.empty() ? j:j-s.top()-1;\\n                        if(h*w>result) result=h*w;\\n                    }\\n                    s.push(j);\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maximalRectangle(vector<vector<char>>& matrix) {\\n            /** largest rectangle based solution **/\\n            if(matrix.size()<=0 || matrix[0].size()<=0)\\n                return 0;\\n            int m=matrix.size();\\n            int n=matrix[0].size()+1;\\n            int h=0, w=0, result=0;\\n            vector<int> height(n, 0);\\n            for(int i=0; i<m; i++){\\n                stack<int> s;\\n                for(int j=0; j<n; j++){\\n                    /** update the current row ended height array **/\\n                    if(j<n-1){\\n                        if(matrix[i][j]=='1')  height[j]+=1;\\n                        else height[j]=0;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 29143,
                "title": "c-solution-uff0c-simple-and-clean-code",
                "content": "     int maximalRectangle(vector<vector<char>>& matrix) {\\n        const int row = matrix.size();\\n        if (0 == row) return 0;\\n        const int col = matrix[0].size();\\n        vector<vector<int>> ones(row, vector<int>(col+1, 0));\\n        for (int i = 0; i < row; i++) \\n         for (int j = 0; j < col; j++) {\\n              if (matrix[i][j] == '1') {\\n                  ones[i][j] = 1 + (i > 0 ? ones[i-1][j] : 0);\\n              }\\n         }\\n         int i = 0, max_a = 0;\\n         for (i; i < row; i++) {\\n             stack<int> stk;\\n             vector<int> cur = ones[i];\\n             int idx = 0;\\n             while (idx < cur.size()) {\\n                 if (stk.empty() || cur[idx] >= cur[stk.top()]) {\\n                     stk.push(idx++);\\n                 } else {\\n                    int h = stk.top();\\n                    stk.pop();\\n                    max_a = max(max_a, cur[h] *(stk.empty() ? idx : idx - stk.top() - 1));\\n                 }\\n             }\\n         }\\n         return max_a;\\n    }",
                "solutionTags": [],
                "code": "     int maximalRectangle(vector<vector<char>>& matrix) {\\n        const int row = matrix.size();\\n        if (0 == row) return 0;\\n        const int col = matrix[0].size();\\n        vector<vector<int>> ones(row, vector<int>(col+1, 0));\\n        for (int i = 0; i < row; i++) \\n         for (int j = 0; j < col; j++) {\\n              if (matrix[i][j] == '1') {\\n                  ones[i][j] = 1 + (i > 0 ? ones[i-1][j] : 0);\\n              }\\n         }\\n         int i = 0, max_a = 0;\\n         for (i; i < row; i++) {\\n             stack<int> stk;\\n             vector<int> cur = ones[i];\\n             int idx = 0;\\n             while (idx < cur.size()) {\\n                 if (stk.empty() || cur[idx] >= cur[stk.top()]) {\\n                     stk.push(idx++);\\n                 } else {\\n                    int h = stk.top();\\n                    stk.pop();\\n                    max_a = max(max_a, cur[h] *(stk.empty() ? idx : idx - stk.top() - 1));\\n                 }\\n             }\\n         }\\n         return max_a;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2954041,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> st;\\n        int n=heights.size();\\n        vector<int> left(n);\\n        vector<int> ryt(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n                            st.pop();\\n            if(st.empty())\\n                left[i]=0;\\n            else\\n                left[i]=st.top()+1;\\n            st.push(i);\\n        }\\n        while(!st.empty())\\n            st.pop();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n                st.pop();\\n            if(st.empty())\\n                ryt[i]=n-1;\\n            else\\n                ryt[i]=st.top()-1;\\n            st.push(i);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int area=heights[i]*(ryt[i]-left[i]+1);\\n            ans=max(ans, area);\\n        }\\n        return ans;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                dp[i][j]=matrix[i][j]-\\'0\\';\\n        \\n        for(int i=1;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(dp[i][j]!=0)\\n                    dp[i][j]+=dp[i-1][j];\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n            ans=max(ans, largestRectangleArea(dp[i]));\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> st;\\n        int n=heights.size();\\n        vector<int> left(n);\\n        vector<int> ryt(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n                            st.pop();\\n            if(st.empty())\\n                left[i]=0;\\n            else\\n                left[i]=st.top()+1;\\n            st.push(i);\\n        }\\n        while(!st.empty())\\n            st.pop();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n                st.pop();\\n            if(st.empty())\\n                ryt[i]=n-1;\\n            else\\n                ryt[i]=st.top()-1;\\n            st.push(i);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int area=heights[i]*(ryt[i]-left[i]+1);\\n            ans=max(ans, area);\\n        }\\n        return ans;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                dp[i][j]=matrix[i][j]-\\'0\\';\\n        \\n        for(int i=1;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(dp[i][j]!=0)\\n                    dp[i][j]+=dp[i-1][j];\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n            ans=max(ans, largestRectangleArea(dp[i]));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228033,
                "title": "dp-concise-explanation-97-faster-javascript-js-es6",
                "content": "\\n`ALGORITHM:` \\n- Initiate an aux-matrix with zeroes to begin with.\\n- The first row of aux-matrix is same as matrix\\'s first row.\\n- Values in aux-matrix reflect the height for that column, like this:\\n```\\n[\"1\",\"0\",\"1\",\"0\",\"0\"]\\n[\"1\",\"0\",\"1\",\"1\",\"1\"]\\n[\"1\",\"1\",\"1\",\"1\",\"1\"]\\n[\"1\",\"0\",\"0\",\"1\",\"0\"]\\nbecomes\\n[\"1\",\"0\",\"1\",\"0\",\"0\"]\\n[\"2\",\"0\",\"2\",\"1\",\"1\"]\\n[\"3\",\"1\",\"3\",\"2\",\"2\"]\\n[\"4\",\"0\",\"0\",\"3\",\"0\"]]\\n```\\n- Another for-loop moves the column-pointer backwards, while updating the maxArea \\n\\n`CODE:`\\n```\\nconst maximalRectangle = function(matrix) {\\n  if (!matrix.length) return 0;\\n  const ROWS = matrix.length;\\n  const COLS = matrix[0].length;\\n  const dp = Array.from({length:ROWS}, ()=> Array(COLS).fill(0));\\n  let maxArea = 0;\\n  \\n  for (let row = 0; row < ROWS; row++) {\\n    for (let col = 0; col < COLS; col++) {\\n\\t\\n\\t  //update height\\n      if(row === 0) dp[row][col] = matrix[row][col] == \\'1\\' ? 1 : 0;\\n      else dp[row][col] = matrix[row][col] == \\'1\\' ? (dp[row-1][col] + 1) : 0;\\n\\t  \\n      //update area \\n\\t  let minHeight = dp[row][col];\\n\\t  for(let pointer = col; pointer >= 0; pointer--) {\\n\\t\\t if (minHeight === 0) break;\\n\\t\\t if (dp[row][pointer] < minHeight) minHeight = dp[row][pointer];\\n\\t\\t maxArea = Math.max(maxArea, minHeight * (col - pointer + 1));\\n\\t  }\\n   }\\n  }\\n  return maxArea;  \\n};\\n```\\n![image](https://assets.leetcode.com/users/images/6e93b417-3583-4f58-9804-5719bc8dd99e_1621868328.6235888.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n[\"1\",\"0\",\"1\",\"0\",\"0\"]\\n[\"1\",\"0\",\"1\",\"1\",\"1\"]\\n[\"1\",\"1\",\"1\",\"1\",\"1\"]\\n[\"1\",\"0\",\"0\",\"1\",\"0\"]\\nbecomes\\n[\"1\",\"0\",\"1\",\"0\",\"0\"]\\n[\"2\",\"0\",\"2\",\"1\",\"1\"]\\n[\"3\",\"1\",\"3\",\"2\",\"2\"]\\n[\"4\",\"0\",\"0\",\"3\",\"0\"]]\\n```\n```\\nconst maximalRectangle = function(matrix) {\\n  if (!matrix.length) return 0;\\n  const ROWS = matrix.length;\\n  const COLS = matrix[0].length;\\n  const dp = Array.from({length:ROWS}, ()=> Array(COLS).fill(0));\\n  let maxArea = 0;\\n  \\n  for (let row = 0; row < ROWS; row++) {\\n    for (let col = 0; col < COLS; col++) {\\n\\t\\n\\t  //update height\\n      if(row === 0) dp[row][col] = matrix[row][col] == \\'1\\' ? 1 : 0;\\n      else dp[row][col] = matrix[row][col] == \\'1\\' ? (dp[row-1][col] + 1) : 0;\\n\\t  \\n      //update area \\n\\t  let minHeight = dp[row][col];\\n\\t  for(let pointer = col; pointer >= 0; pointer--) {\\n\\t\\t if (minHeight === 0) break;\\n\\t\\t if (dp[row][pointer] < minHeight) minHeight = dp[row][pointer];\\n\\t\\t maxArea = Math.max(maxArea, minHeight * (col - pointer + 1));\\n\\t  }\\n   }\\n  }\\n  return maxArea;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1603527,
                "title": "c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row = matrix.size(); \\n        if(row==0) return 0;\\n        int col = matrix[0].size();\\n        vector<vector<int>> grid(row,vector<int> (col,0));\\n        int area=0;\\n        for(int i=0; i<row; ++i){\\n            for(int j=0; j<col; ++j){\\n                if(i==0){\\n                    grid[i][j]=matrix[i][j]-\\'0\\';\\n                }else{\\n                    if(matrix[i][j]==\\'0\\') grid[i][j]=0;\\n                    else grid[i][j] = 1+grid[i-1][j];\\n                }\\n            }\\n            \\n            vector<int> left(col), right(col);\\n            stack<int> stk;\\n            for(int j=0; j<col; ++j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) left[j]=-1 ;\\n                else left[j]=stk.top();\\n                stk.push(j);\\n            }\\n            \\n            while(!stk.empty()) stk.pop();\\n            \\n            for(int j=col-1; j>=0; --j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) right[j]=col;\\n                else right[j]=stk.top();\\n                stk.push(j);\\n            }\\n            \\n            for(int j=0;j<col;++j){\\n                area=max(area, (grid[i][j]*(right[j]-left[j]-1)));\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row = matrix.size(); \\n        if(row==0) return 0;\\n        int col = matrix[0].size();\\n        vector<vector<int>> grid(row,vector<int> (col,0));\\n        int area=0;\\n        for(int i=0; i<row; ++i){\\n            for(int j=0; j<col; ++j){\\n                if(i==0){\\n                    grid[i][j]=matrix[i][j]-\\'0\\';\\n                }else{\\n                    if(matrix[i][j]==\\'0\\') grid[i][j]=0;\\n                    else grid[i][j] = 1+grid[i-1][j];\\n                }\\n            }\\n            \\n            vector<int> left(col), right(col);\\n            stack<int> stk;\\n            for(int j=0; j<col; ++j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) left[j]=-1 ;\\n                else left[j]=stk.top();\\n                stk.push(j);\\n            }\\n            \\n            while(!stk.empty()) stk.pop();\\n            \\n            for(int j=col-1; j>=0; --j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) right[j]=col;\\n                else right[j]=stk.top();\\n                stk.push(j);\\n            }\\n            \\n            for(int j=0;j<col;++j){\\n                area=max(area, (grid[i][j]*(right[j]-left[j]-1)));\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331110,
                "title": "maximal-rectangle-using-max-area-histogram-aditya-verma-c",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    /*\\n    \\n    1.> for every row consider as 1 block of height \\n    2.> write maximum are in histogram\\n    3.> for MAH \\n        a> create a left array of next smaller element  to left\\n        b> create a right array of next smaller to right\\n        c> create a width array\\n        d>make area array \\n        e> take max area\\n    4> for all row it return a max area\\n    5> take maximu of all returned value\\n    6> which is our answer\\n    \\n    \\n    \\n    */\\n    int MAH(int*arr,int n)\\n    {  // next smaller to right side\\n        stack<pair<int,int>>stk1;\\n        vector<int>right;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!stk1.empty() and stk1.top().first>=arr[i])\\n            {\\n                stk1.pop();\\n            }\\n            if(stk1.empty())\\n            {\\n                right.push_back(n);\\n            }\\n            else\\n                right.push_back(stk1.top().second);\\n            \\n            stk1.push({arr[i],i});\\n        }\\n        reverse(right.begin(),right.end());\\n        // next smaller to left side of array\\n        \\n        stack<pair<int,int>>stk2;\\n        vector<int>left;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!stk2.empty() and stk2.top().first>=arr[i])\\n            {\\n                stk2.pop();\\n            }\\n            if(stk2.empty())\\n            {\\n                left.push_back(-1);\\n            }\\n            else\\n            {\\n                left.push_back(stk2.top().second);\\n            }\\n            stk2.push({arr[i],i});\\n        }\\n        \\n        // make width array and area area;\\n        vector<int>area;\\n        for(int i=0;i<n;i++)\\n        {\\n            area.push_back((right[i]-left[i]-1)*arr[i]);\\n        }\\n        int no=*max_element(area.begin(),area.end());\\n        return no;\\n        \\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) \\n    {   if(matrix.empty())\\n        return 0;\\n        int n=matrix[0].size();\\n         \\n        \\n         int arr[200];\\n         vector<int>check;\\n         for(int i=0;i<n;i++)\\n         {\\n             arr[i]=0;\\n         }\\n        for(int i=0;i<matrix.size();i++)\\n        {     int k=0;\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    arr[k]=arr[k]+1;\\n                     k++;\\n                    \\n                }\\n                else\\n                {\\n                    arr[k]=0;\\n                    k++;\\n                }\\n                    \\n           }\\n           \\n          int no=MAH(arr,n);\\n           \\n          check.push_back(no);\\n        }\\n        int ans=0;\\n        ans=*max_element(check.begin(),check.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    /*\\n    \\n    1.> for every row consider as 1 block of height \\n    2.> write maximum are in histogram\\n    3.> for MAH \\n        a> create a left array of next smaller element  to left\\n        b> create a right array of next smaller to right\\n        c> create a width array\\n        d>make area array \\n        e> take max area\\n    4> for all row it return a max area\\n    5> take maximu of all returned value\\n    6> which is our answer\\n    \\n    \\n    \\n    */\\n    int MAH(int*arr,int n)\\n    {  // next smaller to right side\\n        stack<pair<int,int>>stk1;\\n        vector<int>right;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!stk1.empty() and stk1.top().first>=arr[i])\\n            {\\n                stk1.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1149784,
                "title": "python-monotone-stack-solution-with-comments-and-explanation",
                "content": "This problem can be visualised as an extension to [largest rectangle in histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\\nIn the above problem you can use Next Smallest Element (NSE) logic on a monotonically increasing stack to find the maximum rectangle possible in the histogram given.\\n\\nYou can easily extend that concept on this 2D matrix by constructing/updating histogram row by row and processing on the histogram. \\n1.  For the first row the whole row is a histogram with bar heights either 1 or 0\\n2.  For the next row we update the histogram as\\n        =>  If the value of current grid is \\'0\\' then histogram height is reset to 0 (as the continuation of the rectangle breaks here)\\n\\t\\t=>  If the value of the current grid is \\'1\\' then histogram height can be increased by 1 vertically\\n3.  So on for rest of the rows...\\n**Note:**  As we are processing row by row so rectangle continuity in horizontal direction is handled in histogram automatically while the vertical continuity is handled by updating the histogram as in step 2.\\n4. Now after updating the histogram for each row, we calculate the maximum area of rectangle possible.\\n5. Once we have maximum from all the rows, we pick the maximum of the maximums to get our final answer. \\n\\nExample:\\n**Input:** \\n```\\n[\\n  [\"1\",\"0\",\"1\",\"0\",\"0\"],\\n  [\"1\",\"0\",\"1\",\"1\",\"1\"],\\n  [\"1\",\"1\",\"1\",\"1\",\"1\"],\\n  [\"1\",\"0\",\"0\",\"1\",\"0\"]\\n]\\n```\\n\\n**Histogram creation and updation for each row of matrix:**\\n```\\nRow 1 => [1, 0, 1, 0, 0]   [current max = 1 and overall max = 1]\\nRow 2 => [2, 0, 2, 1, 1]   [current max = 3 and overall max = 3]\\nRow 3 => [3, 1, 3, 2, 2]   [current max = 6 and overall max = 6]\\nRow 4 => [4, 0, 0, 3, 0]   [current max = 4 and overall max = 6]\\n```\\nAs you can see the final answer will be picked as 6\\n\\n**Code:**\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0  # To handle `matrix = []` case\\n\\t\\t\\n\\t\\t# Prepare histogram for the first row of input matrix and find maximum area.\\n        histogram = list(map(int, matrix[0]))\\n        histogram.append(0)\\n        current_max = self.max_rect_histogram(histogram)\\n\\t\\t\\n\\t\\t# Process on the remaining rows of matrix\\n        for row in matrix[1:]:\\n            for i in range(len(row)):\\n\\t\\t\\t    # update histogram, if grid is a \\'0\\' reset histogram height else increase height by one\\n                if row[i] == \\'0\\':\\n                    histogram[i] = 0\\n                else:\\n                    histogram[i] += int(row[i])\\n\\t\\t\\t# Once histogram is updated for current row find the maximum rectangle area in current histogram\\n            current_max = max(current_max, self.max_rect_histogram(histogram))\\n        return current_max\\n        \\n    def max_rect_histogram(self, histogram):\\n        stack = [-1]\\n        mx = 0\\n        for i,v in enumerate(histogram):\\n\\t\\t\\t# As long as the stack has increasing value keep adding the index of histogram\\n\\t\\t\\t# If the insertion to stack will result in a decreasing stack, then keep poping till it becomes increasing again\\n\\t\\t\\t# For each pop, calculate the area of the rectangle\\n            while(stack[-1] != -1 and histogram[stack[-1]] > v):\\n                height = histogram[stack.pop()]\\n\\t\\t\\t\\t# i is right limit, stack[-1] is left limit so width of rectangle in consideration is r-l-1\\n                width = i - stack[-1] - 1\\n                mx = max(mx, height*width)\\n            stack.append(i)\\n        return mx\\n```",
                "solutionTags": [],
                "code": "```\\n[\\n  [\"1\",\"0\",\"1\",\"0\",\"0\"],\\n  [\"1\",\"0\",\"1\",\"1\",\"1\"],\\n  [\"1\",\"1\",\"1\",\"1\",\"1\"],\\n  [\"1\",\"0\",\"0\",\"1\",\"0\"]\\n]\\n```\n```\\nRow 1 => [1, 0, 1, 0, 0]   [current max = 1 and overall max = 1]\\nRow 2 => [2, 0, 2, 1, 1]   [current max = 3 and overall max = 3]\\nRow 3 => [3, 1, 3, 2, 2]   [current max = 6 and overall max = 6]\\nRow 4 => [4, 0, 0, 3, 0]   [current max = 4 and overall max = 6]\\n```\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0  # To handle `matrix = []` case\\n\\t\\t\\n\\t\\t# Prepare histogram for the first row of input matrix and find maximum area.\\n        histogram = list(map(int, matrix[0]))\\n        histogram.append(0)\\n        current_max = self.max_rect_histogram(histogram)\\n\\t\\t\\n\\t\\t# Process on the remaining rows of matrix\\n        for row in matrix[1:]:\\n            for i in range(len(row)):\\n\\t\\t\\t    # update histogram, if grid is a \\'0\\' reset histogram height else increase height by one\\n                if row[i] == \\'0\\':\\n                    histogram[i] = 0\\n                else:\\n                    histogram[i] += int(row[i])\\n\\t\\t\\t# Once histogram is updated for current row find the maximum rectangle area in current histogram\\n            current_max = max(current_max, self.max_rect_histogram(histogram))\\n        return current_max\\n        \\n    def max_rect_histogram(self, histogram):\\n        stack = [-1]\\n        mx = 0\\n        for i,v in enumerate(histogram):\\n\\t\\t\\t# As long as the stack has increasing value keep adding the index of histogram\\n\\t\\t\\t# If the insertion to stack will result in a decreasing stack, then keep poping till it becomes increasing again\\n\\t\\t\\t# For each pop, calculate the area of the rectangle\\n            while(stack[-1] != -1 and histogram[stack[-1]] > v):\\n                height = histogram[stack.pop()]\\n\\t\\t\\t\\t# i is right limit, stack[-1] is left limit so width of rectangle in consideration is r-l-1\\n                width = i - stack[-1] - 1\\n                mx = max(mx, height*width)\\n            stack.append(i)\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787990,
                "title": "python-solution-built-off-of-maximal-square-time-complexity-o-n-3",
                "content": "```class Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        if not matrix or not matrix[0]:\\n            return 0\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        #prepping max squares array and finding largest value in array (max_num)\\n\\t\\tmax_num = 1\\n        for i in range(m):\\n            matrix[i][0] = int(matrix[i][0])\\n\\n        for j in range(n):\\n            matrix[0][j] = int(matrix[0][j])\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if matrix[i][j] == \\'1\\':\\n                    tmp = min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1\\n                    matrix[i][j] = tmp\\n                    max_num = max(max_num, tmp)\\n                else:\\n                    matrix[i][j] = 0\\n    \\n\\t\\t#initialize array for global longest chain of each number\\n        max_values = [0 for i in range(max_num)]\\n        \\n        #iterate through rows to find longest chain of each value\\n\\t\\tfor step in range(max_num):\\n            for i in range(m):\\n                curr_value = 0\\n                for j in range(n):\\n                    if matrix[i][j] > step:\\n                        curr_value += 1\\n                    else:\\n                        if curr_value > max_values[step]:\\n                            max_values[step] = curr_value\\n                        curr_value = 0\\n                if curr_value > max_values[step]:\\n                    max_values[step] = curr_value\\n            \\n        #iterate through columns to find largest chain of each value\\n        for step in range(max_num):\\n            for j in range(n):\\n                curr_value = 0\\n                for i in range(m):\\n                    if matrix[i][j] > step:\\n                        curr_value += 1\\n                    else:\\n                        if curr_value > max_values[step]:\\n                            max_values[step] = curr_value\\n                        curr_value = 0\\n                if curr_value > max_values[step]:\\n                    max_values[step] = curr_value                \\n                        \\n        res = 0\\n        \\n\\t\\t#area of the rectangle can be calculated from neigboring squares\\n        for s, count in enumerate(max_values):\\n            if count != 0:\\n                res = max(res, (s + 1) ** 2 + (s + 1) * (count - 1))\\n        \\n        return res",
                "solutionTags": [],
                "code": "```class Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        if not matrix or not matrix[0]:\\n            return 0\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        #prepping max squares array and finding largest value in array (max_num)\\n\\t\\tmax_num = 1\\n        for i in range(m):\\n            matrix[i][0] = int(matrix[i][0])\\n\\n        for j in range(n):\\n            matrix[0][j] = int(matrix[0][j])\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if matrix[i][j] == \\'1\\':\\n                    tmp = min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1\\n                    matrix[i][j] = tmp\\n                    max_num = max(max_num, tmp)\\n                else:\\n                    matrix[i][j] = 0\\n    \\n\\t\\t#initialize array for global longest chain of each number\\n        max_values = [0 for i in range(max_num)]\\n        \\n        #iterate through rows to find longest chain of each value\\n\\t\\tfor step in range(max_num):\\n            for i in range(m):\\n                curr_value = 0\\n                for j in range(n):\\n                    if matrix[i][j] > step:\\n                        curr_value += 1\\n                    else:\\n                        if curr_value > max_values[step]:\\n                            max_values[step] = curr_value\\n                        curr_value = 0\\n                if curr_value > max_values[step]:\\n                    max_values[step] = curr_value\\n            \\n        #iterate through columns to find largest chain of each value\\n        for step in range(max_num):\\n            for j in range(n):\\n                curr_value = 0\\n                for i in range(m):\\n                    if matrix[i][j] > step:\\n                        curr_value += 1\\n                    else:\\n                        if curr_value > max_values[step]:\\n                            max_values[step] = curr_value\\n                        curr_value = 0\\n                if curr_value > max_values[step]:\\n                    max_values[step] = curr_value                \\n                        \\n        res = 0\\n        \\n\\t\\t#area of the rectangle can be calculated from neigboring squares\\n        for s, count in enumerate(max_values):\\n            if count != 0:\\n                res = max(res, (s + 1) ** 2 + (s + 1) * (count - 1))\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 768988,
                "title": "simple-solution-using-nsr-and-nsl-stack-based-solution",
                "content": "``\\nSame approach as to find maximum area histogram using Nearest smaller to left and Nearest smaller to right, only difference is that maximum area histogram is 1D and this is 2D so we start taking by one row at a time and find its area and keep max_area variable which keep track of max and then add it to second row and find again and so on and just keep in mind one thing while you are at current row and adding values to previous check if current level ith value is 0 or 1 if 0 then put 0 because if base is zero which is not possible means bulding can\\'t be in air and if 1 then add it...\\n``\\n\\n```\\nclass Solution {\\npublic:\\n    int pseudoIndex;\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n       int rows = matrix.size();\\n        if (rows == 0) {\\n            return 0;\\n        }\\n        int cols = matrix[0].size();\\n        if (cols == 0) {\\n            return 0;\\n        }\\n        vector<int>histogram(cols,0);\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i< rows; i++) {\\n            for (int j = 0; j< cols; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    histogram[j] = 0;\\n                }\\n                else {\\n                    histogram[j] += (matrix[i][j] - \\'0\\');\\n                }\\n            }\\n            int area = largestRectangleArea(histogram);\\n            \\n            res = max(area, res);\\n        }\\n        return res;\\n    }\\n    \\n    int largestRectangleArea(vector<int>& heights) {\\n        \\n        if(heights.size() == 0)\\n            return 0;\\n        //we store index of nearest smaller to left of i\\n        vector<int> nsl = NearestSmallerToLeft(heights);\\n        //we store index of nearest smaller to right of i\\n        vector<int> nsr = NearestSmallerToRight(heights);\\n        \\n        //find the max area possible\\n        int max_area = INT_MIN,area;\\n        for(int i = 0; i < heights.size(); i++)\\n        {\\n            area = (nsr[i]-nsl[i]-1)*heights[i];\\n            max_area = max(area,max_area);\\n        }\\n        return max_area;\\n    }\\n    \\n   vector<int> NearestSmallerToLeft(vector<int> temp)\\n    {\\n        stack<pair<int,int>> st;\\n        vector<int> left;\\n        pseudoIndex = -1;\\n        for(int i = 0; i < temp.size();i++)\\n        {\\n            if(st.empty())\\n                left.push_back(pseudoIndex);\\n            else if(!st.empty() && st.top().first < temp[i])\\n                left.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first >= temp[i])\\n            {\\n                while(!st.empty() && st.top().first >= temp[i])\\n                {\\n                    st.pop();\\n                }\\n                if(st.empty())\\n                {\\n                    left.push_back(-1);\\n                }\\n                else left.push_back(st.top().second);\\n            }\\n        st.push({temp[i],i});\\n        }\\n    return left;\\n    }\\n\\n    vector<int> NearestSmallerToRight(vector<int> temp)\\n    {\\n        stack<pair<int,int>> st;\\n        vector<int> right;\\n        pseudoIndex = temp.size();    \\n        for(int i = temp.size() - 1; i >= 0; i--)\\n        {\\n            if(st.empty())\\n            {\\n                right.push_back(pseudoIndex);\\n            }\\n            else if(!st.empty() && st.top().first < temp[i])\\n                right.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first >= temp[i])\\n            {\\n                while(!st.empty() && st.top().first >= temp[i])\\n                    st.pop();\\n                if(st.empty())\\n                    right.push_back(pseudoIndex);\\n                else \\n                    right.push_back(st.top().second);\\n            }\\n        st.push({temp[i],i});\\n        }\\n        reverse(right.begin(),right.end());\\n        return right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pseudoIndex;\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n       int rows = matrix.size();\\n        if (rows == 0) {\\n            return 0;\\n        }\\n        int cols = matrix[0].size();\\n        if (cols == 0) {\\n            return 0;\\n        }\\n        vector<int>histogram(cols,0);\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i< rows; i++) {\\n            for (int j = 0; j< cols; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    histogram[j] = 0;\\n                }\\n                else {\\n                    histogram[j] += (matrix[i][j] - \\'0\\');\\n                }\\n            }\\n            int area = largestRectangleArea(histogram);\\n            \\n            res = max(area, res);\\n        }\\n        return res;\\n    }\\n    \\n    int largestRectangleArea(vector<int>& heights) {\\n        \\n        if(heights.size() == 0)\\n            return 0;\\n        //we store index of nearest smaller to left of i\\n        vector<int> nsl = NearestSmallerToLeft(heights);\\n        //we store index of nearest smaller to right of i\\n        vector<int> nsr = NearestSmallerToRight(heights);\\n        \\n        //find the max area possible\\n        int max_area = INT_MIN,area;\\n        for(int i = 0; i < heights.size(); i++)\\n        {\\n            area = (nsr[i]-nsl[i]-1)*heights[i];\\n            max_area = max(area,max_area);\\n        }\\n        return max_area;\\n    }\\n    \\n   vector<int> NearestSmallerToLeft(vector<int> temp)\\n    {\\n        stack<pair<int,int>> st;\\n        vector<int> left;\\n        pseudoIndex = -1;\\n        for(int i = 0; i < temp.size();i++)\\n        {\\n            if(st.empty())\\n                left.push_back(pseudoIndex);\\n            else if(!st.empty() && st.top().first < temp[i])\\n                left.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first >= temp[i])\\n            {\\n                while(!st.empty() && st.top().first >= temp[i])\\n                {\\n                    st.pop();\\n                }\\n                if(st.empty())\\n                {\\n                    left.push_back(-1);\\n                }\\n                else left.push_back(st.top().second);\\n            }\\n        st.push({temp[i],i});\\n        }\\n    return left;\\n    }\\n\\n    vector<int> NearestSmallerToRight(vector<int> temp)\\n    {\\n        stack<pair<int,int>> st;\\n        vector<int> right;\\n        pseudoIndex = temp.size();    \\n        for(int i = temp.size() - 1; i >= 0; i--)\\n        {\\n            if(st.empty())\\n            {\\n                right.push_back(pseudoIndex);\\n            }\\n            else if(!st.empty() && st.top().first < temp[i])\\n                right.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first >= temp[i])\\n            {\\n                while(!st.empty() && st.top().first >= temp[i])\\n                    st.pop();\\n                if(st.empty())\\n                    right.push_back(pseudoIndex);\\n                else \\n                    right.push_back(st.top().second);\\n            }\\n        st.push({temp[i],i});\\n        }\\n        reverse(right.begin(),right.end());\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733725,
                "title": "a-simple-c-approach-with-explanation",
                "content": "This is a mixture of two problems that is\\n1. Finding the largest rectangle in an Histogram.\\n2. Then finding the answer for the particular problem\\n\\nI hereby assume that u know how to find the largest Rectangle in a Histogram,if not check this out\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\nSolve  it first before jumping to it as the intuition behind that problem is the base for this and those who have solve that here is the explanation..\\n\\nThe function find answer is the snippet which simply finds the maximum area rectangle in an histogram but before that the main function requires some preprocessing..\\nIf given the Input\\n1 0 1 0 0 \\n1 0 1 1 1\\n1 1 1 1 1\\n1 0 0 1 0\\n\\n**We can assume each row as potential input for histogram but for every row we have to take the cummulative sum with the above row inorder to get how many 1\\'s are there in the above row**\\n\\nOnce u get the above where each cummulative sum vector is an input for the function **find_ans** which calculates largest are rectangle we can extend it to 2D as well,Once u get the above then it is down hill from there..\\n\\n```\\nclass Solution {\\npublic:\\n    int find_ans(vector<int>& h)\\n    {\\n        h.push_back(0);\\n        int n = h.size();\\n        stack<int> s;\\n        int sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s.empty() && h[i] < h[s.top()])\\n            {\\n                int idx = s.top();\\n                s.pop();\\n                int l = s.empty() ? 0 : s.top() + 1;\\n                sum = max(sum,h[idx]*(i-l));\\n            }\\n            s.push(i);\\n        }\\n        return sum;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty())\\n            return 0;\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int max_ans = 0;\\n        vector<int> h(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n                if(matrix[i][j] == \\'0\\')\\n                    h[j] = 0;\\n                else\\n                    h[j]++;\\n            max_ans = max(max_ans,find_ans(h));\\n        }\\n        return max_ans;\\n    }\\n};\\n```\\n\\n**Upvotes are appreciated**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_ans(vector<int>& h)\\n    {\\n        h.push_back(0);\\n        int n = h.size();\\n        stack<int> s;\\n        int sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s.empty() && h[i] < h[s.top()])\\n            {\\n                int idx = s.top();\\n                s.pop();\\n                int l = s.empty() ? 0 : s.top() + 1;\\n                sum = max(sum,h[idx]*(i-l));\\n            }\\n            s.push(i);\\n        }\\n        return sum;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty())\\n            return 0;\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int max_ans = 0;\\n        vector<int> h(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n                if(matrix[i][j] == \\'0\\')\\n                    h[j] = 0;\\n                else\\n                    h[j]++;\\n            max_ans = max(max_ans,find_ans(h));\\n        }\\n        return max_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640895,
                "title": "c-dynamic-programming-not-so-fast-but-easy-with-explanation",
                "content": "The key to the question is that, in each row, we can compute the area subtended by each column to its right. The maximum value will eventually be computed. The complexity is O(n*m*m). The dynamic programming comes from just memoizing the height of column row by row.\\n```\\nvector<vector<int>> memo;\\nint maximalRectangle(vector<vector<char>>& matrix) \\n{\\n\\tint n=matrix.size(),m;\\n    if(n)\\n        m=matrix[0].size();\\t\\n\\tmemo.resize(n,vector<int>(m,0));\\n    if(n>0)\\n        for(int j=0;j<m;++j)\\n            if(matrix[0][j]==\\'1\\')\\n                memo[0][j]=1;\\n   \\tfor(int i=1;i<n;++i)//finding height of  each cloumn in each row.\\n\\t\\tfor(int j=0;j<m;++j)\\n\\t\\t\\tif(matrix[i][j]==\\'1\\')\\n\\t\\t\\t\\tmemo[i][j]=1+memo[i-1][j];\\n\\tint ret=0;\\n\\tfor(int i=0;i<n;++i)\\n\\t\\tfor(int j=0;j<m;++j)\\n\\t\\t{\\n\\t\\t\\tint h=memo[i][j];\\n\\t\\t\\tfor(int k=j;k<m;++k)\\n\\t\\t\\t{\\n\\t\\t\\t\\th=min(h,memo[i][k]);\\n\\t\\t\\t\\tret=max(ret,(k-j+1)*h);\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<vector<int>> memo;\\nint maximalRectangle(vector<vector<char>>& matrix) \\n{\\n\\tint n=matrix.size(),m;\\n    if(n)\\n        m=matrix[0].size();\\t\\n\\tmemo.resize(n,vector<int>(m,0));\\n    if(n>0)\\n        for(int j=0;j<m;++j)\\n            if(matrix[0][j]==\\'1\\')\\n                memo[0][j]=1;\\n   \\tfor(int i=1;i<n;++i)//finding height of  each cloumn in each row.\\n\\t\\tfor(int j=0;j<m;++j)\\n\\t\\t\\tif(matrix[i][j]==\\'1\\')\\n\\t\\t\\t\\tmemo[i][j]=1+memo[i-1][j];\\n\\tint ret=0;\\n\\tfor(int i=0;i<n;++i)\\n\\t\\tfor(int j=0;j<m;++j)\\n\\t\\t{\\n\\t\\t\\tint h=memo[i][j];\\n\\t\\t\\tfor(int k=j;k<m;++k)\\n\\t\\t\\t{\\n\\t\\t\\t\\th=min(h,memo[i][k]);\\n\\t\\t\\t\\tret=max(ret,(k-j+1)*h);\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 452868,
                "title": "javascript-dp-o-n-time-space",
                "content": "```\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nconst maximalRectangle = (matrix) => {\\n  if (!matrix.length || !matrix[0].length) return 0;\\n  const height = matrix.length;\\n  const width = matrix[0].length;\\n  const lefts = matrix[0].map(() => 0);\\n  const rights = matrix[0].map(() => width);\\n  const heights = lefts.slice();\\n  let max = 0;\\n  for (let row = 0; row < height; row++) {\\n    let left = 0;\\n    let right = width;\\n    for (let i = 0; i < width; i++) {\\n      if (matrix[row][i] === \\'1\\') {\\n        lefts[i] = Math.max(left, lefts[i]);\\n        heights[i]++;\\n      } else {\\n        lefts[i] = heights[i] = 0;\\n        left = i + 1\\n      }\\n\\n      const rightIdx = width - 1 - i;\\n      if (matrix[row][rightIdx] === \\'1\\') {\\n        rights[rightIdx] = Math.min(right, rights[rightIdx])\\n      } else {\\n        rights[rightIdx] = width;\\n        right = rightIdx;\\n      }\\n    }\\n    for (let i = 0; i < width; i++) {\\n      max = Math.max(max,(rights[i] - lefts[i]) * heights[i]);\\n    }\\n  }\\n  return max\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nconst maximalRectangle = (matrix) => {\\n  if (!matrix.length || !matrix[0].length) return 0;\\n  const height = matrix.length;\\n  const width = matrix[0].length;\\n  const lefts = matrix[0].map(() => 0);\\n  const rights = matrix[0].map(() => width);\\n  const heights = lefts.slice();\\n  let max = 0;\\n  for (let row = 0; row < height; row++) {\\n    let left = 0;\\n    let right = width;\\n    for (let i = 0; i < width; i++) {\\n      if (matrix[row][i] === \\'1\\') {\\n        lefts[i] = Math.max(left, lefts[i]);\\n        heights[i]++;\\n      } else {\\n        lefts[i] = heights[i] = 0;\\n        left = i + 1\\n      }\\n\\n      const rightIdx = width - 1 - i;\\n      if (matrix[row][rightIdx] === \\'1\\') {\\n        rights[rightIdx] = Math.min(right, rights[rightIdx])\\n      } else {\\n        rights[rightIdx] = width;\\n        right = rightIdx;\\n      }\\n    }\\n    for (let i = 0; i < width; i++) {\\n      max = Math.max(max,(rights[i] - lefts[i]) * heights[i]);\\n    }\\n  }\\n  return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218583,
                "title": "dp-solution-faster-than-99-8-w-description-example-analysis-o-nm-n-time-o-1-space",
                "content": "# Solution:\\n```\\n/* Leetcode speedup */\\nstatic vector<vector<char>> mat {[](){\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(NULL);\\n    std::cout.tie(NULL);\\n    return NULL;\\n}()};\\n\\n/* Solution */\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>> &mat) {\\n\\t\\t// Iterate over mat and count the number of contiguous 1\\'s to the left of each position\\n        for (int i {0}; i < mat.size(); ++i) {\\n            for (int j {1}; j < mat.front().size(); ++j) {\\n                mat[i][j] = mat[i][j] != \\'0\\' ? mat[i][j-1] + 1 : mat[i][j];\\n            }\\n        }\\n\\n\\t\\t// Return value -- area of maximal 1\\'s rectangle \\n        int ret {0};\\n\\t\\t\\n\\t\\t// Iterate over new values and calculate/find area of maximal 1\\'s rectangle\\n        for (int i {0}; i < mat.size(); ++i) { \\n            for (int j {0}; j < mat.front().size(); ++j) {\\n                for (int k {i}, minw {mat[i][j] - \\'0\\'}; k < mat.size() && minw; ++k) {\\n                    ret = max(ret, (k - i + 1) * (minw= min(minw, mat[k][j] - \\'0\\')));\\n\\t\\t\\t\\t\\tmat[k][j] = mat[k][j] - \\'0\\' <= minw ? \\'0\\' : mat[k][j];\\n                }\\n            }\\n        }\\n    \\n\\t\\t// Return area of maximal rectangle\\n        return ret;\\n    }\\n};\\n```\\n\\n\\n# Description:\\nFirst, the algorithm iterates over the elements in the matrix and counts the number of horizontally contiguous 1\\u2019s to the left of each position. Starting at the 2nd element (1th position) of each row, if the current element, ```mat[i][j]```, is ```\\u20181\\u2019```, then its value is set to that of the previous element in the same row plus one.\\n\\ni.e., if ```mat[i][j] == \\u20181\\u2019``` then  ```mat[i][j] = mat[i][j-1] + 1```, else ```mat[i][j]``` remains ```\\'0\\'```. \\n\\nHere there\\'s one iteration for each element, and the original matrix is modified to count horizontally contiguous 1\\u2019s. Hence, the time complexity for this portion is O(nm), and the space complexity is O(1).\\n \\n*Note: since the matrix holds char types and not ints, it\\u2019s necessary to subtract  \\u20180\\u2019 from elements to obtain an accurate numerical value for the number of horizontally contiguous 1\\u2019s counted. Alternatively, you could use an identical 2d vector of ints for counting, but this would change the space complexity from O(1) to O(nm).*\\n \\nTake the following example matrix: \\n\\n ```\\nvector<vector<char>> mat {\\n    { \\'0\\', \\'1\\', \\'1\\', \\'1\\', \\'0\\' },\\n    { \\'0\\', \\'1\\', \\'1\\', \\'0\\', \\'0\\' }, \\n    { \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\' },\\n    { \\'1\\', \\'1\\', \\'0\\', \\'0\\', \\'0\\' } \\n};\\n```\\n\\nAfter iterating over the elements and counting the number of horizontally contiguous 1\\u2019s for each position, the values (after having subtracted \\u20180\\u2019 from them) for each element would be:\\n \\n ```\\n0 1 2 3 0 \\n0 1 2 0 0 \\n0 0 0 0 1 \\n1 2 0 0 0 \\n ```\\n \\nNext, the new values are iterated over and used to calculate areas of rectangles in the matrix originally, and the maximal area calculated is kept track of with the return variable ```ret```.\\n \\nThis is done using three nested loops:\\n1. The outermost loop iterates vertically over the rows of the matrix, from ```i = 0``` to ```i = n-1```. \\n2. The second loop iterates horizontally over the columns, from ```j = 0``` to ```j = m-1```. \\n3. The innermost loop also iterates over the rows, from```k = i``` to ```k = n-1```, but only while the value of ```mat[k][j]``` is not ```\\'0\\'``` (i.e., non-zero).\\n \\nAs we iterate vertically over elements in the innermost loop, we keep track of the minimum (non-zero) value encountered for ```mat[k][j]```. This value represents the largest width for which the elements iterated over by ```k``` form a rectangle without any gaps or holes. Moreover, since these elements make up one side of the rectangle, the number of elements iterated over consecutively in this loop, ```k - i + 1```, represents the height of the rectangle they form.\\n\\nUsing these values for width and height, each iteration we calculate the area of the largest possible rectangle and keep track of the overall maximal area found. \\n\\nAdditionally, an optimization is made by setting ```mat[k][j] = \\'0\\'``` when its numerical value (```mat[k][j] - \\'0\\'```) is not greater than ```minw```. This allows duplicate iterations over elements we know will not produce a larger area to be avoided. \\n \\n#  Example:\\n\\nGiven the following example input matrix:\\n \\n ```\\nvector<vector<char>> mat {\\n    { \\'0\\', \\'1\\', \\'1\\', \\'1\\', \\'0\\' },\\n    { \\'0\\', \\'1\\', \\'1\\', \\'0\\', \\'0\\' }, \\n    { \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\' },\\n    { \\'1\\', \\'1\\', \\'0\\', \\'0\\', \\'0\\' } \\n};\\n```\\n\\n\\nAfter iterating over the matrix the first time and recording the number of contiguous 1\\'s to the left of each position the values become:\\n\\n![image](https://assets.leetcode.com/users/dd0rz/image_1547590069.png)\\n\\n\\n*Note: integer values shown for mat, i.e., mat[][] - \\'0\\'*\\n\\nNext, the new values are iterated over and used to calculate the area of 1\\'s rectangles in the matrix originally. The first several iterations where area calculations are performed are as follows (note that the innermost loop does not execute and no calculations are performed when ```mat[i][j] == \\'0\\'```, thus these iterations are not shown):\\n\\n![image](https://assets.leetcode.com/users/dd0rz/image_1547588408.png)\\n\\nAfter completion, the maximal rectangle returned for the given matrix is ```ret = 4```.\\n\\n# Computational Complexity\\n**Worst-case Space Complexity**\\nSince our solution modifies the original input matrix and uses a constant amount of memory rather than some amount based on the input size, our space complexity is constant time, O(1). \\n\\n**Worst-case Time Complexity**\\nTo analyze the worst-case runtime complexity, consider a 5x5 matrix with the worst-case configuration:\\n\\n```\\n0, 0, 0, 0, 1\\n0, 0, 0, 1, 1\\n0, 0, 1, 1, 1\\n0, 1, 1, 1, 1\\n1, 1, 1, 1, 1\\n```\\n\\nWhen counting horizontally contiguous 1\\'s in the first set of loops, there\\'s one iteration for each element in the matrix. Hence the runtime complexity for this part is O(nm), where where n = height and w = width. Next, we consider the now modified worst-case 5x5 matrix to determine the runtime complexity of the second set of loops:\\n\\n```\\n0, 0, 0, 0, 1\\n0, 0, 0, 1, 2\\n0, 0, 1, 2, 3\\n0, 1, 2, 3, 4\\n1, 2, 3, 4, 5\\n```\\n\\nIt\\'s now apparent this is the worst-case configuration because when calculating areas smaller widths are always checked before larger ones. This prevents duplicate iterations from being avoided by setting elements to 0. \\n\\nSince the two outer loops in the second part will produce one iteration for each element in the matrix, we\\'ll always have nm iterations plus any additional duplicate iterations over elements performed by the innermost loop. If we can find an expression, X, for the number of extra iterations over elements performed by the innermost loop, then we\\'ll know the runtime complexity for this part is O(nm + X).\\n\\nStart by considering elements in the rightmost column, ```j=4```. When ```i=0``` and the innermost loop is entered, all elements in the column from [```k=0``` to ```k=4```] will be iterated over for 5 iterations total. This is the first time iterating over any element in the column, so none of the iterations are extra iterations. When ```i=1``` elements in the column from [```k=1``` to ```k=4```] (from the value 2 downwards) will be iterated over for 4 iterations total. This time these will all be duplicate iterations since all elements in the column have been iterated over already. When ```i=2```, elements in the column from [```k=2``` to ```k=4```] are iterated over for 3 iterations total, which again are all duplicate iterations. For all values of ```i``` the number of duplicate iterations over elements in rightmost column, ```j=4```, will be:\\n\\n*4 + 3 + 2 + 1 = 10*\\n\\nFor the preceding column, ```j=3```, the first element is 0, so there are no iterations over elements in the column when ```i=0```. Starting at ```i=1```, however, we can see the same pattern as before will occur. This means the total number of duplicate iterations over elements in the column for all values of ```i``` will be:\\n\\n*3 + 2 + 1 = 6*\\n\\nThe same pattern occurs for all columns in the matrix, and the number of duplicate iterations over elements in each will be:\\n\\n*1st column (```j=0```): 0 = 0\\n2nd column (```j=1```): 1 + 0 = 1\\n3rd column (```j=2```): 2 + 1 + 0 = 3\\n4th column (```j=3```): 3 + 2 + 1 + 0 = 6\\n5th column (```j=4```): 4 + 3 + 2 + 1 + 0 = 10*\\n\\nIt can be seen for the worst-case configuration, in each column the number of duplicate iterations over elements will be the sum of the first n-1 natural numbers, where n is the largest value in the column. Putting n-1 into the equation n(n+1)/2 (sum of natural numbers up to n), for each column we have:\\n\\n*(n-1)(n-1+1)/2 = n(n-1)/2 duplicate iterations*\\n\\nThus, for all columns in the matrix, the total number duplicate iterations is:\\n\\n*\\u03A3n(n-1)/2 [1 => n]*, or equivalently, *n\\xB3/6 - n/6*\\n\\nThis means for our worst-case 5x5 matrix we should have nm iterations + n\\xB3/6 - n/6 duplicate iterations:\\n\\n*5 * 5 + 125/6 - 5/6 = 25 iterations + 20 duplicate iterations = 45 total iterations*, which is accurate.\\n\\nCombining both the first and second parts, our overall worst-case time is:\\n\\n*O(nm) + O(nm + n\\xB3/6 - n/6) = O(2nm + n\\xB3/6 - n/6) =*\\n\\n*O(nm + n\\xB3)*, where n = height and m = width.",
                "solutionTags": [],
                "code": "```\\n/* Leetcode speedup */\\nstatic vector<vector<char>> mat {[](){\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(NULL);\\n    std::cout.tie(NULL);\\n    return NULL;\\n}()};\\n\\n/* Solution */\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>> &mat) {\\n\\t\\t// Iterate over mat and count the number of contiguous 1\\'s to the left of each position\\n        for (int i {0}; i < mat.size(); ++i) {\\n            for (int j {1}; j < mat.front().size(); ++j) {\\n                mat[i][j] = mat[i][j] != \\'0\\' ? mat[i][j-1] + 1 : mat[i][j];\\n            }\\n        }\\n\\n\\t\\t// Return value -- area of maximal 1\\'s rectangle \\n        int ret {0};\\n\\t\\t\\n\\t\\t// Iterate over new values and calculate/find area of maximal 1\\'s rectangle\\n        for (int i {0}; i < mat.size(); ++i) { \\n            for (int j {0}; j < mat.front().size(); ++j) {\\n                for (int k {i}, minw {mat[i][j] - \\'0\\'}; k < mat.size() && minw; ++k) {\\n                    ret = max(ret, (k - i + 1) * (minw= min(minw, mat[k][j] - \\'0\\')));\\n\\t\\t\\t\\t\\tmat[k][j] = mat[k][j] - \\'0\\' <= minw ? \\'0\\' : mat[k][j];\\n                }\\n            }\\n        }\\n    \\n\\t\\t// Return area of maximal rectangle\\n        return ret;\\n    }\\n};\\n```\n```mat[i][j]```\n```\\u20181\\u2019```\n```mat[i][j] == \\u20181\\u2019```\n```mat[i][j] = mat[i][j-1] + 1```\n```mat[i][j]```\n```\\'0\\'```\n```\\nvector<vector<char>> mat {\\n    { \\'0\\', \\'1\\', \\'1\\', \\'1\\', \\'0\\' },\\n    { \\'0\\', \\'1\\', \\'1\\', \\'0\\', \\'0\\' }, \\n    { \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\' },\\n    { \\'1\\', \\'1\\', \\'0\\', \\'0\\', \\'0\\' } \\n};\\n```\n```\\n0 1 2 3 0 \\n0 1 2 0 0 \\n0 0 0 0 1 \\n1 2 0 0 0 \\n ```\n```ret```\n```i = 0```\n```i = n-1```\n```j = 0```\n```j = m-1```\n```k = i```\n```k = n-1```\n```mat[k][j]```\n```\\'0\\'```\n```mat[k][j]```\n```k```\n```k - i + 1```\n```mat[k][j] = \\'0\\'```\n```mat[k][j] - \\'0\\'```\n```minw```\n```\\nvector<vector<char>> mat {\\n    { \\'0\\', \\'1\\', \\'1\\', \\'1\\', \\'0\\' },\\n    { \\'0\\', \\'1\\', \\'1\\', \\'0\\', \\'0\\' }, \\n    { \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\' },\\n    { \\'1\\', \\'1\\', \\'0\\', \\'0\\', \\'0\\' } \\n};\\n```\n```mat[i][j] == \\'0\\'```\n```ret = 4```\n```\\n0, 0, 0, 0, 1\\n0, 0, 0, 1, 1\\n0, 0, 1, 1, 1\\n0, 1, 1, 1, 1\\n1, 1, 1, 1, 1\\n```\n```\\n0, 0, 0, 0, 1\\n0, 0, 0, 1, 2\\n0, 0, 1, 2, 3\\n0, 1, 2, 3, 4\\n1, 2, 3, 4, 5\\n```\n```j=4```\n```i=0```\n```k=0```\n```k=4```\n```i=1```\n```k=1```\n```k=4```\n```i=2```\n```k=2```\n```k=4```\n```i```\n```j=4```\n```j=3```\n```i=0```\n```i=1```\n```i```\n```j=0```\n```j=1```\n```j=2```\n```j=3```\n```j=4```",
                "codeTag": "C++"
            },
            {
                "id": 29127,
                "title": "o-n-2-dp-java-solution",
                "content": "    public int maximalRectangle(char[][] matrix) {\\n            if (matrix.length == 0) return 0;\\n            int m = matrix.length;\\n            int n = matrix[0].length;\\n            int[] left = new int[n]; // left boundary of histogram columns.\\n            int[] right = new int[n]; // right boundary of histogram columns.\\n            int[] height = new int[n]; // height of histogram columns.\\n            Arrays.fill(right, n);\\n            int area = 0;\\n            for (int i = 0; i < m; i++) {\\n                int l = 0, r = n;\\n                for (int j = 0; j < n; j++) {\\n                    if (matrix[i][j] == '1') {\\n                        height[j]++;\\n                        left[j] = Math.max(l, left[j]);\\n                    }\\n                    else {\\n                        l = j + 1;\\n                        height[j] = 0;\\n                        left[j] = 0;\\n                        right[j] = n;\\n                    }\\n                }\\n                for (int j = n - 1; j >= 0; j--) {\\n                    if (matrix[i][j] == '1') {\\n                        right[j] = Math.min(r, right[j]);\\n                        area = Math.max(area, height[j] * (right[j] - left[j]));\\n                    }\\n                    else {\\n                        r = j;\\n                    }\\n                }\\n            }\\n            return area;\\n        }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int maximalRectangle(char[][] matrix) {\\n            if (matrix.length == 0) return 0;\\n            int m = matrix.length;\\n            int n = matrix[0].length;\\n            int[] left = new int[n]; // left boundary of histogram columns.\\n            int[] right = new int[n]; // right boundary of histogram columns.\\n            int[] height = new int[n]; // height of histogram columns.\\n            Arrays.fill(right, n);\\n            int area = 0;\\n            for (int i = 0; i < m; i++) {\\n                int l = 0, r = n;\\n                for (int j = 0; j < n; j++) {\\n                    if (matrix[i][j] == '1') {\\n                        height[j]++;\\n                        left[j] = Math.max(l, left[j]);\\n                    }\\n                    else {\\n                        l = j + 1;\\n                        height[j] = 0;\\n                        left[j] = 0;\\n                        right[j] = n;\\n                    }\\n                }\\n                for (int j = n - 1; j >= 0; j--) {\\n                    if (matrix[i][j] == '1') {\\n                        right[j] = Math.min(r, right[j]);\\n                        area = Math.max(area, height[j] * (right[j] - left[j]));\\n                    }\\n                    else {\\n                        r = j;\\n                    }\\n                }\\n            }\\n            return area;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3822775,
                "title": "easy-stack-solution-using-c",
                "content": "# PLS UPVOTE MY SOLUTION IF YOPU LIKE AND COMMENT FOR ANY DISCUSSION\\n\\n# Approach\\nThe nextelement function takes a vector heights and its size n as input. It initializes an empty stack and a vector ans of size n to store the indices of the next smaller elements. It then iterates through the heights vector from right to left (from the last element to the first).\\n\\nFor each element in the heights vector, it compares its height with the elements at the top of the stack (using st.top()), and if the element at the top of the stack is greater than or equal to the current element, it pops elements from the stack (until the top element is smaller than the current element).\\n\\nAfter the while loop, it stores the index of the next smaller element in the ans vector for the current element (ans[i] = st.top()). If there is no smaller element, it stores the value n (one greater than the last index) to indicate that there is no next smaller element for that element.\\n\\nThe prevelement function works similarly to nextelement but iterates from left to right to find the previous smaller elements for each element in the heights vector.\\n\\nThe largestRectangleArea function calculates the largest rectangle area in a histogram. It takes a vector heights as input and uses the nextelement and prevelement functions to find the indices of the next smaller and previous smaller elements for each element in the histogram.\\n\\nIt then iterates through the heights vector and calculates the area of the rectangle for each bar, considering the bar as the height and the width as the difference between the indices of the next smaller and previous smaller elements for that bar.\\n\\nThe function returns the maximum area found.\\n\\nThe maximalRectangle function takes a 2D matrix matrix as input. It initializes a vector histogram of size equal to the number of columns in the matrix, and maxi variable to store the maximum area.\\n\\nIt iterates through each row of the matrix and populates the histogram vector based on the \\'1\\'s encountered in each column. When a \\'0\\' is encountered, the height of the histogram for that column is reset to 0.\\n\\nFor each row, it calculates the largest rectangle area in the histogram (representing the consecutive \\'1\\'s encountered so far) using the largestRectangleArea function.\\n\\nThe function updates maxi with the maximum area found.\\n\\nFinally, the function returns the maximum area, which represents the largest rectangle area formed by \\'1\\'s in the binary matrix.\\n\\nThe approach efficiently uses the concept of histograms and the largest rectangle area calculation to solve the maximalRectangle problem for a binary matrix, resulting in an overall time complexity of O(M * N), where M is the number of rows and N is the number of columns in the matrix.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*(M+N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> nextelement(vector<int>& heights, int n )\\n{\\n    stack<int>st;\\n    st.push(-1);\\n    vector<int>ans(n);\\n    for(int i =n-1;i>=0;i--)\\n    {\\n        int curr= heights[i];\\n        while(st.top()!=-1 && heights[st.top()]>=curr)\\n        {\\n            st.pop();\\n        }\\n        if(st.top()==-1)\\n        {\\n            ans[i]=n;\\n        }\\n        else\\n        {\\n            ans[i]=st.top();\\n        }\\n    st.push(i);\\n    }\\n    return ans;\\n}\\n\\nvector<int> prevelement(vector<int>& heights, int n )\\n{\\n    stack<int>st;\\n    st.push(-1);\\n    vector<int>ans(n);\\n    for(int i =0;i<n;i++)\\n    {\\n        int curr= heights[i];\\n        while(st.top()!=-1 && heights[st.top()]>=curr)\\n        {\\n            st.pop();\\n        }\\n    ans[i]=st.top();\\n    st.push(i);\\n    }\\n    return ans;\\n}\\n\\n int largestRectangleArea(vector<int>& heights) {\\n       int n =heights.size();\\n       int area= INT_MIN;\\n       vector<int>next=nextelement(heights,n); \\n       vector<int>prev=prevelement(heights,n); \\n       for(int i =0;i<n;i++)\\n       {\\n           int l = heights[i];\\n           int b = next[i]-prev[i]-1;\\n           int newarea= l*b;\\n           area=max(area,newarea);\\n       }\\n       return area;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int>histogram(matrix[0].size(),0);\\n        int maxi= INT_MIN;\\n        \\n        for(int i = 0;i<matrix.size();i++)\\n        {\\n            for(int j= 0 ;j<histogram.size();j++)\\n            {\\n                if (matrix[i][j]==\\'1\\')\\n                {\\n                    histogram[j]++;\\n                }\\n                else\\n                {\\n                    histogram[j]=0;\\n                }\\n            }\\n            maxi=max(maxi,largestRectangleArea(histogram));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvector<int> nextelement(vector<int>& heights, int n )\\n{\\n    stack<int>st;\\n    st.push(-1);\\n    vector<int>ans(n);\\n    for(int i =n-1;i>=0;i--)\\n    {\\n        int curr= heights[i];\\n        while(st.top()!=-1 && heights[st.top()]>=curr)\\n        {\\n            st.pop();\\n        }\\n        if(st.top()==-1)\\n        {\\n            ans[i]=n;\\n        }\\n        else\\n        {\\n            ans[i]=st.top();\\n        }\\n    st.push(i);\\n    }\\n    return ans;\\n}\\n\\nvector<int> prevelement(vector<int>& heights, int n )\\n{\\n    stack<int>st;\\n    st.push(-1);\\n    vector<int>ans(n);\\n    for(int i =0;i<n;i++)\\n    {\\n        int curr= heights[i];\\n        while(st.top()!=-1 && heights[st.top()]>=curr)\\n        {\\n            st.pop();\\n        }\\n    ans[i]=st.top();\\n    st.push(i);\\n    }\\n    return ans;\\n}\\n\\n int largestRectangleArea(vector<int>& heights) {\\n       int n =heights.size();\\n       int area= INT_MIN;\\n       vector<int>next=nextelement(heights,n); \\n       vector<int>prev=prevelement(heights,n); \\n       for(int i =0;i<n;i++)\\n       {\\n           int l = heights[i];\\n           int b = next[i]-prev[i]-1;\\n           int newarea= l*b;\\n           area=max(area,newarea);\\n       }\\n       return area;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int>histogram(matrix[0].size(),0);\\n        int maxi= INT_MIN;\\n        \\n        for(int i = 0;i<matrix.size();i++)\\n        {\\n            for(int j= 0 ;j<histogram.size();j++)\\n            {\\n                if (matrix[i][j]==\\'1\\')\\n                {\\n                    histogram[j]++;\\n                }\\n                else\\n                {\\n                    histogram[j]=0;\\n                }\\n            }\\n            maxi=max(maxi,largestRectangleArea(histogram));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603531,
                "title": "c-very-easy-solution-using-stack-84-largest-rectangle-in-histogram",
                "content": "```\\nint largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n        stack<int> s;\\n        s.push(-1);\\n        int maxArea=0;\\n        int rm=0,lm=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            int val = (i==n ? 0 : heights[i]);\\n            while(s.top() != -1 and heights[s.top()]>=val)\\n            {\\n                rm = i;\\n                int h = heights[s.top()];\\n                s.pop();\\n                lm = s.top();\\n                maxArea = max(maxArea, h*(rm-lm-1));\\n            }\\n            s.push(i);\\n        }\\n        return maxArea;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix){\\n        int row = matrix.size();\\n        if(row == 0) return 0;\\n        int col = matrix[0].size();\\n    \\n        vector<int> v(col);\\n        for(int i=0;i<col;i++)\\n        {\\n            v[i] = matrix[0][i] - \\'0\\';\\n        }\\n        int maxArea = 0;\\n        maxArea = max(maxArea, largestRectangleArea(v));\\n        for(int i=1;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    v[j]++;\\n                }\\n                else\\n                {\\n                    v[j]=0;\\n                }\\n            }\\n            maxArea = max(maxArea, largestRectangleArea(v));\\n        }\\n        return maxArea;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n        stack<int> s;\\n        s.push(-1);\\n        int maxArea=0;\\n        int rm=0,lm=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            int val = (i==n ? 0 : heights[i]);\\n            while(s.top() != -1 and heights[s.top()]>=val)\\n            {\\n                rm = i;\\n                int h = heights[s.top()];\\n                s.pop();\\n                lm = s.top();\\n                maxArea = max(maxArea, h*(rm-lm-1));\\n            }\\n            s.push(i);\\n        }\\n        return maxArea;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix){\\n        int row = matrix.size();\\n        if(row == 0) return 0;\\n        int col = matrix[0].size();\\n    \\n        vector<int> v(col);\\n        for(int i=0;i<col;i++)\\n        {\\n            v[i] = matrix[0][i] - \\'0\\';\\n        }\\n        int maxArea = 0;\\n        maxArea = max(maxArea, largestRectangleArea(v));\\n        for(int i=1;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    v[j]++;\\n                }\\n                else\\n                {\\n                    v[j]=0;\\n                }\\n            }\\n            maxArea = max(maxArea, largestRectangleArea(v));\\n        }\\n        return maxArea;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1229906,
                "title": "simple-explanation-o-n-2-c-derived-from-maximum-area-in-histogram",
                "content": "**Prerequisite** : Please solve this problem first for better understanding [Maximum Area in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// This function accepts height of histograms and calculates the maximum area of reactange\\n\\t// i.e this function is the solution of problem mentioned in the above link\\n    int maxAreaHistogram(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        vector<int> rig(n, n), lef(n, -1);        // rig and lef vectors stores the first index in right and left whose height is less\\n        stack<int> s;\\n        \\n\\t\\t// storing the right index\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!s.empty() && arr[s.top()]>=arr[i]) s.pop();\\n            \\n            if(!s.empty()) rig[i] = s.top();\\n            s.push(i);\\n        }\\n\\t\\t\\n        while(!s.empty()) s.pop();\\n        \\n\\t\\t// storing the left index\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s.empty() && arr[s.top()]>=arr[i]) s.pop();\\n            if(!s.empty()) lef[i] = s.top();\\n            s.push(i);\\n        }\\n        \\n        int ans = 0;\\n\\t\\t// area =  width x height = ( rig[i] - lef[i]-1 )  x ( arr[i] )\\n        for(int i=0;i<n;i++)\\n            ans = max(ans, arr[i]*(rig[i]-lef[i]-1));\\n        \\n        return ans;\\n    }\\n    \\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int n = matrix.size();\\n        if(n==0) return 0;\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int> > mat(n, vector<int>(m));\\n        \\n\\t\\t// Converting char matrix to integer matrix\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                mat[i][j] = int(matrix[i][j]-\\'0\\');\\n                \\n\\t\\t// Calculating height of histogram for each row, but note that whenever we encounter zero height will become zero\\n        for(int i=1;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(mat[i][j])\\n                    mat[i][j] += mat[i-1][j];\\n\\n        int ans = 0;\\n\\t\\t\\n\\t\\t// now solving maxAreaHistogram for considering each row, and maximum of each level will be our ans\\n        for(int i=0;i<n;i++)\\n            ans = max(ans, maxAreaHistogram(mat[i]) );\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// This function accepts height of histograms and calculates the maximum area of reactange\\n\\t// i.e this function is the solution of problem mentioned in the above link\\n    int maxAreaHistogram(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        vector<int> rig(n, n), lef(n, -1);        // rig and lef vectors stores the first index in right and left whose height is less\\n        stack<int> s;\\n        \\n\\t\\t// storing the right index\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!s.empty() && arr[s.top()]>=arr[i]) s.pop();\\n            \\n            if(!s.empty()) rig[i] = s.top();\\n            s.push(i);\\n        }\\n\\t\\t\\n        while(!s.empty()) s.pop();\\n        \\n\\t\\t// storing the left index\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s.empty() && arr[s.top()]>=arr[i]) s.pop();\\n            if(!s.empty()) lef[i] = s.top();\\n            s.push(i);\\n        }\\n        \\n        int ans = 0;\\n\\t\\t// area =  width x height = ( rig[i] - lef[i]-1 )  x ( arr[i] )\\n        for(int i=0;i<n;i++)\\n            ans = max(ans, arr[i]*(rig[i]-lef[i]-1));\\n        \\n        return ans;\\n    }\\n    \\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int n = matrix.size();\\n        if(n==0) return 0;\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int> > mat(n, vector<int>(m));\\n        \\n\\t\\t// Converting char matrix to integer matrix\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                mat[i][j] = int(matrix[i][j]-\\'0\\');\\n                \\n\\t\\t// Calculating height of histogram for each row, but note that whenever we encounter zero height will become zero\\n        for(int i=1;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(mat[i][j])\\n                    mat[i][j] += mat[i-1][j];\\n\\n        int ans = 0;\\n\\t\\t\\n\\t\\t// now solving maxAreaHistogram for considering each row, and maximum of each level will be our ans\\n        for(int i=0;i<n;i++)\\n            ans = max(ans, maxAreaHistogram(mat[i]) );\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688497,
                "title": "python-similar-to-leetcode-84-explained",
                "content": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## SIMILAR TO LEETCODE 84. LARGEST RECTANGLE IN A HISTOGRAM ##\\n        \\n        #   1. we will create heights matrix, just like below (to imagine line histogram)\\n        #   2. on each heights matrix row, we find the maxArea\\n        #   3. return maxArea\\n        #   Ex :\\n        # [\\n        #   [\"1\",\"0\",\"1\",\"0\",\"0\"],\\n        #   [\"1\",\"0\",\"1\",\"1\",\"1\"],\\n        #   [\"1\",\"1\",\"1\",\"1\",\"1\"],\\n        #   [\"1\",\"0\",\"0\",\"1\",\"0\"]\\n        # ]\\n        # [\\n        #   [\"1\",\"0\",\"1\",\"0\",\"0\"],\\n        #   [\"2\",\"0\",\"2\",\"1\",\"1\"],\\n        #   [\"3\",\"1\",\"3\",\"2\",\"2\"],\\n        #   [\"4\",\"0\",\"0\",\"3\",\"0\"]\\n        # ]\\n        \\n        if(not matrix) : return 0\\n        \\n        for i in range(0, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if( matrix[i][j] == \\'1\\' ):\\n                    matrix[i][j] = int(matrix[i][j]) + int(matrix[i-1][j] if(i>0) else 0 )\\n                else:\\n                    matrix[i][j] = 0\\n        \\n        def findLargestArea(heights):\\n            if(not heights): return 0\\n            heights.append(0)\\n            stack = [-1]\\n            ans = 0\\n            for i in range(len(heights)):\\n                while( heights[i] < heights[stack[-1]] ):\\n                    h = heights[stack.pop()]\\n                    w = i - stack[-1] - 1\\n                    ans = max( ans, h*w )\\n                stack.append(i)\\n            return ans\\n            \\n        maxArea = 0\\n        for row in matrix:\\n            maxArea = max( maxArea, findLargestArea(row) )\\n        return maxArea        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## SIMILAR TO LEETCODE 84. LARGEST RECTANGLE IN A HISTOGRAM ##\\n        \\n        #   1. we will create heights matrix, just like below (to imagine line histogram)\\n        #   2. on each heights matrix row, we find the maxArea\\n        #   3. return maxArea\\n        #   Ex :\\n        # [\\n        #   [\"1\",\"0\",\"1\",\"0\",\"0\"],\\n        #   [\"1\",\"0\",\"1\",\"1\",\"1\"],\\n        #   [\"1\",\"1\",\"1\",\"1\",\"1\"],\\n        #   [\"1\",\"0\",\"0\",\"1\",\"0\"]\\n        # ]\\n        # [\\n        #   [\"1\",\"0\",\"1\",\"0\",\"0\"],\\n        #   [\"2\",\"0\",\"2\",\"1\",\"1\"],\\n        #   [\"3\",\"1\",\"3\",\"2\",\"2\"],\\n        #   [\"4\",\"0\",\"0\",\"3\",\"0\"]\\n        # ]\\n        \\n        if(not matrix) : return 0\\n        \\n        for i in range(0, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if( matrix[i][j] == \\'1\\' ):\\n                    matrix[i][j] = int(matrix[i][j]) + int(matrix[i-1][j] if(i>0) else 0 )\\n                else:\\n                    matrix[i][j] = 0\\n        \\n        def findLargestArea(heights):\\n            if(not heights): return 0\\n            heights.append(0)\\n            stack = [-1]\\n            ans = 0\\n            for i in range(len(heights)):\\n                while( heights[i] < heights[stack[-1]] ):\\n                    h = heights[stack.pop()]\\n                    w = i - stack[-1] - 1\\n                    ans = max( ans, h*w )\\n                stack.append(i)\\n            return ans\\n            \\n        maxArea = 0\\n        for row in matrix:\\n            maxArea = max( maxArea, findLargestArea(row) )\\n        return maxArea        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 125717,
                "title": "javascript-100-00-72-ms",
                "content": "```\\nvar maximalRectangle = function (matrix) {\\n    const n = matrix.length;\\n    if (n === 0) return 0;\\n    const m = matrix[0].length;\\n\\n    const h = new Array(n).fill(0);\\n\\n    let max = 0;\\n    for (let j = 0; j < m; j++) {\\n        for (let i = 0; i < n; i++) {\\n            if (matrix[i][j] === \\'1\\') h[i]++;\\n            else h[i] = 0;\\n        }\\n        for (let i = 0; i < n; i++) {\\n            let k1 = i - 1;\\n            while (k1 >= 0 && h[i] <= h[k1]) k1--;\\n            let k2 = i + 1;\\n            while (k2 < n && h[i] <= h[k2]) k2++;\\n            max = Math.max(max, h[i] * (k2 - k1 - 1));\\n        }\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximalRectangle = function (matrix) {\\n    const n = matrix.length;\\n    if (n === 0) return 0;\\n    const m = matrix[0].length;\\n\\n    const h = new Array(n).fill(0);\\n\\n    let max = 0;\\n    for (let j = 0; j < m; j++) {\\n        for (let i = 0; i < n; i++) {\\n            if (matrix[i][j] === \\'1\\') h[i]++;\\n            else h[i] = 0;\\n        }\\n        for (let i = 0; i < n; i++) {\\n            let k1 = i - 1;\\n            while (k1 >= 0 && h[i] <= h[k1]) k1--;\\n            let k2 = i + 1;\\n            while (k2 < n && h[i] <= h[k2]) k2++;\\n            max = Math.max(max, h[i] * (k2 - k1 - 1));\\n        }\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846495,
                "title": "easiest-java-solution-beats-100",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\nWe can solve this question using the \"Largest Rectangle in Histogram\" question approach. consider every row as a histogram and for every row find the max rectangle area. \\n\\nYou can check the histogram approach [here](https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/3845893/best-simple-java-solution-beats-85/).\\n\\nAlso, if the current row has an element with 0 value, then the height will be 0. for the rest where matrix[i][j] == 0, just add the previous value + 1, \\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static int histogram(int[] heights){\\n         int n = heights.length;\\n\\n        ArrayDeque<Integer> st1 = new ArrayDeque<>();\\n        ArrayDeque<Integer> st2 = new ArrayDeque<>();\\n\\n        int left[] = new int[n];\\n        int right[] = new int[n];\\n\\n        //previous smaller element\\n        for(int i = 0; i < n; i++){\\n\\n            int num = heights[i] ;\\n\\n            while(!st1.isEmpty() && heights[st1.peek()] > num)\\n                st1.pop();\\n\\n            if(st1.isEmpty())\\n                left[i] = -1;\\n            else \\n                left[i] = st1.peek();\\n\\n            st1.push(i);            \\n\\n        }\\n    \\n\\n        //next greater element\\n        for(int i = n-1; i >= 0; i--){\\n\\n            int num = heights[i];\\n\\n            while(!st2.isEmpty() && heights[st2.peek()] >= num)\\n                st2.pop();\\n\\n            if(st2.isEmpty())\\n                right[i] = n;\\n            else \\n                right[i] = st2.peek();\\n\\n            st2.push(i);            \\n\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < n; i++){\\n\\n            int sum = (right[i] - left[i] - 1) * (heights[i]);\\n            max = Math.max(max, sum); \\n\\n        }\\n\\n        System.out.println(\"Max\"+ max);\\n        return max;\\n    }\\n\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[] currRow = new int[matrix[0].length];\\n        int max = 0;\\n\\n        for(int i = 0; i < n; i++){\\n\\n            for(int j = 0; j < m; j++){\\n\\n                if(matrix[i][j] == \\'1\\')\\n                    currRow[j]++;\\n                else \\n                    currRow[j] = 0;    \\n            }\\n\\n            int currMax = histogram(currRow);\\n            max = Math.max(max, currMax);\\n\\n        }\\n\\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static int histogram(int[] heights){\\n         int n = heights.length;\\n\\n        ArrayDeque<Integer> st1 = new ArrayDeque<>();\\n        ArrayDeque<Integer> st2 = new ArrayDeque<>();\\n\\n        int left[] = new int[n];\\n        int right[] = new int[n];\\n\\n        //previous smaller element\\n        for(int i = 0; i < n; i++){\\n\\n            int num = heights[i] ;\\n\\n            while(!st1.isEmpty() && heights[st1.peek()] > num)\\n                st1.pop();\\n\\n            if(st1.isEmpty())\\n                left[i] = -1;\\n            else \\n                left[i] = st1.peek();\\n\\n            st1.push(i);            \\n\\n        }\\n    \\n\\n        //next greater element\\n        for(int i = n-1; i >= 0; i--){\\n\\n            int num = heights[i];\\n\\n            while(!st2.isEmpty() && heights[st2.peek()] >= num)\\n                st2.pop();\\n\\n            if(st2.isEmpty())\\n                right[i] = n;\\n            else \\n                right[i] = st2.peek();\\n\\n            st2.push(i);            \\n\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < n; i++){\\n\\n            int sum = (right[i] - left[i] - 1) * (heights[i]);\\n            max = Math.max(max, sum); \\n\\n        }\\n\\n        System.out.println(\"Max\"+ max);\\n        return max;\\n    }\\n\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[] currRow = new int[matrix[0].length];\\n        int max = 0;\\n\\n        for(int i = 0; i < n; i++){\\n\\n            for(int j = 0; j < m; j++){\\n\\n                if(matrix[i][j] == \\'1\\')\\n                    currRow[j]++;\\n                else \\n                    currRow[j] = 0;    \\n            }\\n\\n            int currMax = histogram(currRow);\\n            max = Math.max(max, currMax);\\n\\n        }\\n\\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472019,
                "title": "java-solution-for-maximal-rectangle-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe above solution uses a dynamic programming approach to calculate the height of the largest rectangle that can be formed with the current cell at the bottom of the rectangle. It then applies a modified version of the algorithm for finding the maximum area of a histogram on each row of the matrix to find the maximum area of a rectangle that can be formed using that row as the bottom edge.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach first creates a new matrix height where height[i][j] represents the height of the largest rectangle that can be formed with cell (i,j) as the bottom cell. If matrix[i][j] is \\'0\\', then height[i][j] is set to 0, since no rectangle can be formed with a bottom cell of \\'0\\'. Otherwise, height[i][j] is set to height[i-1][j] + 1 if i > 0, since we can extend a rectangle from the cell above it, or to 1 if i == 0, since the current cell is the topmost cell of the rectangle.\\n\\nOnce the height matrix has been constructed, the solution applies the modified histogram algorithm to each row of the height matrix to find the maximum area of a rectangle that can be formed using that row as the bottom edge. The modified histogram algorithm maintains a stack of indices of increasing heights of bars seen so far. When a bar with height smaller than the bar at the top of the stack is encountered, the bars in the stack are popped and their maximum area is calculated based on the height of the popped bar and the width of the rectangle, which is the difference between the current index and the index of the bar at the top of the stack (or the entire length of the stack if it is empty). The maximum area seen so far is updated if the current area is greater than it. Finally, the function returns the maximum area of a rectangle that can be formed using the heights of the bars in the given input array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\nThe code iterates over every cell in the input matrix once to calculate the height array, where m and n are the dimensions of the input matrix. It then calls the maxAreaInHist method once for each row in the matrix, which has a time complexity of O(n) for each row. Thus, the total time complexity is O(m * n) for the two nested loops and the maxAreaInHist method.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\nThe code creates a 2D array height with m rows and n+1 columns to store the height of the histogram. Each row of the height array has n+1 elements, which increases the space complexity by an extra n elements per row. Thus, the space complexity is O(m * (n+1)), which can be simplified to O(m * n) asymptotically. Additionally, the code uses a stack to store indices, which can have a worst-case space complexity of O(n) if all elements are strictly decreasing in height\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int m = matrix.length;\\n        int n = m == 0 ? 0 : matrix[0].length;\\n        int[][] height = new int[m][n + 1];\\n        int maxArea = 0;\\n        for (int i = 0; i < m; i++) \\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (matrix[i][j] == \\'0\\') \\n                {\\n                    height[i][j] = 0;\\n                } \\n                else \\n                {\\n                    height[i][j] = i == 0 ? 1 : height[i - 1][j] + 1;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < m; i++) \\n        {\\n            int area = maxAreaInHist(height[i]);\\n            if (area > maxArea) \\n            {\\n                maxArea = area;\\n            }\\n        }\\n        return maxArea;\\n    }\\n    private int maxAreaInHist(int[] height) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int i = 0;\\n        int max = 0;\\n        while (i < height.length) \\n        {\\n            if (stack.isEmpty() || height[stack.peek()] <= height[i]) \\n            {\\n                stack.push(i++);\\n            } \\n            else \\n            {\\n                int t = stack.pop();\\n                max = Math.max(max, height[t] * (stack.isEmpty() ? i : i - stack.peek() - 1));\\n            }\\n        }\\n        return max;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int m = matrix.length;\\n        int n = m == 0 ? 0 : matrix[0].length;\\n        int[][] height = new int[m][n + 1];\\n        int maxArea = 0;\\n        for (int i = 0; i < m; i++) \\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (matrix[i][j] == \\'0\\') \\n                {\\n                    height[i][j] = 0;\\n                } \\n                else \\n                {\\n                    height[i][j] = i == 0 ? 1 : height[i - 1][j] + 1;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < m; i++) \\n        {\\n            int area = maxAreaInHist(height[i]);\\n            if (area > maxArea) \\n            {\\n                maxArea = area;\\n            }\\n        }\\n        return maxArea;\\n    }\\n    private int maxAreaInHist(int[] height) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int i = 0;\\n        int max = 0;\\n        while (i < height.length) \\n        {\\n            if (stack.isEmpty() || height[stack.peek()] <= height[i]) \\n            {\\n                stack.push(i++);\\n            } \\n            else \\n            {\\n                int t = stack.pop();\\n                max = Math.max(max, height[t] * (stack.isEmpty() ? i : i - stack.peek() - 1));\\n            }\\n        }\\n        return max;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333513,
                "title": "stack-cpp-similar-to-max-area-in-histogram",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# **Please upvote the solution if you like it.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution uses the concept of histogram where the heights of each column are taken as bars of the histogram. Then, the problem is reduced to finding the largest rectangle area in the histogram.\\n\\nThe code first defines two helper functions nextSmaller() and prevSmaller() that return the indices of the next smaller and previous smaller element to each element of a given array. These functions use a stack to store the indices of the elements in a decreasing order of their values. The top of the stack always stores the index of the next smaller or previous smaller element.\\n\\nThen, the maxAreaHistogram() function takes an array and returns the maximum area of the rectangle that can be formed using the histogram of the heights of the bars of the histogram. It uses the nextSmaller() and prevSmaller() functions to calculate the next and previous smaller elements\\' indices for each element in the array and then calculates the maximum area of the rectangle using the formula area = length * width, where length is the height of the current element, and width is the distance between the next smaller and previous smaller element indices.\\n\\nFinally, the maximalRectangle() function takes the binary matrix as input, converts it into an array of integers, and calculates the maximum area of the rectangle by iterating over each row of the matrix and updating the array of heights for each row. The maximum area is returned as the output.\\n\\nOverall, the code is an implementation of the histogram-based approach to find the maximal rectangle area in a binary matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n) where m and n are the dimensions of the input matrix.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> nextSmaller(vector<int> &arr,int n){\\n        stack<int> st;\\n        vector<int> ans(n);\\n        st.push(-1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            while(st.top()!=-1 && arr[st.top()]>=arr[i]){\\n                st.pop();\\n            }\\n            ans[i]=st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> prevSmaller(vector<int> &arr,int n){\\n        stack<int> st;\\n        vector<int> ans(n);\\n        st.push(-1);\\n        for(int i=0;i<arr.size();i++){\\n            while(st.top()!=-1 && arr[st.top()]>=arr[i]){\\n                st.pop();\\n            }\\n            ans[i]=st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    int maxAreaHistogram(vector<int> &arr){\\n        int n = arr.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = nextSmaller(arr,n);\\n        prev = prevSmaller(arr,n);\\n        int area = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int length = arr[i];\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int width = next[i]-prev[i]-1;\\n            area = max(area,(length*width));\\n        }\\n        return area;\\n    }\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        ios_base::sync_with_stdio(false);\\n        vector<vector<int>> mat;\\n        for(int i=0;i<matrix.size();i++){\\n            vector<int> v;\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==\\'1\\'){\\n                    v.push_back(1);\\n                }\\n                else{\\n                    v.push_back(0);\\n                }\\n            }\\n            mat.push_back(v);\\n        }\\n        int n = mat.size();\\n        int area = maxAreaHistogram(mat[0]);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]!=0){\\n                    mat[i][j]+=mat[i-1][j];\\n                }\\n            }\\n            area=max(area,maxAreaHistogram(mat[i]));\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> nextSmaller(vector<int> &arr,int n){\\n        stack<int> st;\\n        vector<int> ans(n);\\n        st.push(-1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            while(st.top()!=-1 && arr[st.top()]>=arr[i]){\\n                st.pop();\\n            }\\n            ans[i]=st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> prevSmaller(vector<int> &arr,int n){\\n        stack<int> st;\\n        vector<int> ans(n);\\n        st.push(-1);\\n        for(int i=0;i<arr.size();i++){\\n            while(st.top()!=-1 && arr[st.top()]>=arr[i]){\\n                st.pop();\\n            }\\n            ans[i]=st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    int maxAreaHistogram(vector<int> &arr){\\n        int n = arr.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = nextSmaller(arr,n);\\n        prev = prevSmaller(arr,n);\\n        int area = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int length = arr[i];\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int width = next[i]-prev[i]-1;\\n            area = max(area,(length*width));\\n        }\\n        return area;\\n    }\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        ios_base::sync_with_stdio(false);\\n        vector<vector<int>> mat;\\n        for(int i=0;i<matrix.size();i++){\\n            vector<int> v;\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==\\'1\\'){\\n                    v.push_back(1);\\n                }\\n                else{\\n                    v.push_back(0);\\n                }\\n            }\\n            mat.push_back(v);\\n        }\\n        int n = mat.size();\\n        int area = maxAreaHistogram(mat[0]);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]!=0){\\n                    mat[i][j]+=mat[i-1][j];\\n                }\\n            }\\n            area=max(area,maxAreaHistogram(mat[i]));\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308619,
                "title": "easy-c-code-zarur-dkhooo",
                "content": "# Intuition\\nThis question links the concept of several questions, for example: \\n- Finding next smaller element\\n- Finding Previous smaller element\\n- Histogram area problem.\\nSo we will be just writting 3 seperate functions for each set of problem mentioned above and use these functions in our current working function.\\n\\n---\\n\\n# Complexity\\n\\n- Time complexity:\\nO(NXN)\\n\\n- Space complexity:\\nO(N), since we have created vectors.\\n\\n---\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     vector<int> prev(vector<int> v,int n){\\n         vector<int> ans(n);\\n         stack<int> s;\\n         s.push(-1);\\n         for(int i=0;i<n;i++){\\n        int curr=v[i];\\n        while(s.top()!=-1 && v[s.top()]>=curr){\\n            s.pop();\\n        }\\n        //top me hi ans h;\\n         ans[i]=s.top();\\n         s.push(i);\\n         }\\n         return ans;\\n     }\\n\\n     vector<int> next(vector<int> v,int n){\\n         vector<int> ans(n);\\n         stack<int> s;\\n           s.push(-1);\\n         for(int i=n-1;i>=0;i--){\\n        int curr=v[i];\\n        while(s.top()!=-1 && v[s.top()]>=curr){\\n            s.pop();\\n        }\\n        //top me hi ans h;\\n         ans[i]=s.top();\\n         s.push(i);\\n         }\\n         return ans;\\n     }\\n\\n    int maxHisto(vector<int> v){\\n        int nt=v.size();\\n        vector<int> p(nt);\\n        p=prev(v,nt);\\n        vector<int> n(nt);\\n        n=next(v,nt);\\n        int sum=INT_MIN;\\n        for(int i=0;i<nt;i++){\\n          if(n[i]==-1){\\n              n[i]=nt;\\n          }\\n        int a= v[i]*(n[i]-p[i]-1);\\n        sum=max(a,sum);\\n        }\\n        return sum;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n       vector<vector<int>> v(matrix.size());\\n       for(int i=0;i<matrix.size();i++){\\n           for(int j=0;j<matrix[i].size();j++){\\n               if(matrix[i][j]==\\'0\\')\\n  v[i].push_back(0);\\n  else v[i].push_back(1);\\n           }\\n       } \\n       int first= maxHisto(v[0]);\\n     for(int i=1;i<v.size();i++){\\n        for(int j=0;j<v[i].size();j++){\\n            if(v[i][j]!=0){\\n                v[i][j]=v[i-1][j]+v[i][j];\\n            }\\n            else v[i][j]=0;\\n        }\\n        int a=  maxHisto(v[i]);\\n        first= max(first,a);\\n     }\\nreturn first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int> prev(vector<int> v,int n){\\n         vector<int> ans(n);\\n         stack<int> s;\\n         s.push(-1);\\n         for(int i=0;i<n;i++){\\n        int curr=v[i];\\n        while(s.top()!=-1 && v[s.top()]>=curr){\\n            s.pop();\\n        }\\n        //top me hi ans h;\\n         ans[i]=s.top();\\n         s.push(i);\\n         }\\n         return ans;\\n     }\\n\\n     vector<int> next(vector<int> v,int n){\\n         vector<int> ans(n);\\n         stack<int> s;\\n           s.push(-1);\\n         for(int i=n-1;i>=0;i--){\\n        int curr=v[i];\\n        while(s.top()!=-1 && v[s.top()]>=curr){\\n            s.pop();\\n        }\\n        //top me hi ans h;\\n         ans[i]=s.top();\\n         s.push(i);\\n         }\\n         return ans;\\n     }\\n\\n    int maxHisto(vector<int> v){\\n        int nt=v.size();\\n        vector<int> p(nt);\\n        p=prev(v,nt);\\n        vector<int> n(nt);\\n        n=next(v,nt);\\n        int sum=INT_MIN;\\n        for(int i=0;i<nt;i++){\\n          if(n[i]==-1){\\n              n[i]=nt;\\n          }\\n        int a= v[i]*(n[i]-p[i]-1);\\n        sum=max(a,sum);\\n        }\\n        return sum;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n       vector<vector<int>> v(matrix.size());\\n       for(int i=0;i<matrix.size();i++){\\n           for(int j=0;j<matrix[i].size();j++){\\n               if(matrix[i][j]==\\'0\\')\\n  v[i].push_back(0);\\n  else v[i].push_back(1);\\n           }\\n       } \\n       int first= maxHisto(v[0]);\\n     for(int i=1;i<v.size();i++){\\n        for(int j=0;j<v[i].size();j++){\\n            if(v[i][j]!=0){\\n                v[i][j]=v[i-1][j]+v[i][j];\\n            }\\n            else v[i][j]=0;\\n        }\\n        int a=  maxHisto(v[i]);\\n        first= max(first,a);\\n     }\\nreturn first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185239,
                "title": "maximal-rectangle-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses the concept of histogram to solve the problem. For each row, it converts the binary values into heights of the bars and then calculates the largest rectangle in the histogram using the stack data structure. The solution has a time complexity of O(n * m) and a space complexity of O(m).\\n\\n# Complexity\\n- Time complexity:\\n89.51%\\n\\n- Space complexity:\\n85%\\n\\n# Code\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        \\n        n, m = len(matrix), len(matrix[0])\\n        height = [0] * (m + 1)\\n        ans = 0\\n        \\n        for row in matrix:\\n            for i in range(m):\\n                height[i] = height[i] + 1 if row[i] == \\'1\\' else 0\\n            stack = [-1]\\n            for i in range(m + 1):\\n                while height[i] < height[stack[-1]]:\\n                    h = height[stack.pop()]\\n                    w = i - stack[-1] - 1\\n                    ans = max(ans, h * w)\\n                stack.append(i)\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        \\n        n, m = len(matrix), len(matrix[0])\\n        height = [0] * (m + 1)\\n        ans = 0\\n        \\n        for row in matrix:\\n            for i in range(m):\\n                height[i] = height[i] + 1 if row[i] == \\'1\\' else 0\\n            stack = [-1]\\n            for i in range(m + 1):\\n                while height[i] < height[stack[-1]]:\\n                    h = height[stack.pop()]\\n                    w = i - stack[-1] - 1\\n                    ans = max(ans, h * w)\\n                stack.append(i)\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495314,
                "title": "aditya-verma-solution-c-maximal-rectangle",
                "content": "# Aditya Verma Solutions\\n\\n**Q1.**\\n***85. Maximal Rectangle***\\nhttps://leetcode.com/problems/maximal-rectangle/\\n\\n```\\nclass Solution {\\npublic:\\nint largestRectangleArea(vector<int>& heights) {\\n    int n= heights.size();\\n    vector<int> left,right;\\n    stack<pair<int,int>> s1,s2;\\n    int pseudo_index =-1;\\n    int pseudo_index1 =n;\\n    for (int i=0;i<n;i++)\\n    {\\n      if (s1.size()==0)\\n      {\\n        left.push_back(pseudo_index);\\n      }\\n      else if (s1.size()>0 && s1.top().first<heights[i])\\n      {\\n        left.push_back(s1.top().second);\\n      }\\n      else if (s1.size()>0 && s1.top().first>=heights[i])\\n      {\\n         while(s1.size()>0 && s1.top().first>=heights[i])\\n         {\\n           s1.pop();\\n         }\\n        if (s1.size()==0)\\n        {\\n          left.push_back(pseudo_index);\\n        }\\n        else\\n        {\\n          left.push_back(s1.top().second);\\n        }\\n      }\\n      s1.push({heights[i],i});\\n    }\\n    for (int i=n-1;i>=0;i--)\\n    {\\n      if (s2.size()==0)\\n      {\\n        right.push_back(pseudo_index1);\\n      }\\n      else if (s2.size()>0 && s2.top().first<heights[i])\\n      {\\n        right.push_back(s2.top().second);\\n      }\\n      else if (s2.size()>0 && s2.top().first >= heights[i])\\n      {\\n        while(s2.size()>0 && s2.top().first >= heights[i])\\n        {\\n          s2.pop();\\n        }\\n        if (s2.size()==0)\\n        {\\n          right.push_back(pseudo_index1);\\n        }\\n        else\\n        {\\n          right.push_back(s2.top().second);\\n        }\\n      }\\n      s2.push({heights[i],i});\\n    }\\n    reverse(right.begin(),right.end());\\n    int m=INT_MIN;\\n    for (long long i=0;i<n;i++)\\n    {\\n      m=max(m,(right[i]-left[i]-1)*heights[i]);// taking max after finding area\\n    }\\n    return m;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestRectangleArea(histogram));\\n            // cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};\\n\\n```\\n\\n**Q2.**\\n***84. Largest Rectangle in Histogram***\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\n```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tint getMaxArea(vector<int> &arr, int n)\\n\\t\\t{\\n\\t\\t\\tvector<int> left, right;\\n\\t\\t\\tstack<pair<int, int>> s1, s2;\\n\\t\\t\\tint pseudo_index = -1;\\n\\t\\t\\tint pseudo_index1 = n;\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (s1.size() == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tleft.push_back(pseudo_index);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (s1.size() > 0 && s1.top().first < arr[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tleft.push_back(s1.top().second);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (s1.size() > 0 && s1.top().first >= arr[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile (s1.size() > 0 && s1.top().first >= arr[i])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts1.pop();\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (s1.size() == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tleft.push_back(pseudo_index);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tleft.push_back(s1.top().second);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ts1.push({ arr[i], i });\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = n - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (s2.size() == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tright.push_back(pseudo_index1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (s2.size() > 0 && s2.top().first < arr[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tright.push_back(s2.top().second);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (s2.size() > 0 && s2.top().first >= arr[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile (s2.size() > 0 && s2.top().first >= arr[i])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts2.pop();\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (s2.size() == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tright.push_back(pseudo_index1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tright.push_back(s2.top().second);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ts2.push({ arr[i], i });\\n\\t\\t\\t}\\n\\n\\t\\t\\treverse(right.begin(), right.end());\\n\\t\\t\\tint m = INT_MIN;\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint s = (right[i] - left[i] - 1) *arr[i];\\n\\t\\t\\t\\tm = max(m, s);\\t// taking max after finding area\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn m;\\n\\t\\t}\\n\\n\\tint largestRectangleArea(vector<int> &heights)\\n\\t{\\n\\t\\tint n = heights.size();\\n\\t\\treturn getMaxArea(heights, n);\\n\\n\\t}\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint largestRectangleArea(vector<int>& heights) {\\n    int n= heights.size();\\n    vector<int> left,right;\\n    stack<pair<int,int>> s1,s2;\\n    int pseudo_index =-1;\\n    int pseudo_index1 =n;\\n    for (int i=0;i<n;i++)\\n    {\\n      if (s1.size()==0)\\n      {\\n        left.push_back(pseudo_index);\\n      }\\n      else if (s1.size()>0 && s1.top().first<heights[i])\\n      {\\n        left.push_back(s1.top().second);\\n      }\\n      else if (s1.size()>0 && s1.top().first>=heights[i])\\n      {\\n         while(s1.size()>0 && s1.top().first>=heights[i])\\n         {\\n           s1.pop();\\n         }\\n        if (s1.size()==0)\\n        {\\n          left.push_back(pseudo_index);\\n        }\\n        else\\n        {\\n          left.push_back(s1.top().second);\\n        }\\n      }\\n      s1.push({heights[i],i});\\n    }\\n    for (int i=n-1;i>=0;i--)\\n    {\\n      if (s2.size()==0)\\n      {\\n        right.push_back(pseudo_index1);\\n      }\\n      else if (s2.size()>0 && s2.top().first<heights[i])\\n      {\\n        right.push_back(s2.top().second);\\n      }\\n      else if (s2.size()>0 && s2.top().first >= heights[i])\\n      {\\n        while(s2.size()>0 && s2.top().first >= heights[i])\\n        {\\n          s2.pop();\\n        }\\n        if (s2.size()==0)\\n        {\\n          right.push_back(pseudo_index1);\\n        }\\n        else\\n        {\\n          right.push_back(s2.top().second);\\n        }\\n      }\\n      s2.push({heights[i],i});\\n    }\\n    reverse(right.begin(),right.end());\\n    int m=INT_MIN;\\n    for (long long i=0;i<n;i++)\\n    {\\n      m=max(m,(right[i]-left[i]-1)*heights[i]);// taking max after finding area\\n    }\\n    return m;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestRectangleArea(histogram));\\n            // cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2490705,
                "title": "using-kadane-s-algorithm",
                "content": "Just Replace 0 with negative of MAX possible sum in array. And proceed as in the question of finding maximum sum rectangle.\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int ans = 0, m=matrix.length,n = matrix[0].length,INF = -m*n;\\n        for(int j=0;j<n;j++){\\n            int[] temp = new int[m];\\n            for(int z=j;z<n;z++){\\n                for(int c=0;c<m;c++) temp[c]+= matrix[c][z]==\\'0\\'?INF:1;\\n        \\n                ans = Math.max(ans,kadaneAlgo(temp));\\n            }\\n        }\\n        return ans;\\n    }\\n    private int kadaneAlgo(int[] arr){\\n        int max = arr[0], local_max = arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            local_max = Math.max(arr[i],local_max+arr[i]);\\n            max = Math.max(local_max,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int ans = 0, m=matrix.length,n = matrix[0].length,INF = -m*n;\\n        for(int j=0;j<n;j++){\\n            int[] temp = new int[m];\\n            for(int z=j;z<n;z++){\\n                for(int c=0;c<m;c++) temp[c]+= matrix[c][z]==\\'0\\'?INF:1;\\n        \\n                ans = Math.max(ans,kadaneAlgo(temp));\\n            }\\n        }\\n        return ans;\\n    }\\n    private int kadaneAlgo(int[] arr){\\n        int max = arr[0], local_max = arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            local_max = Math.max(arr[i],local_max+arr[i]);\\n            max = Math.max(local_max,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460850,
                "title": "java-same-as-maximum-rectangle-in-histogram-nsl-nsr-aditya-verma",
                "content": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] heights = new int[n];\\n           \\n        int ans = Integer.MIN_VALUE;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n               heights[j] = matrix[i][j] == \\'1\\' ? heights[j] + 1: 0;\\n            }\\n            ans = Math.max(ans, getMAH(heights, n));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int getMAH(int[] heights, int n) {\\n        int maxArea = Integer.MIN_VALUE;\\n        List<Integer> nsl = NSL(heights, n);\\n        List<Integer> nsr = NSR(heights, n);\\n        int[] width = new int[n];\\n        \\n        for(int i=0; i<n; i++)\\n            width[i] = nsr.get(i) - nsl.get(i) - 1;\\n                \\n        for(int i=0; i<n; i++) {\\n            int area = heights[i] * width[i];\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }\\n    \\n    \\n    private List<Integer> NSL(int[] heights, int n) {\\n            \\n        List<Integer> nsl = new ArrayList<>();\\n        Stack<int[]> st = new Stack<>();\\n        \\n        for(int i=0; i<n; i++) {\\n            int curr = heights[i];\\n            while(!st.isEmpty() && st.peek()[0] >= curr) { st.pop(); }\\n            if(st.isEmpty()) nsl.add(-1);\\n            else nsl.add(st.peek()[1]);\\n            st.add(new int[] { curr, i });\\n        }\\n        \\n        return nsl;\\n    }\\n    \\n    \\n     private List<Integer> NSR(int[] heights, int n) {\\n            \\n        List<Integer> nsr = new ArrayList<>();\\n        Stack<int[]> st = new Stack<>();\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            int curr = heights[i];\\n            while(!st.isEmpty() && st.peek()[0] >= curr) { st.pop(); }\\n            if(st.isEmpty()) nsr.add(n);\\n            else nsr.add(st.peek()[1]);\\n            st.add(new int[] { curr, i });\\n        }\\n         \\n        Collections.reverse(nsr);\\n        return nsr;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] heights = new int[n];\\n           \\n        int ans = Integer.MIN_VALUE;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n               heights[j] = matrix[i][j] == \\'1\\' ? heights[j] + 1: 0;\\n            }\\n            ans = Math.max(ans, getMAH(heights, n));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int getMAH(int[] heights, int n) {\\n        int maxArea = Integer.MIN_VALUE;\\n        List<Integer> nsl = NSL(heights, n);\\n        List<Integer> nsr = NSR(heights, n);\\n        int[] width = new int[n];\\n        \\n        for(int i=0; i<n; i++)\\n            width[i] = nsr.get(i) - nsl.get(i) - 1;\\n                \\n        for(int i=0; i<n; i++) {\\n            int area = heights[i] * width[i];\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }\\n    \\n    \\n    private List<Integer> NSL(int[] heights, int n) {\\n            \\n        List<Integer> nsl = new ArrayList<>();\\n        Stack<int[]> st = new Stack<>();\\n        \\n        for(int i=0; i<n; i++) {\\n            int curr = heights[i];\\n            while(!st.isEmpty() && st.peek()[0] >= curr) { st.pop(); }\\n            if(st.isEmpty()) nsl.add(-1);\\n            else nsl.add(st.peek()[1]);\\n            st.add(new int[] { curr, i });\\n        }\\n        \\n        return nsl;\\n    }\\n    \\n    \\n     private List<Integer> NSR(int[] heights, int n) {\\n            \\n        List<Integer> nsr = new ArrayList<>();\\n        Stack<int[]> st = new Stack<>();\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            int curr = heights[i];\\n            while(!st.isEmpty() && st.peek()[0] >= curr) { st.pop(); }\\n            if(st.isEmpty()) nsr.add(n);\\n            else nsr.add(st.peek()[1]);\\n            st.add(new int[] { curr, i });\\n        }\\n         \\n        Collections.reverse(nsr);\\n        return nsr;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281941,
                "title": "easy-c-solution-dp-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxarea(vector<int> &v){\\n        stack<int> s;\\n        int ans=0;\\n        for(int i=0; i<=v.size(); i++){\\n            while(!s.empty() && (i==v.size() || v[s.top()]>v[i])){\\n                int cur=s.top();\\n                s.pop();\\n                int width = s.empty()? i:i-s.top()-1;\\n                ans = max(ans, width*v[cur]);\\n            }\\n            s.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> curr(n, 0);\\n        \\n        int ans=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')     curr[j]++;\\n                else    curr[j]=0;\\n            }\\n            int area = maxarea(curr);\\n            ans=max(ans, area);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxarea(vector<int> &v){\\n        stack<int> s;\\n        int ans=0;\\n        for(int i=0; i<=v.size(); i++){\\n            while(!s.empty() && (i==v.size() || v[s.top()]>v[i])){\\n                int cur=s.top();\\n                s.pop();\\n                int width = s.empty()? i:i-s.top()-1;\\n                ans = max(ans, width*v[cur]);\\n            }\\n            s.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> curr(n, 0);\\n        \\n        int ans=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')     curr[j]++;\\n                else    curr[j]=0;\\n            }\\n            int area = maxarea(curr);\\n            ans=max(ans, area);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904690,
                "title": "illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/0f9c1431-a088-4d22-b810-5abfd51f4630_1648848619.0584486.png)\\n\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \"\"\" O(NM)TS \"\"\"\\n        ans = []\\n        prefix = [*zip(*([*itertools.accumulate(map(int, col), lambda x, y: x + y if y == 1 else 0)] for col in zip(*matrix)))]\\n\\n        for row in prefix:\\n            stack = [-1]\\n            for i, n in enumerate(row):\\n                while len(stack) > 1 and row[stack[-1]] >= n:\\n                    ans += row[stack.pop()] * (i - stack[-1] - 1),\\n                stack += i,\\n            while len(stack) > 1:\\n                ans += row[stack.pop()] * (len(row) - stack[-1] - 1),\\n\\n        return max(ans)\\n\\t\\t\\n\\nsee the problem 84\\n\\n![image](https://assets.leetcode.com/users/images/25726517-a8f6-4496-9756-8ee5d78a0a1d_1648848646.6423938.png)\\n\\nhow to use pref summ\\n\\n\\n![image](https://assets.leetcode.com/users/images/afee3df3-6d24-4b1b-9a54-b5bce4bb1679_1648848659.2007706.png)\\n\\n![image](https://assets.leetcode.com/users/images/28fa08c0-f430-4f32-98ff-c016d18e16e4_1648848666.474494.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/0f9c1431-a088-4d22-b810-5abfd51f4630_1648848619.0584486.png)\\n\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \"\"\" O(NM)TS \"\"\"\\n        ans = []\\n        prefix = [*zip(*([*itertools.accumulate(map(int, col), lambda x, y: x + y if y == 1 else 0)] for col in zip(*matrix)))]\\n\\n        for row in prefix:\\n            stack = [-1]\\n            for i, n in enumerate(row):\\n                while len(stack) > 1 and row[stack[-1]] >= n:\\n                    ans += row[stack.pop()] * (i - stack[-1] - 1),\\n                stack += i,\\n            while len(stack) > 1:\\n                ans += row[stack.pop()] * (len(row) - stack[-1] - 1),\\n\\n        return max(ans)\\n\\t\\t\\n\\nsee the problem 84\\n\\n![image](https://assets.leetcode.com/users/images/25726517-a8f6-4496-9756-8ee5d78a0a1d_1648848646.6423938.png)\\n\\nhow to use pref summ\\n\\n\\n![image](https://assets.leetcode.com/users/images/afee3df3-6d24-4b1b-9a54-b5bce4bb1679_1648848659.2007706.png)\\n\\n![image](https://assets.leetcode.com/users/images/28fa08c0-f430-4f32-98ff-c016d18e16e4_1648848666.474494.png)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1873952,
                "title": "explanation-with-diagram",
                "content": "![image](https://assets.leetcode.com/users/images/468d99fd-4348-4866-8b8c-9609d3293cfd_1648020077.274421.png)\\n\\n\\n1. Every row can be converted into a histogram very easily. Total time taken for this operation will be **O(rows * cols)**.\\n2. Then for every histogram we can find the largest area of rectangle in it. We can find the largest area of rectangle in histogram in **O(cols)** time using monotonous stack. So the total time complexity for finding largest area of reactangle in every histogram will be **O(rows * cols)**.\\n3. Max rectangle will be the largest area of histogram among all histograms.\\n\\nTime Complexity: O(rows * cols)\\nSpace Complexity: O(rows * cols)\\n\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n\\n        vector<vector<int>> rowHeights(rows, vector(cols, 0));\\n        \\n\\t\\t// convert every row into a histogram\\n        for(int row = 0; row < rows; row++) {\\n            for(int col = 0; col < cols; col++) {\\n                if (row == 0) {\\n                    rowHeights[row][col] = matrix[row][col] - \\'0\\';\\n                } else {\\n                    if (matrix[row][col] == \\'0\\') rowHeights[row][col] = 0;\\n                    else rowHeights[row][col] = 1 + rowHeights[row-1][col];\\n                }\\n            }\\n        }\\n        \\n        int maxRectangle = 0;\\n        \\n        for(auto &heights: rowHeights) {\\n            int area = getMaxArea(heights);\\n            maxRectangle = max(area, maxRectangle);\\n        }\\n        \\n        return maxRectangle;\\n    }\\n    \\n    // return the maximum area of rectangle in histogram\\n    int getMaxArea(vector<int> &heights) {\\n        int n = heights.size();\\n        vector<int> areas(n);\\n        stack<int> stk;\\n        stk.push(n);\\n        \\n        // nearest smaller element to right\\n        for(int i = n-1; i >= 0; i--) {\\n            int height = heights[i];\\n\\n            while (stk.top() != n && heights[stk.top()] >= height) stk.pop();\\n            \\n            areas[i] = stk.top();\\n            \\n            stk.push(i);\\n        }\\n\\n        stk.push(-1);\\n        // nearest smaller element to left\\n        for(int i = 0; i < n; i++) {\\n            int height = heights[i];\\n\\n            while (stk.top() != -1 && heights[stk.top()] >= height) stk.pop();\\n            \\n            // width = right - left - 1\\n            // width = right - (left + 1)\\n            areas[i] -= stk.top() + 1;\\n\\n            areas[i] *= height;\\n            \\n            stk.push(i);\\n        }\\n        \\n        return *max_element(areas.begin(), areas.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n\\n        vector<vector<int>> rowHeights(rows, vector(cols, 0));\\n        \\n\\t\\t// convert every row into a histogram\\n        for(int row = 0; row < rows; row++) {\\n            for(int col = 0; col < cols; col++) {\\n                if (row == 0) {\\n                    rowHeights[row][col] = matrix[row][col] - \\'0\\';\\n                } else {\\n                    if (matrix[row][col] == \\'0\\') rowHeights[row][col] = 0;\\n                    else rowHeights[row][col] = 1 + rowHeights[row-1][col];\\n                }\\n            }\\n        }\\n        \\n        int maxRectangle = 0;\\n        \\n        for(auto &heights: rowHeights) {\\n            int area = getMaxArea(heights);\\n            maxRectangle = max(area, maxRectangle);\\n        }\\n        \\n        return maxRectangle;\\n    }\\n    \\n    // return the maximum area of rectangle in histogram\\n    int getMaxArea(vector<int> &heights) {\\n        int n = heights.size();\\n        vector<int> areas(n);\\n        stack<int> stk;\\n        stk.push(n);\\n        \\n        // nearest smaller element to right\\n        for(int i = n-1; i >= 0; i--) {\\n            int height = heights[i];\\n\\n            while (stk.top() != n && heights[stk.top()] >= height) stk.pop();\\n            \\n            areas[i] = stk.top();\\n            \\n            stk.push(i);\\n        }\\n\\n        stk.push(-1);\\n        // nearest smaller element to left\\n        for(int i = 0; i < n; i++) {\\n            int height = heights[i];\\n\\n            while (stk.top() != -1 && heights[stk.top()] >= height) stk.pop();\\n            \\n            // width = right - left - 1\\n            // width = right - (left + 1)\\n            areas[i] -= stk.top() + 1;\\n\\n            areas[i] *= height;\\n            \\n            stk.push(i);\\n        }\\n        \\n        return *max_element(areas.begin(), areas.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825997,
                "title": "c-two-stacks-solution-simple",
                "content": "leetcode 84-> same approach\\n https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1825607/C++-oror-two-stack-solution-oror-simple-oror-previous-smaller-element-oror-next-smaller-element\\n \\n ```\\n class Solution {\\n    int fun(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> nsl,nsr;\\n        stack<pair<int,int>> s1,s2;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(s1.empty())\\n                nsl.push_back(-1);\\n            else{\\n                while(!s1.empty() && s1.top().first>=nums[i])\\n                    s1.pop();\\n                if(s1.empty())\\n                    nsl.push_back(-1);\\n                else\\n                    nsl.push_back(s1.top().second);\\n            }\\n            s1.push({nums[i],i});\\n        }\\n\\t\\t\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s2.empty())\\n                nsr.push_back(n);\\n            else{\\n                while(!s2.empty() && s2.top().first>=nums[i])\\n                    s2.pop();\\n                if(s2.empty())\\n                    nsr.push_back(n);\\n                else\\n                    nsr.push_back(s2.top().second);\\n            }\\n            s2.push({nums[i],i});\\n        }\\n        reverse(nsr.begin(),nsr.end());\\n\\t\\t\\n        int res = INT_MIN;\\n        int val=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            val = (nsr[i]-nsl[i]-1)*nums[i];\\n            res = max(res,val);\\n        }\\n        return res;\\n    }\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row = matrix.size();\\n        int column = matrix[0].size();\\n        vector<int> arr(column,0);\\n        int res = INT_MIN;\\n        for(int i = 0;i<row;i++)\\n        {\\n            for(int j=0;j<column;j++)\\n            {\\n                if(matrix[i][j]==\\'0\\')\\n                    arr[j]=0;\\n                else\\n                    arr[j]++;\\n            }\\n            res = max(res,fun(arr));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\n    int fun(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> nsl,nsr;\\n        stack<pair<int,int>> s1,s2;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(s1.empty())\\n                nsl.push_back(-1);\\n            else{\\n                while(!s1.empty() && s1.top().first>=nums[i])\\n                    s1.pop();\\n                if(s1.empty())\\n                    nsl.push_back(-1);\\n                else\\n                    nsl.push_back(s1.top().second);\\n            }\\n            s1.push({nums[i],i});\\n        }\\n\\t\\t\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s2.empty())\\n                nsr.push_back(n);\\n            else{\\n                while(!s2.empty() && s2.top().first>=nums[i])\\n                    s2.pop();\\n                if(s2.empty())\\n                    nsr.push_back(n);\\n                else\\n                    nsr.push_back(s2.top().second);\\n            }\\n            s2.push({nums[i],i});\\n        }\\n        reverse(nsr.begin(),nsr.end());\\n\\t\\t\\n        int res = INT_MIN;\\n        int val=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            val = (nsr[i]-nsl[i]-1)*nums[i];\\n            res = max(res,val);\\n        }\\n        return res;\\n    }\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row = matrix.size();\\n        int column = matrix[0].size();\\n        vector<int> arr(column,0);\\n        int res = INT_MIN;\\n        for(int i = 0;i<row;i++)\\n        {\\n            for(int j=0;j<column;j++)\\n            {\\n                if(matrix[i][j]==\\'0\\')\\n                    arr[j]=0;\\n                else\\n                    arr[j]++;\\n            }\\n            res = max(res,fun(arr));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791446,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic: \\n    vector<int> nextSmallerElement(int *arr,int n)\\n    {\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int curr=arr[i];\\n            while(s.top()!=-1 && arr[s.top()]>=curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> prevSmallerElement(int *arr,int n)\\n    {\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int curr=arr[i];\\n            while(s.top()!=-1 && arr[s.top()]>=curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    int largestRectangleArea(int *heights,int n) {\\n        //int n=heights.size();\\n        \\n        vector<int> next(n);\\n        next=nextSmallerElement(heights,n);\\n        \\n        vector<int> prev(n);\\n        prev=prevSmallerElement(heights,n);\\n        \\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            \\n            if(next[i]==-1)\\n                next[i]=n;\\n            int b=next[i]-prev[i]-1;\\n            int newArea=l*b;\\n            area= max(area,newArea);\\n        }\\n        return area;\\n        \\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int rows=matrix.size();\\n        int cols=matrix[0].size();\\n        int mat[rows][cols];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                mat[i][j]=matrix[i][j]-\\'0\\';\\n            }\\n        }\\n        int area=largestRectangleArea(mat[0],cols);\\n        for(int i=1;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n               if(mat[i][j]!=0)\\n                   mat[i][j]=mat[i][j]+mat[i-1][j];\\n                else\\n                    mat[i][j]=0;\\n            }\\n             int newArea=largestRectangleArea(mat[i],cols);\\n            area=max(area,newArea);\\n        }\\n        \\n       return area;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic: \\n    vector<int> nextSmallerElement(int *arr,int n)\\n    {\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int curr=arr[i];\\n            while(s.top()!=-1 && arr[s.top()]>=curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> prevSmallerElement(int *arr,int n)\\n    {\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int curr=arr[i];\\n            while(s.top()!=-1 && arr[s.top()]>=curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    int largestRectangleArea(int *heights,int n) {\\n        //int n=heights.size();\\n        \\n        vector<int> next(n);\\n        next=nextSmallerElement(heights,n);\\n        \\n        vector<int> prev(n);\\n        prev=prevSmallerElement(heights,n);\\n        \\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            \\n            if(next[i]==-1)\\n                next[i]=n;\\n            int b=next[i]-prev[i]-1;\\n            int newArea=l*b;\\n            area= max(area,newArea);\\n        }\\n        return area;\\n        \\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int rows=matrix.size();\\n        int cols=matrix[0].size();\\n        int mat[rows][cols];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                mat[i][j]=matrix[i][j]-\\'0\\';\\n            }\\n        }\\n        int area=largestRectangleArea(mat[0],cols);\\n        for(int i=1;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n               if(mat[i][j]!=0)\\n                   mat[i][j]=mat[i][j]+mat[i-1][j];\\n                else\\n                    mat[i][j]=0;\\n            }\\n             int newArea=largestRectangleArea(mat[i],cols);\\n            area=max(area,newArea);\\n        }\\n        \\n       return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718057,
                "title": "c-solution",
                "content": "```class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> dp (matrix[0].size(), 0);\\n        int res = 0;\\n        \\n        for (int i = 0; i < matrix.size(); i++) {\\n            for (int j = 0; j < matrix[0].size(); j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    dp[j] ++;\\n                    int row_len = dp[j];\\n                    int k = j;\\n                    while (k >= 0) {\\n                        row_len = min(row_len, dp[k]);\\n                        res = max(res, row_len * (j - k + 1));\\n                        k--;\\n                    }\\n                } else {\\n                    dp[j] = 0;\\n                }\\n            }\\n        } \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> dp (matrix[0].size(), 0);\\n        int res = 0;\\n        \\n        for (int i = 0; i < matrix.size(); i++) {\\n            for (int j = 0; j < matrix[0].size(); j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    dp[j] ++;\\n                    int row_len = dp[j];\\n                    int k = j;\\n                    while (k >= 0) {\\n                        row_len = min(row_len, dp[k]);\\n                        res = max(res, row_len * (j - k + 1));\\n                        k--;\\n                    }\\n                } else {\\n                    dp[j] = 0;\\n                }\\n            }\\n        } \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630281,
                "title": "easy-to-understand-in-c-histogram-approach-d-p",
                "content": "class Solution {\\npublic:\\n    \\n    int maxAreaHistogram(vector<int>& heights)\\n    {\\n        int n = heights.size();\\n        vector<int> nsl(n),psl(n);\\n        \\n        stack<int> s;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[s.top()]>=heights[i]){\\n                s.pop();\\n            }\\n            nsl[i] = s.empty() ? n : s.top();\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && heights[s.top()]>=heights[i]){\\n                s.pop();\\n            }\\n            psl[i] = s.empty() ? -1: s.top();\\n            s.push(i);\\n        }\\n        \\n        int ans = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            ans = max(ans,(nsl[i]-psl[i]-1)*(heights[i]));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        if( matrix.empty() ) return 0;\\n        \\n        int rowSize = matrix.size();\\n        int colSize = matrix[0].size();\\n        int maxArea = 0;\\n        \\n        vector<vector<int>>grid(rowSize,vector<int>(colSize,0));\\n        \\n        for( int i = 0; i < rowSize; i++ )\\n        {\\n            for( int j = 0; j < colSize; j++ )\\n            {\\n                grid[i][j] = ( matrix[i][j] == \\'1\\' ? 1 : 0 );\\n                if( i != 0 && grid[i][j] == 1 ) grid[i][j] += grid[i-1][j];\\n            }\\n            \\n            int tmpAns = maxAreaHistogram(grid[i]);\\n            maxArea = max(maxArea,tmpAns);\\n        }\\n\\n        return maxArea;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int maxAreaHistogram(vector<int>& heights)\\n    {\\n        int n = heights.size();\\n        vector<int> nsl(n),psl(n);\\n        \\n        stack<int> s;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[s.top()]>=heights[i]){\\n                s.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1572778,
                "title": "python-from-n-4-to-n-3-to-n-2",
                "content": "**Goal**: explain approach from n^4 to n^3 to n^2\\n\\n**n^4**\\n- we start creating a rectangle at any given point in matrix -> o(n^2)\\n- so at this given point we check each row below it and see if the # of consecutive \\'1\\'s in each row gives us a new `minWidth` to consider\\n- then update `maxArea` according to this `minWidth`\\n- this approach has ideas similar to max stock price profit problem\\n```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):\\n        maxVal = 0\\n        out = 0\\n        minWidth = defaultdict(int)\\n        for i in range(len(matrix)-1,-1,-1):\\n            for j in range(len(matrix[0])-1, -1, -1):\\n                minW = len(matrix[0])-j\\n                maxArea = 0\\n                for di in range(i, len(matrix)):\\n                    currW = len(matrix[0])-j\\n                    for dj in range(j,len(matrix[0])):\\n                        if matrix[di][dj] != \"1\":\\n                            currW=dj-j\\n                            break\\n                    minW = min(minW, currW)\\n                    maxArea = max(maxArea, (di-i+1)*minW)\\n                out = max(out, maxArea)\\n        return out\\n```\\n\\n**n^3**\\n- we can preprocess the `minWidth` beforehand\\n- if the `matrix[i][j+1]` is \"1\" and `matrix[i][j]` is \\'1\\' then just add `minWidth[i][j+1] + 1` to `matrix[i][j]` else it remains 0\\n```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):        \\n        maxVal = 0\\n        out = 0\\n        minWidth = defaultdict(int)\\n        for di in range(len(matrix)):\\n            currW = len(matrix[0])\\n            for dj in range(len(matrix[0])-1, -1, -1):\\n                if matrix[di][dj] != \"1\":\\n                    minWidth[(di,dj)] = 0\\n                else:\\n                    minWidth[(di,dj)] = 1\\n                    minWidth[(di,dj)] += minWidth[(di,dj+1)] if dj+1!=len(matrix[0]) else 0\\n\\n        \\n        for i in range(len(matrix)-1,-1,-1):\\n            for j in range(len(matrix[0])-1, -1, -1):\\n                minW = len(matrix[0])-j\\n                maxArea = 0\\n                for di in range(i, len(matrix)):\\n                    minW = min(minW, minWidth[(di,j)])\\n                    maxArea = max(maxArea, (di-i+1)*minW)\\n                out = max(out, maxArea)\\n        return out\\n```\\n\\n**n^2**\\n- the last optimization to consider is that instead of using the o(1) extra space `maxArea`, we can use o(n) extra space with `maxLeft`, `maxRight`, and `stack` to do one less loop\\n- we consider that at each column `j`:\\n- one row\\'s `maxWidth[i][j]` to be the max width\\n\\t- that means anything greater than this can still be considered in the rectangle\\'s area\\n\\t- anything less than this will bound the rectangle we\\'re considering\\n\\t- area = `minWidth[i][j]` * distance btwn the two bounding rows\\n- this operation can be implemented using the `stack` data structure\\n- this approach is very similar to the largest rectangle in histogram problem\\n```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):\\n        maxVal = 0\\n        out = 0\\n        if matrix==[]:\\n            return 0\\n        minWidth = defaultdict(lambda: defaultdict(int))\\n        for di in range(len(matrix)):\\n            currW = len(matrix[0])\\n            for dj in range(len(matrix[0])-1, -1, -1):\\n                if matrix[di][dj] != \"1\":\\n                    minWidth[di][dj] = 0\\n                else:\\n                    minWidth[di][dj] = 1\\n                    minWidth[di][dj] += minWidth[di][dj+1] if dj+1!=len(matrix[0]) else 0\\n\\t\\t\\t\\t\\t\\n        maxArea = 0\\n        for j in range(len(matrix[0])):\\n            maxLeft = [-1]*len(matrix)\\n            maxRight = [len(matrix)]*len(matrix)\\n            stack = []\\n            for i in range(len(matrix)):\\n                while stack and minWidth[i][j] < minWidth[stack[-1]][j]:\\n                    maxRight[stack.pop()] = i\\n                maxLeft[i] = stack[-1] if stack else -1\\n                stack.append(i)\\n            area = [(maxRight[i] - maxLeft[i] - 1)*minWidth[i][j] for i in range(len(matrix))]\\n            maxArea = max(maxArea, max(area))\\n        return maxArea\\n```    \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):\\n        maxVal = 0\\n        out = 0\\n        minWidth = defaultdict(int)\\n        for i in range(len(matrix)-1,-1,-1):\\n            for j in range(len(matrix[0])-1, -1, -1):\\n                minW = len(matrix[0])-j\\n                maxArea = 0\\n                for di in range(i, len(matrix)):\\n                    currW = len(matrix[0])-j\\n                    for dj in range(j,len(matrix[0])):\\n                        if matrix[di][dj] != \"1\":\\n                            currW=dj-j\\n                            break\\n                    minW = min(minW, currW)\\n                    maxArea = max(maxArea, (di-i+1)*minW)\\n                out = max(out, maxArea)\\n        return out\\n```\n```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):        \\n        maxVal = 0\\n        out = 0\\n        minWidth = defaultdict(int)\\n        for di in range(len(matrix)):\\n            currW = len(matrix[0])\\n            for dj in range(len(matrix[0])-1, -1, -1):\\n                if matrix[di][dj] != \"1\":\\n                    minWidth[(di,dj)] = 0\\n                else:\\n                    minWidth[(di,dj)] = 1\\n                    minWidth[(di,dj)] += minWidth[(di,dj+1)] if dj+1!=len(matrix[0]) else 0\\n\\n        \\n        for i in range(len(matrix)-1,-1,-1):\\n            for j in range(len(matrix[0])-1, -1, -1):\\n                minW = len(matrix[0])-j\\n                maxArea = 0\\n                for di in range(i, len(matrix)):\\n                    minW = min(minW, minWidth[(di,j)])\\n                    maxArea = max(maxArea, (di-i+1)*minW)\\n                out = max(out, maxArea)\\n        return out\\n```\n```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):\\n        maxVal = 0\\n        out = 0\\n        if matrix==[]:\\n            return 0\\n        minWidth = defaultdict(lambda: defaultdict(int))\\n        for di in range(len(matrix)):\\n            currW = len(matrix[0])\\n            for dj in range(len(matrix[0])-1, -1, -1):\\n                if matrix[di][dj] != \"1\":\\n                    minWidth[di][dj] = 0\\n                else:\\n                    minWidth[di][dj] = 1\\n                    minWidth[di][dj] += minWidth[di][dj+1] if dj+1!=len(matrix[0]) else 0\\n\\t\\t\\t\\t\\t\\n        maxArea = 0\\n        for j in range(len(matrix[0])):\\n            maxLeft = [-1]*len(matrix)\\n            maxRight = [len(matrix)]*len(matrix)\\n            stack = []\\n            for i in range(len(matrix)):\\n                while stack and minWidth[i][j] < minWidth[stack[-1]][j]:\\n                    maxRight[stack.pop()] = i\\n                maxLeft[i] = stack[-1] if stack else -1\\n                stack.append(i)\\n            area = [(maxRight[i] - maxLeft[i] - 1)*minWidth[i][j] for i in range(len(matrix))]\\n            maxArea = max(maxArea, max(area))\\n        return maxArea\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481047,
                "title": "based-on-largest-rectangle-in-histogram",
                "content": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n    \\n        \\n    int[] left = new int[heights.length]; \\n    int[] right = new int[heights.length];\\n    int[] width = new int[heights.length];\\n    Stack<Integer> stack = new Stack();\\n        \\n        \\n       //width --- left\\n        for(int i=0;i<heights.length;i++){\\n            \\n            while(!stack.isEmpty() && heights[i]<=heights[stack.peek()]){\\n                stack.pop();\\n            }\\n            \\n            if(stack.isEmpty()){\\n                left[i] = -1;\\n            }else{\\n                left[i] = stack.peek();\\n            }\\n            \\n            stack.add(i);\\n        }\\n        stack.clear();\\n        //width --- right\\n        for(int i=heights.length-1;i>=0;i--){\\n            \\n            while(!stack.isEmpty() && heights[i]<=heights[stack.peek()]){\\n                stack.pop();\\n            }\\n            \\n            if(stack.isEmpty()){\\n                right[i] = heights.length;\\n            }else{\\n                right[i] = stack.peek();\\n            }\\n            \\n            stack.add(i);\\n        }\\n        \\n        int area = 0;\\n        \\n         for(int i=0;i<heights.length;i++){\\n            width[i] = right[i]-left[i]-1;\\n            area = Math.max(heights[i]* width[i] ,area);\\n         }\\n        \\n        return area;\\n    }\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        // for each cell with value=1, we look upward (north), the number of continuous \\'1\\' is the height of cell\\n        int[] heights = new int[matrix[0].length];\\n        int maxArea=-1;\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j]==\\'0\\'){\\n                    heights[j] = 0;\\n                } else {\\n                    heights[j] ++;\\n                }\\n            }            \\n            int area = largestRectangleArea(heights);\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n    \\n        \\n    int[] left = new int[heights.length]; \\n    int[] right = new int[heights.length];\\n    int[] width = new int[heights.length];\\n    Stack<Integer> stack = new Stack();\\n        \\n        \\n       //width --- left\\n        for(int i=0;i<heights.length;i++){\\n            \\n            while(!stack.isEmpty() && heights[i]<=heights[stack.peek()]){\\n                stack.pop();\\n            }\\n            \\n            if(stack.isEmpty()){\\n                left[i] = -1;\\n            }else{\\n                left[i] = stack.peek();\\n            }\\n            \\n            stack.add(i);\\n        }\\n        stack.clear();\\n        //width --- right\\n        for(int i=heights.length-1;i>=0;i--){\\n            \\n            while(!stack.isEmpty() && heights[i]<=heights[stack.peek()]){\\n                stack.pop();\\n            }\\n            \\n            if(stack.isEmpty()){\\n                right[i] = heights.length;\\n            }else{\\n                right[i] = stack.peek();\\n            }\\n            \\n            stack.add(i);\\n        }\\n        \\n        int area = 0;\\n        \\n         for(int i=0;i<heights.length;i++){\\n            width[i] = right[i]-left[i]-1;\\n            area = Math.max(heights[i]* width[i] ,area);\\n         }\\n        \\n        return area;\\n    }\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        // for each cell with value=1, we look upward (north), the number of continuous \\'1\\' is the height of cell\\n        int[] heights = new int[matrix[0].length];\\n        int maxArea=-1;\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j]==\\'0\\'){\\n                    heights[j] = 0;\\n                } else {\\n                    heights[j] ++;\\n                }\\n            }            \\n            int area = largestRectangleArea(heights);\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374213,
                "title": "c-dp",
                "content": "```\\n\\n```public:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int i,j,k,n,m,minn,res=0;\\n        n=matrix.size();\\n        if(n==0)\\n        {\\n            return 0;\\n        }\\n        m=matrix[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        for(i=0;i<n;i++)\\n        {\\n            dp[i][m-1]=(int)matrix[i][m-1]-\\'0\\';\\n            for(j=m-2;j>=0;j--)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    dp[i][j]=dp[i][j+1]+1;\\n                }\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                k=i;\\n                minn=dp[i][j];\\n                while(k<n&&dp[k][j])\\n                {\\n                    minn=min(minn,dp[k][j]);\\n                    res=max(res,minn*(k-i+1));\\n                    k++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1304139,
                "title": "python-o-row-col-using-histogram",
                "content": "![image](https://assets.leetcode.com/users/images/cf0c802f-690c-4c93-a4bb-8f2c10e032c9_1624947641.2761607.jpeg)\\n\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        row=len(matrix)\\n        col=len(matrix[0])\\n        histograms=[[0]*col for _ in range(row)]\\n        for i in range(row):\\n            for j in range(col):\\n                if i==0:\\n                    histograms[i][j]=int(matrix[i][j])\\n                else:\\n                    if int(matrix[i][j])==0:\\n                        histograms[i][j]=0\\n                    else:\\n                        histograms[i][j]=histograms[i-1][j]+int(matrix[i][j])\\n        def maxArea(arr):\\n            stack=[]\\n            i=0\\n            Max=0\\n            while i<len(arr):\\n                if not stack or arr[i]>=arr[stack[-1]]:\\n                    stack.append(i)\\n                    i+=1\\n                else:\\n                    a=stack.pop()\\n                    area=arr[a]*((i-stack[-1]-1) if stack else i)\\n                    Max=max(area,Max)\\n            pre=stack[-1]\\n            while stack:\\n                a=stack.pop()\\n                area=arr[a]*((pre-stack[-1]) if stack else pre+1)\\n                Max=max(area,Max)\\n            return Max\\n        k=0\\n        for i in histograms:\\n            k=max(k,maxArea(i))\\n        return k\\n                    \\n                    \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        row=len(matrix)\\n        col=len(matrix[0])\\n        histograms=[[0]*col for _ in range(row)]\\n        for i in range(row):\\n            for j in range(col):\\n                if i==0:\\n                    histograms[i][j]=int(matrix[i][j])\\n                else:\\n                    if int(matrix[i][j])==0:\\n                        histograms[i][j]=0\\n                    else:\\n                        histograms[i][j]=histograms[i-1][j]+int(matrix[i][j])\\n        def maxArea(arr):\\n            stack=[]\\n            i=0\\n            Max=0\\n            while i<len(arr):\\n                if not stack or arr[i]>=arr[stack[-1]]:\\n                    stack.append(i)\\n                    i+=1\\n                else:\\n                    a=stack.pop()\\n                    area=arr[a]*((i-stack[-1]-1) if stack else i)\\n                    Max=max(area,Max)\\n            pre=stack[-1]\\n            while stack:\\n                a=stack.pop()\\n                area=arr[a]*((pre-stack[-1]) if stack else pre+1)\\n                Max=max(area,Max)\\n            return Max\\n        k=0\\n        for i in histograms:\\n            k=max(k,maxArea(i))\\n        return k\\n                    \\n                    \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243824,
                "title": "largest-histogram-bottom-up-filling-o-n-2-solution",
                "content": "\\nBased on Largest area rectangle in  Histogram ...\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int hist(vector<int> &height){\\n        \\n        if(height.size()==0){return 0;}\\n        if(height.size()==1){return height[0];}\\n        int ans=0;\\n        stack<int> s;\\n        for(int i=0;i<height.size();i++){\\n            if(s.empty()||height[i]>=height[s.top()]){\\n                s.push(i);\\n            }\\n            else {\\n                int temp=s.top();\\n                s.pop();\\n                if(s.empty()){\\n                    ans=max(ans,height[temp]*i);\\n                }\\n                else{\\n                    ans=max(ans,height[temp]*(i-s.top()-1));\\n                }\\n                i--;\\n            }\\n        }\\n        int i=height.size();\\n        while(!s.empty()){\\n            int temp=s.top();\\n                s.pop();\\n                if(s.empty()){\\n                    ans=max(ans,height[temp]*i);\\n                }\\n                else{\\n                    ans=max(ans,height[temp]*(i-s.top()-1));\\n                }\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.size()==0){return 0;}\\n        vector<vector<int>> heights(matrix.size(),vector<int> (matrix[0].size(),0));\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            heights[i][matrix[i].size()-1]= matrix[i][matrix[i].size()-1]==\\'0\\'?0:1;\\n            \\n            for(int j=matrix[i].size()-2;j>=0;j--){\\n                if(matrix[i][j]==\\'0\\'){heights[i][j]=0;}\\n                else{\\n                    heights[i][j]=heights[i][j+1]+1;\\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n      \\n        for(int j=0;j<matrix[0].size();j++){\\n            vector<int> temp;\\n              int mini =INT_MAX;\\n            for(int i=0;i<matrix.size();i++){\\n                mini=min(mini,heights[i][j]);\\n                temp.push_back(heights[i][j]);\\n            }\\n            ans=max(ans,hist(temp));\\n            j+=mini;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int hist(vector<int> &height){\\n        \\n        if(height.size()==0){return 0;}\\n        if(height.size()==1){return height[0];}\\n        int ans=0;\\n        stack<int> s;\\n        for(int i=0;i<height.size();i++){\\n            if(s.empty()||height[i]>=height[s.top()]){\\n                s.push(i);\\n            }\\n            else {\\n                int temp=s.top();\\n                s.pop();\\n                if(s.empty()){\\n                    ans=max(ans,height[temp]*i);\\n                }\\n                else{\\n                    ans=max(ans,height[temp]*(i-s.top()-1));\\n                }\\n                i--;\\n            }\\n        }\\n        int i=height.size();\\n        while(!s.empty()){\\n            int temp=s.top();\\n                s.pop();\\n                if(s.empty()){\\n                    ans=max(ans,height[temp]*i);\\n                }\\n                else{\\n                    ans=max(ans,height[temp]*(i-s.top()-1));\\n                }\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.size()==0){return 0;}\\n        vector<vector<int>> heights(matrix.size(),vector<int> (matrix[0].size(),0));\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            heights[i][matrix[i].size()-1]= matrix[i][matrix[i].size()-1]==\\'0\\'?0:1;\\n            \\n            for(int j=matrix[i].size()-2;j>=0;j--){\\n                if(matrix[i][j]==\\'0\\'){heights[i][j]=0;}\\n                else{\\n                    heights[i][j]=heights[i][j+1]+1;\\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n      \\n        for(int j=0;j<matrix[0].size();j++){\\n            vector<int> temp;\\n              int mini =INT_MAX;\\n            for(int i=0;i<matrix.size();i++){\\n                mini=min(mini,heights[i][j]);\\n                temp.push_back(heights[i][j]);\\n            }\\n            ans=max(ans,hist(temp));\\n            j+=mini;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801801,
                "title": "java-stack-o-n-m-time-largest-area-in-histogram",
                "content": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] M) {\\n    \\n         int m = M.length;\\n        if( m == 0) return 0;\\n        int n = M[0].length;\\n        int ans  = 0;\\n        int a[] = new int[n];\\n        \\n        for(int i = 0;i<n;i++)\\n            a[i] = M[0][i]-\\'0\\';\\n            \\n        for(int i = 0;i<m;i++){\\n            if( i == 0){\\n                \\n                ans = Math.max(ans, maximumAreaInHistogram(a));\\n                continue;\\n            }\\n            \\n            for(int j = 0; j<n;j++){\\n                a[j] += M[i][j]-\\'0\\' ;\\n                if( M[i][j] == \\'0\\')\\n                    a[j] = 0;\\n            }    \\n            \\n            \\n            ans = Math.max(ans, maximumAreaInHistogram(a));\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n    \\n    \\n    \\n   int maximumAreaInHistogram(int h[]){\\n        \\n        int n = h.length;\\n        \\n        Stack<Integer> st = new Stack();\\n        \\n        int l[] = new int[n];\\n        int r[] = new int[n];\\n        \\n        \\n        for(int i = 0;i<n;i++){\\n            if( st.isEmpty()){\\n                l[i] = -1;\\n                st.push(i);\\n                continue;\\n            }\\n            \\n            while( !st.isEmpty() && h[st.peek()] >= h[i]  ){\\n                st.pop();\\n                \\n            }\\n            \\n            int p = st.isEmpty() ? -1 : st.peek() ;\\n            \\n            l[i] = p;\\n            st.push(i);\\n\\n        }\\n        \\n        st.clear();\\n        \\n        for(int i = n-1; i>=0; i--){\\n            if( st.isEmpty()){\\n                r[i] = n;\\n                st.push(i);\\n                continue;\\n            }\\n            \\n            while( !st.isEmpty() && h[st.peek()] >= h[i]  ){\\n                st.pop();\\n                \\n            }\\n            \\n            int p = st.isEmpty() ? n : st.peek() ;\\n            \\n            r[i] = p;\\n            st.push(i);\\n\\n        }\\n        \\n        \\n        \\n        int m = 0;\\n        \\n        for(int i = 0;i<n;i++){\\n            m = Math.max(m, h[i]*(r[i]-l[i]-1) );\\n        }\\n        \\n        \\n        return m;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] M) {\\n    \\n         int m = M.length;\\n        if( m == 0) return 0;\\n        int n = M[0].length;\\n        int ans  = 0;\\n        int a[] = new int[n];\\n        \\n        for(int i = 0;i<n;i++)\\n            a[i] = M[0][i]-\\'0\\';\\n            \\n        for(int i = 0;i<m;i++){\\n            if( i == 0){\\n                \\n                ans = Math.max(ans, maximumAreaInHistogram(a));\\n                continue;\\n            }\\n            \\n            for(int j = 0; j<n;j++){\\n                a[j] += M[i][j]-\\'0\\' ;\\n                if( M[i][j] == \\'0\\')\\n                    a[j] = 0;\\n            }    \\n            \\n            \\n            ans = Math.max(ans, maximumAreaInHistogram(a));\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n    \\n    \\n    \\n   int maximumAreaInHistogram(int h[]){\\n        \\n        int n = h.length;\\n        \\n        Stack<Integer> st = new Stack();\\n        \\n        int l[] = new int[n];\\n        int r[] = new int[n];\\n        \\n        \\n        for(int i = 0;i<n;i++){\\n            if( st.isEmpty()){\\n                l[i] = -1;\\n                st.push(i);\\n                continue;\\n            }\\n            \\n            while( !st.isEmpty() && h[st.peek()] >= h[i]  ){\\n                st.pop();\\n                \\n            }\\n            \\n            int p = st.isEmpty() ? -1 : st.peek() ;\\n            \\n            l[i] = p;\\n            st.push(i);\\n\\n        }\\n        \\n        st.clear();\\n        \\n        for(int i = n-1; i>=0; i--){\\n            if( st.isEmpty()){\\n                r[i] = n;\\n                st.push(i);\\n                continue;\\n            }\\n            \\n            while( !st.isEmpty() && h[st.peek()] >= h[i]  ){\\n                st.pop();\\n                \\n            }\\n            \\n            int p = st.isEmpty() ? n : st.peek() ;\\n            \\n            r[i] = p;\\n            st.push(i);\\n\\n        }\\n        \\n        \\n        \\n        int m = 0;\\n        \\n        for(int i = 0;i<n;i++){\\n            m = Math.max(m, h[i]*(r[i]-l[i]-1) );\\n        }\\n        \\n        \\n        return m;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657433,
                "title": "detailed-explanation-code-video-with-best-time-complexity",
                "content": "Please refer this video for detailed explanation - \\n[https://www.youtube.com/watch?v=Q39oYu4p9gY]\\n\\n\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length == 0)\\n            return 0;\\n        int max = 0;\\n        int[] height = new int[matrix[0].length];\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j] == \\'0\\'){\\n                    height[j] = 0;\\n                } else {\\n                    height[j]+=1;\\n                }\\n            }\\n            max = Math.max(max, findTheArea(height));\\n        }\\n        return max;\\n    }\\n    \\n    public int findTheArea(int[] h){\\n        int max = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.add(0);\\n        for(int i=1; i<h.length; i++){\\n            int curr = h[i];\\n            if(stack.isEmpty() || curr >= h[stack.peek()]){\\n                stack.add(i);\\n            } else {\\n                while(!stack.isEmpty() && curr < h[stack.peek()]){\\n                    int temp = h[stack.pop()];\\n                    if(stack.isEmpty()){\\n                        max = Math.max(max, temp*i);\\n                    } else {\\n                        max = Math.max(max, temp*(i-stack.peek()-1));\\n                    }\\n                }\\n                stack.add(i);\\n            }\\n        }\\n        \\n        if(!stack.isEmpty()){\\n             while(!stack.isEmpty()){\\n                    int i = h.length;\\n                    int temp = h[stack.pop()];\\n                    if(stack.isEmpty()){\\n                        max = Math.max(max, temp*i);\\n                    } else {\\n                        max = Math.max(max, temp*(i-stack.peek()-1));\\n                    }\\n                }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length == 0)\\n            return 0;\\n        int max = 0;\\n        int[] height = new int[matrix[0].length];\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j] == \\'0\\'){\\n                    height[j] = 0;\\n                } else {\\n                    height[j]+=1;\\n                }\\n            }\\n            max = Math.max(max, findTheArea(height));\\n        }\\n        return max;\\n    }\\n    \\n    public int findTheArea(int[] h){\\n        int max = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.add(0);\\n        for(int i=1; i<h.length; i++){\\n            int curr = h[i];\\n            if(stack.isEmpty() || curr >= h[stack.peek()]){\\n                stack.add(i);\\n            } else {\\n                while(!stack.isEmpty() && curr < h[stack.peek()]){\\n                    int temp = h[stack.pop()];\\n                    if(stack.isEmpty()){\\n                        max = Math.max(max, temp*i);\\n                    } else {\\n                        max = Math.max(max, temp*(i-stack.peek()-1));\\n                    }\\n                }\\n                stack.add(i);\\n            }\\n        }\\n        \\n        if(!stack.isEmpty()){\\n             while(!stack.isEmpty()){\\n                    int i = h.length;\\n                    int temp = h[stack.pop()];\\n                    if(stack.isEmpty()){\\n                        max = Math.max(max, temp*i);\\n                    } else {\\n                        max = Math.max(max, temp*(i-stack.peek()-1));\\n                    }\\n                }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222391,
                "title": "reuse-code-from-problem-84-largest-rectangle-in-histogram",
                "content": "![image](https://assets.leetcode.com/users/goldsail/image_1547999243.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        if (matrix.empty() || matrix[0].empty()) return 0;\\n        \\n        // To ensure all 1\\'s in the monotonic stacks can be popped, insert 0\\'s at the back of each row.\\n        for (int i = 0; i < matrix.size(); i++) {\\n            matrix[i].push_back(\\'0\\');\\n        }\\n        \\n        // First, for each row,\\n        // obtain the number of consecutive 1\\'s on the right side of each element using a monotonic stack.\\n        // These numbers (stored in nums) form a histogram for each column\\n        \\n        vector<vector<int>> nums = vector<vector<int>>(matrix.size(), vector<int>(matrix[0].size()));\\n        \\n        for (int i = 0; i < matrix.size(); i++) {\\n            stack<int> monoStack;\\n            for (int j = 0; j < matrix[0].size(); j++) {\\n                while (!monoStack.empty() && matrix[i][monoStack.top()] > matrix[i][j]) {\\n                    nums[i][monoStack.top()] = j - monoStack.top();\\n                    monoStack.pop();\\n                }\\n                monoStack.push(j);\\n            }\\n        }\\n        \\n        // Second, for each column,\\n        // solve the maximal rectangle in the histogram using the idea of Problem 84 (largest rectangle in histogram)\\n        \\n        int result = 0;\\n        for (int j = 0; j < matrix[0].size(); j++) {\\n            vector<int> column = vector<int>(nums.size());\\n            for (int i = 0; i < matrix.size(); i++) {\\n                column[i] = nums[i][j];\\n            }\\n            \\n            SolutionProblem84 solve;\\n            int area = solve.largestRectangleArea(column);\\n            result = max(result, area);\\n        }\\n        return result;\\n    }\\n    \\nprivate:\\n    static int max(int a, int b) {\\n        return a > b ? a : b;\\n    }\\n    \\n    class SolutionProblem84 {\\n    public:\\n        int largestRectangleArea(vector<int>& heights) {\\n\\n            // Claim: The area of largest rectangle starting from index i depends on next[i] and prev[i], where\\n            // next[i] is the index of the next element smaller than heights[i], and\\n            // prev[i] is the index of the last element smaller than heights[i].\\n            // Initially, set next[i] = heights.size() as we do not know where the next smaller element is.\\n            // Initially, set prev[i] = -1 as we do not know where the last smaller element is.\\n            vector<int> next = vector<int>(heights.size(), heights.size());\\n            vector<int> prev = vector<int>(heights.size(), -1);\\n\\n            // We maintain a monotonic stack which stores indices of which the heights ascend from bottom to top.\\n            stack<int> monoStack;\\n\\n            // First, scan from left to right. \\n            // Update next[j] when j is popped from the monotonic stack, indicating a \"next smaller element\".\\n            monoStack = stack<int>();\\n            for (int i = 0; i < heights.size(); i++) {\\n                while (!monoStack.empty() && heights[monoStack.top()] > heights[i]) {\\n                    next[monoStack.top()] = i;\\n                    monoStack.pop();\\n                }\\n                monoStack.push(i);\\n            }\\n\\n            // Second, scan from right to left. \\n            // Update prev[j] when j is popped from the monotonic stack, indicating a \"last smaller element\".\\n            monoStack = stack<int>();\\n            for (int i = heights.size() - 1; i >= 0; i--) {\\n                while (!monoStack.empty() && heights[monoStack.top()] > heights[i]) {\\n                    prev[monoStack.top()] = i;\\n                    monoStack.pop();\\n                }\\n                monoStack.push(i);\\n            }\\n\\n            // Then, using next[i] and prev[i], calculate the area of the largest rectangle starting from index i\\n            int result = 0;\\n            for (int i = 0; i < heights.size(); i++) {\\n                int area = heights[i] * (next[i] - prev[i] - 1);\\n                result = max(result, area);\\n            }\\n            return result;\\n        }\\n\\n    private:\\n        static int min(int a, int b) {\\n            return a < b ? a : b;\\n        }\\n\\n        static int max(int a, int b) {\\n            return a > b ? a : b;\\n        }\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        if (matrix.empty() || matrix[0].empty()) return 0;\\n        \\n        // To ensure all 1\\'s in the monotonic stacks can be popped, insert 0\\'s at the back of each row.\\n        for (int i = 0; i < matrix.size(); i++) {\\n            matrix[i].push_back(\\'0\\');\\n        }\\n        \\n        // First, for each row,\\n        // obtain the number of consecutive 1\\'s on the right side of each element using a monotonic stack.\\n        // These numbers (stored in nums) form a histogram for each column\\n        \\n        vector<vector<int>> nums = vector<vector<int>>(matrix.size(), vector<int>(matrix[0].size()));\\n        \\n        for (int i = 0; i < matrix.size(); i++) {\\n            stack<int> monoStack;\\n            for (int j = 0; j < matrix[0].size(); j++) {\\n                while (!monoStack.empty() && matrix[i][monoStack.top()] > matrix[i][j]) {\\n                    nums[i][monoStack.top()] = j - monoStack.top();\\n                    monoStack.pop();\\n                }\\n                monoStack.push(j);\\n            }\\n        }\\n        \\n        // Second, for each column,\\n        // solve the maximal rectangle in the histogram using the idea of Problem 84 (largest rectangle in histogram)\\n        \\n        int result = 0;\\n        for (int j = 0; j < matrix[0].size(); j++) {\\n            vector<int> column = vector<int>(nums.size());\\n            for (int i = 0; i < matrix.size(); i++) {\\n                column[i] = nums[i][j];\\n            }\\n            \\n            SolutionProblem84 solve;\\n            int area = solve.largestRectangleArea(column);\\n            result = max(result, area);\\n        }\\n        return result;\\n    }\\n    \\nprivate:\\n    static int max(int a, int b) {\\n        return a > b ? a : b;\\n    }\\n    \\n    class SolutionProblem84 {\\n    public:\\n        int largestRectangleArea(vector<int>& heights) {\\n\\n            // Claim: The area of largest rectangle starting from index i depends on next[i] and prev[i], where\\n            // next[i] is the index of the next element smaller than heights[i], and\\n            // prev[i] is the index of the last element smaller than heights[i].\\n            // Initially, set next[i] = heights.size() as we do not know where the next smaller element is.\\n            // Initially, set prev[i] = -1 as we do not know where the last smaller element is.\\n            vector<int> next = vector<int>(heights.size(), heights.size());\\n            vector<int> prev = vector<int>(heights.size(), -1);\\n\\n            // We maintain a monotonic stack which stores indices of which the heights ascend from bottom to top.\\n            stack<int> monoStack;\\n\\n            // First, scan from left to right. \\n            // Update next[j] when j is popped from the monotonic stack, indicating a \"next smaller element\".\\n            monoStack = stack<int>();\\n            for (int i = 0; i < heights.size(); i++) {\\n                while (!monoStack.empty() && heights[monoStack.top()] > heights[i]) {\\n                    next[monoStack.top()] = i;\\n                    monoStack.pop();\\n                }\\n                monoStack.push(i);\\n            }\\n\\n            // Second, scan from right to left. \\n            // Update prev[j] when j is popped from the monotonic stack, indicating a \"last smaller element\".\\n            monoStack = stack<int>();\\n            for (int i = heights.size() - 1; i >= 0; i--) {\\n                while (!monoStack.empty() && heights[monoStack.top()] > heights[i]) {\\n                    prev[monoStack.top()] = i;\\n                    monoStack.pop();\\n                }\\n                monoStack.push(i);\\n            }\\n\\n            // Then, using next[i] and prev[i], calculate the area of the largest rectangle starting from index i\\n            int result = 0;\\n            for (int i = 0; i < heights.size(); i++) {\\n                int area = heights[i] * (next[i] - prev[i] - 1);\\n                result = max(result, area);\\n            }\\n            return result;\\n        }\\n\\n    private:\\n        static int min(int a, int b) {\\n            return a < b ? a : b;\\n        }\\n\\n        static int max(int a, int b) {\\n            return a > b ? a : b;\\n        }\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29061,
                "title": "simple-solution-beats-98-27-of-java-submissions",
                "content": "Height is calculated for every row and contains number of '1's in this column. \\n\\n```    \\npublic int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0) return 0;\\n        \\n        int col_nums = matrix[0].length;\\n        int height[] = new int[col_nums];\\n        int max_area = 0, area; \\n        for (int i=0; i< matrix.length;i++) {\\n            for(int j=0; j < col_nums; j++) {\\n                if (matrix[i][j] == '0') {\\n                    height[j] = 0;\\n                } else {\\n                    height[j] += 1;\\n                }\\n            }\\n\\n            for(int j=0;j<col_nums;j++) {\\n                if (height[j]==0) continue;\\n \\n                int left = 0, right = 0;\\n\\n                // Check how many columns to my left have same or more height as me\\n                for(int k=j-1;k>=0;k--) {\\n                    if (height[k]<height[j]) break;\\n                    left++;\\n                }\\n\\n                // Check how many columns to my right have same or more height as me\\n                for(int k=j+1;k<col_nums;k++) {\\n                    if (height[k]<height[j]) break;\\n                    right++;\\n                }\\n\\n                area = height[j]*(1+left+right);\\n                if (area > max_area) max_area = area;\\n            }\\n        }\\n\\n        return max_area;\\n    }\\n```",
                "solutionTags": [],
                "code": "```    \\npublic int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0) return 0;\\n        \\n        int col_nums = matrix[0].length;\\n        int height[] = new int[col_nums];\\n        int max_area = 0, area; \\n        for (int i=0; i< matrix.length;i++) {\\n            for(int j=0; j < col_nums; j++) {\\n                if (matrix[i][j] == '0') {\\n                    height[j] = 0;\\n                } else {\\n                    height[j] += 1;\\n                }\\n            }\\n\\n            for(int j=0;j<col_nums;j++) {\\n                if (height[j]==0) continue;\\n \\n                int left = 0, right = 0;\\n\\n                // Check how many columns to my left have same or more height as me\\n                for(int k=j-1;k>=0;k--) {\\n                    if (height[k]<height[j]) break;\\n                    left++;\\n                }\\n\\n                // Check how many columns to my right have same or more height as me\\n                for(int k=j+1;k<col_nums;k++) {\\n                    if (height[k]<height[j]) break;\\n                    right++;\\n                }\\n\\n                area = height[j]*(1+left+right);\\n                if (area > max_area) max_area = area;\\n            }\\n        }\\n\\n        return max_area;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29099,
                "title": "simple-java-solution-using-dp",
                "content": "```\\npublic class Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix==null||matrix.length==0) return 0;\\n        int m=matrix.length;int n=matrix[0].length;\\n        int[] left=new int[n];int[] right=new int[n];int[] height=new int[n];\\n        Arrays.fill(right,n);\\n        int max=0;\\n        for(int i=0;i<m;i++){\\n            int curleft=0;int curright=n;\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]=='1'){height[j]+=1;}\\n                else{height[j]=0;}\\n            }\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]=='1'){left[j]=Math.max(left[j],curleft);}\\n                else{left[j]=0;curleft=j+1;}\\n            }\\n            for(int j=n-1;j>=0;j--){\\n                if(matrix[i][j]=='1'){right[j]=Math.min(right[j],curright);}\\n                else{right[j]=n;curright=j;}\\n            }\\n            for(int j=0;j<n;j++){\\n                max=Math.max(max,(right[j]-left[j])*height[j]);\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix==null||matrix.length==0) return 0;\\n        int m=matrix.length;int n=matrix[0].length;\\n        int[] left=new int[n];int[] right=new int[n];int[] height=new int[n];\\n        Arrays.fill(right,n);\\n        int max=0;\\n        for(int i=0;i<m;i++){\\n            int curleft=0;int curright=n;\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]=='1'){height[j]+=1;}",
                "codeTag": "Java"
            },
            {
                "id": 29066,
                "title": "java-7ms-solution-beats-100-using-largest-rectangle-in-histogram-solved-by-stack-simulation",
                "content": "The idea is to use \\u3010Leetcode#84\\u3011(see below comments). \\n\\nAs for \\u3010LC84\\u3011, there are many fast O(n)/O(n)-time/space methods such as using a stack. Mine is to use an array nLeftGeq[] to simulate the stack so that it is faster than the default implement of stack. \\nIndeed, nLeftGeq[i] = the number of elements to the left of [i] having value greater than or equal to a[i] (including a[i] itself). \\n\\nSince for j < i, with a[j]>a[i], we can compute the largest rectangle area with base a[j] then we throw away [j] or pop() it from the stack. \\n\\nTherefore, nLeftGeq[i] is also = the index difference between [i] and the next index on the top of the stack. And thus such as peek(), pop() methods can be implemented by manipulating the array nLeftGeq[].\\n\\nThis sub-algorithm for \\u3010LC84\\u3011is not the fastest one unfortunately, but still beats 95.45%.\\n\\n    public int maximalRectangle(char[][] matrix) {\\n\\t\\t\\t/**\\n\\t\\t\\t * idea: using [LC84 Largest Rectangle in Histogram]. For each row\\n\\t\\t\\t * of the matrix, construct the histogram based on the current row\\n\\t\\t\\t * and the previous histogram (up to the previous row), then compute\\n\\t\\t\\t * the largest rectangle area using LC84.\\n\\t\\t\\t */\\n\\t\\t\\tint m = matrix.length, n;\\n\\t\\t\\tif (m == 0 || (n = matrix[0].length) == 0)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint i, j, res = 0;\\n\\t\\t\\tint[] heights = new int[n];\\n\\t\\t\\tfor (i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor (j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tif (matrix[i][j] == '0')\\n\\t\\t\\t\\t\\t\\theights[j] = 0;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\theights[j] += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres = Math.max(res, largestRectangleArea(heights));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic int largestRectangleArea(int[] heights) {\\n\\t\\t\\t/**\\n\\t\\t\\t * idea: scan and store if a[i-1]<=a[i] (increasing), then as long\\n\\t\\t\\t * as a[i]<a[i-1], then we can compute the largest rectangle area\\n\\t\\t\\t * with base a[j], for j<=i-1, and a[j]>a[i], which is a[j]*(i-j).\\n\\t\\t\\t * And meanwhile, all these bars (a[j]'s) are already done, and thus\\n\\t\\t\\t * are throwable (using pop() with a stack).\\n\\t\\t\\t * \\n\\t\\t\\t * We can use an array nLeftGeq[] of size n to simulate a stack.\\n\\t\\t\\t * nLeftGeq[i] = the number of elements to the left of [i] having\\n\\t\\t\\t * value greater than or equal to a[i] (including a[i] itself). It\\n\\t\\t\\t * is also the index difference between [i] and the next index on\\n\\t\\t\\t * the top of the stack.\\n\\t\\t\\t */\\n\\t\\t\\tint n = heights.length;\\n\\t\\t\\tif (n == 0)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint[] nLeftGeq = new int[n]; // the number of elements to the left\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// of [i] with value >= heights[i]\\n\\t\\t\\tnLeftGeq[0] = 1;\\n\\n\\t\\t\\t// preIdx=the index of stack.peek(), res=max area so far\\n\\t\\t\\tint preIdx = 0, res = 0;\\n\\n\\t\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t\\tnLeftGeq[i] = 1;\\n\\n\\t\\t\\t\\t// notice that preIdx = i - 1 = peek()\\n\\t\\t\\t\\twhile (preIdx >= 0 && heights[i] < heights[preIdx]) {\\n\\t\\t\\t\\t\\tres = Math.max(res, heights[preIdx] * (nLeftGeq[preIdx] + i - preIdx - 1));\\n\\t\\t\\t\\t\\tnLeftGeq[i] += nLeftGeq[preIdx]; // pop()\\n\\n\\t\\t\\t\\t\\tpreIdx = preIdx - nLeftGeq[preIdx]; // peek() current top\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (preIdx >= 0 && heights[i] == heights[preIdx])\\n\\t\\t\\t\\t\\tnLeftGeq[i] += nLeftGeq[preIdx]; // pop()\\n\\t\\t\\t\\t// otherwise nothing to do\\n\\n\\t\\t\\t\\tpreIdx = i;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// compute the rest largest rectangle areas with (indices of) bases\\n\\t\\t\\t// on stack\\n\\t\\t\\twhile (preIdx >= 0 && 0 < heights[preIdx]) {\\n\\t\\t\\t\\tres = Math.max(res, heights[preIdx] * (nLeftGeq[preIdx] + n - preIdx - 1));\\n\\t\\t\\t\\tpreIdx = preIdx - nLeftGeq[preIdx]; // peek() current top\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea is to use \\u3010Leetcode#84\\u3011(see below comments). \\n\\nAs for \\u3010LC84\\u3011, there are many fast O(n)/O(n)-time/space methods such as using a stack. Mine is to use an array nLeftGeq[] to simulate the stack so that it is faster than the default implement of stack. \\nIndeed, nLeftGeq[i] = the number of elements to the left of [i] having value greater than or equal to a[i] (including a[i] itself). \\n\\nSince for j < i, with a[j]>a[i], we can compute the largest rectangle area with base a[j] then we throw away [j] or pop() it from the stack. \\n\\nTherefore, nLeftGeq[i] is also = the index difference between [i] and the next index on the top of the stack. And thus such as peek(), pop() methods can be implemented by manipulating the array nLeftGeq[].\\n\\nThis sub-algorithm for \\u3010LC84\\u3011is not the fastest one unfortunately, but still beats 95.45%.\\n\\n    public int maximalRectangle(char[][] matrix) {\\n\\t\\t\\t/**\\n\\t\\t\\t * idea: using [LC84 Largest Rectangle in Histogram]. For each row\\n\\t\\t\\t * of the matrix, construct the histogram based on the current row\\n\\t\\t\\t * and the previous histogram (up to the previous row), then compute\\n\\t\\t\\t * the largest rectangle area using LC84.\\n\\t\\t\\t */\\n\\t\\t\\tint m = matrix.length, n;\\n\\t\\t\\tif (m == 0 || (n = matrix[0].length) == 0)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint i, j, res = 0;\\n\\t\\t\\tint[] heights = new int[n];\\n\\t\\t\\tfor (i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor (j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tif (matrix[i][j] == '0')\\n\\t\\t\\t\\t\\t\\theights[j] = 0;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\theights[j] += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres = Math.max(res, largestRectangleArea(heights));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic int largestRectangleArea(int[] heights) {\\n\\t\\t\\t/**\\n\\t\\t\\t * idea: scan and store if a[i-1]<=a[i] (increasing), then as long\\n\\t\\t\\t * as a[i]<a[i-1], then we can compute the largest rectangle area\\n\\t\\t\\t * with base a[j], for j<=i-1, and a[j]>a[i], which is a[j]*(i-j).\\n\\t\\t\\t * And meanwhile, all these bars (a[j]'s) are already done, and thus\\n\\t\\t\\t * are throwable (using pop() with a stack).\\n\\t\\t\\t * \\n\\t\\t\\t * We can use an array nLeftGeq[] of size n to simulate a stack.\\n\\t\\t\\t * nLeftGeq[i] = the number of elements to the left of [i] having\\n\\t\\t\\t * value greater than or equal to a[i] (including a[i] itself). It\\n\\t\\t\\t * is also the index difference between [i] and the next index on\\n\\t\\t\\t * the top of the stack.\\n\\t\\t\\t */\\n\\t\\t\\tint n = heights.length;\\n\\t\\t\\tif (n == 0)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint[] nLeftGeq = new int[n]; // the number of elements to the left\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// of [i] with value >= heights[i]\\n\\t\\t\\tnLeftGeq[0] = 1;\\n\\n\\t\\t\\t// preIdx=the index of stack.peek(), res=max area so far\\n\\t\\t\\tint preIdx = 0, res = 0;\\n\\n\\t\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t\\tnLeftGeq[i] = 1;\\n\\n\\t\\t\\t\\t// notice that preIdx = i - 1 = peek()\\n\\t\\t\\t\\twhile (preIdx >= 0 && heights[i] < heights[preIdx]) {\\n\\t\\t\\t\\t\\tres = Math.max(res, heights[preIdx] * (nLeftGeq[preIdx] + i - preIdx - 1));\\n\\t\\t\\t\\t\\tnLeftGeq[i] += nLeftGeq[preIdx]; // pop()\\n\\n\\t\\t\\t\\t\\tpreIdx = preIdx - nLeftGeq[preIdx]; // peek() current top\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (preIdx >= 0 && heights[i] == heights[preIdx])\\n\\t\\t\\t\\t\\tnLeftGeq[i] += nLeftGeq[preIdx]; // pop()\\n\\t\\t\\t\\t// otherwise nothing to do\\n\\n\\t\\t\\t\\tpreIdx = i;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// compute the rest largest rectangle areas with (indices of) bases\\n\\t\\t\\t// on stack\\n\\t\\t\\twhile (preIdx >= 0 && 0 < heights[preIdx]) {\\n\\t\\t\\t\\tres = Math.max(res, heights[preIdx] * (nLeftGeq[preIdx] + n - preIdx - 1));\\n\\t\\t\\t\\tpreIdx = preIdx - nLeftGeq[preIdx]; // peek() current top\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 29124,
                "title": "c-clear-dp-method",
                "content": "Learn from @morrischen2008\\n\\n\\nclass Solution {\\n\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n\\n        int m = matrix.size();\\n        if (m == 0) return 0;\\n        int n = matrix[0].size();\\n        \\n        vector<int> height (n, 0);\\n        vector<int> left (n, 0);\\n        vector<int> right (n, n - 1);\\n        \\n        int maxA = INT_MIN;\\n        for (int i = 0 ; i < m; ++i){\\n            int current_left = 0;\\n            int current_right = n - 1;\\n            for (int j = 0; j < n; ++j){\\n                if (matrix[i][j] == '0'){\\n                    height[j] = 0;\\n                }else{\\n                    height[j]++;\\n                }\\n            }\\n            for (int j = 0; j < n; ++j){\\n                if (matrix[i][j] == '0'){\\n                    left[j] = 0; \\n                    current_left = j + 1;\\n                }else{\\n                    left[j] = max(left[j], current_left);\\n                }\\n            } \\n            for (int j = n - 1; j >= 0; --j){\\n                if (matrix[i][j] == '0'){\\n                    right[j] = n - 1; \\n                    current_right = j - 1;\\n                }else{\\n                    right[j] = min(right[j], current_right);\\n                }\\n            }\\n            for (int j = 0; j < n; ++j){\\n                if (maxA < (right[j] - left[j] + 1) * height[j]){\\n                    maxA = (right[j] - left[j] + 1) * height[j];\\n                }\\n            }\\n        }\\n        return maxA;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n\\n        int m = matrix.size();\\n        if (m == 0) return 0;\\n        int n = matrix[0].size();\\n        \\n        vector<int> height (n, 0);\\n        vector<int> left (n, 0);\\n        vector<int> right (n, n - 1);\\n        \\n        int maxA = INT_MIN;\\n        for (int i = 0 ; i < m; ++i){\\n            int current_left = 0;\\n            int current_right = n - 1;\\n            for (int j = 0; j < n; ++j){\\n                if (matrix[i][j] == '0'){\\n                    height[j] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 29136,
                "title": "python-solution-using-maximum-histogram",
                "content": "First calculate the height for each row. Then convert this problem to finding the largest rectangle in histogram by computing the rectangle row by row and take the maximum.\\n\\n \\n    class Solution(object):\\n        def maximalRectangle(self, matrix):\\n            \"\"\"\\n            :type matrix: List[List[str]]\\n            :rtype: int\\n            \"\"\"\\n            if len(matrix) == 0: return 0\\n            for i in xrange(len(matrix)):\\n                for j in xrange(len(matrix[i])):\\n                    if i == 0: \\n                        matrix[i][j] = int(matrix[i][j])\\n                        continue\\n                    if matrix[i][j] == '1':\\n                        matrix[i][j] = matrix[i-1][j] + int(matrix[i][j])\\n                    else:\\n                        matrix[i][j] = 0\\n            return max([self.maxRectangle(row) for row in matrix])\\n            \\n        def maxRectangle(self, hist):\\n            stk = []\\n            maxx = 0\\n            hist.append(0)\\n            for i in xrange(len(hist)):\\n                while len(stk) > 0 and hist[i] < hist[stk[-1]]:\\n                    s = stk.pop()\\n                    if len(stk) == 0:\\n                        maxx = max(maxx, i*hist[s])\\n                    else:\\n                        maxx = max(maxx, (i - stk[-1] - 1)*hist[s])\\n                stk.append(i)\\n            return maxx",
                "solutionTags": [],
                "code": "First calculate the height for each row. Then convert this problem to finding the largest rectangle in histogram by computing the rectangle row by row and take the maximum.\\n\\n \\n    class Solution(object):\\n        def maximalRectangle(self, matrix):\\n            \"\"\"\\n            :type matrix: List[List[str]]\\n            :rtype: int\\n            \"\"\"\\n            if len(matrix) == 0: return 0\\n            for i in xrange(len(matrix)):\\n                for j in xrange(len(matrix[i])):\\n                    if i == 0: \\n                        matrix[i][j] = int(matrix[i][j])\\n                        continue\\n                    if matrix[i][j] == '1':\\n                        matrix[i][j] = matrix[i-1][j] + int(matrix[i][j])\\n                    else:\\n                        matrix[i][j] = 0\\n            return max([self.maxRectangle(row) for row in matrix])\\n            \\n        def maxRectangle(self, hist):\\n            stk = []\\n            maxx = 0\\n            hist.append(0)\\n            for i in xrange(len(hist)):\\n                while len(stk) > 0 and hist[i] < hist[stk[-1]]:\\n                    s = stk.pop()\\n                    if len(stk) == 0:\\n                        maxx = max(maxx, i*hist[s])\\n                    else:\\n                        maxx = max(maxx, (i - stk[-1] - 1)*hist[s])\\n                stk.append(i)\\n            return maxx",
                "codeTag": "Java"
            },
            {
                "id": 3544364,
                "title": "super-similar-problem-like-histogram",
                "content": "https://leetcode.com/problems/maximal-rectangle/discuss/3544364/Super-Similar-problem-like-Histogram-------------------------->Histogram problem\\n# Similar to Histogram Problem\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        maxarea=0\\n        height=[0]*(len(matrix[0]))\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j]==\"1\":\\n                    height[j]+=1\\n                else:\\n                    height[j]=0\\n\\t\\t\\t\\tstack=[]\\n            for i,h in enumerate(height):\\n                start=i\\n                while stack and h<stack[-1][1]:\\n                    index,hi=stack.pop()\\n                    start=index\\n                    maxarea=max(maxarea,(i-index)*hi)\\n                stack.append([start,h])\\n            for i,h in stack:\\n                maxarea=max(maxarea,(len(height)-i)*h)\\n        return maxarea\\n  ```\\n  # please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        maxarea=0\\n        height=[0]*(len(matrix[0]))\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j]==\"1\":\\n                    height[j]+=1\\n                else:\\n                    height[j]=0\\n\\t\\t\\t\\tstack=[]\\n            for i,h in enumerate(height):\\n                start=i\\n                while stack and h<stack[-1][1]:\\n                    index,hi=stack.pop()\\n                    start=index\\n                    maxarea=max(maxarea,(i-index)*hi)\\n                stack.append([start,h])\\n            for i,h in stack:\\n                maxarea=max(maxarea,(len(height)-i)*h)\\n        return maxarea\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 3010641,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    vector<int> nextsmall(vector<int>& arr,int n){\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            int c=arr[i];\\n            while(s.top()!=-1&&arr[s.top()]>=c)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> prevsmall(vector<int>& arr,int n){\\n         stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            int c=arr[i];\\n            while(s.top()!=-1&&arr[s.top()]>=c)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n     int large(vector<int>& height,int n){\\n        int area=INT_MIN;\\n        \\n        vector<int> prev(n);\\n        vector<int> next(n);\\n        prev=prevsmall(height,n);\\n        next=nextsmall(height,n);\\n        for(int i=0;i<n;i++){\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int l=height[i];\\n            int b=next[i]-prev[i]-1;\\n            int newarea=l*b;\\n            area=max(area,newarea);\\n        }\\n        return area;\\n    }\\npublic:\\n   int maximalRectangle(vector<vector<char> > &matrix) {\\n    if(matrix.empty()){\\n        return 0;\\n    }\\n    int maxRec = 0;\\n    vector<int> height(matrix[0].size(), 0);\\n    for(int i = 0; i < matrix.size(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            if(matrix[i][j] == \\'0\\'){\\n                height[j] = 0;\\n            }\\n            else{\\n                height[j]++;\\n            }\\n        }\\n        maxRec = max(maxRec, large(height,matrix[0].size()));\\n    }\\n    return maxRec;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> nextsmall(vector<int>& arr,int n){\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            int c=arr[i];\\n            while(s.top()!=-1&&arr[s.top()]>=c)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> prevsmall(vector<int>& arr,int n){\\n         stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            int c=arr[i];\\n            while(s.top()!=-1&&arr[s.top()]>=c)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n     int large(vector<int>& height,int n){\\n        int area=INT_MIN;\\n        \\n        vector<int> prev(n);\\n        vector<int> next(n);\\n        prev=prevsmall(height,n);\\n        next=nextsmall(height,n);\\n        for(int i=0;i<n;i++){\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int l=height[i];\\n            int b=next[i]-prev[i]-1;\\n            int newarea=l*b;\\n            area=max(area,newarea);\\n        }\\n        return area;\\n    }\\npublic:\\n   int maximalRectangle(vector<vector<char> > &matrix) {\\n    if(matrix.empty()){\\n        return 0;\\n    }\\n    int maxRec = 0;\\n    vector<int> height(matrix[0].size(), 0);\\n    for(int i = 0; i < matrix.size(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            if(matrix[i][j] == \\'0\\'){\\n                height[j] = 0;\\n            }\\n            else{\\n                height[j]++;\\n            }\\n        }\\n        maxRec = max(maxRec, large(height,matrix[0].size()));\\n    }\\n    return maxRec;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630546,
                "title": "maximal-rectangle-most-clean-code",
                "content": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        int row = matrix.length;\\n        int column = matrix[0].length;\\n        \\n        if (matrix == null || row == 0) return 0;\\n        \\n        int maxArea = Integer.MIN_VALUE;\\n        \\n        int []arr = new int[column];\\n        \\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < column; j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    arr[j] = arr[j] + 1;\\n                } else {\\n                    arr[j] = 0;\\n                }\\n            }\\n            int currArea = getMaxArea(arr, column);\\n            maxArea = Math.max(maxArea, currArea);\\n        }\\n        return maxArea;\\n    }\\n    \\n    public int getMaxArea(int []arr, int len) {\\n        \\n        int pse[] = getPreviousSmall(arr, len);\\n        int nse[] = getNextSmall(arr, len);\\n        \\n        int maxArea = Integer.MIN_VALUE;\\n        \\n        for (int k = 0; k < len; k++) {\\n            int currArea = (nse[k] - pse[k] - 1) * arr[k];\\n            maxArea = Math.max(maxArea, currArea);\\n        }\\n        \\n        return maxArea;\\n    }\\n    \\n    public int[] getPreviousSmall(int []arr, int len) {\\n        \\n        Stack<Integer> s = new Stack<>();\\n        s.push(0);\\n        \\n        int pse[] = new int[len];\\n        pse[0] = -1;\\n        \\n        for (int i = 1; i < len; i++) {\\n            while(!s.isEmpty() && arr[s.peek()] >= arr[i]) {\\n                s.pop();\\n            }\\n            \\n            if (s.isEmpty()) {\\n                pse[i] = -1;\\n            } else {\\n                pse[i] = s.peek();\\n            }\\n            s.push(i);\\n        }\\n        return pse;\\n    }\\n    \\n    public int[] getNextSmall(int []arr, int len) {\\n        \\n        Stack<Integer> s = new Stack<>();\\n        s.push(len - 1);\\n        \\n        int nse[] = new int[len];\\n        nse[len - 1] = len;\\n        \\n        for (int j = len - 2; j >= 0; j--) {\\n            while(!s.isEmpty() && arr[s.peek()] >= arr[j]) {\\n                s.pop();\\n            }\\n            \\n            if (s.isEmpty()) {\\n                nse[j] = len;\\n            } else {\\n                nse[j] = s.peek();\\n            }\\n            s.push(j);\\n        }\\n        return nse;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        int row = matrix.length;\\n        int column = matrix[0].length;\\n        \\n        if (matrix == null || row == 0) return 0;\\n        \\n        int maxArea = Integer.MIN_VALUE;\\n        \\n        int []arr = new int[column];\\n        \\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < column; j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    arr[j] = arr[j] + 1;\\n                } else {\\n                    arr[j] = 0;\\n                }\\n            }\\n            int currArea = getMaxArea(arr, column);\\n            maxArea = Math.max(maxArea, currArea);\\n        }\\n        return maxArea;\\n    }\\n    \\n    public int getMaxArea(int []arr, int len) {\\n        \\n        int pse[] = getPreviousSmall(arr, len);\\n        int nse[] = getNextSmall(arr, len);\\n        \\n        int maxArea = Integer.MIN_VALUE;\\n        \\n        for (int k = 0; k < len; k++) {\\n            int currArea = (nse[k] - pse[k] - 1) * arr[k];\\n            maxArea = Math.max(maxArea, currArea);\\n        }\\n        \\n        return maxArea;\\n    }\\n    \\n    public int[] getPreviousSmall(int []arr, int len) {\\n        \\n        Stack<Integer> s = new Stack<>();\\n        s.push(0);\\n        \\n        int pse[] = new int[len];\\n        pse[0] = -1;\\n        \\n        for (int i = 1; i < len; i++) {\\n            while(!s.isEmpty() && arr[s.peek()] >= arr[i]) {\\n                s.pop();\\n            }\\n            \\n            if (s.isEmpty()) {\\n                pse[i] = -1;\\n            } else {\\n                pse[i] = s.peek();\\n            }\\n            s.push(i);\\n        }\\n        return pse;\\n    }\\n    \\n    public int[] getNextSmall(int []arr, int len) {\\n        \\n        Stack<Integer> s = new Stack<>();\\n        s.push(len - 1);\\n        \\n        int nse[] = new int[len];\\n        nse[len - 1] = len;\\n        \\n        for (int j = len - 2; j >= 0; j--) {\\n            while(!s.isEmpty() && arr[s.peek()] >= arr[j]) {\\n                s.pop();\\n            }\\n            \\n            if (s.isEmpty()) {\\n                nse[j] = len;\\n            } else {\\n                nse[j] = s.peek();\\n            }\\n            s.push(j);\\n        }\\n        return nse;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477654,
                "title": "c-recursion-dp-tle-68-test-cases-passed-out-of-73",
                "content": "If someone is looking for recursive approach here it is. It will run fine for smaller teset cases but give TLE for large ones.\\nT.C=O(N^4)\\nS.C=O(N^4)+O(N^4)\\nclass Solution {\\npublic:\\n\\n    int maxarea=0;\\n    int check(vector<vector<char>>& matrix,int i,int j,int s,int e){   \\n         for(int k=i;k<=s;k++){\\n            for(int l=j;l<=e;l++){\\n                if(matrix[k][l]==\\'1\\')continue;\\n                else return false;\\n                    \\n                }\\n            }\\n          return true;\\n        }\\n  \\n    \\n    void dp(vector<vector<char>>& matrix,   vector<vector<vector<vector<int>>>>&dps,int i,int j,int s,int e){\\n         int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(i>m || j>n || i<0 || j<0 )return ;\\n        if(s>m || e>n || s<0 || e<0 )return ;\\n        if(i>s || j>e)return ;\\n        if(dps[i][j][s][e]!=-1)return;\\n                 int temp=(s-i+1)*(e-j+1);\\n                  dps[i][j][s][e]=temp;\\n                if(check(matrix,i,j,s,e)){\\n                              \\n                    //cout<<temp<<endl;\\n                    maxarea=max(maxarea,temp);\\n                    dps[i][j][s][e]=maxarea;\\n                    \\n                }\\n                dp(matrix,dps,i,j+1,s,e);\\n                dp(matrix,dps,i+1,j,s,e);\\n                dp(matrix,dps,i,j,s-1,e);\\n                dp(matrix,dps,i,j,s,e-1);           \\n\\n        \\n        \\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n       vector<vector<vector<vector<int>>>> dps(m, vector<vector<vector<int>>>\\n                                           (n, vector<vector<int>>\\n                                           (m, vector<int>\\n                                           (n,-1))));\\n      \\n        \\n        //cout<<check(matrix,1,2,2,4)<<endl;\\n     dp(matrix,dps,0,0,m-1,n-1);\\n        return maxarea;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxarea=0;\\n    int check(vector<vector<char>>& matrix,int i,int j,int s,int e){   \\n         for(int k=i;k<=s;k++){\\n            for(int l=j;l<=e;l++){\\n                if(matrix[k][l]==\\'1\\')continue;\\n                else return false;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2402447,
                "title": "java-solution-monotonic-stack-based-on-largest-area-in-histogram",
                "content": "This solution uses the code of the problem  \\'maximum area in histogram\\'.\\nThis solution is also classified as DP solution because height array uses the history of itself to update itself.\\nIf you like the solution, then please UPVOTE :)\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] height = new int[n];\\n        int maxA = 0;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(matrix[i][j] == \\'1\\')   height[j] = height[j]+1;\\n                else    height[j] = 0;\\n            }\\n            maxA = Math.max(maxA , maxAreaHisto(height , n));\\n        }\\n        return maxA;\\n    }\\n    \\n    public int maxAreaHisto(int[] height , int n){\\n        Stack<Integer> st = new Stack<>();\\n        int maxA = 0;\\n        for(int i = 0 ; i <= n ; i++){\\n            while(!st.isEmpty() && (i == n || height[st.peek()] >= height[i])){\\n                int ht = height[st.peek()];\\n                st.pop();\\n                int width;\\n                if(st.isEmpty())    width = i;\\n                else    width = i-st.peek()-1;\\n                maxA = Math.max(maxA , ht*width);\\n            }\\n            st.push(i);\\n        }\\n        return maxA;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] height = new int[n];\\n        int maxA = 0;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(matrix[i][j] == \\'1\\')   height[j] = height[j]+1;\\n                else    height[j] = 0;\\n            }\\n            maxA = Math.max(maxA , maxAreaHisto(height , n));\\n        }\\n        return maxA;\\n    }\\n    \\n    public int maxAreaHisto(int[] height , int n){\\n        Stack<Integer> st = new Stack<>();\\n        int maxA = 0;\\n        for(int i = 0 ; i <= n ; i++){\\n            while(!st.isEmpty() && (i == n || height[st.peek()] >= height[i])){\\n                int ht = height[st.peek()];\\n                st.pop();\\n                int width;\\n                if(st.isEmpty())    width = i;\\n                else    width = i-st.peek()-1;\\n                maxA = Math.max(maxA , ht*width);\\n            }\\n            st.push(i);\\n        }\\n        return maxA;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130637,
                "title": "c-easy-brute-force",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void presum(vector<vector<int>> &mat){\\n        int n = mat.size(), m = mat[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n        }\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<int>> mat(n, vector<int>(m, 0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==\\'0\\')   mat[i][j] = 0;\\n                else    mat[i][j] = 1;\\n            }\\n        }\\n        presum(mat);\\n        \\n        \\n        int ans = 0;\\n        \\n            for(int c1 = 0;c1<m;c1++){\\n        for(int c2 = c1;c2<m;c2++){\\n                int sum = 0;\\n                for(int i=0;i<n;i++){\\n                    \\n                    int temp = mat[i][c2];\\n                    if(c1>0)    temp-=mat[i][c1-1];\\n                    if(temp==(c2-c1+1)){\\n                        sum+=temp;\\n                        ans = max(ans, sum);\\n                    }\\n                    else    sum = 0;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    void presum(vector<vector<int>> &mat){\\n        int n = mat.size(), m = mat[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j]+=mat[i][j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1603362,
                "title": "python3",
                "content": "class Solution:\\n\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        ROW,COL=len(matrix),len(matrix[0])\\n        dph=[[0]*COL for _ in range(1+ROW)]\\n        dpl=[[0]*COL for _ in range(1+ROW)]\\n        dpr=[[COL-1]*COL for _ in range(1+ROW)]\\n        for i in range(1,1+ROW):\\n            lb,ub=0,COL-1\\n            for j in range(COL):\\n                if matrix[i-1][j]==\"1\":\\n                    dph[i][j]=1+dph[i-1][j]\\n                    dpl[i][j]=max(lb,dpl[i-1][j])\\n                else:\\n                    lb=j+1\\n            for j in reversed(range(COL)):\\n                if matrix[i-1][j]==\"1\":\\n                    dpr[i][j]=min(ub,dpr[i-1][j])\\n                else:\\n                    ub=j-1\\n        maxArea=0             \\n        for i in range(1,1+ROW):\\n            for j in range(COL):\\n                maxArea=max(maxArea,(dpr[i][j]-dpl[i][j]+1)*dph[i][j])\\n        return maxArea",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        ROW,COL=len(matrix),len(matrix[0])\\n        dph=[[0]*COL for _ in range(1+ROW)]\\n        dpl=[[0]*COL for _ in range(1+ROW)]\\n        dpr=[[COL-1]*COL for _ in range(1+ROW)]\\n        for i in range(1,1+ROW):\\n            lb,ub=0,COL-1\\n            for j in range(COL):\\n                if matrix[i-1][j]==\"1\":\\n                    dph[i][j]=1+dph[i-1][j]\\n                    dpl[i][j]=max(lb,dpl[i-1][j])\\n                else:\\n                    lb=j+1\\n            for j in reversed(range(COL)):\\n                if matrix[i-1][j]==\"1\":\\n                    dpr[i][j]=min(ub,dpr[i-1][j])\\n                else:\\n                    ub=j-1\\n        maxArea=0             \\n        for i in range(1,1+ROW):\\n            for j in range(COL):\\n                maxArea=max(maxArea,(dpr[i][j]-dpl[i][j]+1)*dph[i][j])\\n        return maxArea",
                "codeTag": "Java"
            },
            {
                "id": 1383459,
                "title": "c-solution-too-easy",
                "content": "Application of problem - https://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nApproach - we need to make histogram of each row and calculate maximum area from that histogram. Ans will be maximum of all rows.\\nTo make histogram of each row.\\nIf element =0 then height of histogram =0\\nelse height of histogram = Current element height of histogram of previous row  + 1\\n\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n         if(matrix.size()==0)\\n        {\\n            return 0;\\n        }\\n        \\n        vector<int> heights(matrix[0].size(),0);\\n        int maxm=0;\\n       \\n        for(int k=0;k<matrix.size();k++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[k][j]==\\'0\\')\\n                {\\n                    heights[j]=0;\\n                }\\n                else\\n                {\\n                    heights[j]+=1;\\n                }\\n            }\\n            // Approach to find maximum area of histogram link - https://leetcode.com/problems/largest-rectangle-in-histogram/\\n            vector<int> rb(heights.size(),heights.size());\\n        vector<int> lb(heights.size(),-1);\\n        stack<int> s;\\n        s.push(0);\\n        lb[0]=-1;\\n        for(int i=1;i<heights.size();i++)\\n        {\\n            while(!s.empty() && heights[s.top()]>=heights[i])\\n            {\\n                s.pop();\\n            }\\n            if(s.empty())\\n            {\\n                lb[i]=-1;\\n            }\\n            else\\n            {\\n                lb[i]=s.top();\\n            }\\n            s.push(i);\\n        }\\n        while(!s.empty())\\n        {\\n            s.pop();\\n        }\\n        s.push(heights.size()-1);\\n        for(int i=heights.size()-2;i>=0;i--)\\n        {\\n            while(!s.empty() && heights[s.top()]>=heights[i])\\n            {\\n                s.pop();\\n            }\\n            if(s.empty())\\n            {\\n                rb[i]=heights.size();\\n            }\\n            else\\n            {\\n                rb[i]=s.top();\\n            }\\n            s.push(i);\\n        }\\n        int ans=0;\\n        for(int i=0;i<heights.size();i++)\\n        {\\n            ans=max(ans,(rb[i]-lb[i]-1)*heights[i]);\\n        }\\n        maxm=max(ans,maxm);\\n        \\n        }\\n        return maxm;\\n        \\n    }\\n};\\n```\\n\\nIt would be great if you upvote.",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n         if(matrix.size()==0)\\n        {\\n            return 0;\\n        }\\n        \\n        vector<int> heights(matrix[0].size(),0);\\n        int maxm=0;\\n       \\n        for(int k=0;k<matrix.size();k++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[k][j]==\\'0\\')\\n                {\\n                    heights[j]=0;\\n                }\\n                else\\n                {\\n                    heights[j]+=1;\\n                }\\n            }\\n            // Approach to find maximum area of histogram link - https://leetcode.com/problems/largest-rectangle-in-histogram/\\n            vector<int> rb(heights.size(),heights.size());\\n        vector<int> lb(heights.size(),-1);\\n        stack<int> s;\\n        s.push(0);\\n        lb[0]=-1;\\n        for(int i=1;i<heights.size();i++)\\n        {\\n            while(!s.empty() && heights[s.top()]>=heights[i])\\n            {\\n                s.pop();\\n            }\\n            if(s.empty())\\n            {\\n                lb[i]=-1;\\n            }\\n            else\\n            {\\n                lb[i]=s.top();\\n            }\\n            s.push(i);\\n        }\\n        while(!s.empty())\\n        {\\n            s.pop();\\n        }\\n        s.push(heights.size()-1);\\n        for(int i=heights.size()-2;i>=0;i--)\\n        {\\n            while(!s.empty() && heights[s.top()]>=heights[i])\\n            {\\n                s.pop();\\n            }\\n            if(s.empty())\\n            {\\n                rb[i]=heights.size();\\n            }\\n            else\\n            {\\n                rb[i]=s.top();\\n            }\\n            s.push(i);\\n        }\\n        int ans=0;\\n        for(int i=0;i<heights.size();i++)\\n        {\\n            ans=max(ans,(rb[i]-lb[i]-1)*heights[i]);\\n        }\\n        maxm=max(ans,maxm);\\n        \\n        }\\n        return maxm;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353800,
                "title": "python-dp",
                "content": "```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):\\n        if len(matrix) == 0: return 0\\n        matrix, rows, cols=[map(int, i) for i in matrix], len(matrix), len(matrix[0])\\n        max_area, dp = float(\"-inf\"), [[0 for __ in range(cols+1)] for _ in range(rows+1)]\\n        for i in range(0, rows):\\n            for j in range(cols):\\n                dp[i][j]=matrix[i][j] if i==0 else matrix[i][j]+dp[i-matrix[i][j]][j]\\n        for i in range(rows):\\n            for j in range(cols):\\n                current_height = dp[i][j]\\n                for k in range(j, cols):\\n                    current_height = min(current_height, dp[i][k])\\n                    max_area = max(max_area, current_height * (k-j+1))\\n        return max_area\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):\\n        if len(matrix) == 0: return 0\\n        matrix, rows, cols=[map(int, i) for i in matrix], len(matrix), len(matrix[0])\\n        max_area, dp = float(\"-inf\"), [[0 for __ in range(cols+1)] for _ in range(rows+1)]\\n        for i in range(0, rows):\\n            for j in range(cols):\\n                dp[i][j]=matrix[i][j] if i==0 else matrix[i][j]+dp[i-matrix[i][j]][j]\\n        for i in range(rows):\\n            for j in range(cols):\\n                current_height = dp[i][j]\\n                for k in range(j, cols):\\n                    current_height = min(current_height, dp[i][k])\\n                    max_area = max(max_area, current_height * (k-j+1))\\n        return max_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351032,
                "title": "c-using-max-rectangle-in-histogram-faster-than-90",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {int n=0;\\n        int m=matrix.size();\\n        if(m!=0)\\n         n=matrix[0].size();\\n        int res=0;\\n        if(m==0) return 0;\\n        vector<int> v(n,0);\\n        for(int i=0;i<m;++i){\\n           for(int j=0;j<n;++j){ \\n               if(matrix[i][j]==\\'0\\') v[j]=0;\\n               else{\\n                   v[j]+= (matrix[i][j]-\\'0\\');\\n                   }\\n           }\\n              int tmp=maxInRow(v,n);\\n               res=max(res,tmp);\\n            \\n        }\\n        return res;\\n    }\\n    int maxInRow(vector<int> v,int n){\\n     \\n        int res=0;\\n        v.push_back(0);\\n        stack<int> st;\\n        \\n        int i=0;\\n        while(i<n+1){\\n            if(st.empty()|| v[i]>= v[st.top()]) st.push(i++);\\n            else{\\n                int index=st.top();\\n                st.pop();\\n                if(st.empty()) res=max(res, i*v[index]);\\n                else{\\n                    res=max(res,v[index]*(i-st.top()-1));\\n                }                \\n            }     \\n        } \\n       return res;     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {int n=0;\\n        int m=matrix.size();\\n        if(m!=0)\\n         n=matrix[0].size();\\n        int res=0;\\n        if(m==0) return 0;\\n        vector<int> v(n,0);\\n        for(int i=0;i<m;++i){\\n           for(int j=0;j<n;++j){ \\n               if(matrix[i][j]==\\'0\\') v[j]=0;\\n               else{\\n                   v[j]+= (matrix[i][j]-\\'0\\');\\n                   }\\n           }\\n              int tmp=maxInRow(v,n);\\n               res=max(res,tmp);\\n            \\n        }\\n        return res;\\n    }\\n    int maxInRow(vector<int> v,int n){\\n     \\n        int res=0;\\n        v.push_back(0);\\n        stack<int> st;\\n        \\n        int i=0;\\n        while(i<n+1){\\n            if(st.empty()|| v[i]>= v[st.top()]) st.push(i++);\\n            else{\\n                int index=st.top();\\n                st.pop();\\n                if(st.empty()) res=max(res, i*v[index]);\\n                else{\\n                    res=max(res,v[index]*(i-st.top()-1));\\n                }                \\n            }     \\n        } \\n       return res;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218156,
                "title": "c-stack-solution-based-on-largest-area-in-histogram",
                "content": "```\\nclass Solution {\\npublic:\\n    int mah(vector<int>& heights) {\\n    int n= heights.size();\\n    vector<int> left,right;\\n    stack<pair<int,int>> s1,s2;\\n    int pseudo_index =-1;\\n    int pseudo_index1 =n;\\n    for (int i=0;i<n;i++)\\n    {\\n      if (s1.size()==0)\\n      {\\n        left.push_back(pseudo_index);\\n      }\\n      else if (s1.size()>0 && s1.top().first<heights[i])\\n      {\\n        left.push_back(s1.top().second);\\n      }\\n      else if (s1.size()>0 && s1.top().first>=heights[i])\\n      {\\n         while(s1.size()>0 && s1.top().first>=heights[i])\\n         {\\n           s1.pop();\\n         }\\n        if (s1.size()==0)\\n        {\\n          left.push_back(pseudo_index);\\n        }\\n        else\\n        {\\n          left.push_back(s1.top().second);\\n        }\\n      }\\n      s1.push({heights[i],i});\\n    }\\n    for (int i=n-1;i>=0;i--)\\n    {\\n      if (s2.size()==0)\\n      {\\n        right.push_back(pseudo_index1);\\n      }\\n      else if (s2.size()>0 && s2.top().first<heights[i])\\n      {\\n        right.push_back(s2.top().second);\\n      }\\n      else if (s2.size()>0 && s2.top().first >= heights[i])\\n      {\\n        while(s2.size()>0 && s2.top().first >= heights[i])\\n        {\\n          s2.pop();\\n        }\\n        if (s2.size()==0)\\n        {\\n          right.push_back(pseudo_index1);\\n        }\\n        else\\n        {\\n          right.push_back(s2.top().second);\\n        }\\n      }\\n      s2.push({heights[i],i});\\n    }\\n    reverse(right.begin(),right.end());\\n    int m=INT_MIN;\\n    for (long long i=0;i<n;i++)\\n    {\\n      m=max(m,(right[i]-left[i]-1)*heights[i]);\\n    }\\n    return m;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n         if(matrix.size()==0)\\n             return 0;\\n          vector<int>v;\\n          for(int i=0;i<matrix[0].size();i++)\\n              v.push_back(matrix[0][i]-\\'0\\');\\n          int mx=mah(v);\\n          for(int i=1;i<matrix.size();i++)\\n          {\\n              for(int j=0;j<matrix[0].size();j++)\\n              {\\n                  if(matrix[i][j]==\\'0\\')\\n                      v[j]=0;\\n                  else\\n                      v[j]=v[j]+1;\\n              }\\n              mx=max(mx,mah(v));\\n          }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mah(vector<int>& heights) {\\n    int n= heights.size();\\n    vector<int> left,right;\\n    stack<pair<int,int>> s1,s2;\\n    int pseudo_index =-1;\\n    int pseudo_index1 =n;\\n    for (int i=0;i<n;i++)\\n    {\\n      if (s1.size()==0)\\n      {\\n        left.push_back(pseudo_index);\\n      }\\n      else if (s1.size()>0 && s1.top().first<heights[i])\\n      {\\n        left.push_back(s1.top().second);\\n      }\\n      else if (s1.size()>0 && s1.top().first>=heights[i])\\n      {\\n         while(s1.size()>0 && s1.top().first>=heights[i])\\n         {\\n           s1.pop();\\n         }\\n        if (s1.size()==0)\\n        {\\n          left.push_back(pseudo_index);\\n        }\\n        else\\n        {\\n          left.push_back(s1.top().second);\\n        }\\n      }\\n      s1.push({heights[i],i});\\n    }\\n    for (int i=n-1;i>=0;i--)\\n    {\\n      if (s2.size()==0)\\n      {\\n        right.push_back(pseudo_index1);\\n      }\\n      else if (s2.size()>0 && s2.top().first<heights[i])\\n      {\\n        right.push_back(s2.top().second);\\n      }\\n      else if (s2.size()>0 && s2.top().first >= heights[i])\\n      {\\n        while(s2.size()>0 && s2.top().first >= heights[i])\\n        {\\n          s2.pop();\\n        }\\n        if (s2.size()==0)\\n        {\\n          right.push_back(pseudo_index1);\\n        }\\n        else\\n        {\\n          right.push_back(s2.top().second);\\n        }\\n      }\\n      s2.push({heights[i],i});\\n    }\\n    reverse(right.begin(),right.end());\\n    int m=INT_MIN;\\n    for (long long i=0;i<n;i++)\\n    {\\n      m=max(m,(right[i]-left[i]-1)*heights[i]);\\n    }\\n    return m;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n         if(matrix.size()==0)\\n             return 0;\\n          vector<int>v;\\n          for(int i=0;i<matrix[0].size();i++)\\n              v.push_back(matrix[0][i]-\\'0\\');\\n          int mx=mah(v);\\n          for(int i=1;i<matrix.size();i++)\\n          {\\n              for(int j=0;j<matrix[0].size();j++)\\n              {\\n                  if(matrix[i][j]==\\'0\\')\\n                      v[j]=0;\\n                  else\\n                      v[j]=v[j]+1;\\n              }\\n              mx=max(mx,mah(v));\\n          }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024094,
                "title": "python-solution",
                "content": "This is a 2D version of 84. Largest Rectangle in Histogram. For each `row` of `matrix`, and for each index `i` of the `row`, we can find the histogram\\'s bar height at `row[i]`, and find the area of the largest rectangle in the histogram. We have one such largest rectangle per `row`, and when taking the maximum of all such rectangles over the rows, we get the largest rectangle containing only `1`s in the matrix.\\n\\nTime complexity: O(mn), space complexity: O(mn).\\n\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        m = len(matrix)\\n        if m == 0:\\n            return 0\\n        n = len(matrix[0])\\n        if n == 0:\\n            return 0\\n        \\n        rec = [[0] * n for _ in range(m)]\\n        for i in range(n):\\n            if matrix[0][i] == \\'1\\':\\n                rec[0][i] = 1\\n                \\n        max_area = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if i > 0 and matrix[i][j] != \\'0\\':\\n                    rec[i][j] = rec[i - 1][j] + 1\\n            \\n            stack = []\\n            heights = rec[i]\\n            for k, h in enumerate(heights):\\n                if not stack or stack[-1][1] < h:\\n                    stack.append((k, h))\\n                else:\\n                    while stack and stack[-1][1] >= h:\\n                        l, p = stack.pop()\\n                        max_area = max(max_area, (k - l) * p)\\n                    stack.append((l, h))\\n            while stack:\\n                l, p = stack.pop()\\n                max_area = max(max_area, (n - l) * p)  \\n                \\n        return max_area\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        m = len(matrix)\\n        if m == 0:\\n            return 0\\n        n = len(matrix[0])\\n        if n == 0:\\n            return 0\\n        \\n        rec = [[0] * n for _ in range(m)]\\n        for i in range(n):\\n            if matrix[0][i] == \\'1\\':\\n                rec[0][i] = 1\\n                \\n        max_area = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if i > 0 and matrix[i][j] != \\'0\\':\\n                    rec[i][j] = rec[i - 1][j] + 1\\n            \\n            stack = []\\n            heights = rec[i]\\n            for k, h in enumerate(heights):\\n                if not stack or stack[-1][1] < h:\\n                    stack.append((k, h))\\n                else:\\n                    while stack and stack[-1][1] >= h:\\n                        l, p = stack.pop()\\n                        max_area = max(max_area, (k - l) * p)\\n                    stack.append((l, h))\\n            while stack:\\n                l, p = stack.pop()\\n                max_area = max(max_area, (n - l) * p)  \\n                \\n        return max_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937427,
                "title": "clean-code-using-stack",
                "content": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length == 0) return 0;\\n        int output[] = new int[matrix[0].length];\\n        int max = 0;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++)\\n                output[j] = matrix[i][j] == \\'0\\' ? 0 : output[j]+1;\\n            max = Math.max(max, Histogram(output));\\n        }\\n        return max;\\n\\t}\\n\\n    static int Histogram(int output[]){\\n        int left[] = findLeft(output);\\n\\t\\tint right[] = findRight(output);\\n\\t\\tint width[] = findWidth(left, right);\\n\\t\\tint area[] = findArea(output, width);\\n\\t\\tint maxArea = findMax(area);\\n        return maxArea;\\n    }\\n\\n\\tstatic int[] findLeft(int arr[]){\\n\\t\\tStack<Integer> stack = new Stack<Integer>();\\n\\t\\tstack.push(0);\\n\\t\\tint temp[] = new int[arr.length];\\n\\t\\ttemp[0] = -1;\\n\\t\\tfor(int i = 1; i < arr.length; i++){\\n\\t\\t\\tif(stack.size() == 0) temp[i] = -1;\\n\\t\\t\\telse if(stack.size() > 0 && arr[stack.peek()] >= arr[i]){\\n\\t\\t\\t\\twhile(stack.size() > 0 && arr[stack.peek()] >= arr[i]) stack.pop();\\n                temp[i] = stack.size() == 0 ? -1 : stack.peek();\\n\\t\\t\\t}\\n\\t\\t\\telse temp[i] = stack.peek();\\n\\t\\t\\tstack.push(i);\\n\\t\\t}\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int[] findRight(int arr[]){\\n\\t\\tStack<Integer> stack = new Stack<Integer>();\\n\\t\\tstack.push(arr.length - 1);\\n\\t\\tint temp[] = new int[arr.length];\\n\\t\\ttemp[arr.length - 1] = arr.length;\\n\\t\\tfor(int i = arr.length - 1; i >= 0; i--){\\n\\t\\t\\tif(stack.size() == 0) temp[i] = arr.length;\\n\\t\\t\\telse if(stack.size() > 0 && arr[stack.peek()] >= arr[i]){\\n\\t\\t\\t\\twhile(stack.size() > 0 && arr[stack.peek()] >= arr[i]) stack.pop();\\n                temp[i] = stack.size() == 0 ? arr.length : stack.peek();\\n\\t\\t\\t}\\n\\t\\t\\telse temp[i] = stack.peek();\\n\\t\\t\\tstack.push(i);\\n\\t\\t}\\n\\t\\tCollections.reverse(Arrays.asList(temp));\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int[] findWidth(int left[], int right[]){\\n\\t\\tint temp[] = new int[left.length];\\n\\t\\tfor(int i = 0; i < left.length; i++)\\n\\t\\t\\ttemp[i] = right[i] - left[i] - 1;\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int[] findArea(int arr[], int width[]){\\n\\t\\tint temp[] = new int[arr.length];\\n\\t\\tfor(int i = 0; i < arr.length; i++)\\n\\t\\t\\ttemp[i] = arr[i] * width[i];\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int findMax(int area[]){\\n\\t\\tint max = 0;\\n\\t\\tfor(int i = 0; i < area.length; i++)\\n            max = Math.max(max, area[i]);\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length == 0) return 0;\\n        int output[] = new int[matrix[0].length];\\n        int max = 0;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++)\\n                output[j] = matrix[i][j] == \\'0\\' ? 0 : output[j]+1;\\n            max = Math.max(max, Histogram(output));\\n        }\\n        return max;\\n\\t}\\n\\n    static int Histogram(int output[]){\\n        int left[] = findLeft(output);\\n\\t\\tint right[] = findRight(output);\\n\\t\\tint width[] = findWidth(left, right);\\n\\t\\tint area[] = findArea(output, width);\\n\\t\\tint maxArea = findMax(area);\\n        return maxArea;\\n    }\\n\\n\\tstatic int[] findLeft(int arr[]){\\n\\t\\tStack<Integer> stack = new Stack<Integer>();\\n\\t\\tstack.push(0);\\n\\t\\tint temp[] = new int[arr.length];\\n\\t\\ttemp[0] = -1;\\n\\t\\tfor(int i = 1; i < arr.length; i++){\\n\\t\\t\\tif(stack.size() == 0) temp[i] = -1;\\n\\t\\t\\telse if(stack.size() > 0 && arr[stack.peek()] >= arr[i]){\\n\\t\\t\\t\\twhile(stack.size() > 0 && arr[stack.peek()] >= arr[i]) stack.pop();\\n                temp[i] = stack.size() == 0 ? -1 : stack.peek();\\n\\t\\t\\t}\\n\\t\\t\\telse temp[i] = stack.peek();\\n\\t\\t\\tstack.push(i);\\n\\t\\t}\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int[] findRight(int arr[]){\\n\\t\\tStack<Integer> stack = new Stack<Integer>();\\n\\t\\tstack.push(arr.length - 1);\\n\\t\\tint temp[] = new int[arr.length];\\n\\t\\ttemp[arr.length - 1] = arr.length;\\n\\t\\tfor(int i = arr.length - 1; i >= 0; i--){\\n\\t\\t\\tif(stack.size() == 0) temp[i] = arr.length;\\n\\t\\t\\telse if(stack.size() > 0 && arr[stack.peek()] >= arr[i]){\\n\\t\\t\\t\\twhile(stack.size() > 0 && arr[stack.peek()] >= arr[i]) stack.pop();\\n                temp[i] = stack.size() == 0 ? arr.length : stack.peek();\\n\\t\\t\\t}\\n\\t\\t\\telse temp[i] = stack.peek();\\n\\t\\t\\tstack.push(i);\\n\\t\\t}\\n\\t\\tCollections.reverse(Arrays.asList(temp));\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int[] findWidth(int left[], int right[]){\\n\\t\\tint temp[] = new int[left.length];\\n\\t\\tfor(int i = 0; i < left.length; i++)\\n\\t\\t\\ttemp[i] = right[i] - left[i] - 1;\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int[] findArea(int arr[], int width[]){\\n\\t\\tint temp[] = new int[arr.length];\\n\\t\\tfor(int i = 0; i < arr.length; i++)\\n\\t\\t\\ttemp[i] = arr[i] * width[i];\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int findMax(int area[]){\\n\\t\\tint max = 0;\\n\\t\\tfor(int i = 0; i < area.length; i++)\\n            max = Math.max(max, area[i]);\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824064,
                "title": "java-short-dp-solution",
                "content": "```\\nprivate static int findRectangleArea2Ds(char[][] matrix) {\\n\\t\\tif (matrix == null || matrix.length == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint maxArea = 0;\\n\\t\\tint rows = matrix.length;\\n\\t\\tint cols = matrix[0].length;\\n\\t\\tint[][] dp = new int[rows][cols];\\n\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == \\'1\\') {\\n\\t\\t\\t\\t\\tdp[i][j] = j == 0 ? 1 : dp[i][j - 1] + 1;\\n\\t\\t\\t\\t\\tint length = dp[i][j];\\n\\n\\t\\t\\t\\t\\tfor (int k = i; k >= 0; k--) {\\n\\t\\t\\t\\t\\t\\tlength = Math.min(length, dp[k][j]);\\n\\t\\t\\t\\t\\t\\tint width = i - k + 1;\\n\\t\\t\\t\\t\\t\\tmaxArea = Math.max(maxArea, length * width);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn maxArea;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nprivate static int findRectangleArea2Ds(char[][] matrix) {\\n\\t\\tif (matrix == null || matrix.length == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint maxArea = 0;\\n\\t\\tint rows = matrix.length;\\n\\t\\tint cols = matrix[0].length;\\n\\t\\tint[][] dp = new int[rows][cols];\\n\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == \\'1\\') {\\n\\t\\t\\t\\t\\tdp[i][j] = j == 0 ? 1 : dp[i][j - 1] + 1;\\n\\t\\t\\t\\t\\tint length = dp[i][j];\\n\\n\\t\\t\\t\\t\\tfor (int k = i; k >= 0; k--) {\\n\\t\\t\\t\\t\\t\\tlength = Math.min(length, dp[k][j]);\\n\\t\\t\\t\\t\\t\\tint width = i - k + 1;\\n\\t\\t\\t\\t\\t\\tmaxArea = Math.max(maxArea, length * width);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn maxArea;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 771664,
                "title": "javascript-dp",
                "content": "```\\nvar maximalRectangle = function (matrix) {\\n  if (matrix.length <= 0) return 0;\\n  const n = matrix.length;\\n  const m = matrix[0].length;\\n  const dp = new Array(n).fill([]).map(() => new Array(m).fill(0))\\n  let maxArea = 0;\\n  for (let r = 0; r < n; r++) {\\n    for (let c = 0; c < m; c++) {\\n      if (matrix[r][c] == 0) continue;\\n      dp[r][c] += dp[r - 1] ? dp[r - 1][c] + 1 : 1;\\n      let min = dp[r][c];\\n      for (let k = c; k >= 0; k--) {\\n        if (dp[r][k] == 0) break;\\n        min = dp[r][k] < min ? dp[r][k] : min;\\n        maxArea = Math.max(maxArea, min * (c - k + 1))\\n      }\\n    }\\n  }\\n  return maxArea;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maximalRectangle = function (matrix) {\\n  if (matrix.length <= 0) return 0;\\n  const n = matrix.length;\\n  const m = matrix[0].length;\\n  const dp = new Array(n).fill([]).map(() => new Array(m).fill(0))\\n  let maxArea = 0;\\n  for (let r = 0; r < n; r++) {\\n    for (let c = 0; c < m; c++) {\\n      if (matrix[r][c] == 0) continue;\\n      dp[r][c] += dp[r - 1] ? dp[r - 1][c] + 1 : 1;\\n      let min = dp[r][c];\\n      for (let k = c; k >= 0; k--) {\\n        if (dp[r][k] == 0) break;\\n        min = dp[r][k] < min ? dp[r][k] : min;\\n        maxArea = Math.max(maxArea, min * (c - k + 1))\\n      }\\n    }\\n  }\\n  return maxArea;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764461,
                "title": "c-dp",
                "content": "Dynamic Programming:\\n\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if (matrix.size() == 0) return 0;\\n            int maxarea = 0;\\n            vector<vector<int>> dp(matrix.size(), vector<int>(matrix[0].size(), 0));\\n\\n            for(int i = 0; i < matrix.size(); i++){\\n                for(int j = 0; j < matrix[0].size(); j++){\\n                    if (matrix[i][j] == \\'1\\'){\\n\\n                        // compute the maximum width and update dp with it\\n                        dp[i][j] = j == 0? 1 : dp[i][j-1] + 1;\\n\\n                        int width = dp[i][j];\\n\\n                        // compute the maximum area rectangle with a lower right corner at [i, j]\\n                        for(int k = i; k >= 0; k--){\\n                            width = min(width, dp[k][j]);\\n                            maxarea = max(maxarea, width * (i - k + 1));\\n                        }\\n                    }\\n                }\\n            } \\n\\t\\t\\treturn maxarea;\\n        }\\n};\\n```\\n\\nmethod 2: using histogram (stack)\\nThis method uses [approach 5 in LeetCode 84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/solution/)\\n```\\nclass Solution {\\npublic:\\n    \\n/*\\n\\norg:         \\n\\n       c0 c1 c2 c3\\nrow      \\n  0     1  0  1  0\\n  1     1  0  1  1\\n  2     1  1  1  1 \\n  3     1  0  0  1\\n   \\n   \\nstep 1: calculate hist upon rows:\\n   \\n        c0 c1 c2 c3\\nrow\\n  0     1  0  1  0\\n  1     2  0  2  1\\n  2     3  1  3  2\\n  3     4  0  0  3\\n\\n\\nstep 2: calculate max rectangle of hist upon each row:\\n\\nrow\\n  0     1\\n  1     2\\n  2     4\\n  3     4\\n    \\nstep 3: return max area (4).\\n   \\n   \\n*/\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int n_rows = matrix.size();\\n        \\n        if (n_rows == 0)\\n            return 0;\\n        \\n        int n_cols = matrix[0].size();\\n        \\n        vector<int> hist(n_cols, 0);\\n        \\n        int max_area = 0;\\n        \\n        for (int r = 0; r < n_rows; r++) {\\n            \\n            // update the state of this row\\'s histogram using the last row\\'s histogram\\n            // by keeping track of the number of consecutive ones\\n            for (int c= 0; c < n_cols; c++) {\\n                if (matrix[r][c] == \\'1\\')\\n                    hist[c] += 1;\\n                else\\n                    hist[c] = 0;\\n            }\\n            \\n            \\n            // update maxarea with the maximum area from this row\\'s histogram\\n            int area = largest_rectangle_hist(hist);\\n            \\n            max_area = max(max_area, area);\\n        }\\n        \\n        return max_area;\\n    }\\n    \\n    \\n    /*\\n                     #\\n            #     #  #\\n            #     #  #\\n            #  #  #  #\\n    index   0  1  2  3\\n    \\n\\n                     #\\n            .     #  #\\n            .     #  #\\n            .  #  #  #\\n    index   0  1  2  3\\n    \\n    \\n                     .\\n            .     .  .\\n            .     .  .\\n            .  #  .  .\\n    index   0  1  2  3\\n    \\n    \\n    */\\n    int largest_rectangle_hist(vector<int> hist) {\\n        int max_area = 0;\\n        \\n        stack<int> st;\\n        \\n        hist.insert(hist.begin(), 0);\\n        hist.insert(hist.end(), 0);\\n        \\n        for (int i = 0; i < hist.size(); i++) {\\n            while(!st.empty() && hist[st.top()] > hist[i]) {\\n                int h = hist[st.top()];\\n                st.pop();\\n                \\n                int w = (i - st.top() - 1);\\n                \\n                max_area = max(max_area, h * w);\\n            }  \\n            \\n            st.push(i);\\n        }\\n\\n        return max_area;\\n    }\\n};\\n```\\n\\ndp with maximum height at each point\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.size() == 0) return 0;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n\\n        vector<int> left(n); // initialize left as the leftmost boundary possible\\n        vector<int> right(n, n);// initialize right as the rightmost boundary possible\\n        vector<int> height(n);\\n\\n        int maxarea = 0;\\n        for(int i = 0; i < m; i++) {\\n            int cur_left = 0, cur_right = n;\\n            // update height\\n            for(int j = 0; j < n; j++) {\\n                if(matrix[i][j] == \\'1\\') height[j]++;\\n                else height[j] = 0;\\n            }\\n            // update left\\n            for(int j=0; j<n; j++) {\\n                if(matrix[i][j]==\\'1\\') left[j]=max(left[j],cur_left);\\n                else {left[j]=0; cur_left=j+1;}\\n            }\\n            // update right\\n            for(int j = n - 1; j >= 0; j--) {\\n                if(matrix[i][j] == \\'1\\') right[j] = min(right[j], cur_right);\\n                else {right[j] = n; cur_right = j;}    \\n            }\\n            // update area\\n            for(int j = 0; j < n; j++) {\\n                maxarea = max(maxarea, (right[j] - left[j]) * height[j]);\\n            }\\n        }\\n        return maxarea;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if (matrix.size() == 0) return 0;\\n            int maxarea = 0;\\n            vector<vector<int>> dp(matrix.size(), vector<int>(matrix[0].size(), 0));\\n\\n            for(int i = 0; i < matrix.size(); i++){\\n                for(int j = 0; j < matrix[0].size(); j++){\\n                    if (matrix[i][j] == \\'1\\'){\\n\\n                        // compute the maximum width and update dp with it\\n                        dp[i][j] = j == 0? 1 : dp[i][j-1] + 1;\\n\\n                        int width = dp[i][j];\\n\\n                        // compute the maximum area rectangle with a lower right corner at [i, j]\\n                        for(int k = i; k >= 0; k--){\\n                            width = min(width, dp[k][j]);\\n                            maxarea = max(maxarea, width * (i - k + 1));\\n                        }\\n                    }\\n                }\\n            } \\n\\t\\t\\treturn maxarea;\\n        }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n/*\\n\\norg:         \\n\\n       c0 c1 c2 c3\\nrow      \\n  0     1  0  1  0\\n  1     1  0  1  1\\n  2     1  1  1  1 \\n  3     1  0  0  1\\n   \\n   \\nstep 1: calculate hist upon rows:\\n   \\n        c0 c1 c2 c3\\nrow\\n  0     1  0  1  0\\n  1     2  0  2  1\\n  2     3  1  3  2\\n  3     4  0  0  3\\n\\n\\nstep 2: calculate max rectangle of hist upon each row:\\n\\nrow\\n  0     1\\n  1     2\\n  2     4\\n  3     4\\n    \\nstep 3: return max area (4).\\n   \\n   \\n*/\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int n_rows = matrix.size();\\n        \\n        if (n_rows == 0)\\n            return 0;\\n        \\n        int n_cols = matrix[0].size();\\n        \\n        vector<int> hist(n_cols, 0);\\n        \\n        int max_area = 0;\\n        \\n        for (int r = 0; r < n_rows; r++) {\\n            \\n            // update the state of this row\\'s histogram using the last row\\'s histogram\\n            // by keeping track of the number of consecutive ones\\n            for (int c= 0; c < n_cols; c++) {\\n                if (matrix[r][c] == \\'1\\')\\n                    hist[c] += 1;\\n                else\\n                    hist[c] = 0;\\n            }\\n            \\n            \\n            // update maxarea with the maximum area from this row\\'s histogram\\n            int area = largest_rectangle_hist(hist);\\n            \\n            max_area = max(max_area, area);\\n        }\\n        \\n        return max_area;\\n    }\\n    \\n    \\n    /*\\n                     #\\n            #     #  #\\n            #     #  #\\n            #  #  #  #\\n    index   0  1  2  3\\n    \\n\\n                     #\\n            .     #  #\\n            .     #  #\\n            .  #  #  #\\n    index   0  1  2  3\\n    \\n    \\n                     .\\n            .     .  .\\n            .     .  .\\n            .  #  .  .\\n    index   0  1  2  3\\n    \\n    \\n    */\\n    int largest_rectangle_hist(vector<int> hist) {\\n        int max_area = 0;\\n        \\n        stack<int> st;\\n        \\n        hist.insert(hist.begin(), 0);\\n        hist.insert(hist.end(), 0);\\n        \\n        for (int i = 0; i < hist.size(); i++) {\\n            while(!st.empty() && hist[st.top()] > hist[i]) {\\n                int h = hist[st.top()];\\n                st.pop();\\n                \\n                int w = (i - st.top() - 1);\\n                \\n                max_area = max(max_area, h * w);\\n            }  \\n            \\n            st.push(i);\\n        }\\n\\n        return max_area;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.size() == 0) return 0;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n\\n        vector<int> left(n); // initialize left as the leftmost boundary possible\\n        vector<int> right(n, n);// initialize right as the rightmost boundary possible\\n        vector<int> height(n);\\n\\n        int maxarea = 0;\\n        for(int i = 0; i < m; i++) {\\n            int cur_left = 0, cur_right = n;\\n            // update height\\n            for(int j = 0; j < n; j++) {\\n                if(matrix[i][j] == \\'1\\') height[j]++;\\n                else height[j] = 0;\\n            }\\n            // update left\\n            for(int j=0; j<n; j++) {\\n                if(matrix[i][j]==\\'1\\') left[j]=max(left[j],cur_left);\\n                else {left[j]=0; cur_left=j+1;}\\n            }\\n            // update right\\n            for(int j = n - 1; j >= 0; j--) {\\n                if(matrix[i][j] == \\'1\\') right[j] = min(right[j], cur_right);\\n                else {right[j] = n; cur_right = j;}    \\n            }\\n            // update area\\n            for(int j = 0; j < n; j++) {\\n                maxarea = max(maxarea, (right[j] - left[j]) * height[j]);\\n            }\\n        }\\n        return maxarea;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739494,
                "title": "javascript-clean-dp-using-histograms",
                "content": "```javascript\\nvar maximalRectangle = function(matrix) {\\n    if(!matrix.length) return 0;\\n    const R_NUM = matrix.length, C_NUM = matrix[0].length;\\n    const histogram = Array(C_NUM).fill(0);\\n    let maxArea = 0;\\n    \\n    for(let r = 0; r < R_NUM; r++) {\\n        for(let c = 0; c < C_NUM; c++) {\\n            if(+matrix[r][c]) histogram[c]++;\\n            else histogram[c] = 0;\\n        }\\n        \\n        for(let c = 0; c < C_NUM; c++) {\\n            let left = c - 1, right = c + 1;\\n            while(left >= 0 && histogram[left] >= histogram[c]) left--;\\n            while(right < C_NUM && histogram[right] >= histogram[c]) right++;\\n            maxArea = Math.max(histogram[c] * (right - left - 1), maxArea);\\n        }\\n    }\\n    return maxArea;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar maximalRectangle = function(matrix) {\\n    if(!matrix.length) return 0;\\n    const R_NUM = matrix.length, C_NUM = matrix[0].length;\\n    const histogram = Array(C_NUM).fill(0);\\n    let maxArea = 0;\\n    \\n    for(let r = 0; r < R_NUM; r++) {\\n        for(let c = 0; c < C_NUM; c++) {\\n            if(+matrix[r][c]) histogram[c]++;\\n            else histogram[c] = 0;\\n        }\\n        \\n        for(let c = 0; c < C_NUM; c++) {\\n            let left = c - 1, right = c + 1;\\n            while(left >= 0 && histogram[left] >= histogram[c]) left--;\\n            while(right < C_NUM && histogram[right] >= histogram[c]) right++;\\n            maxArea = Math.max(histogram[c] * (right - left - 1), maxArea);\\n        }\\n    }\\n    return maxArea;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 737438,
                "title": "brute-force-method",
                "content": "Similar question of [Count Submatrices With All Ones](https://leetcode.com/problems/count-submatrices-with-all-ones/)\\n\\nInspired by @rsdavis6\\'s [solution](https://leetcode.com/problems/count-submatrices-with-all-ones/discuss/721266/C%2B%2B-Understand-the-brute-force-solution-first!) for above question.\\n\\nI know the `boundary` is not needed, but I leave it there to respect the original author.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row = matrix.size();\\n        if (row == 0) return 0;\\n        int col = matrix[0].size();\\n        \\n        int ans = 0;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                ans = max(ans, area(i, j, matrix));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int area(int row, int col, vector<vector<char>>& matrix) {\\n        int row_max = matrix.size();\\n        int col_max = matrix[0].size();\\n        int boundary = col_max;\\n        \\n        int area = 0;\\n        for (int i = row; i < row_max; i++) {\\n            for (int j = col; j < boundary; j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    continue;\\n                } else {\\n                    boundary = j;\\n                    break;\\n                }\\n            }\\n            area = max((i-row+1) * (boundary-col), area);\\n        }\\n        return area;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row = matrix.size();\\n        if (row == 0) return 0;\\n        int col = matrix[0].size();\\n        \\n        int ans = 0;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                ans = max(ans, area(i, j, matrix));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int area(int row, int col, vector<vector<char>>& matrix) {\\n        int row_max = matrix.size();\\n        int col_max = matrix[0].size();\\n        int boundary = col_max;\\n        \\n        int area = 0;\\n        for (int i = row; i < row_max; i++) {\\n            for (int j = col; j < boundary; j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    continue;\\n                } else {\\n                    boundary = j;\\n                    break;\\n                }\\n            }\\n            area = max((i-row+1) * (boundary-col), area);\\n        }\\n        return area;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736725,
                "title": "python-rust-stack-solution",
                "content": "- **Python**\\n\\n```python\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix: \\n            return 0\\n        \\n        res, histogram = 0, [0] * (len(matrix[0]) + 2)\\n        \\n        for row in matrix:\\n            for i, val in enumerate(row):\\n                if val == \\'0\\':\\n                    histogram[i + 1] = 0\\n                else:\\n                    histogram[i + 1] += 1\\n                    \\n            res = max(res, self.maxInHistogram(histogram))\\n        \\n        return res\\n        \\n        \\n    def maxInHistogram(self, hist: List[int]) -> int:\\n        res, stack = 0, []\\n        \\n        for i, h in enumerate(hist):\\n            \\n            while stack and hist[stack[-1]] > h:\\n                j = stack.pop()\\n                res = max(res, (i - stack[-1]-1) * hist[j])\\n            \\n            stack.append(i)\\n        \\n        return res\\n```\\n\\n- **Rust**\\n\\n```rust\\nimpl Solution {\\n    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {\\n        if matrix.len() == 0 {\\n            return 0;\\n        }\\n        \\n        let mut res = 0;\\n        let mut histogram: Vec<i32> = vec![ 0; (matrix[0].len() + 2) ];\\n        \\n        for row in matrix.iter() {\\n            for (i, val) in row.iter().enumerate() {\\n                if *val == \\'0\\' {\\n                    histogram[i + 1] = 0;\\n                } else {\\n                    histogram[i + 1] += 1;\\n                }\\n            }\\n            res = res.max(Self::maxInHistogram(&histogram));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    pub fn maxInHistogram(hist: &Vec<i32>) -> i32 {\\n        let mut res: i32 = 0;\\n        let mut stack: Vec<usize> = vec![];\\n        \\n        for (i, val) in hist.iter().enumerate() {\\n            while stack.len() > 0 && hist[*stack.iter().last().unwrap()] > *val {\\n                let j = stack.pop().unwrap();\\n                let width = (i - stack[stack.len() - 1] - 1) as i32;\\n                res = res.max(hist[j] * width);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust",
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix: \\n            return 0\\n        \\n        res, histogram = 0, [0] * (len(matrix[0]) + 2)\\n        \\n        for row in matrix:\\n            for i, val in enumerate(row):\\n                if val == \\'0\\':\\n                    histogram[i + 1] = 0\\n                else:\\n                    histogram[i + 1] += 1\\n                    \\n            res = max(res, self.maxInHistogram(histogram))\\n        \\n        return res\\n        \\n        \\n    def maxInHistogram(self, hist: List[int]) -> int:\\n        res, stack = 0, []\\n        \\n        for i, h in enumerate(hist):\\n            \\n            while stack and hist[stack[-1]] > h:\\n                j = stack.pop()\\n                res = max(res, (i - stack[-1]-1) * hist[j])\\n            \\n            stack.append(i)\\n        \\n        return res\\n```\n```rust\\nimpl Solution {\\n    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {\\n        if matrix.len() == 0 {\\n            return 0;\\n        }\\n        \\n        let mut res = 0;\\n        let mut histogram: Vec<i32> = vec![ 0; (matrix[0].len() + 2) ];\\n        \\n        for row in matrix.iter() {\\n            for (i, val) in row.iter().enumerate() {\\n                if *val == \\'0\\' {\\n                    histogram[i + 1] = 0;\\n                } else {\\n                    histogram[i + 1] += 1;\\n                }\\n            }\\n            res = res.max(Self::maxInHistogram(&histogram));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    pub fn maxInHistogram(hist: &Vec<i32>) -> i32 {\\n        let mut res: i32 = 0;\\n        let mut stack: Vec<usize> = vec![];\\n        \\n        for (i, val) in hist.iter().enumerate() {\\n            while stack.len() > 0 && hist[*stack.iter().last().unwrap()] > *val {\\n                let j = stack.pop().unwrap();\\n                let width = (i - stack[stack.len() - 1] - 1) as i32;\\n                res = res.max(hist[j] * width);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29126,
                "title": "sharing-my-12ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int maximalRectangle(vector<vector<char>>& matrix) {\\n            // pure application of dynamic programming\\n            int m = matrix.size();\\n            if(m==0)\\n                return 0;\\n            int n = matrix[0].size();\\n            if(n==0)\\n                return 0;\\n                \\n            int result=0;\\n            vector<int> height(n, 0);\\n            vector<int> left(n, 0);\\n            vector<int> right(n, n-1);\\n            int currentLeft, currentRight;\\n            int i, j;\\n            for(i=0; i<m; i++)\\n            {\\n                currentLeft = 0;\\n                currentRight = n-1;\\n                \\n                for(j=0; j<n; j++)\\n                {\\n                    if(matrix[i][j]=='1')\\n                        height[j]++;\\n                    else\\n                        height[j] = 0;\\n                }\\n                \\n                for(j=0; j<n; j++)\\n                {\\n                    if(matrix[i][j]=='1')\\n                        left[j] = max(left[j], currentLeft);\\n                    else\\n                    {\\n                        left[j] = 0;\\n                        currentLeft = j+1;\\n                    }\\n                }\\n                \\n                for(j=n-1; j>=0; j--)\\n                {\\n                    if(matrix[i][j]=='1')\\n                        right[j] = min(right[j], currentRight);\\n                    else\\n                    {\\n                        right[j] = n-1;\\n                        currentRight = j-1;\\n                    }\\n                }\\n                \\n                for(j=0; j<n; j++)\\n                    result = max(result, (right[j]-left[j]+1)*height[j]);\\n            }\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maximalRectangle(vector<vector<char>>& matrix) {\\n            // pure application of dynamic programming\\n            int m = matrix.size();\\n            if(m==0)\\n                return 0;\\n            int n = matrix[0].size();\\n            if(n==0)\\n                return 0;\\n                \\n            int result=0;\\n            vector<int> height(n, 0);\\n            vector<int> left(n, 0);\\n            vector<int> right(n, n-1);\\n            int currentLeft, currentRight;\\n            int i, j;\\n            for(i=0; i<m; i++)\\n            {\\n                currentLeft = 0;\\n                currentRight = n-1;\\n                \\n                for(j=0; j<n; j++)\\n                {\\n                    if(matrix[i][j]=='1')\\n                        height[j]++;\\n                    else\\n                        height[j] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 29153,
                "title": "sharing-my-296ms-java-solution",
                "content": "The idea is, to form a matrix x where each element indicates the next index of horizontal '1' before '0' or end (getX()), and another matrix y where each element indicates the index of next vertical '1' before '0' or end (getY()). E.g. 1 1 1 0 0 1 1 becomes 2 2 2 -1 -1 6 6.\\n\\nThen, for each element [i][j], only [i+1][j+1], [i+2][j+2]... needs to be checked. The area can be easily computed by the indexes on x and y.\\n\\n    public class Solution {\\n        public int maximalRectangle(char[][] matrix) {\\n    \\n    \\t\\tint h = matrix.length;\\n    \\t\\tif (h == 0) {\\n    \\t\\t\\treturn 0;\\n    \\t\\t}\\n    \\t\\tint w = matrix[0].length;\\n    \\t\\tif (w == 0) {\\n    \\t\\t\\treturn 0;\\n    \\t\\t}\\n    \\n    \\t\\tint[][] x = getX(matrix, h, w);\\n    \\t\\tint[][] y = getY(matrix, h, w);\\n    \\n    \\t\\tint maxArea = 0;\\n    \\n    \\t\\tfor (int i = 0; i < h; i++) {\\n    \\t\\t\\tfor (int j = 0; j < w; j++) {\\n    \\n    \\t\\t\\t\\tint xIdx = x[i][j];\\n    \\t\\t\\t\\tint yIdx = y[i][j];\\n    \\n    \\t\\t\\t\\tint k = 0;\\n    \\t\\t\\t\\twhile (k <= Math.min((xIdx - j), (yIdx - i))\\n    \\t\\t\\t\\t\\t\\t&& matrix[i + k][j + k] == '1') {\\n    \\n    \\t\\t\\t\\t\\txIdx = Math.min(xIdx, x[i+k][j+k]);\\n    \\t\\t\\t\\t\\tyIdx = Math.min(yIdx, y[i+k][j+k]);\\n    \\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tif ((xIdx - j + 1) * (yIdx - i + 1) <= maxArea) {\\n    \\t\\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tint wArea = (k + 1) * (xIdx - j + 1);\\n    \\t\\t\\t\\t\\tint hArea = (k + 1) * (yIdx - i + 1);\\n    \\t\\t\\t\\t\\tif (wArea > maxArea) {\\n    \\t\\t\\t\\t\\t\\tmaxArea = wArea;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\tif (hArea > maxArea) {\\n    \\t\\t\\t\\t\\t\\tmaxArea = hArea;\\n    \\t\\t\\t\\t\\t}\\n    \\n    \\t\\t\\t\\t\\tk++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\treturn maxArea;\\n    \\t}\\n    \\n    \\tprivate int[][] getX(char[][] matrix, int h, int w) {\\n    \\n    \\t\\tint[][] res = new int[h][w];\\n    \\n    \\t\\tfor (int i = h - 1; i >= 0; i--) {\\n    \\t\\t\\tint curr = -1;\\n    \\t\\t\\tfor (int j = w - 1; j >= 0; j--) {\\n    \\t\\t\\t\\tif (matrix[i][j] == '1') {\\n    \\t\\t\\t\\t\\tif (curr == -1) {\\n    \\t\\t\\t\\t\\t\\tcurr = j;\\n    \\t\\t\\t\\t\\t}\\n    \\n    \\t\\t\\t\\t} else {\\n    \\t\\t\\t\\t\\tcurr = -1;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tres[i][j] = curr;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n    \\n    \\tprivate int[][] getY(char[][] matrix, int h, int w) {\\n    \\n    \\t\\tint[][] res = new int[h][w];\\n    \\n    \\t\\tfor (int j = w - 1; j >= 0; j--) {\\n    \\t\\t\\tint curr = -1;\\n    \\t\\t\\tfor (int i = h - 1; i >= 0; i--) {\\n    \\t\\t\\t\\tif (matrix[i][j] == '1') {\\n    \\t\\t\\t\\t\\tif (curr == -1) {\\n    \\t\\t\\t\\t\\t\\tcurr = i;\\n    \\t\\t\\t\\t\\t}\\n    \\n    \\t\\t\\t\\t} else {\\n    \\t\\t\\t\\t\\tcurr = -1;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tres[i][j] = curr;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n    \\t\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int maximalRectangle(char[][] matrix) {\\n    \\n    \\t\\tint h = matrix.length;\\n    \\t\\tif (h == 0) {\\n    \\t\\t\\treturn 0;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3898796,
                "title": "java-solution-stack-based-on-aditya-verma-approach-using-maximum-area-of-histogram-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair<T, U> {\\n    public final T first;\\n    public final U second;\\n\\n    public Pair(T first, U second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[] nums = new int[m];\\n        for (int j = 0; j < m; j++) {\\n            nums[j] = matrix[0][j] - \\'0\\';\\n        }\\n        int max = maximumAreaHistogram(nums);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    nums[j] = 0;\\n                } else {\\n                    nums[j] += (matrix[i][j] - \\'0\\');\\n                }\\n            }\\n            max = Math.max(max, maximumAreaHistogram(nums));\\n        }\\n        return max;\\n    }\\n    public int maximumAreaHistogram(int[] heights) {\\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\\n        int[] left = new int[heights.length];\\n        int pseudoIndex = -1;\\n        //NSL\\n        for (int i = 0; i < heights.length; i++) {\\n            if (stack1.size() == 0) {\\n                left[i] = pseudoIndex;\\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\\n                left[i] = stack1.peek().second;\\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                    stack1.pop();\\n                }\\n                if (stack1.size() == 0) {\\n                    left[i] = pseudoIndex;\\n                } else {\\n                    left[i] = stack1.peek().second;\\n                }\\n            }\\n            stack1.push(new Pair<>(heights[i], i));\\n        }\\n        //NSR\\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\\n        int[] right = new int[heights.length];\\n        pseudoIndex = heights.length;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            if (stack2.size() == 0) {\\n                right[i] = pseudoIndex;\\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\\n                right[i] = stack2.peek().second;\\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                    stack2.pop();\\n                }\\n                if (stack2.size() == 0) {\\n                    right[i] = pseudoIndex;\\n                } else {\\n                    right[i] = stack2.peek().second;\\n                }\\n            }\\n            stack2.push(new Pair<>(heights[i], i));\\n        }\\n\\n        int[] width = new int[heights.length];\\n        for (int i = 0; i < heights.length; i++) {\\n            width[i] = right[i] - left[i] - 1;\\n        }\\n\\n        int[] area = new int[heights.length];\\n        int maxArea = 0;\\n        for (int i = 0; i < heights.length; i++) {\\n            area[i] = heights[i] * width[i];\\n            if (area[i] > maxArea) maxArea = area[i];\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Pair<T, U> {\\n    public final T first;\\n    public final U second;\\n\\n    public Pair(T first, U second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[] nums = new int[m];\\n        for (int j = 0; j < m; j++) {\\n            nums[j] = matrix[0][j] - \\'0\\';\\n        }\\n        int max = maximumAreaHistogram(nums);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    nums[j] = 0;\\n                } else {\\n                    nums[j] += (matrix[i][j] - \\'0\\');\\n                }\\n            }\\n            max = Math.max(max, maximumAreaHistogram(nums));\\n        }\\n        return max;\\n    }\\n    public int maximumAreaHistogram(int[] heights) {\\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\\n        int[] left = new int[heights.length];\\n        int pseudoIndex = -1;\\n        //NSL\\n        for (int i = 0; i < heights.length; i++) {\\n            if (stack1.size() == 0) {\\n                left[i] = pseudoIndex;\\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\\n                left[i] = stack1.peek().second;\\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                    stack1.pop();\\n                }\\n                if (stack1.size() == 0) {\\n                    left[i] = pseudoIndex;\\n                } else {\\n                    left[i] = stack1.peek().second;\\n                }\\n            }\\n            stack1.push(new Pair<>(heights[i], i));\\n        }\\n        //NSR\\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\\n        int[] right = new int[heights.length];\\n        pseudoIndex = heights.length;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            if (stack2.size() == 0) {\\n                right[i] = pseudoIndex;\\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\\n                right[i] = stack2.peek().second;\\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                    stack2.pop();\\n                }\\n                if (stack2.size() == 0) {\\n                    right[i] = pseudoIndex;\\n                } else {\\n                    right[i] = stack2.peek().second;\\n                }\\n            }\\n            stack2.push(new Pair<>(heights[i], i));\\n        }\\n\\n        int[] width = new int[heights.length];\\n        for (int i = 0; i < heights.length; i++) {\\n            width[i] = right[i] - left[i] - 1;\\n        }\\n\\n        int[] area = new int[heights.length];\\n        int maxArea = 0;\\n        for (int i = 0; i < heights.length; i++) {\\n            area[i] = heights[i] * width[i];\\n            if (area[i] > maxArea) maxArea = area[i];\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783795,
                "title": "java-dp",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int maxArea = 0;\\n        int[] heights = new int[matrix[0].length];\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                if(matrix[i][j] == \\'1\\') heights[j]++;\\n                else heights[j] = 0;\\n            }\\n\\n            int area = largestRectangleArea(heights);\\n            maxArea = Math.max(area, maxArea);\\n        }\\n        return maxArea;\\n    }\\n\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n\\n        int[] ls = new int[n];  // next smallest index on the left\\n        ls[0] = -1;\\n        Stack<Integer> st = new Stack<>();\\n        st.push(0);\\n\\n        for(int i = 1; i < n; i++) {\\n            while(st.size() > 0 && heights[i] <= heights[st.peek()]) st.pop();\\n\\n            if(st.size() == 0) ls[i] = -1;\\n            else ls[i] = st.peek();\\n            st.push(i);\\n        }\\n\\n        int[] rs = new int[n];  // next smallest index on the right\\n        rs[n-1] = n;\\n        st = new Stack<>();\\n        st.push(n-1);\\n\\n        for(int i = n-2; i >= 0; i--) {\\n            while(st.size() > 0 && heights[i] <= heights[st.peek()]) st.pop();\\n\\n            if(st.size() == 0) rs[i] = n;\\n            else rs[i] = st.peek();\\n            st.push(i);\\n        }\\n\\n        int maxArea = 0;\\n        for(int i = 0; i < n; i++) {\\n            int width = rs[i] - ls[i] - 1;\\n            int area = heights[i] * width;\\n            maxArea = Math.max(area, maxArea);\\n        } \\n\\n        return maxArea;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int maxArea = 0;\\n        int[] heights = new int[matrix[0].length];\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                if(matrix[i][j] == \\'1\\') heights[j]++;\\n                else heights[j] = 0;\\n            }\\n\\n            int area = largestRectangleArea(heights);\\n            maxArea = Math.max(area, maxArea);\\n        }\\n        return maxArea;\\n    }\\n\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n\\n        int[] ls = new int[n];  // next smallest index on the left\\n        ls[0] = -1;\\n        Stack<Integer> st = new Stack<>();\\n        st.push(0);\\n\\n        for(int i = 1; i < n; i++) {\\n            while(st.size() > 0 && heights[i] <= heights[st.peek()]) st.pop();\\n\\n            if(st.size() == 0) ls[i] = -1;\\n            else ls[i] = st.peek();\\n            st.push(i);\\n        }\\n\\n        int[] rs = new int[n];  // next smallest index on the right\\n        rs[n-1] = n;\\n        st = new Stack<>();\\n        st.push(n-1);\\n\\n        for(int i = n-2; i >= 0; i--) {\\n            while(st.size() > 0 && heights[i] <= heights[st.peek()]) st.pop();\\n\\n            if(st.size() == 0) rs[i] = n;\\n            else rs[i] = st.peek();\\n            st.push(i);\\n        }\\n\\n        int maxArea = 0;\\n        for(int i = 0; i < n; i++) {\\n            int width = rs[i] - ls[i] - 1;\\n            int area = heights[i] * width;\\n            maxArea = Math.max(area, maxArea);\\n        } \\n\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659705,
                "title": "c-dp-simple-solution-w-explanation-easy-histogram-stack",
                "content": "# Intuition\\n1) The problem asks to find the maximum area of a rectangle in a binary matrix.\\n2) We can solve this problem by treating each row of the matrix as a histogram and applying the histogram approach to find the maximum rectangle area.\\n\\n# Approach\\n- Initialize the maxArea variable to 0 to store the maximum area found so far.\\n- Create a vector heights of size cols to track the heights of each column.\\n- Iterate through each row of the matrix.\\n- Update the heights array for the current row:\\n- If the current cell is \\'1\\', increment the height of the column by 1.\\n- If the current cell is \\'0\\', reset the height of the column to 0.\\n- Calculate the maximum area using the histogram approach:\\nUse a stack to maintain a non-decreasing sequence of column heights.\\n- Iterate through each column and compare the current height with the height of the top column in the stack.\\n- If the current height is less than or equal to the height of the top column, pop the top column from the stack and calculate the area using the popped column as the height.\\n- Update the maximum area if necessary.\\n- Push the current column index to the stack.\\n- Update the maximum area if the current area is larger than the previous maximum area.\\n- Return the maximum area found.\\n\\n# Complexity\\n- Time complexity:O(rows * cols)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(cols)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int rows = matrix.size();\\n        if (rows == 0) {\\n            return 0;\\n        }\\n\\n        int cols = matrix[0].size();\\n        int maxArea = 0;\\n\\n        // Create a vector to track the heights of each column\\n        vector<int> heights(cols, 0);\\n\\n        for (int i = 0; i < rows; i++) {\\n            // Update the heights array for the current row\\n            for (int j = 0; j < cols; j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    // If the current cell is \\'1\\', increment the height of the column\\n                    heights[j]++;\\n                } else {\\n                    // If the current cell is \\'0\\', reset the height of the column to 0\\n                    heights[j] = 0;\\n                }\\n            }\\n\\n            // Calculate the maximum area using the histogram approach\\n            stack<int> stk;\\n            int currArea = 0;\\n\\n            for (int j = 0; j <= cols; j++) {\\n                // Process each column and maintain a non-decreasing stack of heights\\n                while (!stk.empty() && (j == cols || heights[j] <= heights[stk.top()])) {\\n                    // The current height is less than the height of the previous column\\n                    int top = heights[stk.top()]; // Get the height of the top column\\n                    stk.pop(); // Pop the top column from the stack\\n                    int breadth = stk.empty() ? j : j - stk.top() - 1;\\n                    // Calculate the breadth of the rectangle using the current column and the previous column\\n                    currArea = max(currArea, top * breadth);\\n                    // Update the maximum area if necessary\\n                }\\n                stk.push(j); // Push the current column index to the stack\\n            }\\n\\n            // Update the maximum area\\n            maxArea = max(maxArea, currArea);\\n        }\\n\\n        return maxArea;\\n    }\\n};\\n\\n```\\n*PLease Upvote If You Find It Helpful.*\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int rows = matrix.size();\\n        if (rows == 0) {\\n            return 0;\\n        }\\n\\n        int cols = matrix[0].size();\\n        int maxArea = 0;\\n\\n        // Create a vector to track the heights of each column\\n        vector<int> heights(cols, 0);\\n\\n        for (int i = 0; i < rows; i++) {\\n            // Update the heights array for the current row\\n            for (int j = 0; j < cols; j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    // If the current cell is \\'1\\', increment the height of the column\\n                    heights[j]++;\\n                } else {\\n                    // If the current cell is \\'0\\', reset the height of the column to 0\\n                    heights[j] = 0;\\n                }\\n            }\\n\\n            // Calculate the maximum area using the histogram approach\\n            stack<int> stk;\\n            int currArea = 0;\\n\\n            for (int j = 0; j <= cols; j++) {\\n                // Process each column and maintain a non-decreasing stack of heights\\n                while (!stk.empty() && (j == cols || heights[j] <= heights[stk.top()])) {\\n                    // The current height is less than the height of the previous column\\n                    int top = heights[stk.top()]; // Get the height of the top column\\n                    stk.pop(); // Pop the top column from the stack\\n                    int breadth = stk.empty() ? j : j - stk.top() - 1;\\n                    // Calculate the breadth of the rectangle using the current column and the previous column\\n                    currArea = max(currArea, top * breadth);\\n                    // Update the maximum area if necessary\\n                }\\n                stk.push(j); // Push the current column index to the stack\\n            }\\n\\n            // Update the maximum area\\n            maxArea = max(maxArea, currArea);\\n        }\\n\\n        return maxArea;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623094,
                "title": "simple-and-efficient-java-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA rectangle can be maximum in three cases:\\n1. Length=1 and Breadth=A positive Integer value.\\n2. Breadth=1 and Heigth=A positive Integer value.\\n3. Both Length and Breadth are positive Integer values.\\n\\n# Approach\\n1. Initially create two arrays as length[][] and breadth[][](below they are considered as h[][] and b[][]).\\n2. By using DP find the maximum length and breadth for each in their respective arrays.\\n3. Find Max value from two arrays.\\n4. For case 3: Both Length and Breadth are positive Integer values.\\n5. create res[][]\\n6. res[i][j] will be fill as mentioned below in code.Find the max value.\\n7. Return max value.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ncode as follows:\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] m) {\\n        int h[][]=new int[m.length+1][m[0].length+1];\\n        int b[][]=new int[m.length+1][m[0].length+1];\\n        int res[][]=new int[m.length][m[0].length];\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<m.length;i++){\\n            for(int j=0;j<m[0].length;j++){\\n                if(m[i][j]==\\'0\\') continue;\\n                else{\\n                    h[i+1][j+1]=h[i][j+1]+1;\\n                    b[i+1][j+1]=b[i+1][j]+1;\\n                    maxi=Math.max(maxi,Math.max(h[i+1][j+1],b[i+1][j+1]));\\n                }\\n            }\\n        }\\n        for(int i=0;i<m.length;i++){\\n            for(int j=0;j<m[0].length;j++){\\n                if(m[i][j]==\\'0\\') continue;\\n                if(b[i][j+1]!=0 && b[i+1][j+1]!=0 && h[i+1][j+1]!=0){\\n                    int val=find(h,b,i,j,Math.min(b[i][j+1],b[i+1][j+1]));\\n                    res[i][j]=val;\\n                    maxi=Math.max(maxi,val);\\n                }\\n                else res[i][j]=1;\\n            }\\n        }\\n        return maxi==Integer.MIN_VALUE?0:maxi;\\n    }\\n    public int find(int[][] h,int[][] b,int i,int j,int len){\\n        int mini=Integer.MIN_VALUE;\\n        int v=0,cur=0;\\n        for(int k=1;k<=len;k++){\\n            if(k==1){\\n                v=h[i+1][j+1];\\n                cur=h[i+1][j+1];\\n            }\\n            else{\\n                cur=Math.min(cur,h[i+1][j+1]);\\n                v=k*cur;\\n            }\\n            mini=Math.max(mini,v);\\n            j--;\\n        }\\n        return mini;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] m) {\\n        int h[][]=new int[m.length+1][m[0].length+1];\\n        int b[][]=new int[m.length+1][m[0].length+1];\\n        int res[][]=new int[m.length][m[0].length];\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<m.length;i++){\\n            for(int j=0;j<m[0].length;j++){\\n                if(m[i][j]==\\'0\\') continue;\\n                else{\\n                    h[i+1][j+1]=h[i][j+1]+1;\\n                    b[i+1][j+1]=b[i+1][j]+1;\\n                    maxi=Math.max(maxi,Math.max(h[i+1][j+1],b[i+1][j+1]));\\n                }\\n            }\\n        }\\n        for(int i=0;i<m.length;i++){\\n            for(int j=0;j<m[0].length;j++){\\n                if(m[i][j]==\\'0\\') continue;\\n                if(b[i][j+1]!=0 && b[i+1][j+1]!=0 && h[i+1][j+1]!=0){\\n                    int val=find(h,b,i,j,Math.min(b[i][j+1],b[i+1][j+1]));\\n                    res[i][j]=val;\\n                    maxi=Math.max(maxi,val);\\n                }\\n                else res[i][j]=1;\\n            }\\n        }\\n        return maxi==Integer.MIN_VALUE?0:maxi;\\n    }\\n    public int find(int[][] h,int[][] b,int i,int j,int len){\\n        int mini=Integer.MIN_VALUE;\\n        int v=0,cur=0;\\n        for(int k=1;k<=len;k++){\\n            if(k==1){\\n                v=h[i+1][j+1];\\n                cur=h[i+1][j+1];\\n            }\\n            else{\\n                cur=Math.min(cur,h[i+1][j+1]);\\n                v=k*cur;\\n            }\\n            mini=Math.max(mini,v);\\n            j--;\\n        }\\n        return mini;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610157,
                "title": "java-code-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[][] mat = new int[row][col];\\n        \\n        for(int i = 0 ; i < row ; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    mat[i][j] = 1;\\n                }else{\\n                    mat[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        int[] curr_row = mat[0];\\n        int curr_sum = max_histogram(curr_row);\\n        \\n        for(int i = 1 ; i < row ; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                if(mat[i][j] == 1){\\n                    curr_row[j] += 1;\\n                }else{\\n                    curr_row[j] = 0;\\n                }\\n            }\\n            int temp = max_histogram(curr_row);\\n            curr_sum = Math.max(curr_sum , temp);\\n        }\\n        return curr_sum;\\n        \\n    }\\n    \\n    public int max_histogram(int[] m){\\n        \\n        Stack<Integer> s1 = new Stack<>();\\n        int[] prev_smaller = new int[m.length];\\n        \\n        for(int i = 0 ; i < m.length ; i++){\\n            while(!s1.isEmpty() && m[s1.peek()] >= m[i]){\\n                s1.pop();\\n            }\\n            \\n            if(s1.isEmpty()){\\n                prev_smaller[i] = -1;\\n            }else{\\n                prev_smaller[i] = s1.peek();\\n            }\\n            s1.push(i);\\n            \\n        }\\n        \\n        Stack<Integer> s2 = new Stack<>();\\n        int[] next_smaller = new int[m.length];\\n        \\n        for(int i = m.length-1 ; i >= 0; i--){\\n            while(!s2.isEmpty() && m[s2.peek()] >= m[i]){\\n                s2.pop();\\n            }\\n            \\n            if(s2.isEmpty()){\\n                next_smaller[i] = m.length;\\n            }else{\\n                next_smaller[i] = s2.peek();\\n            }\\n            s2.push(i);\\n        }\\n        int ans = 0;\\n        \\n        for(int i = 0 ;i < m.length ; i++){\\n            int temp = (next_smaller[i] - prev_smaller[i]-1) * m[i];\\n            ans = Math.max(temp , ans);\\n        }\\n        return ans;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[][] mat = new int[row][col];\\n        \\n        for(int i = 0 ; i < row ; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    mat[i][j] = 1;\\n                }else{\\n                    mat[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        int[] curr_row = mat[0];\\n        int curr_sum = max_histogram(curr_row);\\n        \\n        for(int i = 1 ; i < row ; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                if(mat[i][j] == 1){\\n                    curr_row[j] += 1;\\n                }else{\\n                    curr_row[j] = 0;\\n                }\\n            }\\n            int temp = max_histogram(curr_row);\\n            curr_sum = Math.max(curr_sum , temp);\\n        }\\n        return curr_sum;\\n        \\n    }\\n    \\n    public int max_histogram(int[] m){\\n        \\n        Stack<Integer> s1 = new Stack<>();\\n        int[] prev_smaller = new int[m.length];\\n        \\n        for(int i = 0 ; i < m.length ; i++){\\n            while(!s1.isEmpty() && m[s1.peek()] >= m[i]){\\n                s1.pop();\\n            }\\n            \\n            if(s1.isEmpty()){\\n                prev_smaller[i] = -1;\\n            }else{\\n                prev_smaller[i] = s1.peek();\\n            }\\n            s1.push(i);\\n            \\n        }\\n        \\n        Stack<Integer> s2 = new Stack<>();\\n        int[] next_smaller = new int[m.length];\\n        \\n        for(int i = m.length-1 ; i >= 0; i--){\\n            while(!s2.isEmpty() && m[s2.peek()] >= m[i]){\\n                s2.pop();\\n            }\\n            \\n            if(s2.isEmpty()){\\n                next_smaller[i] = m.length;\\n            }else{\\n                next_smaller[i] = s2.peek();\\n            }\\n            s2.push(i);\\n        }\\n        int ans = 0;\\n        \\n        for(int i = 0 ;i < m.length ; i++){\\n            int temp = (next_smaller[i] - prev_smaller[i]-1) * m[i];\\n            ans = Math.max(temp , ans);\\n        }\\n        return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501899,
                "title": "python-easy-understandable-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        n, m = len(matrix), len(matrix[0])\\n        height = [0] * (m + 1)\\n        res = 0\\n        for row in matrix:\\n            for a in range(m):\\n                height[a] = height[a] + 1 if row[a] == \\'1\\' else 0\\n            stack = [-1]\\n            for a in range(m + 1):\\n                while height[a] < height[stack[-1]]:\\n                    h = height[stack.pop()]\\n                    w = a - stack[-1] - 1\\n                    res = max(res, h * w)\\n                stack.append(a)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Matrix",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        n, m = len(matrix), len(matrix[0])\\n        height = [0] * (m + 1)\\n        res = 0\\n        for row in matrix:\\n            for a in range(m):\\n                height[a] = height[a] + 1 if row[a] == \\'1\\' else 0\\n            stack = [-1]\\n            for a in range(m + 1):\\n                while height[a] < height[stack[-1]]:\\n                    h = height[stack.pop()]\\n                    w = a - stack[-1] - 1\\n                    res = max(res, h * w)\\n                stack.append(a)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292697,
                "title": "javascript-85-maximal-rectangle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- 1-dimensional: https://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nSolution: https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/3297538/javascript-84-largest-rectangle-in-histogram/\\n\\n- 2-dimensional: https://leetcode.com/problems/maximal-rectangle/\\n\\nSolution: below\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nGood one\\n\\n1\\n```\\nvar maximalRectangle = function (aa) {\\n    let m = aa.length,\\n        n = aa[0].length;\\n\\n    let widthOnLeftTillHere = Array.from({ length: m }, () =>\\n        new Array(n).fill(0)\\n    );\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            if (aa[r][c] === \"1\") {\\n                widthOnLeftTillHere[r][c] =\\n                    (widthOnLeftTillHere[r][c - 1] || 0) + 1;\\n            }\\n\\n    let maxArea = 0;\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            if (aa[r][c] === \"1\") {\\n                let minWidthGoingUp = Infinity;\\n                let increasingHeight = 1;\\n                for (let r2 = r; r2 >= 0; r2--, increasingHeight++) {\\n                    minWidthGoingUp = Math.min(\\n                        minWidthGoingUp,\\n                        widthOnLeftTillHere[r2][c]\\n                    );\\n                    maxArea = Math.max(\\n                        maxArea,\\n                        minWidthGoingUp * increasingHeight\\n                    );\\n                }\\n            }\\n    return maxArea;\\n};\\n```\\n\\n2 - Optimized, a bit difficult to understand at begin\\n```\\nfunction maximalRectangle(aa) {\\n    let m = aa.length,\\n        n = aa[0].length;\\n\\n    let heights = new Array(n + 1).fill(0), // this row heights, last col is 0\\n        maxArea = 0;\\n\\n    for (let r = 0; r < m; r++) {\\n        let cols = []; // prev increasing columns - stack\\n        cols.top = () => cols[cols.length - 1]; // get column left on top of stack\\n\\n        for (let c = 0; c <= n; c++) {\\n            if (c < n) {\\n                if (aa[r][c] === \"1\") heights[c]++;\\n                else heights[c] = 0;\\n            }\\n\\n            while (cols.length && heights[cols.top()] > heights[c]) {\\n                let height = heights[cols.pop()]; // prev column height\\n                let width = cols.length ? c - cols.top() - 1 : c; // prev prev column to cur column width\\n                maxArea = Math.max(maxArea, width * height);\\n            }\\n            cols.push(c);\\n        }\\n    }\\n    return maxArea;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximalRectangle = function (aa) {\\n    let m = aa.length,\\n        n = aa[0].length;\\n\\n    let widthOnLeftTillHere = Array.from({ length: m }, () =>\\n        new Array(n).fill(0)\\n    );\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            if (aa[r][c] === \"1\") {\\n                widthOnLeftTillHere[r][c] =\\n                    (widthOnLeftTillHere[r][c - 1] || 0) + 1;\\n            }\\n\\n    let maxArea = 0;\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            if (aa[r][c] === \"1\") {\\n                let minWidthGoingUp = Infinity;\\n                let increasingHeight = 1;\\n                for (let r2 = r; r2 >= 0; r2--, increasingHeight++) {\\n                    minWidthGoingUp = Math.min(\\n                        minWidthGoingUp,\\n                        widthOnLeftTillHere[r2][c]\\n                    );\\n                    maxArea = Math.max(\\n                        maxArea,\\n                        minWidthGoingUp * increasingHeight\\n                    );\\n                }\\n            }\\n    return maxArea;\\n};\\n```\n```\\nfunction maximalRectangle(aa) {\\n    let m = aa.length,\\n        n = aa[0].length;\\n\\n    let heights = new Array(n + 1).fill(0), // this row heights, last col is 0\\n        maxArea = 0;\\n\\n    for (let r = 0; r < m; r++) {\\n        let cols = []; // prev increasing columns - stack\\n        cols.top = () => cols[cols.length - 1]; // get column left on top of stack\\n\\n        for (let c = 0; c <= n; c++) {\\n            if (c < n) {\\n                if (aa[r][c] === \"1\") heights[c]++;\\n                else heights[c] = 0;\\n            }\\n\\n            while (cols.length && heights[cols.top()] > heights[c]) {\\n                let height = heights[cols.pop()]; // prev column height\\n                let width = cols.length ? c - cols.top() - 1 : c; // prev prev column to cur column width\\n                maxArea = Math.max(maxArea, width * height);\\n            }\\n            cols.push(c);\\n        }\\n    }\\n    return maxArea;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3133444,
                "title": "rectangles-in-histogram-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {\\n        let mut histogram = vec![0; matrix[0].len()];\\n        let mut max_area = 0;\\n        for col in matrix {\\n            for (i, c) in col.into_iter().enumerate() {\\n                histogram[i] = if c == \\'0\\' { 0 } else { histogram[i] + 1 }\\n            }\\n            max_area = i32::max(max_area, Self::max_rect(&histogram));\\n        }\\n        max_area\\n    }\\n\\n    fn max_rect(histogram: &Vec<i32>) -> i32 {\\n        let (mut max_area, mut width, n) = (0, 0, histogram.len());\\n        let mut stack = Vec::with_capacity(n);\\n\\n        (0..n).for_each(|cur| {\\n            while let Some(&last) = stack.last() {\\n                if histogram[last] > histogram[cur] {\\n                    stack.pop();\\n                    width = if let Some(&prev) = stack.last() { cur - prev - 1 } else { cur };\\n                    max_area = i32::max(max_area, width as i32 * histogram[last]);\\n                } else { break; }\\n            }\\n            stack.push(cur);\\n        });\\n\\n        while let Some(last) = stack.pop() {\\n            width = if let Some(&prev) = stack.last() { n - prev - 1 } else { n };\\n            max_area = i32::max(max_area, width as i32 * histogram[last]);\\n        }\\n\\n        max_area\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {\\n        let mut histogram = vec![0; matrix[0].len()];\\n        let mut max_area = 0;\\n        for col in matrix {\\n            for (i, c) in col.into_iter().enumerate() {\\n                histogram[i] = if c == \\'0\\' { 0 } else { histogram[i] + 1 }\\n            }\\n            max_area = i32::max(max_area, Self::max_rect(&histogram));\\n        }\\n        max_area\\n    }\\n\\n    fn max_rect(histogram: &Vec<i32>) -> i32 {\\n        let (mut max_area, mut width, n) = (0, 0, histogram.len());\\n        let mut stack = Vec::with_capacity(n);\\n\\n        (0..n).for_each(|cur| {\\n            while let Some(&last) = stack.last() {\\n                if histogram[last] > histogram[cur] {\\n                    stack.pop();\\n                    width = if let Some(&prev) = stack.last() { cur - prev - 1 } else { cur };\\n                    max_area = i32::max(max_area, width as i32 * histogram[last]);\\n                } else { break; }\\n            }\\n            stack.push(cur);\\n        });\\n\\n        while let Some(last) = stack.pop() {\\n            width = if let Some(&prev) = stack.last() { n - prev - 1 } else { n };\\n            max_area = i32::max(max_area, width as i32 * histogram[last]);\\n        }\\n\\n        max_area\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2999576,
                "title": "java-solution-easiest-solution-build-on-top-of-leetcode84",
                "content": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        // for each cell with value=1,\\n        // we look upward (north), the number of continuous \\'1\\' is the height of cell\\n        int[] heights = new int[matrix[0].length];\\n        int maxArea=-1;\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j]==\\'0\\'){\\n                    heights[j] = 0;\\n                } else {\\n                    heights[j] ++;\\n                }\\n            }            \\n            int area = yourLeetCode84Method(heights);\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }  \\n}\\n\\n// Output -\\n/*\\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\\nOutput: 6\\nExplanation: The maximal rectangle is shown in the above picture.\\n*/\\n\\n// Algorithm -\\n/*\\nUse Largest Rectangle in Histogram\\n1. We first initialize the heights array with all zeros.\\n2. We then iterate through the matrix and for each cell with value=1, we look upward (north), the number of continuous \\'1\\' is the height of cell.\\n3. We then calculate the area of the rectangle with the largest area.\\n*/\\n\\n// Time & Space Complexity -\\n/*\\nTime - O(R x C), Only one traversal of the matrix is required, so the time complexity is O(R X C)\\nSpace - O(C), Stack is required to store the columns, so space complexity is O(C)\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        // for each cell with value=1,\\n        // we look upward (north), the number of continuous \\'1\\' is the height of cell\\n        int[] heights = new int[matrix[0].length];\\n        int maxArea=-1;\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j]==\\'0\\'){\\n                    heights[j] = 0;\\n                } else {\\n                    heights[j] ++;\\n                }\\n            }            \\n            int area = yourLeetCode84Method(heights);\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }  \\n}\\n\\n// Output -\\n/*\\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\\nOutput: 6\\nExplanation: The maximal rectangle is shown in the above picture.\\n*/\\n\\n// Algorithm -\\n/*\\nUse Largest Rectangle in Histogram\\n1. We first initialize the heights array with all zeros.\\n2. We then iterate through the matrix and for each cell with value=1, we look upward (north), the number of continuous \\'1\\' is the height of cell.\\n3. We then calculate the area of the rectangle with the largest area.\\n*/\\n\\n// Time & Space Complexity -\\n/*\\nTime - O(R x C), Only one traversal of the matrix is required, so the time complexity is O(R X C)\\nSpace - O(C), Stack is required to store the columns, so space complexity is O(C)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893444,
                "title": "brute-force-tle-and-optimal-dp-in-python",
                "content": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix):\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        max_area = 0\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                for width in range(1, cols-j+1):\\n                    for height in range(1, rows-i+1):\\n                        is_rectangle = True # is composed only of 1\\'s\\n                        for k in range(i, i+height):\\n                            for l in range(j, j+width):\\n                                if matrix[k][l] != \"1\": # If we find a cell that is not 1, rectangle is not valid\\n                                    is_rectangle = False\\n                                    break\\n                                if not is_rectangle:\\n                                    break\\n                        if is_rectangle:\\n                            area = width * height\\n                            max_area = max(max_area, area)\\n        return max_area\\n```\\n\\t\\n\\n1.  DP\\n\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix: # Return 0 if the matrix is empty\\n            return 0\\n\\n        m, n = len(matrix), len(matrix[0]) # Get the number of rows and columns in the matrix\\n\\n        # Initialize three arrays to store the number of consecutive 1\\'s to the left of each cell,\\n        # the number of consecutive 1\\'s to the right of each cell, and the height of each cell\\n        left, right, height = [0] * n, [n] * n, [0] * n\\n\\n        # Initialize the maximum possible area to 0\\n        max_area = 0\\n\\n        # Iterate over each row in the matrix\\n        for i in range(m):\\n            # Initialize the current left and right indices to 0 and n respectively\\n            cur_left, cur_right = 0, n\\n\\n            # Iterate over each column in the matrix to compute the height of each cell\\n            for j in range(n):\\n                # If the cell is a 1, increment the height of the cell\\n                if matrix[i][j] == \"1\":\\n                    height[j] += 1\\n                else:\\n                    height[j] = 0\\n\\n            # Iterate over each column in the matrix to compute the number of consecutive 1\\'s\\n            # to the left of each cell\\n            for j in range(n):\\n                # If the cell is a 1, update the number of consecutive 1\\'s to the left of the cell\\n                # to be the maximum of the current value and the current left index\\n                if matrix[i][j] == \"1\":\\n                    left[j] = max(left[j], cur_left)\\n                else:\\n                    # If the cell is a 0, reset the number of consecutive 1\\'s to the left of the cell to 0\\n                    # and update the current left index to be the current column index plus 1\\n                    left[j] = 0\\n                    cur_left = j + 1\\n\\n            # Iterate over each column in the matrix to compute the number of consecutive 1\\'s\\n            # to the right of each cell\\n            for j in range(n - 1, -1, -1):\\n                # If the cell is a 1, update the number of consecutive 1\\'s to the right of the cell\\n                # to be the minimum of the current value and the current right index\\n                if matrix[i][j] == \"1\":\\n                    right[j] = min(right[j], cur_right)\\n                else:\\n                    # If the cell is a 0, reset the number of consecutive 1\\'s to the right of the cell to n\\n                    # and update\\n                    # the current right index to be the current column index\\n                    right[j] = n\\n                    cur_right = j\\n\\n            # Iterate over each column in the matrix to compute the maximum possible area of a rectangle\\n            # with the given heights\\n            for j in range(n):\\n                # Update the maximum possible area to be the maximum of the current value and the area of\\n                # the rectangle with the given height, left, and right values\\n                max_area = max(max_area, (right[j] - left[j]) * height[j])\\n\\n        # Return the maximum possible area\\n        return max_area\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix):\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        max_area = 0\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                for width in range(1, cols-j+1):\\n                    for height in range(1, rows-i+1):\\n                        is_rectangle = True # is composed only of 1\\'s\\n                        for k in range(i, i+height):\\n                            for l in range(j, j+width):\\n                                if matrix[k][l] != \"1\": # If we find a cell that is not 1, rectangle is not valid\\n                                    is_rectangle = False\\n                                    break\\n                                if not is_rectangle:\\n                                    break\\n                        if is_rectangle:\\n                            area = width * height\\n                            max_area = max(max_area, area)\\n        return max_area\\n```\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix: # Return 0 if the matrix is empty\\n            return 0\\n\\n        m, n = len(matrix), len(matrix[0]) # Get the number of rows and columns in the matrix\\n\\n        # Initialize three arrays to store the number of consecutive 1\\'s to the left of each cell,\\n        # the number of consecutive 1\\'s to the right of each cell, and the height of each cell\\n        left, right, height = [0] * n, [n] * n, [0] * n\\n\\n        # Initialize the maximum possible area to 0\\n        max_area = 0\\n\\n        # Iterate over each row in the matrix\\n        for i in range(m):\\n            # Initialize the current left and right indices to 0 and n respectively\\n            cur_left, cur_right = 0, n\\n\\n            # Iterate over each column in the matrix to compute the height of each cell\\n            for j in range(n):\\n                # If the cell is a 1, increment the height of the cell\\n                if matrix[i][j] == \"1\":\\n                    height[j] += 1\\n                else:\\n                    height[j] = 0\\n\\n            # Iterate over each column in the matrix to compute the number of consecutive 1\\'s\\n            # to the left of each cell\\n            for j in range(n):\\n                # If the cell is a 1, update the number of consecutive 1\\'s to the left of the cell\\n                # to be the maximum of the current value and the current left index\\n                if matrix[i][j] == \"1\":\\n                    left[j] = max(left[j], cur_left)\\n                else:\\n                    # If the cell is a 0, reset the number of consecutive 1\\'s to the left of the cell to 0\\n                    # and update the current left index to be the current column index plus 1\\n                    left[j] = 0\\n                    cur_left = j + 1\\n\\n            # Iterate over each column in the matrix to compute the number of consecutive 1\\'s\\n            # to the right of each cell\\n            for j in range(n - 1, -1, -1):\\n                # If the cell is a 1, update the number of consecutive 1\\'s to the right of the cell\\n                # to be the minimum of the current value and the current right index\\n                if matrix[i][j] == \"1\":\\n                    right[j] = min(right[j], cur_right)\\n                else:\\n                    # If the cell is a 0, reset the number of consecutive 1\\'s to the right of the cell to n\\n                    # and update\\n                    # the current right index to be the current column index\\n                    right[j] = n\\n                    cur_right = j\\n\\n            # Iterate over each column in the matrix to compute the maximum possible area of a rectangle\\n            # with the given heights\\n            for j in range(n):\\n                # Update the maximum possible area to be the maximum of the current value and the area of\\n                # the rectangle with the given height, left, and right values\\n                max_area = max(max_area, (right[j] - left[j]) * height[j])\\n\\n        # Return the maximum possible area\\n        return max_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863424,
                "title": "dp-python-solution-o-m-n-2",
                "content": "# Intuition\\nDP\\n\\n# Approach\\nReduce overlapping counting\\n\\n# Complexity\\n- Time complexity:\\nO(M * N ^ 2)\\n\\n- Space complexity:\\nO(M * N)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        # 1 0 1 2 3        \\n        # 0 1 0 1 0       \\n        # 1 2 0 1 2\\n        # 1 2 0 1 2\\n        # 0 1 2 3 4\\n\\n        M, N = len(matrix), len(matrix[0])\\n        dp = [[0] * N for _  in range(M)]\\n\\n        for i in range(M):\\n            dp[i][0] = 1 if matrix[i][0] == \\'1\\' else 0\\n        \\n        for i in range(M):\\n            for j in range(1, N):\\n                if matrix[i][j] == \\'1\\':\\n                    if dp[i][j - 1]:\\n                        dp[i][j] = dp[i][j - 1] + 1\\n                    else:\\n                        dp[i][j] = 1\\n        \\n        ret = 0\\n        for j in range(N):\\n            column = []\\n            for i in range(M):\\n                column.append(dp[i][j])\\n            \\n            for p in range(len(column)):\\n                left = right = p\\n                val = column[p]\\n\\n                cnt = 1\\n                while left >= 0 and column[left] >= val:\\n                    if left != p:\\n                        cnt += 1\\n                    left -= 1\\n                \\n                while right < len(column) and column[right] >= val:\\n                    if right != p:\\n                        cnt += 1\\n                    right += 1\\n                \\n                ret = max(ret, val * cnt)\\n                        \\n        return ret\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        # 1 0 1 2 3        \\n        # 0 1 0 1 0       \\n        # 1 2 0 1 2\\n        # 1 2 0 1 2\\n        # 0 1 2 3 4\\n\\n        M, N = len(matrix), len(matrix[0])\\n        dp = [[0] * N for _  in range(M)]\\n\\n        for i in range(M):\\n            dp[i][0] = 1 if matrix[i][0] == \\'1\\' else 0\\n        \\n        for i in range(M):\\n            for j in range(1, N):\\n                if matrix[i][j] == \\'1\\':\\n                    if dp[i][j - 1]:\\n                        dp[i][j] = dp[i][j - 1] + 1\\n                    else:\\n                        dp[i][j] = 1\\n        \\n        ret = 0\\n        for j in range(N):\\n            column = []\\n            for i in range(M):\\n                column.append(dp[i][j])\\n            \\n            for p in range(len(column)):\\n                left = right = p\\n                val = column[p]\\n\\n                cnt = 1\\n                while left >= 0 and column[left] >= val:\\n                    if left != p:\\n                        cnt += 1\\n                    left -= 1\\n                \\n                while right < len(column) and column[right] >= val:\\n                    if right != p:\\n                        cnt += 1\\n                    right += 1\\n                \\n                ret = max(ret, val * cnt)\\n                        \\n        return ret\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634280,
                "title": "simple-cpp-o-r-c-solution-using-largest-rectangle-in-histogram-function",
                "content": "\\n```\\n int maxRectangleHistogram(vector<int>h,int n){\\n        stack<int>s;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            while(s.empty()==false && h[s.top()]>=h[i]){\\n                int tp=s.top();\\n                s.pop();\\n                int curr=h[tp]*(s.empty()? i : (i-1-s.top()));\\n                res=max(curr,res);\\n            }\\n            s.push(i);\\n        }\\n        while(!s.empty()){\\n            int tp=s.top();\\n            s.pop();\\n            int curr=h[tp]*(s.empty()? n : (n-1-s.top()));\\n            res=max(curr,res);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    int maximalRectangle(vector<vector<char>>& mat) {\\n        int r=mat.size();\\n        int c=mat[0].size();\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        for(int i=0;i<c;i++){\\n            if(mat[0][i]==\\'1\\')\\n                v.push_back(1);\\n            else v.push_back(0);\\n        }\\n        ans.push_back(v);\\n        for(int i=1;i<r;i++){\\n            vector<int>k;\\n            for(int j=0;j<c;j++){\\n                if(mat[i][j]==\\'1\\')\\n                    k.push_back(1+ans[i-1][j]);\\n                else k.push_back(0);\\n            }\\n            ans.push_back(k);\\n        }\\n        int res=0;\\n        for(int i=0;i<ans.size();i++){\\n           int curr=maxRectangleHistogram(ans[i], ans[i].size());\\n            res=max(curr,res);\\n        }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n int maxRectangleHistogram(vector<int>h,int n){\\n        stack<int>s;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            while(s.empty()==false && h[s.top()]>=h[i]){\\n                int tp=s.top();\\n                s.pop();\\n                int curr=h[tp]*(s.empty()? i : (i-1-s.top()));\\n                res=max(curr,res);\\n            }\\n            s.push(i);\\n        }\\n        while(!s.empty()){\\n            int tp=s.top();\\n            s.pop();\\n            int curr=h[tp]*(s.empty()? n : (n-1-s.top()));\\n            res=max(curr,res);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    int maximalRectangle(vector<vector<char>>& mat) {\\n        int r=mat.size();\\n        int c=mat[0].size();\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        for(int i=0;i<c;i++){\\n            if(mat[0][i]==\\'1\\')\\n                v.push_back(1);\\n            else v.push_back(0);\\n        }\\n        ans.push_back(v);\\n        for(int i=1;i<r;i++){\\n            vector<int>k;\\n            for(int j=0;j<c;j++){\\n                if(mat[i][j]==\\'1\\')\\n                    k.push_back(1+ans[i-1][j]);\\n                else k.push_back(0);\\n            }\\n            ans.push_back(k);\\n        }\\n        int res=0;\\n        for(int i=0;i<ans.size();i++){\\n           int curr=maxRectangleHistogram(ans[i], ans[i].size());\\n            res=max(curr,res);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2492426,
                "title": "simple-concise-c-solution-based-on-histogram-o-n-2-time-complexity",
                "content": "### Simple C++ Solution based on histogram question\\n---\\n\\nIf you haven\\'t done histogram question then complete it first because it concept is same just with one extra loop.\\n\\nTime Complexity - O(N^2)\\n\\nSpace Complexity -  O(N)\\n\\n```\\n    int maximalRectangle(vector<vector<char>> &m)\\n    {\\n        int ans = 0;\\n        vector<int> sums(m[0].size(), 0);\\n        for (int i = 0; i < m.size(); i++)\\n        {\\n            // From here histogram solution starts\\n            stack<int> st;\\n            for (int j = 0; j <= sums.size(); j++)\\n            {\\n                // Summing up each row in sums vector but replacing with zero if current element is zero\\n                if(j != sums.size())\\n                    sums[j] += (m[i][j] == \\'0\\') ? -sums[j] : m[i][j] - \\'0\\';\\n                \\n                // Simple increasing Montonic Stack\\n                while (!st.empty() && (j == sums.size() || sums[st.top()] >= sums[j]))\\n                {\\n                    int height = sums[st.top()], width;\\n                    st.pop();\\n                    width = (st.empty()) ? j : j - st.top() - 1;\\n                    ans = max(ans, width * height);\\n                }\\n                st.push(j);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int maximalRectangle(vector<vector<char>> &m)\\n    {\\n        int ans = 0;\\n        vector<int> sums(m[0].size(), 0);\\n        for (int i = 0; i < m.size(); i++)\\n        {\\n            // From here histogram solution starts\\n            stack<int> st;\\n            for (int j = 0; j <= sums.size(); j++)\\n            {\\n                // Summing up each row in sums vector but replacing with zero if current element is zero\\n                if(j != sums.size())\\n                    sums[j] += (m[i][j] == \\'0\\') ? -sums[j] : m[i][j] - \\'0\\';\\n                \\n                // Simple increasing Montonic Stack\\n                while (!st.empty() && (j == sums.size() || sums[st.top()] >= sums[j]))\\n                {\\n                    int height = sums[st.top()], width;\\n                    st.pop();\\n                    width = (st.empty()) ? j : j - st.top() - 1;\\n                    ans = max(ans, width * height);\\n                }\\n                st.push(j);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2355547,
                "title": "c-solution-maximal-rectangle",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(int *arr , int n){\\n        stack<int> st;\\n        st.push(-1);\\n        vector<int> ans(n);\\n        \\n        for(int i = n - 1 ; i >= 0 ; i--){\\n            int curr = arr[i];\\n            \\n            while(st.top() != -1 && arr[st.top()] >= curr){\\n                st.pop();\\n            }\\n            \\n            ans[i] = st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(int *arr , int n){\\n        stack<int> st;\\n        st.push(-1);\\n        vector<int> ans(n);\\n        \\n        for(int i = 0; i < n ; i++){\\n            int curr = arr[i];\\n            \\n            while(st.top() != -1 && arr[st.top()] >= curr){\\n                st.pop();\\n            }\\n            \\n            ans[i] = st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    int largestRectangleArea(int * heights , int n){\\n        int area = INT_MIN;\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights , n);\\n        \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights , n);\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            int length = heights[i];\\n            \\n            if(next[i] == -1)\\n                next[i] = n;\\n            \\n            int breadth = next[i] - prev[i] - 1;\\n            int newArea = length * breadth;\\n            area = max(area , newArea);\\n        }\\n        return area;\\n    }\\n    \\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int M[n][m];\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                M[i][j] = matrix[i][j] - \\'0\\';\\n            }\\n        }\\n                \\n        //step 1 : compute area of 1st row\\n        int area = largestRectangleArea(M[0] , m);\\n        \\n        for(int i = 1 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                \\n        //step 2 : add upar wala element if it is 1\\n                if(M[i][j] != 0)\\n                    M[i][j] = M[i][j] + M[i-1][j];\\n                    \\n                else\\n                    M[i][j] = 0;\\n            }\\n            \\n            area = max(area , largestRectangleArea(M[i] , m));\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(int *arr , int n){\\n        stack<int> st;\\n        st.push(-1);\\n        vector<int> ans(n);\\n        \\n        for(int i = n - 1 ; i >= 0 ; i--){\\n            int curr = arr[i];\\n            \\n            while(st.top() != -1 && arr[st.top()] >= curr){\\n                st.pop();\\n            }\\n            \\n            ans[i] = st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(int *arr , int n){\\n        stack<int> st;\\n        st.push(-1);\\n        vector<int> ans(n);\\n        \\n        for(int i = 0; i < n ; i++){\\n            int curr = arr[i];\\n            \\n            while(st.top() != -1 && arr[st.top()] >= curr){\\n                st.pop();\\n            }\\n            \\n            ans[i] = st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    int largestRectangleArea(int * heights , int n){\\n        int area = INT_MIN;\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights , n);\\n        \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights , n);\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            int length = heights[i];\\n            \\n            if(next[i] == -1)\\n                next[i] = n;\\n            \\n            int breadth = next[i] - prev[i] - 1;\\n            int newArea = length * breadth;\\n            area = max(area , newArea);\\n        }\\n        return area;\\n    }\\n    \\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int M[n][m];\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                M[i][j] = matrix[i][j] - \\'0\\';\\n            }\\n        }\\n                \\n        //step 1 : compute area of 1st row\\n        int area = largestRectangleArea(M[0] , m);\\n        \\n        for(int i = 1 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                \\n        //step 2 : add upar wala element if it is 1\\n                if(M[i][j] != 0)\\n                    M[i][j] = M[i][j] + M[i-1][j];\\n                    \\n                else\\n                    M[i][j] = 0;\\n            }\\n            \\n            area = max(area , largestRectangleArea(M[i] , m));\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320046,
                "title": "c-simple-and-easy-approach-problem-similar-to-max-area-rectangle-histogram",
                "content": "Comment down if you have any questions! \\n```\\nclass Solution {\\npublic:\\n      int f(vector<int>& histo) {\\n      stack < int > st;\\n      int maxA = 0;\\n      int n = histo.size();\\n      for (int i = 0; i <= n; i++) {\\n        while (!st.empty() && (i == n || histo[st.top()] >= histo[i])) {\\n          int height = histo[st.top()];\\n          st.pop();\\n          int width;\\n          if (st.empty())\\n            width = i;\\n          else\\n            width = i - st.top() - 1;\\n          maxA = max(maxA, width * height);\\n        }\\n        st.push(i);\\n      }\\n      return maxA;\\n \\n\\n        \\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int size=matrix[0].size(); \\n        vector<int>v(size,0);\\n        int maxi=0;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==\\'1\\'){\\n                    int ans=v[j]; \\n                    v[j]=ans+1;\\n                }\\n                else{\\n                    v[j]=0;\\n                }\\n            }\\n            \\n            maxi=max(maxi,f(v));\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n      int f(vector<int>& histo) {\\n      stack < int > st;\\n      int maxA = 0;\\n      int n = histo.size();\\n      for (int i = 0; i <= n; i++) {\\n        while (!st.empty() && (i == n || histo[st.top()] >= histo[i])) {\\n          int height = histo[st.top()];\\n          st.pop();\\n          int width;\\n          if (st.empty())\\n            width = i;\\n          else\\n            width = i - st.top() - 1;\\n          maxA = max(maxA, width * height);\\n        }\\n        st.push(i);\\n      }\\n      return maxA;\\n \\n\\n        \\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int size=matrix[0].size(); \\n        vector<int>v(size,0);\\n        int maxi=0;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==\\'1\\'){\\n                    int ans=v[j]; \\n                    v[j]=ans+1;\\n                }\\n                else{\\n                    v[j]=0;\\n                }\\n            }\\n            \\n            maxi=max(maxi,f(v));\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187181,
                "title": "c-using-maximum-area-rectangle-in-histogram-stack",
                "content": "```\\nclass Solution {\\npublic:\\nint largestRectangleInHistogram(vector<int>& heights) {    \\n        stack<pair<int,int>> s1;\\n        \\n        int n=heights.size();\\n        \\n        //We Will Find Next Smaller element to left and right for all elements in heights vector\\n        \\n        //Nearest Smallest To Left\\n        vector<int> nsl(n,-1);  //To store index to nsl\\n        //if nsl not present default value is -1\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s1.empty() && s1.top().second>=heights[i])\\n                s1.pop();\\n            \\n            if(s1.empty())\\n                nsl[i]=-1;\\n            else \\n                nsl[i]=s1.top().first;\\n            \\n            s1.push({i,heights[i]});\\n        }\\n        \\n        //Nearest Smallest To Right\\n        stack<pair<int,int>> s2;\\n        \\n        vector<int> nsr(n,n);  //To store index to nsr\\n        //if nsr not present default value is n\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!s2.empty() && s2.top().second>=heights[i])\\n                s2.pop();\\n            \\n            if(s2.empty())\\n                nsr[i]=n;\\n            else \\n                nsr[i]=s2.top().first;\\n            \\n            s2.push({i,heights[i]});\\n        }\\n        \\n        \\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int h=heights[i];\\n            int w=nsr[i]-nsl[i]-1; //Width\\n            int largestArea=w*h;  //Minus Beacuse it is added 2 times \\n            ans=max(ans,largestArea);\\n        }\\n        return ans;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();  //Number of Rows\\n        int n=matrix[0].size();  //size of every row\\n        vector<int> h(n,0);  //Stores 1-d histogram of level row in matrix\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==\\'0\\') h[j]=0;\\n                else h[j]+=1;\\n            }\\n             int area=largestRectangleInHistogram(h);\\n             ans=max(ans,area);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint largestRectangleInHistogram(vector<int>& heights) {    \\n        stack<pair<int,int>> s1;\\n        \\n        int n=heights.size();\\n        \\n        //We Will Find Next Smaller element to left and right for all elements in heights vector\\n        \\n        //Nearest Smallest To Left\\n        vector<int> nsl(n,-1);  //To store index to nsl\\n        //if nsl not present default value is -1\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s1.empty() && s1.top().second>=heights[i])\\n                s1.pop();\\n            \\n            if(s1.empty())\\n                nsl[i]=-1;\\n            else \\n                nsl[i]=s1.top().first;\\n            \\n            s1.push({i,heights[i]});\\n        }\\n        \\n        //Nearest Smallest To Right\\n        stack<pair<int,int>> s2;\\n        \\n        vector<int> nsr(n,n);  //To store index to nsr\\n        //if nsr not present default value is n\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!s2.empty() && s2.top().second>=heights[i])\\n                s2.pop();\\n            \\n            if(s2.empty())\\n                nsr[i]=n;\\n            else \\n                nsr[i]=s2.top().first;\\n            \\n            s2.push({i,heights[i]});\\n        }\\n        \\n        \\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int h=heights[i];\\n            int w=nsr[i]-nsl[i]-1; //Width\\n            int largestArea=w*h;  //Minus Beacuse it is added 2 times \\n            ans=max(ans,largestArea);\\n        }\\n        return ans;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();  //Number of Rows\\n        int n=matrix[0].size();  //size of every row\\n        vector<int> h(n,0);  //Stores 1-d histogram of level row in matrix\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==\\'0\\') h[j]=0;\\n                else h[j]+=1;\\n            }\\n             int area=largestRectangleInHistogram(h);\\n             ans=max(ans,area);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148614,
                "title": "c-simple-histogram-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int max(int a,int b) {\\n        return a>b ? a: b;\\n    }\\n    int max_histgram_area(int *arr,int n) {\\n        int ans=0;\\n        stack<int>s;\\n        int tp,max_area_with_tp;\\n        int i=0;\\n        while(i<n) {\\n            if(s.empty() || arr[s.top()]<=arr[i]) {\\n                s.push(i++);\\n            } else {\\n                tp=s.top(); \\n                s.pop();\\n                max_area_with_tp = arr[tp] * (s.empty() ? i : i-s.top()-1);\\n                ans= max(ans,max_area_with_tp);\\n            }\\n        }\\n        \\n        while(s.empty() == false) {\\n            tp=s.top(); \\n            s.pop();\\n            max_area_with_tp = arr[tp] * (s.empty() ? i : i-s.top()-1);\\n            ans= max(ans,max_area_with_tp);\\n        }\\n        return ans;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        long long int ans=0;\\n        int arr[201]= {0};\\n        for(int i=0;i<matrix.size();i++) {\\n            for(int j=0;j<matrix[0].size();j++) {\\n                if(matrix[i][j] == \\'0\\') {\\n                    arr[j]=0;\\n                }\\n                else {\\n                    arr[j]++;\\n                }\\n            }\\n            int tmp = max_histgram_area(arr, matrix[0].size());\\n            if(tmp>ans) ans=tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int max(int a,int b) {\\n        return a>b ? a: b;\\n    }\\n    int max_histgram_area(int *arr,int n) {\\n        int ans=0;\\n        stack<int>s;\\n        int tp,max_area_with_tp;\\n        int i=0;\\n        while(i<n) {\\n            if(s.empty() || arr[s.top()]<=arr[i]) {\\n                s.push(i++);\\n            } else {\\n                tp=s.top(); \\n                s.pop();\\n                max_area_with_tp = arr[tp] * (s.empty() ? i : i-s.top()-1);\\n                ans= max(ans,max_area_with_tp);\\n            }\\n        }\\n        \\n        while(s.empty() == false) {\\n            tp=s.top(); \\n            s.pop();\\n            max_area_with_tp = arr[tp] * (s.empty() ? i : i-s.top()-1);\\n            ans= max(ans,max_area_with_tp);\\n        }\\n        return ans;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        long long int ans=0;\\n        int arr[201]= {0};\\n        for(int i=0;i<matrix.size();i++) {\\n            for(int j=0;j<matrix[0].size();j++) {\\n                if(matrix[i][j] == \\'0\\') {\\n                    arr[j]=0;\\n                }\\n                else {\\n                    arr[j]++;\\n                }\\n            }\\n            int tmp = max_histgram_area(arr, matrix[0].size());\\n            if(tmp>ans) ans=tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127018,
                "title": "using-stack-with-reference-to-nearest-smallest-element-to-left-right",
                "content": "*Time : O(Mx2N) & space O(N)*\\n\\n```\\nclass Solution {\\nprivate:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<pair<int, int>> st;\\n        int n = heights.size();\\n        vector<int> nsl(n), nsr(n), area;\\n        for(int i=0; i<n; i++) {  // Nearest Smallest Element to Left\\n            while(!st.empty() && st.top().first >= heights[i]) st.pop();\\n            if(st.empty()) nsl[i] = -1;\\n            else nsl[i] = st.top().second;\\n            st.push({heights[i], i});\\n        }\\n        while(!st.empty()) st.pop();\\n        for(int i=n-1; i>=0; i--) { // Nearest Smallest Element to Right\\n            while(!st.empty() && st.top().first >= heights[i]) st.pop();\\n            if(st.empty()) nsr[i] = n;\\n            else nsr[i] = st.top().second;\\n            st.push({heights[i], i});\\n        }\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            int width = nsr[i]-nsl[i]-1;\\n            area.push_back(heights[i]*width);\\n            ans = max(ans, area[i]);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int area = 0;\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> heights(n, 0);\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(matrix[i][j] == \\'1\\') heights[j]++;\\n                else heights[j] = 0;\\n            }\\n            area = max(area, largestRectangleArea(heights));\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<pair<int, int>> st;\\n        int n = heights.size();\\n        vector<int> nsl(n), nsr(n), area;\\n        for(int i=0; i<n; i++) {  // Nearest Smallest Element to Left\\n            while(!st.empty() && st.top().first >= heights[i]) st.pop();\\n            if(st.empty()) nsl[i] = -1;\\n            else nsl[i] = st.top().second;\\n            st.push({heights[i], i});\\n        }\\n        while(!st.empty()) st.pop();\\n        for(int i=n-1; i>=0; i--) { // Nearest Smallest Element to Right\\n            while(!st.empty() && st.top().first >= heights[i]) st.pop();\\n            if(st.empty()) nsr[i] = n;\\n            else nsr[i] = st.top().second;\\n            st.push({heights[i], i});\\n        }\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            int width = nsr[i]-nsl[i]-1;\\n            area.push_back(heights[i]*width);\\n            ans = max(ans, area[i]);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int area = 0;\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> heights(n, 0);\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(matrix[i][j] == \\'1\\') heights[j]++;\\n                else heights[j] = 0;\\n            }\\n            area = max(area, largestRectangleArea(heights));\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106878,
                "title": "c-easy-solution-extension-to-largest-rectangle-in-histogram",
                "content": "```\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n        \\n  vector<int> prevNearestSmaller(vector<int>&arr,int &n){\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\n            while(s.top()!=-1 && arr[s.top()]>=arr[i])s.pop();\\n            \\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n        \\n    }\\n     vector<int> nextNearestSmaller(vector<int>&arr,int &n){\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int>ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(s.top()!=-1 && arr[s.top()]>=arr[i])s.pop();\\n            \\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n        \\n    }\\n\\n    int MAH(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int>prev(n);\\n        prev = prevNearestSmaller(arr,n);\\n        \\n        vector<int>next(n);\\n        next=nextNearestSmaller(arr,n);\\n        int area = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int l =arr[i];\\n            \\n            if(next[i]==-1)next[i]=n;\\n            int b = next[i]-prev[i]-1;\\n            area = max(area,l*b);\\n        }\\n        return area;\\n        \\n    }\\n   int maximalRectangle(vector<vector<char>>& v) {\\n        \\n        vector<int> l(v[0].size(), 0);\\n        int mx = 0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[0].size();j++)\\n            {\\n                if(v[i][j]==\\'0\\')\\n                   l[j]=0;\\n                else\\n                {\\n                    l[j]=l[j]+1;\\n                }\\n            }\\n            mx=max(mx,MAH(l));\\n        }\\n         return mx;  \\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n        \\n  vector<int> prevNearestSmaller(vector<int>&arr,int &n){\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\n            while(s.top()!=-1 && arr[s.top()]>=arr[i])s.pop();\\n            \\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n        \\n    }\\n     vector<int> nextNearestSmaller(vector<int>&arr,int &n){\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int>ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(s.top()!=-1 && arr[s.top()]>=arr[i])s.pop();\\n            \\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n        \\n    }\\n\\n    int MAH(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int>prev(n);\\n        prev = prevNearestSmaller(arr,n);\\n        \\n        vector<int>next(n);\\n        next=nextNearestSmaller(arr,n);\\n        int area = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int l =arr[i];\\n            \\n            if(next[i]==-1)next[i]=n;\\n            int b = next[i]-prev[i]-1;\\n            area = max(area,l*b);\\n        }\\n        return area;\\n        \\n    }\\n   int maximalRectangle(vector<vector<char>>& v) {\\n        \\n        vector<int> l(v[0].size(), 0);\\n        int mx = 0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[0].size();j++)\\n            {\\n                if(v[i][j]==\\'0\\')\\n                   l[j]=0;\\n                else\\n                {\\n                    l[j]=l[j]+1;\\n                }\\n            }\\n            mx=max(mx,MAH(l));\\n        }\\n         return mx;  \\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095042,
                "title": "efficient-c-solution-using-histogram-area-stack",
                "content": "***Solution using Largest Histogram Area Concept :*** \\n```\\nclass Solution {\\n    int maxHistogramArea(vector<int>& heights,int n){\\n\\t\\n\\t// TC -> O(M*(N+M))\\n\\t// SC -> O(N)\\n\\n    stack<int>stk;\\n    int maxArea{};\\n    \\n    for(int i=0;i<=n;i++){\\n        while(!stk.empty() && (i==n || (heights[stk.top()]>=heights[i]))){\\n            int height=heights[stk.top()];\\n            stk.pop();\\n            \\n            int width;\\n            if(stk.empty()) width=i;\\n            else width=i-stk.top()-1;\\n            \\n            maxArea=max(maxArea, height*width);\\n        }\\n        stk.push(i);\\n    }\\n    return maxArea;\\n}\\npublic:\\n    int maximalRectangle(vector<vector<char>>& mat) {\\n        int maxArea{};\\n        int n=mat.size(), m=mat[0].size();\\n        vector<int> dp(m,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==\\'1\\') dp[j]++;\\n                else dp[j]=0;\\n            }\\n            maxArea=max(maxArea,maxHistogramArea(dp,m));\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    int maxHistogramArea(vector<int>& heights,int n){\\n\\t\\n\\t// TC -> O(M*(N+M))\\n\\t// SC -> O(N)\\n\\n    stack<int>stk;\\n    int maxArea{};\\n    \\n    for(int i=0;i<=n;i++){\\n        while(!stk.empty() && (i==n || (heights[stk.top()]>=heights[i]))){\\n            int height=heights[stk.top()];\\n            stk.pop();\\n            \\n            int width;\\n            if(stk.empty()) width=i;\\n            else width=i-stk.top()-1;\\n            \\n            maxArea=max(maxArea, height*width);\\n        }\\n        stk.push(i);\\n    }\\n    return maxArea;\\n}\\npublic:\\n    int maximalRectangle(vector<vector<char>>& mat) {\\n        int maxArea{};\\n        int n=mat.size(), m=mat[0].size();\\n        vector<int> dp(m,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==\\'1\\') dp[j]++;\\n                else dp[j]=0;\\n            }\\n            maxArea=max(maxArea,maxHistogramArea(dp,m));\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935921,
                "title": "short-and-simple-using-largest-rectangle-in-histogram",
                "content": "```\\nclass Solution {\\nprivate:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size(), maxA = 0, h, w;\\n        stack<int> s;\\n\\n        for (int i = 0; i <= n; i++) {\\n            while (!s.empty() && (i == n || heights[i] <= heights[s.top()])) {\\n                h = heights[s.top()];   s.pop();\\n                if (s.empty())  w = i;\\n                else    w = i - s.top() - 1;\\n                maxA = max(maxA, h * w);\\n            }\\n            s.push(i);\\n        }\\n        return maxA;\\n    }\\n\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int ans = INT_MIN, r = matrix.size(), c = matrix[0].size();\\n        vector<int> heights(c);\\n\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (matrix[i][j] == \\'1\\')  heights[j]++;\\n                else    heights[j] = 0;\\n            }\\n            int area = largestRectangleArea(heights);\\n            ans = max(ans, area);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size(), maxA = 0, h, w;\\n        stack<int> s;\\n\\n        for (int i = 0; i <= n; i++) {\\n            while (!s.empty() && (i == n || heights[i] <= heights[s.top()])) {\\n                h = heights[s.top()];   s.pop();\\n                if (s.empty())  w = i;\\n                else    w = i - s.top() - 1;\\n                maxA = max(maxA, h * w);\\n            }\\n            s.push(i);\\n        }\\n        return maxA;\\n    }\\n\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int ans = INT_MIN, r = matrix.size(), c = matrix[0].size();\\n        vector<int> heights(c);\\n\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (matrix[i][j] == \\'1\\')  heights[j]++;\\n                else    heights[j] = 0;\\n            }\\n            int area = largestRectangleArea(heights);\\n            ans = max(ans, area);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872578,
                "title": "brute-force-to-optimal",
                "content": "**Brute Force** :- \\n\\n**Time Complexity** :- O((n * m) ^ 3)\\n\\n**Java Code** :- \\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        // create all rectangles\\n        // check whether there is a zero in that or not\\n        // if not, calculate its area\\n        // return the maximum area out of it\\n        \\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        \\n        int maxArea = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                // coordinates of the top left corner of the rectangle\\n                int startingX = i;\\n                int startingY = j;\\n                \\n                for(int k = i; k < n; k++) {\\n                    for(int l = j ; l < m; l++) {\\n                        // coordinates of the bottom right corner of the rectangle\\n                        int endingX = k;\\n                        int endingY = l;\\n                        \\n                        // check whether its contains only one\\n                        if(isEligible(matrix, startingX, startingY, endingX, endingY)) {\\n                            maxArea = Math.max(maxArea, (endingX - startingX + 1) * (endingY - startingY + 1));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxArea;\\n    }\\n    \\n    public static boolean isEligible(char[][] arr, int startingX, int startingY, int endingX, int endingY) {\\n        for(int i = startingX; i <= endingX; i++) {\\n            for(int j = startingY; j <= endingY; j++) {\\n                if(arr[i][j] == \\'0\\') {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\n**Optimal** :- use Max Area of rectangle in a histogram logic on each row but after adding all the top 1\\'s in the current value if current value  is not zero.\\n\\n**Time Complexity** :- O(n * m)\\n\\n**Java Code** :- \\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        \\n        int maxArea = 0;\\n        \\n        // calculate the max area of rectangle for the topmost row\\n        int[] initialRow = new int[m];\\n        for(int i = 0; i < m; i++) {\\n            initialRow[i] = matrix[0][i] - \\'0\\';\\n        }\\n       \\n        maxArea = Math.max(maxAreaOfHistogram(initialRow), maxArea);\\n        \\n        // calculate max area of rectangle for all the remaining row\\n        for(int i = 1; i < n; i++) {\\n            int[] currentRow = new int[m];\\n            \\n            for(int j = 0; j < m; j++) {\\n                if(matrix[i][j] != \\'0\\')\\n                currentRow[j] = matrix[i][j] - \\'0\\' + initialRow[j];\\n            }\\n            \\n            maxArea = Math.max(maxArea, maxAreaOfHistogram(currentRow));\\n            \\n            // to reduce the time complexity for adding all the previous 1\\'s\\n            initialRow = currentRow;\\n        }\\n        \\n        return maxArea;\\n    }\\n    \\n    public static int maxAreaOfHistogram(int[] arr) {\\n        \\n        int[] leftSmallerIndex = findLeftSmallerIndex(arr);\\n        int[] rightSmallerIndex = findRightSmallerIndex(arr);\\n        \\n        int maxArea = 0;\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            maxArea = Math.max(maxArea, (rightSmallerIndex[i] - leftSmallerIndex[i] - 1) * arr[i]);\\n        }\\n        return maxArea;\\n    }\\n    \\n    public static int[] findLeftSmallerIndex(int[] arr) {\\n        int[] ans = new int[arr.length];\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        st.push(0);\\n        \\n        ans[0] = -1;\\n        \\n        for(int i = 1; i < arr.length; i++) {\\n            while(st.size() != 0 && arr[st.peek()] >= arr[i]) {\\n                st.pop();\\n            }\\n            \\n            if(st.size() == 0) {\\n                ans[i] = -1;\\n            } else {\\n                ans[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public static int[] findRightSmallerIndex(int[] arr) {\\n        int[] ans = new int[arr.length];\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        st.push(arr.length - 1);\\n        \\n        ans[arr.length - 1] = arr.length;\\n        \\n        for(int i = arr.length - 2; i >= 0; i--) {\\n            while(st.size() != 0 && arr[st.peek()] >= arr[i]) {\\n                st.pop();\\n            }\\n            \\n            if(st.size() == 0) {\\n                ans[i] = arr.length;\\n            } else {\\n                ans[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**Need to convert char array into int array** :- \\n* let say if the no. of ones above a particular point is >= 10 then if we will put this into a char array then our ans will not be correct",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        // create all rectangles\\n        // check whether there is a zero in that or not\\n        // if not, calculate its area\\n        // return the maximum area out of it\\n        \\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        \\n        int maxArea = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                // coordinates of the top left corner of the rectangle\\n                int startingX = i;\\n                int startingY = j;\\n                \\n                for(int k = i; k < n; k++) {\\n                    for(int l = j ; l < m; l++) {\\n                        // coordinates of the bottom right corner of the rectangle\\n                        int endingX = k;\\n                        int endingY = l;\\n                        \\n                        // check whether its contains only one\\n                        if(isEligible(matrix, startingX, startingY, endingX, endingY)) {\\n                            maxArea = Math.max(maxArea, (endingX - startingX + 1) * (endingY - startingY + 1));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxArea;\\n    }\\n    \\n    public static boolean isEligible(char[][] arr, int startingX, int startingY, int endingX, int endingY) {\\n        for(int i = startingX; i <= endingX; i++) {\\n            for(int j = startingY; j <= endingY; j++) {\\n                if(arr[i][j] == \\'0\\') {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        \\n        int maxArea = 0;\\n        \\n        // calculate the max area of rectangle for the topmost row\\n        int[] initialRow = new int[m];\\n        for(int i = 0; i < m; i++) {\\n            initialRow[i] = matrix[0][i] - \\'0\\';\\n        }\\n       \\n        maxArea = Math.max(maxAreaOfHistogram(initialRow), maxArea);\\n        \\n        // calculate max area of rectangle for all the remaining row\\n        for(int i = 1; i < n; i++) {\\n            int[] currentRow = new int[m];\\n            \\n            for(int j = 0; j < m; j++) {\\n                if(matrix[i][j] != \\'0\\')\\n                currentRow[j] = matrix[i][j] - \\'0\\' + initialRow[j];\\n            }\\n            \\n            maxArea = Math.max(maxArea, maxAreaOfHistogram(currentRow));\\n            \\n            // to reduce the time complexity for adding all the previous 1\\'s\\n            initialRow = currentRow;\\n        }\\n        \\n        return maxArea;\\n    }\\n    \\n    public static int maxAreaOfHistogram(int[] arr) {\\n        \\n        int[] leftSmallerIndex = findLeftSmallerIndex(arr);\\n        int[] rightSmallerIndex = findRightSmallerIndex(arr);\\n        \\n        int maxArea = 0;\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            maxArea = Math.max(maxArea, (rightSmallerIndex[i] - leftSmallerIndex[i] - 1) * arr[i]);\\n        }\\n        return maxArea;\\n    }\\n    \\n    public static int[] findLeftSmallerIndex(int[] arr) {\\n        int[] ans = new int[arr.length];\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        st.push(0);\\n        \\n        ans[0] = -1;\\n        \\n        for(int i = 1; i < arr.length; i++) {\\n            while(st.size() != 0 && arr[st.peek()] >= arr[i]) {\\n                st.pop();\\n            }\\n            \\n            if(st.size() == 0) {\\n                ans[i] = -1;\\n            } else {\\n                ans[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public static int[] findRightSmallerIndex(int[] arr) {\\n        int[] ans = new int[arr.length];\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        st.push(arr.length - 1);\\n        \\n        ans[arr.length - 1] = arr.length;\\n        \\n        for(int i = arr.length - 2; i >= 0; i--) {\\n            while(st.size() != 0 && arr[st.peek()] >= arr[i]) {\\n                st.pop();\\n            }\\n            \\n            if(st.size() == 0) {\\n                ans[i] = arr.length;\\n            } else {\\n                ans[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788708,
                "title": "my-dp-solution-using-largest-rectangle-in-histogram",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestArea(vector<int> &A){\\n        A.push_back(0);\\n        int n = A.size();\\n        stack<int> s;\\n        int i=0;\\n        int max_area = 0;\\n        while(i<n){\\n            if(s.empty()||A[i]>=A[s.top()]) s.push(i++);\\n            else{\\n                int h = s.top();\\n                s.pop();\\n                max_area = max(max_area, A[h]*(s.empty()?i:i-s.top()-1));\\n             }\\n        }\\n        return max_area;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int largestArea(vector<int> &A){\\n        A.push_back(0);\\n        int n = A.size();\\n        stack<int> s;\\n        int i=0;\\n        int max_area = 0;\\n        while(i<n){\\n            if(s.empty()||A[i]>=A[s.top()]) s.push(i++);\\n            else{\\n                int h = s.top();\\n                s.pop();\\n                max_area = max(max_area, A[h]*(s.empty()?i:i-s.top()-1));\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1785827,
                "title": "maximal-rectangle-solution-java",
                "content": "class Solution {\\n  public int maximalRectangle(char[][] matrix) {\\n    if (matrix.length == 0)\\n      return 0;\\n\\n    int ans = 0;\\n    int[] hist = new int[matrix[0].length];\\n\\n    for (char[] row : matrix) {\\n      for (int i = 0; i < row.length; ++i)\\n        hist[i] = row[i] == \\'0\\' ? 0 : hist[i] + 1;\\n      ans = Math.max(ans, largestRectangleArea(hist));\\n    }\\n\\n    return ans;\\n  }\\n\\n  private int largestRectangleArea(int[] heights) {\\n    int ans = 0;\\n    Stack<Integer> stack = new Stack<>();\\n\\n    for (int i = 0; i <= heights.length; ++i) {\\n      while (!stack.isEmpty() && (i == heights.length || heights[stack.peek()] > heights[i])) {\\n        final int h = heights[stack.pop()];\\n        final int w = stack.isEmpty() ? i : i - stack.peek() - 1;\\n        ans = Math.max(ans, h * w);\\n      }\\n      stack.push(i);\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Stack",
                    "Matrix",
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\n  public int maximalRectangle(char[][] matrix) {\\n    if (matrix.length == 0)\\n      return 0;\\n\\n    int ans = 0;\\n    int[] hist = new int[matrix[0].length];\\n\\n    for (char[] row : matrix) {\\n      for (int i = 0; i < row.length; ++i)\\n        hist[i] = row[i] == \\'0\\' ? 0 : hist[i] + 1;\\n      ans = Math.max(ans, largestRectangleArea(hist));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1757359,
                "title": "converting-2d-array-to-1d-and-checking-maximus",
                "content": "```\\nclass Solution {\\npublic:\\n    // copy pasting from 84. Largest Rectangle in Histogram\\n    int largestRectangleArea(vector<int>& heights) {\\n        vector<int>NSL(heights.size());\\n        stack<int>st;\\n        \\n        //for next smaller left(indexes)\\n        for(int i=0;i<heights.size();i++){\\n        while( !st.empty() && heights[i] <= heights[st.top()] ) st.pop();\\n            (st.empty()) ? NSL[i]=-1 : NSL[i]= st.top();\\n            st.push(i);\\n        }\\n        stack<int>t;\\n        st=t;\\n        int ans = 0;\\n        for(int i=heights.size()-1;i>=0;i--){\\n        while( !st.empty() && heights[i] <= heights[st.top()] ) st.pop();\\n            \\n            if(st.empty()) {\\n                int m = heights.size() - NSL[i] - 1;\\n            ans = max(ans , m*heights[i]);\\n            }\\n                 \\n            else{\\n                int m = st.top()-NSL[i]-1;\\n                ans= max(ans,m*heights[i] );\\n            } \\n            st.push(i);\\n        }\\n            return ans;\\n    }\\n    ///\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        vector<int>Temp(matrix[0].size(),0);\\n        int ans = 0 ;\\n        // converting 2d matrix to a 1d array(Temp) and checking maximum\\n        for(auto row : matrix){\\n            for(int i = 0; i<row.size();i++){\\n                (row[i]==\\'0\\')?Temp[i]=0 : Temp[i]++;\\n            }\\n                ans = max(ans,largestRectangleArea(Temp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // copy pasting from 84. Largest Rectangle in Histogram\\n    int largestRectangleArea(vector<int>& heights) {\\n        vector<int>NSL(heights.size());\\n        stack<int>st;\\n        \\n        //for next smaller left(indexes)\\n        for(int i=0;i<heights.size();i++){\\n        while( !st.empty() && heights[i] <= heights[st.top()] ) st.pop();\\n            (st.empty()) ? NSL[i]=-1 : NSL[i]= st.top();\\n            st.push(i);\\n        }\\n        stack<int>t;\\n        st=t;\\n        int ans = 0;\\n        for(int i=heights.size()-1;i>=0;i--){\\n        while( !st.empty() && heights[i] <= heights[st.top()] ) st.pop();\\n            \\n            if(st.empty()) {\\n                int m = heights.size() - NSL[i] - 1;\\n            ans = max(ans , m*heights[i]);\\n            }\\n                 \\n            else{\\n                int m = st.top()-NSL[i]-1;\\n                ans= max(ans,m*heights[i] );\\n            } \\n            st.push(i);\\n        }\\n            return ans;\\n    }\\n    ///\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        vector<int>Temp(matrix[0].size(),0);\\n        int ans = 0 ;\\n        // converting 2d matrix to a 1d array(Temp) and checking maximum\\n        for(auto row : matrix){\\n            for(int i = 0; i<row.size();i++){\\n                (row[i]==\\'0\\')?Temp[i]=0 : Temp[i]++;\\n            }\\n                ans = max(ans,largestRectangleArea(Temp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736123,
                "title": "c-code-time-o-row-col",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& arr) {\\n       int n = arr.size();\\n       int m = arr[0].size();\\n       int dp[n][m+1];\\n       for(int i = 0; i<n; i++)\\n       {\\n           for(int j=0; j<m; j++)\\n           {\\n               if(i == 0)\\n               {\\n                   dp[i][j] = arr[i][j]-\\'0\\';\\n               }\\n               else\\n               {\\n                   if(arr[i][j] == \\'0\\')\\n                   dp[i][j] = 0;\\n                   else\\n                   dp[i][j] = dp[i-1][j] +1; \\n               }\\n           }\\n       }\\n       for(int i=0; i<n; i++)\\n       {\\n         dp[i][m] = 0;\\n       }\\n\\n       int ans = 0;\\n       for(int i=0; i<n; i++)\\n       {\\n           stack<int> st;\\n           for(int j = 0; j<=m; j++)\\n           {\\n               while(!st.empty() && dp[i][st.top()]>dp[i][j])\\n               {\\n                  int t = st.top();\\n                  st.pop();\\n                  int h = dp[i][t];\\n                  if(st.empty())\\n                  ans = max(ans, h*j);\\n                  else\\n                  {\\n                      int len = j - st.top() - 1;\\n                      ans = max(ans, len*h);\\n                  }\\n               }\\n               st.push(j);\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& arr) {\\n       int n = arr.size();\\n       int m = arr[0].size();\\n       int dp[n][m+1];\\n       for(int i = 0; i<n; i++)\\n       {\\n           for(int j=0; j<m; j++)\\n           {\\n               if(i == 0)\\n               {\\n                   dp[i][j] = arr[i][j]-\\'0\\';\\n               }\\n               else\\n               {\\n                   if(arr[i][j] == \\'0\\')\\n                   dp[i][j] = 0;\\n                   else\\n                   dp[i][j] = dp[i-1][j] +1; \\n               }\\n           }\\n       }\\n       for(int i=0; i<n; i++)\\n       {\\n         dp[i][m] = 0;\\n       }\\n\\n       int ans = 0;\\n       for(int i=0; i<n; i++)\\n       {\\n           stack<int> st;\\n           for(int j = 0; j<=m; j++)\\n           {\\n               while(!st.empty() && dp[i][st.top()]>dp[i][j])\\n               {\\n                  int t = st.top();\\n                  st.pop();\\n                  int h = dp[i][t];\\n                  if(st.empty())\\n                  ans = max(ans, h*j);\\n                  else\\n                  {\\n                      int len = j - st.top() - 1;\\n                      ans = max(ans, len*h);\\n                  }\\n               }\\n               st.push(j);\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702443,
                "title": "c-o-n-m-time-o-n-m-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& A) {\\n        int n = A.size(), m = A[0].size();\\n        \\n        // dp[i][j] denotes the number of consecutive ones below (i, j) starting from (i, j)\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        for (int j = 0; j < m; j++) {\\n            for (int i = n - 1; i >= 0; i--) {\\n                if (A[i][j] == \\'0\\')\\n                    dp[i][j] = 0;\\n                else\\n                    dp[i][j] = 1 + (i + 1 < n ? dp[i + 1][j] : 0);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for (auto &row : dp) {\\n            \\n            stack<int> st;\\n            \\n            // left[j] = k, is the closest element to the left of j such that row[k] < row[j]\\n            vector<int> left(m);\\n            for (int j = 0; j < m; j++) {\\n                \\n                // get rid of all the equal or larger elements for we need the smaller element to the left\\n                while (!st.empty() && row[st.top()] >= row[j]) {\\n                    st.pop();\\n                }\\n            \\n                left[j] = st.empty() ? -1 : st.top();\\n                st.push(j);\\n            }\\n            \\n            // empty the stack for further usage\\n            while (!st.empty()) {\\n                st.pop();\\n            }\\n            \\n            // right[j] = k, is the closest element to the right of j such that row[k] < row[j]\\n            vector<int> right(m);\\n            for (int j = m - 1; j >= 0; j--) {\\n                \\n                // get rid of all the equal or larger elements for we need the smaller element to the right\\n                while (!st.empty() && row[st.top()] >= row[j]) {\\n                    st.pop();\\n                }\\n                \\n                right[j] = st.empty() ? m : st.top();\\n\\n                st.push(j);\\n            }\\n            \\n            for (int j = 0; j < m; j++) {\\n                \\n                // height of the rectangle is row[j]\\n                // width of the rectangle is right[j] - left[j] - 1 \\n                // both right[j] and left[j] are not included\\n                int cur = row[j] * (right[j] - left[j] - 1);\\n                ans = max(ans, cur);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& A) {\\n        int n = A.size(), m = A[0].size();\\n        \\n        // dp[i][j] denotes the number of consecutive ones below (i, j) starting from (i, j)\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        for (int j = 0; j < m; j++) {\\n            for (int i = n - 1; i >= 0; i--) {\\n                if (A[i][j] == \\'0\\')\\n                    dp[i][j] = 0;\\n                else\\n                    dp[i][j] = 1 + (i + 1 < n ? dp[i + 1][j] : 0);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for (auto &row : dp) {\\n            \\n            stack<int> st;\\n            \\n            // left[j] = k, is the closest element to the left of j such that row[k] < row[j]\\n            vector<int> left(m);\\n            for (int j = 0; j < m; j++) {\\n                \\n                // get rid of all the equal or larger elements for we need the smaller element to the left\\n                while (!st.empty() && row[st.top()] >= row[j]) {\\n                    st.pop();\\n                }\\n            \\n                left[j] = st.empty() ? -1 : st.top();\\n                st.push(j);\\n            }\\n            \\n            // empty the stack for further usage\\n            while (!st.empty()) {\\n                st.pop();\\n            }\\n            \\n            // right[j] = k, is the closest element to the right of j such that row[k] < row[j]\\n            vector<int> right(m);\\n            for (int j = m - 1; j >= 0; j--) {\\n                \\n                // get rid of all the equal or larger elements for we need the smaller element to the right\\n                while (!st.empty() && row[st.top()] >= row[j]) {\\n                    st.pop();\\n                }\\n                \\n                right[j] = st.empty() ? m : st.top();\\n\\n                st.push(j);\\n            }\\n            \\n            for (int j = 0; j < m; j++) {\\n                \\n                // height of the rectangle is row[j]\\n                // width of the rectangle is right[j] - left[j] - 1 \\n                // both right[j] and left[j] are not included\\n                int cur = row[j] * (right[j] - left[j] - 1);\\n                ans = max(ans, cur);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605532,
                "title": "java-visually-explained-reuse-largest-rectangle-in-histogram",
                "content": "**Idea:** Bottom-Up DP. Reuse [LC 84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1604136/Java-or-Linear-Time-and-Space)\\n* Maximal rectangle (MR) is formed by 1s in rectangles\\n* Moving from top to bottom rows, if a 0 is found in any row then that column will break the rectangle formation, therefore the area for that MR will be 0 i.e. there will be no MR\\n* However if a 1 is found, then size of the column increases by 1\\n* Considering this problem row wise, columns of 1s are formed in the table with certain heights. We need to find the MR across these columns. Now this problem reduces to [LC 84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1604136/Java-or-Linear-Time-and-Space). Please solve that before this one.\\n* Since we need to find the heights of columns of 1s, with rows accumulating in each iteration, we have both overlapping sub-problems and optimals substructure\\n* IMO, in matrix problems, tabulation (bottom-up DP) is more intuitive than memoization.\\n\\n![image](https://assets.leetcode.com/users/images/64bd1b7e-86cb-4ef7-8460-92a53cb3a17d_1638338198.604553.png)\\n> **T/S:** O(mn)/O(n), where m and n are row and colum size of the matrix\\n ```\\npublic int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0 || matrix[0].length == 0)\\n                return 0;\\n        var dp = new int[matrix[0].length];\\n        var maxArea = 0;\\n\\n        for (var row : matrix) {\\n                for (var j = 0; j < matrix[0].length; j++)\\n                        dp[j] = (row[j] == \\'1\\') ? dp[j] + 1 : 0;\\n                maxArea = Math.max(maxArea, largestRectangleArea(dp));\\n        }\\n        return maxArea;\\n}\\n\\n// This method is straight copied from LC 84\\nprivate int largestRectangleArea(int[] heights) {\\n        var n = heights.length;\\n        var leftSmaller = new int[n];\\n        var rightSmaller = new int[n];\\n        leftSmaller[0] = -1;\\n        rightSmaller[n - 1] = n;\\n\\n        for (var i = 1; i < n; i++) {\\n\\t\\t\\tvar j = i - 1;\\n\\t\\t\\twhile (j >= 0 && heights[j] >= heights[i])\\n\\t\\t\\t\\tj = leftSmaller[j];\\n\\t\\t\\tleftSmaller[i] = j;\\n        }\\n\\n        for (var i = n - 2; i >= 0; i--) {\\n\\t\\t\\tvar j = i + 1;\\n\\t\\t\\twhile (j < n && heights[j] >= heights[i])\\n\\t\\t\\t\\tj = rightSmaller[j];\\n\\t\\t\\trightSmaller[i] = j;\\n        }\\n\\n        var maxArea = 0;\\n        for (var i = 0; i < n; i++)\\n\\t\\t\\tmaxArea = Math.max(maxArea, heights[i] * (rightSmaller[i] - leftSmaller[i] - 1));\\n        return maxArea;\\n}\\n```\\n***Please upvote if this helps***\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0 || matrix[0].length == 0)\\n                return 0;\\n        var dp = new int[matrix[0].length];\\n        var maxArea = 0;\\n\\n        for (var row : matrix) {\\n                for (var j = 0; j < matrix[0].length; j++)\\n                        dp[j] = (row[j] == \\'1\\') ? dp[j] + 1 : 0;\\n                maxArea = Math.max(maxArea, largestRectangleArea(dp));\\n        }\\n        return maxArea;\\n}\\n\\n// This method is straight copied from LC 84\\nprivate int largestRectangleArea(int[] heights) {\\n        var n = heights.length;\\n        var leftSmaller = new int[n];\\n        var rightSmaller = new int[n];\\n        leftSmaller[0] = -1;\\n        rightSmaller[n - 1] = n;\\n\\n        for (var i = 1; i < n; i++) {\\n\\t\\t\\tvar j = i - 1;\\n\\t\\t\\twhile (j >= 0 && heights[j] >= heights[i])\\n\\t\\t\\t\\tj = leftSmaller[j];\\n\\t\\t\\tleftSmaller[i] = j;\\n        }\\n\\n        for (var i = n - 2; i >= 0; i--) {\\n\\t\\t\\tvar j = i + 1;\\n\\t\\t\\twhile (j < n && heights[j] >= heights[i])\\n\\t\\t\\t\\tj = rightSmaller[j];\\n\\t\\t\\trightSmaller[i] = j;\\n        }\\n\\n        var maxArea = 0;\\n        for (var i = 0; i < n; i++)\\n\\t\\t\\tmaxArea = Math.max(maxArea, heights[i] * (rightSmaller[i] - leftSmaller[i] - 1));\\n        return maxArea;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604047,
                "title": "c-stack-using-nse-same-as-leetcode-84th-prob",
                "content": "```\\nclass Solution {\\npublic:\\n      void NSER(vector<int>& v,vector<int>& height){\\n          stack<int> st;\\n          st.push(0);\\n\\n          int i=1;\\n          while(i<height.size()){\\n              if(height[i]>=height[st.top()]){st.push(i++);}\\n              else{\\n                  while(!st.empty() && height[st.top()]>height[i]){\\n                      v[st.top()]=i-1;\\n                      st.pop();\\n                  }\\n                    st.push(i++);\\n              }\\n          }\\n               if(st.size()){\\n                   while(!st.empty()){\\n                       v[st.top()]=height.size()-1;\\n                       st.pop();\\n                   }\\n               }\\n\\n}\\n\\nvoid NSEL(vector<int>& v1, vector<int>&height){\\n        stack<int> st;\\n          st.push(height.size()-1);\\n\\n          int i=height.size()-2;\\n          while(i>=0){\\n              if(height[i]>=height[st.top()]){st.push(i--);}\\n              else{\\n                  while(!st.empty() && height[st.top()]>height[i]){\\n                      v1[st.top()]=i+1;\\n                      st.pop();\\n                  }\\n                    st.push(i--);\\n              }\\n          }\\n               if(st.size()){\\n                   while(!st.empty()){\\n                       v1[st.top()]=0;\\n                       st.pop();\\n                   }\\n               }\\n}\\n    int larRectInHisto(vector<int>& heights){\\n         int res=0;\\n      int n=heights.size();\\n        if(n==1) return heights[0];\\n        vector<int> rmIdx(n,0);\\n        vector<int> lmIdx(n,0);\\n        \\n        NSER(rmIdx,heights);\\n        NSEL(lmIdx,heights);\\n        \\n        for(int i=0; i<n; i++){\\n            res=max(res,heights[i]*abs(rmIdx[i]-lmIdx[i]+1));\\n        }\\n          return res;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(!matrix.size()) return 0;\\n        vector<int>v(matrix[0].size(),0);\\n        int ans=0;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==\\'1\\') v[j]+=1;\\n                else v[j]=0;\\n            }\\n            ans=max(ans,larRectInHisto(v));\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n      void NSER(vector<int>& v,vector<int>& height){\\n          stack<int> st;\\n          st.push(0);\\n\\n          int i=1;\\n          while(i<height.size()){\\n              if(height[i]>=height[st.top()]){st.push(i++);}",
                "codeTag": "Java"
            },
            {
                "id": 1458014,
                "title": "c-maximum-histogram-problem-based-solution",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n  // code for largest rectangle in Hologram\\n  int maxisumhistogram(vector<int> &arr)\\n    {\\n         int n = arr.size(),maxi=0;\\n\\n         stack<int>st;\\n         int left[n],right[n];\\n        \\n         for(int i=0;i<n;i++)\\n         {\\n            while(!st.empty()&& arr[st.top()]>=arr[i])\\n                st.pop();\\n            if(st.empty())\\n                left[i]=0;\\n            else left[i]= st.top()+1;\\n            \\n            st.push(i);\\n         }\\n        \\n        while(!st.empty())\\n            st.pop();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty()&& arr[st.top()]>=arr[i])\\n                st.pop();\\n            if(st.empty())\\n                right[i]=n-1;\\n            else right[i]= st.top()-1;\\n            st.push(i);\\n        }\\n        for(int i=0;i<n;i++)\\n            maxi=max(maxi,(right[i]-left[i]+1)*arr[i]);\\n        \\n        return maxi;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.size()==0)\\n            return 0;\\n        int maxi =0;\\n        vector<int> arr(matrix[0].size(),0);\\n        \\n      for(int i=0;i<matrix.size();i++)\\n      {\\n          for(int j=0;j<matrix[i].size();j++)\\n          {\\n              if(matrix[i][j]!=\\'0\\')\\n              {\\n                  arr[j]+= matrix[i][j]-\\'0\\';\\n              }\\n              else {\\n                 arr[j] = matrix[i][j]-\\'0\\';  \\n              }\\n          }\\n          maxi= max(maxi,maxisumhistogram(arr) );\\n      }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n  // code for largest rectangle in Hologram\\n  int maxisumhistogram(vector<int> &arr)\\n    {\\n         int n = arr.size(),maxi=0;\\n\\n         stack<int>st;\\n         int left[n],right[n];\\n        \\n         for(int i=0;i<n;i++)\\n         {\\n            while(!st.empty()&& arr[st.top()]>=arr[i])\\n                st.pop();\\n            if(st.empty())\\n                left[i]=0;\\n            else left[i]= st.top()+1;\\n            \\n            st.push(i);\\n         }\\n        \\n        while(!st.empty())\\n            st.pop();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty()&& arr[st.top()]>=arr[i])\\n                st.pop();\\n            if(st.empty())\\n                right[i]=n-1;\\n            else right[i]= st.top()-1;\\n            st.push(i);\\n        }\\n        for(int i=0;i<n;i++)\\n            maxi=max(maxi,(right[i]-left[i]+1)*arr[i]);\\n        \\n        return maxi;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.size()==0)\\n            return 0;\\n        int maxi =0;\\n        vector<int> arr(matrix[0].size(),0);\\n        \\n      for(int i=0;i<matrix.size();i++)\\n      {\\n          for(int j=0;j<matrix[i].size();j++)\\n          {\\n              if(matrix[i][j]!=\\'0\\')\\n              {\\n                  arr[j]+= matrix[i][j]-\\'0\\';\\n              }\\n              else {\\n                 arr[j] = matrix[i][j]-\\'0\\';  \\n              }\\n          }\\n          maxi= max(maxi,maxisumhistogram(arr) );\\n      }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346443,
                "title": "c-stack-max-area-in-histogram-variation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row=matrix.size();\\n        if(row==0) return 0;\\n        int col=matrix[0].size();\\n        \\n        int area=0;\\n        \\n        vector<vector<int>> grid(row,vector<int>(col));\\n        \\n        for(int i=0;i<row;++i){\\n            for(int j=0;j<col;++j){\\n                if(i==0){\\n                    grid[i][j]=matrix[i][j]-\\'0\\';\\n                }else{\\n                    if(matrix[i][j]==\\'0\\'){\\n                        grid[i][j]=0;\\n                    }else{\\n                        grid[i][j]=grid[i-1][j]+1;\\n                    }\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//code below is similar to \"MAX AREA IN HISTOGRAM\" problem\\n            vector<int> left, right;\\n            stack<int> stk;\\n\\n            for(int j=0;j<col;++j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) left.push_back(-1);\\n                else left.push_back(stk.top());\\n                stk.push(j);\\n            }\\n\\n            while(!stk.empty()) stk.pop();\\n\\n            for(int j=col-1;j>=0;--j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) right.push_back(col);\\n                else right.push_back(stk.top());\\n                stk.push(j);\\n            }\\n            reverse(right.begin(),right.end());\\n\\n            for(int j=0;j<col;++j){\\n                area=max(area, (grid[i][j]*(right[j]-left[j]-1)));\\n            }\\n        }\\n    \\n        return area;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row=matrix.size();\\n        if(row==0) return 0;\\n        int col=matrix[0].size();\\n        \\n        int area=0;\\n        \\n        vector<vector<int>> grid(row,vector<int>(col));\\n        \\n        for(int i=0;i<row;++i){\\n            for(int j=0;j<col;++j){\\n                if(i==0){\\n                    grid[i][j]=matrix[i][j]-\\'0\\';\\n                }else{\\n                    if(matrix[i][j]==\\'0\\'){\\n                        grid[i][j]=0;\\n                    }else{\\n                        grid[i][j]=grid[i-1][j]+1;\\n                    }\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//code below is similar to \"MAX AREA IN HISTOGRAM\" problem\\n            vector<int> left, right;\\n            stack<int> stk;\\n\\n            for(int j=0;j<col;++j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) left.push_back(-1);\\n                else left.push_back(stk.top());\\n                stk.push(j);\\n            }\\n\\n            while(!stk.empty()) stk.pop();\\n\\n            for(int j=col-1;j>=0;--j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) right.push_back(col);\\n                else right.push_back(stk.top());\\n                stk.push(j);\\n            }\\n            reverse(right.begin(),right.end());\\n\\n            for(int j=0;j<col;++j){\\n                area=max(area, (grid[i][j]*(right[j]-left[j]-1)));\\n            }\\n        }\\n    \\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290331,
                "title": "solution-using-stack",
                "content": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        def mah(t):    \\n            n= len(t)\\n            #next smaller element in right\\n            stack1=[]\\n            nsr = []\\n            \\n            for j in range(n-1,-1,-1):\\n                if len(stack1)==0:\\n                    nsr.append(t[j]*1)\\n                else:\\n                    while stack1 and t[stack1[-1]]>=t[j]:\\n                        stack1.pop()\\n                        \\n                    if len(stack1)==0:\\n                        nsr.append((n-j)*t[j])\\n                    else:\\n                        nsr.append((stack1[-1]-j)*t[j])\\n                stack1.append(j)\\n            \\n            # next smaller element in left\\n            \\n            stack2=[]\\n            nsl=[]\\n            \\n            for i in range(n):\\n                if len(stack2)==0:\\n                    nsl.append((i+1)*t[i])\\n                else:\\n                    \\n                    while stack2 and t[stack2[-1]]>=t[i]:\\n                        stack2.pop()\\n                    \\n                    if len(stack2)==0:\\n                        nsl.append((i+1)*t[i])\\n                    else:\\n                        nsl.append((i-stack2[-1])*t[i])\\n                stack2.append(i)\\n                \\n            ans=0\\n            for i in range(n):\\n                ans = max(ans,   nsl[i]+nsr[-(i+1)]-t[i])\\n            return ans\\n        \\n        if not matrix:\\n            return 0\\n        n=len(matrix)\\n        m= len(matrix[0])\\n        \\n        g=[0]*(m)\\n        \\n        u=0\\n        ans=0\\n        while u<n:\\n            \\n            for i in range(m):\\n                x=int(matrix[u][i])\\n                if x==0:\\n                    g[i]=0\\n                else:\\n                    g[i]+=x\\n            ans=max(mah(g),ans)\\n            u+=1\\n        return ans\\n    \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        def mah(t):    \\n            n= len(t)\\n            #next smaller element in right\\n            stack1=[]\\n            nsr = []\\n            \\n            for j in range(n-1,-1,-1):\\n                if len(stack1)==0:\\n                    nsr.append(t[j]*1)\\n                else:\\n                    while stack1 and t[stack1[-1]]>=t[j]:\\n                        stack1.pop()\\n                        \\n                    if len(stack1)==0:\\n                        nsr.append((n-j)*t[j])\\n                    else:\\n                        nsr.append((stack1[-1]-j)*t[j])\\n                stack1.append(j)\\n            \\n            # next smaller element in left\\n            \\n            stack2=[]\\n            nsl=[]\\n            \\n            for i in range(n):\\n                if len(stack2)==0:\\n                    nsl.append((i+1)*t[i])\\n                else:\\n                    \\n                    while stack2 and t[stack2[-1]]>=t[i]:\\n                        stack2.pop()\\n                    \\n                    if len(stack2)==0:\\n                        nsl.append((i+1)*t[i])\\n                    else:\\n                        nsl.append((i-stack2[-1])*t[i])\\n                stack2.append(i)\\n                \\n            ans=0\\n            for i in range(n):\\n                ans = max(ans,   nsl[i]+nsr[-(i+1)]-t[i])\\n            return ans\\n        \\n        if not matrix:\\n            return 0\\n        n=len(matrix)\\n        m= len(matrix[0])\\n        \\n        g=[0]*(m)\\n        \\n        u=0\\n        ans=0\\n        while u<n:\\n            \\n            for i in range(m):\\n                x=int(matrix[u][i])\\n                if x==0:\\n                    g[i]=0\\n                else:\\n                    g[i]+=x\\n            ans=max(mah(g),ans)\\n            u+=1\\n        return ans\\n    \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204207,
                "title": "using-2-stack-max-area-histogram-variation-by-aditya-verma",
                "content": "// If any one wants to do DSA and competitive coding from scratch you can visit my Github Repository\\n// https://github.com/skjha1/Data-Structure-Algorithm-Programs\\n// https://github.com/skjha1/Competitive-Coding\\n```\\nclass Solution {\\npublic:\\nint largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> left,right;\\n    stack<pair<int,int>> s1,s2;\\n    int pseudo_index =-1;\\n    int pseudo_index1 =n;\\n    for (int i=0;i<n;i++)\\n    {\\n      if (s1.size()==0)\\n      {\\n        left.push_back(pseudo_index);\\n      }\\n      else if (s1.size()>0 && s1.top().first<heights[i])\\n      {\\n        left.push_back(s1.top().second);\\n      }\\n      else if (s1.size()>0 && s1.top().first>=heights[i])\\n      {\\n         while(s1.size()>0 && s1.top().first>=heights[i])\\n         {\\n           s1.pop();\\n         }\\n        if (s1.size()==0)\\n        {\\n          left.push_back(pseudo_index);\\n        }\\n        else\\n        {\\n          left.push_back(s1.top().second);\\n        }\\n      }\\n      s1.push({heights[i],i});\\n    }\\n    for (int i=n-1;i>=0;i--)\\n    {\\n      if (s2.size()==0)\\n      {\\n        right.push_back(pseudo_index1);\\n      }\\n      else if (s2.size()>0 && s2.top().first<heights[i])\\n      {\\n        right.push_back(s2.top().second);\\n      }\\n      else if (s2.size()>0 && s2.top().first >= heights[i])\\n      {\\n        while(s2.size()>0 && s2.top().first >= heights[i])\\n        {\\n          s2.pop();\\n        }\\n        if (s2.size()==0)\\n        {\\n          right.push_back(pseudo_index1);\\n        }\\n        else\\n        {\\n          right.push_back(s2.top().second);\\n        }\\n      }\\n      s2.push({heights[i],i});\\n    }\\n    reverse(right.begin(),right.end());\\n    int m=INT_MIN;\\n    for (long long i=0;i<n;i++)\\n    {\\n      m=max(m,(right[i]-left[i]-1)*heights[i]);// taking max after finding area\\n    }\\n    return m;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestRectangleArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> left,right;\\n    stack<pair<int,int>> s1,s2;\\n    int pseudo_index =-1;\\n    int pseudo_index1 =n;\\n    for (int i=0;i<n;i++)\\n    {\\n      if (s1.size()==0)\\n      {\\n        left.push_back(pseudo_index);\\n      }\\n      else if (s1.size()>0 && s1.top().first<heights[i])\\n      {\\n        left.push_back(s1.top().second);\\n      }\\n      else if (s1.size()>0 && s1.top().first>=heights[i])\\n      {\\n         while(s1.size()>0 && s1.top().first>=heights[i])\\n         {\\n           s1.pop();\\n         }\\n        if (s1.size()==0)\\n        {\\n          left.push_back(pseudo_index);\\n        }\\n        else\\n        {\\n          left.push_back(s1.top().second);\\n        }\\n      }\\n      s1.push({heights[i],i});\\n    }\\n    for (int i=n-1;i>=0;i--)\\n    {\\n      if (s2.size()==0)\\n      {\\n        right.push_back(pseudo_index1);\\n      }\\n      else if (s2.size()>0 && s2.top().first<heights[i])\\n      {\\n        right.push_back(s2.top().second);\\n      }\\n      else if (s2.size()>0 && s2.top().first >= heights[i])\\n      {\\n        while(s2.size()>0 && s2.top().first >= heights[i])\\n        {\\n          s2.pop();\\n        }\\n        if (s2.size()==0)\\n        {\\n          right.push_back(pseudo_index1);\\n        }\\n        else\\n        {\\n          right.push_back(s2.top().second);\\n        }\\n      }\\n      s2.push({heights[i],i});\\n    }\\n    reverse(right.begin(),right.end());\\n    int m=INT_MIN;\\n    for (long long i=0;i<n;i++)\\n    {\\n      m=max(m,(right[i]-left[i]-1)*heights[i]);// taking max after finding area\\n    }\\n    return m;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestRectangleArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1179059,
                "title": "a-solutin-based-on-prefix-sum-and-binary-search",
                "content": "Most of solution in discuss is DP, in here I use `prefix sum + binary search`, of course it\\' slow...but maybe new way for your. Hope it\\'s helpful for you.\\n```c++\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty()||matrix[0].empty()) return 0;\\n\\t\\tint n=matrix.size(),m =matrix[0].size();\\n        printf(\"%d,%d\\\\n\",n,m);\\n\\t\\tvector<vector<int>> sum(n+1,vector<int>(m+1,0));\\n\\t\\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++){\\n\\t\\t\\tint tmp = matrix[i-1][j-1]==\\'1\\'?1:0;\\n\\t\\t    // prefix sum\\n\\t\\t\\tsum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + tmp;\\n\\t\\t}\\n        \\n\\t\\tint ans=0,cnt=0;\\n        for(int i=n;i>=1;i--){\\n            if(ans>=i*m) break;\\n            for(int j=m;j>=1;j--){\\n                if(ans>=i*j) break;\\n                if(matrix[i-1][j-1]!=\\'1\\') continue;\\n                for(int d=min(m,j);d>=1;d--){\\n                    int l=0, r= n,mid,t=0;\\n                    // binary search\\n                    while(l<=r){\\n                        mid = l + (r-l)/2;\\n                        if(i-mid<0||j-d<0||sum[i][j]-sum[i-mid][j]-sum[i][j-d]+sum[i-mid][j-d]<d*mid) r=mid-1;\\n                        else l = mid+1;\\n                    }\\n                    ans = max(ans,r*d);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty()||matrix[0].empty()) return 0;\\n\\t\\tint n=matrix.size(),m =matrix[0].size();\\n        printf(\"%d,%d\\\\n\",n,m);\\n\\t\\tvector<vector<int>> sum(n+1,vector<int>(m+1,0));\\n\\t\\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++){\\n\\t\\t\\tint tmp = matrix[i-1][j-1]==\\'1\\'?1:0;\\n\\t\\t    // prefix sum\\n\\t\\t\\tsum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + tmp;\\n\\t\\t}\\n        \\n\\t\\tint ans=0,cnt=0;\\n        for(int i=n;i>=1;i--){\\n            if(ans>=i*m) break;\\n            for(int j=m;j>=1;j--){\\n                if(ans>=i*j) break;\\n                if(matrix[i-1][j-1]!=\\'1\\') continue;\\n                for(int d=min(m,j);d>=1;d--){\\n                    int l=0, r= n,mid,t=0;\\n                    // binary search\\n                    while(l<=r){\\n                        mid = l + (r-l)/2;\\n                        if(i-mid<0||j-d<0||sum[i][j]-sum[i-mid][j]-sum[i][j-d]+sum[i-mid][j-d]<d*mid) r=mid-1;\\n                        else l = mid+1;\\n                    }\\n                    ans = max(ans,r*d);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154976,
                "title": "c-solution-by-accumulation",
                "content": "#### Idea\\nAccumulate the number from left to right. Then iterate the new table column by column. Pick the smallest `width` and largest `height` before encountering 0.\\n**Time complexity** : O(n * m)\\uFF0Cm=rowNumOf(matrix)\\n**Space complexity** : O(n^2)\\n\\n#### Cost\\n28 ms\\t11.5 MB\\n\\n#### Code\\n```\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n\\tif (matrix.empty())return 0;\\n\\tint r = 0, m = matrix.size(), n = matrix[0].size();\\n\\n\\tvector<vector<int>> dp(m, vector<int>(n, 0));\\n\\tfor (int i = 0; i < m; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tdp[i][j] = (matrix[i][j] == \\'1\\') ? (j == 0 ? 1 : dp[i][j - 1] + 1) : 0;\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int j = 0; j < n; j++)\\n\\t{\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t{\\n\\t\\t\\tint width = dp[i][j];\\n\\t\\t\\tfor (int k = i; k < m; k++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (dp[k][j] == 0) break;\\n\\t\\t\\t\\tif (dp[k][j] < width)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twidth = dp[k][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tr = max(r, width * (k - i + 1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn r;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n\\tif (matrix.empty())return 0;\\n\\tint r = 0, m = matrix.size(), n = matrix[0].size();\\n\\n\\tvector<vector<int>> dp(m, vector<int>(n, 0));\\n\\tfor (int i = 0; i < m; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tdp[i][j] = (matrix[i][j] == \\'1\\') ? (j == 0 ? 1 : dp[i][j - 1] + 1) : 0;\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int j = 0; j < n; j++)\\n\\t{\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t{\\n\\t\\t\\tint width = dp[i][j];\\n\\t\\t\\tfor (int k = i; k < m; k++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (dp[k][j] == 0) break;\\n\\t\\t\\t\\tif (dp[k][j] < width)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twidth = dp[k][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tr = max(r, width * (k - i + 1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1145856,
                "title": "c-change-the-problem-to-be-using-problem-84",
                "content": "```\\npublic class Solution {\\n    public int MaximalRectangle(char[][] matrix) {\\n        if (matrix == null || matrix.Length == 0) return 0;\\n        int m = matrix.Length;\\n        int n = matrix[0].Length;\\n        int max = 0;\\n        \\n        // we can solve this problem with problem 84\\n        // make it line by line\\n        var heights = new int[n];\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    heights[j] = 0; // reset, start from 0 again\\n                } else {\\n                    heights[j]++;\\n                }\\n            }\\n            \\n            max = Math.Max(max, LargestRectangle(heights));\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int LargestRectangle(int[] heights) {\\n        var stack = new Stack<int>(); // keep increasing stack with index in it\\n        int len = heights.Length;\\n        int index = 0;\\n        int maxArea = 0;\\n        \\n        while (index < len) {\\n            if (stack.Count == 0 || heights[stack.Peek()] <= heights[index]) {\\n                stack.Push(index);\\n                index++;\\n            } else {\\n                // start processing the smallest bar\\n                var tp = stack.Pop();\\n                var area = heights[tp] * (stack.Count == 0 ? index : (index - stack.Peek()-1));\\n                maxArea = Math.Max(maxArea, area);\\n            }\\n        }\\n        \\n        while (stack.Count > 0) {\\n            var tp = stack.Pop();\\n            var area = heights[tp] * (stack.Count == 0 ? index : (index - stack.Peek() -1 ));\\n            maxArea = Math.Max(maxArea, area);\\n        }\\n        \\n        return maxArea;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaximalRectangle(char[][] matrix) {\\n        if (matrix == null || matrix.Length == 0) return 0;\\n        int m = matrix.Length;\\n        int n = matrix[0].Length;\\n        int max = 0;\\n        \\n        // we can solve this problem with problem 84\\n        // make it line by line\\n        var heights = new int[n];\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    heights[j] = 0; // reset, start from 0 again\\n                } else {\\n                    heights[j]++;\\n                }\\n            }\\n            \\n            max = Math.Max(max, LargestRectangle(heights));\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int LargestRectangle(int[] heights) {\\n        var stack = new Stack<int>(); // keep increasing stack with index in it\\n        int len = heights.Length;\\n        int index = 0;\\n        int maxArea = 0;\\n        \\n        while (index < len) {\\n            if (stack.Count == 0 || heights[stack.Peek()] <= heights[index]) {\\n                stack.Push(index);\\n                index++;\\n            } else {\\n                // start processing the smallest bar\\n                var tp = stack.Pop();\\n                var area = heights[tp] * (stack.Count == 0 ? index : (index - stack.Peek()-1));\\n                maxArea = Math.Max(maxArea, area);\\n            }\\n        }\\n        \\n        while (stack.Count > 0) {\\n            var tp = stack.Pop();\\n            var area = heights[tp] * (stack.Count == 0 ? index : (index - stack.Peek() -1 ));\\n            maxArea = Math.Max(maxArea, area);\\n        }\\n        \\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104867,
                "title": "c-code-using-largest-rectangle-in-histogram",
                "content": "\\nDo Upvote if you like this solution\\n\\nclass Solution {\\npublic:\\n    \\n    void MAH(vector<int>col ,int& res2)\\n    {\\n        int n=col.size();\\n        stack<pair<int,int>>s;\\n        vector<int>left(n),right(n);\\n        \\n        // Nearest Samller to left\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.empty())\\n            {\\n                left[i]=-1;\\n            }\\n            else\\n            {\\n                if(s.top().first<col[i])\\n                {\\n                    left[i]=s.top().second;\\n                }\\n                else\\n                {\\n                    while(!s.empty() && s.top().first>=col[i])\\n                    {\\n                        s.pop();\\n                    }\\n                    if(s.empty())\\n                    {\\n                        left[i]=-1;\\n                    }\\n                    else\\n                    {\\n                       left[i]=s.top().second;   \\n                    }\\n                }\\n                \\n            }\\n            \\n            s.push({col[i],i});\\n        }\\n        \\n        // Clearing the Stack for the Right\\n        \\n        while(!s.empty())\\n        {\\n            s.pop();\\n        }\\n        \\n        // Nearest smallest right\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s.empty())\\n            {\\n                right[i]=n;\\n            }\\n            else\\n            {\\n                if(s.top().first<col[i])\\n                {\\n                    right[i]=s.top().second;\\n                }\\n                else\\n                {\\n                    while(!s.empty() && s.top().first>=col[i])\\n                    {\\n                        s.pop();\\n                    }\\n                    if(s.empty())\\n                    {\\n                        right[i]=n;\\n                    }\\n                    else\\n                    {\\n                        right[i]=s.top().second;\\n                    }\\n                }\\n            }\\n            \\n            s.push({col[i],i});\\n        }\\n        \\n        int ans=INT_MIN;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int x=right[i]-left[i]-1;\\n            ans=max(ans,x*col[i]);\\n        }\\n        \\n        res2=max(res2,ans);\\n    \\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix)\\n    {\\n        if(matrix.empty())\\n        {\\n            return 0;\\n        }\\n        \\n        int res=INT_MIN;\\n        vector<int>col(matrix[0].size(),0);\\n        \\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[i].size();j++)\\n            {\\n                if((matrix[i][j]-\\'0\\')==0)\\n                {\\n                    col[j]=0;\\n                }\\n                else\\n                {\\n                    col[j]+=1;\\n                }\\n            }\\n            \\n            MAH(col,res);\\n        }\\n            \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void MAH(vector<int>col ,int& res2)\\n    {\\n        int n=col.size();\\n        stack<pair<int,int>>s;\\n        vector<int>left(n),right(n);\\n        \\n        // Nearest Samller to left\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.empty())\\n            {\\n                left[i]=-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 982255,
                "title": "c-solution-using-the-concept-of-max-area-histogram",
                "content": "```\\nint MAH(vector<int>& arr) {\\n     int n = arr.size();\\n    vector<int> leftindex;\\n    stack<pair<int,int>> s1;\\n    vector<int> rightindex;\\n    stack<pair<int,int>> s2;\\n    vector<int> width(n);\\n        if(n==0)\\n            return 0;\\n    for(int i = n-1;i>=0;i--)\\n    {\\n        if(s1.size() == 0)\\n            rightindex.push_back(n);\\n        else if(s1.size() > 0 && s1.top().first<arr[i])\\n        {\\n            rightindex.push_back(s1.top().second);\\n        }\\n        else if(s1.size() > 0  && s1.top().first>=arr[i])\\n        {\\n            while(s1.size()>0 && s1.top().first>=arr[i])\\n            {\\n                s1.pop();\\n            }\\n            if(s1.size() == 0 )\\n                rightindex.push_back(n);\\n            else\\n                rightindex.push_back(s1.top().second);\\n        }\\n      s1.push({arr[i],i});\\n    } \\n    reverse(rightindex.begin(),rightindex.end());\\n    for(int i =0;i<n;i++)\\n    {\\n        if(s2.size() == 0)\\n            leftindex.push_back(-1);\\n        else if(s2.size() > 0 && s2.top().first<arr[i])\\n        {\\n            leftindex.push_back(s2.top().second);\\n        }\\n        else if(s2.size() > 0  && s2.top().first>=arr[i])\\n        {\\n            while(s2.size()>0 && s2.top().first>=arr[i])\\n            {\\n                s2.pop();\\n            }\\n            if(s2.size() == 0 )\\n                leftindex.push_back(-1);\\n            else\\n                leftindex.push_back(s2.top().second);\\n        }\\n      s2.push({arr[i],i});\\n    } \\n    for(int i = 0;i<n;i++)\\n    {\\n        width[i] = (rightindex[i] - leftindex[i]) - 1;\\n        width[i] = width[i] * arr[i];\\n    }\\n    int max  = *max_element(width.begin(),width.end());\\n  return max;  \\n}\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n    if(matrix.size() == 0) return 0;\\n    int row = matrix.size();\\n    int col = matrix[0].size();\\n    vector<int> nums;\\n    int ans = 0;\\n    int temp = 0;\\n    for(int i = 0;i<col;i++)\\n    \\tnums.push_back((int)matrix[0][i] - \\'0\\');\\n    ans = MAH(nums);\\n    for(int i = 1;i<row;i++)\\n    {\\n    \\tfor(int j = 0;j<col;j++)\\n    \\t{\\n    \\t\\tif(matrix[i][j] == \\'0\\')\\n    \\t\\t\\tnums[j] = 0;\\n    \\t\\telse\\n    \\t\\t\\tnums[j] = (nums[j] + (int) matrix[i][j]) - \\'0\\';\\n    \\t}\\n    \\t temp = MAH(nums);\\n         ans = max(ans,temp);\\n    }\\n        \\nreturn ans;\\n}",
                "solutionTags": [],
                "code": "```\\nint MAH(vector<int>& arr) {\\n     int n = arr.size();\\n    vector<int> leftindex;\\n    stack<pair<int,int>> s1;\\n    vector<int> rightindex;\\n    stack<pair<int,int>> s2;\\n    vector<int> width(n);\\n        if(n==0)\\n            return 0;\\n    for(int i = n-1;i>=0;i--)\\n    {\\n        if(s1.size() == 0)\\n            rightindex.push_back(n);\\n        else if(s1.size() > 0 && s1.top().first<arr[i])\\n        {\\n            rightindex.push_back(s1.top().second);\\n        }\\n        else if(s1.size() > 0  && s1.top().first>=arr[i])\\n        {\\n            while(s1.size()>0 && s1.top().first>=arr[i])\\n            {\\n                s1.pop();\\n            }\\n            if(s1.size() == 0 )\\n                rightindex.push_back(n);\\n            else\\n                rightindex.push_back(s1.top().second);\\n        }\\n      s1.push({arr[i],i});\\n    } \\n    reverse(rightindex.begin(),rightindex.end());\\n    for(int i =0;i<n;i++)\\n    {\\n        if(s2.size() == 0)\\n            leftindex.push_back(-1);\\n        else if(s2.size() > 0 && s2.top().first<arr[i])\\n        {\\n            leftindex.push_back(s2.top().second);\\n        }\\n        else if(s2.size() > 0  && s2.top().first>=arr[i])\\n        {\\n            while(s2.size()>0 && s2.top().first>=arr[i])\\n            {\\n                s2.pop();\\n            }\\n            if(s2.size() == 0 )\\n                leftindex.push_back(-1);\\n            else\\n                leftindex.push_back(s2.top().second);\\n        }\\n      s2.push({arr[i],i});\\n    } \\n    for(int i = 0;i<n;i++)\\n    {\\n        width[i] = (rightindex[i] - leftindex[i]) - 1;\\n        width[i] = width[i] * arr[i];\\n    }\\n    int max  = *max_element(width.begin(),width.end());\\n  return max;  \\n}\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n    if(matrix.size() == 0) return 0;\\n    int row = matrix.size();\\n    int col = matrix[0].size();\\n    vector<int> nums;\\n    int ans = 0;\\n    int temp = 0;\\n    for(int i = 0;i<col;i++)\\n    \\tnums.push_back((int)matrix[0][i] - \\'0\\');\\n    ans = MAH(nums);\\n    for(int i = 1;i<row;i++)\\n    {\\n    \\tfor(int j = 0;j<col;j++)\\n    \\t{\\n    \\t\\tif(matrix[i][j] == \\'0\\')\\n    \\t\\t\\tnums[j] = 0;\\n    \\t\\telse\\n    \\t\\t\\tnums[j] = (nums[j] + (int) matrix[i][j]) - \\'0\\';\\n    \\t}\\n    \\t temp = MAH(nums);\\n         ans = max(ans,temp);\\n    }\\n        \\nreturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 979263,
                "title": "c-dp-solution-99-07-faster-using-the-idea-of-largest-rect-in-histogram",
                "content": "```\\n int maximalRectangle(vector<vector<char> > &matrix) {\\n    if(matrix.empty()) return 0;\\n    \\n    // Since r and c dont change we use a constant sized array instead of vector\\n    const int r = matrix.size();\\n    const int c = matrix[0].size();\\n       \\n    /* height[j] stores the height of the possible rectangle at col=j for any row i\\n       left[j] stores the index of the col havin the leftMost edge of the rect at col=j for any row i\\n       right[j] stores the index of the col havin the rightMost edge of the rect at col=j for any row i\\n       Rect Area = (right[j]-left[j])*height[j]\\n    */\\n    \\n    // We find the largest rectangle for every triplet values in the order of rows:\\n     /*          0      1      2     3      4\\n     Index 0: (0 1 1)(0 0 5)(2 1 3)(0 0 5)(0 0 5)\\n     Index 1: (0 2 1)(0 0 5)(2 2 3)(2 1 5)(2 1 5)\\n     Index 2: (0 3 1)(0 1 5)(2 3 3)(2 2 5)(2 2 5)\\n     Index 3: (0 4 1)(0 0 5)(0 0 5)(3 3 4)(0 0 5)\\n     */\\n     // Note: At any index (i,j), triplet = (left, height, right)\\n     \\n    int left[c], right[c], height[c];\\n    \\n    // filling the arrays with default values\\n    fill_n(left,c,0);\\n    fill_n(right,c,c); // default value is not zero\\n    fill_n(height,c,0);\\n       \\n    int ans = 0;\\n    for(int i=0; i<r; i++) {\\n        \\n        int cur_left=0, cur_right=c; \\n        \\n        /*\\n        height of rect at current (row,col) = height of rect at prev row on the same col + 1\\n        height[i][j] = height[i-1][j] + 1, if matrix[i][j] = 1\\n                     = 0, otherwise\\n        */\\n        for(int j=0; j<c; j++) {\\n            if(matrix[i][j]==\\'1\\') height[j]++; \\n            else height[j]=0;\\n        }\\n        \\n        \\n        /*\\n        leftEdge of current Row = max(leftEdge of prev row, currentRowLeftEdge)\\n        leftEdge[i][j] = max(leftEdge[i-1][j], currenLeftEdge), if matrix[i][j] = 1;\\n                       = 0, otherwise, Also update the currentLeftEdge to next index because current matrix[i][j] is 0.\\n        */\\n        for(int j=0; j<c; j++) {\\n            if(matrix[i][j]==\\'1\\') left[j]=max(left[j],cur_left);\\n            else {\\n                left[j]=0;\\n                cur_left=j+1;\\n            }\\n        }\\n        \\n        /*\\n        RightEdge of current Row = min(rightEdge of prev row, currentRowRightEdge)\\n        rightEdge[i][j] = min(rightEdge[i-1][j], currentRowRightEdge), if matrix[i][j] = 1;\\n                       = col, otherwise. Also update the currentRightEdge to current index because current matrix[i][j] is 0.\\n        */\\n        for(int j=c-1; j>=0; j--) {\\n            if(matrix[i][j]==\\'1\\') right[j]=min(right[j],cur_right);\\n            else {\\n                right[j]=c;\\n                cur_right=j;\\n            }    \\n        }\\n        \\n        // For Debug Purpose:\\n        // cout<<\"Index: \"<<i<<\" \";\\n        // for(int j = 0; j<c; j++) {\\n        //     cout<<\"(\"<<left[j]<<\" \"<<height[j]<<\" \"<<right[j]<<\")\";\\n        // }\\n        // cout<<\"\\\\n\";\\n        \\n        // compute the area of rectangle using (left, height, right), Area = (right-left)*height\\n        for(int j=0; j<c; j++) {\\n            ans = max(ans,(right[j]-left[j])*height[j]);\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n int maximalRectangle(vector<vector<char> > &matrix) {\\n    if(matrix.empty()) return 0;\\n    \\n    // Since r and c dont change we use a constant sized array instead of vector\\n    const int r = matrix.size();\\n    const int c = matrix[0].size();\\n       \\n    /* height[j] stores the height of the possible rectangle at col=j for any row i\\n       left[j] stores the index of the col havin the leftMost edge of the rect at col=j for any row i\\n       right[j] stores the index of the col havin the rightMost edge of the rect at col=j for any row i\\n       Rect Area = (right[j]-left[j])*height[j]\\n    */\\n    \\n    // We find the largest rectangle for every triplet values in the order of rows:\\n     /*          0      1      2     3      4\\n     Index 0: (0 1 1)(0 0 5)(2 1 3)(0 0 5)(0 0 5)\\n     Index 1: (0 2 1)(0 0 5)(2 2 3)(2 1 5)(2 1 5)\\n     Index 2: (0 3 1)(0 1 5)(2 3 3)(2 2 5)(2 2 5)\\n     Index 3: (0 4 1)(0 0 5)(0 0 5)(3 3 4)(0 0 5)\\n     */\\n     // Note: At any index (i,j), triplet = (left, height, right)\\n     \\n    int left[c], right[c], height[c];\\n    \\n    // filling the arrays with default values\\n    fill_n(left,c,0);\\n    fill_n(right,c,c); // default value is not zero\\n    fill_n(height,c,0);\\n       \\n    int ans = 0;\\n    for(int i=0; i<r; i++) {\\n        \\n        int cur_left=0, cur_right=c; \\n        \\n        /*\\n        height of rect at current (row,col) = height of rect at prev row on the same col + 1\\n        height[i][j] = height[i-1][j] + 1, if matrix[i][j] = 1\\n                     = 0, otherwise\\n        */\\n        for(int j=0; j<c; j++) {\\n            if(matrix[i][j]==\\'1\\') height[j]++; \\n            else height[j]=0;\\n        }\\n        \\n        \\n        /*\\n        leftEdge of current Row = max(leftEdge of prev row, currentRowLeftEdge)\\n        leftEdge[i][j] = max(leftEdge[i-1][j], currenLeftEdge), if matrix[i][j] = 1;\\n                       = 0, otherwise, Also update the currentLeftEdge to next index because current matrix[i][j] is 0.\\n        */\\n        for(int j=0; j<c; j++) {\\n            if(matrix[i][j]==\\'1\\') left[j]=max(left[j],cur_left);\\n            else {\\n                left[j]=0;\\n                cur_left=j+1;\\n            }\\n        }\\n        \\n        /*\\n        RightEdge of current Row = min(rightEdge of prev row, currentRowRightEdge)\\n        rightEdge[i][j] = min(rightEdge[i-1][j], currentRowRightEdge), if matrix[i][j] = 1;\\n                       = col, otherwise. Also update the currentRightEdge to current index because current matrix[i][j] is 0.\\n        */\\n        for(int j=c-1; j>=0; j--) {\\n            if(matrix[i][j]==\\'1\\') right[j]=min(right[j],cur_right);\\n            else {\\n                right[j]=c;\\n                cur_right=j;\\n            }    \\n        }\\n        \\n        // For Debug Purpose:\\n        // cout<<\"Index: \"<<i<<\" \";\\n        // for(int j = 0; j<c; j++) {\\n        //     cout<<\"(\"<<left[j]<<\" \"<<height[j]<<\" \"<<right[j]<<\")\";\\n        // }\\n        // cout<<\"\\\\n\";\\n        \\n        // compute the area of rectangle using (left, height, right), Area = (right-left)*height\\n        for(int j=0; j<c; j++) {\\n            ans = max(ans,(right[j]-left[j])*height[j]);\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 975142,
                "title": "clean-fully-explained-python-solution-o-n-2-explains-every-step",
                "content": "This problem is definitely trickier than it looks and took me a while to comprehend. First, I strongly recommend that you read this [explanation for finding the maximum area of a rectangle in a histogram](https://abhinandandubey.github.io/posts/2019/12/15/Largest-Rectangle-In-Histogram.html), which we will use. \\n\\nEffectively, this problem is **identical to finding max rectangle in a histogram**, and here\\'s how. First, in problems that ask to find subarrays or submatrices that satisfy a certain condition, it is usually convenient to use a prefix sum. Suppose our matrix had just one row `mat = [1,0,1,1,1,0]`, then we can use a prefix sum to count the number of consecutive ones `prefixSum = [1,0,1,2,3,0]`.\\n\\nIf we have a matrix `mat = [[1,0,1],[1,1,1],[0,1,1]]` then `prefixSum = [[1,0,1],[1,2,3],[0,1,2]]`. So we\\'ve counted consecutive ones in each row, but how can we use this information to find the maximal rectangle?\\n\\n**Here\\'s the trick:**\\n\\nSince we\\'ve preprocessed the rows, we need to iterate over the columns somehow to compute the maximal rectangle. But how? The trick is to notice that each column in the prefix sum can be interpreted as a histogram. In the above example `col1 = [1,1,0] col2 =[0,2,3] col3 = [1,3,2]`.  *Finding the maximal rectangle for each column is equivalent to finding the maximal rectangle in the column histogram*. Once you understand this, then you just find the maximal rectangle for each column and return the largest one.\\n\\n```\\n\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \"\"\"\\n        This code \\n        a) computes prefix sums for each row\\n        b) iterates through the cols of the prefix sum matrix\\n        c) treats these cols as histogram\\n        d) computes largest rectangle within the histogram\\n        https://leetcode.com/problems/largest-rectangle-in-histogram/\\n        https://abhinandandubey.github.io/posts/2019/12/15/Largest-Rectangle-In-Histogram.html\\n        \"\"\"\\n        if len(matrix) < 1: return 0\\n        hist = [self.prefixSum(m) for m in matrix]\\n        rows,cols = len(hist),len(hist[0])\\n        maxarea = 0\\n        for i in range(cols):\\n            h = [row[i] for row in hist]\\n            area = self.maxHistRec(h)\\n            maxarea = max(maxarea,area)\\n        return maxarea\\n        \\n    def prefixSum(self,row):\\n        dp = [0 for _ in row]\\n        for i,v in enumerate(row):\\n            dp[i] = dp[i-1] + 1 if int(v) == 1 else 0\\n        return dp       \\n        \\n    def maxHistRec(self,hist):\\n        h = [-1] + hist + [-1]\\n        # use a stack\\n        stack = [0]\\n        area = 0\\n        for i in range(len(h)):\\n            while h[stack[-1]] > h[i]:\\n                j = stack.pop()\\n                area = max(area,h[j]*(i-stack[-1]-1))\\n            stack.append(i)\\n        return area\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \"\"\"\\n        This code \\n        a) computes prefix sums for each row\\n        b) iterates through the cols of the prefix sum matrix\\n        c) treats these cols as histogram\\n        d) computes largest rectangle within the histogram\\n        https://leetcode.com/problems/largest-rectangle-in-histogram/\\n        https://abhinandandubey.github.io/posts/2019/12/15/Largest-Rectangle-In-Histogram.html\\n        \"\"\"\\n        if len(matrix) < 1: return 0\\n        hist = [self.prefixSum(m) for m in matrix]\\n        rows,cols = len(hist),len(hist[0])\\n        maxarea = 0\\n        for i in range(cols):\\n            h = [row[i] for row in hist]\\n            area = self.maxHistRec(h)\\n            maxarea = max(maxarea,area)\\n        return maxarea\\n        \\n    def prefixSum(self,row):\\n        dp = [0 for _ in row]\\n        for i,v in enumerate(row):\\n            dp[i] = dp[i-1] + 1 if int(v) == 1 else 0\\n        return dp       \\n        \\n    def maxHistRec(self,hist):\\n        h = [-1] + hist + [-1]\\n        # use a stack\\n        stack = [0]\\n        area = 0\\n        for i in range(len(h)):\\n            while h[stack[-1]] > h[i]:\\n                j = stack.pop()\\n                area = max(area,h[j]*(i-stack[-1]-1))\\n            stack.append(i)\\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964501,
                "title": "o-n-2-faster-than-99",
                "content": "* h(r, c): if we start at (r, c) and go upwards, how many 1 cells do we find before the first 0?\\n* l(r, c): how far left can we extend a rectangle with bottom-right corner at (r, c) and height h(r, c)?\\n* r(r,c): how far right can we extend a rectangle with bottom-left corner at (r, c) and height h(r, c)?\\n* The three recurrence relations are:\\n\\n* h(0, c) = 0\\n* h(r, c) = 0 if matrix[r][c] == 0\\n* h(r, c) = h(r-1, c)+1 otherwise\\n* l(r, 0) = 0\\n* l(r, c) = c-p if matrix[r-1][c] == 0\\n* l(r, c) = min(l(r \\u2212 1, c), c \\u2212 p) otherwise\\n* r(r,C+1) = 0\\n* r(r,c) = p-c if matrix[r-1][c] == 0\\n* r(r,c) = min(r(r \\u2212 1, c), p \\u2212 c) otherwise\\nwhere p is the column of the previous 0 as we populate l from left-right and r from right-left.\\n\\nThe answer is then:\\n\\nmax_r,c(h(r, c) \\u2217 (l(r, c) + r(r, c) \\u2212 1))\\nThis works because of the observation that the largest rectangle will always touch a 0 (considering the edge as being covered in 0\\'s) on all four sides. By considering all rectangles with at least top, left and right touching a 0, we cover all candidate rectangles. Generate every possible rectangle. You can do this by iterating through every pair of points (r1,c1) (r2,c2) with r1 \\u2264 r2 and c1 \\u2264 c2 (can be done with 4 for loops). If a rectangle does not contain a 0, you compare the area to the largest area found so far.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int left[201][201], right[201][201], height[201][201];\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int n = matrix.size();\\n        if(n == 0)return 0;\\n        int m = matrix[0].size();\\n        if(m == 0)return 0;\\n        for(int i = 0; i < n; ++i){\\n            int l = -1;\\n            for(int j = 0; j < m; ++j){\\n                if(matrix[i][j] == \\'0\\'){\\n                    left[i][j] = j;\\n                    l = j;\\n                }else{\\n                    left[i][j] = l;\\n                }\\n            }\\n            int r = m;\\n            for(int j = m - 1; j >= 0; --j){\\n                if(matrix[i][j] == \\'0\\'){\\n                    right[i][j] = j;\\n                    r = j;\\n                }else right[i][j] = r;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < m; ++i){\\n            if(matrix[0][i] == \\'1\\'){\\n                height[0][i] = 1;\\n            }\\n            ans = max(ans, height[0][i] * (right[0][i] - left[0][i] - 1));\\n        }\\n        for(int i = 1; i < n; ++i){\\n            for(int j = 0; j < m; ++j){\\n                if(matrix[i][j] == \\'1\\'){\\n                    height[i][j] = height[i - 1][j] + 1;\\n                    if(height[i - 1][j] != 0){\\n                        left[i][j] = max(left[i][j], left[i - 1][j]);\\n                        right[i][j] = min(right[i][j], right[i - 1][j]);\\n                    } \\n                    ans = max(ans, height[i][j] * (right[i][j] - left[i][j] - 1));\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int left[201][201], right[201][201], height[201][201];\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int n = matrix.size();\\n        if(n == 0)return 0;\\n        int m = matrix[0].size();\\n        if(m == 0)return 0;\\n        for(int i = 0; i < n; ++i){\\n            int l = -1;\\n            for(int j = 0; j < m; ++j){\\n                if(matrix[i][j] == \\'0\\'){\\n                    left[i][j] = j;\\n                    l = j;\\n                }else{\\n                    left[i][j] = l;\\n                }\\n            }\\n            int r = m;\\n            for(int j = m - 1; j >= 0; --j){\\n                if(matrix[i][j] == \\'0\\'){\\n                    right[i][j] = j;\\n                    r = j;\\n                }else right[i][j] = r;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < m; ++i){\\n            if(matrix[0][i] == \\'1\\'){\\n                height[0][i] = 1;\\n            }\\n            ans = max(ans, height[0][i] * (right[0][i] - left[0][i] - 1));\\n        }\\n        for(int i = 1; i < n; ++i){\\n            for(int j = 0; j < m; ++j){\\n                if(matrix[i][j] == \\'1\\'){\\n                    height[i][j] = height[i - 1][j] + 1;\\n                    if(height[i - 1][j] != 0){\\n                        left[i][j] = max(left[i][j], left[i - 1][j]);\\n                        right[i][j] = min(right[i][j], right[i - 1][j]);\\n                    } \\n                    ans = max(ans, height[i][j] * (right[i][j] - left[i][j] - 1));\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836988,
                "title": "python-stack-solution-with-walk-through-example",
                "content": "**This solution can be broken down into two steps:**\\n1. Find the height of each column of ones for reach row.\\n2. Calculate the area of the largest rectangle whose top edge is touching the current row.  \\n\\nThese two steps are explained in the annotations of the code, but feel free to leave a comment if you have any questions.  \\n\\n```python\\ndef maximalRectangle(self, matrix: List[List[str]]) -> int:\\n\\n\\tdef update_heights(row: int) -> None:\\n\\t\\t\\'\\'\\'\\n\\t\\tUpdates heights in place.\\n\\t\\tInitially heights[col] represents the height at index (col) from the previous row.  \\n\\t\\tIf heights[col] IS NOT zero, then heights[col] of the current row will just be heights[col] - 1.\\n\\t\\tIf heights[col] IS zero, then traverse up column matrix[row:][col] to find the height of the column.  \\n\\t\\t\\'\\'\\'\\n\\t\\tnonlocal heights, matrix\\n\\n\\t\\tfor col,h in enumerate(heights):\\n\\t\\t\\tif h:\\n\\t\\t\\t\\theights[col] -= 1\\n\\t\\t\\telif matrix[row][col] == \\'0\\':\\n\\t\\t\\t\\theights[col] = 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcount = 1\\n\\t\\t\\t\\twhile (count + row < R) and matrix[count+row][col] == \\'1\\':\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\theights[col] = count\\n\\n\\tdef largest_rectangle() -> int:\\n\\t\\t\\'\\'\\'\\n\\t\\tReturns the area of the largest rectangle.  \\n\\t\\tOnly rectangles whose top edge is in the current row are considered.\\n\\t\\t\\'\\'\\'\\n\\t\\tnonlocal heights, matrix\\n\\n\\t\\t# 1. Find the index of the first column to the RIGHT of (i) that is shorter than heights[i]\\n\\t\\tright = [len(heights)]*len(heights)\\n\\t\\tstack = []\\n\\t\\tfor i,h1 in enumerate(heights):\\n\\t\\t\\twhile stack and (h1 < stack[-1][1]):\\n\\t\\t\\t\\tj,h2 = stack.pop()\\n\\t\\t\\t\\tright[j] = i\\n\\t\\t\\tstack.append((i,h1))\\n\\n\\t\\t# 2. Find the index of the first column to the LEFT of (i) that is shorter than heights[i]\\n\\t\\tleft = [-1]*len(heights)\\n\\t\\tstack = []\\n\\t\\tfor i in range(len(heights)-1,-1,-1):\\n\\t\\t\\th1 = heights[i]\\n\\t\\t\\twhile stack and (h1 < stack[-1][1]):\\n\\t\\t\\t\\tj,h2 = stack.pop()\\n\\t\\t\\t\\tleft[j] = i\\n\\t\\t\\tstack.append((i,h1))\\n\\n\\t\\t# 3. The largest rectangle at each location will be height (h) times the width (right[i] - left[i] - 1)\\n\\t\\treturn max(h * (right[i] - left[i] - 1) for i,h in enumerate(heights))\\n\\n\\tres = 0\\n\\tif not matrix: return res\\n\\tR, C = len(matrix), len(matrix[0])\\n\\theights = [0]*C # 1\\n\\n\\tfor row in range(R):\\n\\t\\tupdate_heights(row)                 # 2.1\\n\\t\\tres = max(res, largest_rectangle()) # 2.2\\n\\n\\treturn res     \\n```\\n\\n**Here is a walk-through of the example in the description:**\\n\\n(#1) Heights is initialized to [0, 0, 0, 0, 0] meaning the height of every column still needs to be calculated.  \\n\\n(#2.1) Update heights for the first row:\\n**Row 0: heights = [4, 0, 3, 0, 0] ; area = 4 ; res = max(0, 4)**\\n\\n  [<b>\"1\"</b>,\"0\",<b>\"1\"</b>,\"0\",\"0\"]\\n  [<b>\"1\"</b>,\"0\",<b>\"1\"</b>,\"1\",\"1\"]\\n  [<b>\"1\"</b>,\"1\",<b>\"1\"</b>,\"1\",\"1\"]\\n  [<b>\"1\"</b>,\"0\",\"0\", \"1\",\"0\"]\\n\\n(#2.2) Calculate the largest rectangle area, of rectangles whose top is at row 0.  \\n```\\ni.e. Column 0 has an area of 4 # largest area is 4\\n     Column 1 has an area of 0\\n     Column 2 has an area of 3\\n     Column 3 has an area of 0\\n     Column 4 has an area of 0\\n```\\n(#3) Repeat steps (#2.1) and (#2.2) for the remaining rows, updating **res** at each step:\\n\\n**Row 1: heights = [3, 0, 2, 3, 2] ; area = 6 ; res = max(4, 6)**\\n  [\"1\", \"0\",\"1\", \"0\", \"0\"]\\n  [<b>\"1\"</b>,\"0\",<b>\"1\"</b>,<b>\"1\"</b>,<b>\"1\"</b>]\\n  [<b>\"1\"</b>,\"1\",<b>\"1\"</b>,<b>\"1\"</b>,<b>\"1\"</b>]\\n  [<b>\"1\"</b>,\"0\",\"0\", <b>\"1\"</b>, \"0\"]\\n  \\n```\\n                          # height * (right_index - left_index - 1) = area\\nColumn 0 has an area of 3 # 3 * (1 - (-1) - 1) = 3\\nColumn 1 has an area of 0 # 0 * (5 - (-1) - 1) = 0\\nColumn 2 has an area of 6 # 2 * (5 - 1 - 1) = 6\\nColumn 3 has an area of 3 # 3 * (4 - 2 - 1) = 3\\nColumn 4 has an area of 6 # 2 * (5 - 1 - 1) = 6\\n```\\n  \\n**Row 2: heights = [2, 1, 1, 2, 1] ; area = 5 ; res = max(6, 5)**\\n  [\"1\", \"0\", \"1\", \"0\", \"0\"]\\n  [\"1\", \"0\", \"1\", \"1\", \"1\"]\\n  [<b>\"1\"</b>,<b>\"1\"</b>,<b>\"1\"</b>,<b>\"1\"</b>,<b>\"1\"</b>]\\n  [<b>\"1\"</b>, \"0\", \"0\",<b>\"1\"</b>, \"0\"]\\n  \\n**Row 3: heights = [1, 0, 0, 1, 0] ; area = 1 ; res = max(6, 1)**\\n  [\"1\", \"0\",\"1\",\"0\", \"0\"]\\n  [\"1\", \"0\",\"1\",\"1\", \"1\"]\\n  [\"1\", \"1\",\"1\",\"1\", \"1\"]\\n  [<b>\"1\"</b>,\"0\",\"0\",<b>\"1\"</b>,\"0\"]",
                "solutionTags": [],
                "code": "```python\\ndef maximalRectangle(self, matrix: List[List[str]]) -> int:\\n\\n\\tdef update_heights(row: int) -> None:\\n\\t\\t\\'\\'\\'\\n\\t\\tUpdates heights in place.\\n\\t\\tInitially heights[col] represents the height at index (col) from the previous row.  \\n\\t\\tIf heights[col] IS NOT zero, then heights[col] of the current row will just be heights[col] - 1.\\n\\t\\tIf heights[col] IS zero, then traverse up column matrix[row:][col] to find the height of the column.  \\n\\t\\t\\'\\'\\'\\n\\t\\tnonlocal heights, matrix\\n\\n\\t\\tfor col,h in enumerate(heights):\\n\\t\\t\\tif h:\\n\\t\\t\\t\\theights[col] -= 1\\n\\t\\t\\telif matrix[row][col] == \\'0\\':\\n\\t\\t\\t\\theights[col] = 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcount = 1\\n\\t\\t\\t\\twhile (count + row < R) and matrix[count+row][col] == \\'1\\':\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\theights[col] = count\\n\\n\\tdef largest_rectangle() -> int:\\n\\t\\t\\'\\'\\'\\n\\t\\tReturns the area of the largest rectangle.  \\n\\t\\tOnly rectangles whose top edge is in the current row are considered.\\n\\t\\t\\'\\'\\'\\n\\t\\tnonlocal heights, matrix\\n\\n\\t\\t# 1. Find the index of the first column to the RIGHT of (i) that is shorter than heights[i]\\n\\t\\tright = [len(heights)]*len(heights)\\n\\t\\tstack = []\\n\\t\\tfor i,h1 in enumerate(heights):\\n\\t\\t\\twhile stack and (h1 < stack[-1][1]):\\n\\t\\t\\t\\tj,h2 = stack.pop()\\n\\t\\t\\t\\tright[j] = i\\n\\t\\t\\tstack.append((i,h1))\\n\\n\\t\\t# 2. Find the index of the first column to the LEFT of (i) that is shorter than heights[i]\\n\\t\\tleft = [-1]*len(heights)\\n\\t\\tstack = []\\n\\t\\tfor i in range(len(heights)-1,-1,-1):\\n\\t\\t\\th1 = heights[i]\\n\\t\\t\\twhile stack and (h1 < stack[-1][1]):\\n\\t\\t\\t\\tj,h2 = stack.pop()\\n\\t\\t\\t\\tleft[j] = i\\n\\t\\t\\tstack.append((i,h1))\\n\\n\\t\\t# 3. The largest rectangle at each location will be height (h) times the width (right[i] - left[i] - 1)\\n\\t\\treturn max(h * (right[i] - left[i] - 1) for i,h in enumerate(heights))\\n\\n\\tres = 0\\n\\tif not matrix: return res\\n\\tR, C = len(matrix), len(matrix[0])\\n\\theights = [0]*C # 1\\n\\n\\tfor row in range(R):\\n\\t\\tupdate_heights(row)                 # 2.1\\n\\t\\tres = max(res, largest_rectangle()) # 2.2\\n\\n\\treturn res     \\n```\n```\\ni.e. Column 0 has an area of 4 # largest area is 4\\n     Column 1 has an area of 0\\n     Column 2 has an area of 3\\n     Column 3 has an area of 0\\n     Column 4 has an area of 0\\n```\n```\\n                          # height * (right_index - left_index - 1) = area\\nColumn 0 has an area of 3 # 3 * (1 - (-1) - 1) = 3\\nColumn 1 has an area of 0 # 0 * (5 - (-1) - 1) = 0\\nColumn 2 has an area of 6 # 2 * (5 - 1 - 1) = 6\\nColumn 3 has an area of 3 # 3 * (4 - 2 - 1) = 3\\nColumn 4 has an area of 6 # 2 * (5 - 1 - 1) = 6\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 769455,
                "title": "python-dp-soln-on-largest-rect-in-histogram-faster-than-91",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def histogramArea(self,A):\\n        n = len(A)\\n        stack = deque()\\n        \\n        max_area = 0\\n        i = 0\\n        \\n        while i < n:\\n            if not stack or A[stack[-1]] <= A[i]:\\n                stack.append(i)\\n                i += 1\\n            else:\\n                top = stack.pop()\\n                area = A[top] * ((i - stack[-1] -1) if stack else i)\\n                max_area = max(area, max_area)\\n        \\n        while stack:\\n            top = stack.pop()\\n            area = A[top] * ((i - stack[-1] -1) if stack else i)\\n            max_area = max(area, max_area)\\n        \\n        return max_area\\n            \\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        m = len(matrix)\\n        if m == 0: return 0\\n        n = len(matrix[0])\\n        \\n        dp = [int(i) for i in matrix[0]]\\n        ans = 0\\n        \\n        area = self.histogramArea(dp)\\n        ans = max(ans,area)\\n        \\n        for i in range(1,m):\\n            for j in range(n):\\n                if matrix[i][j] == \\'1\\':\\n                    dp[j] += 1\\n                else:\\n                    dp[j] = 0\\n                    \\n            area = self.histogramArea(dp)\\n            ans = max(ans,area)\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def histogramArea(self,A):\\n        n = len(A)\\n        stack = deque()\\n        \\n        max_area = 0\\n        i = 0\\n        \\n        while i < n:\\n            if not stack or A[stack[-1]] <= A[i]:\\n                stack.append(i)\\n                i += 1\\n            else:\\n                top = stack.pop()\\n                area = A[top] * ((i - stack[-1] -1) if stack else i)\\n                max_area = max(area, max_area)\\n        \\n        while stack:\\n            top = stack.pop()\\n            area = A[top] * ((i - stack[-1] -1) if stack else i)\\n            max_area = max(area, max_area)\\n        \\n        return max_area\\n            \\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        m = len(matrix)\\n        if m == 0: return 0\\n        n = len(matrix[0])\\n        \\n        dp = [int(i) for i in matrix[0]]\\n        ans = 0\\n        \\n        area = self.histogramArea(dp)\\n        ans = max(ans,area)\\n        \\n        for i in range(1,m):\\n            for j in range(n):\\n                if matrix[i][j] == \\'1\\':\\n                    dp[j] += 1\\n                else:\\n                    dp[j] = 0\\n                    \\n            area = self.histogramArea(dp)\\n            ans = max(ans,area)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679232,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        if(matrix ==null || matrix.length==0)\\n            return 0;\\n        \\n        int[] dp = new int[matrix[0].length];\\n        int res = 0;\\n        for(int i=0;i<matrix.length;i++) {\\n            for(int j=0;j<matrix[0].length;j++) {\\n                if(matrix[i][j] == \\'0\\') {\\n                    dp[j] = 0;\\n                    continue;\\n                }\\n                dp[j] = dp[j] + matrix[i][j]-\\'0\\';\\n            }\\n            res = Math.max(res, histogra(dp));\\n        }\\n        return res;\\n    }\\n    \\n    private int histogra(int[] dp) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int res = 0;\\n        for(int i=0;i<dp.length;i++) {\\n            \\n            while(!st.isEmpty() && dp[i] <= dp[st.peek()] ) {\\n                \\n                int top = st.pop();\\n                int area = (i-(st.isEmpty() ? -1 : st.peek())-1)*dp[top];\\n                res = Math.max(area, res);\\n            }   \\n            st.push(i);\\n        }\\n        while(!st.isEmpty()) {\\n            int top = st.pop();\\n            int area = (dp.length-(st.isEmpty() ? -1 : st.peek())-1)*dp[top];\\n            res = Math.max(area, res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        if(matrix ==null || matrix.length==0)\\n            return 0;\\n        \\n        int[] dp = new int[matrix[0].length];\\n        int res = 0;\\n        for(int i=0;i<matrix.length;i++) {\\n            for(int j=0;j<matrix[0].length;j++) {\\n                if(matrix[i][j] == \\'0\\') {\\n                    dp[j] = 0;\\n                    continue;\\n                }\\n                dp[j] = dp[j] + matrix[i][j]-\\'0\\';\\n            }\\n            res = Math.max(res, histogra(dp));\\n        }\\n        return res;\\n    }\\n    \\n    private int histogra(int[] dp) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int res = 0;\\n        for(int i=0;i<dp.length;i++) {\\n            \\n            while(!st.isEmpty() && dp[i] <= dp[st.peek()] ) {\\n                \\n                int top = st.pop();\\n                int area = (i-(st.isEmpty() ? -1 : st.peek())-1)*dp[top];\\n                res = Math.max(area, res);\\n            }   \\n            st.push(i);\\n        }\\n        while(!st.isEmpty()) {\\n            int top = st.pop();\\n            int area = (dp.length-(st.isEmpty() ? -1 : st.peek())-1)*dp[top];\\n            res = Math.max(area, res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623207,
                "title": "c-simple-o-nm-time-space-solution",
                "content": "```\\n// note that there are 2 published O(M) space solutions \\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) \\n    {\\n        if (matrix.empty ())\\n            return 0;\\n        \\n        vector <vector <pair <int,int>>> dp (matrix.size ()+1, vector <pair <int,int>> (matrix [0].size ()+1)); // largest rectangle with (i-1, j-1) as bottom right vertex.\\n        vector <vector <int>> dpr (matrix.size ()+1, vector <int> (matrix [0].size ()+1)); // longest horizontal line with (i-1, j-1) as right end point.\\n        vector <vector <int>> dpc = dpr; // tallent vertical line with (i-1, j-1) as bottom end point.\\n        int ret = 0;\\n        \\n        for (int i = 0; i < matrix.size (); i++)\\n            for (int j = 0; j < matrix [0].size (); j++)\\n                if (matrix [i][j] == \\'1\\')\\n                {\\n                    // build out horizontal, vertical lines.\\n                    dpr [i+1][j+1] = 1 + dpr [i+1][j];\\n                    dpc [i+1][j+1] = 1 + dpc [i][j+1];\\n                    \\n                    // build out rectangle.\\n                    // 1. based on contained rectangle with current row, column taken out.\\n                    dp [i+1][j+1] = {1 + min (dp [i][j].first, dpc [i][j+1]), 1 + min (dp [i][j].second, dpr [i+1][j])};\\n                    \\n                    // 2. based on horizontal line.\\n                    if (dpr [i+1][j+1] > dp [i+1][j+1].first * dp [i+1][j+1].second)\\n                        dp [i+1][j+1] = {1, dpr [i+1][j+1]};\\n                    \\n                    // 3. based on veritical line.\\n                    if (dpc [i+1][j+1] > dp [i+1][j+1].first * dp [i+1][j+1].second)\\n                        dp [i+1][j+1] = {dpc [i+1][j+1], 1};\\n                    \\n                    // maintain return value.\\n                    ret = max (ret, dp [i+1][j+1].first * dp [i+1][j+1].second);\\n                }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// note that there are 2 published O(M) space solutions \\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) \\n    {\\n        if (matrix.empty ())\\n            return 0;\\n        \\n        vector <vector <pair <int,int>>> dp (matrix.size ()+1, vector <pair <int,int>> (matrix [0].size ()+1)); // largest rectangle with (i-1, j-1) as bottom right vertex.\\n        vector <vector <int>> dpr (matrix.size ()+1, vector <int> (matrix [0].size ()+1)); // longest horizontal line with (i-1, j-1) as right end point.\\n        vector <vector <int>> dpc = dpr; // tallent vertical line with (i-1, j-1) as bottom end point.\\n        int ret = 0;\\n        \\n        for (int i = 0; i < matrix.size (); i++)\\n            for (int j = 0; j < matrix [0].size (); j++)\\n                if (matrix [i][j] == \\'1\\')\\n                {\\n                    // build out horizontal, vertical lines.\\n                    dpr [i+1][j+1] = 1 + dpr [i+1][j];\\n                    dpc [i+1][j+1] = 1 + dpc [i][j+1];\\n                    \\n                    // build out rectangle.\\n                    // 1. based on contained rectangle with current row, column taken out.\\n                    dp [i+1][j+1] = {1 + min (dp [i][j].first, dpc [i][j+1]), 1 + min (dp [i][j].second, dpr [i+1][j])};\\n                    \\n                    // 2. based on horizontal line.\\n                    if (dpr [i+1][j+1] > dp [i+1][j+1].first * dp [i+1][j+1].second)\\n                        dp [i+1][j+1] = {1, dpr [i+1][j+1]};\\n                    \\n                    // 3. based on veritical line.\\n                    if (dpc [i+1][j+1] > dp [i+1][j+1].first * dp [i+1][j+1].second)\\n                        dp [i+1][j+1] = {dpc [i+1][j+1], 1};\\n                    \\n                    // maintain return value.\\n                    ret = max (ret, dp [i+1][j+1].first * dp [i+1][j+1].second);\\n                }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616182,
                "title": "python-same-idea-as-leetcode-84-largest-histogram-area",
                "content": "```python\\nclass Solution(object):\\n    def maxArea(self, bar):\\n        if not bar:\\n            return 0\\n        bar.append(0)\\n        s, ret = [], 0\\n        for i in range(len(bar)):\\n            while s and bar[i] <= bar[s[-1]]:\\n                h = bar[s[-1]]\\n                s.pop()\\n                if s:\\n                    w = i -1 - s[-1]\\n                else:\\n                    w = i\\n                ret = max(ret, h*w)\\n            s.append(i)\\n        return ret\\n    def maximalRectangle(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        M, N = len(matrix), len(matrix[0])\\n        bar = [0]*N\\n        ret = 0\\n        for i in range(M):\\n            for j in range(N):\\n                if matrix[i][j] == \\'1\\':\\n                    bar[j]+=1\\n                else:\\n                    bar[j] = 0\\n            ret = max(ret, self.maxArea(bar))\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maxArea(self, bar):\\n        if not bar:\\n            return 0\\n        bar.append(0)\\n        s, ret = [], 0\\n        for i in range(len(bar)):\\n            while s and bar[i] <= bar[s[-1]]:\\n                h = bar[s[-1]]\\n                s.pop()\\n                if s:\\n                    w = i -1 - s[-1]\\n                else:\\n                    w = i\\n                ret = max(ret, h*w)\\n            s.append(i)\\n        return ret\\n    def maximalRectangle(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        M, N = len(matrix), len(matrix[0])\\n        bar = [0]*N\\n        ret = 0\\n        for i in range(M):\\n            for j in range(N):\\n                if matrix[i][j] == \\'1\\':\\n                    bar[j]+=1\\n                else:\\n                    bar[j] = 0\\n            ret = max(ret, self.maxArea(bar))\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562266,
                "title": "5-ms-sec-java-solution-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int row=matrix.length;\\n        if(row==0)\\n            return 0;\\n        int col=matrix[0].length;\\n        int[][] left=new int[row][col];//to keep track of max left.->->->\\n        int[][] up=new int[row][col];//to keep track of max top.^\\n        int max=0;\\n        if(matrix[0][0]==\\'1\\')\\n        {\\n            left[0][0]=1;\\n            up[0][0]=1;\\n            max=1;\\n        }\\n        for(int i=1;i<row;i++)\\n        {\\n            if(matrix[i][0]==\\'1\\'){\\n                up[i][0]=up[i-1][0]+1;\\n                left[i][0]=1;\\n                max=Math.max(up[i][0],max);\\n            }\\n        }\\n        \\n        for(int j=1;j<col;j++)\\n        {\\n            if(matrix[0][j]==\\'1\\'){\\n                left[0][j]=left[0][j-1]+1;\\n                up[0][j]=1;\\n                max=Math.max(left[0][j],max);\\n            }\\n        }\\n        for(int i=1;i<row;i++)\\n        {\\n            for(int j=1;j<col;j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    int upto=0;\\n                    left[i][j]=left[i][j-1]+1;\\n                    up[i][j]=up[i-1][j]+1;\\n                    \\n                    if(left[i][j]>1 && up[i][j]>1)\\n                    {\\n                        int val=0; \\n                        int track=i;\\n                        int min=left[i][j];\\n                        while(track>=0 && left[track][j]>1 && up[track][j]>=1)//this is important when both top and left are\\n                        {                                                     //non zero\\n                            if(min>left[track][j])\\n                                min=left[track][j];\\n                            val++;\\n                            upto=Math.max(min*val,upto);\\n                            track--;\\n                        }\\n                    }\\n                    \\n                    max=Math.max(max,Math.max(left[i][j],Math.max(up[i][j],upto)));\\n                }\\n                else\\n                {\\n                    left[i][j]=0;\\n                    up[i][j]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int row=matrix.length;\\n        if(row==0)\\n            return 0;\\n        int col=matrix[0].length;\\n        int[][] left=new int[row][col];//to keep track of max left.->->->\\n        int[][] up=new int[row][col];//to keep track of max top.^\\n        int max=0;\\n        if(matrix[0][0]==\\'1\\')\\n        {\\n            left[0][0]=1;\\n            up[0][0]=1;\\n            max=1;\\n        }\\n        for(int i=1;i<row;i++)\\n        {\\n            if(matrix[i][0]==\\'1\\'){\\n                up[i][0]=up[i-1][0]+1;\\n                left[i][0]=1;\\n                max=Math.max(up[i][0],max);\\n            }\\n        }\\n        \\n        for(int j=1;j<col;j++)\\n        {\\n            if(matrix[0][j]==\\'1\\'){\\n                left[0][j]=left[0][j-1]+1;\\n                up[0][j]=1;\\n                max=Math.max(left[0][j],max);\\n            }\\n        }\\n        for(int i=1;i<row;i++)\\n        {\\n            for(int j=1;j<col;j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    int upto=0;\\n                    left[i][j]=left[i][j-1]+1;\\n                    up[i][j]=up[i-1][j]+1;\\n                    \\n                    if(left[i][j]>1 && up[i][j]>1)\\n                    {\\n                        int val=0; \\n                        int track=i;\\n                        int min=left[i][j];\\n                        while(track>=0 && left[track][j]>1 && up[track][j]>=1)//this is important when both top and left are\\n                        {                                                     //non zero\\n                            if(min>left[track][j])\\n                                min=left[track][j];\\n                            val++;\\n                            upto=Math.max(min*val,upto);\\n                            track--;\\n                        }\\n                    }\\n                    \\n                    max=Math.max(max,Math.max(left[i][j],Math.max(up[i][j],upto)));\\n                }\\n                else\\n                {\\n                    left[i][j]=0;\\n                    up[i][j]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544591,
                "title": "java-dp",
                "content": "\\t// Induction Rule: dp[i][j] represents the cur largest length at row i, from 0 to j\\n\\t// Base case: j == 0 && matrix[i][j] == 1  --> length == 1\\n\\t// Time: O(rows * cols * rows) --> O(rows * rows * cols) = O(N^2 * M)\\n\\t// Space: 2d array : O(rows * cols) -> O(N * M)\\n\\tclass Solution {\\n\\t\\tpublic int maximalRectangle(char[][] matrix) {\\n\\t\\t\\tif (matrix == null || matrix.length == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint maxArea = 0;\\n\\t\\t\\tint rows = matrix.length;\\n\\t\\t\\tint cols = matrix[0].length;\\n\\t\\t\\tint[][] dp = new int[rows][cols];\\n\\t\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\t\\t\\tif (matrix[i][j] == \\'1\\') {\\n\\t\\t\\t\\t\\t\\tdp[i][j] = j == 0 ? 1 : dp[i][j - 1] + 1; \\n\\t\\t\\t\\t\\t\\tint length = dp[i][j];\\n\\t\\t\\t\\t\\t\\tfor (int k = i; k >= 0; k--) {\\n\\t\\t\\t\\t\\t\\t\\tlength = Math.min(length, dp[k][j]);  // horizontal \\n\\t\\t\\t\\t\\t\\t\\tint width = i - k + 1; // vertical\\n\\t\\t\\t\\t\\t\\t\\tmaxArea = Math.max(maxArea, length * width);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\treturn maxArea;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int maximalRectangle(char[][] matrix) {\\n\\t\\t\\tif (matrix == null || matrix.length == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 495606,
                "title": "easy-solution-based-on-leetcode-84-largest-rectangle-in-histogram-beats-78-15",
                "content": "```\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nvar maximalRectangle = function(matrix) {\\n    if (!matrix || !matrix.length) {\\n        return 0;\\n    }\\n    \\n    const m = matrix.length;\\n    const n = matrix[0].length;\\n    const heights = Array(n).fill(0);\\n    let max = 0;\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            heights[j] = matrix[i][j] == \\'1\\' ? heights[j] + 1 : 0;\\n        }\\n        max = Math.max(max, maximalRectangleInHistogram(heights));\\n    }\\n    \\n    return max;\\n};\\n\\nfunction maximalRectangleInHistogram(heights) {\\n    const n = heights.length;\\n    const left = Array(n).fill(0);\\n    const right = Array(n).fill(n-1);\\n    let max = 0;\\n    \\n    for (let i = 1; i < n; i++) {\\n        let j = i - 1;\\n        while (j >= 0 && heights[j] >= heights[i]) {\\n            j = left[j] - 1;\\n        }\\n        left[i] = j + 1;\\n    }\\n    \\n    for (let i = n - 2; i >= 0; i--) {\\n        let j = i + 1;\\n        while (j < n && heights[j] >= heights[i]) {\\n            j = right[j] + 1;\\n        }\\n        right[i] = j - 1;\\n    }\\n    \\n    for (let i = 0; i < n; i++) {\\n        max = Math.max(max, heights[i] * (right[i] - left[i] + 1));\\n    }\\n    \\n    return max;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nvar maximalRectangle = function(matrix) {\\n    if (!matrix || !matrix.length) {\\n        return 0;\\n    }\\n    \\n    const m = matrix.length;\\n    const n = matrix[0].length;\\n    const heights = Array(n).fill(0);\\n    let max = 0;\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            heights[j] = matrix[i][j] == \\'1\\' ? heights[j] + 1 : 0;\\n        }\\n        max = Math.max(max, maximalRectangleInHistogram(heights));\\n    }\\n    \\n    return max;\\n};\\n\\nfunction maximalRectangleInHistogram(heights) {\\n    const n = heights.length;\\n    const left = Array(n).fill(0);\\n    const right = Array(n).fill(n-1);\\n    let max = 0;\\n    \\n    for (let i = 1; i < n; i++) {\\n        let j = i - 1;\\n        while (j >= 0 && heights[j] >= heights[i]) {\\n            j = left[j] - 1;\\n        }\\n        left[i] = j + 1;\\n    }\\n    \\n    for (let i = n - 2; i >= 0; i--) {\\n        let j = i + 1;\\n        while (j < n && heights[j] >= heights[i]) {\\n            j = right[j] + 1;\\n        }\\n        right[i] = j - 1;\\n    }\\n    \\n    for (let i = 0; i < n; i++) {\\n        max = Math.max(max, heights[i] * (right[i] - left[i] + 1));\\n    }\\n    \\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 494079,
                "title": "c-reuse-code-in-question-84",
                "content": "```\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        const int m = matrix.size();\\n        if (m == 0) return 0;\\n        const int n = matrix[0].size();\\n        if (n == 0) return 0;\\n        vector<vector<int>> vert_dp(m, vector<int>(n)); // height of vertical segmanet whose bottom point is [i][j]\\n        \\n        for (int j = 0; j < n; j++){\\n            vert_dp[0][j] = (matrix[0][j] == \\'1\\');\\n            for (int i = 1; i < m; i++){\\n                vert_dp[i][j] = (matrix[i][j] == \\'1\\') ? vert_dp[i-1][j]+1 : 0;\\n            }\\n        }\\n        \\n        int cur_max = 0;\\n        for (int i = 0; i < m; i++){\\n            cur_max = max(cur_max, largestRectangleArea(vert_dp[i]));\\n        }\\n        \\n        return cur_max;\\n    }\\n    \\n    \\n    // 84.largestRectangleArea() by:\\n    // https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/492959/C%2B%2B-easy-using-stack\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> s;\\n        if(heights.size()==0)return 0;\\n        int ans = heights[0];\\n        int n = heights.size();\\n        int i = 0;\\n        int tp = 0;\\n        while(i<n) {\\n            if(s.empty() || heights[s.top()] <= heights[i]) { // ensure the heights in stack is ascending\\n                s.push(i++);\\n                //cout << s.top()  << \": \" << heights[s.top()] << endl;\\n            } else { // drive out all the previous heights that is greater than heights[i]\\n                tp = s.top();\\n                s.pop();\\n                ans = max(ans, heights[tp] * (s.empty()?i: i - s.top() - 1)); \\n                // indexes from s.top() to i-1, because heights[i-1] >= s.top()\\n            }\\n        }\\n        \\n        while(!s.empty()) {\\n            tp = s.top();\\n            s.pop();\\n            ans = max(ans,heights[tp] *  (s.empty()?i: i - s.top() - 1));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        const int m = matrix.size();\\n        if (m == 0) return 0;\\n        const int n = matrix[0].size();\\n        if (n == 0) return 0;\\n        vector<vector<int>> vert_dp(m, vector<int>(n)); // height of vertical segmanet whose bottom point is [i][j]\\n        \\n        for (int j = 0; j < n; j++){\\n            vert_dp[0][j] = (matrix[0][j] == \\'1\\');\\n            for (int i = 1; i < m; i++){\\n                vert_dp[i][j] = (matrix[i][j] == \\'1\\') ? vert_dp[i-1][j]+1 : 0;\\n            }\\n        }\\n        \\n        int cur_max = 0;\\n        for (int i = 0; i < m; i++){\\n            cur_max = max(cur_max, largestRectangleArea(vert_dp[i]));\\n        }\\n        \\n        return cur_max;\\n    }\\n    \\n    \\n    // 84.largestRectangleArea() by:\\n    // https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/492959/C%2B%2B-easy-using-stack\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> s;\\n        if(heights.size()==0)return 0;\\n        int ans = heights[0];\\n        int n = heights.size();\\n        int i = 0;\\n        int tp = 0;\\n        while(i<n) {\\n            if(s.empty() || heights[s.top()] <= heights[i]) { // ensure the heights in stack is ascending\\n                s.push(i++);\\n                //cout << s.top()  << \": \" << heights[s.top()] << endl;\\n            } else { // drive out all the previous heights that is greater than heights[i]\\n                tp = s.top();\\n                s.pop();\\n                ans = max(ans, heights[tp] * (s.empty()?i: i - s.top() - 1)); \\n                // indexes from s.top() to i-1, because heights[i-1] >= s.top()\\n            }\\n        }\\n        \\n        while(!s.empty()) {\\n            tp = s.top();\\n            s.pop();\\n            ans = max(ans,heights[tp] *  (s.empty()?i: i - s.top() - 1));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 474014,
                "title": "accepted-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        //https://leetcode.com/problems/largest-rectangle-in-histogram/\\n        private int LargestRectangleArea(int[] heights)\\n        {\\n            if (heights.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            if (heights.Length == 1)\\n            {\\n                return heights[0];\\n            }\\n\\n            int res = heights[0];\\n            Stack<int> indices = new Stack<int>();\\n            for (int i = 0; i < heights.Length; i++)\\n            {\\n                while (indices.Count > 0 && heights[indices.Peek()] >= heights[i])\\n                {\\n                    var pop = indices.Pop();\\n                    var leftMost = indices.Count > 0 ? indices.Peek() + 1 : 0;\\n                    res = Math.Max(res, heights[pop] * (i - leftMost));\\n                }\\n                indices.Push(i);\\n            }\\n\\n            while (indices.Count > 0)\\n            {\\n                var pop = indices.Pop();\\n                var leftMost = indices.Count > 0 ? indices.Peek() + 1 : 0;\\n                res = Math.Max(res, heights[pop] * (heights.Length - leftMost));\\n            }\\n            return res;\\n        }\\n\\n        public int MaximalRectangle(char[][] matrix)\\n        {\\n            if (matrix.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            int res = 0;\\n\\n            int[] heights = null;\\n            for (int i = 0; i < matrix.Length; i++)\\n            {\\n                if (heights == null)\\n                {\\n                    heights = matrix[i].Select(c => c - \\'0\\').ToArray();\\n                }\\n                else\\n                {\\n                    for (int j = 0; j < matrix[i].Length; j++)\\n                    {\\n                        if (matrix[i][j] == \\'0\\')\\n                        {\\n                            heights[j] = 0;\\n                        }\\n                        else\\n                        {\\n                            heights[j]++;\\n                        }\\n                    }\\n                }\\n\\n                res = Math.Max(res, LargestRectangleArea(heights));\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        //https://leetcode.com/problems/largest-rectangle-in-histogram/\\n        private int LargestRectangleArea(int[] heights)\\n        {\\n            if (heights.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            if (heights.Length == 1)\\n            {\\n                return heights[0];\\n            }\\n\\n            int res = heights[0];\\n            Stack<int> indices = new Stack<int>();\\n            for (int i = 0; i < heights.Length; i++)\\n            {\\n                while (indices.Count > 0 && heights[indices.Peek()] >= heights[i])\\n                {\\n                    var pop = indices.Pop();\\n                    var leftMost = indices.Count > 0 ? indices.Peek() + 1 : 0;\\n                    res = Math.Max(res, heights[pop] * (i - leftMost));\\n                }\\n                indices.Push(i);\\n            }\\n\\n            while (indices.Count > 0)\\n            {\\n                var pop = indices.Pop();\\n                var leftMost = indices.Count > 0 ? indices.Peek() + 1 : 0;\\n                res = Math.Max(res, heights[pop] * (heights.Length - leftMost));\\n            }\\n            return res;\\n        }\\n\\n        public int MaximalRectangle(char[][] matrix)\\n        {\\n            if (matrix.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            int res = 0;\\n\\n            int[] heights = null;\\n            for (int i = 0; i < matrix.Length; i++)\\n            {\\n                if (heights == null)\\n                {\\n                    heights = matrix[i].Select(c => c - \\'0\\').ToArray();\\n                }\\n                else\\n                {\\n                    for (int j = 0; j < matrix[i].Length; j++)\\n                    {\\n                        if (matrix[i][j] == \\'0\\')\\n                        {\\n                            heights[j] = 0;\\n                        }\\n                        else\\n                        {\\n                            heights[j]++;\\n                        }\\n                    }\\n                }\\n\\n                res = Math.Max(res, LargestRectangleArea(heights));\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391679,
                "title": "python-solution-using-stack-and-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        mat = matrix\\n        if mat==[]:\\n            return 0\\n        else:\\n            def histogram_area(arr):\\n                stack = []\\n                max_area,index = 0,0\\n                while index<len(arr):\\n                    if (not stack) or (arr[stack[-1]])<=arr[index]:\\n                        stack.append(index)\\n                        index+=1\\n                    else:\\n                        top = stack.pop()\\n                        if stack:\\n                            area = arr[top]*(index-stack[-1]-1)\\n                        else:\\n                            area = arr[top]*index\\n                        max_area = max(area,max_area)\\n                while stack:\\n                    top = stack.pop()\\n                    if stack:\\n                        area = arr[top]*(index-stack[-1]-1)\\n                    else:\\n                        area = arr[top]*index\\n                    max_area = max(area,max_area)\\n                return max_area\\n            for i in range(len(mat)):\\n                if i==0:\\n                    arr = []\\n                    for j in mat[i]:\\n                        if j==\\'0\\':\\n                            arr.append(0)\\n                        else:\\n                            arr.append(1)\\n                    max_area = histogram_area(arr)\\n                else:\\n                    temp = []\\n                    for j in range(len(mat[i])):\\n                        if mat[i][j] == \\'0\\':\\n                            temp.append(0)\\n                        else:\\n                            temp.append(arr[j]+1)\\n                    area = histogram_area(temp)\\n                    max_area = max(area,max_area)\\n                    arr = temp\\n            return max_area\\n                        \\n                        \\n        \\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        mat = matrix\\n        if mat==[]:\\n            return 0\\n        else:\\n            def histogram_area(arr):\\n                stack = []\\n                max_area,index = 0,0\\n                while index<len(arr):\\n                    if (not stack) or (arr[stack[-1]])<=arr[index]:\\n                        stack.append(index)\\n                        index+=1\\n                    else:\\n                        top = stack.pop()\\n                        if stack:\\n                            area = arr[top]*(index-stack[-1]-1)\\n                        else:\\n                            area = arr[top]*index\\n                        max_area = max(area,max_area)\\n                while stack:\\n                    top = stack.pop()\\n                    if stack:\\n                        area = arr[top]*(index-stack[-1]-1)\\n                    else:\\n                        area = arr[top]*index\\n                    max_area = max(area,max_area)\\n                return max_area\\n            for i in range(len(mat)):\\n                if i==0:\\n                    arr = []\\n                    for j in mat[i]:\\n                        if j==\\'0\\':\\n                            arr.append(0)\\n                        else:\\n                            arr.append(1)\\n                    max_area = histogram_area(arr)\\n                else:\\n                    temp = []\\n                    for j in range(len(mat[i])):\\n                        if mat[i][j] == \\'0\\':\\n                            temp.append(0)\\n                        else:\\n                            temp.append(arr[j]+1)\\n                    area = histogram_area(temp)\\n                    max_area = max(area,max_area)\\n                    arr = temp\\n            return max_area\\n                        \\n                        \\n        \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 369948,
                "title": "solved-with-largest-rectangle-area-as-base-algorithm-ruby-94",
                "content": "check following videos if you couldn\\'t figure out, \\nTo solve this challenge, first need to solve the challenge 84 - largest rectangle area, once it solve, this challenge become very simple. \\n\\n### Explaination for Maximal Rectangle\\nhttps://www.youtube.com/watch?v=g8bSdXCG-lA\\n\\n### Exlaination for Largest Rectangle Area\\nhttps://www.youtube.com/watch?v=ZmnqCZp9bBs\\n\\n```ruby\\ndef maximal_rectangle(matrix)\\n  row = matrix.size\\n  return 0 if row == 0\\n  col = matrix.first.size\\n  max_area = 0\\n  heights = Array.new(col, 0)\\n\\n  for i in 0...row do\\n    for j in 0...col do\\n      matrix[i][j] == \"0\" ? (heights[j] = 0) : (heights[j] += 1)\\n    end\\n    area = largest_rectangle_area(heights)\\n    max_area = area if max_area < area\\n  end\\n  max_area\\nend\\n\\ndef largest_rectangle_area(heights)\\n  max_area = area = 0\\n  stack = []\\n  i = 0\\n\\n  while i < heights.size do \\n    if stack.empty? || heights[stack.last] <= heights[i]\\n      stack << i\\n      i += 1\\n    else\\n      top = stack.pop\\n      area = stack.empty? ? heights[top]*i : heights[top]*(i - stack.last - 1)\\n      max_area = area if max_area < area\\n    end\\n  end\\n\\n  while !stack.empty?\\n    top = stack.pop\\n    area = stack.empty? ? heights[top]*i : heights[top]*(i - stack.last - 1)\\n    max_area = area if max_area < area\\n  end\\n  max_area\\nend\\n\\n```",
                "solutionTags": [],
                "code": "```ruby\\ndef maximal_rectangle(matrix)\\n  row = matrix.size\\n  return 0 if row == 0\\n  col = matrix.first.size\\n  max_area = 0\\n  heights = Array.new(col, 0)\\n\\n  for i in 0...row do\\n    for j in 0...col do\\n      matrix[i][j] == \"0\" ? (heights[j] = 0) : (heights[j] += 1)\\n    end\\n    area = largest_rectangle_area(heights)\\n    max_area = area if max_area < area\\n  end\\n  max_area\\nend\\n\\ndef largest_rectangle_area(heights)\\n  max_area = area = 0\\n  stack = []\\n  i = 0\\n\\n  while i < heights.size do \\n    if stack.empty? || heights[stack.last] <= heights[i]\\n      stack << i\\n      i += 1\\n    else\\n      top = stack.pop\\n      area = stack.empty? ? heights[top]*i : heights[top]*(i - stack.last - 1)\\n      max_area = area if max_area < area\\n    end\\n  end\\n\\n  while !stack.empty?\\n    top = stack.pop\\n    area = stack.empty? ? heights[top]*i : heights[top]*(i - stack.last - 1)\\n    max_area = area if max_area < area\\n  end\\n  max_area\\nend\\n\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1573583,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1565570,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1567501,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1821428,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1565343,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1565830,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1566882,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1566474,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1566070,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1898438,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1573583,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1565570,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1567501,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1821428,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1565343,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1565830,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1566882,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1566474,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1566070,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1898438,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1790833,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 1650012,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 1574794,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 1567844,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 1568905,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 1571192,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 2061475,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 2046166,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 2028564,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 2027005,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 2021639,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1978903,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1866614,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1855963,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1815150,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1808667,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1790831,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1754146,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1707493,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1665120,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            }
        ]
    }
]