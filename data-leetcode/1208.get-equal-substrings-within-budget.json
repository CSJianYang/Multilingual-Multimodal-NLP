[
    {
        "title": "Consecutive Numbers Sum",
        "question_content": "Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.\n&nbsp;\nExample 1:\n\nInput: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\n\nExample 2:\n\nInput: n = 9\nOutput: 3\nExplanation: 9 = 4 + 5 = 2 + 3 + 4\n\nExample 3:\n\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 109",
        "solutions": [
            {
                "id": 129015,
                "title": "5-lines-c-solution-with-detailed-mathematical-explanation",
                "content": "The thought process goes like this- Given a number `N`, we can *possibly* write it as a sum of 2 numbers, 3 numbers, 4 numbers and so on. Let\\'s assume the fist number in this series be `x`. Hence, we should have \\n`x + (x+1) + (x+2)+...+ k terms = N`\\n`kx + k*(k-1)/2 = N` implies\\n`kx  = N - k*(k-1)/2`\\nSo, we can calculate the RHS for every value of `k` and if it is a multiple of `k` then we can construct a sum of `N` using `k` terms starting from `x`.\\nNow, the question arises, till what value of `k` should we loop for? That\\'s easy. In the worst case, RHS should be greater than 0. That is \\n` N - k*(k-1)/2 > 0` which implies\\n`k*(k-1) < 2N` which can be approximated to\\n`k*k < 2N ==> k < sqrt(2N)`\\nHence the overall complexity of the algorithm is `O(sqrt(N))`\\n\\n**PS**: OJ expects the answer to be 1 greater than the number of possible ways because it considers `N` as being written as `N` itself. It\\'s confusing since they ask for sum of consecutive integers which implies atleast 2 numbers. But to please OJ, we should start `count` from 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        int count = 1;\\n        for( int k = 2; k < sqrt( 2 * N ); k++ ) {\\n            if ( ( N - ( k * ( k - 1 )/2) ) % k == 0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        int count = 1;\\n        for( int k = 2; k < sqrt( 2 * N ); k++ ) {\\n            if ( ( N - ( k * ( k - 1 )/2) ) % k == 0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128959,
                "title": "java-python-3-5-liners-o-n-0-5-math-method-w-explanation-and-analysis",
                "content": "**Q & A**\\nQ1: Since `N = k * i + (i - 1) * i / 2`, why the loop condition is `i * (i - 1) / 2 < N`?\\nA1: \\n1. `k > 0, i > 0` so `i * k > 0`; Therefore, `i * (i - 1) / 2 < i * (i - 1) / 2 + k * i = N`; \\n2. On the other hand, `k` is unknow. Notice the term `i * (i - 1) / 2 ` and `k * i`, the complexity of the former is `O(i ^ 2)`, which is greater than that of the latter, `O(i)`. So we can get rid of `k * i`, but still guarantee that the  the loop condition `i * (i - 1) / 2 < N` is tight enough to cover all solutions.\\n\\nQ2: Why `k + (k + 1) + (k + 2) + ... + (k + (i - 1)) = k * i + (i - 1) * i / 2`?\\nA2: \\n```\\nN = k + (k + 1) + (k + 2) + ... + (k + (i - 1))\\n```\\nThere are `i` `k`\\'s, together with `0 + 1 + 2 + ... + i - 1` in the right hand side of the above expression,  therefore\\n```\\nN = i * k + (0 + (i - 1)) * i / 2\\n  = i * k + i * (i - 1) / 2\\n```\\n\\n**End of Q & A**\\n\\n----\\n\\n\\nN can be expressed as `k, k + 1, k + 2, ..., k + (i - 1)`, where `k` is a positive integer; therefore \\n\\n`N = k * i + (i - 1) * i / 2 => \\nN - (i - 1) * i / 2 = k * i`, which implies that as long as `N - (i - 1) * i / 2` is `k` times of `i`, we get a solution corresponding to `i`; Hence iteration of all possible values of `i`, starting from `1`, will cover all cases of the problem.  \\n\\n```\\n    public int consecutiveNumbersSum(int N) {\\n        int ans = 0;\\n        for (int i = 1; i * (i - 1) / 2 < N; ++i)\\n            if ((N - i * (i - 1) / 2) % i == 0)\\n                ++ans;\\n        return ans;\\n    }\\n```\\n```\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        i, ans = 1, 0\\n        while N > i * (i - 1) // 2:\\n            if (N - i * (i - 1) // 2) % i == 0:\\n                ans += 1\\n            i += 1\\n        return ans\\n```\\n**Analysis**\\n\\nSolve the equation `i * (i - 1) / 2 = N`, we know `i ~ N ^ 0.5`\\nLoop runs at most `N ^ 0.5` times, so\\n\\nTime: O(N ^ 0.5), space: O(1)",
                "solutionTags": [],
                "code": "```\\nN = k + (k + 1) + (k + 2) + ... + (k + (i - 1))\\n```\n```\\nN = i * k + (0 + (i - 1)) * i / 2\\n  = i * k + i * (i - 1) / 2\\n```\n```\\n    public int consecutiveNumbersSum(int N) {\\n        int ans = 0;\\n        for (int i = 1; i * (i - 1) / 2 < N; ++i)\\n            if ((N - i * (i - 1) / 2) % i == 0)\\n                ++ans;\\n        return ans;\\n    }\\n```\n```\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        i, ans = 1, 0\\n        while N > i * (i - 1) // 2:\\n            if (N - i * (i - 1) // 2) % i == 0:\\n                ans += 1\\n            i += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 128947,
                "title": "java-c-python-fastest-count-odd-factors-o-logn",
                "content": "## **Basic Math**\\n`N = (x+1) + (x+2) + ... + (x+k)`\\n`N = kx + k(k+1)/2`\\n`N * 2 = k(2x + k + 1)`,where `x >= 0, k >= 1`\\n\\nEither `k` or `2x + k + 1` is odd.\\n\\nIt means that, for each odd factor of `N`,\\nwe can find a consecutive numbers solution.\\n\\nNow this problem is only about counting odd numbers!\\nI believe you can find many solutions to do this.\\nLike `O(sqrt(N))` solution used in all other post.\\n\\nHere I shared my official solution.\\n<br>\\n\\n## **Some Math about Counting Factors**\\nIf `N = 3^a * 5^b * 7*c * 11*d ....`, the number of factors that `N` has equals\\n`N_factors = (a + 1) * (b + 1) * (c + 1) * (d + 1) .....`\\n<br>\\n\\n## **Explanantion**:\\n1. Discard all factors 2 from `N`.\\n2. Check all odd number `i` if `N` is divided by `i`.\\n3. Calculate the `count` of factors `i` that `N` has.\\n4. Update `res *= count`.\\n5. If `N==1`, we have found all primes and just return res.\\nOtherwise, `N` will be equal to `P` and we should do `res *= count + 1` where `count = 1`.\\n<br>\\n\\n## **Complexity:**\\nTo be more accurate, it\\'s `O(biggest prime factor)`.\\nBecause every time I find a odd factor, we do `N /= i`.\\nThis help reduce `N` faster.\\n\\nAssume `P` is the biggest prime factor of a **odd** number `N` .\\nIf `N = 3^x * 5^y ...*  P`, Loop on `i` will stop at `P^0.5`\\nIf `N = 3^x * 5^y ...*  P^z`, Loop on `i` will stop at `P`.\\nIn the best case, `N = 3^x` and our solution is `O(log3N)`\\nIn the worst case, `N = P^2` and our solution is `O(P) = O(N^0.5)`\\n\\nThough in my solution, we didn\\'t cache our process of finding odd factor.\\nMoreover, if we prepare all prime between `[3\\uFF0C10^4.5]`.\\nit will be super faster because there are only 3400 primes in this range.\\nThis complexity will be `O(P/logP)` with `P < sqrt(N)`\\n<br>\\n\\n\\n**Java**\\n```java\\n    public int consecutiveNumbersSum(int N) {\\n        int res = 1, count;\\n        while (N % 2 == 0) N /= 2;\\n        for (int i = 3; i * i <= N; i += 2) {\\n            count = 0;\\n            while (N % i == 0) {\\n                N /= i;\\n                count++;\\n            }\\n            res *= count + 1;\\n        }\\n        return N == 1 ? res : res * 2;\\n    }\\n```\\n**Short C++/Java:**\\n```cpp\\n        int res = 1, count;\\n        while (N % 2 == 0) N /= 2;\\n        for (int i = 3; i * i <= N; res *= count + 1, i += 2)\\n            for (count = 0; N % i == 0; N /= i, count++);\\n        return N == 1 ? res : res * 2;\\n```\\n**Python**\\n```py\\n    def consecutiveNumbersSum(self, N):\\n        res = 1\\n        i = 3\\n        while N % 2 == 0:\\n            N /= 2\\n        while i * i <= N:\\n            count = 0\\n            while N % i == 0:\\n                N /= i\\n                count += 1\\n            res *= count + 1\\n            i += 2\\n        return res if N == 1 else res * 2\\n```\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public int consecutiveNumbersSum(int N) {\\n        int res = 1, count;\\n        while (N % 2 == 0) N /= 2;\\n        for (int i = 3; i * i <= N; i += 2) {\\n            count = 0;\\n            while (N % i == 0) {\\n                N /= i;\\n                count++;\\n            }\\n            res *= count + 1;\\n        }\\n        return N == 1 ? res : res * 2;\\n    }\\n```\n```cpp\\n        int res = 1, count;\\n        while (N % 2 == 0) N /= 2;\\n        for (int i = 3; i * i <= N; res *= count + 1, i += 2)\\n            for (count = 0; N % i == 0; N /= i, count++);\\n        return N == 1 ? res : res * 2;\\n```\n```py\\n    def consecutiveNumbersSum(self, N):\\n        res = 1\\n        i = 3\\n        while N % 2 == 0:\\n            N /= 2\\n        while i * i <= N:\\n            count = 0\\n            while N % i == 0:\\n                N /= i\\n                count += 1\\n            res *= count + 1\\n            i += 2\\n        return res if N == 1 else res * 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1117669,
                "title": "mathematical-solution",
                "content": "Lets make some observation first.\\n1. of length k only one consecutive sequence is possible.\\neg: let say we want to make 18\\n  \\n **3 4 5 6** sum:18\\n if we go left  having length k sum will decrease(2 3 4 5)\\n  if we go to right sum increase (4 5 6 7)\\n\\n**So only one consecutive sequence of length k with specific sum is possible.** \\n\\n\\nSo now i have to find all possible sequence that starts with x , having length k and sum equals to n.\\n\\n x+ (x+1) + (x+2) ..... (x+k-1)=n\\n k*x + k*(k-1)/2 = n\\n \\n**K:unknown and also X:unknown**\\nSo **try hit and trail**\\n\\nkx=n - k*(k-1)/2\\nk>0 and x>0 so LHS always Positive\\n\\nn-k*(k-1)/2 > 0\\nn>k*(k-1)/2\\nn>k*(k)/2      // approximation\\n2n>k^2\\nsqrt(2n)>k \\n\\n **now we have range for k . k>0 and k<sqrt(2n)**\\n \\n kx= n - k*(k-1)/2\\n\\n**left side is mutliple of k.**\\nif right side (n-k*(k-1)/2) % k ==0 **means right side is also a multiple of k**. \\nSo if this condition follows increase answer count 1.\\n```\\n public int consecutiveNumbersSum(int N) {\\n\\n        int ans=0;\\n        \\n        for(int k=1;k*k<2*N;k++){\\n            \\n            if((N-k*(k-1)/2)%k==0) ans++;\\n        }\\n        return ans;\\n}\\n```\\n**Time : O(sqrt(n)) and Space:O(1)**\\n\\nPlease **Upvote** if found it helpful:)",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n public int consecutiveNumbersSum(int N) {\\n\\n        int ans=0;\\n        \\n        for(int k=1;k*k<2*N;k++){\\n            \\n            if((N-k*(k-1)/2)%k==0) ans++;\\n        }\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 129227,
                "title": "java-easy-4-lines-o-n-0-5",
                "content": "\\n    public int consecutiveNumbersSum(int N) {\\n        int ans = 0;\\n        for(int i = 1, n = N - 1; n >= 0; n -= ++i)\\n            if ((n % i) == 0) ans++;\\n        return ans;\\n    }\\n\\n**Explaination**: \\nlet `N = k + (k+1) + (k+2) + (k+3) + ... + (k+i-1) = i*k + (1+2+3+... + i-1)`\\nlet `sum(i) = (1+2+3+...+i-1)`, then we have\\n`\\tN = sum(i) + i*k`  ==>` i*k = N - sum(i)`\\nWhich means: for each `i`, we can calculate `N-sum(i)`. If `N-sum(i)` can be divided by `i`, there is an answer with length `i`.\\nBecause, let `k = (N - sum(i)) / i`, we can add an integer `k` to each of `(0,1, 2, 3, 4, ...., i-1)` to become `(k, k+1, k+2, k+3,.... k + i-1)`\\nthat is: `sum(i) + i * k = N`\\n\\nThe naive solution is:\\n\\n    public int consecutiveNumbersSum(int N) {\\n        int sum = 0, ans = 0;\\n        for(int i = 1; sum < N; i++) {\\n            sum += i;\\n            if (((N-sum) % i) == 0)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n\\t\\nWhich is the same as the first solution.\\n\\nObviously, the runtime is O(n^0.5).",
                "solutionTags": [],
                "code": "\\n    public int consecutiveNumbersSum(int N) {\\n        int ans = 0;\\n        for(int i = 1, n = N - 1; n >= 0; n -= ++i)\\n            if ((n % i) == 0) ans++;\\n        return ans;\\n    }\\n\\n**Explaination**: \\nlet `N = k + (k+1) + (k+2) + (k+3) + ... + (k+i-1) = i*k + (1+2+3+... + i-1)`\\nlet `sum(i) = (1+2+3+...+i-1)`, then we have\\n`\\tN = sum(i) + i*k`  ==>` i*k = N - sum(i)`\\nWhich means: for each `i`, we can calculate `N-sum(i)`. If `N-sum(i)` can be divided by `i`, there is an answer with length `i`.\\nBecause, let `k = (N - sum(i)) / i`, we can add an integer `k` to each of `(0,1, 2, 3, 4, ...., i-1)` to become `(k, k+1, k+2, k+3,.... k + i-1)`\\nthat is: `sum(i) + i * k = N`\\n\\nThe naive solution is:\\n\\n    public int consecutiveNumbersSum(int N) {\\n        int sum = 0, ans = 0;\\n        for(int i = 1; sum < N; i++) {\\n            sum += i;\\n            if (((N-sum) % i) == 0)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n\\t\\nWhich is the same as the first solution.\\n\\nObviously, the runtime is O(n^0.5).",
                "codeTag": "Unknown"
            },
            {
                "id": 129033,
                "title": "c-2-lines-o-sqrt-n",
                "content": "With ```n``` consecutive integers, the first number we can form is ```1 + 2 + ... + n```. The next number is ```2 + 3 + ... + n + n + 1```, or ```1 + 2 + ... + n + n```, and then ```1 + 2 + ... + n + n + n```, and so on.\\n\\nTherefore, a number N can be formed by n consecutive integers, if ```N - (1 + 2 + ... n)``` modulo ```n``` is zero. The code below just increases ```n``` and tests if ```N``` can be formed by ```n``` numbers.\\n\\nNote that a sum of arithmetic progression from 1 to n can be calculated as ```n * (n + 1) / 2```.\\n```\\nint consecutiveNumbersSum(int N, int res = 0) {\\n  for (auto n = 2; n * (n + 1) / 2 <= N; ++n) res += (N - n * (n + 1) / 2) % n == 0 ? 1 : 0;\\n  return res + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```n```\n```1 + 2 + ... + n```\n```2 + 3 + ... + n + n + 1```\n```1 + 2 + ... + n + n```\n```1 + 2 + ... + n + n + n```\n```N - (1 + 2 + ... n)```\n```n```\n```n```\n```N```\n```n```\n```n * (n + 1) / 2```\n```\\nint consecutiveNumbersSum(int N, int res = 0) {\\n  for (auto n = 2; n * (n + 1) / 2 <= N; ++n) res += (N - n * (n + 1) / 2) % n == 0 ? 1 : 0;\\n  return res + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128985,
                "title": "python-solution-with-simple-proof",
                "content": "For each possible number of terms `d` in a sequence of consecutive integers whose sum equals `N`, determine whether there is an integral `n` such that\\n    `n + (n +1) + ... (n + d -1) = N`\\n\\n\\n\\n* Factor out the `n`:\\n  * `n*d + 0+1+...(d-1) = N`\\n* Express `0+1+...(d-1)` as an arithmetic sequence ending at `d-1`:\\n  * `n*d + (d-1)*d/2 = N`\\n* Solve for `n*d` to determine if `n` can be integral:\\n  * `n*d = N-(d-1)*d/2`\\n * Iff `n*d` is divisible by `d`, then an integral `n` exists, and there is a valid sequence of `d` consecutive terms that sums to N\\n * A valid sum cannot have more than `d ~= sqrt(N)` elements, so this is in `O(sqrt(N))`\\n\\n```\\nclass Solution(object):\\n    def consecutiveNumbersSum(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        cnt=0\\n        for d in xrange(1, N+1):\\n            diff=d*(d-1)/2\\n            nd = N - diff\\n            if nd<=0: break\\n            if nd%d==0:\\n                cnt+=1\\n\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def consecutiveNumbersSum(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        cnt=0\\n        for d in xrange(1, N+1):\\n            diff=d*(d-1)/2\\n            nd = N - diff\\n            if nd<=0: break\\n            if nd%d==0:\\n                cnt+=1\\n\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401530,
                "title": "simple-python",
                "content": "I\\'m sure there\\'s a better way, but I got this simple solution based on observing that any run of consecutive integers that sums to N has the form `x + (x + 1) + (x + 2) + ...` where x is the first number of the sequence. If you factor those formulas, you get the following formulas that could yield a valid solution:\\n```\\nx = N\\n2x + 1 = N\\n3x + 3 = N\\n4x + 6 = N\\n5x + 10 = N\\n...\\n```\\n\\nSuppose your target is 10. Then you can solve each of the above formulae in turn and if you get an integer solution, increment the counter.\\n\\n```\\nx = 10 # counter++\\n2x + 1 = 10 => x = 9/2\\n3x + 3 = 10 => x = 7/3\\n4x + 6 = 10 => x = 1 # counter++\\n```\\n\\nSince N can be pretty big, we want to stop as early as possible to avoid doing unnecessary work. If our equation is `ax + b = N` then as soon as `(N - b) / a` is less than 1 we can stop because the quotient is never going to increase. This allows us to stop pretty early: even for a big number like 10e9, the algorithm only requires 10e4 operations.\\n\\n```python\\nclass Solution:\\n    def consecutiveNumbersSum(self, N):\\n        if N == 1: return 1\\n        cnt, prev = 0, 0\\n        for i in range(N):\\n            sub = i + prev\\n            prev = sub\\n            div = i + 1\\n            Q, R = divmod(N - sub, div)\\n            if not Q:\\n                return cnt\\n            if not R:\\n                cnt += 1\\n```",
                "solutionTags": [],
                "code": "```\\nx = N\\n2x + 1 = N\\n3x + 3 = N\\n4x + 6 = N\\n5x + 10 = N\\n...\\n```\n```\\nx = 10 # counter++\\n2x + 1 = 10 => x = 9/2\\n3x + 3 = 10 => x = 7/3\\n4x + 6 = 10 => x = 1 # counter++\\n```\n```python\\nclass Solution:\\n    def consecutiveNumbersSum(self, N):\\n        if N == 1: return 1\\n        cnt, prev = 0, 0\\n        for i in range(N):\\n            sub = i + prev\\n            prev = sub\\n            div = i + 1\\n            Q, R = divmod(N - sub, div)\\n            if not Q:\\n                return cnt\\n            if not R:\\n                cnt += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926550,
                "title": "java-sliding-window-o-n-time-limit-exceeded",
                "content": "Suppose we have a number 15 , we have to go max till 8 i.e ( N/2+1) ,then we maintain a window which will contain the sum of consecutive numbers, if the sum is greater than 15 , we increment the start otherwise we keep on increasing the end.\\n\\n![image](https://assets.leetcode.com/users/images/86153d01-5075-4c04-ba10-6cd83e10ca42_1604733024.204155.png)\\n\\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        if( N <= 2 )\\n            return 1;\\n        int n = N/2+1;\\n        int start = 1;\\n        int counter = 0;\\n        int currentSum = 0 ;\\n        for(int end = 1; end <= n; end++ )\\n        {\\n          currentSum = currentSum + end;\\n          while( currentSum > N  && start <= end )\\n          {\\n              currentSum = currentSum - start++;\\n          }\\n          if( currentSum == N )\\n              counter++;\\n        }\\n    return counter+1;\\n    }\\n}\\n```\\nWe are at max going till o(n/2) but since asymptotically O(n/2) tightest upper bound is O(n) complexity is O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        if( N <= 2 )\\n            return 1;\\n        int n = N/2+1;\\n        int start = 1;\\n        int counter = 0;\\n        int currentSum = 0 ;\\n        for(int end = 1; end <= n; end++ )\\n        {\\n          currentSum = currentSum + end;\\n          while( currentSum > N  && start <= end )\\n          {\\n              currentSum = currentSum - start++;\\n          }\\n          if( currentSum == N )\\n              counter++;\\n        }\\n    return counter+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521717,
                "title": "tle-but-dp-approach",
                "content": "```\\nvar consecutiveNumbersSum = function(N) {\\n    if(N<=2) return 1;\\n    let result = 0;\\n    let dp = new Set(); //summation of consecutive nums\\n    for(let i = 0; i<=N; i++){\\n        let curSum = i*((i+1)/2);\\n        if(dp.has(curSum-N))\\n            result++;\\n        dp.add(curSum);\\n    }\\n    return result;\\n};\\n```\\nThought someone might be curious, works up to ~6 digits (maybe more, didn\\'t check). Time: O(n) Space: O(n)\\nSolved it like a dynamic programming problem instead of mathematically (mostly). This algorithm uses that sum of 3 to 9 is equivalent to (sum of 1 to 9) - (sum of 1 to 2). So by storing old sums we can quickly look up if solution exists by checking the complement.",
                "solutionTags": [],
                "code": "```\\nvar consecutiveNumbersSum = function(N) {\\n    if(N<=2) return 1;\\n    let result = 0;\\n    let dp = new Set(); //summation of consecutive nums\\n    for(let i = 0; i<=N; i++){\\n        let curSum = i*((i+1)/2);\\n        if(dp.has(curSum-N))\\n            result++;\\n        dp.add(curSum);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 974849,
                "title": "python-3-simple-math-with-proof",
                "content": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        \\'\\'\\'\\n        Consider N = 10, and a sequence 1 + 2 + 3 + 4\\n        This sequence starts at x = 1 and goes as:\\n        x + (x + 1) + (x + 2) + (x + 3) = x + (x + 1) + (x + 2) + (x + n - 1)\\n        where n = 4, ie, the total number of elements in the sequence\\n        x + (x + 1) + (x + 2) + (x + n - 1) = (first_elem + last_elem) * num_elem / 2 [properties of arithmetic series]\\n        x + (x + 1) + (x + 2) + (x + n - 1) = (x + x + n - 1) * n / 2\\n        x + (x + 1) + (x + 2) + (x + n - 1) = (2x + n - 1) * n / 2\\n        \\n        Note that x + (x + 1) + (x + 2) + (x + n - 1) = N\\n        (2x + n - 1) * n / 2 = N\\n        2xn / 2 + n(n-1) / 2 = N\\n        xn + n(n-1)/2 = N\\n        xn = N - n(n-1)/2\\n        \\n        All we require is x to be an integer, like 1 above.\\n        This means that if [N - n(n-1)/2] % n == 0, this means that we can form a sequence\\n        starting at x = [N - n(n-1)/2]/n\\n        \\n        All we need to do is loop through each n from 2 onwards\\n        Why two? Remember that n describes the number of elements in the sequence, and by default,\\n        the sequence 10 is already included, which is 1 number\\n        \\n        What must n be less than? Notice that x is positive, which means N - n(n-1)/2 > 0, which further \\n        translated to 2N > n(n-1), which is close to 2N > n(n)\\n        So now we see that 2N > n^2, meaning that n < sqrt(2N)\\n        \\n        The code then is a simple loop\\n        \\'\\'\\'\\n        import math\\n        \\n        # initial answer\\n        count = 1\\n        \\n        # smallest size\\n        n = 2\\n        target = math.sqrt(2*N)\\n        while n < target:\\n            if (N - n*(n-1)/2) % n == 0:\\n                count += 1\\n            n += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        \\'\\'\\'\\n        Consider N = 10, and a sequence 1 + 2 + 3 + 4\\n        This sequence starts at x = 1 and goes as:\\n        x + (x + 1) + (x + 2) + (x + 3) = x + (x + 1) + (x + 2) + (x + n - 1)\\n        where n = 4, ie, the total number of elements in the sequence\\n        x + (x + 1) + (x + 2) + (x + n - 1) = (first_elem + last_elem) * num_elem / 2 [properties of arithmetic series]\\n        x + (x + 1) + (x + 2) + (x + n - 1) = (x + x + n - 1) * n / 2\\n        x + (x + 1) + (x + 2) + (x + n - 1) = (2x + n - 1) * n / 2\\n        \\n        Note that x + (x + 1) + (x + 2) + (x + n - 1) = N\\n        (2x + n - 1) * n / 2 = N\\n        2xn / 2 + n(n-1) / 2 = N\\n        xn + n(n-1)/2 = N\\n        xn = N - n(n-1)/2\\n        \\n        All we require is x to be an integer, like 1 above.\\n        This means that if [N - n(n-1)/2] % n == 0, this means that we can form a sequence\\n        starting at x = [N - n(n-1)/2]/n\\n        \\n        All we need to do is loop through each n from 2 onwards\\n        Why two? Remember that n describes the number of elements in the sequence, and by default,\\n        the sequence 10 is already included, which is 1 number\\n        \\n        What must n be less than? Notice that x is positive, which means N - n(n-1)/2 > 0, which further \\n        translated to 2N > n(n-1), which is close to 2N > n(n)\\n        So now we see that 2N > n^2, meaning that n < sqrt(2N)\\n        \\n        The code then is a simple loop\\n        \\'\\'\\'\\n        import math\\n        \\n        # initial answer\\n        count = 1\\n        \\n        # smallest size\\n        n = 2\\n        target = math.sqrt(2*N)\\n        while n < target:\\n            if (N - n*(n-1)/2) % n == 0:\\n                count += 1\\n            n += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067964,
                "title": "very-simple-and-intuitive-solution",
                "content": "Here\\'s my simple understanding of the problem:\\nFor representing N as sum of consecutive integers we have the following scenarios:\\n\\n\\nN = M + 0 (Base case when M == N, or when N is sum of only one number i.e itself)\\nN =  M + (M + 1) (when N is sum of two consecutive numbers e.g 9 = 4+5, here M is 4 ) => 2*M + 1\\nN = M + (M+1) + (M+2) (when N is sum of 3 consecutive numbers, e.g 9 = 2+3+4, here M is 2) => 3*M + 3\\nN = M + (M+1) + (M+2) + (M+3) => 4*M + 6\\nN = M + (M+1) + (M+2) + (M+3) + (M+4) => 5M + 10\\nN = M + (M+1) + (M+2) + (M+3) + (M+4) + (M + 5) => 6M + 15\\n....... and so on\\n\\nso looking at this series we need to find the unique numbers of M such that they fit our equations. (M needs to be an integer)\\n\\nSo we can write it as something like this =>\\n\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        \\n        constant_term = 0\\n        divisor = 1\\n        ans = 0\\n        while constant_term < N:\\n           # if ((N-constant_term)/divisor).is_integer():\\n\\t\\t\\tif ((N-constant)%divisor==0):\\n                ans += 1\\n            \\n            constant_term = constant_term + divisor\\n            divisor += 1\\n        \\n        return ans\\n        \\n```\\n\\n\\nwe are looping till constant_term is less than N, because \\n1.) if the constant term becomes greater than N there\\'ll be no solution furthermore.\\n2.) if the constant term gets equal to N then this case will be similar to the very first case.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        \\n        constant_term = 0\\n        divisor = 1\\n        ans = 0\\n        while constant_term < N:\\n           # if ((N-constant_term)/divisor).is_integer():\\n\\t\\t\\tif ((N-constant)%divisor==0):\\n                ans += 1\\n            \\n            constant_term = constant_term + divisor\\n            divisor += 1\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 144847,
                "title": "python-3-132ms-series-with-explanation",
                "content": "```\\nimport math\\n\\nclass Solution:\\n    \\n    def consecutiveNumbersSum(self, n):  \\n\\n        res = 1\\n        \\n        for i in range(2, math.ceil((1 + (1+8*n)**0.5) / 2)):\\n            \\n            if ((n/i) - (i-1)/2).is_integer():\\n                res += 1\\n\\n        return res\\n```\\n\\n---\\n\\n*(For this explination, k = consecutive numbers wanted)* \\n\\nTo begin let\\'s think about finding **2 consecutive positive numbers** that add to give **15** - (**n = 15** and **k = 2**)\\nThe answer is **7** and **8**, there are **NO** other combinations \\n\\nThis is becasue **15 = 7 + (7+1)**\\nThis can be written as **15 = i + (i+1)** where **i = 7**\\n\\nIf we wanted to find **k = 3** we could write\\n**15 = i + (i+1) + (i+2)** where **i = ?**\\n\\n---\\n\\nThis can be generalised for any **n** and **k**\\n**n = i + (i+1) + (i+2) + ... + (i+k-1)**\\n**n = ki + (1 + 2 + ... + k-1)**\\n\\nThe summation of the first **k-1** natural numbers, which can be written as **(k(k-1)) / 2**\\n**n = ki +(k(k-1)) / 2**\\n\\nIn terms if **i** this is:\\n**i = (n/k) - (k-1)/2**\\n\\n---\\n\\nIf we plug **k** into our euqation, we will find the first result. For example:\\n(**n = 15** and **k = 3**)\\n\\n**i = (n/k) - (k-1)/2**\\n**i = (15/3) - (3-1)/2 = 4**\\n\\nWhich is the first number in the answer, **[4,5,6]**\\n\\n---\\n\\nIf the euqation does not give a positive integer, then there is no answer for that **k**, for example - (**n = 15** and **k = 4**)\\n**i = (n/k) - (k-1)/2**\\n**i = (15/4) - (4-1)/2 = 2.25**\\n\\nThere are no 4 consecutive positive numbers that add to 15\\n\\n---\\n\\n**When to end?**\\n\\nEventually, the only possible way for the integers to add up to **n** is if **i < 0**:\\n\\n**(n/k) - (k-1)/2 < 0**\\n\\nThis expands to:\\n**(1/2)k^2 - (1/2)k - 2n > 0**\\n\\nWe can use the quadractic formula to find the roots of this euqation, and we are only interested in the positive root.\\n**positie root = (1/2)(1 + (1 + 8n)^0.5 )**\\n\\nFor example, the positive root of **n = 15** is **6.0**, meaning **k >= 6** would require a negaitve **i**, so we can stop beforehand.\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    \\n    def consecutiveNumbersSum(self, n):  \\n\\n        res = 1\\n        \\n        for i in range(2, math.ceil((1 + (1+8*n)**0.5) / 2)):\\n            \\n            if ((n/i) - (i-1)/2).is_integer():\\n                res += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922956,
                "title": "c-with-explanation",
                "content": "All ways can be represented in the following form:\\n`a + a + 1 + a + 2 ... + a + k = N` \\nWhere `a`  is the first number in the seqeunce and `a + k` is the last number in the sequence.\\n\\n**General Idea**:  Iterate through all the possible values of `k` and if there exist an integer value of `a` that satisfy the equation, we have found a valid way.\\n\\nWe can use arithematic progression to condense this representation:\\n`a + a + 1 + a + 2 ... + a + k = (k+1)a + (1+2+...+k)= (k+1)a + (k*(k+1)/2) = N`\\n\\nAs the `a` is easily fractorized out we can repsent `a` in terms of `k` and `N` by:\\n`a = N/(k+1) - k/2`\\n\\nAs we know the that `a` must be positive, we can find the upper bound for `k`:\\n`N/(k+1) - k/2 > 0`\\n`N/(k+1) > k/2 `\\n`N > k(k+1)/2 `\\n\\nThis will allow us to terminate early instead of iterating through every possible `k` from `0` to `N`\\n```cpp\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        long long int count = 0; \\n        for (long long int k = 0; k*(k+1)/2 < N ;k++) {\\n            double a = ((double) N)/((double) k + 1) - (double) k/2;\\n            if (a - (int) a == 0) {\\n                count += 1;\\n            }\\n        }\\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        long long int count = 0; \\n        for (long long int k = 0; k*(k+1)/2 < N ;k++) {\\n            double a = ((double) N)/((double) k + 1) - (double) k/2;\\n            if (a - (int) a == 0) {\\n                count += 1;\\n            }\\n        }\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809348,
                "title": "with-explanation-simple-solution-beats-98-in-java",
                "content": "The idea here is to understand the math behind \\'consecutive sum.\\'\\n\\nLet\\'s go through a few examples (here I will ignore the base case, which is the number itself)\\n\\n1. N = 9\\n\\n`9 = 4 + 5`: in this, there are two numbers that make up the sum (4 and 5). \\n`9 = 2 + 3 + 4`: in this one, there are three numbers that make up the sum\\n\\nWe can generalize this to:\\n\\n`9 = x + (x + 1) + (x + 2) ... (x + n) = n \\u2022 x + (1 + 2 + 3 + ... + n-1)` \\n\\nAs a result, to find the numbers of consecutive sum, we can test how many sub-additions it can take to get to the number. We can iterate from `0 to n`, with each iteration, subtract away the sum (`1 + 2 ... etc.`), and mod by `n` \\n\\nThe code is very simple: \\n\\n```\\nint result = 1;\\nint sum = 0;\\nint i = 2;\\n\\nwhile (sum < N){\\n\\tsum += i - 1;\\n\\tif ((N - sum > 0) && (N - sum) % i == 0) result++;\\n\\ti++;\\n}\\n\\nreturn result;\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint result = 1;\\nint sum = 0;\\nint i = 2;\\n\\nwhile (sum < N){\\n\\tsum += i - 1;\\n\\tif ((N - sum > 0) && (N - sum) % i == 0) result++;\\n\\ti++;\\n}\\n\\nreturn result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2301548,
                "title": "java-triangular-numbers-with-explanation-fast-simple-o-1-space-o-sqrt-n-time",
                "content": "**Intuition and Observations**:\\n* We can always form a sum of one consecutive integer (simply n itself).\\n* Let\\'s consider two consecutive numbers.  `(1 + k) +  (2 + k) = n`.  Then `1 + 2 + 2k = n`.  Then `3 + 2k = n`.  Then `2k = n - 3`.  This works when 2 divides `n - 3`.\\n* Let\\'s consider three consecutive numbers.  `(1 + k) + (2 + k) + (3 + k) = n`.  Then `6 + 3k = n`.  Then `3k = n - 6`.  This is works when 3 divides `n - 6`.\\n* Let\\'s consider four consecutive numbers.  `(1 + k) + (2 + k) + (3 + k) + (4 + k) = n`.  Then `10 + 4k = n`.  Then `4k = n - 6`.  This works when 4 divides `n - 10`\\n* Generally, let\\'s consider `m` consecutive numbers.  Define `T[m]` as the mth triangular number (the sum the integers from 1 to `m`, inclusive).  We have `(1 + k) + ... + (m + k) = n`.  Then `T[m] + mk = n`.  Then `mk = n - T[m]`.  This works when `m` divides `n - T[m]`.  Note that the formula for `T[m]` is `m(m+1)/2`.\\n* Note that `k` must be non-negative as we are looking for sums of consecutive positive integers.  Since `n - T[m]` is `mk`, this means `n - T[m] >= 0` and thus `T[m] <= n`.  (As a counter-example, in our \"derivation\" above, we start the series with `1 + k`, but if `k` is negative, then our first consecutive integer in the series is non-positive, which contradicts the conditions of the problem.)\\n* We can compute the max triangular number with the quadratic equation.  `T[m]` is `m(m+1)/2`, and we said that `T[m] <= n` is required, so combining these, we have `m(m+1)/2 <= n`.  We solve this inequality for `m` to look for an upper bound on `m`.  We then have: `m^2 + m <= 2n`, and thus `m^2 + m - 2n <= 0`.  We apply the quadratic equation\\\\* and discard the negative root\\\\*, and thus, `m <= (-1 + sqrt(1 + 8n)) / 2`\\\\*.  Thus, the maximum triangular number `maxTriangular` to check is the integer floor of `(-1 + sqrt(1 + 8n)) / 2`.  (See the end for the explanations of the asterisks if you have questions like \"why the postiive root?\" or \"how can we use the quadratic equation for an inequality?\")\\n\\nNow, we can start with `ways = 1` and simply check every possible triangular number from `m=2` to `m=maxTriangular` inclusive to see if `n - T[m]` is divisible by `m`.  It is computationally efficient to keep a running sum matching the triangular numbers by starting at `triangular=1` and looping from `m=2` to `maxTriangular`, inclusive, and incrementing `triangular` by `m` each time at the beginning of the loop.  That is, we start at 1, and for `m=2` we add 2 to get `triangular=3`, for `m=3` we add 3 to get `triangular=6`, for `m=4` we add 4 to get `triangular=10`, etc.\\n\\nNow we have enough of an idea of the workings of this problem that we can write some code!\\n\\n**Java Code**:\\n```\\nclass Solution {\\n\\n    public int consecutiveNumbersSum(int n) {\\n\\t    final double eightN = (8d * ((double) n)); // convert to double because 8n can overflow int\\n        final int maxTriangular = (int) Math.floor((-1d + Math.sqrt(1d + eightN)) / 2d);\\n        int ways = 1;\\n        int triangular = 1;\\n        for (int m = 2; m <= maxTriangular; ++m) {\\n            triangular += m;\\n            final int difference = n - triangular;\\n            if ((difference % m) == 0) {\\n                ways++;\\n            }\\n        }\\n        return ways;\\n    }\\n\\n}\\n```\\n\\n**Complexity**: O(1) space, O(sqrt(n)) time.  We can see from the formula for the maximum triangular number that there is a square root of n factor.  We ignore the constant terms and coefficients.  Runtime: ~3-4ms, faster than ~93-97% as of July, 2022.\\n\\n**Standard Plea**: If you found this solution helpful, interesting, or even just not a waste of time, **I\\'d greatly appreciate your upvote**.  If not, **I\\'d love your constructive criticism** so I can write a better solution next time.  Thanks, and happy coding!\\n\\n\\n\\\\* Note: In the last bullet point of the first section above, we did a bit of hand-waving regarding use of the quadratic equation for an inequality, and why we want only the positive root.  If you care about the argument, read on.  If not, feel free to skip this.  We are given that `n >= 1`, so we know that at the least, the smallest \"max triangular number\" allowed would be 1.  Additionally, `m` is the number of consecutive integers we are adding, thus we never consider `m < 1`.  This is why we can disregard the negative root for `m` - applying the quadratic formula and applying `n >= 1`, we can see that the negative root is at most -2, which contradicts `m >= 1`.  Now, we know we have a parabola `f(m) = m^2 + m - 2n` with a minimum (due to the positive coefficient of the `m^2` term), and we are seeking the positive root; therefore, we know `m` must remain less than this positive root.  Then our inequality is `f(m) <= 0`.  Suppose `r` is the positive root of `f`.  Then `f(r)` is zero.  Additionally, we know since r is the positive root and since the parabola has a minimum at some m smaller than this root, that `f(r + epsilon) > 0`, and `f(r - epsilon) < 0` for any positive sufficiently small epsilon.  That is, we know in the region of the positive root that the parabola is increasing as `m` increases.   Thus, to stay in the portion of the parabola below or on the m-axis, that is, to satisfy `f(m) <= 0`, the maximum integer value of `m` is no greater than the positive root which is `(-1 + sqrt(1 + 8n)) / 2` by the quadratic equation.  This is why we say `m <= (-1 + sqrt(1 + 8n)) / 2`.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int consecutiveNumbersSum(int n) {\\n\\t    final double eightN = (8d * ((double) n)); // convert to double because 8n can overflow int\\n        final int maxTriangular = (int) Math.floor((-1d + Math.sqrt(1d + eightN)) / 2d);\\n        int ways = 1;\\n        int triangular = 1;\\n        for (int m = 2; m <= maxTriangular; ++m) {\\n            triangular += m;\\n            final int difference = n - triangular;\\n            if ((difference % m) == 0) {\\n                ways++;\\n            }\\n        }\\n        return ways;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347296,
                "title": "simple-python-96-with-explanation",
                "content": "If  **N = i * j,** then we want to find **i** consecutive numbers with average **j**\\nFor example, 15 = 3 * 5, then 4 + 5 + 6, 3 numbers with average 5;  and 15 = 5 * 3, then 1 + 2 + 3 + 4 + 5, 5 numbers with average 3 \\t\\nBut one constraint is that **i** must be **odd**, since if i is even k + 1, k + 2, ... k + i. The average = (ik + (1 + i)*i/2) / i = k + (1 + i) / 2, cannot be an integer.\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        if N == 1: \\n            return 1\\n        res = 1\\n        for i in range(2, int(N ** .5 + 1)):   \\n            if N % i == 0:\\n                if i % 2 == 1: # If i is odd, then we can form a sum of length i\\n                    res += 1\\n                j = (N // i) # Check the corresponding N // i\\n                if i != j and j % 2 == 1:\\n                    res += 1\\n        if N % 2 == 1: # If N is odd(2k + 1). Then N = k + k + 1, not included above\\n            res += 1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        if N == 1: \\n            return 1\\n        res = 1\\n        for i in range(2, int(N ** .5 + 1)):   \\n            if N % i == 0:\\n                if i % 2 == 1: # If i is odd, then we can form a sum of length i\\n                    res += 1\\n                j = (N // i) # Check the corresponding N // i\\n                if i != j and j % 2 == 1:\\n                    res += 1\\n        if N % 2 == 1: # If N is odd(2k + 1). Then N = k + k + 1, not included above\\n            res += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466133,
                "title": "8-lines-python3-code",
                "content": "Let say integer **n** is equal to sum of **i** consecutive positive integers. Then \\n**n=a+(a+1)+(a+2)..+(a+i-1)**\\n**=ai+(0+1+2+...+(i-1))**\\nso **(n-(0+1+2+...+(i-1)))/i==a**, which means if **(n-(0+1+2+...+(i-1))) % i ==0**, there will be integer **a** and **i** satisfies the requirement.\\n\\n\\n\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        csum=0\\n        result=0\\n        for i in range(1,n+1):\\n            csum+=i-1\\n            if csum>=n:\\n                break\\n            if (n-csum)%i==0:\\n                result+=1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        csum=0\\n        result=0\\n        for i in range(1,n+1):\\n            csum+=i-1\\n            if csum>=n:\\n                break\\n            if (n-csum)%i==0:\\n                result+=1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235055,
                "title": "swift-consecutive-numbers-sum-test-cases",
                "content": "```swift\\nclass Solution {\\n    func consecutiveNumbersSum(_ n: Int) -> Int {\\n        var res = 1, k = 2.0, dn = Double(n*2)\\n        while (dn + k - (k*k)) > 0 { // don\\'t use \"pow\"\\n            let a = (dn + k - (k * k)) / (2.0 * k)\\n            if a  == floor(a) { res += 1 }\\n            k += 1\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n//      Executed 3 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        XCTAssertEqual(s.consecutiveNumbersSum(5), 2)\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.consecutiveNumbersSum(9), 3)\\n    }\\n    func test3() {\\n        XCTAssertEqual(s.consecutiveNumbersSum(15), 4)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func consecutiveNumbersSum(_ n: Int) -> Int {\\n        var res = 1, k = 2.0, dn = Double(n*2)\\n        while (dn + k - (k*k)) > 0 { // don\\'t use \"pow\"\\n            let a = (dn + k - (k * k)) / (2.0 * k)\\n            if a  == floor(a) { res += 1 }\\n            k += 1\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n//      Executed 3 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        XCTAssertEqual(s.consecutiveNumbersSum(5), 2)\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.consecutiveNumbersSum(9), 3)\\n    }\\n    func test3() {\\n        XCTAssertEqual(s.consecutiveNumbersSum(15), 4)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304471,
                "title": "c-most-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int count=0,i=1;\\n        while(n>0)\\n        {\\n            n=n-i;\\n            if(n%i==0)count++;\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nIf you like the solution plz upvote..",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int count=0,i=1;\\n        while(n>0)\\n        {\\n            n=n-i;\\n            if(n%i==0)count++;\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150754,
                "title": "just-explanation-easy",
                "content": "**UPVOTE IF HELPFuuL**\\nFirstly the question demands sum of consecutive ```positive``` integers.\\n\\nLet there be ```k``` positive integers that sum to ```num```.\\n\\n**Only possible values of k are ```1 <= k <= \\u221A( 2*num )```**\\n\\nBecause sum of first k ```positive``` numbers is **( k * ( k+1 ) ) / 2**\\n\\nHence our search space is reduced.\\n\\nNow for odd values of k.\\n* It is valid if and only if **num % k == 0**.\\n* Proof is divide the number to get the middle of consecutive numbers, and form arithmetic progression with diff +1 and -1\\n\\nFor even values,\\nTest runs are needed to be done.\\n* for k=2,  sum = n + n+1 = **2y + 1**\\n* for k=4,  sum = n + n+1 + n+2 + n+3 = 4y+6 = **4x +2**\\n* same way for k=6, sum = **6x+3**\\n* for k=8 , sum = **8x+4**\\n\\n* Hence for ```k = i``` and i is even, \\nSum will exist if  ```( i * x ) + ( i / 2 ) == num```\\nOR we can say ``` ( num - ( i / 2 )) % ( i ) ==0\\nIf above condition hold then a **x** exists\\n\\n**UPVOTE IF HELPFuuL**\\n\\n![image](https://assets.leetcode.com/users/images/5b4f1353-0c85-4430-a42e-7f3ec03a5a77_1655201233.83737.jpeg)\\n\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```positive```\n```k```\n```num```\n```1 <= k <= \\u221A( 2*num )```\n```positive```\n```k = i```\n```( i * x ) + ( i / 2 ) == num```",
                "codeTag": "Unknown"
            },
            {
                "id": 1508921,
                "title": "mathematical-solution-in-o-n-0-5-with-explanation",
                "content": "**Exapmple we are using is 9**\\n\\nFor this question we need to use some claims.\\n**Claim 1:-**\\nWe can have at most one k length consecutive sequence with the given sum.\\nFor example in case of 9 we can have 2,3,4 as 3 length consecutive sequence now if we move our window then we will have either sum > 9 or sum < 9.\\n**Claim 2:-**\\nSuppose we have sequence of k length consecutive sequence starting from x then our sequence be: \\nx + (x + 1) + (x + 2) + ........ + (x + k -1) \\nNow this is equal to n (according to question)\\n=> kx + (1+2+3+4+........+k-1) = n\\n=> kx + (k(k-1))/2 = n\\n=> x = {n - (k(k-1))/2}/k\\nNow to find valid answers we need to find weather x is Integer or not \\nIf it is integer then increment counter else continue\\n\\nNow x can\\'t be negative hence n - (k(k-1))/2 >= 0\\n=> 2n >= (k)(k-1)\\n=> hence max value of k can be (2n)^0.5\\n\\n```\\nclass Solution {\\n     public int consecutiveNumbersSum(int N) {\\n        int ans=0;\\n        for(int k=1;k*k<2*N;k++){\\n            if((N - (k-1)*k/2) % k == 0) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int consecutiveNumbersSum(int N) {\\n        int ans=0;\\n        for(int k=1;k*k<2*N;k++){\\n            if((N - (k-1)*k/2) % k == 0) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453727,
                "title": "c-maths-with-detailed-explanation-easy",
                "content": "we have to count the number of ways to express the number\\nas a sum of consecutive numbers\\n\\n k - length of each answer\\n \\nn = 15\\nk = 1 -> 15\\nk = 2 -> 7 + 8\\nk = 3 -> 4 + 5 + 6\\n k = 4 -> No answer\\n k = 5 -> 1 + 2 + 3 + 4 + 5\\n\\n\\nso for some k, lets say that the starting element is x, which means\\nx + (x + 1) + (x + 1) + .... (x + (k-1)) = N;\\nk*x + k*(k-1)/2 = N\\n\\nx = (N - k*(k-1))/k\\nx = numerator/denominator\\n\\nalso it is given that x is +ve, so N - k*(k-1)/2 > 0\\n\\t\\t\\t\\t\\t\\t\\t    => k(k-1) < 2*N\\nso basically we have to explore all the k values from  1 till k*(k-1) becomes gte 2N\\nalso, a k is valid , that is we can form a series of length k only when x is an integer\\n\\nx = integer\\nor numerator % denominator = 0 - (condition 1)\\n\\nso iterating over each k as stated above , whenever condition 1 holds we will increment our count\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\tint consecutiveNumbersSum(int n) {\\n\\t\\tint cnt = 0;\\n\\n\\t\\tfor (int k = 1; k * (k - 1) < 2 * n ; k++) {\\n\\t\\t\\tint nr = n - (k * (k - 1)) / 2;\\n\\t\\t\\tint dr = k;\\n\\t\\t\\tif (nr % dr == 0) cnt++;\\n\\t\\t}\\n\\n\\t\\treturn cnt;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint consecutiveNumbersSum(int n) {\\n\\t\\tint cnt = 0;\\n\\n\\t\\tfor (int k = 1; k * (k - 1) < 2 * n ; k++) {\\n\\t\\t\\tint nr = n - (k * (k - 1)) / 2;\\n\\t\\t\\tint dr = k;\\n\\t\\t\\tif (nr % dr == 0) cnt++;\\n\\t\\t}\\n\\n\\t\\treturn cnt;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188150,
                "title": "python-brute-force-to-optimal-heavily-commented",
                "content": "\\t# Let\\'s represent N as the sum of the following series of consequetive numbers:\\n\\t# N = a + (a+1) + (a+2) + ... + (a+k-1) \\n\\t# Now there are two ways to go from here:\\n\\t# Approach 1 -\\n\\t# Look at all possible values of \\'a\\' and calculate \\'k\\'\\n\\t# This can be achieved using a variable length sliding window\\n\\t# So we basically start calculating sum from 1, 2, 3... upto N\\n\\t# if the sum equals N, add one to the result\\n\\t# if the sum exceeds N, shrink the window from the left\\n\\t\\n\\t# Time - O(N) since we iterate over all numbers from 1 to N\\n\\t# Space - O(1)\\n\\t# This approach will TLE, let\\'s try to do better...\\n\\n```\\nclass Solution(object):\\n    def consecutiveNumbersSum(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        # Initialize sum to 0\\n        _sum = 0\\n        \\n        # Start window at 1\\n        start = 1\\n        \\n        # Initialize count to 0\\n        count = 0\\n        \\n        # Iterate over the range 1 to N and calculate the running sum\\n        for i in range(1, N+1):\\n            _sum += i\\n            # If the sum exceeds K, shrink the window\\n            while _sum > N:\\n                _sum -= start\\n                start += 1\\n            # If the sum equals N, add one to the count\\n            if _sum == N:\\n                count += 1\\n        return count\\n```\\n\\n\\t# Approach 2 - \\n\\t# Look at all possible values of \\'k\\' and calculate \\'a\\'\\n\\t# From the previous series:  N = a + (a+1) + (a+2) + ... + (a+k-1) \\n\\t# For different values of k, check if a == n?\\n\\t# k = 1 -> a = n\\n\\t# k = 2 -> a + (a+1) == n -> a = (n-1)/2\\n\\t# k = 3 -> a + (a+1) + (a+2) == n -> a = (n-3)/2\\n\\t#...\\n\\t# k = n -> a + (a+1) + (a+2) + (a+3) + ... +(a+n-1) == n -> a = 1\\n\\t# Generalizing this,\\n\\t# a + (a+1) + (a+2) + ... +(a+k-1) = n\\n\\t# (k*a) + (1+2+3+...+k-1) = n\\n\\t# a = (n - k*(k-1)/2)/k\\n\\t# if a is in the range 1 to N and a is an integer, it is valid, add one to the count\\n\\n\\t# Time complexity:\\n\\t# for a > 0, (n - k*(k-1)/2)/k > 0\\n\\t# -> n - k*(k-1)/2 > 0\\n\\t# -> k*(k-1)/2 < n\\n\\t# -> ~ k**2 < 2*n\\n\\t# -> ~ k < \\u221A2*n\\n\\t# -> k ~ O(\\u221An) FAST!\\n\\n```        \\nclass Solution(object):\\n    def consecutiveNumbersSum(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        k = 1\\n        count = 0\\n        while (N - (k*(k-1))//2) > 0:\\n            if (N - (k*(k-1))//2) % k == 0:\\n                count += 1\\n            k +=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution(object):\\n    def consecutiveNumbersSum(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        # Initialize sum to 0\\n        _sum = 0\\n        \\n        # Start window at 1\\n        start = 1\\n        \\n        # Initialize count to 0\\n        count = 0\\n        \\n        # Iterate over the range 1 to N and calculate the running sum\\n        for i in range(1, N+1):\\n            _sum += i\\n            # If the sum exceeds K, shrink the window\\n            while _sum > N:\\n                _sum -= start\\n                start += 1\\n            # If the sum equals N, add one to the count\\n            if _sum == N:\\n                count += 1\\n        return count\\n```\n```        \\nclass Solution(object):\\n    def consecutiveNumbersSum(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        k = 1\\n        count = 0\\n        while (N - (k*(k-1))//2) > 0:\\n            if (N - (k*(k-1))//2) % k == 0:\\n                count += 1\\n            k +=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098250,
                "title": "java-sliding-window-approach-tle-with-easy-to-understand-code-o-n",
                "content": "Realistically, this is probably what I can come up with in an interview. Sliding window approach that loops N/2 times, and time complexity is O(n). Broke up the code in a way it is easier to understand.\\n\\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        if (N == 1)\\n            return 1;\\n        \\n        int half = (N - 1)/2 + 1; // The max number in the series is bound by this\\n        int count = 1; // Signifies count of consecutive integers leading to the sum\\n        int left = 1;\\n        int right = 1;\\n        int runningSum = 1;\\n        \\n        // Sliding window from left to right to try and get consecutive numbers\\n        while (right <= half) {\\n            if (runningSum == N) {\\n                // Match found!\\n                count++;\\n                runningSum -= left;\\n                // Reduce the window by one since a match has been found already\\n                left++; \\n            }\\n            else if (runningSum > N) {\\n                // Current window has no chance of finding a match by expanding\\n                runningSum -= left;\\n                left++;\\n            }\\n            else {\\n                // Increase right side of the window\\n                right++; \\n                runningSum += right;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        if (N == 1)\\n            return 1;\\n        \\n        int half = (N - 1)/2 + 1; // The max number in the series is bound by this\\n        int count = 1; // Signifies count of consecutive integers leading to the sum\\n        int left = 1;\\n        int right = 1;\\n        int runningSum = 1;\\n        \\n        // Sliding window from left to right to try and get consecutive numbers\\n        while (right <= half) {\\n            if (runningSum == N) {\\n                // Match found!\\n                count++;\\n                runningSum -= left;\\n                // Reduce the window by one since a match has been found already\\n                left++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 848402,
                "title": "1-line-solution-java-5ms-with-detailed-explanation",
                "content": "Let\\'s take an Example for 15 :- \\nFor 15 :- we have the following cases :- \\n**1. 15\\n2. 7 + 8\\n3. 4 + 5 + 6\\n4. 1 + 2 + 3 + 4 + 5**\\n\\nNow let\\'s take an Example that the **current starting value be x** and the **length of the consecutive sequence be K**. So for above K can be 1,2,3(which are length) and so on. \\n\\nNow :- \\n**(x + 0) + (x + 1) + (x + 2) + .....(x + (k - 1)) = N** ( As **x is a starting point** and **there is consecutive sequence so we can have x + 0 , x + 1 and till x + (k - 1)** till the sum is equal to N.\\n\\nNow :- \\n**k*x + (0 + 1 + 2 + 3 + 4 + (k - 1)) = N**. (Seperating the above equation)\\n\\n**k*x + ( k * ( k - 1 )/2) = N** ( sum of natural number formula )\\n\\nNow put k value as 1 which basically means that the length should be 1.\\n1*x  + (1 * (1 - 1)/2) = N ( N is 15 )\\nx + 0 = 15\\nx = 15. ( with length 1 we can have x = 15 , where x is the starting value )\\n\\nNow consider same for **k = 2 you will get the answer as 7. :P (Try it)**\\n\\nNow **the question arises that till when we have to compute the value of k** ( like from 1 till ............ )\\n\\nsee k*x will always be positive because k is length which is positive and x is the starting value which is also positive as given in the question.\\nSo :- \\nN - k * ( k - 1 )/2 >= 0\\nN >= k*(k - 1)/2\\nN >= k^2 / 2 ( Rounding off)\\n**k <= sqrt(2*N)**\\n```\\npublic int consecutiveNumbersSum(int N) {\\n        int ans = 0;\\n        for(int k = 1;k <= Math.sqrt(2 * N);k++) if(((N - (k*(k - 1)/2)) % k) == 0) ans++;\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int consecutiveNumbersSum(int N) {\\n        int ans = 0;\\n        for(int k = 1;k <= Math.sqrt(2 * N);k++) if(((N - (k*(k - 1)/2)) % k) == 0) ans++;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356091,
                "title": "thought-process-explanation-with-mathematical-proof-with-code",
                "content": "In question for few example test cases  we observed that we are getting n by adding consecutive k terms in 1 way only.. **Example for n = 5 and k = 2, `5 -> 2 + 3 the only way for 2 terms`**\\n\\nwe can get n by taking 1 term(n itself),adding two terms.. adding 3 terms.. upto k terms..\\nfor `n = 9` the value of `k is 3`.. for `k = 1 -> 9`, for `k = 2 -> 4 + 5 = 9`, for `k = 3 -> 2 + 3 + 4 = 9`\\nk terms, k known and assume x as starting term\\nsum of k terms should give n\\nx + (x+1) + (x+2) + (x+k-1) = n\\nkx + k(k-1)/2 = n \\nkx = n - k(k-1)/2\\n**for upto what values of k, the expression n - k(k-1)/2 will give positive**\\nn - k(k-1)/2 > 0\\nk(k-1) < 2n\\nsince we know (k-1)(k-1) < k(k-1) so we can write as `(k-1)(k-1) < k(k-1) < 2n`-> `(k-1)(k-1) < 2n`\\n(k-1)(k-1) < 2n -> k-1 < math.sqrt(2n) ->` k < math.sqrt(2n) + 1`\\n\\nnow x = (n- k(k-1)/2)/k  `so if n-k(k-1)/2 is divisible by k then only we can get x as positive integer and a way`\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        res = 0\\n        for k in range(1,math.ceil(math.sqrt(2*n))+1):\\n            if (n- k*(k-1)//2) > 0 and not (n- k*(k-1)//2) % k: res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        res = 0\\n        for k in range(1,math.ceil(math.sqrt(2*n))+1):\\n            if (n- k*(k-1)//2) > 0 and not (n- k*(k-1)//2) % k: res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150748,
                "title": "python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\nFirstly the question demands sum of consecutive ```positive``` integers.\\n\\nLet there be ```k``` positive integers that sum to ```num```.\\n\\n**Only possible values of k are ```1 <= k <= \\u221A( 2*num )```**\\n\\nBecause sum of first k ```positive``` numbers is **( k * ( k+1 ) ) / 2**\\n\\nHence our search space is reduced.\\n\\nNow for odd values of k.\\n* It is valid if and only if **num % k == 0**.\\n* Proof is divide the number to get the middle of consecutive numbers, and form arithmetic progression with diff +1 and -1\\n\\nFor even values,\\nTest runs are needed to be done.\\n* for k=2,  sum = n + n+1 = **2y + 1**\\n* for k=4,  sum = n + n+1 + n+2 + n+3 = 4y+6 = **4x +2**\\n* same way for k=6, sum = **6x+3**\\n* for k=8 , sum = **8x+4**\\n\\n* Hence for ```k = i``` and i is even, \\nSum will exist if  ```( i * x ) + ( i / 2 ) == num```\\nOR we can say ``` ( num - ( i / 2 )) % ( i ) ==0\\nIf above condition hold then a **x** exists\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        i=1\\n        res=0\\n        k=int((n*2)**0.5)\\n        while i<=k:\\n            if i%2:\\n                if n%i==0:\\n                    res+=1\\n            elif (n-(i//2))%i==0:\\n                res+=1\\n            i+=1\\n        return res\\n```\\n\\n![image](https://assets.leetcode.com/users/images/f53fe2c0-978c-4939-baa5-5d30cec472ab_1655201159.264783.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```positive```\n```k```\n```num```\n```1 <= k <= \\u221A( 2*num )```\n```positive```\n```k = i```\n```( i * x ) + ( i / 2 ) == num```\n``` ( num - ( i / 2 )) % ( i ) ==0\\nIf above condition hold then a **x** exists\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1370730,
                "title": "java-solution-simple-algebra-solution",
                "content": "Please rate if I helped, keeps me motivated to post more\\n```\\n// Sum of consecutive integers is given by N = n * (n+1)/2\\n// Here is a list of possibilities where we can form our target:\\n// 1 +2 + ... + n\\n// 2 + 3 + ... + n + (n+1) \\n// Wait, why don\\'t we do some algebra and notice \\n// 1 + 2 + ... + n + n \\\\\\\\ then we can keep doing this step \\n// 1 + 2 + ... + n + n + n\\n// Notice that % n here can be applied to account for these extra n\\'s\\n// This is the hardest part because we are so used to using mod to check for odd and\\n// even or remainders. Both in mathematical proofs and algorithms\\n\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int total = 0;\\n        for(int n = 2; n* (n+1) / 2 <= N; n++) // while our sum is smaller than our target\\n            if( (N - (n*(n+1)/2)) % n == 0) total++;   \\n        return total + 1; // the plus one accounts for \"trivial case\" of 1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Sum of consecutive integers is given by N = n * (n+1)/2\\n// Here is a list of possibilities where we can form our target:\\n// 1 +2 + ... + n\\n// 2 + 3 + ... + n + (n+1) \\n// Wait, why don\\'t we do some algebra and notice \\n// 1 + 2 + ... + n + n \\\\\\\\ then we can keep doing this step \\n// 1 + 2 + ... + n + n + n\\n// Notice that % n here can be applied to account for these extra n\\'s\\n// This is the hardest part because we are so used to using mod to check for odd and\\n// even or remainders. Both in mathematical proofs and algorithms\\n\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int total = 0;\\n        for(int n = 2; n* (n+1) / 2 <= N; n++) // while our sum is smaller than our target\\n            if( (N - (n*(n+1)/2)) % n == 0) total++;   \\n        return total + 1; // the plus one accounts for \"trivial case\" of 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344674,
                "title": "java-no-math-solution-with-explaination",
                "content": "The idea behind the solution is that for a large target number, to make consecutive sum equal to the target, each number would be a first number plus 1, 2, 3...\\n\\nfor example, for 2 numbers to add up to 50001, we need 25000 and 25001, which is (25000 + 0) + (25000 + 1)\\nfor 3 number to add up to 60003, we need 20000, 20001, 20002, which is (20000 + 0) + (20000 + 1) + (20000 + 2)\\n\\nlet\\'s look at the numbers after the first number, basically they need to add 1, 2, 3.. \\n\\nbut how many? \\n\\nfor 2 numbers, we need to add 1\\nfor 3 numbers, we need to add 1 + 2\\nfor 4 numbers, we need to add 1 + 2 + 3\\n...\\nfor k numbers, we need to add 1 + 2 + 3 + 4 .. + k - 1\\n\\nso now let\\'s loop through the possible number of consecutive numbers that adds to target. \\nfor loop 1, we just need to subtract 0, and make sure 1 integer can add up to target. here this number is just target itself.\\nfor loop 2, we substract 1, the rest should be able to be devided into two integers, like 100 + 100, or 200 + 200. we can use mod to check this, as long as rest % 2 == 0, we know such two numbers exist.\\nfor loop 3, we substract 1 + 2, the rest should be able to be devided into three integers, like 12 + 12 + 12. the 1 and 2 are taken away from the second 12 and third 12, which they were 12 + 13 (12 + 1) + 14 (12 + 2). for the rest, we just need to % 3 and check if it\\'s 0;\\n\\nhere is the code:\\n\\n    public int consecutiveNumbersSum(int n) {\\n        \\n        int substrahend = 0;\\n        int nums = 1;\\n        int res = 0;\\n        \\n        while (substrahend + nums <= n) {\\n            if ((n - substrahend) % nums == 0) {\\n                res ++;\\n            }\\n            \\n            substrahend += nums;\\n            nums++;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "The idea behind the solution is that for a large target number, to make consecutive sum equal to the target, each number would be a first number plus 1, 2, 3...\\n\\nfor example, for 2 numbers to add up to 50001, we need 25000 and 25001, which is (25000 + 0) + (25000 + 1)\\nfor 3 number to add up to 60003, we need 20000, 20001, 20002, which is (20000 + 0) + (20000 + 1) + (20000 + 2)\\n\\nlet\\'s look at the numbers after the first number, basically they need to add 1, 2, 3.. \\n\\nbut how many? \\n\\nfor 2 numbers, we need to add 1\\nfor 3 numbers, we need to add 1 + 2\\nfor 4 numbers, we need to add 1 + 2 + 3\\n...\\nfor k numbers, we need to add 1 + 2 + 3 + 4 .. + k - 1\\n\\nso now let\\'s loop through the possible number of consecutive numbers that adds to target. \\nfor loop 1, we just need to subtract 0, and make sure 1 integer can add up to target. here this number is just target itself.\\nfor loop 2, we substract 1, the rest should be able to be devided into two integers, like 100 + 100, or 200 + 200. we can use mod to check this, as long as rest % 2 == 0, we know such two numbers exist.\\nfor loop 3, we substract 1 + 2, the rest should be able to be devided into three integers, like 12 + 12 + 12. the 1 and 2 are taken away from the second 12 and third 12, which they were 12 + 13 (12 + 1) + 14 (12 + 2). for the rest, we just need to % 3 and check if it\\'s 0;\\n\\nhere is the code:\\n\\n    public int consecutiveNumbersSum(int n) {\\n        \\n        int substrahend = 0;\\n        int nums = 1;\\n        int res = 0;\\n        \\n        while (substrahend + nums <= n) {\\n            if ((n - substrahend) % nums == 0) {\\n                res ++;\\n            }\\n            \\n            substrahend += nums;\\n            nums++;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 859874,
                "title": "python-6-lines-with-tighter-upper-bound-for-k",
                "content": "The idea is that we loop through all the possible k such that the sum of k consecutive integers is equal to N. We can easily prove that for each k there is at most one solution (not proven here).\\nBelow is the calculation step to find a tighter upper bound for k to reduce our time complexity to O(sqrt(N)).\\n```\\nx+(x+1)+...+(x+k-1) = N\\n<--total k terms--> We start with x instead of x+1 to eliminate the possibility of x being 0\\nxk + k(k-1)/2 = N\\nx >= 1 and k >= 1 and both x and k need to be integer, thus\\nN - k(k-1)/2 = xk >= 1\\n2(N-1) >= k(k-1)\\n2(N-1) + 1/4 >= (k-1/2)**2\\nsqrt(2(N-1)+1/4) + 1/2 >= k\\n```\\n\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        # x+(x+1)+...+(x+k-1) = N\\n        # <---- k  terms ---->\\n        # xk + k(k-1)/2 = N\\n        # x >= 1, k >= 1 and both x and k is integer\\n        # calculate k upperbound\\n\\t\\t# use floor here because if we have k <= 5.3, k can be at most 5\\n        upper = math.floor(math.sqrt(2*(N-1)+0.25) + 0.5)\\n        count = 0\\n\\t\\t# we make sure k is an integer and k >=1 with this loop\\n        for k in range(1, upper+1):\\n\\t\\t\\t# we want to make sure x is an integer, we already make sure we choose k so that x >= 1 with that upper bound for k\\n            if (N - (k-1)*k // 2) % k == 0:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nx+(x+1)+...+(x+k-1) = N\\n<--total k terms--> We start with x instead of x+1 to eliminate the possibility of x being 0\\nxk + k(k-1)/2 = N\\nx >= 1 and k >= 1 and both x and k need to be integer, thus\\nN - k(k-1)/2 = xk >= 1\\n2(N-1) >= k(k-1)\\n2(N-1) + 1/4 >= (k-1/2)**2\\nsqrt(2(N-1)+1/4) + 1/2 >= k\\n```\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        # x+(x+1)+...+(x+k-1) = N\\n        # <---- k  terms ---->\\n        # xk + k(k-1)/2 = N\\n        # x >= 1, k >= 1 and both x and k is integer\\n        # calculate k upperbound\\n\\t\\t# use floor here because if we have k <= 5.3, k can be at most 5\\n        upper = math.floor(math.sqrt(2*(N-1)+0.25) + 0.5)\\n        count = 0\\n\\t\\t# we make sure k is an integer and k >=1 with this loop\\n        for k in range(1, upper+1):\\n\\t\\t\\t# we want to make sure x is an integer, we already make sure we choose k so that x >= 1 with that upper bound for k\\n            if (N - (k-1)*k // 2) % k == 0:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155120,
                "title": "c-solution-with-strict-and-detailed-proof",
                "content": "We assume that the Consecutive Numbers start with `x`, and end with `(x + k)`(of course `k >= 0`, if `k == 0`, we got a solution `x = N`).\\n\\nSo we get the series:\\n\\n`x + (x+1) + (x+2) + ... + (x+k) = (k+1)x + 1+2+ ... +k`\\n\\nAccording to The sum of the arithmetic series:\\n\\n`1+2+ ... +k = (k+1)k/2`\\n\\nWe got:\\n\\n`(k+1)x + 1+2+ ... +k = (k+1)x + (k+1)k/2`\\n\\nLet the above fomula equal to `N`:\\n\\n`(k+1)x + (k+1)k/2 = N`\\n\\nThen:\\n\\n`x = [N-(k+1)k/2]/(k+1)`\\n\\nThe number of `k` such that `0 < x <= N` and `x belong to integer` is the answer.\\n\\nSo we just need to take different `k` to the fomula above and calculate the `x`, if `0 < x <= N` and `x belong to integer`, the answer plus one.\\n\\nBut what is the range of `k` should we try?\\n\\nWe just need to solve two inequality:\\n\\n`x = [N-(k+1)k/2]/(k+1) <= N, k >= 0`\\n\\n`x = [N-(k+1)k/2]/(k+1) > 0, k >= 0`\\n\\nSimpliffied the first inequality we got:\\n\\n`k[N+(k+1)/2] >= 0`\\n\\nBecause `k >= 0` and `N > 0`, so the inequality above always true.\\n\\nSimpliffied the second inequality we got:\\n\\n`k*k + k - 2N < 0`\\n\\nSolve the inequality we got:\\n\\n`-sqrt(0.25 + 2N) - 0.5 < k < sqrt(0.25 + 2N) - 0.5`\\n\\nBecause `k >= 0`, finally we got:\\n\\n`0 <= k < sqrt(0.25 + 2N) - 0.5`\\n\\n```c++\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        int ans = 0;\\n        for(int k = 0; k < sqrt(0.25 + 2*N) - 0.5; k++)\\n            if((N-((k+1)*k)/2) % (k+1) == 0)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```\\n\\nInspired by @pavan5 top solution.",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        int ans = 0;\\n        for(int k = 0; k < sqrt(0.25 + 2*N) - 0.5; k++)\\n            if((N-((k+1)*k)/2) % (k+1) == 0)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171793,
                "title": "easy-and-small-solution-math-time-complexity-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution is to find a pattern between consicutive sums, if you calculate consicutive sum of **length 2**\\neg -> **(1 + 2 = 3), (2 + 3 = 5), (3 + 4 = 7)**, ...\\nit is an ap with **common diff = 2** and **first term = 3**\\n\\nsimilarly for **length 3**\\neg -> **(1 + 2 + 3 = 6), (2 + 3 + 4 = 9), (3 + 4 + 5 = 12)**,....\\nit is an ap with **common diff = 3** and **first term = 6**.\\nSimilarly if you calculate further you will notice that\\n\\n```\\nlength---------common diff---------first term\\n1-------------------1------------------1\\n2-------------------2------------------3\\n3-------------------3------------------6\\n4-------------------4------------------10\\n5-------------------5------------------15\\n6-------------------6------------------21\\n```\\nand so on...................\\n\\nIf you notice common diff for each length is equal to length and difference between every first term is the length of bigger term\\neg -> **(3 - 1 = 2), (6 - 3 = 3), (10 - 6 = 4), (15 - 10 = 5), (21 - 15 = 6)**, ......\\nSo from above information I can get first term and diff for each length.\\n`i.e. for length = i, common diff = i, first term = previous first term + i`\\nSince we know consecutive sum of any length have all terms in ap\\nso from nth term formula of ap i.e\\n***a(n) = a + (n-1) * d***\\nwe get that ( a(n) - a ) / d = n-1.\\nHere ***common diff = d*** and ***first term = a***.\\n``So we can say that if d divides (x - a) or ((x-a) % d == 0) then x is in that ap``\\neg -> for length 3 common diff = d = 3 and first term = a = 6\\nif x = 11,\\n(x - a) = (11 - 6) = 5 & 5 % d = 5 % 3 = 2 != 0\\ntherefore if x = 11 it cannot be broken in term of 3 consecutive terms\\nbut if x = 12\\n(x - a) = (12 - 6) = 6 & 6 % d = 6 % 3 = 0\\ntherefore 12 can be broken in terms of 3 consecutive terms\\ni.e. 12 = 3 + 4 + 5\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo for solving the problem we can find first term and common diff of each length using `loop till first term <= n` and use a counter and `if (n - first term) % (common diff) == 0` then we will increment the counter i.e. `ct++`.\\nAnd that counter will represent how many lengths can have consecutuve integers as sum n.\\n\\n# Complexity\\n#### - Time complexity: O(sqrt(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nif you see first terms have difference in ap for which mth term can be represented in a quadratic polynomial (a(m^2) + b(m) + c = m^th term)\\nso if you want mth term to be n you will have m close to sqrt(n) which gives m^2 = n, therefore putting m = sqrt(n) in expression we get sqrt(n)^th term > n\\nYou can get more info here -> \\n[https://math.stackexchange.com/questions/1961952/how-do-i-find-the-sum-of-a-sequence-whose-common-difference-is-in-arithmetic-pro](https://math.stackexchange.com/questions/1961952/how-do-i-find-the-sum-of-a-sequence-whose-common-difference-is-in-arithmetic-pro)\\n\\n#### - Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n#### Upvote if you find it useful\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int first_term = 0;\\n        int common_diff = 0;\\n        int ct = 0;\\n        for(int i = 1; i < 100000; i++)\\n        {\\n            first_term += i;\\n            common_diff++;\\n            if((n - first_term) < 0)\\n            {\\n                break;\\n            }\\n            if((n-first_term) % common_diff == 0)\\n            {\\n                ct++;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nlength---------common diff---------first term\\n1-------------------1------------------1\\n2-------------------2------------------3\\n3-------------------3------------------6\\n4-------------------4------------------10\\n5-------------------5------------------15\\n6-------------------6------------------21\\n```\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int first_term = 0;\\n        int common_diff = 0;\\n        int ct = 0;\\n        for(int i = 1; i < 100000; i++)\\n        {\\n            first_term += i;\\n            common_diff++;\\n            if((n - first_term) < 0)\\n            {\\n                break;\\n            }\\n            if((n-first_term) % common_diff == 0)\\n            {\\n                ct++;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077079,
                "title": "java-with-mathematical-observation-o-logn",
                "content": "\\t\\n\\tLet be Number, N = 15.\\n\\tLets discuss the posibility of making number N using k consecutive number.\\n\\tk = 1, True => 15\\n\\tk = 2, True => 7 + 8 = 15\\n\\tk = 3, True => 4 + 5 + 6 = 15\\n\\tk = 4, False => Not possible to make number using four consecutive number\\n\\tk = 5, True => 1 + 2 + 3 + 4 + 5 = 15\\n\\tk = 6, false => Not possible to make number using six consecutive number\\n\\t.\\n\\t.\\n\\tk = Kmax???\\n\\n\\tIf we know the value of Kmax, then we simply run a loop from k = 1 to k = Kmax \\n\\tand check the possibility of making number N using k consecutive number. Then, question is how to find the value of Kmax?? \\n\\tLet\\'s discuss the mathematical observation for finding Kmax.\\n\\n\\t<====== OBSERVATION ======>\\n\\t\\uD83D\\uDCCC 1. HOW TO FIND Kmax??? \\uD83D\\uDCCC\\n\\t=> Let x be 1st term in k consecutive number which is neither negative nor zero;\\n\\t=> x + (x + 1) + (x + 2) + (x + 3) + ..... + [x + (k - 1)] = N; \\n\\t=> kx + (0 + 1 + 2 + 3 + .... + (k - 1)) = N\\n\\t=> kx + k(k - 1) / 2 = N\\n\\t=> kx = N - k(k - 1) / 2  ---------------->> ( i )\\n\\t=> x = N/k - (k - 1)/2 , \\n\\n\\tWe know x(starting value of consecutive) can not be a negative or zero so x always be greater than zero\\n\\t=> N/k - (k - 1)/ 2 > 0\\n\\t=> 2N > k(k - 1) , condition between N & k -> In terms of order = O(square root of (N))\\n\\n\\tFor k, it is from k = 1 to 2N > k(k - 1), k increment by 1\\n\\n\\t\\uD83D\\uDCCC 2. How to find it is possible to make target sum with k consecutive numbers??? \\uD83D\\uDCCC\\n\\t=> kx  = N - k(k - 1)/2 ,   [From eq (i)]\\n\\t=> x = [2N - k(k - 1)] / 2k\\n\\t=> x = [N - k(k - 1) / 2] / k , numerator->N - k(k - 1)/2, denomanator -> k\\n\\t\\n\\t------------------------------------------------------------------------------------------------------------------------------------------\\n\\tJAVA CODE:\\n\\tclass Solution {\\n\\t\\tpublic int consecutiveNumbersSum(int n) {\\n\\t\\t\\tint cnt = 0;\\n\\t\\t\\tfor(int k = 1; k*(k - 1) < 2*n; k++) {\\n\\t\\t\\t\\t// we have to find it is possible to make sum with k numbers\\n\\t\\t\\t\\tint numerator = n - (k * (k - 1) / 2);\\n\\t\\t\\t\\tint denomanator = k;\\n\\n\\t\\t\\t\\tif(numerator % denomanator == 0) cnt++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int consecutiveNumbersSum(int n) {\\n\\t\\t\\tint cnt = 0;\\n\\t\\t\\tfor(int k = 1; k*(k - 1) < 2*n; k++) {\\n\\t\\t\\t\\t// we have to find it is possible to make sum with k numbers\\n\\t\\t\\t\\tint numerator = n - (k * (k - 1) / 2);\\n\\t\\t\\t\\tint denomanator = k;\\n\\n\\t\\t\\t\\tif(numerator % denomanator == 0) cnt++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1483214,
                "title": "java-explanation",
                "content": "**IDEA**\\nEvery number can be equal to sum of either 1 number, 2 numbers....k numbers.\\nOur goal in this problem is to find such numbers with constraint that all number should be consecutive\\nLets say first number be `x` then 2nd number be `x+1`, 3rd number be `x+2` and Kth number be `x + k - 1`\\n\\nIn below code main focus was to check in `kth` iteration if there exist `k` consecutive numbers whose sum is equal to n. If exist increment my ans.\\n```\\nat kth iteration\\n\\tif x + (x+1) + (x+2) + (x +3) +.....+(x + k - 1) == n\\n\\tthen increment ans;\\n```\\n\\nNow to find until when while loop will run \\nwe have to find  value of k in terms of n by solving:\\n`x + (x+1) + (x+2) + (x +3) +.....+(x + k - 1) = n`\\nwhich will give `k * (k-1) < 2 * n`\\n**CODE**\\n```\\n\\tpublic int consecutiveNumbersSum(int n) {\\n        int sum = 1;\\n        int count = 1;\\n        int k = 2;\\n        while(2*n > k * (k - 1)){\\n            if((n - sum) % k == 0){\\n                count++;\\n            }\\n            sum += k;\\n            k++;\\n        }\\n        \\n        return count;\\n     }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nat kth iteration\\n\\tif x + (x+1) + (x+2) + (x +3) +.....+(x + k - 1) == n\\n\\tthen increment ans;\\n```\n```\\n\\tpublic int consecutiveNumbersSum(int n) {\\n        int sum = 1;\\n        int count = 1;\\n        int k = 2;\\n        while(2*n > k * (k - 1)){\\n            if((n - sum) % k == 0){\\n                count++;\\n            }\\n            sum += k;\\n            k++;\\n        }\\n        \\n        return count;\\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1077905,
                "title": "java-c-easy-solution-with-explanation",
                "content": "The thought process goes like this- Given a number N, we can possibly write it as a sum of 2 numbers, 3 numbers, 4 numbers and so on. Let\\'s assume the fist number in this series be x. Hence, we should have\\nx + (x+1) + (x+2)+...+ k terms = N\\nkx + k*(k-1)/2 = N implies\\nkx = N - k*(k-1)/2\\nSo, we can calculate the RHS for every value of k and if it is a multiple of k then we can construct a sum of N using k terms starting from `x`.\\nNow, the question arises, till what value of k should we loop for? That\\'s easy. In the worst case, RHS should be greater than 0. That is\\n`N - k*(k-1)/2 > 0` which implies\\n`k*(k-1) < 2N` which can be approximated to\\n`k*k < 2N ==> k < sqrt(2N)`\\nHence the overall complexity of the algorithm is O(sqrt(N))\\n\\nC++ ================================================\\n\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        double upperLimit = sqrt(2 * N);\\n        int count = 0;\\n        for (int k = 1; k < upperLimit; k++) {\\n            int num = (N - (k * (k - 1) / 2));\\n            if (num % k == 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nJava ================================================\\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        double upperLimit = Math.sqrt(2 * N);\\n        int count = 0;\\n        for (int k = 1; k < upperLimit; k++) {\\n            int num = (N - (k * (k - 1) / 2));\\n            if (num % k == 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        double upperLimit = sqrt(2 * N);\\n        int count = 0;\\n        for (int k = 1; k < upperLimit; k++) {\\n            int num = (N - (k * (k - 1) / 2));\\n            if (num % k == 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        double upperLimit = Math.sqrt(2 * N);\\n        int count = 0;\\n        for (int k = 1; k < upperLimit; k++) {\\n            int num = (N - (k * (k - 1) / 2));\\n            if (num % k == 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943209,
                "title": "beat-100-improved-solution-o-n-1-4-time",
                "content": "Maybe this solution is overkill and advanced.\\nI won\\'t go into much details and analysis \\nbecause the solution involves two math theorems and strong algorithms(but not hard). \\nyou can easily find them with google or wiki.\\n\\nThe previous best solution and explanation is credited to [lee215](https://leetcode.com/problems/consecutive-numbers-sum/discuss/128947/JavaC%2B%2BPython-Fastest-Count-Odd-Factors-O(logN)).\\nI had the same thought as he provided and analysed.\\n\\nBasic analysis may be defined\\nN = (top+bottom) * height / 2 \\nN = (x + x + k) * (k+1) / 2 means (k+1) or (2x + k) must be odd and even (2x must be even)\\nIf above is true, odd factors must exist.\\nIn other words, one odd factor can make one combination true.\\n\\nOur mission turns to find how many odd factors can be in N.\\nThat\\'s all! But....how to do is better?\\n\\nLater, I found one important thing most posts neglected(I did\\'t see anyone mentioned it).\\n\\nThat is, after basic analysis, \\nwe can know we need to **find all odd prime factors of N** , \\nbut **not all given N must be a composite number in general cases**.\\n******\\nI think **primality test is the core part** in this task.\\n\\nHow about an edge case, 999999937, the prime nearest to 10^9 ?\\nI guess most solutions will get stuck. \\n(even previous best solution needs to take 2.74 ms per 1,000,000 loops, now improved to 28.9 \\xB5s)\\n\\nIt seems no posts take care of the important point. \\nBut there are around 5% primes in 10^9. \\nI don\\'t think we can neglect their effects to solution.\\n\\nI tested [most upvoted](https://leetcode.com/problems/consecutive-numbers-sum/discuss/128959/JavaPython-3-5-liners-O(N-0.5)-Math-method-w-explanation-and-analysis.), official\\'s, lee215\\'s, and this solution in 10000 random numbers from 100 to 10^9. \\nThey respectively spend around 100s, 30s, 3s, and 0.4s.\\nObiviously, hedging the edge case is as crucial as main operation.\\n\\nIf we use trial division, we only can get O(N^1/2) at best.\\nIt\\'s only efficient in small factor like 2, 3, 5, 7, or so.\\nOfficial provides Shor\\'s Algorithm or GNFS Algorithm, \\nwhich are not used for the general cases but for big numbers(like 10^100).\\nAnd they are difficult to implement and realize(computationally expensive)\\nif we do not have solid academic background of math or cryptography (of course, no quantum computer).\\n\\nI combine two practical algorithms, \\n[**Miller\\u2013Rabin primality test**](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test)  and **[Pollard\\'s rho algorithm](https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm)** \\nto avoid we get stuck in those edge cases, the larger prime factors.\\nThey are easier for us to understand (code) and applied in practical work often.\\n\\nIf you have any question of these two algorithms or code, \\nfeel free to comment this post. I will answer as I can.\\nHope helpful! \\n\\nTime complexity: O(N^1/4) (heuristic)\\nSpace complexity: O(1)\\n\\n```\\nclass Solution: # best 16 ms\\n    def consecutiveNumbersSum(self, N):\\n        res = 1; factor = 3\\n        # extract factor of 2^n\\n        while not N & 1: N >>= 1\\n        \\n        while factor * factor <= N:\\n            count = 0\\n\\t\\t\\t# avoid edge case and use strong algorithm\\n\\t\\t\\t# this setting is because we can\\'t expect to iterate so many times to find a big prime,\\n\\t\\t\\t# like 999999937(need (999999937^0.5) / 2 times vs miller_rabin_test\\'s 11 times)\\n            if factor > 50 and N > 10**5: \\n                if self.miller_rabin_test(N): break # O(k*logN)\\n                else: factor = self.pollard_rho(N) # O(N^1/4)\\n            while not N % factor:\\n                N //= factor\\n                count += 1\\n            res *= count + 1\\n            factor += 2\\n\\n        return res if N == 1 else res * 2\\n    \\n    # O(k*logN), k: num of bases, primality test\\n    def miller_rabin_test(self, num):\\n\\t    # helper func. for faster b^e % m \\n        def fast_modular_exp(base, exponent, modulo):\\n            ans = 1\\n            while exponent:\\n                if exponent & 1:\\n                    ans = (ans * base) % modulo\\n                exponent >>= 1\\n                base = (base * base) % modulo\\n            return ans\\n\\n        # current test setting definitely\\n        # works only in num < 4,759,123,141 (almost 2.007**32)\\n        bases = [2, 7, 61]; isPrime = True\\n        \\n        m = n = num - 1; s = 0\\n\\t\\t# extract m * 2 ^ s, make m odd\\n        while not m & 1: m >>= 1; s += 1 # O(logN)\\n        \\n        for b in bases:\\n            # O(logN), pow() is efficient only when m < 1000\\n            if m < 1000: remainder = pow(b, m) % num\\n            else: remainder = fast_modular_exp(b, m, num)\\n\\t\\t\\t\\n            # if pass test of current base, change base\\n\\t\\t\\t# if pass all bases, num is a prime\\n            if remainder == 1 or remainder == n: continue\\n\\t\\t\\t# O(k*logN), k is dependent on test\\'s need\\n            for i in range(1, s+1): \\n                if i == s: isPrime = False; break\\n                remainder = remainder **2 % num\\n                if remainder == 1: isPrime = False; break\\n                if remainder == n: break\\n            if not isPrime or num < 2047: break\\n            \\n        return isPrime \\n    \\n    # O(N^1/4), find larger factor\\n    def pollard_rho(self, num, a = 1):\\n        x = 2; y = 2; d = 1\\n        # pseudorandom func.\\n        g = lambda x: (x*x + a) % num\\n\\n        while d == 1:\\n            x = g(x); y = g(g(y))\\n            d = gcd(x-y, num)\\n\\n        # if factor is composite, factorize again by another parameter(rare case)\\n        if self.miller_rabin_test(d): return d\\n        else: return self.pollard_rho(d, a + 1)  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution: # best 16 ms\\n    def consecutiveNumbersSum(self, N):\\n        res = 1; factor = 3\\n        # extract factor of 2^n\\n        while not N & 1: N >>= 1\\n        \\n        while factor * factor <= N:\\n            count = 0\\n\\t\\t\\t# avoid edge case and use strong algorithm\\n\\t\\t\\t# this setting is because we can\\'t expect to iterate so many times to find a big prime,\\n\\t\\t\\t# like 999999937(need (999999937^0.5) / 2 times vs miller_rabin_test\\'s 11 times)\\n            if factor > 50 and N > 10**5: \\n                if self.miller_rabin_test(N): break # O(k*logN)\\n                else: factor = self.pollard_rho(N) # O(N^1/4)\\n            while not N % factor:\\n                N //= factor\\n                count += 1\\n            res *= count + 1\\n            factor += 2\\n\\n        return res if N == 1 else res * 2\\n    \\n    # O(k*logN), k: num of bases, primality test\\n    def miller_rabin_test(self, num):\\n\\t    # helper func. for faster b^e % m \\n        def fast_modular_exp(base, exponent, modulo):\\n            ans = 1\\n            while exponent:\\n                if exponent & 1:\\n                    ans = (ans * base) % modulo\\n                exponent >>= 1\\n                base = (base * base) % modulo\\n            return ans\\n\\n        # current test setting definitely\\n        # works only in num < 4,759,123,141 (almost 2.007**32)\\n        bases = [2, 7, 61]; isPrime = True\\n        \\n        m = n = num - 1; s = 0\\n\\t\\t# extract m * 2 ^ s, make m odd\\n        while not m & 1: m >>= 1; s += 1 # O(logN)\\n        \\n        for b in bases:\\n            # O(logN), pow() is efficient only when m < 1000\\n            if m < 1000: remainder = pow(b, m) % num\\n            else: remainder = fast_modular_exp(b, m, num)\\n\\t\\t\\t\\n            # if pass test of current base, change base\\n\\t\\t\\t# if pass all bases, num is a prime\\n            if remainder == 1 or remainder == n: continue\\n\\t\\t\\t# O(k*logN), k is dependent on test\\'s need\\n            for i in range(1, s+1): \\n                if i == s: isPrime = False; break\\n                remainder = remainder **2 % num\\n                if remainder == 1: isPrime = False; break\\n                if remainder == n: break\\n            if not isPrime or num < 2047: break\\n            \\n        return isPrime \\n    \\n    # O(N^1/4), find larger factor\\n    def pollard_rho(self, num, a = 1):\\n        x = 2; y = 2; d = 1\\n        # pseudorandom func.\\n        g = lambda x: (x*x + a) % num\\n\\n        while d == 1:\\n            x = g(x); y = g(g(y))\\n            d = gcd(x-y, num)\\n\\n        # if factor is composite, factorize again by another parameter(rare case)\\n        if self.miller_rabin_test(d): return d\\n        else: return self.pollard_rho(d, a + 1)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 774877,
                "title": "c-easy-to-understand-math-with-explination",
                "content": "Longest consecutive sum possible for the given number is (sqrt(1+8*num)-1)/2.  ->1\\ni.e.\\nsum of first n numbers is (n*(n+1))/2.    ->2\\nso longest consecutive sum is : 1+2+3+...+n=num; ->3\\nfrom 3 and 2 we can derive 1.\\n\\nNow lets see how can we come up with Consecutive Numbers sum\\n\\n2 Consecutive numbers sum is *x+(x+1)=>2x+1*\\n3 Consecutive numbers sum is *(x-1)+x+(x+1)=>3x*\\n4 Consecutive numbers sum is* (x-1)+x+(x+1)+(x+2)=>4x+2*\\n5 Consecutive numbers sum is *(x-2)+(x-1)+x+(x+1)+(x-2)=>5x*\\n6 Consecutive numbers sum is *(x-2)+(x-1)+x+(x+1)+(x-2)+(x+3)=>6x+3*\\n\\nfrom above 5 equations we can infer that \\nn Consecutive numbers sum is *(nx+(n/2))==num if n is even and (nx)==num if n is odd*.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxnum (long num){\\n\\t    return (int)((sqrt(1+(8*num))-1)/2);\\n    }\\n    int consecutiveNumbersSum(int num) {\\n        int maxConsec=maxnum(num);\\n        int res=0;\\n        for(int i=2;i<=maxConsec;i++){\\n            if(i%2==1&&num%i==0){res++;}\\n            else if(i%2==0&&num%i==i/2){res++;}\\n        }\\n        return res+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxnum (long num){\\n\\t    return (int)((sqrt(1+(8*num))-1)/2);\\n    }\\n    int consecutiveNumbersSum(int num) {\\n        int maxConsec=maxnum(num);\\n        int res=0;\\n        for(int i=2;i<=maxConsec;i++){\\n            if(i%2==1&&num%i==0){res++;}\\n            else if(i%2==0&&num%i==i/2){res++;}\\n        }\\n        return res+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747191,
                "title": "very-simple-java-94-faster-solution",
                "content": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int ans=0;\\n        int n = 1;\\n        int temp = N;\\n        while(temp>0){\\n            if(temp%(n)==0) ans++;\\n            temp-=n;\\n            n++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int ans=0;\\n        int n = 1;\\n        int temp = N;\\n        while(temp>0){\\n            if(temp%(n)==0) ans++;\\n            temp-=n;\\n            n++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305451,
                "title": "c-4ms-solution-with-a-clear-explanation",
                "content": "```\\nint consecutiveNumbersSum(int N) {\\n\\tint ret = 0; \\n\\tfor(int n = 1; n*(n+1)/2 <= N; n++){// n -> number of consecutive numbers\\n\\t\\tif((N-n*(n+1)/2)%n==0) ret++;\\n\\t}\\n\\treturn ret;\\n}\\n```\\nI found a good explanation on youtube [](https://www.youtube.com/watch?v=oKOCYZd4m7E)starting at 7:40. Would like to share it.",
                "solutionTags": [],
                "code": "```\\nint consecutiveNumbersSum(int N) {\\n\\tint ret = 0; \\n\\tfor(int n = 1; n*(n+1)/2 <= N; n++){// n -> number of consecutive numbers\\n\\t\\tif((N-n*(n+1)/2)%n==0) ret++;\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128946,
                "title": "short-math-solution-with-explanation",
                "content": "The goal is to looking for the number of arithmetic sequences whos summation is *N*. Let the starting number of a sequence be *i* and the length of the sequence be *n*. From the summation equation, we know \\n```\\n(i+i+n-1)*n/2 = N  (1)\\n```\\nrearrange the equation we obtaion\\n```\\ni = (2*N-n(n-1))/(2*n) (2) \\n```\\nIf there exist such i, the denominator should satisfy\\n```\\n0=<2*N-n(n-1) <=2*N-n*n\\n```\\nTherefore, the length of the sequence cannot exceed sqrt(2*N)\\nFrom equation (2), we know i must be a interger, so when (2*N-n(n-1))%(2*n) == 0, the i satisfies the requirement. The code is simple \\n\\n```\\n    public int consecutiveNumbersSum(int N) {\\n        int count = 0;\\n        for (int i = 1; i <= (int)Math.sqrt(2*N); i++) {\\n        \\tif ((2*N-i*(i-1)) % (2*i) == 0) count++;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n(i+i+n-1)*n/2 = N  (1)\\n```\n```\\ni = (2*N-n(n-1))/(2*n) (2) \\n```\n```\\n0=<2*N-n(n-1) <=2*N-n*n\\n```\n```\\n    public int consecutiveNumbersSum(int N) {\\n        int count = 0;\\n        for (int i = 1; i <= (int)Math.sqrt(2*N); i++) {\\n        \\tif ((2*N-i*(i-1)) % (2*i) == 0) count++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569393,
                "title": "best-easy-and-simple-approach-math-formula-based",
                "content": "class Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        c=0\\n        k=1        \\n        while((2*n)>(k*(k-1))):\\n            numerator=n-(k*(k-1)/2)\\n            if numerator%k==0:\\n                c+=1\\n            k+=1\\n        return c",
                "solutionTags": [],
                "code": "class Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        c=0\\n        k=1        \\n        while((2*n)>(k*(k-1))):\\n            numerator=n-(k*(k-1)/2)\\n            if numerator%k==0:\\n                c+=1\\n            k+=1\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 2301692,
                "title": "python3-solution-two-approaches-with-detailed-explanation",
                "content": "***Please upvote if you found this helpful!***\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        \\n    # First solution \\n    # representing N as sum of k consecutive integers with starting value as a\\n    # N = a + (a+1) + (a+2) + ....... + (a+k) \\n    # N = (k*a) + (1+2+3+....+k)\\n    # N = k*a + k*(k+1)/2\\n    # Hence, a = ( N - k*(k+1)/2 ) / k\\n    \\n    # DRY RUN:\\n    # 15 = 1 + 2 + 3 + 4 + 5 ; k = 5\\n    # 15 = 1 + (1+1) + (1+2) + (1+3) + (1+4)\\n    # 15 = 5*1 + 5*(5-1)/2 = 5 + 10 = 15\\n    \\n        k = 1\\n        count = 0\\n        while (k*(k+1)//2)<=n:\\n            sum_until_k = k*(k+1)//2\\n            if ( n - sum_until_k ) % k == 0:\\n                count += 1\\n            k += 1\\n        return count\\n    \\n    # Observation 2:\\n    # 15 = 4 + 5 + 6 ; k = 3 ; start = 4 (seq. starts at 4)\\n    # 15 = (3+1) + (3+2) + (3+3)\\n    # 15 = 3 + 3 + 3 + 1 + 2 + 3\\n    # 15 - 1 - 2 - 3 = 3 + 3 + 3\\n    # 15 - (start-3) - (start-2) - (start-1) = k*(start-1)\\n    # Hence for a base/start = 3 if LHS is divisible by base\\n    # then it means we formed a consecutive sequence.\\n    # eg: 15 = 1 + 2 + 3 + 4 + 5 \\n    # so if 15 - 1  = 2 + 3 + 4 + 5 = 1*4 + 1*(1+2+3)\\n    # so at each step if num - start is divisble by start\\n    # then that start forms a sequence.\\n    \\n        count = 0\\n        start = 1\\n        while n > 0:\\n            n -= start\\n            if n%start == 0:\\n                count += 1\\n            start += 1\\n        return count \\n```\\n    \\n            \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        \\n    # First solution \\n    # representing N as sum of k consecutive integers with starting value as a\\n    # N = a + (a+1) + (a+2) + ....... + (a+k) \\n    # N = (k*a) + (1+2+3+....+k)\\n    # N = k*a + k*(k+1)/2\\n    # Hence, a = ( N - k*(k+1)/2 ) / k\\n    \\n    # DRY RUN:\\n    # 15 = 1 + 2 + 3 + 4 + 5 ; k = 5\\n    # 15 = 1 + (1+1) + (1+2) + (1+3) + (1+4)\\n    # 15 = 5*1 + 5*(5-1)/2 = 5 + 10 = 15\\n    \\n        k = 1\\n        count = 0\\n        while (k*(k+1)//2)<=n:\\n            sum_until_k = k*(k+1)//2\\n            if ( n - sum_until_k ) % k == 0:\\n                count += 1\\n            k += 1\\n        return count\\n    \\n    # Observation 2:\\n    # 15 = 4 + 5 + 6 ; k = 3 ; start = 4 (seq. starts at 4)\\n    # 15 = (3+1) + (3+2) + (3+3)\\n    # 15 = 3 + 3 + 3 + 1 + 2 + 3\\n    # 15 - 1 - 2 - 3 = 3 + 3 + 3\\n    # 15 - (start-3) - (start-2) - (start-1) = k*(start-1)\\n    # Hence for a base/start = 3 if LHS is divisible by base\\n    # then it means we formed a consecutive sequence.\\n    # eg: 15 = 1 + 2 + 3 + 4 + 5 \\n    # so if 15 - 1  = 2 + 3 + 4 + 5 = 1*4 + 1*(1+2+3)\\n    # so at each step if num - start is divisble by start\\n    # then that start forms a sequence.\\n    \\n        count = 0\\n        start = 1\\n        while n > 0:\\n            n -= start\\n            if n%start == 0:\\n                count += 1\\n            start += 1\\n        return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767911,
                "title": "python-simple-6-lines-solution",
                "content": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        ans, sumNum, cnt = 1, 1, 2\\n        while sumNum < n:\\n            if sumNum % cnt == n % cnt: ans += 1\\n            sumNum += cnt\\n            cnt += 1\\n        return ans\\n```\\n\\nThe point of this problem is, it should be divided into **consecutive** numbers. \\n\\nLet\\'s think about dividing the number 15. \\n\\nIf we want to break 15 down to three consecutive numbers, it should be like **m / m + 1 / m + 2**(or m - 1 / m / m + 1, or m - 2 / m - 1 / m), which is **4 / 5 / 6** and m is 4 in this case.\\n\\nIf it\\'s divided into five chunks, it should be like **m / m + 1 /m + 2 / m + 3 / m + 4**, which will be **1 / 2 / 3 / 4 / 5** and m is 1.\\n\\nSo we can say the number n can be expressed as **k*m + Sum{0~(k-1)}** if the number n is split into k pieces.\\n\\nNow, all we have to do is to see if the result of **Sum{0~(k-1)} % k is equal to n % k** because if they have the same remainders, it means we can successfully split n into k consecutive numbers.\\n\\nIn my code, sumNum is the result of Sum{0~(k-1)} and cnt is the k number and also the next number to be added to sumNum at the same time. Running though the loop, the code checks the value of remainders and keeps adding numbers to sumNum and cnt.\\n\\nThe loop ends when sumNum is equal or bigger than the number n because the sum of remainders shouldn\\'t be bigger than n.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        ans, sumNum, cnt = 1, 1, 2\\n        while sumNum < n:\\n            if sumNum % cnt == n % cnt: ans += 1\\n            sumNum += cnt\\n            cnt += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682388,
                "title": "easy-java-solution-with-explanation",
                "content": "\\nhere i denotes no. of consecutive numbers starting from 1  (e.g.  i = 4 --> 1+2+3+4)\\n(i*(i+1)/2) will give sum of i consecutive numbers starting from 1...\\nif the remaining number(n-(i*(i+1)/2)) is a multiple of i then we increase count by 1 ...\\nbecause if we add the result obtained by [(n - (i*(i+1)/2)) / i] to all consecutive digits starting from 1...then the total sum will be equal to given n\\n\\nfor e.g. ......\\nif n = 9\\nfor i = 1 ( 1 consecutive digit ) :- (n-(i*(i+1)/2)) = 8 and 8%1 = 0 so.. {1+(8/1)} = 9\\n\\nfor i = 2 ( 2 consecutive digits ):- (n-(i*(i+1)/2)) = 6 and 6%2 = 0 so.. {1+(6/2)}+{2+(6/2)} = 4+5 = 9\\n\\nfor i = 3 ( 3 consecutive digits ):- (n-(i*(i+1)/2)) = 3 and 3%3 = 0 so.. {1+(3/3)}+{2+(3/3)}{3+(3/3)} = 2+3+4 = 9\\n\\nfor i = 4( 1 consecutive digits )....for loop wiil exit\\n\\n\\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int n) {\\n        int count = 0;\\n        for(int i = 1; i*(i+1)/2<=n; i++){\\n            if((n-(i*(i+1)/2))%i==0) count++;\\n        }\\n        return count;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int n) {\\n        int count = 0;\\n        for(int i = 1; i*(i+1)/2<=n; i++){\\n            if((n-(i*(i+1)/2))%i==0) count++;\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229393,
                "title": "c-solution-with-explanation",
                "content": "```\\n    /*\\n     * Solution is to find the Consecutive positive integers that sums\\n     * up to n ie..,\\n     *   a, a + 1, a + 2, ......\\n     *\\n     * The summation of above numbers should be equal to n\\n     *\\n     *  a + a + 1 + a + 2 + ....... + a + k-1  = n\\n     * => a + a + .... + 1 + 2 + 3 + .... + k - 1 = n\\n     *\\n     * From above it is seen that, a + a + ....  = ka\\n     * the 2nd half 1 + 2 + 3 + .... k - 1, sum of first k natural numbers is\\n     *    k(k + 1) / 2  but it needs till k - 1 => (k - 1) * (k - 1 + 1) / 2\\n     *  => k(k - 1) / 2\\n     *\\n     * so equation a + a + .... + 1 + 2 .... + k - 1 = n\\n     *        =>  ka + k(k - 1) / 2 = n, solution is to find a\\n     *    as only positive integers are needed, k = 1... x(will find it)\\n     *\\n     *       => ka = n - k(k - 1) / 2\\n     *       => a = (n - k(k - 1)/2) % k where k = 1 ..... x (x needs to be find)\\n     *\\n     * So we need to evaluate above equation to find a for different values of k\\n     *\\n     * As a is +ve integers   n - k(k-1)/2 > 0\\n     *                     => n > k(k - 1) /2\\n     *                     => k(k - 1) < 2n\\n     *                     => k^2 < 2n\\n     * so loop will travers from  k = 1 ....... sqrt(2n)\\n     *\\n     * For eg: n = 5  \\n     *      a = (n - k(k - 1) / 2) % k  k = 1 , 2, 3 as k * k < 2n\\n     *    k = 1 => a = (5 - 1 * (1 - 1) / 2) % 1 = 5\\n     *    k = 2 => a = (5 - 2 * (2 - 1) / 2) % 2 = 0\\n    */\\n    int consecutiveNumbersSum(int n) {\\n        // variable to store the num ways that the n can be generated\\n        // When k = 1 it evaluates to n, so it is a way.\\n        int numWays = 1;\\n        \\n        // Travers the loop for every k value from 2 ... k * k < 2n\\n        for (int k = 2; k * k < (n << 1); k++) {\\n            // Evaluate the expression for the current value of k\\n            // and check if result is zero\\n            if ((n - k * (k - 1) / 2) % k == 0 ) {\\n                // we have a solution , increment the way.\\n                numWays++;\\n            }           \\n        }\\n        \\n        return numWays;        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * Solution is to find the Consecutive positive integers that sums\\n     * up to n ie..,\\n     *   a, a + 1, a + 2, ......\\n     *\\n     * The summation of above numbers should be equal to n\\n     *\\n     *  a + a + 1 + a + 2 + ....... + a + k-1  = n\\n     * => a + a + .... + 1 + 2 + 3 + .... + k - 1 = n\\n     *\\n     * From above it is seen that, a + a + ....  = ka\\n     * the 2nd half 1 + 2 + 3 + .... k - 1, sum of first k natural numbers is\\n     *    k(k + 1) / 2  but it needs till k - 1 => (k - 1) * (k - 1 + 1) / 2\\n     *  => k(k - 1) / 2\\n     *\\n     * so equation a + a + .... + 1 + 2 .... + k - 1 = n\\n     *        =>  ka + k(k - 1) / 2 = n, solution is to find a\\n     *    as only positive integers are needed, k = 1... x(will find it)\\n     *\\n     *       => ka = n - k(k - 1) / 2\\n     *       => a = (n - k(k - 1)/2) % k where k = 1 ..... x (x needs to be find)\\n     *\\n     * So we need to evaluate above equation to find a for different values of k\\n     *\\n     * As a is +ve integers   n - k(k-1)/2 > 0\\n     *                     => n > k(k - 1) /2\\n     *                     => k(k - 1) < 2n\\n     *                     => k^2 < 2n\\n     * so loop will travers from  k = 1 ....... sqrt(2n)\\n     *\\n     * For eg: n = 5  \\n     *      a = (n - k(k - 1) / 2) % k  k = 1 , 2, 3 as k * k < 2n\\n     *    k = 1 => a = (5 - 1 * (1 - 1) / 2) % 1 = 5\\n     *    k = 2 => a = (5 - 2 * (2 - 1) / 2) % 2 = 0\\n    */\\n    int consecutiveNumbersSum(int n) {\\n        // variable to store the num ways that the n can be generated\\n        // When k = 1 it evaluates to n, so it is a way.\\n        int numWays = 1;\\n        \\n        // Travers the loop for every k value from 2 ... k * k < 2n\\n        for (int k = 2; k * k < (n << 1); k++) {\\n            // Evaluate the expression for the current value of k\\n            // and check if result is zero\\n            if ((n - k * (k - 1) / 2) % k == 0 ) {\\n                // we have a solution , increment the way.\\n                numWays++;\\n            }           \\n        }\\n        \\n        return numWays;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1136982,
                "title": "logical-sliding-window-approach-python-3-linear",
                "content": "I tried this question for 30 minutes and came up sliding window O(n) solution. I was thinking why this question is labelled as hard considering the below code, but then of course when I saw the solution, I realized. First of all its really sad to ask such questions in interview. I mean it is just evil math.\\n\\nAnyways, sharing my logical solution which will work in O(n), but as expected gives a TLE while submitting. I am pretty sure this is the best I could have come up during the interview.\\n\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        start = 1\\n        end = 1\\n        \\n        curr = 0\\n        res = 0\\n        \\n        while end <= n:\\n            curr += end\\n            while curr >= n:\\n                if curr == n:\\n                    res += 1\\n                curr -= start\\n\\n                start += 1\\n            \\n            end += 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        start = 1\\n        end = 1\\n        \\n        curr = 0\\n        res = 0\\n        \\n        while end <= n:\\n            curr += end\\n            while curr >= n:\\n                if curr == n:\\n                    res += 1\\n                curr -= start\\n\\n                start += 1\\n            \\n            end += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994601,
                "title": "python3-6-lines-o-sqrt-n-solution-with-simple-math",
                "content": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        \\'\\'\\'\\n\\t\\tlet a be the starting number and k be the number of terms\\n        a + (a + 1) + ... (a + k - 1) = N\\n        (2a + k - 1) * k / 2 = N\\n\\t\\tSince (k + 2a - 1) * k = 2N, k < sqrt(2N)\\n        On the other hand, the above equation can be turned into ak + k(k-1)/2 \\n        k(k-1)/2 is basically the sum of 1 to k-1. \\n\\t\\tIf we iterate all the way up to sqrt(2N), we could do the sum along the way. \\n\\t\\tAs long as (N - sum) can be devided by k, that\\'s one count. \\n        \\'\\'\\'\\n        sum_term = 0\\n        count = 0\\n        for i in range(int((2 * N) ** 0.5)):\\n            sum_term += i\\n            if (N - sum_term) % (i + 1) == 0:\\n                count += 1\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        \\'\\'\\'\\n\\t\\tlet a be the starting number and k be the number of terms\\n        a + (a + 1) + ... (a + k - 1) = N\\n        (2a + k - 1) * k / 2 = N\\n\\t\\tSince (k + 2a - 1) * k = 2N, k < sqrt(2N)\\n        On the other hand, the above equation can be turned into ak + k(k-1)/2 \\n        k(k-1)/2 is basically the sum of 1 to k-1. \\n\\t\\tIf we iterate all the way up to sqrt(2N), we could do the sum along the way. \\n\\t\\tAs long as (N - sum) can be devided by k, that\\'s one count. \\n        \\'\\'\\'\\n        sum_term = 0\\n        count = 0\\n        for i in range(int((2 * N) ** 0.5)):\\n            sum_term += i\\n            if (N - sum_term) % (i + 1) == 0:\\n                count += 1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993511,
                "title": "java-solution-with-explanation",
                "content": "```\\n    public int consecutiveNumbersSum(int N) {\\n        /**\\n         * Here we are to find number of combinations where sum is N and numbers summing are consecutive\\n         * Sum of consecutive number starting from 1 is given by\\n         * 1 + 2 + 3 + 4 ...k = k*(k+1)/2\\n         *\\n         * Now if number starts from x then it becomes\\n         * (x+1) + (x+2) + (x+3) ...(x+k) = kx + (k*(k+1)/2) = N\\n         * N = kx + (k*(k+1)/2)\\n         * N - (k*(k+1)/2) = kx - Equation A If this condition is satisfied then we know that there is a combination of consecutive +ve integers\\n         * x has to be +ve and so should be k. Hence, kx should be > 0\\n         * N - (k*(k+1)/2) >= 0\\n         * N >= (k*(k+1)/2)\\n         * 2N >= k^2 + k\\n         * 2N -k >= k^2 ignoring -k  as it will only reduce some of the iterations for k. Instead, we ignore at expense of more k iterations\\n         * Hence, k should be sqrt(2N).\\n         * That means we need to try to find if x satisfies Equation A by iterating k from 2 till sqrt(2N)\\n         */\\n        int count = 1; // for single element N\\n        for(int k=2; k< Math.sqrt(2*N); k++) {\\n            int exp = (N - ((k*(k+1))/2)); // Equation A\\n            if(exp>=0 && exp%k == 0)  count++;\\n        }\\n     \\n```",
                "solutionTags": [],
                "code": "```\\n    public int consecutiveNumbersSum(int N) {\\n        /**\\n         * Here we are to find number of combinations where sum is N and numbers summing are consecutive\\n         * Sum of consecutive number starting from 1 is given by\\n         * 1 + 2 + 3 + 4 ...k = k*(k+1)/2\\n         *\\n         * Now if number starts from x then it becomes\\n         * (x+1) + (x+2) + (x+3) ...(x+k) = kx + (k*(k+1)/2) = N\\n         * N = kx + (k*(k+1)/2)\\n         * N - (k*(k+1)/2) = kx - Equation A If this condition is satisfied then we know that there is a combination of consecutive +ve integers\\n         * x has to be +ve and so should be k. Hence, kx should be > 0\\n         * N - (k*(k+1)/2) >= 0\\n         * N >= (k*(k+1)/2)\\n         * 2N >= k^2 + k\\n         * 2N -k >= k^2 ignoring -k  as it will only reduce some of the iterations for k. Instead, we ignore at expense of more k iterations\\n         * Hence, k should be sqrt(2N).\\n         * That means we need to try to find if x satisfies Equation A by iterating k from 2 till sqrt(2N)\\n         */\\n        int count = 1; // for single element N\\n        for(int k=2; k< Math.sqrt(2*N); k++) {\\n            int exp = (N - ((k*(k+1))/2)); // Equation A\\n            if(exp>=0 && exp%k == 0)  count++;\\n        }\\n     \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 814842,
                "title": "java-absolutely-no-math-i-promise-pure-binary-search",
                "content": "I kind of suck at math, so I never find or use mathematical solutions unless I know them in advance. So here\\'s my solution based on intuition - binary search:\\n\\n1. Find `maxLen`, where subsequence of consequtive integers of this length could potentially sum up to `target`\\n2. For each possible subsequence length starting from `1` to  `maxLen`:\\n\\t* binary search for the mid\\n\\t* try expand subsequence in both sides around mid and find the sum\\n\\t* if the sum is too high, decrease mid. If too low, increase it. If matches - we\\'ve found answer for this length, add `1` to result and continue to the next length.\\n\\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        if (N == 1) return 1;\\n        \\n        int res = 0;\\n        int currLen = 1;\\n        //binary search for the maximum possible length\\n        int maxLen = findMaxLen(N);\\n        while (currLen <= maxLen) {\\n            int left = 1, right = N;\\n            while (left <= right) {\\n                int mid = left + (right-left)/2;\\n                //binary search for the sequence of given length which sums to N\\n                long answ = tryAround(mid, currLen, N);\\n                if (answ == N) {\\n                    res++;\\n                    break;\\n                } else if (answ < N) {\\n                    left = mid+1;\\n                } else {\\n                    right = mid-1;\\n                }\\n            }\\n            currLen++;\\n        }\\n        return res;\\n    }\\n    \\n    private int findMaxLen(int N) {\\n        int left = 1, right = N;\\n        while (left < right) {\\n            int mid = left + (right-left)/2;\\n\\t\\t\\t// arithmetic progression sum - (first + last) * len / 2\\n            if ((1L+mid)* mid / 2 > N) {\\n                right = mid;\\n            } else {\\n                left = mid+1;\\n            }\\n        }\\n        return left-1;\\n    }\\n    \\n    long tryAround(int num, int len, int to) {\\n        long min = min(num, len), max = max(num, len);\\n        if (min <= 0) {\\n            return Integer.MIN_VALUE;\\n        } else if (max > to) {\\n            return Integer.MAX_VALUE;\\n        }\\n\\t\\t// arithmetic progression sum - (first + last) * len / 2\\n        return (min+max)* len / 2;    \\n    }\\n    \\n    int min(int num, int len) {\\n        if ((len % 2) == 1) {\\n            return num-(len/2);\\n        } else {\\n            return num-(len/2)+1;\\n        }\\n    }\\n    \\n    int max(int num, int len) {\\n        return num+(len/2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        if (N == 1) return 1;\\n        \\n        int res = 0;\\n        int currLen = 1;\\n        //binary search for the maximum possible length\\n        int maxLen = findMaxLen(N);\\n        while (currLen <= maxLen) {\\n            int left = 1, right = N;\\n            while (left <= right) {\\n                int mid = left + (right-left)/2;\\n                //binary search for the sequence of given length which sums to N\\n                long answ = tryAround(mid, currLen, N);\\n                if (answ == N) {\\n                    res++;\\n                    break;\\n                } else if (answ < N) {\\n                    left = mid+1;\\n                } else {\\n                    right = mid-1;\\n                }\\n            }\\n            currLen++;\\n        }\\n        return res;\\n    }\\n    \\n    private int findMaxLen(int N) {\\n        int left = 1, right = N;\\n        while (left < right) {\\n            int mid = left + (right-left)/2;\\n\\t\\t\\t// arithmetic progression sum - (first + last) * len / 2\\n            if ((1L+mid)* mid / 2 > N) {\\n                right = mid;\\n            } else {\\n                left = mid+1;\\n            }\\n        }\\n        return left-1;\\n    }\\n    \\n    long tryAround(int num, int len, int to) {\\n        long min = min(num, len), max = max(num, len);\\n        if (min <= 0) {\\n            return Integer.MIN_VALUE;\\n        } else if (max > to) {\\n            return Integer.MAX_VALUE;\\n        }\\n\\t\\t// arithmetic progression sum - (first + last) * len / 2\\n        return (min+max)* len / 2;    \\n    }\\n    \\n    int min(int num, int len) {\\n        if ((len % 2) == 1) {\\n            return num-(len/2);\\n        } else {\\n            return num-(len/2)+1;\\n        }\\n    }\\n    \\n    int max(int num, int len) {\\n        return num+(len/2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760518,
                "title": "o-n-iterative-solution-with-detailed-explanation",
                "content": "Explanaition:-\\n\\nLet us consider **k length sequence** of consecutive numbers whose **sum = N** and starting point is **x**\\n\\n   ```\\n(x+0) + (x+1) + ........... + (x+(k-1)) = N\\n   => kx + (k) * (k-1)/2 = N\\n   => x = ( N - (k) * (k-1)/2 ) / k \\n```\\n\\t\\n```\\nso for x to be a positive integer\\n(N-((k)(k-1))/2)%k==0\\nAnd, N > (k) * (k-1) /2  ==> k*(k-1)<2*N\\n```\\n\\n\\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        \\n        int c = 1;\\n        for(int k=2;k<=Math.sqrt(2*N);k++){\\n            if((N-((k)*(k-1))/2)%k==0)\\n                c++;\\n        }\\n        \\n        return c;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n(x+0) + (x+1) + ........... + (x+(k-1)) = N\\n   => kx + (k) * (k-1)/2 = N\\n   => x = ( N - (k) * (k-1)/2 ) / k \\n```\n```\\nso for x to be a positive integer\\n(N-((k)(k-1))/2)%k==0\\nAnd, N > (k) * (k-1) /2  ==> k*(k-1)<2*N\\n```\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        \\n        int c = 1;\\n        for(int k=2;k<=Math.sqrt(2*N);k++){\\n            if((N-((k)*(k-1))/2)%k==0)\\n                c++;\\n        }\\n        \\n        return c;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670684,
                "title": "short-easy-with-comments-python-time-o-sqrt-n",
                "content": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n                \\n        k = 1\\n        current = N - ((k + 1) * k) // 2\\n        res = 0\\n        \\n        while current >= 0:\\n            if current % k == 0:      # because current = kx, kx % x is to check if exists an x, make kx == N - ((k + 1) * k) // 2\\n                res += 1\\n            k += 1\\n            current = N - ((k + 1) * k) // 2   # k increased by 1, current needs to be reassigned.\\n        \\n        return res\\n    \\n        # We are looking for (x + 1) + (x + 2) + .... (x + k) = N\\n        # The equation can be resolved to kx + k(k -1) // 2 = N    \\n        # Then kx = N - k(k - 1) // 2\\n\\t\\t\\n\\t\\t# Test case:\\n        # N = 9\\n        # k = 1, x = 8, (8 + 1) = 9\\n        # k = 2, x = 3, (3 + 1) + (3 + 2) = 9\\n        # k = 3, x = 1, (1 + 1) + (1 + 2) + (1 + 3)= 9\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n                \\n        k = 1\\n        current = N - ((k + 1) * k) // 2\\n        res = 0\\n        \\n        while current >= 0:\\n            if current % k == 0:      # because current = kx, kx % x is to check if exists an x, make kx == N - ((k + 1) * k) // 2\\n                res += 1\\n            k += 1\\n            current = N - ((k + 1) * k) // 2   # k increased by 1, current needs to be reassigned.\\n        \\n        return res\\n    \\n        # We are looking for (x + 1) + (x + 2) + .... (x + k) = N\\n        # The equation can be resolved to kx + k(k -1) // 2 = N    \\n        # Then kx = N - k(k - 1) // 2\\n\\t\\t\\n\\t\\t# Test case:\\n        # N = 9\\n        # k = 1, x = 8, (8 + 1) = 9\\n        # k = 2, x = 3, (3 + 1) + (3 + 2) = 9\\n        # k = 3, x = 1, (1 + 1) + (1 + 2) + (1 + 3)= 9\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533630,
                "title": "python",
                "content": "had there been is a sequence of\\n1. (k+1) consecutive numbers \\n2. summing up to n\\n3. starting at i \\n\\nthese guys \\n```\\ni , i+1, i+2, ..., i +k  \\n```\\n\\nsum up to n\\n```\\ni + (i+1) + (i+2) + ... (i+k) = n\\n```\\ngrouping the i\\'s\\n```\\ni + ik + 1 + 2 + ... + k = n\\n```\\ncomputing the sum 1 + 2 + 3 + ... + k\\n```\\ni (k + 1)  + k ( k +1 )/2 = n\\n```\\nthen isolating i (k + 1)\\n```\\ni ( k + 1) = n -  k ( k + 1) /2\\n```\\nto have that condition\\n```\\nn -  k ( k + 1 ) / 2  % ( k + 1) ==0\\n```\\nit ll allow us to ditch k relatively quickly (n == 10 ^ 9 at most, we have n ^ 0.5 checks at most about 30 000)\\n\\ntrying all k till I exceed n \\n\\n```\\nclass Solution(object):\\n    def consecutiveNumbersSum(self, n):\\n        # calvin klein\\n        c,k = 0,0\\n        while( k * (k+1) / 2 < n):\\n            r = n- k * (k + 1) / 2\\n            if  r % (k+1) == 0: c+=1\\n            k +=1\\n            \\n        return c\\n    \\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ni , i+1, i+2, ..., i +k  \\n```\n```\\ni + (i+1) + (i+2) + ... (i+k) = n\\n```\n```\\ni + ik + 1 + 2 + ... + k = n\\n```\n```\\ni (k + 1)  + k ( k +1 )/2 = n\\n```\n```\\ni ( k + 1) = n -  k ( k + 1) /2\\n```\n```\\nn -  k ( k + 1 ) / 2  % ( k + 1) ==0\\n```\n```\\nclass Solution(object):\\n    def consecutiveNumbersSum(self, n):\\n        # calvin klein\\n        c,k = 0,0\\n        while( k * (k+1) / 2 < n):\\n            r = n- k * (k + 1) / 2\\n            if  r % (k+1) == 0: c+=1\\n            k +=1\\n            \\n        return c\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 413107,
                "title": "easiest-hard-problem-on-leetcode",
                "content": "I feel like this is the easiest hard question so far, although I just solved a small amount of questions on LeetCode.\\nAnyone can find an easier hard problem can post in comment?\\n\\nThis is my solution anyway\\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int count = 0;\\n        for (int i = 1; (double)(N)/i > i/2.0; i++) {\\n            if (i % 2 == 1 && N % i == 0) count++;\\n            else if (i % 2 == 0 && N % i == i/2) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int count = 0;\\n        for (int i = 1; (double)(N)/i > i/2.0; i++) {\\n            if (i % 2 == 1 && N % i == 0) count++;\\n            else if (i % 2 == 0 && N % i == i/2) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309070,
                "title": "javascript-solution-no-math-identity-bs-beats-95",
                "content": "You know what? Screw math! Let\\'s just try all valid configurations of n-consecutive numbers!\\n\\n```\\nfunction consecutiveNumbersSum(N) {\\n  let solutionCount = 0;\\n  let consecutiveNumberCount = 1;\\n  while (true) {\\n    const mid = Math.ceil(N / consecutiveNumberCount);           // Get middle number of sequence containing X numbers\\n    const countToLeft = Math.floor(consecutiveNumberCount / 2);  // Get count of how many numbers are to the left of mid \\n    const leftMostN = mid - countToLeft;                         // Get left-most number in the sequence \\n    if (leftMostN < 1) break;                                    // Break if the left-most number is out of bounds\\n    let sum = mid * consecutiveNumberCount;                      // Calculate the sequence sum\\n    if (consecutiveNumberCount % 2 === 0) sum -= countToLeft;    // Adjust the sum if it contains an even # of numbers \\n    if (sum === N) solutionCount += 1;                           // Count solutions\\n    consecutiveNumberCount += 1;                                 // Try next sequence length\\n  }\\n  return solutionCount; // YEEEAAH! TRY ALL THE THINGS!\\n}\\n```\\n\\nI got beats 95%, which is pretty damn good for not doing any real math work. Just incremental improvements on a simple idea.",
                "solutionTags": [],
                "code": "```\\nfunction consecutiveNumbersSum(N) {\\n  let solutionCount = 0;\\n  let consecutiveNumberCount = 1;\\n  while (true) {\\n    const mid = Math.ceil(N / consecutiveNumberCount);           // Get middle number of sequence containing X numbers\\n    const countToLeft = Math.floor(consecutiveNumberCount / 2);  // Get count of how many numbers are to the left of mid \\n    const leftMostN = mid - countToLeft;                         // Get left-most number in the sequence \\n    if (leftMostN < 1) break;                                    // Break if the left-most number is out of bounds\\n    let sum = mid * consecutiveNumberCount;                      // Calculate the sequence sum\\n    if (consecutiveNumberCount % 2 === 0) sum -= countToLeft;    // Adjust the sum if it contains an even # of numbers \\n    if (sum === N) solutionCount += 1;                           // Count solutions\\n    consecutiveNumberCount += 1;                                 // Try next sequence length\\n  }\\n  return solutionCount; // YEEEAAH! TRY ALL THE THINGS!\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 214130,
                "title": "c-detailed-explanation-5-lines",
                "content": "## Solution 1.\\n\\nThe sum of Arithmetic Progression (AP) is:\\n\\n```\\nS = an + n(n-1)d/2\\n```\\n\\nwhere `a` is the first element, `n` is the count of elements, `d` is the common difference.\\n\\nIn our case, `S = N`, `d = 1` so we have:\\n\\n```\\na = (N - n(n-1)/2) / n\\n```\\n\\nSo we can traverse from `n = 1` to `n = N` to get `a`, but they need to satisfy the following requirements:\\n\\n1. `a = (N - n(n-1)/2) / n >= 1` so `2N - n^2 + n >= 2n`, `n(n+1) <= 2N`. For `n >= 1`, `n(n+1) > n^2` so `n^2 < 2N`, `n < sqrt(2N)`. For `N >= 1`, `n < sqrt(2N)` is the same or tighter than `n <= N`, so we can simply use `n(n+1) <= 2N` as the upper bound.\\n2. The last element `a + n - 1 <= N` so\\n```\\n(N - n(n-1)/2)/n + n - 1 <= N\\n2N - n(n-1) + 2n(n-1) <= 2nN\\nn(n-1) <= 2(n-1)N\\nn = 1 or n <= 2N\\n```\\nThis is useless.\\n\\nIn sum, we traverse from `n = 1` to `n(n+1) <= 2N`, and if `N - n(n-1)/2` can be divided by `n`, we can increment the count.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/consecutive-numbers-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(sqrt(N))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        int ans = 0;\\n        for (int n = 1; n * (n + 1) <= 2 * N; ++n) {\\n            int a = N - n * (n - 1) / 2;\\n            if (a % n == 0) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2.\\n\\nThere are lots of multiplication in Solution 1. Is it possible to reduce them?\\n\\nIf we let `n(n+1)` as `s`. In the previous loop, `s\\' = n(n-1)`, `s - s\\' = 2n`. So we can change the multiplication to addition.\\n\\nNow let `s = n(n+1)/2`, the upper bound of `n` will be `s <= N`. In each step, we do `s += n`. And the `a` can be `N - s + n` now. We can further simply `a % n == 0` to `(N - s) % n == 0` since if `(N - s + n) % n == 0` then `(N - s) % n == 0`\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/consecutive-numbers-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(sqrt(N))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        int ans = 0, n = 1, s = 1;\\n        for (; s <= N; s += ++n) {\\n            if ((N - s) % n == 0) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 3.\\n\\nAssume `N=(x+1)+(x+2)+...+(x+k)`, where `x >= 0`, `k >= 1`.\\n\\nWe have `2N=k(2x+k+1)`, which has two factors, `k` and `2x+k+1`, one of which is odd number and another is even. So the question now is how many ways to factor `2N` into one even and one odd number.\\n\\nAssume `2N=2^t * M`, where `M` is odd. If we factor `M = a * b`, then multiply `2^t` to one of them will yield the even number. So the question now becomes how many ways to factor the odd part of `N`.\\n\\nIf `N = 3*3*3*5*5`, how many ways to factor `N` into two numbers?\\n\\nFor one number, we can pick 0 to 3 `3`s, and 0 to 2 `5`s, so we have 4 * 3 = 12 options.\\n\\nHere you can see the answer is multiplication of `1 + {count of a factor}`.\\n\\nTo get the count, we can start from `d = 3` to `d * d <= N` with increment 2, and try to divide `N` with d to count the occurrance of `d` in `N`. If the count is `c`, we multiply `1 + c` to answer.\\n\\nBut what if there is a factor greater than `sqrt(N)`? In this case it have to be a prime number and there will be only one of it. So if eventually `N > 1`, we multiply `2` to answer.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/consecutive-numbers-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(sqrt(N))\\n// Space: O(1)\\n// Ref: https://leetcode.com/problems/consecutive-numbers-sum/solution/\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        while ((N & 1) == 0) N >>= 1;\\n        int ans = 1, d = 3;\\n        while (d * d <= N) {\\n            int e = 0;\\n            for (; N % d == 0; N /= d, ++e);\\n            ans *= e + 1;\\n            d += 2;\\n        }\\n        if (N > 1) ans <<= 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nS = an + n(n-1)d/2\\n```\n```\\na = (N - n(n-1)/2) / n\\n```\n```\\n(N - n(n-1)/2)/n + n - 1 <= N\\n2N - n(n-1) + 2n(n-1) <= 2nN\\nn(n-1) <= 2(n-1)N\\nn = 1 or n <= 2N\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/consecutive-numbers-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(sqrt(N))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        int ans = 0;\\n        for (int n = 1; n * (n + 1) <= 2 * N; ++n) {\\n            int a = N - n * (n - 1) / 2;\\n            if (a % n == 0) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/consecutive-numbers-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(sqrt(N))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        int ans = 0, n = 1, s = 1;\\n        for (; s <= N; s += ++n) {\\n            if ((N - s) % n == 0) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/consecutive-numbers-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(sqrt(N))\\n// Space: O(1)\\n// Ref: https://leetcode.com/problems/consecutive-numbers-sum/solution/\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        while ((N & 1) == 0) N >>= 1;\\n        int ans = 1, d = 3;\\n        while (d * d <= N) {\\n            int e = 0;\\n            for (; N % d == 0; N /= d, ++e);\\n            ans *= e + 1;\\n            d += 2;\\n        }\\n        if (N > 1) ans <<= 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128982,
                "title": "o-n-0-5-c-solution-with-detailed-explanation",
                "content": "let  sum(m,n) = N;\\n```\\n(m + n) * (n - m + 1) / 2 = N;\\n(m + n) * (n - m + 1) = 2 * N\\n```\\nlet\\'s say: \\n```\\na * b = 2 * N\\n```\\nwe have: \\n```\\n1. m + n = a         \\n2. n - m + 1 = b \\n```           \\nplus 1 and 2\\n```\\n2n + 1 = a + b\\n```\\nso if  a * b = 2* N and a + b is an odd number, there is a solution\\n\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        long long n = N * 2;\\n        int res = 0;\\n        for (int i = 1; i < n / i; i++)\\n        {\\n            if (n % i == 0 &&  ((i + n / i) % 2 == 1))\\n            {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n(m + n) * (n - m + 1) / 2 = N;\\n(m + n) * (n - m + 1) = 2 * N\\n```\n```\\na * b = 2 * N\\n```\n```\\n1. m + n = a         \\n2. n - m + 1 = b \\n```\n```\\n2n + 1 = a + b\\n```\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        long long n = N * 2;\\n        int res = 0;\\n        for (int i = 1; i < n / i; i++)\\n        {\\n            if (n % i == 0 &&  ((i + n / i) % 2 == 1))\\n            {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558307,
                "title": "very-easy-basic-maths",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int i=1;\\n        long long j=0;\\n        int ans=0;\\n        while(j<n)\\n        {\\n            if((n-j)%i==0)\\n             {\\n                ans++;\\n                cout<<i<<endl;\\n             } \\n              j+=i;\\n              i++;\\n\\n        }\\n        return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int i=1;\\n        long long j=0;\\n        int ans=0;\\n        while(j<n)\\n        {\\n            if((n-j)%i==0)\\n             {\\n                ans++;\\n                cout<<i<<endl;\\n             } \\n              j+=i;\\n              i++;\\n\\n        }\\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2386601,
                "title": "runtime-0-ms-faster-than-100-00-of-c",
                "content": "class Solution {\\npublic:\\n\\n    int consecutiveNumbersSum(int n) {\\n        int cnt=0,i=1;\\n        while(n>0){\\n            n-=i;\\n            if(n%i==0)\\n                cnt++;\\n            i++;\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int consecutiveNumbersSum(int n) {\\n        int cnt=0,i=1;\\n        while(n>0){\\n            n-=i;\\n            if(n%i==0)\\n                cnt++;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2342761,
                "title": "consecutive-numbers-sum-solution-java",
                "content": "class Solution {\\n  public int consecutiveNumbersSum(int N) {\\n    int ans = 0;\\n\\n    for (int i = 1, triangleNum = i; triangleNum <= N; ++i, triangleNum += i)\\n      if ((N - triangleNum) % i == 0)\\n        ++ans;\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Math",
                    "Enumeration"
                ],
                "code": "class Solution {\\n  public int consecutiveNumbersSum(int N) {\\n    int ans = 0;\\n\\n    for (int i = 1, triangleNum = i; triangleNum <= N; ++i, triangleNum += i)\\n      if ((N - triangleNum) % i == 0)\\n        ++ans;\\n\\n    return ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2108448,
                "title": "can-someone-explain-why-for-n-5-the-answer-is-2-and-not-1",
                "content": "The example given on leetcode is that for n=5 there are 2 ways to write sum of of consecutive positive integers. I know one way is (2+3), what is the second way? Is this problem even correct?\\nThanks\\n\\n \\n\\n",
                "solutionTags": [],
                "code": "The example given on leetcode is that for n=5 there are 2 ways to write sum of of consecutive positive integers. I know one way is (2+3), what is the second way? Is this problem even correct?\\nThanks\\n\\n \\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1866263,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        \\n        \\n   int res=0;\\n        int i=1;\\n        \\n        while(N>0){\\n            N-=i;\\n            \\n            if(N%i==0){\\n                res++;\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        \\n        \\n   int res=0;\\n        int i=1;\\n        \\n        while(N>0){\\n            N-=i;\\n            \\n            if(N%i==0){\\n                res++;\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794783,
                "title": "c-simple-mathematical-reasoning",
                "content": "The idea is to think N as sum of i possible consecutive integers. \\n```\\nFor example: N = 9\\ni = 2: 4 + 5 = 9\\ni = 3: 2 + 3 + 4 = 9\\ni = 4, 5 .... Not possible.\\n```\\nThe key questions here are:\\n```\\na. how to determine if N can be represented as sum of i consecutive intergers?\\nb. what is the range of i (we have to look for)?\\n```\\n\\na. how to determine if N can be represented as sum of i consecutive intergers?\\n```\\nConsider fist interger in sequence is x. So, we should have\\nx + (x+1) + (x+2)+...+ i terms = N\\ni*x + i*(i-1)/2 = N \\n=> i*x = N - i*(i-1)/2\\nwe can calculate rhs = N - i*(i-1)/2 for every possible value of i and if rhs is multiple of i \\nthen we can represent N as sum of i consecutive intergers starting from x.\\n```\\n\\nb. what is the range of i, we have to look for?\\n```\\nNotice carefully:\\nN - i*(i-1)/2 > 0\\n=> 2*N > i*(i-1)\\nSo, approximately i should be less then square root of 2*N. \\nTherefore, i ranges from (1, sqrt(2*N))\\n```\\nC++ Code snippet:\\n\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int count = 0;\\n        for(int i=1;i*i<2*n;i++){\\n            int rhs = n - (i*(i-1))/2;\\n            if(rhs % i == 0) count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nFor example: N = 9\\ni = 2: 4 + 5 = 9\\ni = 3: 2 + 3 + 4 = 9\\ni = 4, 5 .... Not possible.\\n```\n```\\na. how to determine if N can be represented as sum of i consecutive intergers?\\nb. what is the range of i (we have to look for)?\\n```\n```\\nConsider fist interger in sequence is x. So, we should have\\nx + (x+1) + (x+2)+...+ i terms = N\\ni*x + i*(i-1)/2 = N \\n=> i*x = N - i*(i-1)/2\\nwe can calculate rhs = N - i*(i-1)/2 for every possible value of i and if rhs is multiple of i \\nthen we can represent N as sum of i consecutive intergers starting from x.\\n```\n```\\nNotice carefully:\\nN - i*(i-1)/2 > 0\\n=> 2*N > i*(i-1)\\nSo, approximately i should be less then square root of 2*N. \\nTherefore, i ranges from (1, sqrt(2*N))\\n```\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int count = 0;\\n        for(int i=1;i*i<2*n;i++){\\n            int rhs = n - (i*(i-1))/2;\\n            if(rhs % i == 0) count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669559,
                "title": "python-straightforward-intuitive-answer",
                "content": "My code checks if n can be split into i consecutive terms for each `i` from 1 to n. It terminates early upon a certain condition; I will elaborate on this later.\\n\\n**Idea:**  The intuition is to divide n by i for each i from 1 to n. We call this variable `mid`.  This `mid` will be the midway point of the consecutive positive integers sequence. For even i\\'s, since there is no `mid` element for an even number of elements (eg. [1,2, 3, 4]), `mid` is the midpoint between the two middle indexes (eg. 2.5).\\n\\nWhy? Well we can split this into two cases:\\n\\n1. If `i` is even (eg. 2, 4,...), `mid` will have to be \"mid-way\\' between two (positive) integers, so we need to check if `mid` is x.5, x being a positive integer.\\n2. If `i` is odd( eg. 3, 5,...) `mid` corresponds directly with the middle element of the sequence, so we just need to check if `mid` is a positive integer.\\n\\nThis will work as the sequence of i consecutive positive integers corresponding to `mid` will sum to n.\\n\\nHowever now we need to determine an important question. When do we terminate?\\n\\nWe will terminate if the consecutive sequence corresponding to mid may contain an integer less than 1 (non-positive integer). This is because 1 is the smallest integer we can include in our sequence. Thus we terminate if `mid <= floor(i/2)`.\\n\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        count = 1\\n        for i in range(2, n):\\n            mid = n / i\\n            if mid <= i // 2:\\n                break\\n            if i % 2 == 0: # i is even\\n                if (mid / 0.5) % 2  == 1: # mid is x.5, x \\u2208 positive integer\\n                    count += 1\\n            else:          # i is odd\\n                if mid % 1 == 0:          # mid is x, x \\u2208 positive integer\\n                    count += 1\\n        return count\\n```        \\nThe tightest upper bound I could think of for this implementation was O(n). Running thru the code with examples is probably the best way to understand it.\\n\\nIn addition, I felt this explanation and algorithm was slightly handwavy, so please feel free to comment with suggestions and improvements.",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        count = 1\\n        for i in range(2, n):\\n            mid = n / i\\n            if mid <= i // 2:\\n                break\\n            if i % 2 == 0: # i is even\\n                if (mid / 0.5) % 2  == 1: # mid is x.5, x \\u2208 positive integer\\n                    count += 1\\n            else:          # i is odd\\n                if mid % 1 == 0:          # mid is x, x \\u2208 positive integer\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603568,
                "title": "python-simple-easy-no-sqrt-no-complex-math",
                "content": "* The equation 4 + 5 + 6 = 15 can be simplified as   (3+1) + (3+2) + (3+3)  = 15\\n* or 3 + 3 + 3 = 15 - 1 - 2 - 3 \\n* so 3 is base here and the RHS is also divisible by 3\\n* if RHS is divisible by BASE = there is a conecutive sum \\n\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        \\n        count = 0 \\n        \\n        i = 1\\n        \\n        while (n > 0):\\n            n -= i\\n            if n%i == 0:\\n                count += 1\\n            i += 1        \\n        return count\\n    \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        \\n        count = 0 \\n        \\n        i = 1\\n        \\n        while (n > 0):\\n            n -= i\\n            if n%i == 0:\\n                count += 1\\n            i += 1        \\n        return count\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514481,
                "title": "java-intuitive-solution",
                "content": "Writing down the base cases:\\nInput: n = 15\\nOutput: 4\\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\\n\\nN = M + 0 ( M +0)  => 15+0\\nN = 2M + 1 => (7+0) + (7+1)\\nN = 3M + 3 =>  4+0 +4 +1 +(4+2) \\n\\nso it boils down to an equation with  3 variables\\nN = (coEfficient) * M + variable. \\n\\nWe need to solve for M. If M is an integer, then there is a candidate\\n\\nsolving for M would look like \\nM = (N-variable)/coEfficient;\\n\\nAs per the equation - if the numertor crosses negative - the equation doesnt make sense \\nhence, our exit condition is variable < N. \\n\\nCode:\\n\\n\\tclass Solution {\\n    public int consecutiveNumbersSum(int n) {\\n        \\n        int coEfficient = 1;\\n        int variable = 0;\\n        \\n        int result = 0;\\n\\n        while(variable < n){\\n            double d = (n - variable)/(double)coEfficient;\\n            \\n            if( d == (int) d ) result ++; // it has to be an integer, or this is not a candidate \\n            \\n            variable += coEfficient++;\\n        }\\n        return result;\\n        \\n    }\\n}\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int consecutiveNumbersSum(int n) {\\n        \\n        int coEfficient = 1;\\n        int variable = 0;\\n        \\n        int result = 0;\\n\\n        while(variable < n){\\n            double d = (n - variable)/(double)coEfficient;\\n            \\n            if( d == (int) d ) result ++; // it has to be an integer, or this is not a candidate \\n            \\n            variable += coEfficient++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1442339,
                "title": "simple-solution-with-derivation",
                "content": "``` \\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        # N = x + x+1 + x+2 + ... + (x+i-1) [total i terms]\\n        # N = x*i + i*(i-1)/2\\n        \\n        # N - i*(i-1)/2 = x*i > 0 [ as x and i are > 0 and LHS is a multiple of \\'i\\']\\n        \\n        # => N > i*(i-1)/2\\n        # => 2*N > i**2 - i + 1/4 - 1/4\\n        # => 2*N + 1/4 > (i-1/2)**2\\n        # => (2*N + 1/4)**0.5 > i-1/2\\n        # => (2*N + 1/4)**0.5 + 1/2 > i\\n        \\n        limit = int( (2*n + 1/4)**0.5 + 1/2 )\\n        ans = 0\\n        for i in range(1, limit):\\n            \\n            if ( n - ((i*(i-1))//2) ) % i == 0:  # remember this is a multiple of \\'i\\'\\n                ans += 1\\n                \\n        return ans\\n\\t",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        # N = x + x+1 + x+2 + ... + (x+i-1) [total i terms]\\n        # N = x*i + i*(i-1)/2\\n        \\n        # N - i*(i-1)/2 = x*i > 0 [ as x and i are > 0 and LHS is a multiple of \\'i\\']\\n        \\n        # => N > i*(i-1)/2\\n        # => 2*N > i**2 - i + 1/4 - 1/4\\n        # => 2*N + 1/4 > (i-1/2)**2\\n        # => (2*N + 1/4)**0.5 > i-1/2\\n        # => (2*N + 1/4)**0.5 + 1/2 > i\\n        \\n        limit = int( (2*n + 1/4)**0.5 + 1/2 )\\n        ans = 0\\n        for i in range(1, limit):\\n            \\n            if ( n - ((i*(i-1))//2) ) % i == 0:  # remember this is a multiple of \\'i\\'\\n                ans += 1\\n                \\n        return ans\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 1439454,
                "title": "c-o-sqrt-n-soln-with-expanation",
                "content": "```\\n    int consecutiveNumbersSum(int n) {\\n        // the idea behind the below code is .\\n       // 4 + 5 + 6 = (3+1) + (3+2) + (3+3) =   3*3 + (1 + 2 + 3) =  n*k + n*(n+1)/2  (where n and k both are integer).\\n       //largest possible value of n is number = n*(n+1)/2 :- range = pow(2*number , .5)\\n \\n        int i;\\n        long long range = pow(n*2 , .5) + 1;\\n        long double k = 0;\\n        int ans = 0;\\n\\t\\t//if will run the loop for all possible value of n and if some interger value of \\n\\t\\t//k exist then it will considerd as answer.\\n        for(i=2; i<range; i++)\\n        {\\n            k = ( n - i*(i+1)/2.0 ) / i;\\n            if(k == (int)k){ans++; }\\n        }\\n        return ans + 1; // number itself is considered as a consecutive sum of length 1 \\n    }\\n\\nif it was helpful please upvtoe :)\\n```",
                "solutionTags": [],
                "code": "```\\n    int consecutiveNumbersSum(int n) {\\n        // the idea behind the below code is .\\n       // 4 + 5 + 6 = (3+1) + (3+2) + (3+3) =   3*3 + (1 + 2 + 3) =  n*k + n*(n+1)/2  (where n and k both are integer).\\n       //largest possible value of n is number = n*(n+1)/2 :- range = pow(2*number , .5)\\n \\n        int i;\\n        long long range = pow(n*2 , .5) + 1;\\n        long double k = 0;\\n        int ans = 0;\\n\\t\\t//if will run the loop for all possible value of n and if some interger value of \\n\\t\\t//k exist then it will considerd as answer.\\n        for(i=2; i<range; i++)\\n        {\\n            k = ( n - i*(i+1)/2.0 ) / i;\\n            if(k == (int)k){ans++; }\\n        }\\n        return ans + 1; // number itself is considered as a consecutive sum of length 1 \\n    }\\n\\nif it was helpful please upvtoe :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403789,
                "title": "python",
                "content": "We can write any consecutive sum in the form of `n = k + (k + 1) + (k + 2) + ... (k + c)`, for some positive integer `k`.\\nIf you write a few iterations:\\n\\n`n = k`\\n`n = k + (k + 1) = 2k + 1`\\n`n = k + (k + 1) + (k + 2) = 3k + 3`\\n`n = k + (k + 1) + (k + 2) + (k + 3) = 4k + 6`\\n...\\n...\\n...\\n`n = i * k + sum(0, i - 1)`\\n\\nA valid sequence of numbers that sum to `n` must satisfy the relation above. We will use `i` to denote the coefficient of `k`. At any iteration `i`, we want to make sure that `n - sum(0, i - 1)` is both positive and divisible by `i` (the coefficient of `k`). \\n\\n```\\ndef consecutiveNumbersSum(self, n: int) -> int:\\n\\tif n == 1:\\n\\t\\treturn 1\\n\\t\\t\\n\\tres = 0\\n\\tconstant = 0\\n\\tfor i in range(1, n):\\n\\t\\tif n - constant <= 0:\\n\\t\\t\\tbreak\\n\\t\\tif (n - constant) % i == 0:\\n\\t\\t\\tres += 1\\n\\t\\tconstant += i\\n\\t\\t\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef consecutiveNumbersSum(self, n: int) -> int:\\n\\tif n == 1:\\n\\t\\treturn 1\\n\\t\\t\\n\\tres = 0\\n\\tconstant = 0\\n\\tfor i in range(1, n):\\n\\t\\tif n - constant <= 0:\\n\\t\\t\\tbreak\\n\\t\\tif (n - constant) % i == 0:\\n\\t\\t\\tres += 1\\n\\t\\tconstant += i\\n\\t\\t\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1306835,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        int ans=0;\\n        for(int k=1;k*k<=2*N;k++){\\n            int val=2*N-(k*(k+1));\\n            if((val%(2*k))==0){\\n                ans+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// x+(x+1)+(x+3)+........\\n// N= kx + k*(k+1)/2\\n// 2*N=2kx+k*(k+1)\\n// x=2*N-(k*(k+1))/2*k\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        int ans=0;\\n        for(int k=1;k*k<=2*N;k++){\\n            int val=2*N-(k*(k+1));\\n            if((val%(2*k))==0){\\n                ans+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// x+(x+1)+(x+3)+........\\n// N= kx + k*(k+1)/2\\n// 2*N=2kx+k*(k+1)\\n// x=2*N-(k*(k+1))/2*k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161998,
                "title": "easier-to-understand-o-n-solution-java-thorough-explanation",
                "content": "All the O(sqrt(N)) are mathematically tricky to understand but I got an O(N) mathematical solution that still works, is easier to follow, and might serve as a good starting point for the O(sqrt(N)) solution.\\n\\n**The Summation:**\\n\\nSince we\\'re looking at consecutive sequence of integers that add of to a certain number *N*. We can express this using a sum from *A* to *B* where *A* is the first integer of the sequence and *B* is the last.\\n\\nIt would look something like this:\\n![image](https://assets.leetcode.com/users/images/5c62c80c-7a72-4623-899d-44e76184f009_1618605175.1425345.png)\\nThe focus of the problem would be to find how many combinations of *A* and *B* result in a sum of *N*\\n*Note: the range of our values is* ![image](https://assets.leetcode.com/users/images/72077c0b-9345-43ca-af17-99c5ea431100_1618606058.1533134.png)\\n\\n\\n\\n\\nFirst, we can start by writing a simple *sum* method that solves the summation for us:\\n```\\npublic int sum(int A, int B){\\n\\tint sum = 0;\\n\\twhile(A <= B){\\n\\t\\tsum+=A;\\n\\t\\tA++;\\n\\t}\\n\\treturn sum;\\n}\\n```\\n\\nThis issue with this that it has an O(B-A) or ~O(N) runtime. We\\'re going to be calling this method a lot so it makes sense to optimize this. \\n\\nThose with a little bit of math experience might recall that we can express a the sum of a consecutive sequence as follows:\\n![image](https://assets.leetcode.com/users/images/39e44361-a332-45b4-be4e-3617368eb504_1618605528.9007967.png)\\n\\nOur original equation doesn\\'t quite match this format, but we can split up the sum and rewrite it as follows:\\n![image](https://assets.leetcode.com/users/images/70a9043a-4fcc-49bc-a767-d5cbbd07a41f_1618605854.9574213.png)\\nAnd then convert it to the formula:\\n![image](https://assets.leetcode.com/users/images/ccba4f77-2776-4eee-b90b-0526df72000b_1618606109.1258433.png)\\n\\nNow we can rewrite our sum method in O(1) time:\\n```\\npublic int sum(int A, int B){\\n\\tint sumToB = B*(B+1)/2;\\n    int sumToA = (A-1)*A/2;\\n\\treturn sumToB - sumToA;\\n}\\n```\\n*Note: one issue I ran into is that when plugging in big numbers, I would get integer roll-over due to the Bx(B+1) or (A-1)xA operations resulting in REALLY big numbers (>2,147,483,647) . To combat this issue I converted the code to use BigInteger but it\\'s functionally still identical:*\\n```\\npublic int sum(int A, int B){\\n        BigInteger bigB = BigInteger.valueOf(B);\\n        BigInteger bigA = BigInteger.valueOf(A);\\n        int sumToB = bigB.multiply(bigB.add(BigInteger.valueOf(1))).divide(BigInteger.valueOf(2)).intValue();\\n        int sumToA = bigA.multiply(bigA.subtract(BigInteger.valueOf(1))).divide(BigInteger.valueOf(2)).intValue();\\n        return sumToB - sumToA;\\n    }\\n```\\n\\n**The main problem:**\\nNow that we have a good sum function, all we really have to do is figure out how many combinations of *A* and *B* work. We start off at *A=B=N* since the very first consecutive integer is just the number itself. From there we can do the following:\\n\\n-If the sum from A to B is equal to N, we increase our count by one and then increase our \\'range\\' by subtracting 1 from A\\n-If the sum from A to B is greater than N, we have to narrow down our interval by subtracting 1 from B\\n-If the sum from A to B is less than N, we have to expand our interval by subtract 1 from A\\n\\nNow do the steps above over and over until you reach A = 1.\\n\\nThe code for this would look as follows:\\n```\\npublic int consecutiveNumbersSum(int N) {\\n        int B = N, A = N;\\n        int count = 0;\\n        while(A > 0){\\n            int theSum = sum(A,B);\\n            if(theSum == N){\\n                count++;\\n                A--;\\n            }\\n            else if(theSum > N){\\n                B--;\\n            }\\n            else{\\n                A--;\\n            }\\n        }\\n        return count;\\n    }\\n```\\n\\nAnd there you go, thats the solution!\\n\\n**A couple caveats:**\\n-This solution is definetly far from optimal. In fact you could probably optimize it even more by starting at N/2 for example and just adding an initial 1 to the count. There are many more optimizations you can do to this, but it\\'ll still end up with O(N) runtime.\\n-While this is not a great solution, I believe it uses some similar concepts to the O(sqrt(N)) solution and can serve as a good starting point for figuring it out.\\n-Note: Putting this code into LeetCode and submitting it results in a \\'Time Limit Exceeded\\'. However I verified that it does definitely work for every input that they throw at you, it just takes too long to run for ALL their inputs since its O(N).\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic int sum(int A, int B){\\n\\tint sum = 0;\\n\\twhile(A <= B){\\n\\t\\tsum+=A;\\n\\t\\tA++;\\n\\t}\\n\\treturn sum;\\n}\\n```\n```\\npublic int sum(int A, int B){\\n\\tint sumToB = B*(B+1)/2;\\n    int sumToA = (A-1)*A/2;\\n\\treturn sumToB - sumToA;\\n}\\n```\n```\\npublic int sum(int A, int B){\\n        BigInteger bigB = BigInteger.valueOf(B);\\n        BigInteger bigA = BigInteger.valueOf(A);\\n        int sumToB = bigB.multiply(bigB.add(BigInteger.valueOf(1))).divide(BigInteger.valueOf(2)).intValue();\\n        int sumToA = bigA.multiply(bigA.subtract(BigInteger.valueOf(1))).divide(BigInteger.valueOf(2)).intValue();\\n        return sumToB - sumToA;\\n    }\\n```\n```\\npublic int consecutiveNumbersSum(int N) {\\n        int B = N, A = N;\\n        int count = 0;\\n        while(A > 0){\\n            int theSum = sum(A,B);\\n            if(theSum == N){\\n                count++;\\n                A--;\\n            }\\n            else if(theSum > N){\\n                B--;\\n            }\\n            else{\\n                A--;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155042,
                "title": "recursion-and-dp-with-tle-because-what-if-i-can-t-get-mathematical",
                "content": "```\\nclass Solution {\\n    int ways = 0;\\n    public int consecutiveNumbersSum(int N) {\\n        \\n        for (int i = 1; i <= N; i++) {\\n            backtrack(i, 0, N);\\n        }\\n        \\n        return ways;\\n    }\\n    \\n    public void backtrack(int number, long sum, int N) {\\n        if (sum > N)\\n            return;\\n        if (sum == N) {\\n            ways++;\\n            return;\\n        }\\n        \\n        backtrack(number + 1, sum + number, N);\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int ways = 0;\\n        LinkedList<Long> storage = new LinkedList<>();\\n        storage.add((long)0);\\n        \\n        // Store sum upto i at each index in array\\n        int i = 1;\\n        while (i <= N) {\\n            long currSum = storage.getLast() + i;\\n            storage.add(currSum);\\n            i++;\\n        }\\n        ways += 1;      // Default way of standalone N\\n        \\n        // storage: [0 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 ]\\n        // i: [0 1 2 3 4   5  6  7  8  9 10 11 12 13  14  15]\\n        \\n        for (i = 1; i < N; i++) {\\n            if (storage.get(i - 1) - storage.get(i) > N)\\n                break;\\n            for (int j = i + 1; j < N; j++) {\\n                long currsum = storage.get(j) - storage.get(i - 1);\\n                if (currsum == N)\\n                    ways += 1;\\n                if (currsum > N)\\n                    break;\\n            }\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ways = 0;\\n    public int consecutiveNumbersSum(int N) {\\n        \\n        for (int i = 1; i <= N; i++) {\\n            backtrack(i, 0, N);\\n        }\\n        \\n        return ways;\\n    }\\n    \\n    public void backtrack(int number, long sum, int N) {\\n        if (sum > N)\\n            return;\\n        if (sum == N) {\\n            ways++;\\n            return;\\n        }\\n        \\n        backtrack(number + 1, sum + number, N);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int ways = 0;\\n        LinkedList<Long> storage = new LinkedList<>();\\n        storage.add((long)0);\\n        \\n        // Store sum upto i at each index in array\\n        int i = 1;\\n        while (i <= N) {\\n            long currSum = storage.getLast() + i;\\n            storage.add(currSum);\\n            i++;\\n        }\\n        ways += 1;      // Default way of standalone N\\n        \\n        // storage: [0 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 ]\\n        // i: [0 1 2 3 4   5  6  7  8  9 10 11 12 13  14  15]\\n        \\n        for (i = 1; i < N; i++) {\\n            if (storage.get(i - 1) - storage.get(i) > N)\\n                break;\\n            for (int j = i + 1; j < N; j++) {\\n                long currsum = storage.get(j) - storage.get(i - 1);\\n                if (currsum == N)\\n                    ways += 1;\\n                if (currsum > N)\\n                    break;\\n            }\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117335,
                "title": "3-lines-python-solution-o-n-0-5",
                "content": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        res = 0; maxK = int(math.sqrt(2 * N))\\n        for k in range(1, maxK + 1):\\n            res += (N - (k * (k - 1)) // 2) % k == 0\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        res = 0; maxK = int(math.sqrt(2 * N))\\n        for k in range(1, maxK + 1):\\n            res += (N - (k * (k - 1)) // 2) % k == 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047057,
                "title": "shortest-answer-in-python",
                "content": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        return sum((1 for k in range(1, int(sqrt(2*N))+1) if (N - k*(k+1)/2) % k == 0))\\n```\\n\\nSome math:\\nWe have at least one term that starts with 1. Therefore, x can be 0, so x+1 = 1.\\n![image](https://assets.leetcode.com/users/images/a49405f5-ccbb-434d-ba79-4b4aad3f2765_1612299451.8731813.png)\\nNow, express the solution as a formular:\\n![image](https://assets.leetcode.com/users/images/4c855307-79d6-4b8e-863b-f8a8d1a8e7c9_1612299228.209036.png)\\nThe third line gives us the final equation we use to calculate the number of all possible values for k and x. There\\'s only a solution if the right-hand-side is diviable by k. Hence, the ```if (N - k*(k+1)/2) % k == 0```.\\nThe last line shows us what size k can grow up to. Hence, the ```range(1, int(sqrt(2*N))+1)```.\\n\\nOptimization: I used ```sum((...))``` instead of ```sum([...])``` to save memory. The round brackets give us a generator instead of a list.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        return sum((1 for k in range(1, int(sqrt(2*N))+1) if (N - k*(k+1)/2) % k == 0))\\n```\n```if (N - k*(k+1)/2) % k == 0```\n```range(1, int(sqrt(2*N))+1)```\n```sum((...))```\n```sum([...])```",
                "codeTag": "Java"
            },
            {
                "id": 992893,
                "title": "python3-easy-clean-o-n-iterative-solution",
                "content": "```\\ndef nWays(num):\\n    ways = 0\\n    sumArray = [0]\\n    for i in range(1, num+1):\\n        sumArray.append(sumArray[-1]+i)\\n\\n    lookup = set()\\n    for item in sumArray:\\n        if item - num in lookup:\\n            ways += 1\\n        lookup.add(item)\\n\\n    return ways\\n```\\n\\n\\n## Explanation:-\\n\\n### To Find:\\n- consecutive numbers that sum up to the number `N`\\n\\n### Solution:\\n- Upon creating an running sum array we observe that\\n\\t-  if arr[i] - arr[j] == N where i > j, then numbers from j to i sum up to N\\n- This implies `sum(arr[j:i+1]) == N`\\n\\n\\n**for example -**\\n```\\nsay N = 15\\nIndices -      0, 1, 2, 3,  4, 5,   6,  7,  8,  9, 10, 11, 12, 13,  14,  15\\nrunning sum - [0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120]\\n```\\nHence\\n```\\narray[0:6] == 15, therefore sum(1,2,3,4,5) == 15\\narray[3:7] == 15, therefore sum(4,5,6) == 15\\narray[6:9] == 15, therefore sum(7,8) == 15\\narray[14:] == 15, therefore sum(15) == 15\\n\\nresult = 4\\n```\\n\\n**Note:**\\n- starting and ending indices are non inclusive\\n- Runtime complexity = O(n)\\n\\t- *this will throw time limit exceeded error on Leetcode*\\n\\t- ***but the solution is great for interviews***\\n- Space Complexity = O(n)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef nWays(num):\\n    ways = 0\\n    sumArray = [0]\\n    for i in range(1, num+1):\\n        sumArray.append(sumArray[-1]+i)\\n\\n    lookup = set()\\n    for item in sumArray:\\n        if item - num in lookup:\\n            ways += 1\\n        lookup.add(item)\\n\\n    return ways\\n```\n```\\nsay N = 15\\nIndices -      0, 1, 2, 3,  4, 5,   6,  7,  8,  9, 10, 11, 12, 13,  14,  15\\nrunning sum - [0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120]\\n```\n```\\narray[0:6] == 15, therefore sum(1,2,3,4,5) == 15\\narray[3:7] == 15, therefore sum(4,5,6) == 15\\narray[6:9] == 15, therefore sum(7,8) == 15\\narray[14:] == 15, therefore sum(15) == 15\\n\\nresult = 4\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 887091,
                "title": "evolve-from-intuition-to-optimal",
                "content": "1. O(n^2) brute force, try starting from 1 to N\\n```\\n\\tpublic int consecutiveNumbersSum(int N) {\\n        int count=0;\\n        for(int i=1;i<=N;i++) {\\n            int sum=0;\\n            for(int j=i;sum<N&&j<=N;j++) {\\n                sum+=j;\\n            }\\n            if(sum==N) count++;\\n        }\\n        return count;\\n    }\\n```\\n2. O(nlogn), given a start number and a sum, we can find the end number by binary search.\\n```\\n\\tpublic int consecutiveNumbersSum(int N) {\\n        int count=0;\\n        for(int i=1;i<=N;i++) {\\n            count+=findSum(i,N);\\n        }\\n        return count;\\n    }\\n    private int findSum(int i, int N) {\\n        int l=i, r=N;\\n        while(l<=r) {\\n            int mid=(l+r)/2;\\n            long sum=(long)(i+mid)*(mid-i+1)/2;\\n            if(sum==N) return 1;\\n            if(sum<N) l=mid+1;\\n            else r=mid-1;\\n        }\\n        return 0;\\n    }\\n```\\n3. O(n), given a start number and a sum, we can compute the end number using math formular. Say we have i to j that sums to N. \\n```\\n\\t(i+j)(j-i+1)/2=N =>j*(j+1) = 2N+i^2-i\\n```\\n```\\n\\tpublic int consecutiveNumbersSum(int N) {\\n        int count=0;\\n        for(int i=1;i<=N;i++) {\\n            long prod=2L*N+(long)i*i-i;\\n            long sqrt=(int)Math.sqrt(prod);\\n            if(sqrt*(sqrt+1)==prod) count++;\\n        }\\n        return count;\\n    }\\n```\\n4. O(sqrt(n)), trying all start numbers requires at least O(n) and does not pass OJ. A different way is to look at the length of the sequence. Say we have i, i+1,i+2,...,i+k-1 that sums to N\\n```\\n\\t(i+i+k-1)*k/2=N => k*i=N-(k-1)*k/2\\n\\t2i-1=2N/k-k and i>0 => 2N/k-k>0 => k<sqrt(2N)\\n```\\n```\\n\\tpublic int consecutiveNumbersSum(int N) {\\n        int count=0;\\n        for(long i=1;i<Math.sqrt(2*N);i++) {\\n            if((N+i*(i-1)/2)%i==0) count++;\\n        }\\n        return count;\\n    }\\n```\\n5. O(logn) see [@lee215](https://leetcode.com/problems/consecutive-numbers-sum/discuss/128947/JavaC%2B%2BPython-Fastest-Count-Odd-Factors-O(logN))\\n",
                "solutionTags": [],
                "code": "```\\n\\tpublic int consecutiveNumbersSum(int N) {\\n        int count=0;\\n        for(int i=1;i<=N;i++) {\\n            int sum=0;\\n            for(int j=i;sum<N&&j<=N;j++) {\\n                sum+=j;\\n            }\\n            if(sum==N) count++;\\n        }\\n        return count;\\n    }\\n```\n```\\n\\tpublic int consecutiveNumbersSum(int N) {\\n        int count=0;\\n        for(int i=1;i<=N;i++) {\\n            count+=findSum(i,N);\\n        }\\n        return count;\\n    }\\n    private int findSum(int i, int N) {\\n        int l=i, r=N;\\n        while(l<=r) {\\n            int mid=(l+r)/2;\\n            long sum=(long)(i+mid)*(mid-i+1)/2;\\n            if(sum==N) return 1;\\n            if(sum<N) l=mid+1;\\n            else r=mid-1;\\n        }\\n        return 0;\\n    }\\n```\n```\\n\\t(i+j)(j-i+1)/2=N =>j*(j+1) = 2N+i^2-i\\n```\n```\\n\\tpublic int consecutiveNumbersSum(int N) {\\n        int count=0;\\n        for(int i=1;i<=N;i++) {\\n            long prod=2L*N+(long)i*i-i;\\n            long sqrt=(int)Math.sqrt(prod);\\n            if(sqrt*(sqrt+1)==prod) count++;\\n        }\\n        return count;\\n    }\\n```\n```\\n\\t(i+i+k-1)*k/2=N => k*i=N-(k-1)*k/2\\n\\t2i-1=2N/k-k and i>0 => 2N/k-k>0 => k<sqrt(2N)\\n```\n```\\n\\tpublic int consecutiveNumbersSum(int N) {\\n        int count=0;\\n        for(long i=1;i<Math.sqrt(2*N);i++) {\\n            if((N+i*(i-1)/2)%i==0) count++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 792381,
                "title": "c-solution-no-math",
                "content": "\\n```\\n\\npublic class Solution {\\n    public int ConsecutiveNumbersSum(int N) {\\n        \\n        if(N < 3)\\n            return 1;\\n        \\n        int minNum = 1, maxNum = 1, sum = 1, count = 0;        \\n        \\n        while(minNum <= N/2)\\n        {            \\n            while(sum < N)\\n                sum += ++maxNum;                                                \\n                        \\n            if(sum == N)\\n                count++;                \\n                        \\n            sum -= minNum;           \\n            minNum++;            \\n        }               \\n        \\n        return count + 1;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public int ConsecutiveNumbersSum(int N) {\\n        \\n        if(N < 3)\\n            return 1;\\n        \\n        int minNum = 1, maxNum = 1, sum = 1, count = 0;        \\n        \\n        while(minNum <= N/2)\\n        {            \\n            while(sum < N)\\n                sum += ++maxNum;                                                \\n                        \\n            if(sum == N)\\n                count++;                \\n                        \\n            sum -= minNum;           \\n            minNum++;            \\n        }               \\n        \\n        return count + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262307,
                "title": "java-3ms-solution",
                "content": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int total = 0;\\n        int extra = 0;\\n        for (int i = 1; i < N + 1; i++) {\\n            extra = extra + (i - 1);\\n            if (extra >= N) {\\n                break;\\n            }\\n            int remain = N - extra;\\n            if (remain % i == 0) {\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int total = 0;\\n        int extra = 0;\\n        for (int i = 1; i < N + 1; i++) {\\n            extra = extra + (i - 1);\\n            if (extra >= N) {\\n                break;\\n            }\\n            int remain = N - extra;\\n            if (remain % i == 0) {\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130602,
                "title": "clean-java-solution-o-sqrt-n-19-ms",
                "content": "The consecutive numbers that satisfy the condition can be expressed as,\\n`N = a1 + a2 + ... + an = (1 + 2 + ... + n) + n * c`\\nAnd `n` is at most sqrt(N) since `(1 + max_n) * max_n / 2 = N`\\nSo we can start with dividend as `N`, keep subtracting the next consecutive number and see if the devidend is divisable by `n = ni`.   `ni` increases every loop. We do at most sqrt(N) times, which is the maximum of `ni`.\\n\\n```\\npublic int consecutiveNumbersSum(int N) {\\n\\tint count = 0, devidend = N, devisor = 1;\\n\\twhile (devisor <= devidend) {\\n\\t\\tif (devidend % devisor == 0) count++;\\n\\t\\tdevidend -= devisor;\\n\\t\\tdevisor++;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int consecutiveNumbersSum(int N) {\\n\\tint count = 0, devidend = N, devisor = 1;\\n\\twhile (devisor <= devidend) {\\n\\t\\tif (devidend % devisor == 0) count++;\\n\\t\\tdevidend -= devisor;\\n\\t\\tdevisor++;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 129476,
                "title": "java-sqrt-solution",
                "content": "```\\nclass Solution {\\n    \\n    public int consecutiveNumbersSum(int n) {\\n        int result = 0;\\n        for(int i=1; i*(i-1)/2 <=n ;++i){\\n            // a0*i + i*(i-1)/2 = n;\\n            // a0 = (n - i*(i-1)/2) / i\\n            if((n - i*(i-1)/2)%i==0 && (n - i*(i-1)/2) > 0){\\n                result++;\\n            }\\n        }    \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int consecutiveNumbersSum(int n) {\\n        int result = 0;\\n        for(int i=1; i*(i-1)/2 <=n ;++i){\\n            // a0*i + i*(i-1)/2 = n;\\n            // a0 = (n - i*(i-1)/2) / i\\n            if((n - i*(i-1)/2)%i==0 && (n - i*(i-1)/2) > 0){\\n                result++;\\n            }\\n        }    \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739833,
                "title": "simplest-c-solution-just-using-simple-math-observation-86-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. \\n\\n---\\n\\n1. # Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(3) , Extra Space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n         int j=0;\\n        int k=0,i=1;\\n        while(n>0){\\n            n=n-i;\\n            if(n%i==0) k++;\\n            i++;\\n            \\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n         int j=0;\\n        int k=0,i=1;\\n        while(n>0){\\n            n=n-i;\\n            if(n%i==0) k++;\\n            i++;\\n            \\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555795,
                "title": "829-consecutive-numbers-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int count = 0;\\n        for(int i = 2 ; i < n ; i++){\\n            int sum_1 = i*(i+1)/2;\\n            if(sum_1 > n)\\n                break;\\n            if((n-sum_1)%i == 0)\\n                count++;\\n        }\\n        return count+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int count = 0;\\n        for(int i = 2 ; i < n ; i++){\\n            int sum_1 = i*(i+1)/2;\\n            if(sum_1 > n)\\n                break;\\n            if((n-sum_1)%i == 0)\\n                count++;\\n        }\\n        return count+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484874,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int ans=1;\\n        for(int i=2;i<n;i++) {\\n            if((i*(i+1))/2 > n) return ans;\\n            if((n - (i*(i+1))/2)%i==0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        res, i = 1, 3\\n        while n % 2 == 0:\\n            n //= 2\\n        \\n        while i*i <= n:\\n            count = 0\\n            while n % i == 0:\\n                n //= i\\n                count += 1\\n            res *= count + 1\\n            i += 2\\n        return res if n == 1 else res * 2\\n```\\n\\n```Java []\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int res = 1, count;\\n        while (N % 2 == 0) N /= 2;\\n        for (int i = 3; i * i <= N; i += 2) {\\n            count = 0;\\n            while (N % i == 0) {\\n                N /= i;\\n                count++;\\n            }\\n            res *= count + 1;\\n        }\\n        return N == 1 ? res : res * 2;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int ans=1;\\n        for(int i=2;i<n;i++) {\\n            if((i*(i+1))/2 > n) return ans;\\n            if((n - (i*(i+1))/2)%i==0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        res, i = 1, 3\\n        while n % 2 == 0:\\n            n //= 2\\n        \\n        while i*i <= n:\\n            count = 0\\n            while n % i == 0:\\n                n //= i\\n                count += 1\\n            res *= count + 1\\n            i += 2\\n        return res if n == 1 else res * 2\\n```\n```Java []\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int res = 1, count;\\n        while (N % 2 == 0) N /= 2;\\n        for (int i = 3; i * i <= N; i += 2) {\\n            count = 0;\\n            while (N % i == 0) {\\n                N /= i;\\n                count++;\\n            }\\n            res *= count + 1;\\n        }\\n        return N == 1 ? res : res * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270043,
                "title": "c-o-n-time-simple-math-arithmetic-progression",
                "content": "# Intuition\\nSum of an AP (Arithmetic Progression) [common difference = 1]\\na + (a+1) + (a+2) + ... + (a + (m-1))  = m/2(2a + (m-1))\\n\\nHere n = this sum\\n\\nWe need to find all the consecutive series that sum to n.\\nWhich means we just need to find unique values of m and a\\n\\nSince the sum is equal to n.\\nWe dont need to find the second variable as it will be dependent on m.\\nWe just need to make sure it is an integer.\\n\\nLower bound to m can be set as 1, in which a = n\\nUpper bound to m can be set by setting a as 1 and solving for m.\\nWhich will give m=\\u221A(2*n + 1/4) - (1/2)\\n\\n# Approach\\nJust loop from m=1 to m=\\u221A(2n+1/4)-1/2 (or while m(m+1)<=2n), if a is integer increase count.\\n\\n# Complexity\\n- Time complexity:\\n$$O(\\u221An)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int cnt = 0;\\n        for(int m=1;m*(m+1)<=2*n;m++){\\n            if((2*n - m*(m-1))%(2*m) == 0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int cnt = 0;\\n        for(int m=1;m*(m+1)<=2*n;m++){\\n            if((2*n - m*(m-1))%(2*m) == 0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492120,
                "title": "two-java-approaches-sliding-window-o-n-gauss-sum-o-n-0-5",
                "content": "`Approach One` - Sliding Window (Excess Time Limit)\\nIt has a time complexity of `O(n)`, which cannot pass all the tests, but I believe it is enough for the interview.\\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int n) {\\n        if (n <= 2) return 1;\\n        int[] arr = new int[n / 2 + 1];\\n\\t\\t// it is because (n / 2) + (n / 2 + 1) >= n   \\n\\t\\t// e.g. if n = 11, then 6 will be enough for the length of the array\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = i + 1;\\n        }\\n        int left = 0;\\n        int right = 0;\\n        int sum = 0;\\n        int ans = 1;\\n        while (right < arr.length) {\\n            sum += arr[right];\\n            right++;\\n            while (sum >= n) {\\n                if (sum == n) {\\n                    ans++;\\n                }\\n                sum -= arr[left];\\n                left++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n`Approach Two` - Gauss Sum (Accepted)\\nGuass Sum is `(1 + n) * n / 2`\\nIt is the same as the approach 1 provided by Leetcode. For here, I will provide my base version, and then do 2 optimization to be the final answer.\\n\\nIdea:\\n1. Find the minimum number `bound` which makes `(1 + bound) * bound / 2 >= N` by using quadratic formula (`bound` should be positive)\\n2. Declare a variable called `sum` which is = (1 + bound) * bound / 2;\\n3. Declare a variable called `x` which represents the number of `bound`\\nHere is an example - suppose N = 15, then we can calculate that n = 5:\\n![image](https://assets.leetcode.com/users/images/1516a4b7-571b-456d-a950-552c9e654c76_1661634828.401214.png)\\n\\nBase version:\\n```\\npublic int consecutiveNumbersSum(int n) {\\n        // Math.sqrt(1 + 8 * n) * 1/2 will cause overflow, which is = Math.sqrt(0.25 + 2 * n)\\n        int bound = (int) (-0.5 + Math.sqrt(0.25 + 2 * n) + 0.5);\\n        int sum = (1 + bound) * bound / 2;\\n        int x = 0;\\n        int count = 0;\\n        while (bound > 1) {\\n            int formula = sum + bound * x;\\n            if (formula == n) {\\n                count++;\\n                sum -= bound;\\n                bound--;\\n            } else if (formula > n) {\\n                sum -= bound;\\n                bound--;\\n            } else {\\n                x++;\\n            }\\n        }\\n        return ans + 1; // plus 1 represents the number itself\\n    }\\n```\\n\\nFirst Optimal - calculate `x` by using `(N - sum) / n`:\\n```\\npublic int consecutiveNumbersSum(int n) {\\n        int bound = (int) (-0.5 + Math.sqrt(0.25 + 2 * n) + 0.5);\\n        int sum = (1 + bound) * bound / 2;\\n        int x = 0;\\n        int count = 0;\\n        while (bound > 1) {\\n            int formula = sum + bound * x;\\n            if (formula == n) {\\n                count++;\\n                sum -= bound;\\n                bound--;\\n            } else if (formula > n) {\\n                sum -= bound;\\n                bound--;\\n            } else {\\n                x = (int) ((n - sum) / bound + 0.5); // plus 0.5 to avoid round down\\n            }\\n        }\\n        return ans + 1; // plus 1 represents the number itself\\n    }\\n```\\n\\nLast Optimal - check if x is an integer:\\nIn other words, `(n - sum) = x * bound` AND `x should be integer`, so `(n - sum) % bound == 0`.\\nWe need to make sure that there exists an integer x such that x * bound + sum == N.  \\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int n) {\\n        int bound = (int) (-0.5 + Math.sqrt(0.25 + 2 * n) + 0.5);\\n        int count = 0;\\n        while (bound >= 1) {\\n            int sum = (1 + bound) * bound / 2;\\n            if ((n - sum) % bound == 0) {\\n                count++;\\n            }\\n            bound--;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int n) {\\n        if (n <= 2) return 1;\\n        int[] arr = new int[n / 2 + 1];\\n\\t\\t// it is because (n / 2) + (n / 2 + 1) >= n   \\n\\t\\t// e.g. if n = 11, then 6 will be enough for the length of the array\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = i + 1;\\n        }\\n        int left = 0;\\n        int right = 0;\\n        int sum = 0;\\n        int ans = 1;\\n        while (right < arr.length) {\\n            sum += arr[right];\\n            right++;\\n            while (sum >= n) {\\n                if (sum == n) {\\n                    ans++;\\n                }\\n                sum -= arr[left];\\n                left++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\npublic int consecutiveNumbersSum(int n) {\\n        // Math.sqrt(1 + 8 * n) * 1/2 will cause overflow, which is = Math.sqrt(0.25 + 2 * n)\\n        int bound = (int) (-0.5 + Math.sqrt(0.25 + 2 * n) + 0.5);\\n        int sum = (1 + bound) * bound / 2;\\n        int x = 0;\\n        int count = 0;\\n        while (bound > 1) {\\n            int formula = sum + bound * x;\\n            if (formula == n) {\\n                count++;\\n                sum -= bound;\\n                bound--;\\n            } else if (formula > n) {\\n                sum -= bound;\\n                bound--;\\n            } else {\\n                x++;\\n            }\\n        }\\n        return ans + 1; // plus 1 represents the number itself\\n    }\\n```\n```\\npublic int consecutiveNumbersSum(int n) {\\n        int bound = (int) (-0.5 + Math.sqrt(0.25 + 2 * n) + 0.5);\\n        int sum = (1 + bound) * bound / 2;\\n        int x = 0;\\n        int count = 0;\\n        while (bound > 1) {\\n            int formula = sum + bound * x;\\n            if (formula == n) {\\n                count++;\\n                sum -= bound;\\n                bound--;\\n            } else if (formula > n) {\\n                sum -= bound;\\n                bound--;\\n            } else {\\n                x = (int) ((n - sum) / bound + 0.5); // plus 0.5 to avoid round down\\n            }\\n        }\\n        return ans + 1; // plus 1 represents the number itself\\n    }\\n```\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int n) {\\n        int bound = (int) (-0.5 + Math.sqrt(0.25 + 2 * n) + 0.5);\\n        int count = 0;\\n        while (bound >= 1) {\\n            int sum = (1 + bound) * bound / 2;\\n            if ((n - sum) % bound == 0) {\\n                count++;\\n            }\\n            bound--;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435209,
                "title": "simple-maths-c",
                "content": "```\\nint consecutiveNumbersSum(int n) \\n    {\\n        int ans=0;\\n        for(int k=1;2*n>k*(k-1);k++)\\n        {\\n            int numerator = n - (k*(k-1)/2);\\n            if(numerator%k==0)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\nint consecutiveNumbersSum(int n) \\n    {\\n        int ans=0;\\n        for(int k=1;2*n>k*(k-1);k++)\\n        {\\n            int numerator = n - (k*(k-1)/2);\\n            if(numerator%k==0)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2421524,
                "title": "python-extremely-simple-faster-than-88",
                "content": "i represents the number of consecutive numbers you\\'re trying. Since you are looking values of a that satisfy the following:\\na = n\\n(a)+(a+1) = n\\n(a)+(a+1)+(a+2) = n\\n...\\nYou can subtract the constants and see if its divisible by the number of \"a\"s.\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        res=0\\n        i=0\\n        while n>0:\\n            i+=1\\n            if n%i==0:\\n                res+=1\\n            n-=i\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        res=0\\n        i=0\\n        while n>0:\\n            i+=1\\n            if n%i==0:\\n                res+=1\\n            n-=i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379525,
                "title": "python-long-math-explanation-o-sqrt-n-worst-case-o-log-n-best-case",
                "content": "```python\\n# For every odd divisor d of n, there\\'s exactly one sum of length d, e.g.\\n#\\n#     21 = 3 * 7 = 6 + 7 + 8.\\n#\\n# Also, every odd length sum is of this form, since the middle value is average,\\n# and the sum is just (number of elements) * (average) = d * n/d.\\n#\\n# For even length sums, the average is a half-integer\\n#\\n#     2 + 3 + 4 + 5 = 4 * 3.5\\n#\\n# So n can be written as\\n#\\n#     n = (even length) * (half-integer average)\\n#       = (2 * c) * (d / 2)\\n#       = c * d\\n#\\n# for some arbitrary integer c and odd integer d. So again, any odd d divisor of\\n# n produces an even length sum, and every even length sum is of this form.\\n#\\n# However, we need to ensure that the sum only contains positive integers.\\n#\\n# For the first case, the smallest number is n/d - (d-1)/2. For the second case,\\n# it\\'s (d+1)/2 - n/d.\\n#\\n# For all d, exactly one of these is positive, and so every odd divisor\\n# corresponds to exactly one sum, and all sums are of this form.\\n#\\n# Therefore, we need to count the odd divisors.\\n#\\n# There\\'s no way I know of doing this without essentially factoring the number.\\n# So say\\n#\\n#     n = 2**n0 * p1**n1 * p2**n2 * ... * pk**nk\\n#\\n# is the prime decomposition (all p are odd). Then n has\\n#\\n#     (n1+1) * (n2+1) * ... * (nk+1)\\n#\\n# odd divisors.\\n#\\n# For the implementation, we search the smallest divisor, which is neccessarily\\n# prime and divide by it as often as possible (and count the divisions). If\\n# after that p**2 > n, we know that n itself is prime.\\n#\\n# Complexity is O(sqrt(n)) in bad cases (if n is prime), but can be much better\\n# if n only has small prime factors, e.g. for n = 3**k it\\'s O(k) = O(log(n)).\\n\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        while n % 2 == 0:\\n            # Kill even factors\\n            n //= 2\\n        result = 1\\n        p = 3\\n        while n != 1:\\n            count = 1\\n            while n % p == 0:\\n                n //= p\\n                count += 1\\n            result *= count\\n            if p**2 >= n:\\n                # Rest of n is prime, stop here\\n                if n > p:\\n                    # We have not counted n yet\\n                    result *= 2\\n                break\\n            p += 2\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n# For every odd divisor d of n, there\\'s exactly one sum of length d, e.g.\\n#\\n#     21 = 3 * 7 = 6 + 7 + 8.\\n#\\n# Also, every odd length sum is of this form, since the middle value is average,\\n# and the sum is just (number of elements) * (average) = d * n/d.\\n#\\n# For even length sums, the average is a half-integer\\n#\\n#     2 + 3 + 4 + 5 = 4 * 3.5\\n#\\n# So n can be written as\\n#\\n#     n = (even length) * (half-integer average)\\n#       = (2 * c) * (d / 2)\\n#       = c * d\\n#\\n# for some arbitrary integer c and odd integer d. So again, any odd d divisor of\\n# n produces an even length sum, and every even length sum is of this form.\\n#\\n# However, we need to ensure that the sum only contains positive integers.\\n#\\n# For the first case, the smallest number is n/d - (d-1)/2. For the second case,\\n# it\\'s (d+1)/2 - n/d.\\n#\\n# For all d, exactly one of these is positive, and so every odd divisor\\n# corresponds to exactly one sum, and all sums are of this form.\\n#\\n# Therefore, we need to count the odd divisors.\\n#\\n# There\\'s no way I know of doing this without essentially factoring the number.\\n# So say\\n#\\n#     n = 2**n0 * p1**n1 * p2**n2 * ... * pk**nk\\n#\\n# is the prime decomposition (all p are odd). Then n has\\n#\\n#     (n1+1) * (n2+1) * ... * (nk+1)\\n#\\n# odd divisors.\\n#\\n# For the implementation, we search the smallest divisor, which is neccessarily\\n# prime and divide by it as often as possible (and count the divisions). If\\n# after that p**2 > n, we know that n itself is prime.\\n#\\n# Complexity is O(sqrt(n)) in bad cases (if n is prime), but can be much better\\n# if n only has small prime factors, e.g. for n = 3**k it\\'s O(k) = O(log(n)).\\n\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        while n % 2 == 0:\\n            # Kill even factors\\n            n //= 2\\n        result = 1\\n        p = 3\\n        while n != 1:\\n            count = 1\\n            while n % p == 0:\\n                n //= p\\n                count += 1\\n            result *= count\\n            if p**2 >= n:\\n                # Rest of n is prime, stop here\\n                if n > p:\\n                    # We have not counted n yet\\n                    result *= 2\\n                break\\n            p += 2\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353539,
                "title": "python-quick-maths-slightly-different-from-other-solns",
                "content": "If n can be written as the sum of consecutive integers, say from y+1, y+2,  ..., x, then it is also the difference between the sum of the first x positive integers and the first y positive integers. Thus, we can write\\nn = x(x+1)/2-y(y+1)/2<=>\\n8n = 4x^2+4x+1-(4y^2+4y+1)<=>\\n8n =(2x+1)^2 - (2y+1)^2<=>\\n8n = (2x-2y)(2x+2y+2)<=>\\n2n = (x-y)(x+y+1)\\nThe main observation is now that x-y, x+y+1 have different parities, since they differ by 2y+1 which is an odd number.\\n\\nThus, we get a solution (x,y) corresponding to each pair of divisors of different parities of 2n.  It suffices then to cycle through all i from 1 to floor of root(2n) and check whether \\na) i divides 2n\\nb) whether 2n/i and i have the same parity\\n\\ncode included for completion:\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        count = 0\\n        k = floor(math.sqrt(2*n))\\n        for i in range(1,k+1):\\n            if (2*n)%i==0 and (2*n/i+i)%2!=0:\\n                count +=1\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        count = 0\\n        k = floor(math.sqrt(2*n))\\n        for i in range(1,k+1):\\n            if (2*n)%i==0 and (2*n/i+i)%2!=0:\\n                count +=1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307850,
                "title": "golang-unittest-runtime-4-ms-faster-than-100-00-of-go-online-submissions",
                "content": "```golang\\nfunc consecutiveNumbersSum(n int) int {\\n\\tif n <= 2 {\\n\\t\\treturn 1\\n\\t}\\n\\t// x = n/r - (r-1)/2  --> Find integer of x\\n\\tcount := 1\\n\\tx := 0.0\\n\\tfor r := 2.0; r*r < float64(2*n) && x >= 0; r++ {\\n\\t\\tx = (float64(n)/r - float64(r-1)/2)\\n\\t\\tif x > 0 && x == float64(int(x)) {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n```\\nUnit test: https://github.com/nitro2/leetcode/tree/master/consecutive-numbers-sum",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```golang\\nfunc consecutiveNumbersSum(n int) int {\\n\\tif n <= 2 {\\n\\t\\treturn 1\\n\\t}\\n\\t// x = n/r - (r-1)/2  --> Find integer of x\\n\\tcount := 1\\n\\tx := 0.0\\n\\tfor r := 2.0; r*r < float64(2*n) && x >= 0; r++ {\\n\\t\\tx = (float64(n)/r - float64(r-1)/2)\\n\\t\\tif x > 0 && x == float64(int(x)) {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2286805,
                "title": "one-liner",
                "content": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int ans = 0; for(int i=1; i<=sqrt(2*n-1); i++) if((n-i*(i-1)/2)%i==0) ++ans; return ans;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int ans = 0; for(int i=1; i<=sqrt(2*n-1); i++) if((n-i*(i-1)/2)%i==0) ++ans; return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241744,
                "title": "c-easy-solution-with-o-sqrt-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        long long int k=n;\\n        if(k<3)\\n            return 1;\\n        int count=0;\\n        for(long long int i=1;i*i<=k;i++)\\n        {\\n            if(k%2==0)\\n            {\\n                if(k%i==0)\\n                {\\n                    if(i!=k/i)\\n                    {\\n                         if((i%2==1)||((k/i)%2==1))\\n                            count++;\\n                    }\\n                    else if(i%2==1)\\n                        count++;\\n                }\\n            }\\n            else if(k%2==1)\\n            {   if(k%i==0)\\n            {\\n                if(k/i!=i)\\n                    count+=2;\\n                else\\n                    count++;\\n            }}\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Enumeration"
                ],
                "code": "class Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        long long int k=n;\\n        if(k<3)\\n            return 1;\\n        int count=0;\\n        for(long long int i=1;i*i<=k;i++)\\n        {\\n            if(k%2==0)\\n            {\\n                if(k%i==0)\\n                {\\n                    if(i!=k/i)\\n                    {\\n                         if((i%2==1)||((k/i)%2==1))\\n                            count++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2184704,
                "title": "c-2-liner-branchless-w-o-analysis-it-just-works-3-4ms",
                "content": "```\\n// modificaz 2022\\nint consecutiveNumbersSum(int n) {\\n\\n  int i, res = 0; int const k = (int) floor(sqrt(2) * sqrt(n)), dn = 2 * n, o = !!(n % 2);\\n  \\n  for (i = 2; i <= k; i += 2) res += (!(dn % i) && (o || (n % i)));\\n  for (i = 3; i <= k; i += 2) res += !(n % i);\\n\\n  return ++res;\\n}\\n```\\n# Pros\\n1. Even and Odd Loops (100% Parallelizable)\\n2. Optimizations for odd n, and for i = 1 (LOL)\\n3. Constants are constants and variables are variables (Compiler love)\\n\\n# Cons\\n1. gcc 8.2 -O1 doesn\\'t like my branchless (Compiler hate)\\n2. There is a lot of sorcery here -- I don\\'t know exactly what I\\'m doing but it works.\\n\\n# What\\'s happening\\n* Like other implementations, except that it also checks divisibility of `dn = 2 * n`\\n\\n**Tips and suggestions more than welcome**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// modificaz 2022\\nint consecutiveNumbersSum(int n) {\\n\\n  int i, res = 0; int const k = (int) floor(sqrt(2) * sqrt(n)), dn = 2 * n, o = !!(n % 2);\\n  \\n  for (i = 2; i <= k; i += 2) res += (!(dn % i) && (o || (n % i)));\\n  for (i = 3; i <= k; i += 2) res += !(n % i);\\n\\n  return ++res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2104232,
                "title": "for-human-beings-in-primary-school",
                "content": "Too many black magics in this thread, looks very difficult to understand for normal human being people, here is one solution, easy enough to understand even for primary school kids!\\n\\n```c++\\nclass Solution {\\n  public:\\n    int consecutiveNumbersSum(int n) {\\n        int result = 0;\\n        // _n meas the length of consecutive numbers, obviously the shortest is\\n        // 1, think about the longest, to make it longer, should as small as\\n        // possible, it must start with 1, ends at _n, also sum([1, ..., _n])\\n        // should not greater than n\\n        for (int _n = 1; _n * (1 + _n) / 2 <= n; ++_n) {\\n            // when it comes to even length[which means 0 == (1 & _n)]\\n            // the average of _n numbers has to be 0.5 + floor(n / _n)[which\\n            // means the 2*avg is odd]\\n            if ((0 == (1 & _n) && 0 == ((2 * n) % _n) &&\\n                 0 != (1 & (2 * n / _n))) ||\\n                // on the other hand, when it comes to odd length, all we need\\n                // is n can be divided by _n in piece\\n                (0 != (1 & _n) && 0 == (n % _n))) {\\n                ++result;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\n  public:\\n    int consecutiveNumbersSum(int n) {\\n        int result = 0;\\n        // _n meas the length of consecutive numbers, obviously the shortest is\\n        // 1, think about the longest, to make it longer, should as small as\\n        // possible, it must start with 1, ends at _n, also sum([1, ..., _n])\\n        // should not greater than n\\n        for (int _n = 1; _n * (1 + _n) / 2 <= n; ++_n) {\\n            // when it comes to even length[which means 0 == (1 & _n)]\\n            // the average of _n numbers has to be 0.5 + floor(n / _n)[which\\n            // means the 2*avg is odd]\\n            if ((0 == (1 & _n) && 0 == ((2 * n) % _n) &&\\n                 0 != (1 & (2 * n / _n))) ||\\n                // on the other hand, when it comes to odd length, all we need\\n                // is n can be divided by _n in piece\\n                (0 != (1 & _n) && 0 == (n % _n))) {\\n                ++result;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091749,
                "title": "average-thinking-with-explanation",
                "content": "1. With k consecutive numbers from i1..ik and sum of i1..ik = n we have n = average * k, ex:\\n- 3 = 1 + 2, average = 1.5 * 2 = 3 \\n- 6 = 1 + 2 + 3, average = 2 * 3 = 6\\n2. So we just need to count 2 cases\\n- k is odd and average is integer\\n- k is even and average is integer and half\\n3. And the condition i1 must >= 1\\n```\\nint consecutiveNumbersSum(int n) {\\n\\tint ans = 0;\\n\\tfor (int k = 1; k <= n; k++) {\\n\\t\\t// double of average (n / k) need to be >= k as i1 >= 1 && ik >= k \\n\\t\\tif (2 * n / k < k) break;\\n\\n\\t\\tif (k % 2) {    // is odd\\n\\t\\t\\tif (!(n % k)) ans++;    // average is integer\\n\\t\\t} else {    // is even\\n\\t\\t    // average is integer and half\\n            // => average is not integer and double average is integer\\n\\t\\t\\tif (!(2 * n % k) && (n % k))    ans++;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nint consecutiveNumbersSum(int n) {\\n\\tint ans = 0;\\n\\tfor (int k = 1; k <= n; k++) {\\n\\t\\t// double of average (n / k) need to be >= k as i1 >= 1 && ik >= k \\n\\t\\tif (2 * n / k < k) break;\\n\\n\\t\\tif (k % 2) {    // is odd\\n\\t\\t\\tif (!(n % k)) ans++;    // average is integer\\n\\t\\t} else {    // is even\\n\\t\\t    // average is integer and half\\n            // => average is not integer and double average is integer\\n\\t\\t\\tif (!(2 * n % k) && (n % k))    ans++;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067375,
                "title": "c-easy-to-understand-mathematical-approach",
                "content": "consider the number lets say 5 the ans will start with 1 as there is a way to write 5 as 5 now for the other cases.lets start with i=2;\\nnow the sum of first i will be given by i*(i+1)/2; now we need a sum of n\\nconsider y=n-i*(i+1)/2;\\nif this sum can be fitted in that i space then increment it and since the loop is increasing whenever y become negative break the loop as no further increament is possible.\\n\\nHere is the code:\\n\\n```\\nif(n==1)\\n        {\\n            return 1;\\n        }\\n        int ans=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            long long s1=i*(i+1);\\n            long long s=s1/2;\\n            long long y=n-s;\\n            // cout<<y<<\" \"<<i<<\\'\\\\n\\';\\n            if(y<0)\\n            {\\n                break;\\n            }\\n            double x=((double)y)/i;\\n            long long x1=x;\\n            if(x==x1)\\n            {\\n                // cout<<x<<\\'\\\\n\\';\\n                ans++;\\n            }\\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nif(n==1)\\n        {\\n            return 1;\\n        }\\n        int ans=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            long long s1=i*(i+1);\\n            long long s=s1/2;\\n            long long y=n-s;\\n            // cout<<y<<\" \"<<i<<\\'\\\\n\\';\\n            if(y<0)\\n            {\\n                break;\\n            }\\n            double x=((double)y)/i;\\n            long long x1=x;\\n            if(x==x1)\\n            {\\n                // cout<<x<<\\'\\\\n\\';\\n                ans++;\\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2016573,
                "title": "c-different-approach-to-discussion-explained-no-complex-formula-o-sqrt-n",
                "content": "Consider the case where you\\'re trying to find a k-digit summation for n.\\nStart with sum of the first k digits, `kSum1 = 1+2+3+...+k`\\nIf this sum does not work, then the next value of `kSum` would be calculated by subtracting `1` and adding `k+1` (lets call this `kSum2`).\\n`kSum2 = kSum1 + k+1 - 1` or `kSum2 = kSum1 + k`\\nNow if this does not work either, let\\'s calculate `kSum3`\\n`kSum3 = kSum2 + k+2 - 2` or `kSum3 = kSum2 + k`\\n\\nAs you can see, the increment each time is `k`. If there really exists a solution with `k` digits, then `n = kSum1 + m*k` or `n-kSum1 = m*k`. So, for any `k`, it is sufficient to check if `n-kSum1` is divisible by `k`. Till when do you check? Till the time `kSum1` (called `startSum` in the code below) becomes greater than `n`.\\n\\nLet\\'s understand time complexity.\\nThe loop stops when the sum of first `k` numbers becomes greater than `n`.\\nSum of first `k` numbers = `k*(k+1)/2`\\nCalculating the sum means we run the loop `k` times.\\nSo time complexity = `O(k)`\\n\\nTherefore, our stop condition is\\n`k*(k+1)/2 = n` (Ignoring the > sign as that would only mean one more iteration)\\n`k^2 + k = 2n`\\n`k = (-1 +- sqrt(1+4n))/2`\\n\\nTherefore, time complexity in terms of n = `O(sqrt(n))`\\n\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int i = 1;\\n        int count = 0;\\n        int startSum = 1;\\n        \\n        while(startSum<=n) {\\n            int sumToMake = n-startSum;\\n            if(sumToMake%i==0) {\\n                count++;\\n            }\\n            i++;\\n            startSum += i;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int i = 1;\\n        int count = 0;\\n        int startSum = 1;\\n        \\n        while(startSum<=n) {\\n            int sumToMake = n-startSum;\\n            if(sumToMake%i==0) {\\n                count++;\\n            }\\n            i++;\\n            startSum += i;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928875,
                "title": "python3-simple-math-solution",
                "content": "\\tdef consecutiveNumbersSum(self, n: int) -> int:\\n\\t\\t\\ts=0\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor i in range(1,n+1):\\n\\t\\t\\t\\ts+=i-1\\n\\t\\t\\t\\tif s>=n:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif (n-s)%i==0:\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\treturn count",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "\\tdef consecutiveNumbersSum(self, n: int) -> int:\\n\\t\\t\\ts=0\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor i in range(1,n+1):\\n\\t\\t\\t\\ts+=i-1\\n\\t\\t\\t\\tif s>=n:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif (n-s)%i==0:\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\treturn count",
                "codeTag": "Python3"
            },
            {
                "id": 1872746,
                "title": "c-math-solution-based-on-integer-factorization",
                "content": "### Code\\n```cpp\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        n >>= __builtin_ctz(n);\\n        int d = 1;\\n        for (int i = 3; i * i <= n; i += 2)\\n        {\\n            int c = 1;\\n            while (!(n % i))\\n            {\\n                n /= i;\\n                ++c;\\n            }\\n            d *= c;\\n        }\\n        return n > 1 ? d + d : d;\\n    }\\n};\\n```\\n### Explanation\\nThe code merely calculates and returns the number of odd factors of `n`.\\n### Reasoning\\n* For a positive integer `x`, let `mp2(x) = argmax_b b|x` s.t. `b` is power of `2`.\\n* `n` should be written as `n = a + (a+1) + (a+2) ... (a+m-1) = m(2a+m-1)/2`, or equivalently `2n = m(2a+m-1)` for some positive integer `a` and `m`.\\n* An observation is that `m` and `2a+m-1` must have differnt parity, so `mp2(m)` must equals to either `1` or `mp2(n)`.\\n* Consider two odd factors `i` and `j` of `n` s.t. `ij = n/mp2(n)`, then we have 4 cases:\\n  + `m = i`, `2a+m-1 = j*mp(2)`\\n  + `m = i*mp(2)`, `2a+m-1 = j`\\n  + `m = j`, `2a+m-1 = i*mp(2)`\\n  + `m = j*mp(2)`, `2a+m-1 = i`\\n* It can be verified that there are exactly 2 cases satisfying `a > 0` and they are equivalent if `i = j`\\n* So every ordered odd factor pair `(i, j)` maps to a single consecutive number sum.\\n* So the final answer can be computed by calculating the number of odd factors of `n`.",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        n >>= __builtin_ctz(n);\\n        int d = 1;\\n        for (int i = 3; i * i <= n; i += 2)\\n        {\\n            int c = 1;\\n            while (!(n % i))\\n            {\\n                n /= i;\\n                ++c;\\n            }\\n            d *= c;\\n        }\\n        return n > 1 ? d + d : d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1835341,
                "title": "java-solution-with-math-explanation",
                "content": "This one is my own solution that I used my math knowledge to deliver.  There are some rules in the numbers and I observed it and deliver this solution:\\n\\n2 numbers, n%2 need to  be 1  and n need to be >=3\\n3 numbers, n% 3 need to be  0 and n need to be  >= 6\\n4 numbers, n%4 need to be 2 and n need to be >= 10\\n5 numbers, n%5 need to be  0 and n need to be  >=  15\\n6 numbers, n%6 need to be 3 and n need to be >= 21\\n7 numbers, n%7 need to be  0 and n need to be  >= 28\\n\\n=> For even numbers, n need to be >= (i * i+i)/2 and n%i == i/2\\n=> For odd numbers, n need to be >= i * (i/2+1) and n%i == 0\\n\\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int n) {\\n        int count = 1;\\n        for(int i = 2; i < n; i++){\\n            \\n            if(i % 2 == 0){ // for even number of consecutive numbers\\n                if((i*i+i)/2 > n){\\n                    break; //avoid further checking \\n                }\\n                if(n >= (i*i+i)/2 && n % i == i/2){\\n                    count++; \\n                }\\n            }else{ //for odd\\n                if(i*(i/2 + 1) > n){\\n                    break;\\n                }\\n                if(n >= i*(i/2 + 1) && n % i == 0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int n) {\\n        int count = 1;\\n        for(int i = 2; i < n; i++){\\n            \\n            if(i % 2 == 0){ // for even number of consecutive numbers\\n                if((i*i+i)/2 > n){\\n                    break; //avoid further checking \\n                }\\n                if(n >= (i*i+i)/2 && n % i == i/2){\\n                    count++; \\n                }\\n            }else{ //for odd\\n                if(i*(i/2 + 1) > n){\\n                    break;\\n                }\\n                if(n >= i*(i/2 + 1) && n % i == 0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819603,
                "title": "simple-two-pointer-non-mathematical-o-n-solution-exceeds-time-limit-though",
                "content": "The idea is to maintain a left and right pointer and continuously adjust the window so that their sum <= n. \\n\\n```\\n    public int consecutiveNumbersSum(int n) {\\n        int ways = 0;\\n        \\n        int sum = 0;\\n        int left = 1, right = 1;\\n        while (right <= n) {\\n            sum += right;\\n            while (sum > n) {\\n                sum = sum - left;\\n                left++;\\n            }\\n            if (sum == n) {\\n                ways++;\\n            }\\n            right++;\\n        }\\n        \\n        return ways;\\n    }",
                "solutionTags": [],
                "code": "The idea is to maintain a left and right pointer and continuously adjust the window so that their sum <= n. \\n\\n```\\n    public int consecutiveNumbersSum(int n) {\\n        int ways = 0;\\n        \\n        int sum = 0;\\n        int left = 1, right = 1;\\n        while (right <= n) {\\n            sum += right;\\n            while (sum > n) {\\n                sum = sum - left;\\n                left++;\\n            }\\n            if (sum == n) {\\n                ways++;\\n            }\\n            right++;\\n        }\\n        \\n        return ways;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1777599,
                "title": "c-most-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int x) {\\n        if(x<=2){\\n            return 1;\\n        }\\n        int ans=0;\\n        int st=3;int diff=2; //  for two elements\\n        // for three elements diff++ st+=num of elements\\n        while(st<=x){\\n            if((x-st)%diff==0){\\n                ans++;\\n            }\\n            diff++;\\n            st+=diff;\\n        }\\n        \\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int x) {\\n        if(x<=2){\\n            return 1;\\n        }\\n        int ans=0;\\n        int st=3;int diff=2; //  for two elements\\n        // for three elements diff++ st+=num of elements\\n        while(st<=x){\\n            if((x-st)%diff==0){\\n                ans++;\\n            }\\n            diff++;\\n            st+=diff;\\n        }\\n        \\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777109,
                "title": "java-simple-solution",
                "content": "class Solution {\\n    public int consecutiveNumbersSum(int n) {\\n              int count = 0;\\n        for(int i = 1; i*(i+1)/2<=n; i++){\\n            if((n-(i*(i+1)/2))%i==0) count++;\\n        }\\n        return count;\\n    }\\n}\\n\\n// Space Complexity: O(1)\\n//Time Complexity: O(  sqrt(N  )  ).",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n    public int consecutiveNumbersSum(int n) {\\n              int count = 0;\\n        for(int i = 1; i*(i+1)/2<=n; i++){\\n            if((n-(i*(i+1)/2))%i==0) count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1724943,
                "title": "javascript-js-solution-full-explained-easy-understand-beat-100-time-complexity",
                "content": "\"\\n\"\\nFirst thing we can observe, if number n can be divided into different number of consecutive integers, then the every possible of combination is only one. For example, 15 can be divided to 5 numbers, and can only be [1,2,3,4,5]. No second possiblility.  If 15 is divided into 3 numbers, it can only be [4,5,6].\\n\\nThe second point is that if the number can be divided into odd number of integers, such as [1,2,3,4,5] or [3,4,5,6,7]. You can find that the middle one is the average of the sequence sum (the average of the number  n ).\\n\\nAnd if the number can be divided into even number of integers, such as [1,2,3,4] or [3,4,5,6,7,8]. We will know that the average of the sequence sum is some integer plus 0.5 \\n(For Example:  for number 15.  It can be divided by 3, the result is 5, and the following sequence is [4,5,6] (5 is the middle of the sequence),  is an answer; it can be divided by 5, the result is 3,  and the following sequence is [1,2,3,4,5] ( 3 is the middle of the sequence), is another answer. If it is divided by 2, the answer is 7.5, and the sequence is [7,8], is another answer. But if it is divided by 4, the result is 3.75, is not possible to form a consecutive sequence)\\n\\nBecause the sum of the sequence is the number  n   itself, so we can iterate the interger   i   from number 2 to n, and do the following calculation.  If   i   is odd, and the module of   n   divide   i   is  0; or if   i   is even , and if the module of   n   divide   i  is 0.5 , then this is the one of the answers we are looking for.\\n(The actual calculations need to be modified to fit the program)\\n(The number itself is an answer, we don\\'t need to calculate the number   n  divide 1.  So we iterate   i  from 2.  And set the result initially to be 1)\\n\\nAnd last thing is we don\\'t need to iterate the divisor up to n, such as 15 to form [1,2,3,4,5], is the last possible answer. If we divide 15 into more numbers,  the result could be less than 1, that is a wrong answer. So we can find out the terminate situation is the quotient of number  n  and the divisor i (for example the number 3 in sequence [1,2,3,4,5] from number 15) (need to be floor down) minus the half of the length(  i   /  2, floor down) is less than 1, then we break the iteration.\\n\\nThis is how I implement the code. I also notice some guys have more effiencient solutions, I can\\'t figure out at the first glance. But I think this approach is easy to understand, so I post it. This approach beat 100% time complexity :)\\n\\n```\\nvar consecutiveNumbersSum = function(n) {\\n    let result = 1;\\n    for (let i = 2; i <= n; i++) {\\n        if (n / i < Math.floor((i + 1) / 2)) break;\\n        if (i % 2) {\\n            if (n % i === 0) result++;\\n        } else {\\n            if ((n / i) * 10 - Math.floor(n / i) * 10 === 5) result++;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar consecutiveNumbersSum = function(n) {\\n    let result = 1;\\n    for (let i = 2; i <= n; i++) {\\n        if (n / i < Math.floor((i + 1) / 2)) break;\\n        if (i % 2) {\\n            if (n % i === 0) result++;\\n        } else {\\n            if ((n / i) * 10 - Math.floor(n / i) * 10 === 5) result++;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679537,
                "title": "java-explained-maths-explained-if-condition",
                "content": "// Let us assume that to find CONSECUTIVE numbers which will ADD up to make N starts with \\'x\\'. SO we have following \\'k\\' numbers starting from \\'x\\' and ending at x + (k - 1) that will ADD up to \\'n\\'\\n\\n// (x + 0) + (x + 1) + (x + 2) + ... + (x + (k - 2)) + (x + (k - 1)) = n\\n// There are \\'k\\' \\'x\\' + (0 + 1 + 2 + ... + k -1) => k*x + (0 + 1 + 2 + ... + k -1)\\n// => k*x + (k - 1) * ((k - 1) + 1)/2 = n (sum of \\'n\\' num starting from 1 is n * (n + 1)/2) (in our case, n = k - 1)\\n// => k*x = n - k * (k - 1)/2 (LHS = RHS) (x = (n - k * (k - 1)/2)/k) => see explanation for using it below in code\\n// Now, k > 0 & x > 0 so LHS > 0, that means \\n// => n - k * (k - 1)/2 > 0 => n > k * (k - 1)/2\\n// => 2n > k * (k - 1) => sqrt(2n) > k\\n\\n// TC : O(sqrt(n))\\n// SC : O(1)\\n```\\nclass Solution {\\n    public int consecutiveNumbersSum(int n) {\\n        int count = 1;\\n        for(int k = 2; k <= Math.sqrt(2 * n); k++) {\\n            if((n - (k * (k - 1)/2)) % k == 0) { // if for any value of \\'k\\' starting at 2, if RHS in above explanation is MULTIPLE of \\'k\\' that means we can find \\'x\\' from where a SEQUENCE needs to start to form a sum \\'n\\'\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int n) {\\n        int count = 1;\\n        for(int k = 2; k <= Math.sqrt(2 * n); k++) {\\n            if((n - (k * (k - 1)/2)) % k == 0) { // if for any value of \\'k\\' starting at 2, if RHS in above explanation is MULTIPLE of \\'k\\' that means we can find \\'x\\' from where a SEQUENCE needs to start to form a sum \\'n\\'\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676154,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int count = 0;\\n        int i = 1;\\n        while(n > 0){\\n            n -= i;\\n            if(n % i == 0)\\n                count++;\\n            i++;\\n        }\\n        return count;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int count = 0;\\n        int i = 1;\\n        while(n > 0){\\n            n -= i;\\n            if(n % i == 0)\\n                count++;\\n            i++;\\n        }\\n        return count;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589447,
                "title": "c-maths-based-approach-with-explanation",
                "content": "/*\\n\\n\\nFor a given integer N, any set of consecutive integers can only add up once (unique) to value N. Example, for number 5, there is only one (unique) set of two consecutive positive integers that add up to 5, i.e, 2 + 3. There is no other set of two consecutive positive integers that add up to 5 (1+2 or 3+4 not equal to 5, only 2+3 is equal to 5). This is the case for three, four, or any other set of consecutive positive integers.\\n\\nNow, how to check efficiently if N can be formed from a given set of consecutive positive integers (two, three, four, etc.)? The first integer that can be formed  from sum of n consecutive positive integers is n (n+1) / 2, which is the formula for summation of n numbers. Example, for n = 5, the first integer that can be formed is 15 (1+2+3+4+5). The next integer that can be formed from sum of n consecutive positive integers is 15 + 5  = 20 (2+3+4+5+6). The next after that is 15 + 5 + 5 = 25(3+4+5+6+7), and so on. So to check if N can be formed from five consecutive integers in this example, I just have to check if N - (summation of n consecutive integers) is divisible by n. If it is, I can say that N can be formed from some set of 5 consecutive integers. For example, for N = 20 and n = 3, if 20 - (1+2+3), which is 14 is divisible by 3 (it\\'s not), then this means that I cannot express 20 by any combination of three consecutive positive integers.\\n\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        \\n        int count=1;\\n        \\n        for(int n=2;n*(n+1)<=2*N;n++){\\n            \\n            if((N-((n*(n+1))/2))%n==0){\\n                count++;\\n            }\\n            \\n        }\\n        \\n        return count;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        \\n        int count=1;\\n        \\n        for(int n=2;n*(n+1)<=2*N;n++){\\n            \\n            if((N-((n*(n+1))/2))%n==0){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1573774,
                "title": "java-33-ok-let-s-pretend-they-are-not-interviewing-rocket-scientists",
                "content": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int n) {\\n        int res=1; // set 1, for every number n itself is one solution\\n        for(int i=2;i<=n;i++){\\n\\t\\t\\t//i is how many integers to do the sum\\n            boolean iIsOdd=i%2!=0; \\n            int k=n/i;\\n\\t\\t\\t// only positive integer is allowed , so i can not be too large\\n            if(i/2.0>k){  \\n                break;\\n            }\\n            int r=n%i;\\n\\t\\t\\t\\n\\t\\t\\t// list some numbers, and you can see this pattern\\n                if(r==0&&iIsOdd){\\n\\t\\t\\t\\t//15 = 1+2+3+4+5  5 integers, 5 is odd number, 15%5=0\\n                    res++;\\n                }else if(!iIsOdd && r*2==i){\\n\\t\\t\\t\\t// 10 = 1+2+3+4    4 integers, 4 is even number, 10%4=2  \\n                    res++;\\n                }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int n) {\\n        int res=1; // set 1, for every number n itself is one solution\\n        for(int i=2;i<=n;i++){\\n\\t\\t\\t//i is how many integers to do the sum\\n            boolean iIsOdd=i%2!=0; \\n            int k=n/i;\\n\\t\\t\\t// only positive integer is allowed , so i can not be too large\\n            if(i/2.0>k){  \\n                break;\\n            }\\n            int r=n%i;\\n\\t\\t\\t\\n\\t\\t\\t// list some numbers, and you can see this pattern\\n                if(r==0&&iIsOdd){\\n\\t\\t\\t\\t//15 = 1+2+3+4+5  5 integers, 5 is odd number, 15%5=0\\n                    res++;\\n                }else if(!iIsOdd && r*2==i){\\n\\t\\t\\t\\t// 10 = 1+2+3+4    4 integers, 4 is even number, 10%4=2  \\n                    res++;\\n                }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567149,
                "title": "java-sliding-window-tle",
                "content": "In my opinion this is a perfectly reasonable answer in an interview situation...\\n\\n```java\\npublic int consecutiveNumbersSum(int n) {\\n\\tif (n < 3) return 1;\\n\\tint max = n/2 + 1; // after this number solutions would always go over\\n\\tint count = 0;\\n\\n\\tint fast = 0;\\n\\tint slow = 0;\\n\\tint sum = 0;\\n\\twhile (fast <= max) {\\n\\t\\tif (sum <= n) {\\n\\t\\t\\tfast++;\\n\\t\\t\\tsum += fast;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tsum -= slow;\\n\\t\\t\\tslow++;\\n\\t\\t}\\n\\t\\tif (sum == n) {\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t}\\n\\treturn count + 1; // add 1 for the number itself\\n}\\n```\\n\\nO(N) time, O(1) space",
                "solutionTags": [],
                "code": "```java\\npublic int consecutiveNumbersSum(int n) {\\n\\tif (n < 3) return 1;\\n\\tint max = n/2 + 1; // after this number solutions would always go over\\n\\tint count = 0;\\n\\n\\tint fast = 0;\\n\\tint slow = 0;\\n\\tint sum = 0;\\n\\twhile (fast <= max) {\\n\\t\\tif (sum <= n) {\\n\\t\\t\\tfast++;\\n\\t\\t\\tsum += fast;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tsum -= slow;\\n\\t\\t\\tslow++;\\n\\t\\t}\\n\\t\\tif (sum == n) {\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t}\\n\\treturn count + 1; // add 1 for the number itself\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1556012,
                "title": "python-tle-but-recursive-with-memo-soln",
                "content": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        ans = 0\\n        memo = {}\\n        for i in range(1, n // 2 + 1):\\n            ans += self.helper(n, i, memo)\\n        return ans + 1\\n    \\n    def helper(self, n, cur, memo):\\n        if n == 0:\\n            return 1\\n        if n < cur:\\n            return 0\\n        if (n, cur) in memo:\\n            return memo[(n, cur)]\\n        ans = self.helper(n - cur, cur + 1, memo)\\n        memo[(n, cur)] = ans\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        ans = 0\\n        memo = {}\\n        for i in range(1, n // 2 + 1):\\n            ans += self.helper(n, i, memo)\\n        return ans + 1\\n    \\n    def helper(self, n, cur, memo):\\n        if n == 0:\\n            return 1\\n        if n < cur:\\n            return 0\\n        if (n, cur) in memo:\\n            return memo[(n, cur)]\\n        ans = self.helper(n - cur, cur + 1, memo)\\n        memo[(n, cur)] = ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550929,
                "title": "java-4-lines-super-easy-with-explanation",
                "content": "```\\n public int consecutiveNumbersSum(int n) {\\n        // each time subtract the number start from 1 and increment\\n        //then check if it is divisible by subtract number then inc counter 1\\n        \\n        int ans=0;\\n        int i=1;\\n        while(n > 0){\\n           n -= i;\\n           if(n%i == 0)\\n               ans++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n//example \\n/**\\nn=5\\nn=4\\n4%1 ==0 ans =1\\ni=2\\n\\nn=2\\n2%2 =0 ans =2\\ni=3\\n\\nn=-1 \\n-1%3==0 no so increment in ans\\ni=4\\n\\nbreak */\\n```",
                "solutionTags": [],
                "code": "```\\n public int consecutiveNumbersSum(int n) {\\n        // each time subtract the number start from 1 and increment\\n        //then check if it is divisible by subtract number then inc counter 1\\n        \\n        int ans=0;\\n        int i=1;\\n        while(n > 0){\\n           n -= i;\\n           if(n%i == 0)\\n               ans++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n//example \\n/**\\nn=5\\nn=4\\n4%1 ==0 ans =1\\ni=2\\n\\nn=2\\n2%2 =0 ans =2\\ni=3\\n\\nn=-1 \\n-1%3==0 no so increment in ans\\ni=4\\n\\nbreak */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529003,
                "title": "can-someone-help-with-memoization-here",
                "content": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int num) {\\n        int ans = 0;\\n    \\n        for (int i=1;i<num;i++) {\\n            ans += helper(num, i, 0);\\n        }\\n        \\n        return ans+1;\\n    }\\n    \\n    private static int helper(int num, int i, int sum) {\\n        if (num == sum) {\\n            return 1;\\n        }\\n        if (sum>num) return 0;\\n        \\n        return helper(num, i+1, sum+i);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int consecutiveNumbersSum(int num) {\\n        int ans = 0;\\n    \\n        for (int i=1;i<num;i++) {\\n            ans += helper(num, i, 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1507210,
                "title": "python3-math-explanations",
                "content": "# Assume k consecutive numbers, start from x\\n    # x + (x+1) + (x+2)+...(x+k-1) = N # k term\\n    # => kx + k*(k-1)/2 = N\\n    # => (N - k*(k-1)/2) = kx \\n    # => kx > 0 => check the bound of kx (condition1)\\n    # => x is integer => (N - k*(k-1)/2) % k == 0 (condition2)\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        ans = 0\\n        k = 1 \\n        while k <= n:\\n            kx = (n - k*(k-1)/2)\\n            # => kx > 0 => check the bound of kx (condition1)\\n            if kx <= 0: break\\n            # => x is integer => (N - k*(k-1)/2) % k == 0 (condition2)\\n            if kx % k == 0: ans += 1\\n            k +=1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "# Assume k consecutive numbers, start from x\\n    # x + (x+1) + (x+2)+...(x+k-1) = N # k term\\n    # => kx + k*(k-1)/2 = N\\n    # => (N - k*(k-1)/2) = kx \\n    # => kx > 0 => check the bound of kx (condition1)\\n    # => x is integer => (N - k*(k-1)/2) % k == 0 (condition2)\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        ans = 0\\n        k = 1 \\n        while k <= n:\\n            kx = (n - k*(k-1)/2)\\n            # => kx > 0 => check the bound of kx (condition1)\\n            if kx <= 0: break\\n            # => x is integer => (N - k*(k-1)/2) % k == 0 (condition2)\\n            if kx % k == 0: ans += 1\\n            k +=1\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 1505220,
                "title": "c-829-consecutive-numbers-sum",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int ans = 0; \\n        for (int x = 1; x*x < 2*n; ++x) \\n            if ((n - x*(x+1)/2) % x == 0) ++ans; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int ans = 0; \\n        for (int x = 1; x*x < 2*n; ++x) \\n            if ((n - x*(x+1)/2) % x == 0) ++ans; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489562,
                "title": "explained-o-sqrt-n",
                "content": "Appraoch : we will firstly calculate k = no of maximum consecutive numbers which sum upto n,\\nso obviously, we will count all the possible number of values i  from 2 upto k such that the sum of i values = n.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int res=1;\\n        double kb = n;\\n        int k=(sqrt(1+8*kb)-1)/2;\\n        for(int i=2;i<=k;i++){\\n             double x = ( kb/i - (float)(i-1)/(float)2);\\n             int y = x;\\n           \\n              if(x-y==0){\\n                  res++;\\n              }\\n        }\\n        return res;\\n\\n    }\\n};\\n```\\n time complexity : O(sqrt(n))\\n Do upvote if u like!\\n happy coding :)",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int res=1;\\n        double kb = n;\\n        int k=(sqrt(1+8*kb)-1)/2;\\n        for(int i=2;i<=k;i++){\\n             double x = ( kb/i - (float)(i-1)/(float)2);\\n             int y = x;\\n           \\n              if(x-y==0){\\n                  res++;\\n              }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462513,
                "title": "c-maths-clean-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int c=0;\\n        for(int k=1;2*n>k*(k-1);k++)\\n        {\\n            int numerator=n-(k*(k-1)/2);\\n            if(numerator%k==0)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\n**For a detailed understanding watch the youtube video on pepcoding channel.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int c=0;\\n        for(int k=1;2*n>k*(k-1);k++)\\n        {\\n            int numerator=n-(k*(k-1)/2);\\n            if(numerator%k==0)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452427,
                "title": "c-easiest-code-ever",
                "content": "class Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int count=0;\\n        int i=1;\\n        while(n>0){\\n            n=n-i;\\n            if(n%i==0) count++;\\n            i++;\\n        }\\n        return count;\\n        }   \\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int count=0;\\n        int i=1;\\n        while(n>0){\\n            n=n-i;\\n            if(n%i==0) count++;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1434627,
                "title": "c-solution-with-detailed-explanation",
                "content": "```\\npublic class Solution \\n{\\n    private bool CheckNumberOfDigits(int i, int n)\\n    {\\n        // All numbers which are odd can be represented as a pair of consecutive numbers.\\n        // For example 99 = 49 + 50, 17 = 8 + 9;\\n        // Even numbers can\\'t because one of 2 consecutive numbers will be odd;\\n        if (i == 2) return n % 2 == 1;\\n        \\n        \\n        // if \\'i\\' is odd then:\\n        // x-2, x-1, x, x+1, x+2 = x + x + x + x + x\\n        // and this is true for all odd \\'i\\'\\n        // so if \\'n\\' can be divided by \\'i\\' then it can be represented as \\'i\\' consecutive numbers\\n        if (i % 2 == 1) return n % i == 0;\\n        \\n        // if \\'i\\' is even (note that case when \\'i\\' == 2 is handled already) then:\\n        // consecutive row can look like this:\\n        // (?) (?) (?) (?) (?) (?) - 6 numbers in a row.\\n        //\\n        // we can then put a separator in the middle:\\n        // (?) (?) (?) | (?) (?) (?) and note:\\n        //  \\\\   \\\\   \\\\    /   /   /\\n        //   \\\\   \\\\   \\\\  /   /   /\\n        //    \\\\   \\\\   X    /   /\\n        //     \\\\   -- X --    /\\n        //      \\\\ --- X ---- /\\n        // so if \\'n\\' can be represented as 6 consecutive numbers then it can be represented as n = 3 * X\\n        // the number of \\'X\\'s is i / 2;\\n        // so there should be verification: n % (i / 2) == 0\\n        // Also look at the middle of the sequence:\\n        // (?) | (?)\\n        // X = (?) + (?) where these numbers are consecutive => 1 of them is odd => X is always odd.\\n        \\n        if (n % (i / 2) == 0) return (n / (i / 2) % 2) == 1;\\n        \\n        // othervise \\'n\\' can\\'t be represented as sequence of consecutive \\'i\\' numbers.\\n        return false;\\n    }\\n    \\n    public int ConsecutiveNumbersSum(int n) \\n    {\\n        int result = 1;\\n        for (int i = 2; i * i / 2 < n; i++) \\n            if (CheckNumberOfDigits(i, n))\\n                result++;\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    private bool CheckNumberOfDigits(int i, int n)\\n    {\\n        // All numbers which are odd can be represented as a pair of consecutive numbers.\\n        // For example 99 = 49 + 50, 17 = 8 + 9;\\n        // Even numbers can\\'t because one of 2 consecutive numbers will be odd;\\n        if (i == 2) return n % 2 == 1;\\n        \\n        \\n        // if \\'i\\' is odd then:\\n        // x-2, x-1, x, x+1, x+2 = x + x + x + x + x\\n        // and this is true for all odd \\'i\\'\\n        // so if \\'n\\' can be divided by \\'i\\' then it can be represented as \\'i\\' consecutive numbers\\n        if (i % 2 == 1) return n % i == 0;\\n        \\n        // if \\'i\\' is even (note that case when \\'i\\' == 2 is handled already) then:\\n        // consecutive row can look like this:\\n        // (?) (?) (?) (?) (?) (?) - 6 numbers in a row.\\n        //\\n        // we can then put a separator in the middle:\\n        // (?) (?) (?) | (?) (?) (?) and note:\\n        //  \\\\   \\\\   \\\\    /   /   /\\n        //   \\\\   \\\\   \\\\  /   /   /\\n        //    \\\\   \\\\   X    /   /\\n        //     \\\\   -- X --    /\\n        //      \\\\ --- X ---- /\\n        // so if \\'n\\' can be represented as 6 consecutive numbers then it can be represented as n = 3 * X\\n        // the number of \\'X\\'s is i / 2;\\n        // so there should be verification: n % (i / 2) == 0\\n        // Also look at the middle of the sequence:\\n        // (?) | (?)\\n        // X = (?) + (?) where these numbers are consecutive => 1 of them is odd => X is always odd.\\n        \\n        if (n % (i / 2) == 0) return (n / (i / 2) % 2) == 1;\\n        \\n        // othervise \\'n\\' can\\'t be represented as sequence of consecutive \\'i\\' numbers.\\n        return false;\\n    }\\n    \\n    public int ConsecutiveNumbersSum(int n) \\n    {\\n        int result = 1;\\n        for (int i = 2; i * i / 2 < n; i++) \\n            if (CheckNumberOfDigits(i, n))\\n                result++;\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411467,
                "title": "c-ez-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumofdigit(int n){\\n        return n*(n+1)/2;\\n    }\\n    int consecutiveNumbersSum(int n) {\\n        int res = 1;\\n        int len = sqrt(2*n);\\n        for(int i = 2;i<=len;i++){\\n            if((n-sumofdigit(i-1))%i == 0){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumofdigit(int n){\\n        return n*(n+1)/2;\\n    }\\n    int consecutiveNumbersSum(int n) {\\n        int res = 1;\\n        int len = sqrt(2*n);\\n        for(int i = 2;i<=len;i++){\\n            if((n-sumofdigit(i-1))%i == 0){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395887,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int ConsecutiveNumbersSum(int n) {\\n        \\n        int cnt = 0;\\n        \\n        for(int k = 1; k <= Math.Sqrt(2*n); k++)\\n        {\\n            if(((2 * n - k * k + k) % (2 * k)) == 0)\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n\\n\\n/*\\n    x + (x+1) + (x+2) + ... + (x+k-1) = n\\n => (x + x + k - 1) * k / 2 = n\\n => 2x + k - 1 = 2n / k\\n => x = n/k - k/2 + 1/2\\n => x = (2*n - k*k + k) / 2k\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int ConsecutiveNumbersSum(int n) {\\n        \\n        int cnt = 0;\\n        \\n        for(int k = 1; k <= Math.Sqrt(2*n); k++)\\n        {\\n            if(((2 * n - k * k + k) % (2 * k)) == 0)\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n\\n\\n/*\\n    x + (x+1) + (x+2) + ... + (x+k-1) = n\\n => (x + x + k - 1) * k / 2 = n\\n => 2x + k - 1 = 2n / k\\n => x = n/k - k/2 + 1/2\\n => x = (2*n - k*k + k) / 2k\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379128,
                "title": "c-solution-all-methods-including-tle",
                "content": "METHOD 1: Sliding Window (TLE) [T(n) = S(n) = O(n)]\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n\\t\\t// Exception/ Corner Case\\n        if (n <= 2) return 1;\\n        // Method 1: Using Sliding Window\\n        vector<int> nums;\\n        int high = n & 1 ? n / 2 + 1 : n / 2;\\n        for (int i = 1; i <= high; i++)\\n            nums.push_back(i);\\n        // Now we need to find no. of subarrays with sum = n (variable size window)\\n        int i = 0, j = 0, sum = 0, ans = 0;\\n        while (j < nums.size()) {\\n            sum += nums[j];\\n            if (sum == n)\\n                ans++;\\n            // BELOW IF IS MUST, o.w ans can contain repeated results\\n            // EG: TRY with n = 15\\n            if (sum > n) {\\n                while (sum > n) {\\n                    sum -= nums[i];\\n                    i++;\\n                }\\n                if (sum == n)\\n                    ans++;\\n            }\\n            j++;\\n        }\\n        // Leetcode consider N also itself\\'s representation, so ans + 1\\n        return ans + 1;\\n    }\\n};\\n// CONSOLE CAN RUN SUCCESSFULLY FOR N = 72316829 and 88888888 but on submission, i got TLE\\n// Because of range: it is 10^9 => need to solve it either in logn or sqrt(n)\\n```\\n\\nMETHOD 2: Sliding Window (TLE) [T(n) = O(n) and S(n) = O(1)]\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n\\t\\t// Exception/ Corner Case\\n        if (n <= 2) return 1;\\n        // Method 2: Using Sliding Window (Constant Space)\\n        int high = n & 1 ? n / 2 + 1 : n / 2;\\n        int start = 1, end = 1;\\n        // Now we need to find no. of subarrays with sum = n (variable size window)\\n        int i = 0, j = 0, sum = 0, ans = 0;\\n        while (j <= high and start <= high and end <= high) {\\n            sum += end++;\\n            if (sum == n)\\n                ans++;\\n            // BELOW IF IS MUST, o.w ans can contain repeated results\\n            // EG: TRY with n = 15\\n            if (sum > n) {\\n                while (sum > n) {\\n                    sum -= start++;\\n                    i++;\\n                }\\n                if (sum == n)\\n                    ans++;\\n            }\\n            j++;\\n        }\\n        // Leetcode consider N also itself\\'s representation, so ans + 1\\n        return ans + 1;\\n    }\\n};\\n// CONSOLE CAN RUN SUCCESSFULLY FOR N = 72316829 and 88888888 and 855877922 but on submission, i got TLE\\n// Because of range: it is 10^9 => need to solve it either in logn or sqrt(n)\\n```\\n\\nMETHOD 3 [Accepted]: Using Math  [T(n) = O(sqrt(n)) and S(n) = O(1)]\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n\\t\\t// Exception/ Corner Case\\n        if (n <= 2) return 1;\\n        // Method 3: Using Math (Constant Space and O(n^0.5) time)\\n        /*  n = a + (a + 1) + (a + 2) + (a + 3) ... (a + k - 1)\\n            n = ak + k(k - 1) / 2\\n            n - k(k - 1) / 2 = ak\\n            i.e n - k(k - 1) / 2 is divisible by k OR (n - k(k - 1) / 2) % k = 0\\n            also, we need to find lower and upper bound for k, clearly, k >= 2 (atleast two terms)\\n            and also, n - k(k - 1) / 2 >= 0 => k(k - 1) - 2n <= 0 \\n            which approximately gives k <= sqrt(2 * n)\\n        */\\n        int low = 2, high = sqrt(2 * n), ans = 0;\\n        for (int k = low; k <= high; k++)\\n            if ((n - k* (k - 1) / 2) % k == 0)\\n                ans++;\\n        // Leetcode consider N also itself\\'s representation, so ans + 1\\n        return ans + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n\\t\\t// Exception/ Corner Case\\n        if (n <= 2) return 1;\\n        // Method 1: Using Sliding Window\\n        vector<int> nums;\\n        int high = n & 1 ? n / 2 + 1 : n / 2;\\n        for (int i = 1; i <= high; i++)\\n            nums.push_back(i);\\n        // Now we need to find no. of subarrays with sum = n (variable size window)\\n        int i = 0, j = 0, sum = 0, ans = 0;\\n        while (j < nums.size()) {\\n            sum += nums[j];\\n            if (sum == n)\\n                ans++;\\n            // BELOW IF IS MUST, o.w ans can contain repeated results\\n            // EG: TRY with n = 15\\n            if (sum > n) {\\n                while (sum > n) {\\n                    sum -= nums[i];\\n                    i++;\\n                }\\n                if (sum == n)\\n                    ans++;\\n            }\\n            j++;\\n        }\\n        // Leetcode consider N also itself\\'s representation, so ans + 1\\n        return ans + 1;\\n    }\\n};\\n// CONSOLE CAN RUN SUCCESSFULLY FOR N = 72316829 and 88888888 but on submission, i got TLE\\n// Because of range: it is 10^9 => need to solve it either in logn or sqrt(n)\\n```\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n\\t\\t// Exception/ Corner Case\\n        if (n <= 2) return 1;\\n        // Method 2: Using Sliding Window (Constant Space)\\n        int high = n & 1 ? n / 2 + 1 : n / 2;\\n        int start = 1, end = 1;\\n        // Now we need to find no. of subarrays with sum = n (variable size window)\\n        int i = 0, j = 0, sum = 0, ans = 0;\\n        while (j <= high and start <= high and end <= high) {\\n            sum += end++;\\n            if (sum == n)\\n                ans++;\\n            // BELOW IF IS MUST, o.w ans can contain repeated results\\n            // EG: TRY with n = 15\\n            if (sum > n) {\\n                while (sum > n) {\\n                    sum -= start++;\\n                    i++;\\n                }\\n                if (sum == n)\\n                    ans++;\\n            }\\n            j++;\\n        }\\n        // Leetcode consider N also itself\\'s representation, so ans + 1\\n        return ans + 1;\\n    }\\n};\\n// CONSOLE CAN RUN SUCCESSFULLY FOR N = 72316829 and 88888888 and 855877922 but on submission, i got TLE\\n// Because of range: it is 10^9 => need to solve it either in logn or sqrt(n)\\n```\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n\\t\\t// Exception/ Corner Case\\n        if (n <= 2) return 1;\\n        // Method 3: Using Math (Constant Space and O(n^0.5) time)\\n        /*  n = a + (a + 1) + (a + 2) + (a + 3) ... (a + k - 1)\\n            n = ak + k(k - 1) / 2\\n            n - k(k - 1) / 2 = ak\\n            i.e n - k(k - 1) / 2 is divisible by k OR (n - k(k - 1) / 2) % k = 0\\n            also, we need to find lower and upper bound for k, clearly, k >= 2 (atleast two terms)\\n            and also, n - k(k - 1) / 2 >= 0 => k(k - 1) - 2n <= 0 \\n            which approximately gives k <= sqrt(2 * n)\\n        */\\n        int low = 2, high = sqrt(2 * n), ans = 0;\\n        for (int k = low; k <= high; k++)\\n            if ((n - k* (k - 1) / 2) % k == 0)\\n                ans++;\\n        // Leetcode consider N also itself\\'s representation, so ans + 1\\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367421,
                "title": "easy-mathematics-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int count=0,i=1;\\n        while(n>0){\\n            n-=i;\\n            if(n%i==0) count++;\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int count=0,i=1;\\n        while(n>0){\\n            n-=i;\\n            if(n%i==0) count++;\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360108,
                "title": "simple-o-sqrt-n",
                "content": "EXPLAIN: \\n\\noutput : 15 is 3\\n\\n14 % 1 = 0\\n12 % 2 = 0\\n9 % 3 = 0\\n5 % 4= NO  \\n  \\n  int count = 0; \\n    int i = 1;\\n    while(n > 0){\\n        n -= i;\\n        if(n % i ==0)\\n            count++;\\n        i++;\\n    }\\n    return count;\\n\\n\\n",
                "solutionTags": [],
                "code": "EXPLAIN: \\n\\noutput : 15 is 3\\n\\n14 % 1 = 0\\n12 % 2 = 0\\n9 % 3 = 0\\n5 % 4= NO  \\n  \\n  int count = 0; \\n    int i = 1;\\n    while(n > 0){\\n        n -= i;\\n        if(n % i ==0)\\n            count++;\\n        i++;\\n    }\\n    return count;\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1239669,
                "title": "85-faster-than-other-users-simple-and-easy-also-contains-follow-up-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        //let k be a number which is common in a sequence like 4+5+6 if we take k as 3 here then \\n                                                             //(3+1)+(3+2)+(3+3)\\n        // so k+k+1+k+2+k+3....d terms=n;\\n        // k*d + d*(d-1)/2=n;\\n        // k*d=(n-d*(d-1)/2)--> this means if this rhs is divisible by k then k exist else ans=0\\n        \\n        // code\\n        \\n        int ans=0;\\n        for(int d=1; ; d++){\\n            int temp=n-d*(d-1)/2;\\n            if(temp<=0) break;\\n            if(temp%d==0){\\n                temp/=d;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n        \\n        //this is also a google kickstart question if you want to try search Alien Generator at google kickstart ;)\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        //let k be a number which is common in a sequence like 4+5+6 if we take k as 3 here then \\n                                                             //(3+1)+(3+2)+(3+3)\\n        // so k+k+1+k+2+k+3....d terms=n;\\n        // k*d + d*(d-1)/2=n;\\n        // k*d=(n-d*(d-1)/2)--> this means if this rhs is divisible by k then k exist else ans=0\\n        \\n        // code\\n        \\n        int ans=0;\\n        for(int d=1; ; d++){\\n            int temp=n-d*(d-1)/2;\\n            if(temp<=0) break;\\n            if(temp%d==0){\\n                temp/=d;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n        \\n        //this is also a google kickstart question if you want to try search Alien Generator at google kickstart ;)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228985,
                "title": "math-solution-with-proof-simple-handwritting-o-sqrt-n-beat-80-python3",
                "content": "![image](https://assets.leetcode.com/users/images/9740a56c-952b-400e-938a-8d4f6606655b_1621914740.9634964.png)\\nTo find the upper limit of i, which is the max_i\\n![image](https://assets.leetcode.com/users/images/a164db67-7e51-454d-a59f-93001862b1c4_1621914763.88758.png)\\n![image](https://assets.leetcode.com/users/images/7306d085-76b3-4316-8a81-00bc214347f6_1621914775.3115222.png)\\n\\n\\n\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        res=0\\n        upper=int(((8*n+1)**0.5-1)//2+1) # the upper limit of i\\n  \\n        for i in range(upper):\\n            k=n/(i+1)-i/2\\n            if k>0 and int(k)==k: # if k is positive and k is an integer\\n                res+=1\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, n: int) -> int:\\n        res=0\\n        upper=int(((8*n+1)**0.5-1)//2+1) # the upper limit of i\\n  \\n        for i in range(upper):\\n            k=n/(i+1)-i/2\\n            if k>0 and int(k)==k: # if k is positive and k is an integer\\n                res+=1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223612,
                "title": "c-3-lines-of-code-faster-then-100",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint consecutiveNumbersSum(int n) {\\n\\t\\t\\tint sum=0; \\n\\t\\t\\tfor(int i=1,ct=1;ct<n;i++,ct+=i)if(((n-ct)%(i+1)==0))sum++;\\n\\t\\t\\treturn sum+1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint consecutiveNumbersSum(int n) {\\n\\t\\t\\tint sum=0; \\n\\t\\t\\tfor(int i=1,ct=1;ct<n;i++,ct+=i)if(((n-ct)%(i+1)==0))sum++;\\n\\t\\t\\treturn sum+1;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1184244,
                "title": "simple-c-solution",
                "content": "class Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        int n = 0; \\n        int k = int(sqrt(2*N+0.25));\\n        \\n        n = 1; \\n\\n        for ( int i = 2; i<=k ; i++)\\n        {\\n            long long t = 2*N;\\n            t = t-(i+1)*i;\\n            if ( t % (2*i) == 0)\\n                n++;\\n        }\\n        \\n        return n; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        int n = 0; \\n        int k = int(sqrt(2*N+0.25));\\n        \\n        n = 1; \\n\\n        for ( int i = 2; i<=k ; i++)\\n        {\\n            long long t = 2*N;\\n            t = t-(i+1)*i;\\n            if ( t % (2*i) == 0)\\n                n++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1161273,
                "title": "this-is-a-o-sqrt-n-mathematical-solution",
                "content": "Suppose we split the number N to 1 consecutive number, we get n = N by solving `n*1 = N`\\nSuppose we split the number N to 2 consecutive number, we get n = (N-1) / 2 by solving `2*n + 1 = N`\\nSuppose we split the number N to 2 consecutive number, we get n = (N-1-2) / 3 by solving `3*n + 1 + 2 = N`\\n...\\nSuppose we split the number N to k consecutive number, we get n = (N - 1 -2 -.. k) / k by solving `k*n + 1 + 2..+k-1 = N`\\n\\nSo once we add 1 to `k`, we subtract `N` by `k - 1`; and we keep this actions until k as great as N, so that there won\\'t be any reasonable `n`.\\n\\nComplexity:\\nAs for k: `1 + 1 + 1 + 1 ..`\\nAs for N: `N-1-2-3-4....`\\nTwo sequence converge until `k == N`  i.e.  `1 + 2 + 3 + 4 + 5 + ... == N + 1` ,\\nwe want to know how many items, `b`, for the sequence on the left to make N + 1.\\n\\nSolve: `b * (1 + b) / 2 = N+1 -> b ^ 2 + b = 2 * N -> b = sqrt(2N) approximately` \\nSo TC: `O(sqrt(N))`\\n\\n```c++\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n      int  k = 1;\\n      int res = 0;\\n      \\n      while(N >= k) {\\n        N -= k - 1;\\n        if(N % k++ == 0)  res++;\\n      }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n      int  k = 1;\\n      int res = 0;\\n      \\n      while(N >= k) {\\n        N -= k - 1;\\n        if(N % k++ == 0)  res++;\\n      }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157740,
                "title": "java-simple-math-solution",
                "content": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int count=0;\\n        for(int i=1;N-(i*(i-1)/2)>0;i++){\\n            int val = N-(i*(i-1)/2);\\n            if(val%i==0)count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int count=0;\\n        for(int i=1;N-(i*(i-1)/2)>0;i++){\\n            int val = N-(i*(i-1)/2);\\n            if(val%i==0)count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128754,
                "title": "easiest-c-6-lines-code",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int ans=0;\\n        for(int x=1;x*x<=2*n;x++){\\n            double a=((2*n*1.0)-(x*1.0*(x-1)))/(2*x*1.0);\\n            if(a==ceil(a)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int n) {\\n        int ans=0;\\n        for(int x=1;x*x<=2*n;x++){\\n            double a=((2*n*1.0)-(x*1.0*(x-1)))/(2*x*1.0);\\n            if(a==ceil(a)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116223,
                "title": "c-sliding-window-solution-time-limit-exceeded",
                "content": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        if(N==1) return 1;\\n        \\n        int count = 0;\\n        // use sliding window\\n        int start = 1;\\n        int sum = start;\\n        for(int end = 2; end <= N; end++){\\n            sum += end;\\n            while(sum > N && end >= start){\\n                sum -= start;\\n                start++;\\n            }\\n            if(sum == N) count++;\\n       }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        if(N==1) return 1;\\n        \\n        int count = 0;\\n        // use sliding window\\n        int start = 1;\\n        int sum = start;\\n        for(int end = 2; end <= N; end++){\\n            sum += end;\\n            while(sum > N && end >= start){\\n                sum -= start;\\n                start++;\\n            }\\n            if(sum == N) count++;\\n       }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082498,
                "title": "c-o-logn-solution-explained-with-example",
                "content": "First, some maths concepts\\n**Sum of N consecutive numbers = (N)X(N+1)/2**\\nexample : sum of first 5 nos = 5X6/2 = 15\\n\\n**Now, what will be the sum of numbers (n1+1), (n1+2), .......(n2) ? (note : it is starting from n1+1)\\nwell it will be ((n2)X(n2+1)/2) - ((n1)X(n1+1)/2**)...\\n\\nWhich implies for our question where N is given we need to find n2 and n1, where,\\n**N = ((n2)X(n2+1)/2) - ((n1)X(n1+1)/2) .................Equation 1**\\n\\nfor example if N = 9, \\nThen, it can be sum of 9 -> here, n1 = 8 and n2 = 9\\nIt can be sum of 4,5 -> here, n1 = 3 and n2 = 5\\nIt can be sum of 2,3,4 -> here, n1 = 1 and n2 = 4\\n\\nSo, we just need to find the total number of sets{n1, n2} possible.\\nLet\\'s simplify Equation 1 more:\\nN = ((n2)X(n2+1)/2) - ((n1)X(n1+1)/2)\\nN = ((n2^2 + n2)-(n1^2 + n1))/2\\nN = ((n2^2-n1^2) + (n2 - n1))/2\\nN = ((n2-n1)(n2+n1) + (n2-n1))/2\\nN = (n2-n1)(n2+n1+1)/2\\n**2N = (n2 - n1)(n2 + n1 + 1)**\\n\\nNotice that 2N is multiplication of two positive whole numbers here (as n1 and n2 are positive whole numbers, and n2 < n1)\\nSo, we just need to break 2N in multiplication of 2 nos, such as **2N = d1*d2**\\n**hence, (n2-n1) = d1 and (n2 + n1 + 1) = d2**\\n\\nSimplifying more, \\n**n1 = (d1 + d2 - 1) / 2;\\nn2 = (d2 - d1 - 1) / 2;**\\n\\n**for all such d1(positive whole number) and d2(positive whole number) where n1 and n2 are positive whole nos and n1 > n2 -> count++\\nreturn count**\\n\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        //N = (n1-n2)*(n1+n2+1)\\n        int d1, d2;\\n        int n1, n2;\\n        int count = 0;\\n        if(N == 1)\\n            return 1;\\n        for(int i = 1; i < N; i++)\\n        {\\n            if((2*N)%i == 0)\\n            {\\n                d1 = i;\\n                d2 = (2*N)/i;\\n                \\n                //d1 = n1 - n2;\\n                //d2 = n1 + n2 + 1;\\n                if((d1 + d2 - 1)%2 == 0 && (d2 - d1 - 1)%2 == 0)\\n                {\\n                    n1 = (d1 + d2 - 1) / 2;\\n                    n2 = (d2 - d1 - 1) / 2;\\n\\n                    cout << d1 << \" X \" << d2 << \" : \" << n1 << \" and \" << n2 << endl;\\n\\n                    if(n1 >= 0 && n2 >= 0)\\n                        count++;\\n                    if(n1 < 0 || n2 < 0)\\n                        break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        //N = (n1-n2)*(n1+n2+1)\\n        int d1, d2;\\n        int n1, n2;\\n        int count = 0;\\n        if(N == 1)\\n            return 1;\\n        for(int i = 1; i < N; i++)\\n        {\\n            if((2*N)%i == 0)\\n            {\\n                d1 = i;\\n                d2 = (2*N)/i;\\n                \\n                //d1 = n1 - n2;\\n                //d2 = n1 + n2 + 1;\\n                if((d1 + d2 - 1)%2 == 0 && (d2 - d1 - 1)%2 == 0)\\n                {\\n                    n1 = (d1 + d2 - 1) / 2;\\n                    n2 = (d2 - d1 - 1) / 2;\\n\\n                    cout << d1 << \" X \" << d2 << \" : \" << n1 << \" and \" << n2 << endl;\\n\\n                    if(n1 >= 0 && n2 >= 0)\\n                        count++;\\n                    if(n1 < 0 || n2 < 0)\\n                        break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1060393,
                "title": "c-easy-to-understand-with-detailed-explanation",
                "content": "I best understood using averages around pivot points, and thought my approach differed enough from other submissions to share.\\n\\nLet\\'s start with an arbitrary series `1, 2, 3, 4, 5`. What we can say about that series is it has an average value of 3, length 5, and sums to 15. It\\'s trivial to compute these for any given series.\\n\\nThis problem can be done by reversing that calculation; given the target number, does there there exist a series of whole numbers of length i that sum up to that value? The gist is this is true if the average has some special value.\\n\\nFor series of odd lengths, we see that the average value is always a whole number exactly in the center of the series. In the above example, the series centers exactly around the average value `3`. So we can say that if i is odd (`i % 2 == 1`) and N is evenly divisible by i (`N % i == 0`), there exists a valid series centered around N / i of length i.\\n\\nFor series of even lengths, we see that the average value has to be exactly half way between two whole numbers. e.g. for the series `4, 5, 6, 7, 8, 9` the average value is 6.5 and the series is equally balanced around that point. To always fall exactly in the middle, the average must be some whole number + .5. Or in other words, A = (N // i) + (N % i) / i where `//` is integer division and (N % i) / i is the remainder. Since the remainder must be `.5`, we can rewrite the second part of this equation as our constraint; `(N % i ) / i == .5 ` or `(N % i) == i / 2`\\n\\nFrom there, we iterate up until the point where half the series length (`i / 2`) is smaller than the pivot point (`N / i`). To think of this intuitively, this is the point where our series has a length long enough to expand into 0 or negative numbers. O(N^.5) can be derived from the loop condition. `N / i >= i / 2` --> `sqrt(N) ~ i`\\n\\n```cpp\\nclass Solution {\\npublic:\\n  int consecutiveNumbersSum(int N) {\\n    int i = 1, sum = 0;\\n\\n    while (N / (float) i >= i / 2.0) {\\n\\t  // If even and our even constraint OR odd and our odd constraint\\n      if (i % 2 == 0 && (N % i == (i / 2)) || (i % 2 == 1 && N % i == 0))\\n          sum++;\\n      i++;\\n    }\\n    return sum;\\n  }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n  int consecutiveNumbersSum(int N) {\\n    int i = 1, sum = 0;\\n\\n    while (N / (float) i >= i / 2.0) {\\n\\t  // If even and our even constraint OR odd and our odd constraint\\n      if (i % 2 == 0 && (N % i == (i / 2)) || (i % 2 == 1 && N % i == 0))\\n          sum++;\\n      i++;\\n    }\\n    return sum;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055403,
                "title": "clear-java-solution-beats-91-48",
                "content": "```\\nclass Solution {\\n    // let n number of consecutive numbers, l is the smallest number\\n    // [l, l + n -1] sum up to N\\n    // nl = N - [n * (n - 1) / 2]\\n    // let r = N - [n * (n - 1) / 2], r > 0 and r % n == 0\\n    // r(n+1) = r(n) - n\\n    public int consecutiveNumbersSum(int N) {\\n        int count = 0;\\n        \\n        int n = 1;\\n        int r = N;\\n        while (n <= N) {\\n            r -= (n - 1);\\n            if (r <= 0) break;\\n            if (r % n == 0) count++;\\n            n++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // let n number of consecutive numbers, l is the smallest number\\n    // [l, l + n -1] sum up to N\\n    // nl = N - [n * (n - 1) / 2]\\n    // let r = N - [n * (n - 1) / 2], r > 0 and r % n == 0\\n    // r(n+1) = r(n) - n\\n    public int consecutiveNumbersSum(int N) {\\n        int count = 0;\\n        \\n        int n = 1;\\n        int r = N;\\n        while (n <= N) {\\n            r -= (n - 1);\\n            if (r <= 0) break;\\n            if (r % n == 0) count++;\\n            n++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033952,
                "title": "python3-with-interesting-factorization-solution-and-algebra",
                "content": "Assume 2 variables, m and n, where m < n.\\nlet S(m) = 1 + 2 + 3 + .... + m and S(n) = 1 + 2 + 3 + ... + n.\\nWe know from algebra that the sum of consecutive numbers from 1 to x equals x(x + 1)/2.\\nTherefore, S(m) = m(m + 1)/2, and S(n) = n(n + 1)/2\\nThis means that the sum from m + 1 to n equals:\\nS(m + 1... n) = S(n) - S(m) = n(n + 1)/2 - m(m+1)/2 = 0.5(n^2-m^2+n-m)\\nNext we use the algebra formula x^2 - y^2 = (x - y)(x + y):\\nS(m+1...n) = 0.5((n-m)(n+m) + (n - m)) = 0.5(n - m)(n + m + 1)\\nLet N be the input to the function. We can simplify the problem down to:\\nWe want to find all m,n integer pairs where N = 0.5(n - m)(n + m + 1)\\nIn other words, 2N = (n - m)(n + m + 1)\\nLets say N = 5, then 2N = 10, and the factorizaton of 2N = 2 * 5\\nThat means:\\nn - m = 2 (because n > m, the smaller factor must equal n - m)\\nn + m + 1 = 5\\nAdd these together and we get 2n + 1 = 7, meaning n = 3 and m = 1. This verifies that S(m+1...n) = 2 + 3 = 5 = N.\\nSo when does a factor pair not work? Note that in the above example, we have 2n + 1 = odd number. However, if 2n + 1 had equaled an even number, then n would not be an integer. Therefore, the solution to this problem equals all the factor pairs where the sum of the pair equals an odd number. Note that the only way for a sum to be an odd number is if the pair is one even, and one odd. Because 2N is guaranteed to be divisible by 2, we can just ignore the even factor and the solution becomes how many ways can we make an odd factor?\\n\\nTo get all the pairs, all we have to do is multiply by each odd prime factor\\'s exponent plus one. This is because there are exponent + 1 ways to use that odd number in a pair. We multiply due to the product rule (https://en.wikipedia.org/wiki/Rule_of_product#:~:text=In%20combinatorics%2C%20the%20rule%20of,ways%20of%20performing%20both%20actions). Ignore the exponent of 2 because it is even.\\n\\n\\nGet the prime factorization of N. Example:\\nIf N = 2025, then prime factorization = 3^4 * 5^2\\nthen the answer equals (4 + 1)(2 + 1) = 15\\n\\nif N = 1008, then prime factorization = 2^4 * 3^2 * 7\\nthen the answer equals (2 + 1)(1 + 1) = 6\\nReason: 3^0 * 7^0, 3^1 * 7^0, 3^2 * 7^0, 3^0 * 7^1,3^1 * 7^1, 3^2 * 7^1 = 6 ways to make an odd factor\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        def factors(n):\\n            x = 2\\n            ret = []\\n            while x * x <= n:\\n                e = 0\\n                while n % x == 0:\\n                    e += 1\\n                    n //= x\\n                if e > 0:\\n                    ret.append((x, e))\\n                x += 1\\n            if n > 1:\\n                ret.append((n, 1))\\n            return ret\\n        facs = factors(N)\\n        mult = 1\\n        for fac, e in facs:\\n            if fac % 2 == 1:\\n                mult *= e + 1\\n        return mult\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        def factors(n):\\n            x = 2\\n            ret = []\\n            while x * x <= n:\\n                e = 0\\n                while n % x == 0:\\n                    e += 1\\n                    n //= x\\n                if e > 0:\\n                    ret.append((x, e))\\n                x += 1\\n            if n > 1:\\n                ret.append((n, 1))\\n            return ret\\n        facs = factors(N)\\n        mult = 1\\n        for fac, e in facs:\\n            if fac % 2 == 1:\\n                mult *= e + 1\\n        return mult\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031268,
                "title": "ruby-sliding-window-and-dp-of-sums-tle",
                "content": "Here is my ruby solution using a sliding window and caching the sums so as not to compute sums for each window.  The solution  gets TLE on the 92nd test case.\\n\\nSince this is a sliding window the time complexity should be around O(N).\\n\\nSurely,  this should be good enough to pass TLE?  The offical LC solutions is O(sqrt(n)) but uses some obscure math.  IMO Leetcode should accept an O(N) solution.\\n\\n\\n```\\ndef consecutive_numbers_sum(n)\\n    \\n    solutions = Set.new\\n    \\n    a = (1..n).to_a\\n    \\n    l = 0\\n    r = 0\\n    \\n    sum_cache = {}\\n    sum_cache[[0, 0]] = a[0]\\n    \\n    while true\\n        break if r > a.length - 1\\n        \\n        sum = sum_cache[[l, r]] \\n        \\n        if sum == n\\n            solutions.add([a[l..r]])\\n            sum_cache[[l+1, r]] = sum_cache[[l, r]] - a[l]\\n            l += 1\\n            next\\n        end\\n        \\n        # expand right\\n        if sum < n            \\n            break if r + 1 > a.length - 1\\n            sum_cache[[l, r+1]] = sum_cache[[l, r]] + a[r+1]\\n            r += 1\\n            next\\n        end\\n        \\n        # slide right\\n        if sum > n\\n            sum_cache[[l+1, r]] = sum_cache[[l, r]] - a[l]\\n            l += 1\\n            next\\n        end\\n    end\\n    \\n    puts solutions.inspect\\n    return solutions.length\\nend\\n``",
                "solutionTags": [],
                "code": "Here is my ruby solution using a sliding window and caching the sums so as not to compute sums for each window.  The solution  gets TLE on the 92nd test case.\\n\\nSince this is a sliding window the time complexity should be around O(N).\\n\\nSurely,  this should be good enough to pass TLE?  The offical LC solutions is O(sqrt(n)) but uses some obscure math.  IMO Leetcode should accept an O(N) solution.\\n\\n\\n```\\ndef consecutive_numbers_sum(n)\\n    \\n    solutions = Set.new\\n    \\n    a = (1..n).to_a\\n    \\n    l = 0\\n    r = 0\\n    \\n    sum_cache = {}\\n    sum_cache[[0, 0]] = a[0]\\n    \\n    while true\\n        break if r > a.length - 1\\n        \\n        sum = sum_cache[[l, r]] \\n        \\n        if sum == n\\n            solutions.add([a[l..r]])\\n            sum_cache[[l+1, r]] = sum_cache[[l, r]] - a[l]\\n            l += 1\\n            next\\n        end\\n        \\n        # expand right\\n        if sum < n            \\n            break if r + 1 > a.length - 1\\n            sum_cache[[l, r+1]] = sum_cache[[l, r]] + a[r+1]\\n            r += 1\\n            next\\n        end\\n        \\n        # slide right\\n        if sum > n\\n            sum_cache[[l+1, r]] = sum_cache[[l, r]] - a[l]\\n            l += 1\\n            next\\n        end\\n    end\\n    \\n    puts solutions.inspect\\n    return solutions.length\\nend\\n``",
                "codeTag": "Python3"
            },
            {
                "id": 1008250,
                "title": "2-pointer-but-tle",
                "content": "```\\n\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int start = 1, end = 1, count = 1, sum = 0;\\n\\n        while(end <= N){\\n            sum += end;\\n\\n            if(sum >= N){\\n                while(sum >= N && start < end){\\n                    if(sum == N) count++;\\n                    sum -= start;\\n                    start++;\\n                }\\n            }\\n            end++;\\n            if(start + end > N) break;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int consecutiveNumbersSum(int N) {\\n        int start = 1, end = 1, count = 1, sum = 0;\\n\\n        while(end <= N){\\n            sum += end;\\n\\n            if(sum >= N){\\n                while(sum >= N && start < end){\\n                    if(sum == N) count++;\\n                    sum -= start;\\n                    start++;\\n                }\\n            }\\n            end++;\\n            if(start + end > N) break;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957403,
                "title": "python3",
                "content": "```\\ndef consecutiveNumbersSum(self, N: int) -> int:\\n        m=1\\n        n=0\\n        k=N/m\\n        ans=0\\n        while k>=1:\\n            if k==int(k):\\n                ans+=1\\n            n+=m\\n            m+=1\\n            k=float((N-n)/m)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef consecutiveNumbersSum(self, N: int) -> int:\\n        m=1\\n        n=0\\n        k=N/m\\n        ans=0\\n        while k>=1:\\n            if k==int(k):\\n                ans+=1\\n            n+=m\\n            m+=1\\n            k=float((N-n)/m)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 944811,
                "title": "other-failed-approaches-as-well-as-simple-explanation-of-correct-mathematical-solution",
                "content": "At the first glance, recursion seems to be the way to go :\\n```\\n public int consecutiveNumbersSum(int N) {\\n\\t for(int i = 1; i <= N; i++) \\n\\t\\t go(i, N, 0);\\n\\t return cnt;\\n }\\nint cnt = 0;\\npublic void go(int n, int target, int cur_sum) {\\n        if(cur_sum < 0) {\\n            return;\\n        }\\n        if(cur_sum == 0) {\\n            cnt++;\\n            return;\\n        }\\n        for(int i = n; i < target+1; i++) {\\n            go(i+1, target, cur_sum-i);\\n            return;\\n        }\\n        return;\\n    }\\n```\\nbut it gives TLE , due to the complexity being O(N^3), I think!\\nNext approach would be use a HashMap but since N is too large HashMap will blow up.\\nSo,  we get a hint to look for some Mathmatical approach here since some form of Arithmetic Progression is required.\\n \\n Let\\'s assume we start with number p+1 for ( not p for simpler coding purposes)\\n So, N = (p+1)+(p+2)+(p+3)....(p+k) \\n => N = kp + (1+2..+k)\\n      N = kp + (k+1)/2 => p = N/k - (k+1)/2\\nAs given in the questions p will be a positive number hence we can solve the above equation furthur to form the following inequality\\nSo, p > 0\\n=> N/k > (k+1)/2\\nsolving this equation, we get k* k +  k - 2N > 0 which is a quadratic equation that can be solved by the formula -b+ sqrt(b^2-4ac)/2a.\\nUsing the above formula, get the upper limit of k that will be k < sqrt(2N+0.25) - 0.5 for p to be a positve number\\nNow, we have the maximum value of k we can now check for each value k will p be a positive number using the equation p = N/k +(k+1)/2, that means  expression N + k(k+1)/2 modulus k should be 0.\\nBelow is the code for the same:\\n```\\n public int consecutiveNumbersSum(int N) {\\n        cnt = 0;\\n        int upperLimit = (int)(Math.sqrt(2*N + 0.25) - 0.5);\\n        for(int k = 1; k <= upperLimit; k++) {\\n            // p should be positive for some value of k\\n            //  p = N/k - (k+1)/2; => (N -k(k+1))/2 should be divisible by k\\n            if(( N - k*(k+1)/2) % k == 0) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n",
                "solutionTags": [],
                "code": "```\\n public int consecutiveNumbersSum(int N) {\\n\\t for(int i = 1; i <= N; i++) \\n\\t\\t go(i, N, 0);\\n\\t return cnt;\\n }\\nint cnt = 0;\\npublic void go(int n, int target, int cur_sum) {\\n        if(cur_sum < 0) {\\n            return;\\n        }\\n        if(cur_sum == 0) {\\n            cnt++;\\n            return;\\n        }\\n        for(int i = n; i < target+1; i++) {\\n            go(i+1, target, cur_sum-i);\\n            return;\\n        }\\n        return;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 921772,
                "title": "c-4-lines-easiest-math-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        int count=0;\\n        for(int k=1;k<sqrt(2*N);k++){\\n            int num = N - (k*(k-1)/2) , den = k;\\n            if(num%den==0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        int count=0;\\n        for(int k=1;k<sqrt(2*N);k++){\\n            int num = N - (k*(k-1)/2) , den = k;\\n            if(num%den==0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911684,
                "title": "javascript-solution",
                "content": "```\\nvar consecutiveNumbersSum = function (N) {\\n  let count = 1;\\n  for (let item = 2; item < Math.sqrt(2 * N); item++) {\\n    if ((N - [(item + 1) * item] / 2) % item === 0) {\\n      count++;\\n    }\\n  }\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar consecutiveNumbersSum = function (N) {\\n  let count = 1;\\n  for (let item = 2; item < Math.sqrt(2 * N); item++) {\\n    if ((N - [(item + 1) * item] / 2) % item === 0) {\\n      count++;\\n    }\\n  }\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906068,
                "title": "backtracking-tle-how-i-expected-this-to-pass",
                "content": "```\\n    public int consecutiveNumbersSum(int N) {\\n         return backtrack(N, N, new ArrayList<>(), 1);\\n    }\\n    \\n    private int backtrack(int target, int N, List<Integer> tmpList, int start) {\\n        if (sum(tmpList) > target) {\\n            return 0;\\n        }\\n        \\n        if (tmpList.size()>1 && tmpList.get(tmpList.size()-1)-tmpList.get(tmpList.size()-2)!=1)\\n            return 0;\\n        \\n        if (sum(tmpList) == target) {\\n            return 1;\\n        }\\n        \\n        String key = N + \"_\" + start;            \\n        \\n        int total = 0;\\n        \\n        for (int i=start; i<=N; i++) {\\n            tmpList.add(i);\\n            total+=backtrack(target, N-i, tmpList, i+1);\\n            tmpList.remove(tmpList.size()-1);\\n        }     \\n\\n        \\n        return total;\\n    }\\n    \\n    private int sum(List<Integer> tmpList) {\\n        int sum=0;\\n        for (int num: tmpList)\\n            sum+=num;\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int consecutiveNumbersSum(int N) {\\n         return backtrack(N, N, new ArrayList<>(), 1);\\n    }\\n    \\n    private int backtrack(int target, int N, List<Integer> tmpList, int start) {\\n        if (sum(tmpList) > target) {\\n            return 0;\\n        }\\n        \\n        if (tmpList.size()>1 && tmpList.get(tmpList.size()-1)-tmpList.get(tmpList.size()-2)!=1)\\n            return 0;\\n        \\n        if (sum(tmpList) == target) {\\n            return 1;\\n        }\\n        \\n        String key = N + \"_\" + start;            \\n        \\n        int total = 0;\\n        \\n        for (int i=start; i<=N; i++) {\\n            tmpList.add(i);\\n            total+=backtrack(target, N-i, tmpList, i+1);\\n            tmpList.remove(tmpList.size()-1);\\n        }     \\n\\n        \\n        return total;\\n    }\\n    \\n    private int sum(List<Integer> tmpList) {\\n        int sum=0;\\n        for (int num: tmpList)\\n            sum+=num;\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 898428,
                "title": "python-solution-memory-usage-less-than-99-96",
                "content": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        divisor = 2\\n        dividen_sub = 1\\n        count = 1\\n        \\n        while N >= divisor + dividen_sub:\\n            if (N - dividen_sub) % divisor == 0:\\n                count = count + 1\\n            dividen_sub = dividen_sub + divisor\\n            divisor = divisor + 1\\n        \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        divisor = 2\\n        dividen_sub = 1\\n        count = 1\\n        \\n        while N >= divisor + dividen_sub:\\n            if (N - dividen_sub) % divisor == 0:\\n                count = count + 1\\n            dividen_sub = dividen_sub + divisor\\n            divisor = divisor + 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889448,
                "title": "java-explanation-with-examples-upto-n-20-o-sqrt-n",
                "content": "Let us take examples for N from 1 to 20 so that the pattern becomes clear to us,\\nN: ans : all combinations\\n```\\n1: \\t1 : 1\\n2: \\t1 : 2\\n3: \\t2 : 3 = 1+2\\n4: \\t1 : 4\\n5: \\t2 : 5 = 2+3\\n6: \\t2 : 6 = \\t= 1+2+3\\n7: \\t2 : 7 = 3+4\\n8: \\t1 : 8\\n9: \\t3 : 9 = 4+5 = 2+3+4\\n10: 2 : 10= \\t\\t\\t= 1+2+3+4\\n11: 2 : 11= 5+6\\n12: 2 : 12= \\t= 3+4+5\\n13: 2 : 13= 6+7\\n14: 2 : 14=\\t\\t\\t\\t= 2+3+4+5\\n15: 4 : 15= 7+8 = 4+5+6 = \\t\\t  = 1+2+3+4+5\\n16: 1 : 16\\n17: 2 : 17= 8+9\\n18: 3 : 18= \\t= 5+6+7 = 3+4+5+6\\n19: 2 : 19= 9+10\\n20: 2 : 20= \\t\\t\\t\\t\\t  = 2+3+4+5+6\\n```\\nWe start to see a pattern here:\\nfor all combinations where there are sum of 2 numbers, N is ```3+2k``` where k= 0,1,2,3...\\nfor all sum of 3 numbers N is ```6+3k```\\nfor all sum of 4 numbers N is ```10+4k```\\nHence to sumarize:\\n```\\n2: 3+2k\\n3: 6+3k\\n4: 10+4k\\n5: 15+5k\\n6: 21+6k\\n....\\n```\\nthe initNums are increasing with a difference which is an ever increasing sequence i.e \\n3 + 3 = 6,\\n6 + 4 = 10,\\n10 + 5 = 15,\\n15 + 6 = 21\\n\\nCode:\\n```\\n    public int consecutiveNumbersSum(int N) {\\n        int ans = 1; //N will have N as one of its sums\\n        int initNum = 3, initDiff = 3, initFact = 2; //initNum + initFact*k\\n        while(N >= initNum){\\n            if((N - initNum) % initFact == 0) //check for all our patterns i. 3+2k, 6+3k and so on\\n                ans++;\\n            initNum += initDiff;\\n            initDiff++;\\n            initFact++;\\n        }\\n        return ans;\\n    }\\n```\\nTime Complexity:\\nWe can observe for N we are making an iteration for consecutive positive integers: 3,4,5,6....\\nFrom formula for sum of consecutive numbers:\\n```N = 3+4+5+6.... ~ noOfIterations*(noOfIterations+1)/2```\\nso \\n```noOfIterations ~ Sqrt(N) i.e O(Sqrt(N))```",
                "solutionTags": [],
                "code": "```\\n1: \\t1 : 1\\n2: \\t1 : 2\\n3: \\t2 : 3 = 1+2\\n4: \\t1 : 4\\n5: \\t2 : 5 = 2+3\\n6: \\t2 : 6 = \\t= 1+2+3\\n7: \\t2 : 7 = 3+4\\n8: \\t1 : 8\\n9: \\t3 : 9 = 4+5 = 2+3+4\\n10: 2 : 10= \\t\\t\\t= 1+2+3+4\\n11: 2 : 11= 5+6\\n12: 2 : 12= \\t= 3+4+5\\n13: 2 : 13= 6+7\\n14: 2 : 14=\\t\\t\\t\\t= 2+3+4+5\\n15: 4 : 15= 7+8 = 4+5+6 = \\t\\t  = 1+2+3+4+5\\n16: 1 : 16\\n17: 2 : 17= 8+9\\n18: 3 : 18= \\t= 5+6+7 = 3+4+5+6\\n19: 2 : 19= 9+10\\n20: 2 : 20= \\t\\t\\t\\t\\t  = 2+3+4+5+6\\n```\n```3+2k```\n```6+3k```\n```10+4k```\n```\\n2: 3+2k\\n3: 6+3k\\n4: 10+4k\\n5: 15+5k\\n6: 21+6k\\n....\\n```\n```\\n    public int consecutiveNumbersSum(int N) {\\n        int ans = 1; //N will have N as one of its sums\\n        int initNum = 3, initDiff = 3, initFact = 2; //initNum + initFact*k\\n        while(N >= initNum){\\n            if((N - initNum) % initFact == 0) //check for all our patterns i. 3+2k, 6+3k and so on\\n                ans++;\\n            initNum += initDiff;\\n            initDiff++;\\n            initFact++;\\n        }\\n        return ans;\\n    }\\n```\n```N = 3+4+5+6.... ~ noOfIterations*(noOfIterations+1)/2```\n```noOfIterations ~ Sqrt(N) i.e O(Sqrt(N))```",
                "codeTag": "Unknown"
            },
            {
                "id": 887282,
                "title": "prefix-sum-based-algorithm-works-but-time-limit-exceeds-and-easy-integer-overflow",
                "content": "It fails on testing: \\n\\n90 / 170 test cases passed.\\n\\nStatus: Wrong Answer\\nSubmitted: 10 minutes ago\\n\\nInput: 855204\\nOutput: 71\\nExpected: 8\\n\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n\\n        unordered_map <int, int> hist;\\n        hist[0]=1;\\n\\n        int count=0;\\n        long long curSum=0;\\n        for (long long i=1; i<N+1; i++ )\\n        {\\n            curSum+= i;\\n            if (hist.count(curSum-N))\\n              count+= hist[curSum-N];\\n            hist[curSum]++;\\n        }\\n\\n        return count;\\n    }\\n};\\n\\n```\\n\\nI tested with a smaller number 300000 . I also print out all sequences\\n\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n       // mistake: out of bounds! \\n        // vector <long long > hist(N+1, 0) ;\\n        // value and offsets\\n        unordered_map <int, vector<int>> hist;\\n        hist[0].push_back(-1);\\n\\n        int count=0;\\n        long long curSum=0;\\n        //for (long long i=1; i<N/2+1+1; i++ )\\n        for (long long i=1; i<N+1; i++ )\\n        {\\n            curSum+= i;\\n            if (hist[curSum-N].size()>0)\\n            {\\n              count+= hist[curSum-N].size();\\n              for (auto o: hist[curSum-N])\\n              {\\n                 cout<<\"Found a solution prev offset \"<< o << \" with sum \"<< curSum-N; \\n                 cout<< \" current i \"<<i<< \" with sum \" << curSum <<endl;\\n                 int test_sum=0;\\n                 for (int j=o+1; j<=i; j++)\\n                   test_sum+=j;\\n                 assert (test_sum == N);\\n              }\\n            }\\n            hist[curSum].push_back(i);\\n        }\\n\\n        //return count+1; \\n        return count;  \\n    }\\n};\\n\\n```\\n\\n./a.out \\nFound a solution prev offset 167 with sum 14028 current i 792 with sum 314028\\nFound a solution prev offset 612 with sum 187578 current i 987 with sum 487578\\nFound a solution prev offset 777 with sum 302253 current i 1097 with sum 602253\\nFound a solution prev offset 1466 with sum 1075311 current i 1658 with sum 1375311\\nFound a solution prev offset 2337 with sum 2731953 current i 2462 with sum 3031953\\nFound a solution prev offset 3962 with sum 7850703 current i 4037 with sum 8150703\\nFound a solution prev offset 4655 with sum 10836840 current i 4719 with sum 11136840\\nFound a solution prev offset 11987 with sum 71850078 current i 12012 with sum 72150078\\nFound a solution prev offset 19992 with sum 199850028 current i 20007 with sum 200150028\\nFound a solution prev offset 59997 with sum 1799850003 current i 60002 with sum 1800150003\\nFound a solution prev offset 99998 with sum 4999850001 current i 100001 with sum 5000150001\\nFound a solution prev offset 70612 with sum 11082997170 current i 148884 with sum 11083297170\\nFound a solution prev offset 86392 with sum 12321766620 current i 156984 with sum 12322066620\\nFound a solution prev offset 35994 with sum 13532703903 current i 164517 with sum 13533003903\\nFound a solution prev offset 89183 with sum 42631554000 current i 291999 with sum 42631854000\\nFound a solution prev offset 131227 with sum 42970066746 current i 293156 with sum 42970366746\\nFound a solution prev offset 299999 with sum 44999850000 current i 300000 with sum 45000150000\\n17\\n\\nHowevever, the expected is 12.   It is obvious integer overflow happens. \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n\\n        unordered_map <int, int> hist;\\n        hist[0]=1;\\n\\n        int count=0;\\n        long long curSum=0;\\n        for (long long i=1; i<N+1; i++ )\\n        {\\n            curSum+= i;\\n            if (hist.count(curSum-N))\\n              count+= hist[curSum-N];\\n            hist[curSum]++;\\n        }\\n\\n        return count;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n       // mistake: out of bounds! \\n        // vector <long long > hist(N+1, 0) ;\\n        // value and offsets\\n        unordered_map <int, vector<int>> hist;\\n        hist[0].push_back(-1);\\n\\n        int count=0;\\n        long long curSum=0;\\n        //for (long long i=1; i<N/2+1+1; i++ )\\n        for (long long i=1; i<N+1; i++ )\\n        {\\n            curSum+= i;\\n            if (hist[curSum-N].size()>0)\\n            {\\n              count+= hist[curSum-N].size();\\n              for (auto o: hist[curSum-N])\\n              {\\n                 cout<<\"Found a solution prev offset \"<< o << \" with sum \"<< curSum-N; \\n                 cout<< \" current i \"<<i<< \" with sum \" << curSum <<endl;\\n                 int test_sum=0;\\n                 for (int j=o+1; j<=i; j++)\\n                   test_sum+=j;\\n                 assert (test_sum == N);\\n              }\\n            }\\n            hist[curSum].push_back(i);\\n        }\\n\\n        //return count+1; \\n        return count;  \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 854838,
                "title": "two-pointer-solution-tle-for-large-numbers",
                "content": "Two pointer solution. I get a TLE for large numbers.\\n```\\nclass Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        \\n        int left = 1;\\n        int res = 0, sum = 0;\\n        \\n        for(int right = 1; right <= N; right++)\\n        {\\n\\t\\t    // Keep adding the right number to the sum\\n            sum += right;\\n            \\n\\t\\t\\t// While the sum > N, keep subtracting the left number until\\n\\t\\t\\t// it is less than or equal to N\\n            while(sum >= N)\\n            {\\n                if(sum == N)\\n                {\\n                    res++;\\n                } \\n                \\n                sum -= left;\\n                left++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int consecutiveNumbersSum(int N) {\\n        \\n        int left = 1;\\n        int res = 0, sum = 0;\\n        \\n        for(int right = 1; right <= N; right++)\\n        {\\n\\t\\t    // Keep adding the right number to the sum\\n            sum += right;\\n            \\n\\t\\t\\t// While the sum > N, keep subtracting the left number until\\n\\t\\t\\t// it is less than or equal to N\\n            while(sum >= N)\\n            {\\n                if(sum == N)\\n                {\\n                    res++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 833122,
                "title": "simplest-solution-o-sqrt-n",
                "content": "First, this is actually a math question. Without loss of generality, if **N** can be written in consecutive number, it follows the following form:\\n\\n**N = (x+1) + (x+2) + ... + (x+k)**, where **x** and **k** are the two variables we have to determine, the only constraint is that both of them are **integers**\\n\\nTherefore, we have **N = (2x+k+1)(k) / 2**, which means **2N = (2x+k+1)(k)**. This implies that if **N** can be written in sum of consecutive numbers (that starts in **x** with length **k**), **2N** can be represented by the multiplication above. We only have to enumerate **k** up to **sqrt(2N)**, where the time complexity is **O(sqrt(N))**.\\n\\nBelow is a simple code without optimization:\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        cnt = 0\\n        for i in range(1, 2*N):\\n            if i**2 >= 2*N:\\n                break\\n            if (2*N) % i == 0:\\n                x = ((2*N) / i - i - 1) / 2\\n                if x.is_integer():\\n                    cnt += 1\\n        return cnt\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        cnt = 0\\n        for i in range(1, 2*N):\\n            if i**2 >= 2*N:\\n                break\\n            if (2*N) % i == 0:\\n                x = ((2*N) / i - i - 1) / 2\\n                if x.is_integer():\\n                    cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 817197,
                "title": "no-math-fast-naive-solution",
                "content": "So the idea comes from the observation of 9 = 9\\\\*1 = 4\\\\*2+1 = 2\\\\*3+3 ... You may see the pattern here. I use `acc` for accumulated remainder part, `i` for number of consecutive items, and have something as follow:\\n\\n```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        cnt = 0\\n        acc, i = 0, 1\\n        while N-acc >= i:\\n            if (N-acc)%i == 0: cnt += 1\\n            acc += i\\n            i += 1\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def consecutiveNumbersSum(self, N: int) -> int:\\n        cnt = 0\\n        acc, i = 0, 1\\n        while N-acc >= i:\\n            if (N-acc)%i == 0: cnt += 1\\n            acc += i\\n            i += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816798,
                "title": "python3-solution-faster-than-95-less-memory-than-95",
                "content": "```\\n\\t\\tfrom functools import reduce\\n        def factors(n):    \\n            return set(reduce(list.__add__, \\n                        ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\\n        #odd factors\\n        a = list(factors(N))\\n        return len([x for x in a if x%2 != 0])\\n```\\nIt finds all of the factors of the number, and then returns the number of odd factors.",
                "solutionTags": [],
                "code": "```\\n\\t\\tfrom functools import reduce\\n        def factors(n):    \\n            return set(reduce(list.__add__, \\n                        ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\\n        #odd factors\\n        a = list(factors(N))\\n        return len([x for x in a if x%2 != 0])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 796181,
                "title": "super-fast-and-clear-java-2ms-beats-95",
                "content": "```\\nclass Solution {\\n\\n    public int consecutiveNumbersSum(int N) {\\n        int count = 0;\\n        final int n2 = 2 * N;\\n        \\n        for (int i = 1; i * i < (n2); i++) {\\n            if (n2 % i == 0 && (i + n2 / i) % 2 == 1) {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int consecutiveNumbersSum(int N) {\\n        int count = 0;\\n        final int n2 = 2 * N;\\n        \\n        for (int i = 1; i * i < (n2); i++) {\\n            if (n2 % i == 0 && (i + n2 / i) % 2 == 1) {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570268,
                "content": [
                    {
                        "username": "alexanderholman",
                        "content": "The solution to this problem is not challenging; the hard part is knowing when one can stop checking.\\n\\nFor a first attempt, a brute force of sorts was to iterate from `2` through `N` on smaller numbers and `sqrt(N)` on the larger ones, for each iteration summing `i` numbers, with the middle number roughly `N/i`. This solution barely passed, at about 7 seconds.\\n\\nIt took some googling to discover a mathematical approach, bringing the time complexity down to `O(N)`.\\n\\nIt took reading the solution to learn the formula of `k = sqrt((2N + (1/4)) - 1/2)`; allowing the `O(sqrt(N))` complexity.\\n\\nIn an interview, there is no way I would have gotten this in `O(N)` let alone anything better.\\n\\nThus, to the question outlined in the subject; in what roles would someone expect this sort of question? I have interviewed at many companies for general SWE and have never come across a question that relied on knowledge of any mathematical formulae.\\n\\nWas it just luck? Or are these question types specific to roles involving, for example, ML or similar?"
                    },
                    {
                        "username": "buddy_lee",
                        "content": "I haven\\'t interviewed much, so I\\'m not sure. I came up with a dynamic programming solution that exceeds the time limit for this problem. My intuition uses purely alogrithms and data structures, no mathematical insights. How common is it to run into interview problems that require some purely mathematical insight such as this one?\\n\\nI understand algorithms and math has some overlap, but this problem clearly requires more math than programming knowledge."
                    },
                    {
                        "username": "yeeeeetelite",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/\\n\\nHey guys,\\nNoob here. \\n\\nI wanted to know how is this question not the same as subarray sum equals to k?\\nI think I am missing something here?\\n\\nWhy cant we just create a map/set of runningSum and check everytime if runningSum -n is present in the set or not?"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question! Indeed, both problems involve dealing with sums and sequences, but they differ in their specifics. \\n\\nThe problem \"Subarray Sum Equals K\" is defined as: Given an array of integers and an integer K, you need to find the total number of continuous subarrays whose sum equals to K. In this problem, you\\'re dealing with an already given array, and you\\'re looking for all subarrays that sum up to a target value, K. \\n\\nThe key difference between this problem and the current problem is that the \"Subarray Sum Equals K\" problem deals with a predefined array that may contain any integers, not necessarily consecutive. Additionally, the subarray can start and end at any position within the array.\\n\\nOn the other hand, the problem \"Number of Ways to Write N as a Sum of Consecutive Positive Integers\" is about finding sequences of consecutive positive integers that sum up to a given number, N. Here, you\\'re not given any array to start with, and the integers must be consecutive. Moreover, these sequences can start from any positive integer, not just from the first element of an array.\\n\\nAs a result, the map/set strategy for \"Subarray Sum Equals K\" problem doesn\\'t directly apply here, because we\\'re not given an array, and we need to deal with sequences of consecutive integers instead. In other words, the two problems are asking for different things, and the approach used for one does not directly translate to the other.\\n"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Here O(sqrt(n)) is possible because the equivalent input `nums` has a strong pattern."
                    },
                    {
                        "username": "sukidayo",
                        "content": "3 useful facts:\\n1. n + (n+1) + (n+2) + ... + (n+k-1) = (2n+k-1)*k/2\\n2. (2n+k-1)*k/2 mod k = 0 if k is odd\\n3. (2n+k-1)*k/2 mod k = k/2 if k is even"
                    },
                    {
                        "username": "newcomer03",
                        "content": "I am getting a TLE on a test-case for n=53965645, but when I add it to my test-cases and run it, it passes the test-case... What should I do??\nint consecutiveNumbersSum(int n) {\n        long int sum = 0;\n        int ctr = 1;\n        if(n==1 || n==2)\n            return 1;\n        for(int i=1; i<n/2+1; i++)\n        {\n            for(int j=i; j<=n/2+2; j++)\n            {\n                if(sum<n)\n                {\n                    sum += j;\n                }\n                else\n                {\n                    if(sum==n)\n                        ctr++;\n                    sum = 0;\n                    break;\n                }\n            }\n        }\n        return ctr;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue you\\'re encountering is due to the time complexity of your solution. Your current approach has a time complexity of roughly O(n^2), which can be too slow for larger inputs like `n = 53965645`.\\n\\nYour code currently iterates over every number up to `n/2+1`, and for each of those numbers, it starts another loop to add numbers until the sum is equal to or greater than `n`. This process is quite time-consuming, especially for large inputs.\\n\\nA more efficient solution to this problem exists with a time complexity of O(sqrt(n)).\\n\\nHere is an optimized approach:\\n\\n1. Initiate a variable `count` to 0. This variable will keep track of the total number of ways.\\n2. Iterate `i` from 1 while `(i * (i + 1)) / 2 <= n`. This part uses the sum formula of an arithmetic progression, ensuring that the sum does not exceed `n`.\\n    - In each iteration, check if `n - (i * (i + 1)) / 2` is divisible by `i`. If it is, increment `count`.\\n3. At the end of the loop, `count` will be the answer.\\n\\nThis approach works because it efficiently checks for all possible lengths of sequences (i.e., `i`) that can sum up to `n`. \\n\\nPlease try to implement this approach in your code, and it should solve the TLE issue you\\'re currently facing. \\n\\nRemember, in coding problems, often brute force solutions can lead to time limit exceeded errors. It\\'s crucial to try and find patterns or mathematical properties that can help you optimize your solution. In this case, the key insight is understanding how arithmetic progressions work and using that to limit the search space effectively."
                    },
                    {
                        "username": "Seemon2000",
                        "content": "Thanks for posting these type of questions and if its here to scare 50% of the population for preparing for FAANGM companies then you have done a great job. I would really appreciate if you also mention for what kind of roles interviews, these type of questions are asked? Even someone getting interviewed for Support backend engineer, he/she should be knowing quantum theory of computing, I must salute the number of candidates giving importance to these companies and taking pride in living others dreams Inspite of having so much knowledge and talent!!! \\nPlease my suggestion is, if you could solve this problem on your own then do something good startup and work on your own ideas... work on how to control implications of AI/ML... Its very much needed for humanity!!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I think the problem doesn't require a deep understanding of math.Knowing only a basic high school formula is enough for solving it"
                    }
                ]
            },
            {
                "id": 1574768,
                "content": [
                    {
                        "username": "alexanderholman",
                        "content": "The solution to this problem is not challenging; the hard part is knowing when one can stop checking.\\n\\nFor a first attempt, a brute force of sorts was to iterate from `2` through `N` on smaller numbers and `sqrt(N)` on the larger ones, for each iteration summing `i` numbers, with the middle number roughly `N/i`. This solution barely passed, at about 7 seconds.\\n\\nIt took some googling to discover a mathematical approach, bringing the time complexity down to `O(N)`.\\n\\nIt took reading the solution to learn the formula of `k = sqrt((2N + (1/4)) - 1/2)`; allowing the `O(sqrt(N))` complexity.\\n\\nIn an interview, there is no way I would have gotten this in `O(N)` let alone anything better.\\n\\nThus, to the question outlined in the subject; in what roles would someone expect this sort of question? I have interviewed at many companies for general SWE and have never come across a question that relied on knowledge of any mathematical formulae.\\n\\nWas it just luck? Or are these question types specific to roles involving, for example, ML or similar?"
                    },
                    {
                        "username": "buddy_lee",
                        "content": "I haven\\'t interviewed much, so I\\'m not sure. I came up with a dynamic programming solution that exceeds the time limit for this problem. My intuition uses purely alogrithms and data structures, no mathematical insights. How common is it to run into interview problems that require some purely mathematical insight such as this one?\\n\\nI understand algorithms and math has some overlap, but this problem clearly requires more math than programming knowledge."
                    },
                    {
                        "username": "yeeeeetelite",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/\\n\\nHey guys,\\nNoob here. \\n\\nI wanted to know how is this question not the same as subarray sum equals to k?\\nI think I am missing something here?\\n\\nWhy cant we just create a map/set of runningSum and check everytime if runningSum -n is present in the set or not?"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question! Indeed, both problems involve dealing with sums and sequences, but they differ in their specifics. \\n\\nThe problem \"Subarray Sum Equals K\" is defined as: Given an array of integers and an integer K, you need to find the total number of continuous subarrays whose sum equals to K. In this problem, you\\'re dealing with an already given array, and you\\'re looking for all subarrays that sum up to a target value, K. \\n\\nThe key difference between this problem and the current problem is that the \"Subarray Sum Equals K\" problem deals with a predefined array that may contain any integers, not necessarily consecutive. Additionally, the subarray can start and end at any position within the array.\\n\\nOn the other hand, the problem \"Number of Ways to Write N as a Sum of Consecutive Positive Integers\" is about finding sequences of consecutive positive integers that sum up to a given number, N. Here, you\\'re not given any array to start with, and the integers must be consecutive. Moreover, these sequences can start from any positive integer, not just from the first element of an array.\\n\\nAs a result, the map/set strategy for \"Subarray Sum Equals K\" problem doesn\\'t directly apply here, because we\\'re not given an array, and we need to deal with sequences of consecutive integers instead. In other words, the two problems are asking for different things, and the approach used for one does not directly translate to the other.\\n"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Here O(sqrt(n)) is possible because the equivalent input `nums` has a strong pattern."
                    },
                    {
                        "username": "sukidayo",
                        "content": "3 useful facts:\\n1. n + (n+1) + (n+2) + ... + (n+k-1) = (2n+k-1)*k/2\\n2. (2n+k-1)*k/2 mod k = 0 if k is odd\\n3. (2n+k-1)*k/2 mod k = k/2 if k is even"
                    },
                    {
                        "username": "newcomer03",
                        "content": "I am getting a TLE on a test-case for n=53965645, but when I add it to my test-cases and run it, it passes the test-case... What should I do??\nint consecutiveNumbersSum(int n) {\n        long int sum = 0;\n        int ctr = 1;\n        if(n==1 || n==2)\n            return 1;\n        for(int i=1; i<n/2+1; i++)\n        {\n            for(int j=i; j<=n/2+2; j++)\n            {\n                if(sum<n)\n                {\n                    sum += j;\n                }\n                else\n                {\n                    if(sum==n)\n                        ctr++;\n                    sum = 0;\n                    break;\n                }\n            }\n        }\n        return ctr;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue you\\'re encountering is due to the time complexity of your solution. Your current approach has a time complexity of roughly O(n^2), which can be too slow for larger inputs like `n = 53965645`.\\n\\nYour code currently iterates over every number up to `n/2+1`, and for each of those numbers, it starts another loop to add numbers until the sum is equal to or greater than `n`. This process is quite time-consuming, especially for large inputs.\\n\\nA more efficient solution to this problem exists with a time complexity of O(sqrt(n)).\\n\\nHere is an optimized approach:\\n\\n1. Initiate a variable `count` to 0. This variable will keep track of the total number of ways.\\n2. Iterate `i` from 1 while `(i * (i + 1)) / 2 <= n`. This part uses the sum formula of an arithmetic progression, ensuring that the sum does not exceed `n`.\\n    - In each iteration, check if `n - (i * (i + 1)) / 2` is divisible by `i`. If it is, increment `count`.\\n3. At the end of the loop, `count` will be the answer.\\n\\nThis approach works because it efficiently checks for all possible lengths of sequences (i.e., `i`) that can sum up to `n`. \\n\\nPlease try to implement this approach in your code, and it should solve the TLE issue you\\'re currently facing. \\n\\nRemember, in coding problems, often brute force solutions can lead to time limit exceeded errors. It\\'s crucial to try and find patterns or mathematical properties that can help you optimize your solution. In this case, the key insight is understanding how arithmetic progressions work and using that to limit the search space effectively."
                    },
                    {
                        "username": "Seemon2000",
                        "content": "Thanks for posting these type of questions and if its here to scare 50% of the population for preparing for FAANGM companies then you have done a great job. I would really appreciate if you also mention for what kind of roles interviews, these type of questions are asked? Even someone getting interviewed for Support backend engineer, he/she should be knowing quantum theory of computing, I must salute the number of candidates giving importance to these companies and taking pride in living others dreams Inspite of having so much knowledge and talent!!! \\nPlease my suggestion is, if you could solve this problem on your own then do something good startup and work on your own ideas... work on how to control implications of AI/ML... Its very much needed for humanity!!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I think the problem doesn't require a deep understanding of math.Knowing only a basic high school formula is enough for solving it"
                    }
                ]
            },
            {
                "id": 1568590,
                "content": [
                    {
                        "username": "alexanderholman",
                        "content": "The solution to this problem is not challenging; the hard part is knowing when one can stop checking.\\n\\nFor a first attempt, a brute force of sorts was to iterate from `2` through `N` on smaller numbers and `sqrt(N)` on the larger ones, for each iteration summing `i` numbers, with the middle number roughly `N/i`. This solution barely passed, at about 7 seconds.\\n\\nIt took some googling to discover a mathematical approach, bringing the time complexity down to `O(N)`.\\n\\nIt took reading the solution to learn the formula of `k = sqrt((2N + (1/4)) - 1/2)`; allowing the `O(sqrt(N))` complexity.\\n\\nIn an interview, there is no way I would have gotten this in `O(N)` let alone anything better.\\n\\nThus, to the question outlined in the subject; in what roles would someone expect this sort of question? I have interviewed at many companies for general SWE and have never come across a question that relied on knowledge of any mathematical formulae.\\n\\nWas it just luck? Or are these question types specific to roles involving, for example, ML or similar?"
                    },
                    {
                        "username": "buddy_lee",
                        "content": "I haven\\'t interviewed much, so I\\'m not sure. I came up with a dynamic programming solution that exceeds the time limit for this problem. My intuition uses purely alogrithms and data structures, no mathematical insights. How common is it to run into interview problems that require some purely mathematical insight such as this one?\\n\\nI understand algorithms and math has some overlap, but this problem clearly requires more math than programming knowledge."
                    },
                    {
                        "username": "yeeeeetelite",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/\\n\\nHey guys,\\nNoob here. \\n\\nI wanted to know how is this question not the same as subarray sum equals to k?\\nI think I am missing something here?\\n\\nWhy cant we just create a map/set of runningSum and check everytime if runningSum -n is present in the set or not?"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question! Indeed, both problems involve dealing with sums and sequences, but they differ in their specifics. \\n\\nThe problem \"Subarray Sum Equals K\" is defined as: Given an array of integers and an integer K, you need to find the total number of continuous subarrays whose sum equals to K. In this problem, you\\'re dealing with an already given array, and you\\'re looking for all subarrays that sum up to a target value, K. \\n\\nThe key difference between this problem and the current problem is that the \"Subarray Sum Equals K\" problem deals with a predefined array that may contain any integers, not necessarily consecutive. Additionally, the subarray can start and end at any position within the array.\\n\\nOn the other hand, the problem \"Number of Ways to Write N as a Sum of Consecutive Positive Integers\" is about finding sequences of consecutive positive integers that sum up to a given number, N. Here, you\\'re not given any array to start with, and the integers must be consecutive. Moreover, these sequences can start from any positive integer, not just from the first element of an array.\\n\\nAs a result, the map/set strategy for \"Subarray Sum Equals K\" problem doesn\\'t directly apply here, because we\\'re not given an array, and we need to deal with sequences of consecutive integers instead. In other words, the two problems are asking for different things, and the approach used for one does not directly translate to the other.\\n"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Here O(sqrt(n)) is possible because the equivalent input `nums` has a strong pattern."
                    },
                    {
                        "username": "sukidayo",
                        "content": "3 useful facts:\\n1. n + (n+1) + (n+2) + ... + (n+k-1) = (2n+k-1)*k/2\\n2. (2n+k-1)*k/2 mod k = 0 if k is odd\\n3. (2n+k-1)*k/2 mod k = k/2 if k is even"
                    },
                    {
                        "username": "newcomer03",
                        "content": "I am getting a TLE on a test-case for n=53965645, but when I add it to my test-cases and run it, it passes the test-case... What should I do??\nint consecutiveNumbersSum(int n) {\n        long int sum = 0;\n        int ctr = 1;\n        if(n==1 || n==2)\n            return 1;\n        for(int i=1; i<n/2+1; i++)\n        {\n            for(int j=i; j<=n/2+2; j++)\n            {\n                if(sum<n)\n                {\n                    sum += j;\n                }\n                else\n                {\n                    if(sum==n)\n                        ctr++;\n                    sum = 0;\n                    break;\n                }\n            }\n        }\n        return ctr;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue you\\'re encountering is due to the time complexity of your solution. Your current approach has a time complexity of roughly O(n^2), which can be too slow for larger inputs like `n = 53965645`.\\n\\nYour code currently iterates over every number up to `n/2+1`, and for each of those numbers, it starts another loop to add numbers until the sum is equal to or greater than `n`. This process is quite time-consuming, especially for large inputs.\\n\\nA more efficient solution to this problem exists with a time complexity of O(sqrt(n)).\\n\\nHere is an optimized approach:\\n\\n1. Initiate a variable `count` to 0. This variable will keep track of the total number of ways.\\n2. Iterate `i` from 1 while `(i * (i + 1)) / 2 <= n`. This part uses the sum formula of an arithmetic progression, ensuring that the sum does not exceed `n`.\\n    - In each iteration, check if `n - (i * (i + 1)) / 2` is divisible by `i`. If it is, increment `count`.\\n3. At the end of the loop, `count` will be the answer.\\n\\nThis approach works because it efficiently checks for all possible lengths of sequences (i.e., `i`) that can sum up to `n`. \\n\\nPlease try to implement this approach in your code, and it should solve the TLE issue you\\'re currently facing. \\n\\nRemember, in coding problems, often brute force solutions can lead to time limit exceeded errors. It\\'s crucial to try and find patterns or mathematical properties that can help you optimize your solution. In this case, the key insight is understanding how arithmetic progressions work and using that to limit the search space effectively."
                    },
                    {
                        "username": "Seemon2000",
                        "content": "Thanks for posting these type of questions and if its here to scare 50% of the population for preparing for FAANGM companies then you have done a great job. I would really appreciate if you also mention for what kind of roles interviews, these type of questions are asked? Even someone getting interviewed for Support backend engineer, he/she should be knowing quantum theory of computing, I must salute the number of candidates giving importance to these companies and taking pride in living others dreams Inspite of having so much knowledge and talent!!! \\nPlease my suggestion is, if you could solve this problem on your own then do something good startup and work on your own ideas... work on how to control implications of AI/ML... Its very much needed for humanity!!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I think the problem doesn't require a deep understanding of math.Knowing only a basic high school formula is enough for solving it"
                    }
                ]
            },
            {
                "id": 2077473,
                "content": [
                    {
                        "username": "alexanderholman",
                        "content": "The solution to this problem is not challenging; the hard part is knowing when one can stop checking.\\n\\nFor a first attempt, a brute force of sorts was to iterate from `2` through `N` on smaller numbers and `sqrt(N)` on the larger ones, for each iteration summing `i` numbers, with the middle number roughly `N/i`. This solution barely passed, at about 7 seconds.\\n\\nIt took some googling to discover a mathematical approach, bringing the time complexity down to `O(N)`.\\n\\nIt took reading the solution to learn the formula of `k = sqrt((2N + (1/4)) - 1/2)`; allowing the `O(sqrt(N))` complexity.\\n\\nIn an interview, there is no way I would have gotten this in `O(N)` let alone anything better.\\n\\nThus, to the question outlined in the subject; in what roles would someone expect this sort of question? I have interviewed at many companies for general SWE and have never come across a question that relied on knowledge of any mathematical formulae.\\n\\nWas it just luck? Or are these question types specific to roles involving, for example, ML or similar?"
                    },
                    {
                        "username": "buddy_lee",
                        "content": "I haven\\'t interviewed much, so I\\'m not sure. I came up with a dynamic programming solution that exceeds the time limit for this problem. My intuition uses purely alogrithms and data structures, no mathematical insights. How common is it to run into interview problems that require some purely mathematical insight such as this one?\\n\\nI understand algorithms and math has some overlap, but this problem clearly requires more math than programming knowledge."
                    },
                    {
                        "username": "yeeeeetelite",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/\\n\\nHey guys,\\nNoob here. \\n\\nI wanted to know how is this question not the same as subarray sum equals to k?\\nI think I am missing something here?\\n\\nWhy cant we just create a map/set of runningSum and check everytime if runningSum -n is present in the set or not?"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question! Indeed, both problems involve dealing with sums and sequences, but they differ in their specifics. \\n\\nThe problem \"Subarray Sum Equals K\" is defined as: Given an array of integers and an integer K, you need to find the total number of continuous subarrays whose sum equals to K. In this problem, you\\'re dealing with an already given array, and you\\'re looking for all subarrays that sum up to a target value, K. \\n\\nThe key difference between this problem and the current problem is that the \"Subarray Sum Equals K\" problem deals with a predefined array that may contain any integers, not necessarily consecutive. Additionally, the subarray can start and end at any position within the array.\\n\\nOn the other hand, the problem \"Number of Ways to Write N as a Sum of Consecutive Positive Integers\" is about finding sequences of consecutive positive integers that sum up to a given number, N. Here, you\\'re not given any array to start with, and the integers must be consecutive. Moreover, these sequences can start from any positive integer, not just from the first element of an array.\\n\\nAs a result, the map/set strategy for \"Subarray Sum Equals K\" problem doesn\\'t directly apply here, because we\\'re not given an array, and we need to deal with sequences of consecutive integers instead. In other words, the two problems are asking for different things, and the approach used for one does not directly translate to the other.\\n"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Here O(sqrt(n)) is possible because the equivalent input `nums` has a strong pattern."
                    },
                    {
                        "username": "sukidayo",
                        "content": "3 useful facts:\\n1. n + (n+1) + (n+2) + ... + (n+k-1) = (2n+k-1)*k/2\\n2. (2n+k-1)*k/2 mod k = 0 if k is odd\\n3. (2n+k-1)*k/2 mod k = k/2 if k is even"
                    },
                    {
                        "username": "newcomer03",
                        "content": "I am getting a TLE on a test-case for n=53965645, but when I add it to my test-cases and run it, it passes the test-case... What should I do??\nint consecutiveNumbersSum(int n) {\n        long int sum = 0;\n        int ctr = 1;\n        if(n==1 || n==2)\n            return 1;\n        for(int i=1; i<n/2+1; i++)\n        {\n            for(int j=i; j<=n/2+2; j++)\n            {\n                if(sum<n)\n                {\n                    sum += j;\n                }\n                else\n                {\n                    if(sum==n)\n                        ctr++;\n                    sum = 0;\n                    break;\n                }\n            }\n        }\n        return ctr;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue you\\'re encountering is due to the time complexity of your solution. Your current approach has a time complexity of roughly O(n^2), which can be too slow for larger inputs like `n = 53965645`.\\n\\nYour code currently iterates over every number up to `n/2+1`, and for each of those numbers, it starts another loop to add numbers until the sum is equal to or greater than `n`. This process is quite time-consuming, especially for large inputs.\\n\\nA more efficient solution to this problem exists with a time complexity of O(sqrt(n)).\\n\\nHere is an optimized approach:\\n\\n1. Initiate a variable `count` to 0. This variable will keep track of the total number of ways.\\n2. Iterate `i` from 1 while `(i * (i + 1)) / 2 <= n`. This part uses the sum formula of an arithmetic progression, ensuring that the sum does not exceed `n`.\\n    - In each iteration, check if `n - (i * (i + 1)) / 2` is divisible by `i`. If it is, increment `count`.\\n3. At the end of the loop, `count` will be the answer.\\n\\nThis approach works because it efficiently checks for all possible lengths of sequences (i.e., `i`) that can sum up to `n`. \\n\\nPlease try to implement this approach in your code, and it should solve the TLE issue you\\'re currently facing. \\n\\nRemember, in coding problems, often brute force solutions can lead to time limit exceeded errors. It\\'s crucial to try and find patterns or mathematical properties that can help you optimize your solution. In this case, the key insight is understanding how arithmetic progressions work and using that to limit the search space effectively."
                    },
                    {
                        "username": "Seemon2000",
                        "content": "Thanks for posting these type of questions and if its here to scare 50% of the population for preparing for FAANGM companies then you have done a great job. I would really appreciate if you also mention for what kind of roles interviews, these type of questions are asked? Even someone getting interviewed for Support backend engineer, he/she should be knowing quantum theory of computing, I must salute the number of candidates giving importance to these companies and taking pride in living others dreams Inspite of having so much knowledge and talent!!! \\nPlease my suggestion is, if you could solve this problem on your own then do something good startup and work on your own ideas... work on how to control implications of AI/ML... Its very much needed for humanity!!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I think the problem doesn't require a deep understanding of math.Knowing only a basic high school formula is enough for solving it"
                    }
                ]
            },
            {
                "id": 1936241,
                "content": [
                    {
                        "username": "alexanderholman",
                        "content": "The solution to this problem is not challenging; the hard part is knowing when one can stop checking.\\n\\nFor a first attempt, a brute force of sorts was to iterate from `2` through `N` on smaller numbers and `sqrt(N)` on the larger ones, for each iteration summing `i` numbers, with the middle number roughly `N/i`. This solution barely passed, at about 7 seconds.\\n\\nIt took some googling to discover a mathematical approach, bringing the time complexity down to `O(N)`.\\n\\nIt took reading the solution to learn the formula of `k = sqrt((2N + (1/4)) - 1/2)`; allowing the `O(sqrt(N))` complexity.\\n\\nIn an interview, there is no way I would have gotten this in `O(N)` let alone anything better.\\n\\nThus, to the question outlined in the subject; in what roles would someone expect this sort of question? I have interviewed at many companies for general SWE and have never come across a question that relied on knowledge of any mathematical formulae.\\n\\nWas it just luck? Or are these question types specific to roles involving, for example, ML or similar?"
                    },
                    {
                        "username": "buddy_lee",
                        "content": "I haven\\'t interviewed much, so I\\'m not sure. I came up with a dynamic programming solution that exceeds the time limit for this problem. My intuition uses purely alogrithms and data structures, no mathematical insights. How common is it to run into interview problems that require some purely mathematical insight such as this one?\\n\\nI understand algorithms and math has some overlap, but this problem clearly requires more math than programming knowledge."
                    },
                    {
                        "username": "yeeeeetelite",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/\\n\\nHey guys,\\nNoob here. \\n\\nI wanted to know how is this question not the same as subarray sum equals to k?\\nI think I am missing something here?\\n\\nWhy cant we just create a map/set of runningSum and check everytime if runningSum -n is present in the set or not?"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question! Indeed, both problems involve dealing with sums and sequences, but they differ in their specifics. \\n\\nThe problem \"Subarray Sum Equals K\" is defined as: Given an array of integers and an integer K, you need to find the total number of continuous subarrays whose sum equals to K. In this problem, you\\'re dealing with an already given array, and you\\'re looking for all subarrays that sum up to a target value, K. \\n\\nThe key difference between this problem and the current problem is that the \"Subarray Sum Equals K\" problem deals with a predefined array that may contain any integers, not necessarily consecutive. Additionally, the subarray can start and end at any position within the array.\\n\\nOn the other hand, the problem \"Number of Ways to Write N as a Sum of Consecutive Positive Integers\" is about finding sequences of consecutive positive integers that sum up to a given number, N. Here, you\\'re not given any array to start with, and the integers must be consecutive. Moreover, these sequences can start from any positive integer, not just from the first element of an array.\\n\\nAs a result, the map/set strategy for \"Subarray Sum Equals K\" problem doesn\\'t directly apply here, because we\\'re not given an array, and we need to deal with sequences of consecutive integers instead. In other words, the two problems are asking for different things, and the approach used for one does not directly translate to the other.\\n"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Here O(sqrt(n)) is possible because the equivalent input `nums` has a strong pattern."
                    },
                    {
                        "username": "sukidayo",
                        "content": "3 useful facts:\\n1. n + (n+1) + (n+2) + ... + (n+k-1) = (2n+k-1)*k/2\\n2. (2n+k-1)*k/2 mod k = 0 if k is odd\\n3. (2n+k-1)*k/2 mod k = k/2 if k is even"
                    },
                    {
                        "username": "newcomer03",
                        "content": "I am getting a TLE on a test-case for n=53965645, but when I add it to my test-cases and run it, it passes the test-case... What should I do??\nint consecutiveNumbersSum(int n) {\n        long int sum = 0;\n        int ctr = 1;\n        if(n==1 || n==2)\n            return 1;\n        for(int i=1; i<n/2+1; i++)\n        {\n            for(int j=i; j<=n/2+2; j++)\n            {\n                if(sum<n)\n                {\n                    sum += j;\n                }\n                else\n                {\n                    if(sum==n)\n                        ctr++;\n                    sum = 0;\n                    break;\n                }\n            }\n        }\n        return ctr;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue you\\'re encountering is due to the time complexity of your solution. Your current approach has a time complexity of roughly O(n^2), which can be too slow for larger inputs like `n = 53965645`.\\n\\nYour code currently iterates over every number up to `n/2+1`, and for each of those numbers, it starts another loop to add numbers until the sum is equal to or greater than `n`. This process is quite time-consuming, especially for large inputs.\\n\\nA more efficient solution to this problem exists with a time complexity of O(sqrt(n)).\\n\\nHere is an optimized approach:\\n\\n1. Initiate a variable `count` to 0. This variable will keep track of the total number of ways.\\n2. Iterate `i` from 1 while `(i * (i + 1)) / 2 <= n`. This part uses the sum formula of an arithmetic progression, ensuring that the sum does not exceed `n`.\\n    - In each iteration, check if `n - (i * (i + 1)) / 2` is divisible by `i`. If it is, increment `count`.\\n3. At the end of the loop, `count` will be the answer.\\n\\nThis approach works because it efficiently checks for all possible lengths of sequences (i.e., `i`) that can sum up to `n`. \\n\\nPlease try to implement this approach in your code, and it should solve the TLE issue you\\'re currently facing. \\n\\nRemember, in coding problems, often brute force solutions can lead to time limit exceeded errors. It\\'s crucial to try and find patterns or mathematical properties that can help you optimize your solution. In this case, the key insight is understanding how arithmetic progressions work and using that to limit the search space effectively."
                    },
                    {
                        "username": "Seemon2000",
                        "content": "Thanks for posting these type of questions and if its here to scare 50% of the population for preparing for FAANGM companies then you have done a great job. I would really appreciate if you also mention for what kind of roles interviews, these type of questions are asked? Even someone getting interviewed for Support backend engineer, he/she should be knowing quantum theory of computing, I must salute the number of candidates giving importance to these companies and taking pride in living others dreams Inspite of having so much knowledge and talent!!! \\nPlease my suggestion is, if you could solve this problem on your own then do something good startup and work on your own ideas... work on how to control implications of AI/ML... Its very much needed for humanity!!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I think the problem doesn't require a deep understanding of math.Knowing only a basic high school formula is enough for solving it"
                    }
                ]
            },
            {
                "id": 1913727,
                "content": [
                    {
                        "username": "alexanderholman",
                        "content": "The solution to this problem is not challenging; the hard part is knowing when one can stop checking.\\n\\nFor a first attempt, a brute force of sorts was to iterate from `2` through `N` on smaller numbers and `sqrt(N)` on the larger ones, for each iteration summing `i` numbers, with the middle number roughly `N/i`. This solution barely passed, at about 7 seconds.\\n\\nIt took some googling to discover a mathematical approach, bringing the time complexity down to `O(N)`.\\n\\nIt took reading the solution to learn the formula of `k = sqrt((2N + (1/4)) - 1/2)`; allowing the `O(sqrt(N))` complexity.\\n\\nIn an interview, there is no way I would have gotten this in `O(N)` let alone anything better.\\n\\nThus, to the question outlined in the subject; in what roles would someone expect this sort of question? I have interviewed at many companies for general SWE and have never come across a question that relied on knowledge of any mathematical formulae.\\n\\nWas it just luck? Or are these question types specific to roles involving, for example, ML or similar?"
                    },
                    {
                        "username": "buddy_lee",
                        "content": "I haven\\'t interviewed much, so I\\'m not sure. I came up with a dynamic programming solution that exceeds the time limit for this problem. My intuition uses purely alogrithms and data structures, no mathematical insights. How common is it to run into interview problems that require some purely mathematical insight such as this one?\\n\\nI understand algorithms and math has some overlap, but this problem clearly requires more math than programming knowledge."
                    },
                    {
                        "username": "yeeeeetelite",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/\\n\\nHey guys,\\nNoob here. \\n\\nI wanted to know how is this question not the same as subarray sum equals to k?\\nI think I am missing something here?\\n\\nWhy cant we just create a map/set of runningSum and check everytime if runningSum -n is present in the set or not?"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s a good question! Indeed, both problems involve dealing with sums and sequences, but they differ in their specifics. \\n\\nThe problem \"Subarray Sum Equals K\" is defined as: Given an array of integers and an integer K, you need to find the total number of continuous subarrays whose sum equals to K. In this problem, you\\'re dealing with an already given array, and you\\'re looking for all subarrays that sum up to a target value, K. \\n\\nThe key difference between this problem and the current problem is that the \"Subarray Sum Equals K\" problem deals with a predefined array that may contain any integers, not necessarily consecutive. Additionally, the subarray can start and end at any position within the array.\\n\\nOn the other hand, the problem \"Number of Ways to Write N as a Sum of Consecutive Positive Integers\" is about finding sequences of consecutive positive integers that sum up to a given number, N. Here, you\\'re not given any array to start with, and the integers must be consecutive. Moreover, these sequences can start from any positive integer, not just from the first element of an array.\\n\\nAs a result, the map/set strategy for \"Subarray Sum Equals K\" problem doesn\\'t directly apply here, because we\\'re not given an array, and we need to deal with sequences of consecutive integers instead. In other words, the two problems are asking for different things, and the approach used for one does not directly translate to the other.\\n"
                    },
                    {
                        "username": "PabloLION",
                        "content": "Here O(sqrt(n)) is possible because the equivalent input `nums` has a strong pattern."
                    },
                    {
                        "username": "sukidayo",
                        "content": "3 useful facts:\\n1. n + (n+1) + (n+2) + ... + (n+k-1) = (2n+k-1)*k/2\\n2. (2n+k-1)*k/2 mod k = 0 if k is odd\\n3. (2n+k-1)*k/2 mod k = k/2 if k is even"
                    },
                    {
                        "username": "newcomer03",
                        "content": "I am getting a TLE on a test-case for n=53965645, but when I add it to my test-cases and run it, it passes the test-case... What should I do??\nint consecutiveNumbersSum(int n) {\n        long int sum = 0;\n        int ctr = 1;\n        if(n==1 || n==2)\n            return 1;\n        for(int i=1; i<n/2+1; i++)\n        {\n            for(int j=i; j<=n/2+2; j++)\n            {\n                if(sum<n)\n                {\n                    sum += j;\n                }\n                else\n                {\n                    if(sum==n)\n                        ctr++;\n                    sum = 0;\n                    break;\n                }\n            }\n        }\n        return ctr;\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue you\\'re encountering is due to the time complexity of your solution. Your current approach has a time complexity of roughly O(n^2), which can be too slow for larger inputs like `n = 53965645`.\\n\\nYour code currently iterates over every number up to `n/2+1`, and for each of those numbers, it starts another loop to add numbers until the sum is equal to or greater than `n`. This process is quite time-consuming, especially for large inputs.\\n\\nA more efficient solution to this problem exists with a time complexity of O(sqrt(n)).\\n\\nHere is an optimized approach:\\n\\n1. Initiate a variable `count` to 0. This variable will keep track of the total number of ways.\\n2. Iterate `i` from 1 while `(i * (i + 1)) / 2 <= n`. This part uses the sum formula of an arithmetic progression, ensuring that the sum does not exceed `n`.\\n    - In each iteration, check if `n - (i * (i + 1)) / 2` is divisible by `i`. If it is, increment `count`.\\n3. At the end of the loop, `count` will be the answer.\\n\\nThis approach works because it efficiently checks for all possible lengths of sequences (i.e., `i`) that can sum up to `n`. \\n\\nPlease try to implement this approach in your code, and it should solve the TLE issue you\\'re currently facing. \\n\\nRemember, in coding problems, often brute force solutions can lead to time limit exceeded errors. It\\'s crucial to try and find patterns or mathematical properties that can help you optimize your solution. In this case, the key insight is understanding how arithmetic progressions work and using that to limit the search space effectively."
                    },
                    {
                        "username": "Seemon2000",
                        "content": "Thanks for posting these type of questions and if its here to scare 50% of the population for preparing for FAANGM companies then you have done a great job. I would really appreciate if you also mention for what kind of roles interviews, these type of questions are asked? Even someone getting interviewed for Support backend engineer, he/she should be knowing quantum theory of computing, I must salute the number of candidates giving importance to these companies and taking pride in living others dreams Inspite of having so much knowledge and talent!!! \\nPlease my suggestion is, if you could solve this problem on your own then do something good startup and work on your own ideas... work on how to control implications of AI/ML... Its very much needed for humanity!!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I think the problem doesn't require a deep understanding of math.Knowing only a basic high school formula is enough for solving it"
                    }
                ]
            }
        ]
    },
    {
        "title": "Get Equal Substrings Within Budget",
        "question_content": "<p>You are given two strings <code>s</code> and <code>t</code> of the same length and an integer <code>maxCost</code>.</p>\n\n<p>You want to change <code>s</code> to <code>t</code>. Changing the <code>i<sup>th</sup></code> character of <code>s</code> to <code>i<sup>th</sup></code> character of <code>t</code> costs <code>|s[i] - t[i]|</code> (i.e., the absolute difference between the ASCII values of the characters).</p>\n\n<p>Return <em>the maximum length of a substring of </em><code>s</code><em> that can be changed to be the same as the corresponding substring of </em><code>t</code><em> with a cost less than or equal to </em><code>maxCost</code>. If there is no substring from <code>s</code> that can be changed to its corresponding substring from <code>t</code>, return <code>0</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcd&quot;, t = &quot;bcdf&quot;, maxCost = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> &quot;abc&quot; of s can change to &quot;bcd&quot;.\nThat costs 3, so the maximum length is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcd&quot;, t = &quot;cdef&quot;, maxCost = 3\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Each character in s costs 2 to change to character in t,  so the maximum length is 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcd&quot;, t = &quot;acde&quot;, maxCost = 0\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> You cannot make any change, so the maximum length is 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>t.length == s.length</code></li>\n\t<li><code>0 &lt;= maxCost &lt;= 10<sup>6</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 392837,
                "title": "java-c-python-sliding-window",
                "content": "## **Intuition**\\nChange the input of string `s` and `t` into an array of difference.\\nThen it\\'s a standard sliding window problem.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)` for one pass\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int equalSubstring(String s, String t, int k) {\\n        int n = s.length(), i = 0, j;\\n        for (j = 0; j < n; ++j) {\\n            k -= Math.abs(s.charAt(j) - t.charAt(j));\\n            if (k < 0) {\\n                k += Math.abs(s.charAt(i) - t.charAt(i));\\n                ++i;\\n            }\\n        }\\n        return j - i;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int equalSubstring(string s, string t, int k) {\\n        int n = s.length(), i = 0, j;\\n        for (j = 0; j < n; ++j) {\\n            if ((k -= abs(s[j] - t[j])) < 0)\\n                k += abs(s[i] - t[i++]);\\n        }\\n        return j - i;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def equalSubstring(self, s, t, cost):\\n        i = 0\\n        for j in xrange(len(s)):\\n            cost -= abs(ord(s[j]) - ord(t[j]))\\n            if cost < 0:\\n                cost += abs(ord(s[i]) - ord(t[i]))\\n                i += 1\\n        return j - i + 1\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int equalSubstring(String s, String t, int k) {\\n        int n = s.length(), i = 0, j;\\n        for (j = 0; j < n; ++j) {\\n            k -= Math.abs(s.charAt(j) - t.charAt(j));\\n            if (k < 0) {\\n                k += Math.abs(s.charAt(i) - t.charAt(i));\\n                ++i;\\n            }\\n        }\\n        return j - i;\\n    }\\n```\n```cpp\\n    int equalSubstring(string s, string t, int k) {\\n        int n = s.length(), i = 0, j;\\n        for (j = 0; j < n; ++j) {\\n            if ((k -= abs(s[j] - t[j])) < 0)\\n                k += abs(s[i] - t[i++]);\\n        }\\n        return j - i;\\n    }\\n```\n```python\\n    def equalSubstring(self, s, t, cost):\\n        i = 0\\n        for j in xrange(len(s)):\\n            cost -= abs(ord(s[j]) - ord(t[j]))\\n            if cost < 0:\\n                cost += abs(ord(s[i]) - ord(t[i]))\\n                i += 1\\n        return j - i + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 392833,
                "title": "c-sliding-window-o-n-prefix-sum-o-nlogn-implementations",
                "content": "**Observation**\\nSince we need to find the maximum substring that can be replaced we can actually breakdown this problem to an array of integers that represent the replacement cost of `s[i]` to `t[i]` and then find the maximum length of continuous integers in that array whose `sum <= maxCost`.\\neg:\\n`s = \"aabcd\"`\\n`t =  \"zbdag\"`\\nThe array to find the maximum length on comes out to` [1,1,2,2,3]`.\\n\\nThis problem can now be solved in many ways, two of which are descibed below.\\nSomewhat similar to `209. Minimum Size Subarray Sum`\\n\\n**Sliding window solution**\\nIn general a sliding window is when we keep increasing the size of the window by increasing the right end to fit our goal, if it increases the goal we reduce the window by  sliding the left end until it again fits the goal, this ensures that the maximum window size is attained.\\n```c++\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) \\n    {\\n        int start=0,end=0,sum=0;\\n        while(end<s.length())\\n        {\\n            sum+=abs(s[end]-t[end++]);\\n            if(sum>maxCost)\\n                sum-=abs(s[start]-t[start++]);\\n        }\\n        return end-start;\\n    }\\n};\\n```\\n\\n**Complexity**\\nTime: O(n). Since each element is added and removed once at max.\\nSpace: O(1). Since we get the elemets of sum array on the fly.\\n\\n**Prefix sum slolution**\\nHere we create an array of prefix sums that hold the sum of differences from `0` to `i`.\\nAt every iteration of `i` we can find the continuous sum of `numbers <= maxCost` by binary searching the lowerbound of `prefixSum[i] - maxCost`.\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) \\n    {\\n        vector<int> prefixDiffSum(s.length()+1,0);\\n        int Max=0;\\n        for(int i=1;i<s.length()+1;i++)\\n        {\\n            prefixDiffSum[i]=prefixDiffSum[i-1]+abs(s[i-1]-t[i-1]);   //Stores sum of differences from begining till i.\\n            Max=max(Max,i-(int)(lower_bound(prefixDiffSum.begin(),prefixDiffSum.begin()+i+1,prefixDiffSum[i]-maxCost)-prefixDiffSum.begin()));         //Binary search to find start of the window that holds sum<=maxCost and ends with i.\\n        }\\n        return Max;\\n    }\\n};\\n```\\n**Complexity**\\nTime: O(nlogn). \\nSpace: O(n). Storing prefix sums.",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) \\n    {\\n        int start=0,end=0,sum=0;\\n        while(end<s.length())\\n        {\\n            sum+=abs(s[end]-t[end++]);\\n            if(sum>maxCost)\\n                sum-=abs(s[start]-t[start++]);\\n        }\\n        return end-start;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) \\n    {\\n        vector<int> prefixDiffSum(s.length()+1,0);\\n        int Max=0;\\n        for(int i=1;i<s.length()+1;i++)\\n        {\\n            prefixDiffSum[i]=prefixDiffSum[i-1]+abs(s[i-1]-t[i-1]);   //Stores sum of differences from begining till i.\\n            Max=max(Max,i-(int)(lower_bound(prefixDiffSum.begin(),prefixDiffSum.begin()+i+1,prefixDiffSum[i]-maxCost)-prefixDiffSum.begin()));         //Binary search to find start of the window that holds sum<=maxCost and ends with i.\\n        }\\n        return Max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392950,
                "title": "java-sliding-window-with-clear-explanation",
                "content": "**Explanation:**\\n\\nThe idea is that you want to convert one character to another in that same position i.e. s[i] to t[i] such that you form the longest contiguous converted String.\\n\\nThere is just one key realization that you must make to solve this problem:\\n\\nYou need to realize that this problem can be reduced to finding the longest subarray such that the sum of the elements in that subarray is less than maxCost.\\n\\nThis is because you can generate an array `diff` such that `diff[i] = Math.abs(s[i] - t[i])` which is the cost of converting one character to another. You also want to find the maximum length substring that can be converted given the maxCost so this is equivalent to finding the longest subarray in `diff` which has sum of elements less than cost.\\n\\nFor this we can use a sliding window. We slide the `end` of the window to the right with each step. If the total sum exceeds the maxCost, we slide the `start` of the window to the right until the total sum inside the window is less than maxCosts. With each eligible window, we take the length and keep track of the maximum length.\\n\\nFor more info on sliding window: [Explanation](https://www.geeksforgeeks.org/window-sliding-technique/)\\n\\n**Code:**\\n\\n```\\n\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        // Convert the problem into a min subarray problem\\n        int[] diff = new int[s.length()];\\n        for(int i = 0; i < s.length(); ++i) {\\n            int asciiS = s.charAt(i);\\n            int asciiT = t.charAt(i);\\n            diff[i] = Math.abs(asciiS - asciiT);\\n        }\\n        \\n        // Now find the longest subarray <= maxCost\\n        // all diff[i] >= 0 (non-negative)\\n        \\n        // Use sliding window?\\n        int maxLen = 0;\\n        int curCost = 0;\\n        int start = 0;\\n        \\n        for(int end = 0; end < diff.length; ++end) {\\n            curCost += diff[end];\\n            while(curCost > maxCost) {\\n                curCost -= diff[start];\\n                ++start;\\n            }\\n            maxLen = Math.max(maxLen, end - start + 1);\\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n```\\n\\n`Time Complexity: O(N) where N is the length of strings s, t`\\n`Space Complexity: O(N) for diff`\\nNote: O(1) space can be achieved if we don\\'t create the diff array - we can just get the values on the fly.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        // Convert the problem into a min subarray problem\\n        int[] diff = new int[s.length()];\\n        for(int i = 0; i < s.length(); ++i) {\\n            int asciiS = s.charAt(i);\\n            int asciiT = t.charAt(i);\\n            diff[i] = Math.abs(asciiS - asciiT);\\n        }\\n        \\n        // Now find the longest subarray <= maxCost\\n        // all diff[i] >= 0 (non-negative)\\n        \\n        // Use sliding window?\\n        int maxLen = 0;\\n        int curCost = 0;\\n        int start = 0;\\n        \\n        for(int end = 0; end < diff.length; ++end) {\\n            curCost += diff[end];\\n            while(curCost > maxCost) {\\n                curCost -= diff[start];\\n                ++start;\\n            }\\n            maxLen = Math.max(maxLen, end - start + 1);\\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392901,
                "title": "standard-python-moving-window-similar-problems-listed",
                "content": "Please see and vote for my solutions for these similar problems.\\n[1208. Get Equal Substrings Within Budget](https://leetcode.com/problems/get-equal-substrings-within-budget/discuss/392901/Simple-Python-moving-window)\\n[3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/348137/Simple-Python-two-pointer-solution-(52ms-beat-97.94))\\n[159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/348157/Simple-Python-two-pointer-solution)\\n[340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/348216/Simple-Python-two-pointer-solution-(72-ms-beat-94.93))\\n[992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/348984/Different-Python-two-pointer-solutions)\\n[424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/discuss/363071/Simple-Python-two-pointer-solution)\\n[209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/344476/Simple-Python-two-pointer-solution)\\n[713. Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/discuss/344245/Simple-Python-solution-(beat-94.59))\\n[76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/discuss/344533/Simple-Python-two-pointer-solution)\\n\\n```\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        n = len(s)\\n        cost = 0\\n        left = 0\\n        max_len = 0\\n        for right in range(n):\\n            cost += abs(ord(s[right]) - ord(t[right]))\\n            while cost > maxCost:\\n                cost -= abs(ord(s[left]) - ord(t[left]))\\n                left += 1\\n            max_len = max(max_len, right - left + 1)\\n        return max_len\\n```",
                "solutionTags": [],
                "code": "```\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        n = len(s)\\n        cost = 0\\n        left = 0\\n        max_len = 0\\n        for right in range(n):\\n            cost += abs(ord(s[right]) - ord(t[right]))\\n            while cost > maxCost:\\n                cost -= abs(ord(s[left]) - ord(t[left]))\\n                left += 1\\n            max_len = max(max_len, right - left + 1)\\n        return max_len\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 392857,
                "title": "c-java-sliding-window-o-n-o-1",
                "content": "# Intuition\\nInstead of two string, we can imagine an array of the same size with absolute differences. Then, the problem is to find the longest subarray with the sum not exceeding ```maxCost```.\\n# Sliding Window\\nWe can use a sliding window technique when we move right ```i``` pointer and decrease ```maxCost```, and increment left ```j``` pointer, increasing  ```maxCost``` if it is negative.\\n\\nThen, the difference ```i - j``` is our answer.\\n### C++\\n```\\nint equalSubstring(string s, string t, int maxCost) {\\n  auto i = 0, j = 0;\\n  while (i < s.size()) {\\n    maxCost -= abs(s[i] - t[i++]);\\n    if (maxCost < 0) maxCost += abs(s[j] - t[j++]);\\n  }\\n  return i - j;\\n}\\n```\\n### Java\\n```\\npublic int equalSubstring(String s, String t, int maxCost) {\\n  int i = 0, j = 0;\\n  while (i < s.length()) {\\n    maxCost -= Math.abs(s.charAt(i) - t.charAt(i++));\\n    if (maxCost < 0) maxCost += Math.abs(s.charAt(j) - t.charAt(j++));\\n  }\\n  return i - j;\\n}\\n```\\n# Complexity Analysis\\nTime: O(n)\\nMemory: O(1)",
                "solutionTags": [],
                "code": "```maxCost```\n```i```\n```maxCost```\n```j```\n```maxCost```\n```i - j```\n```\\nint equalSubstring(string s, string t, int maxCost) {\\n  auto i = 0, j = 0;\\n  while (i < s.size()) {\\n    maxCost -= abs(s[i] - t[i++]);\\n    if (maxCost < 0) maxCost += abs(s[j] - t[j++]);\\n  }\\n  return i - j;\\n}\\n```\n```\\npublic int equalSubstring(String s, String t, int maxCost) {\\n  int i = 0, j = 0;\\n  while (i < s.length()) {\\n    maxCost -= Math.abs(s.charAt(i) - t.charAt(i++));\\n    if (maxCost < 0) maxCost += Math.abs(s.charAt(j) - t.charAt(j++));\\n  }\\n  return i - j;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392841,
                "title": "java-python-3-sliding-window-space-o-1-w-brief-explanation-and-analysis",
                "content": "1. Maintain a window and keep accumulating the cost on `hi` end; if the cost is higher than `maxCost`, then shrink widow by removing element from `lo` end; \\n2. Update the max window `width` during each iteration.\\n\\n```\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int width = 0;\\n        for (int hi = 0, lo = -1; hi < s.length(); ++hi) {\\n            maxCost -= Math.abs(s.charAt(hi) - t.charAt(hi));\\n            if (maxCost < 0) {\\n                ++lo;\\n                maxCost += Math.abs(s.charAt(lo) - t.charAt(lo));\\n            }\\n            width = Math.max(width, hi - lo);\\n        }\\n        return width;\\n    }\\n```\\n```\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        width, lo = 0, -1\\n        for hi in range(len(s)):\\n            maxCost -= abs(ord(s[hi]) - ord(t[hi]))\\n            if maxCost < 0:\\n                lo += 1\\n                maxCost += abs(ord(s[lo]) - ord(t[lo]))\\n            width = max(width, hi - lo)\\n        return width\\n```\\n**Analysis:**\\n\\nTime: O(n), space: O(1), where n = s.length().",
                "solutionTags": [],
                "code": "```\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int width = 0;\\n        for (int hi = 0, lo = -1; hi < s.length(); ++hi) {\\n            maxCost -= Math.abs(s.charAt(hi) - t.charAt(hi));\\n            if (maxCost < 0) {\\n                ++lo;\\n                maxCost += Math.abs(s.charAt(lo) - t.charAt(lo));\\n            }\\n            width = Math.max(width, hi - lo);\\n        }\\n        return width;\\n    }\\n```\n```\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        width, lo = 0, -1\\n        for hi in range(len(s)):\\n            maxCost -= abs(ord(s[hi]) - ord(t[hi]))\\n            if maxCost < 0:\\n                lo += 1\\n                maxCost += abs(ord(s[lo]) - ord(t[lo]))\\n            width = max(width, hi - lo)\\n        return width\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1201553,
                "title": "c-easiest",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n\\t\\n        int n=s.size(),arr[n];\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n            arr[i]=abs(s[i]-t[i]);\\n        \\n        int cost=0,start=0,maxlen=INT_MIN;\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n            cost+=arr[i];\\n        \\n            while(cost>maxCost)\\n                cost-=arr[start++];\\n        \\n            maxlen=max(maxlen,i-start+1);\\n        }\\n        return maxlen;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n\\t\\n        int n=s.size(),arr[n];\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n            arr[i]=abs(s[i]-t[i]);\\n        \\n        int cost=0,start=0,maxlen=INT_MIN;\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n            cost+=arr[i];\\n        \\n            while(cost>maxCost)\\n                cost-=arr[start++];\\n        \\n            maxlen=max(maxlen,i-start+1);\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932654,
                "title": "easy-prefsum-binarysearch-o-nlogn",
                "content": "# Intuition\\nThe intution came to me when i was solving the question i saw i needed to find a substring sum which leads me to this size or less.\\n# Approach\\nMade a prefix sum to calculate sum/change cost in O(1)\\nThen i searched substring of size k which satisfy the value and then if it satisfied i searched for higher values otherwise lesser size.\\n# Complexity\\n- Time complexity:O(NLogN)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& pref , int cost , int mid){\\n        int l = 0 , r = mid;\\n        int flag = false;\\n        while(r < pref.size()){\\n            int sum = pref[r] - pref[l];\\n            if(sum <= cost){\\n                flag = true;\\n                break;\\n            }\\n            l++;\\n            r++;\\n        }\\n        return flag;\\n    }\\n    int equalSubstring(string s, string t, int cost) {\\n        int n = s.size();\\n        vector<int> pref(n + 1 , 0);\\n        for(int i = 1 ; i <= n ; i++){\\n            pref[i] = pref[i-1] + abs((s[i - 1] - \\'a\\') - (t[i - 1] - \\'a\\'));\\n        }\\n        int l = 0 , h = s.size()+1;\\n        int ans = 0;\\n        while(l <= h){\\n            int mid = l + (h - l)/2;\\n            if(check(pref , cost , mid)){\\n                ans = mid ;\\n                l = mid + 1;\\n            }\\n            else{\\n                h = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& pref , int cost , int mid){\\n        int l = 0 , r = mid;\\n        int flag = false;\\n        while(r < pref.size()){\\n            int sum = pref[r] - pref[l];\\n            if(sum <= cost){\\n                flag = true;\\n                break;\\n            }\\n            l++;\\n            r++;\\n        }\\n        return flag;\\n    }\\n    int equalSubstring(string s, string t, int cost) {\\n        int n = s.size();\\n        vector<int> pref(n + 1 , 0);\\n        for(int i = 1 ; i <= n ; i++){\\n            pref[i] = pref[i-1] + abs((s[i - 1] - \\'a\\') - (t[i - 1] - \\'a\\'));\\n        }\\n        int l = 0 , h = s.size()+1;\\n        int ans = 0;\\n        while(l <= h){\\n            int mid = l + (h - l)/2;\\n            if(check(pref , cost , mid)){\\n                ans = mid ;\\n                l = mid + 1;\\n            }\\n            else{\\n                h = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743626,
                "title": "java-sliding-window",
                "content": "class Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        // Convert the problem into a min subarray problem\\n        int[] diff = new int[s.length()];\\n        for(int i = 0; i < s.length(); ++i) {\\n            int asciiS = s.charAt(i);\\n            int asciiT = t.charAt(i);\\n            diff[i] = Math.abs(asciiS - asciiT);\\n        }\\n        \\n        // Now find the longest subarray <= maxCost\\n        // all diff[i] >= 0 (non-negative)\\n        \\n        // Use sliding window?\\n        int maxLen = 0;\\n        int curCost = 0;\\n        int start = 0;\\n        \\n        for(int end = 0; end < diff.length; ++end) {\\n            curCost += diff[end];\\n            while(curCost > maxCost) {\\n                curCost -= diff[start];\\n                ++start;\\n            }\\n            maxLen = Math.max(maxLen, end - start + 1);\\n        }\\n        \\n        return maxLen;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        // Convert the problem into a min subarray problem\\n        int[] diff = new int[s.length()];\\n        for(int i = 0; i < s.length(); ++i) {\\n            int asciiS = s.charAt(i);\\n            int asciiT = t.charAt(i);\\n            diff[i] = Math.abs(asciiS - asciiT);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1529234,
                "title": "c-sliding-window-cheat-sheet",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Sliding Window\\n\\nCheck out \"[C++ Maximum Sliding Window Cheatsheet Template!](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!)\".\\n\\nShrinkable Sliding Window:\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/get-equal-substrings-within-budget/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int i = 0, j = 0, N = s.size(), cost = 0, ans = 0;\\n        for (; j < N; ++j) {\\n            cost += abs(s[j] - t[j]);\\n            for (; cost > maxCost; ++i) cost -= abs(s[i] - t[i]);\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nNon-shrinkable Sliding Window:\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/get-equal-substrings-within-budget/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int i = 0, j = 0, N = s.size(), cost = 0;\\n        for (; j < N; ++j) {\\n            cost += abs(s[j] - t[j]);\\n            if (cost > maxCost) {\\n                cost -= abs(s[i] - t[i]);\\n                ++i;\\n            }\\n        }\\n        return j - i;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/get-equal-substrings-within-budget/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int i = 0, j = 0, N = s.size(), cost = 0, ans = 0;\\n        for (; j < N; ++j) {\\n            cost += abs(s[j] - t[j]);\\n            for (; cost > maxCost; ++i) cost -= abs(s[i] - t[i]);\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/get-equal-substrings-within-budget/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int i = 0, j = 0, N = s.size(), cost = 0;\\n        for (; j < N; ++j) {\\n            cost += abs(s[j] - t[j]);\\n            if (cost > maxCost) {\\n                cost -= abs(s[i] - t[i]);\\n                ++i;\\n            }\\n        }\\n        return j - i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393080,
                "title": "javascript-easy-to-understand-2-solutions",
                "content": "## SOLUTION 1\\n\\nWe use the sliding window to solve it. The `left` and `right` means both edges of the window.\\n\\nSo, we could meet 2 situations when we move the right edge from start to end:\\n\\n- The cost is less than `maxCost`: we could update the max length;\\n- The cost is bigger than `maxCost`: we need to move the left edge to reduce cost.\\n\\nHere\\'s the code:\\n\\n```js\\nconst equalSubstring = (s, t, maxCost) => {\\n  let max = 0;\\n  for (let left = -1, right = 0; right < s.length; ++right) {\\n    maxCost -= Math.abs(s.charCodeAt(right) - t.charCodeAt(right));\\n    if (maxCost >= 0) {\\n      right - left > max && (max = right - left);\\n    } else {\\n      while (maxCost < 0) {\\n        ++left;\\n        maxCost += Math.abs(s.charCodeAt(left) - t.charCodeAt(left));\\n      }\\n    }\\n  }\\n  return max;\\n};\\n```\\n\\n## SOLUTION 2\\n\\nHere\\'s a more concise version of solution 1.\\n\\nWe move the right edge step by step just like solution 1. But the key point is that we also move the left edge step by step if it\\'s necessary.\\n\\nBut why? It\\'s pretty easy to find out that the window could be invalidated.\\n\\nLet\\'s see, first of all, we only need to find out the longest substring which means we don\\'t care about the others.\\n\\nThen, if we have a substring right now. There are only 2 situations:\\n\\n- We could find a longer one: the window will be validated naturally when we meet the longer one.\\n- It\\'s the longest one: we got the longest length even the current window may not be validated.\\n\\nSo, according to this, we could get this code:\\n\\n```js\\nconst equalSubstring = (s, t, maxCost) => {\\n  let left = -1;\\n  for (let right = 0; right < s.length; ++right) {\\n    maxCost -= Math.abs(s.charCodeAt(right) - t.charCodeAt(right));\\n    if (maxCost < 0) {\\n      ++left;\\n      maxCost += Math.abs(s.charCodeAt(left) - t.charCodeAt(left));\\n    }\\n  }\\n  return s.length - left - 1;\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst equalSubstring = (s, t, maxCost) => {\\n  let max = 0;\\n  for (let left = -1, right = 0; right < s.length; ++right) {\\n    maxCost -= Math.abs(s.charCodeAt(right) - t.charCodeAt(right));\\n    if (maxCost >= 0) {\\n      right - left > max && (max = right - left);\\n    } else {\\n      while (maxCost < 0) {\\n        ++left;\\n        maxCost += Math.abs(s.charCodeAt(left) - t.charCodeAt(left));\\n      }\\n    }\\n  }\\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392947,
                "title": "java-simple-sliding-window-10-lines-code-time-o-n-space-o-1",
                "content": "```java\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int l = 0, r = 0, n = s.length(), cost = 0, ans = 0;\\n        while (r < n) {\\n            cost += Math.abs(s.charAt(r) - t.charAt(r));\\n             while (cost > maxCost) {\\n                cost -= Math.abs(s.charAt(l) - t.charAt(l));\\n                l++;\\n            }\\n            ans = Math.max(ans, r - l + 1);\\n            r++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int l = 0, r = 0, n = s.length(), cost = 0, ans = 0;\\n        while (r < n) {\\n            cost += Math.abs(s.charAt(r) - t.charAt(r));\\n             while (cost > maxCost) {\\n                cost -= Math.abs(s.charAt(l) - t.charAt(l));\\n                l++;\\n            }\\n            ans = Math.max(ans, r - l + 1);\\n            r++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695539,
                "title": "simplest-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        vector<int> v(t.size());\\n        for(int i=0;i<t.size();i++)\\n        {\\n            v[i]=abs(t[i]-s[i]);\\n        }\\n        int ans=0;\\n        int i=0;\\n        int j=0;\\n        int k=maxCost;\\n        while(i<t.size())\\n        {\\n            k-=v[i];\\n            while(k<0)\\n            {\\n                k+=v[j];\\n                j++;\\n            }\\n            ans=max(ans,i-j+1);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        vector<int> v(t.size());\\n        for(int i=0;i<t.size();i++)\\n        {\\n            v[i]=abs(t[i]-s[i]);\\n        }\\n        int ans=0;\\n        int i=0;\\n        int j=0;\\n        int k=maxCost;\\n        while(i<t.size())\\n        {\\n            k-=v[i];\\n            while(k<0)\\n            {\\n                k+=v[j];\\n                j++;\\n            }\\n            ans=max(ans,i-j+1);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313539,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        \\n        cost=0\\n        l=0\\n        ans=0\\n        for r in range(len(s)):\\n            \\n            cost+= abs(ord(s[r])-ord(t[r]))\\n            while cost > maxCost:\\n                cost -= abs(ord(s[l]) - ord(t[l]))\\n                l+=1\\n            ans=max(ans,  r-l+1)\\n        return ans\\n            \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        \\n        cost=0\\n        l=0\\n        ans=0\\n        for r in range(len(s)):\\n            \\n            cost+= abs(ord(s[r])-ord(t[r]))\\n            while cost > maxCost:\\n                cost -= abs(ord(s[l]) - ord(t[l]))\\n                l+=1\\n            ans=max(ans,  r-l+1)\\n        return ans\\n            \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 958225,
                "title": "c-subarrray-sum-very-easy-to-understand-o-n",
                "content": "\\nWe can visualise this problem as we have to maximise the length of the substring we can change in string a  to string b such that it never exceeds maximum_cost.\\n\\nIt is like having a **Maximum Size Subarray Sum with sum less than k.**\\n\\nAlgorithm\\n1. For each index (0 to n) , take absolute difference of string s and t at index i. and increase our cost\\n\\t\\t\\t**cost = cost + abs(s[i] - t[i]);**\\t\\t\\t\\n2. Till cost is greater than maximumCost, Just Take a counter at index j = 0, and till i increment j and decrease the cost difference at that index j.\\n3. Take the maximum of (i - j + 1).\\n\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        \\n      int i = 0, j =0, cost = 0, maxm = INT_MIN;\\n      \\n      for(i = 0; i < s.size(); i++)\\n      {\\n        cost += abs(s[i] - t[i]);\\n        \\n        if(cost > maxCost) \\n        {\\n          while(j <= i and cost > maxCost)\\n          {\\n            int prevCost = abs(s[j] - t[j]);\\n            cost = cost - prevCost;\\n            j++;\\n          }\\n        }\\n        \\n        maxm = max(maxm, i - j + 1);\\n      }\\n      return (maxm == INT_MIN) ? 0 : maxm;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        \\n      int i = 0, j =0, cost = 0, maxm = INT_MIN;\\n      \\n      for(i = 0; i < s.size(); i++)\\n      {\\n        cost += abs(s[i] - t[i]);\\n        \\n        if(cost > maxCost) \\n        {\\n          while(j <= i and cost > maxCost)\\n          {\\n            int prevCost = abs(s[j] - t[j]);\\n            cost = cost - prevCost;\\n            j++;\\n          }\\n        }\\n        \\n        maxm = max(maxm, i - j + 1);\\n      }\\n      return (maxm == INT_MIN) ? 0 : maxm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461493,
                "title": "python3-sliding-window-two-ways-to-implement-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        res = 0\\n        i = j = cost = 0\\n        while j < len(s):\\n            cost += abs(ord(s[j]) - ord(t[j]))\\n            while cost > maxCost:\\n                cost -= abs(ord(s[i]) - ord(t[i]))\\n                i += 1\\n            res = max(res, j - i + 1)\\n            j += 1\\n        return res\\n```\\n\\n\\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        res = 0\\n        i = j = cost = 0\\n        while j < len(s):\\n            cost += abs(ord(s[j]) - ord(t[j]))\\n            if cost > maxCost:\\n                cost -= abs(ord(s[i]) - ord(t[i]))\\n                i += 1\\n            j += 1\\n        return j - i\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        res = 0\\n        i = j = cost = 0\\n        while j < len(s):\\n            cost += abs(ord(s[j]) - ord(t[j]))\\n            while cost > maxCost:\\n                cost -= abs(ord(s[i]) - ord(t[i]))\\n                i += 1\\n            res = max(res, j - i + 1)\\n            j += 1\\n        return res\\n```\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        res = 0\\n        i = j = cost = 0\\n        while j < len(s):\\n            cost += abs(ord(s[j]) - ord(t[j]))\\n            if cost > maxCost:\\n                cost -= abs(ord(s[i]) - ord(t[i]))\\n                i += 1\\n            j += 1\\n        return j - i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418732,
                "title": "very-fast-easy-to-understand-solution",
                "content": "```\\n public int equalSubstring(String s1, String s2, int maxCost) {\\n        int []arr = new int[s1.length()];\\n        for(int i=0;i<s1.length();i++){\\n            arr[i] = Math.abs(s1.charAt(i)-s2.charAt(i)); \\n        }\\n        int i=0,j=0,sum=0,max=0;\\n\\n        while(i<arr.length && j<arr.length){\\n            sum += arr[j++];\\n            if(sum<=maxCost){\\n                max = Math.max(max,j-i);\\n            }else{\\n                while(sum>maxCost){\\n                    sum -= arr[i++];\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n public int equalSubstring(String s1, String s2, int maxCost) {\\n        int []arr = new int[s1.length()];\\n        for(int i=0;i<s1.length();i++){\\n            arr[i] = Math.abs(s1.charAt(i)-s2.charAt(i)); \\n        }\\n        int i=0,j=0,sum=0,max=0;\\n\\n        while(i<arr.length && j<arr.length){\\n            sum += arr[j++];\\n            if(sum<=maxCost){\\n                max = Math.max(max,j-i);\\n            }else{\\n                while(sum>maxCost){\\n                    sum -= arr[i++];\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 741395,
                "title": "java-sliding-window",
                "content": "```\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int res = 0, n = s.length();\\n        for (int r = 0, l = 0, diff = 0; r < n; r++) {\\n            diff += Math.abs(s.charAt(r) - t.charAt(r));\\n            while (diff > maxCost) {\\n                diff -= Math.abs(s.charAt(l) - t.charAt(l++));\\n            }\\n            res = Math.max(r - l + 1, res);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int res = 0, n = s.length();\\n        for (int r = 0, l = 0, diff = 0; r < n; r++) {\\n            diff += Math.abs(s.charAt(r) - t.charAt(r));\\n            while (diff > maxCost) {\\n                diff -= Math.abs(s.charAt(l) - t.charAt(l++));\\n            }\\n            res = Math.max(r - l + 1, res);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1172247,
                "title": "c-sliding-window-standard-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int currCost=0;\\n        int len=s.length();\\n        int low=0;\\n        int max_len=0;\\n        \\n        for(int i=0;i<len;i++){\\n            currCost+=abs(s[i]-t[i]);\\n            \\n            while(low<=i && currCost>maxCost){\\n                currCost-=abs(s[low]-t[low]);\\n                low++;\\n            } \\n            max_len=max(max_len,i-low+1);\\n        }\\n        return max_len;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int currCost=0;\\n        int len=s.length();\\n        int low=0;\\n        int max_len=0;\\n        \\n        for(int i=0;i<len;i++){\\n            currCost+=abs(s[i]-t[i]);\\n            \\n            while(low<=i && currCost>maxCost){\\n                currCost-=abs(s[low]-t[low]);\\n                low++;\\n            } \\n            max_len=max(max_len,i-low+1);\\n        }\\n        return max_len;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774327,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) \\n    {\\n        int n=s.length();\\n        int i=0,j=0,ans=0,cost=0;\\n        for(;j<n;j++)\\n        {\\n            cost+=abs(s[j]-t[j]);\\n            for(;cost>maxCost;i++)\\n            cost-=abs(s[i]-t[i]);\\n            ans=max(ans,j-i+1);\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) \\n    {\\n        int n=s.length();\\n        int i=0,j=0,ans=0,cost=0;\\n        for(;j<n;j++)\\n        {\\n            cost+=abs(s[j]-t[j]);\\n            for(;cost>maxCost;i++)\\n            cost-=abs(s[i]-t[i]);\\n            ans=max(ans,j-i+1);\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037854,
                "title": "c-3-lines-only-sliding-window",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost, int res = 0) {\\n        for (int i = 0, left = 0, counting = 0; i < cost.size(); i++) {\\n            counting += abs(s[i] - t[i]);\\n            while (counting > maxCost) counting -= cost[left++];\\n            res = max(res, i - left + 1);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost, int res = 0) {\\n        for (int i = 0, left = 0, counting = 0; i < cost.size(); i++) {\\n            counting += abs(s[i] - t[i]);\\n            while (counting > maxCost) counting -= cost[left++];\\n            res = max(res, i - left + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652018,
                "title": "c-python-sliding-window",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int ans = 0, c = maxCost, i = 0, j = 0;\\n\\n        for(int j=0; j<s.size(); j++) {\\n            c -= abs(s[j] - t[j]);\\n            if(c >= 0) ans = max(ans, j - i + 1);\\n            else c += abs(s[i] - t[i]), i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def equalSubstring(self, s, t, maxCost):\\n        ans, i, c = 0, 0, maxCost\\n\\n        for j in range(len(s)):\\n            c -= abs(ord(s[j]) - ord(t[j]))\\n            if c >= 0: ans = max(ans, j - i + 1)\\n            else:\\n                c +=  abs(ord(s[i]) - ord(t[i]))\\n                i += 1\\n        \\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int ans = 0, c = maxCost, i = 0, j = 0;\\n\\n        for(int j=0; j<s.size(); j++) {\\n            c -= abs(s[j] - t[j]);\\n            if(c >= 0) ans = max(ans, j - i + 1);\\n            else c += abs(s[i] - t[i]), i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def equalSubstring(self, s, t, maxCost):\\n        ans, i, c = 0, 0, maxCost\\n\\n        for j in range(len(s)):\\n            c -= abs(ord(s[j]) - ord(t[j]))\\n            if c >= 0: ans = max(ans, j - i + 1)\\n            else:\\n                c +=  abs(ord(s[i]) - ord(t[i]))\\n                i += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596095,
                "title": "python-solution-with-sliding-window",
                "content": "\\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        if maxCost == 0 and s!=t:\\n            return 1\\n        res = 0\\n        m={\\'a\\':1,\\'b\\':2,\\'c\\':3,\\'d\\':4,\\'e\\':5,\\'f\\':6,\\'g\\':7,\\'h\\':8,\\'i\\':9,\\'j\\':10,\\'k\\':11,\\'l\\':12,\\'m\\':13,\\'n\\':14,\\'o\\':15,\\'p\\':16,\\'q\\':17,\\'r\\':18,\\'s\\':19,\\'t\\':20,\\'u\\':21,\\'v\\':22,\\'w\\':23,\\'x\\':24,\\'y\\':25,\\'z\\':26}\\n        l1=[]\\n        l2=[]\\n        for k in range(len(s)):\\n            l1.append(m[s[k]])\\n            l2.append(m[t[k]])\\n        l = 0\\n        for r in range(len(s)):\\n            maxCost -= (abs(l2[r]-l1[r]))\\n            if maxCost < 0:\\n                maxCost += (abs(l2[l]-l1[l]))\\n                l += 1\\n        return r-l+1\\n            \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        if maxCost == 0 and s!=t:\\n            return 1\\n        res = 0\\n        m={\\'a\\':1,\\'b\\':2,\\'c\\':3,\\'d\\':4,\\'e\\':5,\\'f\\':6,\\'g\\':7,\\'h\\':8,\\'i\\':9,\\'j\\':10,\\'k\\':11,\\'l\\':12,\\'m\\':13,\\'n\\':14,\\'o\\':15,\\'p\\':16,\\'q\\':17,\\'r\\':18,\\'s\\':19,\\'t\\':20,\\'u\\':21,\\'v\\':22,\\'w\\':23,\\'x\\':24,\\'y\\':25,\\'z\\':26}\\n        l1=[]\\n        l2=[]\\n        for k in range(len(s)):\\n            l1.append(m[s[k]])\\n            l2.append(m[t[k]])\\n        l = 0\\n        for r in range(len(s)):\\n            maxCost -= (abs(l2[r]-l1[r]))\\n            if maxCost < 0:\\n                maxCost += (abs(l2[l]-l1[l]))\\n                l += 1\\n        return r-l+1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462357,
                "title": "c-solution-time-o-n-memory-o-1-easy-to-understand-sliding-window",
                "content": "```C#\\npublic class Solution {\\n    public int EqualSubstring(string s, string t, int maxCost) {\\n        int cost = 0, start = 0, end = 0;\\n        while (end < s.Length) {\\n            cost += Math.Abs(s[end] - t[end]);\\n            if (cost > maxCost) {\\n                cost -= Math.Abs(s[start] - t[start]);\\n                start++;\\n            }\\n            \\n            end++;\\n        }\\n        \\n        return end - start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int EqualSubstring(string s, string t, int maxCost) {\\n        int cost = 0, start = 0, end = 0;\\n        while (end < s.Length) {\\n            cost += Math.Abs(s[end] - t[end]);\\n            if (cost > maxCost) {\\n                cost -= Math.Abs(s[start] - t[start]);\\n                start++;\\n            }\\n            \\n            end++;\\n        }\\n        \\n        return end - start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747579,
                "title": "c-sliding-window-template-easy",
                "content": "**Do upvote if it helps! :)**\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n       int n=s.size();\\n       vector<int>diff(n,0);\\n        for(int i=0;i<n;i++){\\n            diff[i]=abs((s[i]-\\'a\\')-(t[i]-\\'a\\'));\\n        }\\n        int res=0,left=0,k=maxCost,sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=diff[i];\\n            if(sum>k){\\n                sum-=diff[left];\\n                left++;\\n            }\\n            res=max(res,i-left+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n       int n=s.size();\\n       vector<int>diff(n,0);\\n        for(int i=0;i<n;i++){\\n            diff[i]=abs((s[i]-\\'a\\')-(t[i]-\\'a\\'));\\n        }\\n        int res=0,left=0,k=maxCost,sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=diff[i];\\n            if(sum>k){\\n                sum-=diff[left];\\n                left++;\\n            }\\n            res=max(res,i-left+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793610,
                "title": "c-sliding-window-easy-efficient-code",
                "content": "Please upvote and comment if you like the solution!\\n```\\n public int EqualSubstring(string s, string t, int maxCost) {\\n\\tint n = s.Length, left = 0, window = 0, ans = int.MinValue;\\n\\tint[] cost = new int[n];\\n\\tfor (int right = 0; right < n; right++)\\n\\t{\\n\\t\\tcost[right] = Math.Abs(s[right] - t[right]);\\n\\t\\twindow += cost[right];\\n\\n\\t\\twhile (window > maxCost)\\n\\t\\t\\twindow -= cost[left++];\\n\\n\\t\\tans = Math.Max(ans, right - left + 1);\\n\\t}\\n\\treturn ans;\\n    }",
                "solutionTags": [],
                "code": "Please upvote and comment if you like the solution!\\n```\\n public int EqualSubstring(string s, string t, int maxCost) {\\n\\tint n = s.Length, left = 0, window = 0, ans = int.MinValue;\\n\\tint[] cost = new int[n];\\n\\tfor (int right = 0; right < n; right++)\\n\\t{\\n\\t\\tcost[right] = Math.Abs(s[right] - t[right]);\\n\\t\\twindow += cost[right];\\n\\n\\t\\twhile (window > maxCost)\\n\\t\\t\\twindow -= cost[left++];\\n\\n\\t\\tans = Math.Max(ans, right - left + 1);\\n\\t}\\n\\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 689763,
                "title": "c-sliding-window-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.length();\\n        int left=0,right=0,ans=0,cost=0;\\n        while(right<n){\\n            cost= cost + abs(s[right]-t[right]);\\n            while(cost>maxCost){\\n                cost= cost - abs(s[left]-t[left]);\\n                left++;\\n            }\\n            ans = max(ans,right-left+1);\\n            right++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.length();\\n        int left=0,right=0,ans=0,cost=0;\\n        while(right<n){\\n            cost= cost + abs(s[right]-t[right]);\\n            while(cost>maxCost){\\n                cost= cost - abs(s[left]-t[left]);\\n                left++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 657440,
                "title": "c-sliding-window-standard-problem-o-n",
                "content": "**Intuition:**\\n\\nTrack using two pointers and keep on adding the cost in variable and keep on increasing the window towards right.\\nOnce the variable value exceed maxcost, reduce the window size from left.\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        \\n        int n = s.length();\\n        \\n        int i = 0, j = 0, d = 0, res = 0;\\n        for (i = 0; i < n; i++) {\\n            d += abs(s[i] - t[i]);\\n            while (j < n && d > maxCost) {\\n                d -= abs(s[j] - t[j]);\\n                j++;\\n            }\\n            res = max(res, i-j+1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        \\n        int n = s.length();\\n        \\n        int i = 0, j = 0, d = 0, res = 0;\\n        for (i = 0; i < n; i++) {\\n            d += abs(s[i] - t[i]);\\n            while (j < n && d > maxCost) {\\n                d -= abs(s[j] - t[j]);\\n                j++;\\n            }\\n            res = max(res, i-j+1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393053,
                "title": "java-simple-solution-based-on-two-pointers",
                "content": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        if(maxCost < 0 || s == null || t == null || s.length() != t.length() || s.length() == 0) {\\n            return 0;\\n        }\\n        \\n        int[] diffs = new int[s.length()];\\n        int left = 0, cost = 0, maxLen = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            diffs[i] = Math.abs((int)s.charAt(i) - (int)t.charAt(i));\\n            if(diffs[i] > maxCost) {\\n                left = i+1;\\n                cost = 0;\\n            } else {\\n                cost += diffs[i];\\n\\t\\t\\t\\t// can use binary search to speed it up\\n                while(left <= i && cost > maxCost) {\\n                    cost -= diffs[left];\\n                    ++left;\\n                }\\n            }\\n            \\n            maxLen = Math.max(maxLen, i - left + 1);\\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        if(maxCost < 0 || s == null || t == null || s.length() != t.length() || s.length() == 0) {\\n            return 0;\\n        }\\n        \\n        int[] diffs = new int[s.length()];\\n        int left = 0, cost = 0, maxLen = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            diffs[i] = Math.abs((int)s.charAt(i) - (int)t.charAt(i));\\n            if(diffs[i] > maxCost) {\\n                left = i+1;\\n                cost = 0;\\n            } else {\\n                cost += diffs[i];\\n\\t\\t\\t\\t// can use binary search to speed it up\\n                while(left <= i && cost > maxCost) {\\n                    cost -= diffs[left];\\n                    ++left;\\n                }\\n            }\\n            \\n            maxLen = Math.max(maxLen, i - left + 1);\\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392854,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int l = 0;\\n        int r = 0;\\n        int max = 0;\\n        while (r < s.length()) {\\n            maxCost -= Math.abs(s.charAt(r) - t.charAt(r));\\n            r++;\\n            if (maxCost >= 0) {\\n                max = Math.max(max, r - l);\\n            }\\n            while (maxCost < 0) {\\n                maxCost += Math.abs(s.charAt(l) - t.charAt(l));\\n                l++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int l = 0;\\n        int r = 0;\\n        int max = 0;\\n        while (r < s.length()) {\\n            maxCost -= Math.abs(s.charAt(r) - t.charAt(r));\\n            r++;\\n            if (maxCost >= 0) {\\n                max = Math.max(max, r - l);\\n            }\\n            while (maxCost < 0) {\\n                maxCost += Math.abs(s.charAt(l) - t.charAt(l));\\n                l++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014244,
                "title": "python-easy-clean-solution-sliding-window",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        left = ans = curr = 0\\n        for i in range(len(s)):\\n            curr += abs(ord(s[i]) - ord(t[i]))\\n            while curr > maxCost:\\n                curr -= abs(ord(s[left]) - ord(t[left]))\\n                left += 1\\n            ans = max(ans, i - left + 1)\\n        return ans\\n```\\n![catty.png](https://assets.leetcode.com/users/images/3d1b0651-e8aa-4b87-86b9-53e2e873f76d_1694092487.3318822.png)\\n",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        left = ans = curr = 0\\n        for i in range(len(s)):\\n            curr += abs(ord(s[i]) - ord(t[i]))\\n            while curr > maxCost:\\n                curr -= abs(ord(s[left]) - ord(t[left]))\\n                left += 1\\n            ans = max(ans, i - left + 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814955,
                "title": "javascript-1208-get-equal-substrings-within-budget",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n```\\ntake max length substring\\n  whose cost/diffence between 2 strings\\n    does not exceed the maxCost given\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\n/*\\n  maxCost =  3\\n    s                 a b c d\\n    t                 b c d f\\n    distance/cost     1 1 1 2\\n      distance a to b  = 1\\n      distance b to c  = 1\\n      distance c to d  = 1\\n      distance d to f  = 2\\n  we can only take 1st 3 chars (maxCost), ans = 3\\n*/\\nvar equalSubstring = function (s, t, maxCost) {\\n  const distance = (ch1, ch2) => {\\n    return Math.abs(ch1.charCodeAt(0) - ch2.charCodeAt(0))\\n  }\\n\\n  let maxLen = 0\\n  let n = s.length\\n  let totalCost = 0\\n  for (let L = 0, R = 0; R < n;) {\\n    totalCost += distance(s[R], t[R]); // add - assume cost will be within maxCost\\n    R++\\n\\n    while (totalCost > maxCost) {\\n      totalCost -= distance(s[L], t[L]); // keep removing from left, if maxCost exceeded\\n      L++\\n    }\\n\\n    // must be 0 or more chars without exceeding maxCost\\n    maxLen = Math.max(maxLen, R - L)\\n  }\\n  return maxLen\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\ntake max length substring\\n  whose cost/diffence between 2 strings\\n    does not exceed the maxCost given\\n```\n```\\n/*\\n  maxCost =  3\\n    s                 a b c d\\n    t                 b c d f\\n    distance/cost     1 1 1 2\\n      distance a to b  = 1\\n      distance b to c  = 1\\n      distance c to d  = 1\\n      distance d to f  = 2\\n  we can only take 1st 3 chars (maxCost), ans = 3\\n*/\\nvar equalSubstring = function (s, t, maxCost) {\\n  const distance = (ch1, ch2) => {\\n    return Math.abs(ch1.charCodeAt(0) - ch2.charCodeAt(0))\\n  }\\n\\n  let maxLen = 0\\n  let n = s.length\\n  let totalCost = 0\\n  for (let L = 0, R = 0; R < n;) {\\n    totalCost += distance(s[R], t[R]); // add - assume cost will be within maxCost\\n    R++\\n\\n    while (totalCost > maxCost) {\\n      totalCost -= distance(s[L], t[L]); // keep removing from left, if maxCost exceeded\\n      L++\\n    }\\n\\n    // must be 0 or more chars without exceeding maxCost\\n    maxLen = Math.max(maxLen, R - L)\\n  }\\n  return maxLen\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3632673,
                "title": "very-simple-c-longest-sub-array-sum",
                "content": "# if it Helps You. Please UpVote Me...! \\u2764\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nApproach is Simple But we have to change the problem Statement to **Longest Sub-Array with Sum <=K.**\\n\\n**Just Follow the Below Points to change the Problem Statement:-**\\n1. Calculate the absolute Cost for Each Character and store it to the new Cost Vector.\\n2. Now Calculate the Longest Sub-Array With Sum <= k.\\n\\n**EX:- S = \"abc\"  and t = \"bcd\"\\ncost[0] = abs(s[0]-t[0]) = 1\\ncost[1] = abs(s[1]-t[1]) = 1\\ncost[2] = abs(s[2]-t[2]) = 1**\\n\\n**Cost[] = {1,1,1} maxcost = 2 Now find the Longest SubSub-Array with Sum<=2.**\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxcost) {\\n\\n        int n = s.size(),sum = 0,ans = 0;\\n        vector<int>cost(n,0);\\n\\n        for(int i = 0;i<n;i++)\\n        cost[i] = abs(s[i]-t[i]);\\n\\n        queue<int> q;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t      if(sum+cost[i]<=maxcost)\\n\\t      {\\n\\t        sum+=cost[i];\\n\\t        q.push(cost[i]);\\n\\t        if(ans<q.size())\\n\\t            ans=q.size();\\n\\t      }\\n\\t      else if(q.size()>0)\\n\\t      {\\n\\t        sum-=q.front();\\n\\t        q.pop();\\n\\t        i--;\\n\\t      }\\n\\t    }\\n\\n        return ans;\\n        \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/46b72ab1-178f-42da-94e9-0225ed60c9c7_1686649809.4518604.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxcost) {\\n\\n        int n = s.size(),sum = 0,ans = 0;\\n        vector<int>cost(n,0);\\n\\n        for(int i = 0;i<n;i++)\\n        cost[i] = abs(s[i]-t[i]);\\n\\n        queue<int> q;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t      if(sum+cost[i]<=maxcost)\\n\\t      {\\n\\t        sum+=cost[i];\\n\\t        q.push(cost[i]);\\n\\t        if(ans<q.size())\\n\\t            ans=q.size();\\n\\t      }\\n\\t      else if(q.size()>0)\\n\\t      {\\n\\t        sum-=q.front();\\n\\t        q.pop();\\n\\t        i--;\\n\\t      }\\n\\t    }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495869,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        int max=0;\\n\\n        while(j<s.length()){\\n            ans+=Math.abs((int)s.charAt(j)-(int)t.charAt(j));\\n\\n            if(ans<=maxCost){\\n                max=Math.max(max,j-i+1);\\n            }\\n             \\n            else {\\n                while(ans>maxCost){\\n                    ans-=Math.abs((int)s.charAt(i)-(int)t.charAt(i));\\n                    i++;\\n                }\\n            }\\n            j++;\\n\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        int max=0;\\n\\n        while(j<s.length()){\\n            ans+=Math.abs((int)s.charAt(j)-(int)t.charAt(j));\\n\\n            if(ans<=maxCost){\\n                max=Math.max(max,j-i+1);\\n            }\\n             \\n            else {\\n                while(ans>maxCost){\\n                    ans-=Math.abs((int)s.charAt(i)-(int)t.charAt(i));\\n                    i++;\\n                }\\n            }\\n            j++;\\n\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443908,
                "title": "c-using-sliding-window-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxc) {\\n       int sum=0,i=0,j=0,ans=0;\\n        while(j<s.size())\\n        {\\n            int a = s[j]-\\'a\\';\\n            int b = t[j]-\\'a\\';\\n           sum+=  abs(a-b);\\n           if(sum<=maxc)\\n           {\\n               j++;\\n               ans = max(ans,(j-i));\\n           }\\n            else if(maxc<sum)\\n            {\\n                while(maxc<sum)\\n                {\\n                    int x  = s[i]-\\'a\\';\\n                    int y = t[i]-\\'a\\';\\n                    sum-=abs(x-y);\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxc) {\\n       int sum=0,i=0,j=0,ans=0;\\n        while(j<s.size())\\n        {\\n            int a = s[j]-\\'a\\';\\n            int b = t[j]-\\'a\\';\\n           sum+=  abs(a-b);\\n           if(sum<=maxc)\\n           {\\n               j++;\\n               ans = max(ans,(j-i));\\n           }\\n            else if(maxc<sum)\\n            {\\n                while(maxc<sum)\\n                {\\n                    int x  = s[i]-\\'a\\';\\n                    int y = t[i]-\\'a\\';\\n                    sum-=abs(x-y);\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368725,
                "title": "php-beats-100-runtime-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @param String $t\\n     * @param Integer $maxCost\\n     * @return Integer\\n     */\\n    function equalSubstring($s, $t, $maxCost) {\\n        $left = $currCost = $ans = 0;\\n        for ($i = 0; $i < strlen($s); $i++) {\\n            $currCost += abs(ord($s[$i]) - ord($t[$i]));\\n            while($currCost > $maxCost) {\\n                $currCost -= abs(ord($s[$left]) - ord($t[$left]));\\n                $left++;\\n            }\\n            $ans = max($ans, $i - $left + 1);\\n        }\\n        return $ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @param String $t\\n     * @param Integer $maxCost\\n     * @return Integer\\n     */\\n    function equalSubstring($s, $t, $maxCost) {\\n        $left = $currCost = $ans = 0;\\n        for ($i = 0; $i < strlen($s); $i++) {\\n            $currCost += abs(ord($s[$i]) - ord($t[$i]));\\n            while($currCost > $maxCost) {\\n                $currCost -= abs(ord($s[$left]) - ord($t[$left]));\\n                $left++;\\n            }\\n            $ans = max($ans, $i - $left + 1);\\n        }\\n        return $ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339145,
                "title": "runtime-0-ms-beats-100",
                "content": "# Code\\n```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\n\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) \\n    {\\n        //we need to maximize the lengt of the string (substring)\\n        //in t that can be changed to the corresponding substring\\n        //as in s while keeping the constraint in the mind;\\n\\n        //as the length of the s and t are equal \\n\\n        int ans_len = 0;\\n\\n        int cost = 0;\\n\\n        int start = 0;\\n        int end   = 0;\\n\\n        //traversing on the string t and checking if the particular substring can be made equal\\n        \\n        while(end < (s.length()))\\n        {\\n            int diff = abs(t[end] - s[end]);\\n\\n            while((start <= end) and (cost + diff) > maxCost)\\n            {\\n                cost = cost - abs(t[start] - s[start]);\\n                start++;\\n            }\\n\\n            cost = cost + diff;\\n            ans_len = max(ans_len,(end - start + 1));\\n            end++;\\n        }\\n        return ans_len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\n\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) \\n    {\\n        //we need to maximize the lengt of the string (substring)\\n        //in t that can be changed to the corresponding substring\\n        //as in s while keeping the constraint in the mind;\\n\\n        //as the length of the s and t are equal \\n\\n        int ans_len = 0;\\n\\n        int cost = 0;\\n\\n        int start = 0;\\n        int end   = 0;\\n\\n        //traversing on the string t and checking if the particular substring can be made equal\\n        \\n        while(end < (s.length()))\\n        {\\n            int diff = abs(t[end] - s[end]);\\n\\n            while((start <= end) and (cost + diff) > maxCost)\\n            {\\n                cost = cost - abs(t[start] - s[start]);\\n                start++;\\n            }\\n\\n            cost = cost + diff;\\n            ans_len = max(ans_len,(end - start + 1));\\n            end++;\\n        }\\n        return ans_len;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3051532,
                "title": "javascript-sliding-window-hash-map",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} maxCost\\n * @return {number}\\n */\\nvar equalSubstring = function(s, t, maxCost) {\\n    let left = 0, curr = 0, ans = 0;\\n    let map = new Map();\\n    for(let right = 0; right < s.length; right++) {\\n        if(s[right] !== t[right]) {\\n            let subst = Math.abs(s.charCodeAt(right) - t.charCodeAt(right))\\n            map.set(right, subst);\\n            curr += subst;\\n\\n            while(curr > maxCost) {\\n                curr -= (map.get(left) || 0);\\n                left++;\\n            }\\n        }\\n        ans = Math.max(ans, right - left + 1);\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} maxCost\\n * @return {number}\\n */\\nvar equalSubstring = function(s, t, maxCost) {\\n    let left = 0, curr = 0, ans = 0;\\n    let map = new Map();\\n    for(let right = 0; right < s.length; right++) {\\n        if(s[right] !== t[right]) {\\n            let subst = Math.abs(s.charCodeAt(right) - t.charCodeAt(right))\\n            map.set(right, subst);\\n            curr += subst;\\n\\n            while(curr > maxCost) {\\n                curr -= (map.get(left) || 0);\\n                left++;\\n            }\\n        }\\n        ans = Math.max(ans, right - left + 1);\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2859857,
                "title": "java-sliding-window",
                "content": "class Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int [] arr = new int[s.length()];\\n        for(int i = 0 ; i<s.length() ; i++){\\n            arr[i] = Math.abs(s.charAt(i)-t.charAt(i));\\n        }\\n        int j = 0 ;\\n        int length = 0 ;\\n        int sum = 0;\\n        for(int i = 0 ; i<arr.length ; i++){\\n            sum = sum + arr[i];\\n            while(sum>maxCost){\\n                sum = sum - arr[j];\\n                j++;\\n            }\\n            length = Math.max(length , i-j+1);\\n        }\\n        return length;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int [] arr = new int[s.length()];\\n        for(int i = 0 ; i<s.length() ; i++){\\n            arr[i] = Math.abs(s.charAt(i)-t.charAt(i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2695361,
                "title": "simple-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n\\n       int n=s.size();\\n\\n       int ans=0;\\n       int left=0;\\n       int cost=0;\\n\\n       for(int i=0;i<n;i++)\\n       {\\n\\n           cost+=(abs(s[i]-t[i]));\\n           \\n           while(cost>maxCost)\\n           {\\n\\n               cost-=(abs(s[left]-t[left]));\\n               left++;\\n\\n           }\\n\\n           ans=max(ans,i-left+1);\\n\\n       }\\n\\n\\n    return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n\\n       int n=s.size();\\n\\n       int ans=0;\\n       int left=0;\\n       int cost=0;\\n\\n       for(int i=0;i<n;i++)\\n       {\\n\\n           cost+=(abs(s[i]-t[i]));\\n           \\n           while(cost>maxCost)\\n           {\\n\\n               cost-=(abs(s[left]-t[left]));\\n               left++;\\n\\n           }\\n\\n           ans=max(ans,i-left+1);\\n\\n       }\\n\\n\\n    return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644063,
                "title": "faster-easy-to-understand-c-code",
                "content": "- # ***Using Sliding Window Approach***\\n\\n- # ***Time Complexity :- O(N)***\\n\\n- # ***Space Complexity :- O(1)***\\n\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string str, string tar, int maxCost) {\\n\\n        int n = str.size();\\n\\n        int left = 0;\\n\\n        int curr_cost = 0;\\n\\n        int maxi = 0;\\n\\n        // apply sliding window\\n\\n        for(int right = 0; right < n; right++)\\n        {\\n            // add the cost into curr_cost\\n\\n            curr_cost += abs(str[right] - tar[right]);\\n\\n            // shrink the window from left to decrement the curr_cost, to make it within range\\n\\n            while(left <= right && curr_cost > maxCost)\\n            {\\n                curr_cost -= abs(str[left] - tar[left]);\\n\\n                left++;\\n            }\\n\\n            // update maxi\\n\\n            maxi = max({maxi, right - left + 1});\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string str, string tar, int maxCost) {\\n\\n        int n = str.size();\\n\\n        int left = 0;\\n\\n        int curr_cost = 0;\\n\\n        int maxi = 0;\\n\\n        // apply sliding window\\n\\n        for(int right = 0; right < n; right++)\\n        {\\n            // add the cost into curr_cost\\n\\n            curr_cost += abs(str[right] - tar[right]);\\n\\n            // shrink the window from left to decrement the curr_cost, to make it within range\\n\\n            while(left <= right && curr_cost > maxCost)\\n            {\\n                curr_cost -= abs(str[left] - tar[left]);\\n\\n                left++;\\n            }\\n\\n            // update maxi\\n\\n            maxi = max({maxi, right - left + 1});\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543077,
                "title": "c-easy-solution-sliding-window",
                "content": "can do without map bu sum variable\\n```\\n   int n=s.length();\\n        int i=0;\\n        int j=0;\\n        int sum=0;\\n        int len=0;\\n        unordered_map<int,int>mp;\\n        while(i<n){\\n            int diff=abs(s[i]-t[i]);\\n            mp[i]+=diff;\\n            sum+=mp[i];\\n            while(sum>maxCost ){\\n                int res=abs(s[j]-t[j]);\\n                mp[j]-=res;\\n                sum-=res;\\n                j++;\\n            }\\n              \\n            i++;\\n            len=max(len,i-j);\\n          \\n           \\n            \\n        }\\n        return len;",
                "solutionTags": [],
                "code": "can do without map bu sum variable\\n```\\n   int n=s.length();\\n        int i=0;\\n        int j=0;\\n        int sum=0;\\n        int len=0;\\n        unordered_map<int,int>mp;\\n        while(i<n){\\n            int diff=abs(s[i]-t[i]);\\n            mp[i]+=diff;\\n            sum+=mp[i];\\n            while(sum>maxCost ){\\n                int res=abs(s[j]-t[j]);\\n                mp[j]-=res;\\n                sum-=res;\\n                j++;\\n            }\\n              \\n            i++;\\n            len=max(len,i-j);\\n          \\n           \\n            \\n        }\\n        return len;",
                "codeTag": "Unknown"
            },
            {
                "id": 2312556,
                "title": "python-sliding-window-o-n-well-explained-easy",
                "content": "# EXPLANATION\\nThe idea is very simple we keep a sliding window which will contain the substring which we \\ncan convert using maxCost\\n\\nNow the idea of sliding window is \\n1. increase the window from right\\n2. decrease the window from left when we cannot increase further\\n\\nwe use the same idea for our sliding window \\n\\n\\n# CODE\\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        n = len(s)\\n        cost,start,ans = 0,0,0\\n        for i in range(n):\\n            diff = abs(ord(s[i]) - ord(t[i]))\\n            if cost + diff <= maxCost:\\n                # we can increase our sliding window\\n                cost += diff\\n            else:\\n                # we are unable to increase our sliding window\\n                ans = max(ans,i - start)\\n                while True:\\n                    cost -= abs(ord(s[start]) - ord(t[start]))\\n                    start += 1\\n                    if cost + diff <= maxCost: break\\n                if cost + diff > maxCost: start = i + 1\\n                else: cost += diff\\n                    \\n        ans = max(ans,n - start)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        n = len(s)\\n        cost,start,ans = 0,0,0\\n        for i in range(n):\\n            diff = abs(ord(s[i]) - ord(t[i]))\\n            if cost + diff <= maxCost:\\n                # we can increase our sliding window\\n                cost += diff\\n            else:\\n                # we are unable to increase our sliding window\\n                ans = max(ans,i - start)\\n                while True:\\n                    cost -= abs(ord(s[start]) - ord(t[start]))\\n                    start += 1\\n                    if cost + diff <= maxCost: break\\n                if cost + diff > maxCost: start = i + 1\\n                else: cost += diff\\n                    \\n        ans = max(ans,n - start)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250696,
                "title": "python-simple-sliding-window",
                "content": "\\n    def equalSubstring(self, s, t, maxCost):\\n        max_len, left, running_sum = 0, 0, 0\\n        \\n        for right in range(len(s)):\\n            running_sum += abs(ord(s[right]) - ord(t[right]))\\n            \\n            while running_sum > maxCost:\\n                running_sum -= abs(ord(s[left]) - ord(t[left]))\\n                left += 1\\n                \\n            max_len = max(max_len, right - left + 1)\\n            \\n        return max_len",
                "solutionTags": [],
                "code": "\\n    def equalSubstring(self, s, t, maxCost):\\n        max_len, left, running_sum = 0, 0, 0\\n        \\n        for right in range(len(s)):\\n            running_sum += abs(ord(s[right]) - ord(t[right]))\\n            \\n            while running_sum > maxCost:\\n                running_sum -= abs(ord(s[left]) - ord(t[left]))\\n                left += 1\\n                \\n            max_len = max(max_len, right - left + 1)\\n            \\n        return max_len",
                "codeTag": "Python3"
            },
            {
                "id": 2168903,
                "title": "easy-sliding-window-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int k) {\\n        int i=0,j=0,n=s.length(),z=0,sum=0,maxi=0;\\n        while(j<n)\\n        {\\n            int p=abs(s[j]-t[j]); //calculating difference between every character\\n            sum+=p;\\n            if(sum<=k) //Checking if the sum is lesser or equal to maxCost\\n            {\\n                maxi=max(maxi,j-i+1); //If it is we\\'ll store the size of the substring\\n                j++; //Increase the end pointer\\n            }\\n            else if(sum>k)\\n            {\\n                while(sum>k) // If sum is greater than maxCost then we\\'ll start decreasing the sum \\n\\t\\t\\t\\t//so that the sum is lesser than the maxCost. \\n                {\\n                    int p=abs(s[i]-t[i]);\\n                    sum-=p;\\n                    i++;\\n                }\\n                j++; //We\\'ll increase the end pointer. \\n            }\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int equalSubstring(string s, string t, int k) {\\n        int i=0,j=0,n=s.length(),z=0,sum=0,maxi=0;\\n        while(j<n)\\n        {\\n            int p=abs(s[j]-t[j]); //calculating difference between every character\\n            sum+=p;\\n            if(sum<=k) //Checking if the sum is lesser or equal to maxCost\\n            {\\n                maxi=max(maxi,j-i+1); //If it is we\\'ll store the size of the substring\\n                j++; //Increase the end pointer\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2159291,
                "title": "easy-cpp-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int cost) {\\n        int start=0,maxi=0;\\n        for(int i=0;i<s.length();i++){\\n            if(abs(t[i]-s[i])<=cost){\\n                cost-=abs(t[i]-s[i]);\\n                maxi=max(maxi,i-start+1);\\n            }\\n            else{\\n                while(start<i && cost<abs(t[i]-s[i])){\\n                    cost+=abs(t[start]-s[start]);\\n                    start++;\\n                }\\n                cost-=abs(t[i]-s[i]);\\n                if(cost>=0) maxi=max(maxi,i-start+1);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int cost) {\\n        int start=0,maxi=0;\\n        for(int i=0;i<s.length();i++){\\n            if(abs(t[i]-s[i])<=cost){\\n                cost-=abs(t[i]-s[i]);\\n                maxi=max(maxi,i-start+1);\\n            }\\n            else{\\n                while(start<i && cost<abs(t[i]-s[i])){\\n                    cost+=abs(t[start]-s[start]);\\n                    start++;\\n                }\\n                cost-=abs(t[i]-s[i]);\\n                if(cost>=0) maxi=max(maxi,i-start+1);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945578,
                "title": "java-sliding-window",
                "content": "```\\n\\tpublic int equalSubstring(String s, String t, int maxCost) {\\n        int start = 0;\\n        int end = 0;\\n        int sum = 0;\\n        int res = 0;\\n        // Treat cost as ascii difference and can use Sliding Window\\n        while( end < s.length()){\\n            sum += Math.abs(s.charAt(end) - t.charAt(end));// sum of cost includes current cost at end index\\n            \\n            if(sum <= maxCost){\\n                res = Math.max(res, end-start+1);        \\n            }\\n            \\n            while(sum > maxCost && start < s.length()){\\n                sum -= Math.abs(s.charAt(start) - t.charAt(start));//subtract cost of start index\\n                start += 1;\\n            }\\n            end += 1;\\n        }\\n        return res;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n\\tpublic int equalSubstring(String s, String t, int maxCost) {\\n        int start = 0;\\n        int end = 0;\\n        int sum = 0;\\n        int res = 0;\\n        // Treat cost as ascii difference and can use Sliding Window\\n        while( end < s.length()){\\n            sum += Math.abs(s.charAt(end) - t.charAt(end));// sum of cost includes current cost at end index\\n            \\n            if(sum <= maxCost){\\n                res = Math.max(res, end-start+1);        \\n            }\\n            \\n            while(sum > maxCost && start < s.length()){\\n                sum -= Math.abs(s.charAt(start) - t.charAt(start));//subtract cost of start index\\n                start += 1;\\n            }\\n            end += 1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916699,
                "title": "c-sliding-window-99-4-easy-code",
                "content": "```\\nint equalSubstring(string s, string t, int maxCost) {\\n        int stringSize=s.size();\\n        vector<int>arr;\\n        for(int i=0;i<stringSize;i++)\\n        {\\n            int difference=s[i]-t[i];\\n            if(difference<0)\\n                difference=-difference;\\n            arr.push_back(difference);\\n        }\\n        int i=0;\\n        int j=0;\\n        int currentcost=0;\\n        int ans=INT_MIN;\\n        while(j<stringSize)\\n        {\\n            if(arr[j]+currentcost<=maxCost)\\n            {\\n                currentcost+=arr[j];\\n                ans=max(ans,j-i+1);\\n                j++;\\n            }\\n            else\\n            {\\n                while(currentcost+arr[j]>maxCost&&i<j)\\n                {\\n                    currentcost-=arr[i++];\\n                }\\n                if(arr[j]+currentcost<=maxCost)\\n                {\\n                    currentcost+=arr[j];\\n                    ans=max(ans,j-i+1);\\n                    j++;\\n                }\\n                else\\n                {\\n                    j++;\\n                    i=j;\\n                    currentcost=0;\\n                }\\n            }\\n        }\\n        if(ans==INT_MIN)\\n            return 0;\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint equalSubstring(string s, string t, int maxCost) {\\n        int stringSize=s.size();\\n        vector<int>arr;\\n        for(int i=0;i<stringSize;i++)\\n        {\\n            int difference=s[i]-t[i];\\n            if(difference<0)\\n                difference=-difference;\\n            arr.push_back(difference);\\n        }\\n        int i=0;\\n        int j=0;\\n        int currentcost=0;\\n        int ans=INT_MIN;\\n        while(j<stringSize)\\n        {\\n            if(arr[j]+currentcost<=maxCost)\\n            {\\n                currentcost+=arr[j];\\n                ans=max(ans,j-i+1);\\n                j++;\\n            }\\n            else\\n            {\\n                while(currentcost+arr[j]>maxCost&&i<j)\\n                {\\n                    currentcost-=arr[i++];\\n                }\\n                if(arr[j]+currentcost<=maxCost)\\n                {\\n                    currentcost+=arr[j];\\n                    ans=max(ans,j-i+1);\\n                    j++;\\n                }\\n                else\\n                {\\n                    j++;\\n                    i=j;\\n                    currentcost=0;\\n                }\\n            }\\n        }\\n        if(ans==INT_MIN)\\n            return 0;\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1881770,
                "title": "two-pointers-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int left = 0, right = 0, answer = 0, res = 0;\\n        while(right < s.size()){\\n            res += abs(s[right] - t[right]); \\n            while(res > maxCost){\\n                res -= abs(s[left] - t[left]);\\n                left++;\\n            }\\n            answer = max(answer, (right - left + 1));\\n            right++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int left = 0, right = 0, answer = 0, res = 0;\\n        while(right < s.size()){\\n            res += abs(s[right] - t[right]); \\n            while(res > maxCost){\\n                res -= abs(s[left] - t[left]);\\n                left++;\\n            }\\n            answer = max(answer, (right - left + 1));\\n            right++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711055,
                "title": "golang-o-n-time-o-1-mem-sliding-window-100",
                "content": "```go\\nfunc equalSubstring(s string, t string, maxCost int) (max int) {\\n    n := len(s)\\n    \\n    left, cost := 0, 0 // cost and left-index of sliding window\\n    for i := range s {\\n        cost += diff(s[i], t[i])\\n        for left < n && cost > maxCost  {\\n            cost -= diff(s[left], t[left])\\n            left++\\n        }\\n        \\n        if d := i - left + 1; d >= max {\\n            max = d\\n        }\\n    }\\n    \\n    return\\n}\\n\\nfunc diff(a, b byte) int {\\n    if a < b {\\n        return int(b-a)\\n    }\\n    return int(a - b)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc equalSubstring(s string, t string, maxCost int) (max int) {\\n    n := len(s)\\n    \\n    left, cost := 0, 0 // cost and left-index of sliding window\\n    for i := range s {\\n        cost += diff(s[i], t[i])\\n        for left < n && cost > maxCost  {\\n            cost -= diff(s[left], t[left])\\n            left++\\n        }\\n        \\n        if d := i - left + 1; d >= max {\\n            max = d\\n        }\\n    }\\n    \\n    return\\n}\\n\\nfunc diff(a, b byte) int {\\n    if a < b {\\n        return int(b-a)\\n    }\\n    return int(a - b)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1670503,
                "title": "sliding-window-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int l=0,r=0;\\n        int res=0;\\n        int n=s.size();\\n        int cost=0;\\n        while(r<n){\\n            cost+=abs(s[r]-t[r]);\\n            while(cost>maxCost){\\n                cost-=abs(s[l]-t[l]);\\n                l++;\\n            }\\n            \\n            res=max(res,r-l+1);\\n            r++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int l=0,r=0;\\n        int res=0;\\n        int n=s.size();\\n        int cost=0;\\n        while(r<n){\\n            cost+=abs(s[r]-t[r]);\\n            while(cost>maxCost){\\n                cost-=abs(s[l]-t[l]);\\n                l++;\\n            }\\n            \\n            res=max(res,r-l+1);\\n            r++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637502,
                "title": "c-prefix-sum-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        vector<int > cost;// store cost to convert ith character\\n        for(int i=0;i<s.length();i++)\\n        {\\n            cost.push_back(abs(s[i]-t[i]));\\n        }\\n        for(int i=1;i<cost.size();i++)\\n            cost[i]+=cost[i-1];\\n        \\n        auto it = upper_bound(cost.begin(),cost.end(),maxCost);\\n        int ans = it-cost.begin();\\n        cout<<ans<<endl;\\n        for(int i=1;i<cost.size();i++)\\n        {\\n            auto it1 = upper_bound(cost.begin()+i,cost.end(),maxCost+cost[i-1]);\\n            ans=max(ans, (int)(it1-cost.begin()-i));\\n            cout<<ans<<endl;\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        vector<int > cost;// store cost to convert ith character\\n        for(int i=0;i<s.length();i++)\\n        {\\n            cost.push_back(abs(s[i]-t[i]));\\n        }\\n        for(int i=1;i<cost.size();i++)\\n            cost[i]+=cost[i-1];\\n        \\n        auto it = upper_bound(cost.begin(),cost.end(),maxCost);\\n        int ans = it-cost.begin();\\n        cout<<ans<<endl;\\n        for(int i=1;i<cost.size();i++)\\n        {\\n            auto it1 = upper_bound(cost.begin()+i,cost.end(),maxCost+cost[i-1]);\\n            ans=max(ans, (int)(it1-cost.begin()-i));\\n            cout<<ans<<endl;\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1576266,
                "title": "c-sliding-window-100-faster-solution-o-n-tc",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int l = 0 ,r = 0;\\n        int maxLen = 0;\\n        int n= s.length();\\n        int lcost =0 ;\\n        while(r<n){\\n            lcost+= abs((s[r] -\\'a\\') - (t[r]-\\'a\\'));\\n            while(lcost > maxCost) {\\n                lcost-=abs((s[l] -\\'a\\') - (t[l]-\\'a\\'));\\n                l++;\\n            }\\n            maxLen = max(maxLen,r-l+1);\\n            r++;\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int l = 0 ,r = 0;\\n        int maxLen = 0;\\n        int n= s.length();\\n        int lcost =0 ;\\n        while(r<n){\\n            lcost+= abs((s[r] -\\'a\\') - (t[r]-\\'a\\'));\\n            while(lcost > maxCost) {\\n                lcost-=abs((s[l] -\\'a\\') - (t[l]-\\'a\\'));\\n                l++;\\n            }\\n            maxLen = max(maxLen,r-l+1);\\n            r++;\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433407,
                "title": "c-window-sliding-6-lines",
                "content": "```\\n\\n```public:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        long long int i,j=0,m=0,sum=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            while(j<s.length()&&sum+abs(s[j]-t[j])<=maxCost)\\n            {\\n                sum=sum+abs(s[j]-t[j]);\\n                j++;\\n            }\\n            m=max(m,j-i);\\n            sum=sum-abs(s[i]-t[i]);\\n        }\\n        return m;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1393131,
                "title": "java-easy-sliding-window",
                "content": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n          int i = 0;\\n          int j = 0;\\n          int n = s.length();\\n          int cc = 0; //current cost\\n          int max = 0;\\n      \\n         while(j < n){\\n            if(s.charAt(j) != t.charAt(j)){\\n               cc = cc + Math.abs(s.charAt(j) - t.charAt(j));\\n            }\\n           \\n            if(cc > maxCost){\\n               while(cc > maxCost){\\n                 if(s.charAt(j) != t.charAt(j)){\\n                 cc = cc - Math.abs(s.charAt(i) - t.charAt(i));\\n                 i++;\\n                  }\\n               }\\n            }\\n           max = Math.max(max, j - i + 1); \\n           \\n           j++; \\n         }\\n      return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n          int i = 0;\\n          int j = 0;\\n          int n = s.length();\\n          int cc = 0; //current cost\\n          int max = 0;\\n      \\n         while(j < n){\\n            if(s.charAt(j) != t.charAt(j)){\\n               cc = cc + Math.abs(s.charAt(j) - t.charAt(j));\\n            }\\n           \\n            if(cc > maxCost){\\n               while(cc > maxCost){\\n                 if(s.charAt(j) != t.charAt(j)){\\n                 cc = cc - Math.abs(s.charAt(i) - t.charAt(i));\\n                 i++;\\n                  }\\n               }\\n            }\\n           max = Math.max(max, j - i + 1); \\n           \\n           j++; \\n         }\\n      return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391575,
                "title": "easiest-c-solution-shortest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int i = 0, j = 0;\\n        \\n        int cost = maxCost;\\n        int ans = INT_MIN;\\n        while(i < s.size() && i < t.size()) {\\n            if(s[i] != t[i]) {\\n                cost -= abs(s[i] - t[i]);\\n                while(cost < 0 && j <= i) {\\n                    cost += abs(s[j] - t[j]);\\n                    j++;\\n                }\\n            }\\n            ans = max(ans, i - j + 1);\\n            i++;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int i = 0, j = 0;\\n        \\n        int cost = maxCost;\\n        int ans = INT_MIN;\\n        while(i < s.size() && i < t.size()) {\\n            if(s[i] != t[i]) {\\n                cost -= abs(s[i] - t[i]);\\n                while(cost < 0 && j <= i) {\\n                    cost += abs(s[j] - t[j]);\\n                    j++;\\n                }\\n            }\\n            ans = max(ans, i - j + 1);\\n            i++;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327337,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>pre;\\n    vector<int>sum;\\n    int n ;\\n    bool check(int mid , int mxcost)\\n    {\\n        bool f = false;\\n        //int c = 0 ;\\n        //cout<<\"mid\"<<mid<<endl;\\n        int s = sum[mid] - sum[0];\\n        if(s <= mxcost)\\n            f = true;\\n        //cout<<\"s\"<<s<<endl;\\n       // int j = 0 ;\\n        for(int i = mid + 1 , j = 1; i <= n ;i++,j++  )\\n        {\\n            int p = sum[i] - sum[j];\\n            if(p <= mxcost)\\n                f = true;\\n            \\n        }\\n        return f;\\n    }\\n    int equalSubstring(string s, string t, int mxcost) {\\n         n = s.size();\\n        int l = 0 ; \\n        int h = s.size();\\n        pre.resize(n , 0 );\\n        for(int i = 0 ; i < n ;i++)\\n        {\\n            pre[i] = abs(s[i] - t[i]);\\n        }\\n        sum.resize(n+1,0);\\n        sum[1] = pre[0];\\n        for(int i = 1 ;i < n ;i++)\\n        {\\n            sum[i+1] = sum[i] + pre[i];\\n        }\\n         //for(auto i : sum)\\n            // cout<<i<<\" \";\\n        int ans = 0 ;\\n        \\n        while(l <= h)\\n        {\\n            int mid = l + (h-l)/2 ;\\n            if(check(mid , mxcost) == true )\\n            {\\n                ans = mid ;\\n                l = mid  + 1;\\n            }\\n            else \\n                h = mid - 1;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int>pre;\\n    vector<int>sum;\\n    int n ;\\n    bool check(int mid , int mxcost)\\n    {\\n        bool f = false;\\n        //int c = 0 ;\\n        //cout<<\"mid\"<<mid<<endl;\\n        int s = sum[mid] - sum[0];\\n        if(s <= mxcost)\\n            f = true;\\n        //cout<<\"s\"<<s<<endl;\\n       // int j = 0 ;\\n        for(int i = mid + 1 , j = 1; i <= n ;i++,j++  )\\n        {\\n            int p = sum[i] - sum[j];\\n            if(p <= mxcost)\\n                f = true;\\n            \\n        }",
                "codeTag": "C++"
            },
            {
                "id": 1327153,
                "title": "c-easy-simple-short-approach",
                "content": "class Solution {\\npublic:\\n    \\n    int equalSubstring(string s, string t, int maxCost){\\n        \\n        int maxLen=0;\\n        int start=0;\\n        int curr_budget=0;\\n        for(int end=0;end<s.size();end++){\\n            curr_budget+=abs(s[end]-t[end]);\\n            while(curr_budget > maxCost){ // to remove starting characters\\n                curr_budget-=abs(s[start]-t[start]);\\n                start++;\\n            }\\n            maxLen=max(maxLen, end-start+1);\\n        }\\n        return maxLen;\\n      }\\n\\t};\\n\\t\\n\\t*If any doubt please comment & ask, I\\'ll be happy if I can help  :)*",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int equalSubstring(string s, string t, int maxCost){\\n        \\n        int maxLen=0;\\n        int start=0;\\n        int curr_budget=0;\\n        for(int end=0;end<s.size();end++){\\n            curr_budget+=abs(s[end]-t[end]);\\n            while(curr_budget > maxCost){ // to remove starting characters\\n                curr_budget-=abs(s[start]-t[start]);\\n                start++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1306756,
                "title": "sliding-window-with-explanation-in-comments-c",
                "content": "Though sliding window seems a straightforward logic here, implementing it has been a nightmare for me since long. When to expand or shrink the window, and when to start a window anew - these questions consume a bit of mental bandwidth if the figure is not so clear in mind.\\nBelow is the code with explanation :\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n\\t\\n        int n = s.size();\\n        vector<int> cost(n , 0);\\n        \\n        for(int i = 0 ; i < n ; i++)\\n            cost[i] = abs((int)s[i] - (int)t[i]);\\n        \\n        int start = 0 , end = 0;\\n        int sum = 0;\\n        int res = 0;\\n            \\n        while(end < n){\\n            \\n            \\n            if(sum + cost[end] <= maxCost){   \\n                \\n                sum = sum + cost[end];//it\\'s ok to add as we have checked\\n                res = max(res , end - start + 1);//update res, since this can be a feasible solution\\n                end++;//now, we try to expand the window rightwards\\n                \\n            }\\n            \\n            else if(start < end){//cost is higher than budget, but start < end, so we increment start\\n                sum = sum - cost[start];//as we increment start, we need to remove that start\\'s cost\\n                start++;//incrementing start\\n            }\\n            \\n            else if(start == end)//if cost is higher and start == end, then we need to start a new window rightwards\\n                start++, end++, sum = 0;\\n            \\n        }\\n        \\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n\\t\\n        int n = s.size();\\n        vector<int> cost(n , 0);\\n        \\n        for(int i = 0 ; i < n ; i++)\\n            cost[i] = abs((int)s[i] - (int)t[i]);\\n        \\n        int start = 0 , end = 0;\\n        int sum = 0;\\n        int res = 0;\\n            \\n        while(end < n){\\n            \\n            \\n            if(sum + cost[end] <= maxCost){   \\n                \\n                sum = sum + cost[end];//it\\'s ok to add as we have checked\\n                res = max(res , end - start + 1);//update res, since this can be a feasible solution\\n                end++;//now, we try to expand the window rightwards\\n                \\n            }\\n            \\n            else if(start < end){//cost is higher than budget, but start < end, so we increment start\\n                sum = sum - cost[start];//as we increment start, we need to remove that start\\'s cost\\n                start++;//incrementing start\\n            }\\n            \\n            else if(start == end)//if cost is higher and start == end, then we need to start a new window rightwards\\n                start++, end++, sum = 0;\\n            \\n        }\\n        \\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263601,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int i = 0;\\n        int j = 0;\\n        int cost = 0;\\n        int maxLength = 0;\\n        while (j < s.length()) {\\n            cost += Math.abs((s.charAt(j) - \\'a\\') - (t.charAt(j) - \\'a\\'));\\n            if (cost <= maxCost)\\n                maxLength = Math.max(maxLength, j - i + 1);\\n            if (cost > maxCost) {\\n                cost -= Math.abs((s.charAt(i) - \\'a\\') - (t.charAt(i) - \\'a\\'));\\n                i++;\\n            }\\n            j++;\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int i = 0;\\n        int j = 0;\\n        int cost = 0;\\n        int maxLength = 0;\\n        while (j < s.length()) {\\n            cost += Math.abs((s.charAt(j) - \\'a\\') - (t.charAt(j) - \\'a\\'));\\n            if (cost <= maxCost)\\n                maxLength = Math.max(maxLength, j - i + 1);\\n            if (cost > maxCost) {\\n                cost -= Math.abs((s.charAt(i) - \\'a\\') - (t.charAt(i) - \\'a\\'));\\n                i++;\\n            }\\n            j++;\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226434,
                "title": "c-sliding-window-with-explanation",
                "content": "#### Steps--->\\n#### 1. Store the diff for each character(i.e. cost) in vector. (Just for convenience)\\n#### Now problem is converted into longest subarray with sum<=k (maxCost)\\n#### 2.Use Sliding window to find it.\\n#### \\n#### Time Complexity :- O(n)\\n\\n**It is not necessary to store diff in vector.\\nWe can use directly and improve space complexity.**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubarrayWithSumAtmostK(vector<int>&v,int k)\\n    {\\n        int n=v.size();\\n        int sum=0,i=0,j=0,res=0;\\n        while(j<n)\\n        {\\n            sum+=v[j++];\\n            while(sum>k)\\n            {\\n                sum-=v[i++];\\n            }\\n            res=max(res,j-i);\\n        }\\n        return res;\\n    }\\n    int equalSubstring(string s, string t, int K) \\n    {\\n        vector<int>v;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(abs(s[i]-t[i]));\\n        }\\n        return longestSubarrayWithSumAtmostK(v,K);\\n    }\\n};\\n```\\n\\n**Improved--->**\\n**Space -O(1)\\nTime-  O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int K) \\n    {\\n        int n=s.size();\\n        int sum=0,i=0,j=0,res=0;\\n        while(j<n)\\n        {\\n            sum+=abs(s[j]-t[j]);\\n            j++;\\n            while(sum>K)\\n            {\\n                sum-=abs(s[i]-t[i]);\\n                i++;\\n            }\\n            res=max(res,j-i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarrayWithSumAtmostK(vector<int>&v,int k)\\n    {\\n        int n=v.size();\\n        int sum=0,i=0,j=0,res=0;\\n        while(j<n)\\n        {\\n            sum+=v[j++];\\n            while(sum>k)\\n            {\\n                sum-=v[i++];\\n            }\\n            res=max(res,j-i);\\n        }\\n        return res;\\n    }\\n    int equalSubstring(string s, string t, int K) \\n    {\\n        vector<int>v;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(abs(s[i]-t[i]));\\n        }\\n        return longestSubarrayWithSumAtmostK(v,K);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int K) \\n    {\\n        int n=s.size();\\n        int sum=0,i=0,j=0,res=0;\\n        while(j<n)\\n        {\\n            sum+=abs(s[j]-t[j]);\\n            j++;\\n            while(sum>K)\\n            {\\n                sum-=abs(s[i]-t[i]);\\n                i++;\\n            }\\n            res=max(res,j-i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219718,
                "title": "java-very-easy-to-understand-sliding-window",
                "content": "Slightly slow as per leetcode, but very easy to understand and the basic application of variable size sliding window.\\n\\n```\\npublic static int equalSubstring(String s, String t, int maxCost) {\\n        int totalMax = 0;\\n        int currentMax = 0;\\n        int currentCost = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            currentCost += Math.abs(s.charAt(i) - t.charAt(i));\\n            currentMax++;\\n\\n            while (currentCost > maxCost) {\\n                currentMax--;\\n                currentCost -= Math.abs(s.charAt(i - currentMax) - t.charAt(i - currentMax));                \\n            }\\n\\n            if (totalMax < currentMax) {\\n                totalMax = currentMax;\\n            }\\n\\n        }\\n\\n        return totalMax;\\n    }\\n\\n``",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "Slightly slow as per leetcode, but very easy to understand and the basic application of variable size sliding window.\\n\\n```\\npublic static int equalSubstring(String s, String t, int maxCost) {\\n        int totalMax = 0;\\n        int currentMax = 0;\\n        int currentCost = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            currentCost += Math.abs(s.charAt(i) - t.charAt(i));\\n            currentMax++;\\n\\n            while (currentCost > maxCost) {\\n                currentMax--;\\n                currentCost -= Math.abs(s.charAt(i - currentMax) - t.charAt(i - currentMax));                \\n            }\\n\\n            if (totalMax < currentMax) {\\n                totalMax = currentMax;\\n            }\\n\\n        }\\n\\n        return totalMax;\\n    }\\n\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 1200582,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string a, string b, int maxCost) {\\n        int left = 0, right = 0, res = 0;\\n        int sz = a.length();\\n        int currCost = 0;\\n        \\n        while (right < sz) {\\n            int dist = (int)a[right] - (int)b[right];\\n            currCost += abs(dist);\\n            \\n            while (currCost > maxCost) {\\n                int left_dist = (int)a[left] - (int)b[left];\\n                currCost -= abs(left_dist);\\n                left++;\\n            }\\n            \\n            res = max (res, right - left + 1);\\n            right++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string a, string b, int maxCost) {\\n        int left = 0, right = 0, res = 0;\\n        int sz = a.length();\\n        int currCost = 0;\\n        \\n        while (right < sz) {\\n            int dist = (int)a[right] - (int)b[right];\\n            currCost += abs(dist);\\n            \\n            while (currCost > maxCost) {\\n                int left_dist = (int)a[left] - (int)b[left];\\n                currCost -= abs(left_dist);\\n                left++;\\n            }\\n            \\n            res = max (res, right - left + 1);\\n            right++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166814,
                "title": "java-sliding-window-t-c-o-n-s-c-o-1",
                "content": "\\n    public int equalSubstring(String s, String t, int maxCost) {\\n\\n\\t\\tint len = s.length(), max = 0, idx1 = -1, idx2 = 0, cost = 0;\\n\\n\\t\\twhile (idx2 < len) {\\n\\n\\t\\t\\twhile (idx2 < len) {\\n\\t\\t\\t\\tcost += Math.abs(s.charAt(idx2) - t.charAt(idx2));\\n\\t\\t\\t\\tif (cost <= maxCost) {\\n\\t\\t\\t\\t\\tif (idx2 - idx1 > max)\\n\\t\\t\\t\\t\\t\\tmax = idx2 - idx1;\\n\\t\\t\\t\\t\\tidx2++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tidx2++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (idx1 < idx2) {\\n\\t\\t\\t\\tidx1++;\\n\\t\\t\\t\\tcost -= Math.abs(s.charAt(idx1) - t.charAt(idx1));\\n\\t\\t\\t\\tif (cost <= maxCost)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    public int equalSubstring(String s, String t, int maxCost) {\\n\\n\\t\\tint len = s.length(), max = 0, idx1 = -1, idx2 = 0, cost = 0;\\n\\n\\t\\twhile (idx2 < len) {\\n\\n\\t\\t\\twhile (idx2 < len) {\\n\\t\\t\\t\\tcost += Math.abs(s.charAt(idx2) - t.charAt(idx2));\\n\\t\\t\\t\\tif (cost <= maxCost) {\\n\\t\\t\\t\\t\\tif (idx2 - idx1 > max)\\n\\t\\t\\t\\t\\t\\tmax = idx2 - idx1;\\n\\t\\t\\t\\t\\tidx2++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tidx2++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (idx1 < idx2) {\\n\\t\\t\\t\\tidx1++;\\n\\t\\t\\t\\tcost -= Math.abs(s.charAt(idx1) - t.charAt(idx1));\\n\\t\\t\\t\\tif (cost <= maxCost)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1102842,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int left = 0, right = 0, size = s.size();\\n        vector<int> difs(size, 0);\\n        for (int i = 0; i < size; i++) {\\n            difs[i] = abs(s[i] - t[i]);\\n        }\\n        int tempSum = difs[0], result = 0;\\n        while (right < size) {\\n            if (tempSum <= maxCost) {\\n                result = max(result, right - left + 1);\\n                right++;\\n                if (right < size) {\\n                    tempSum += difs[right];\\n                }\\n            }\\n            else {\\n                tempSum -= difs[left];\\n                left++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int left = 0, right = 0, size = s.size();\\n        vector<int> difs(size, 0);\\n        for (int i = 0; i < size; i++) {\\n            difs[i] = abs(s[i] - t[i]);\\n        }\\n        int tempSum = difs[0], result = 0;\\n        while (right < size) {\\n            if (tempSum <= maxCost) {\\n                result = max(result, right - left + 1);\\n                right++;\\n                if (right < size) {\\n                    tempSum += difs[right];\\n                }\\n            }\\n            else {\\n                tempSum -= difs[left];\\n                left++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019199,
                "title": "java",
                "content": "\\u89E3\\u9898\\u601D\\u8DEF\\uFF1A\\u5229\\u7528\\u6ED1\\u52A8\\u7A97\\u53E3\\u601D\\u60F3\\uFF0C\\u4ECE\\u5DE6\\u5230\\u53F3\\u8FDB\\u884C\\u904D\\u5386\\uFF0C\\u5F53\\u7A97\\u53E3\\u7684\\u5F00\\u9500\\u5927\\u4E8E\\u6700\\u5927\\u5F00\\u9500\\u65F6\\uFF0C\\u79FB\\u52A8\\u5DE6\\u8FB9\\uFF0C\\u5728\\u6B64\\u8FC7\\u7A0B\\u57CE\\u8BB0\\u5F55\\u53EF\\u4EE5\\u8F6C\\u5316\\u7684\\u6700\\u5927\\u957F\\u5EA6\\u3002\\n```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int[] costs = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n            costs[i] = Math.abs(s.charAt(i)-t.charAt(i));\\n        int count = 0;\\n        int maxLen = 0;\\n        for(int i=0,j=0;j<s.length();j++){\\n            count += costs[j];\\n            if(count>maxCost){\\n                while(count>maxCost){\\n                    count -= costs[i];\\n                    i++;\\n                }\\n            }\\n            maxLen = Math.max(maxLen,j-i+1);\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int[] costs = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n            costs[i] = Math.abs(s.charAt(i)-t.charAt(i));\\n        int count = 0;\\n        int maxLen = 0;\\n        for(int i=0,j=0;j<s.length();j++){\\n            count += costs[j];\\n            if(count>maxCost){\\n                while(count>maxCost){\\n                    count -= costs[i];\\n                    i++;\\n                }\\n            }\\n            maxLen = Math.max(maxLen,j-i+1);\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950787,
                "title": "python3-explanation-runtime-and-space-analysis-o-n-time-o-1-space",
                "content": "**Explanation**\\nThe idea is to use a left pointer and a right pointer which together form a sliding window which is of the size of the greatest subarray. We first start with `left = right = 0` and move `right` to the right as long as the maximal cost is not met. `Right` will be on the second invalid position or at the end of `s`. In the first case, the valid window is of size `right - left - 1` and in the second of size `right - left`. \\nWe then move `left` and `right` by one position to the right and repeat the process of expanding the window (= expanding the subarray) from the new position `left`. By doing this, we get the greatest valid subarray starting in each position `left` which is greater than or equal to the current greatest subarray (all the smaller subarrays are not interesting since they are not going to improve the result so they will be skipped by applying the sliding window method).\\n_________\\n**Runtime Complexity**\\n*Version 1 and 2* \\n`O(n)` for visiting each input character of `s` at most twice.\\n________\\n**Space Complexity**\\n*Version 1*\\n`O(1)`\\n*Version 2*\\n`O(n)` for possibly storing all costs in a list.\\n________\\n**Python Implementations**\\n*Version 1: More space-oriented*\\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        left = 0\\n        right = 0\\n        max_length = 0\\n        \\n        while len(s) - left > max_length:\\n            maxCost -= abs(ord(s[right]) - ord(t[right]))\\n            right += 1\\n            \\n            while maxCost >= 0 and right < len(s):\\n                maxCost -= abs(ord(s[right]) - ord(t[right]))\\n                right += 1\\n\\n            max_length = max(max_length, right - left) if maxCost >= 0 else max(max_length, right - left - 1)  \\n            maxCost += abs(ord(s[left]) - ord(t[left]))\\n            left += 1\\n                \\n        return max_length\\n\\n```\\n*Version 2: More runtime-oriented*\\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        left = 0\\n        right = 0\\n        max_length = 0\\n        costs = []\\n        \\n        while len(s) - left > max_length:\\n            costs.append(abs(ord(s[right]) - ord(t[right])))\\n            maxCost -= costs[right] \\n            right += 1\\n            \\n            while maxCost >= 0 and right < len(s):\\n                costs.append(abs(ord(s[right]) - ord(t[right])))\\n                maxCost -= costs[right]\\n                right += 1\\n\\n            max_length = max(max_length, right - left) if maxCost >= 0 else max(max_length, right - left - 1)  \\n            maxCost += costs[left]\\n            left += 1\\n                \\n        return max_length\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        left = 0\\n        right = 0\\n        max_length = 0\\n        \\n        while len(s) - left > max_length:\\n            maxCost -= abs(ord(s[right]) - ord(t[right]))\\n            right += 1\\n            \\n            while maxCost >= 0 and right < len(s):\\n                maxCost -= abs(ord(s[right]) - ord(t[right]))\\n                right += 1\\n\\n            max_length = max(max_length, right - left) if maxCost >= 0 else max(max_length, right - left - 1)  \\n            maxCost += abs(ord(s[left]) - ord(t[left]))\\n            left += 1\\n                \\n        return max_length\\n\\n```\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        left = 0\\n        right = 0\\n        max_length = 0\\n        costs = []\\n        \\n        while len(s) - left > max_length:\\n            costs.append(abs(ord(s[right]) - ord(t[right])))\\n            maxCost -= costs[right] \\n            right += 1\\n            \\n            while maxCost >= 0 and right < len(s):\\n                costs.append(abs(ord(s[right]) - ord(t[right])))\\n                maxCost -= costs[right]\\n                right += 1\\n\\n            max_length = max(max_length, right - left) if maxCost >= 0 else max(max_length, right - left - 1)  \\n            maxCost += costs[left]\\n            left += 1\\n                \\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898745,
                "title": "java-solution-faster-than-94",
                "content": "```\\nclass Solution {\\n\\tint max_len;\\npublic int equalSubstring(String s, String t, int maxCost) {\\n\\tmax_len=0;\\n\\tchar sarr[]=s.toCharArray();\\n\\tchar tarr[]=t.toCharArray();\\n\\tint cost[]=new int[s.length()];\\n\\tfor (int i=0;i<s.length();i++)\\n\\t{\\n\\t\\tcost[i]=Math.abs(sarr[i]-tarr[i]);\\n\\t}\\n\\tint start=0;\\n\\tint end;\\n\\tint sum=0;\\n\\tint max_len=Integer.MIN_VALUE;\\n\\tfor (end=0;end<cost.length;end++)\\n\\t{\\n\\t\\tsum+=cost[end];\\n\\t\\tif (sum<=maxCost)\\n\\t\\t{\\n\\t\\t\\tmax_len=Math.max(max_len,end-start+1);\\n\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\twhile (sum>maxCost)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum=sum-cost[start++];\\n\\t\\t\\t}\\n\\t\\t\\tmax_len=Math.max(max_len,end-start+1);\\n\\t\\t}\\n\\t}\\n\\treturn max_len==Integer.MIN_VALUE?0:max_len;\\n}\\n}   \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tint max_len;\\npublic int equalSubstring(String s, String t, int maxCost) {\\n\\tmax_len=0;\\n\\tchar sarr[]=s.toCharArray();\\n\\tchar tarr[]=t.toCharArray();\\n\\tint cost[]=new int[s.length()];\\n\\tfor (int i=0;i<s.length();i++)\\n\\t{\\n\\t\\tcost[i]=Math.abs(sarr[i]-tarr[i]);\\n\\t}\\n\\tint start=0;\\n\\tint end;\\n\\tint sum=0;\\n\\tint max_len=Integer.MIN_VALUE;\\n\\tfor (end=0;end<cost.length;end++)\\n\\t{\\n\\t\\tsum+=cost[end];\\n\\t\\tif (sum<=maxCost)\\n\\t\\t{\\n\\t\\t\\tmax_len=Math.max(max_len,end-start+1);\\n\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\twhile (sum>maxCost)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum=sum-cost[start++];\\n\\t\\t\\t}\\n\\t\\t\\tmax_len=Math.max(max_len,end-start+1);\\n\\t\\t}\\n\\t}\\n\\treturn max_len==Integer.MIN_VALUE?0:max_len;\\n}\\n}   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 892279,
                "title": "binary-search-sliding-window",
                "content": "```\\nbool fun(int len,string s,string t,int maxcost,int n)\\n    {\\n        int temp=0,cost=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            cost+=(abs((s[i]-\\'a\\')-(t[i]-\\'a\\')));\\n        }\\n        for(int i=n;i<len;i++)\\n        {\\n            if(cost<=maxcost) return(1);\\n            cost+=(abs((s[i]-\\'a\\')-(t[i]-\\'a\\')));\\n            cost-=(abs((s[i-n]-\\'a\\')-(t[i-n]-\\'a\\')));\\n        }\\n        if(cost<=maxcost) return(1);\\n        return(0);\\n    }\\n    \\n    \\n    \\n    int equalSubstring(string s, string t, int maxCost)\\n    {\\n        int len1=s.size();\\n        int lo=0,hi=len1;\\n        int ans=0;\\n        while(hi>=lo)\\n        {\\n            int mid=(lo+hi)/2;\\n            if(fun(len1,s,t,maxCost,mid)) \\n            {\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else hi=mid-1;\\n        }\\n        return(ans);\\n    }\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nbool fun(int len,string s,string t,int maxcost,int n)\\n    {\\n        int temp=0,cost=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            cost+=(abs((s[i]-\\'a\\')-(t[i]-\\'a\\')));\\n        }\\n        for(int i=n;i<len;i++)\\n        {\\n            if(cost<=maxcost) return(1);\\n            cost+=(abs((s[i]-\\'a\\')-(t[i]-\\'a\\')));\\n            cost-=(abs((s[i-n]-\\'a\\')-(t[i-n]-\\'a\\')));\\n        }\\n        if(cost<=maxcost) return(1);\\n        return(0);\\n    }\\n    \\n    \\n    \\n    int equalSubstring(string s, string t, int maxCost)\\n    {\\n        int len1=s.size();\\n        int lo=0,hi=len1;\\n        int ans=0;\\n        while(hi>=lo)\\n        {\\n            int mid=(lo+hi)/2;\\n            if(fun(len1,s,t,maxCost,mid)) \\n            {\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else hi=mid-1;\\n        }\\n        return(ans);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 862632,
                "title": "c-10-lines-sliding-window-o-n-time-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.size(), len = 0;\\n        for(int i=0, j=0; j<n; j++) {\\n            if(s[j]!=t[j]) maxCost-=abs(s[j]-t[j]);\\n            while(maxCost<0) {\\n                if(s[i]!=t[i]) maxCost+=abs(s[i]-t[i]);\\n                i++;\\n            }\\n            len = max(len, j-i+1);\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.size(), len = 0;\\n        for(int i=0, j=0; j<n; j++) {\\n            if(s[j]!=t[j]) maxCost-=abs(s[j]-t[j]);\\n            while(maxCost<0) {\\n                if(s[i]!=t[i]) maxCost+=abs(s[i]-t[i]);\\n                i++;\\n            }\\n            len = max(len, j-i+1);\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841304,
                "title": "python-o-n-sliding-window",
                "content": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        diff = [abs(ord(s[i]) - ord(t[i])) for i in range(len(s))]\\n        summ = 0\\n        low = length = 0\\n        for i in range(len(s)):\\n            summ += diff[i]\\n            while low < i and summ > maxCost:\\n                summ -= diff[low]\\n                low += 1\\n            if summ <= maxCost:\\n                length = max(length, i-low+1)\\n        return length\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        diff = [abs(ord(s[i]) - ord(t[i])) for i in range(len(s))]\\n        summ = 0\\n        low = length = 0\\n        for i in range(len(s)):\\n            summ += diff[i]\\n            while low < i and summ > maxCost:\\n                summ -= diff[low]\\n                low += 1\\n            if summ <= maxCost:\\n                length = max(length, i-low+1)\\n        return length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797049,
                "title": "c-prefix-sum-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int find_pos(vector<int> & dp,int target)\\n    {\\n        int l=0;\\n        int r=dp.size()-1;\\n        while(l<r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(target>dp[mid])\\n            {\\n                l=mid+1;\\n            }\\n            else{\\n                r=mid;\\n            }\\n        }\\n        return l;\\n    }\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n=s.length();\\n        vector<int> dp(n+1,0);\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i]=dp[i-1]+abs(s[i-1]-t[i-1]);\\n        }\\n        if(maxCost>dp[n]) return n;\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(dp[i]<=maxCost)\\n            {\\n                ans=max(ans,i);\\n            }\\n            else{\\n                int pos=find_pos(dp,dp[i]-maxCost);\\n                ans=max(ans,i-pos);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_pos(vector<int> & dp,int target)\\n    {\\n        int l=0;\\n        int r=dp.size()-1;\\n        while(l<r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(target>dp[mid])\\n            {\\n                l=mid+1;\\n            }\\n            else{\\n                r=mid;\\n            }\\n        }\\n        return l;\\n    }\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n=s.length();\\n        vector<int> dp(n+1,0);\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i]=dp[i-1]+abs(s[i-1]-t[i-1]);\\n        }\\n        if(maxCost>dp[n]) return n;\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(dp[i]<=maxCost)\\n            {\\n                ans=max(ans,i);\\n            }\\n            else{\\n                int pos=find_pos(dp,dp[i]-maxCost);\\n                ans=max(ans,i-pos);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770023,
                "title": "c-short-sliding-window-solution-o-n-time-o-1-space",
                "content": "While the cost is below the maximum cost, it expands the window. If the cost becomes higher than the maximum cost, it shifts the window and tries to expand it more (there is no need to shrink the window, because it is looking for the longest substring).\\n\\n\\n```\\npublic class Solution {\\n    public int EqualSubstring(string s, string t, int maxCost) {\\n        var currentCost = 0;\\n        var startIndex = 0;\\n        for (var i = 0; i < s.Length; ++i) {\\n            currentCost += Math.Abs(s[i] - t[i]);\\n            if (currentCost > maxCost) {\\n                currentCost -= Math.Abs(s[startIndex] - t[startIndex]);\\n                startIndex++;                \\n            }\\n        }\\n        \\n        return s.Length - startIndex;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int EqualSubstring(string s, string t, int maxCost) {\\n        var currentCost = 0;\\n        var startIndex = 0;\\n        for (var i = 0; i < s.Length; ++i) {\\n            currentCost += Math.Abs(s[i] - t[i]);\\n            if (currentCost > maxCost) {\\n                currentCost -= Math.Abs(s[startIndex] - t[startIndex]);\\n                startIndex++;                \\n            }\\n        }\\n        \\n        return s.Length - startIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764431,
                "title": "python-sliding-window",
                "content": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, c: int) -> int:\\n        l=len(s)\\n        ma=i=li=co=0\\n        while i<l and li<l:\\n            while i<l and  co+abs(ord(s[i])-ord(t[i]))<=c:\\n                co+=abs(ord(s[i])-ord(t[i]))\\n                i+=1\\n            ma=max(i-li,ma)\\n            co-=abs(ord(s[li])-ord(t[li]))\\n            li+=1\\n        return ma\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, c: int) -> int:\\n        l=len(s)\\n        ma=i=li=co=0\\n        while i<l and li<l:\\n            while i<l and  co+abs(ord(s[i])-ord(t[i]))<=c:\\n                co+=abs(ord(s[i])-ord(t[i]))\\n                i+=1\\n            ma=max(i-li,ma)\\n            co-=abs(ord(s[li])-ord(t[li]))\\n            li+=1\\n        return ma\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728147,
                "title": "my-java-solution",
                "content": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int[] ascii_values = new int[s.length()];\\n        \\n        for(int i = 0; i < s.length(); i++)\\n            ascii_values[i] = Math.abs(s.charAt(i) - t.charAt(i));\\n        \\n        int max_match = 0;\\n        int start = 0;\\n        int current_sum = 0;\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            current_sum += ascii_values[i];\\n            while(current_sum > maxCost && start <= i){\\n                current_sum -= ascii_values[start++];\\n            }\\n            max_match = Math.max(max_match,i - start + 1 );\\n        }\\n        \\n        return max_match;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int[] ascii_values = new int[s.length()];\\n        \\n        for(int i = 0; i < s.length(); i++)\\n            ascii_values[i] = Math.abs(s.charAt(i) - t.charAt(i));\\n        \\n        int max_match = 0;\\n        int start = 0;\\n        int current_sum = 0;\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            current_sum += ascii_values[i];\\n            while(current_sum > maxCost && start <= i){\\n                current_sum -= ascii_values[start++];\\n            }\\n            max_match = Math.max(max_match,i - start + 1 );\\n        }\\n        \\n        return max_match;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725783,
                "title": "java-0-n-sliding-window",
                "content": "```java\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int[] arr = new int[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            arr[i] = Math.abs(s.charAt(i) - t.charAt(i));\\n        }\\n        int maxMatch = 0;\\n        int start = 0;\\n        int currentSum = 0;\\n        // slinding window problem, find maximum subarray whose sum is less than target\\n        for (int i = 0; i < s.length(); i++) {\\n            currentSum = currentSum + arr[i];\\n            while (currentSum > maxCost && start <= i) {\\n                currentSum = currentSum - arr[start];\\n                start++;\\n            }\\n            maxMatch = Math.max(maxMatch, i-start+1);\\n        }\\n        return maxMatch; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int[] arr = new int[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            arr[i] = Math.abs(s.charAt(i) - t.charAt(i));\\n        }\\n        int maxMatch = 0;\\n        int start = 0;\\n        int currentSum = 0;\\n        // slinding window problem, find maximum subarray whose sum is less than target\\n        for (int i = 0; i < s.length(); i++) {\\n            currentSum = currentSum + arr[i];\\n            while (currentSum > maxCost && start <= i) {\\n                currentSum = currentSum - arr[start];\\n                start++;\\n            }\\n            maxMatch = Math.max(maxMatch, i-start+1);\\n        }\\n        return maxMatch; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722991,
                "title": "c-sliding-window-o-n",
                "content": "While `curCost > maxCost` we need to shift the starting pointer to match the values.\\n\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int d=0;\\n        int start=0, end=0, curCost=0;\\n        while(end < s.size()) {\\n            curCost += abs(s[end] - t[end]);\\n            end++;\\n            while(curCost > maxCost) {\\n                curCost -= abs(s[start] - t[start]);\\n                start++;\\n            }\\n            if (end-start > d) d = end-start;\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int d=0;\\n        int start=0, end=0, curCost=0;\\n        while(end < s.size()) {\\n            curCost += abs(s[end] - t[end]);\\n            end++;\\n            while(curCost > maxCost) {\\n                curCost -= abs(s[start] - t[start]);\\n                start++;\\n            }\\n            if (end-start > d) d = end-start;\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719507,
                "title": "easy-understand-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int sum=0,temp=0,ans=0,j=0;       //temp is the current window size,sum is the current window cost, ans is the maximum substring length till now\\n        for(int i=0;i<s.length();i++)\\n        {\\n            sum+=abs(s[i]-t[i]);\\n            if(sum<=maxCost)               //increase the window size\\n                temp++;\\n            else\\n            {\\n                while(j<=i && sum>maxCost)      //decrease the window size from back\\n                {\\n                    sum-=abs(s[j]-t[j]);\\n                    j++;\\n                }\\n                temp=i-j+1;            // update the current window size\\n            }\\n            ans=max(temp,ans);\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int sum=0,temp=0,ans=0,j=0;       //temp is the current window size,sum is the current window cost, ans is the maximum substring length till now\\n        for(int i=0;i<s.length();i++)\\n        {\\n            sum+=abs(s[i]-t[i]);\\n            if(sum<=maxCost)               //increase the window size\\n                temp++;\\n            else\\n            {\\n                while(j<=i && sum>maxCost)      //decrease the window size from back\\n                {\\n                    sum-=abs(s[j]-t[j]);\\n                    j++;\\n                }\\n                temp=i-j+1;            // update the current window size\\n            }\\n            ans=max(temp,ans);\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 667370,
                "title": "python3-simple-sliding-window",
                "content": "```\\nclass Solution(object):\\n    def equalSubstring(self, s, t, maxCost):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :type maxCost: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        start = 0\\n        ans = 0\\n        cur = 0\\n        \\n        for end in range(len(s)):\\n            \\n            val = abs(ord(s[end]) - ord(t[end]))\\n            cur += val\\n            if cur <= maxCost:\\n                ans = max(ans, end-start+1)\\n            else:\\n                while cur > maxCost:\\n                    cur -= abs(ord(s[start]) - ord(t[start]))\\n                    start += 1\\n                \\n        return ans\\n",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def equalSubstring(self, s, t, maxCost):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :type maxCost: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        start = 0\\n        ans = 0\\n        cur = 0\\n        \\n        for end in range(len(s)):\\n            \\n            val = abs(ord(s[end]) - ord(t[end]))\\n            cur += val\\n            if cur <= maxCost:\\n                ans = max(ans, end-start+1)\\n            else:\\n                while cur > maxCost:\\n                    cur -= abs(ord(s[start]) - ord(t[start]))\\n                    start += 1\\n                \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 660131,
                "title": "simplest-java-solution",
                "content": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int i=0,maxLen=0,sum=0;\\n        for(int j=0;j<t.length();j++){\\n\\t\\t\\t//at every index find sum \\n            sum=sum+Math.abs((int)t.charAt(j)-(int)s.charAt(j));\\n            while(sum>maxCost){\\n\\t\\t\\t//if not a valid window subtract ith from sum\\n                sum-=Math.abs((int)t.charAt(i)-(int)s.charAt(i));\\n                i++;\\n            }\\n            maxLen=Math.max(maxLen,j-i+1);\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int i=0,maxLen=0,sum=0;\\n        for(int j=0;j<t.length();j++){\\n\\t\\t\\t//at every index find sum \\n            sum=sum+Math.abs((int)t.charAt(j)-(int)s.charAt(j));\\n            while(sum>maxCost){\\n\\t\\t\\t//if not a valid window subtract ith from sum\\n                sum-=Math.abs((int)t.charAt(i)-(int)s.charAt(i));\\n                i++;\\n            }\\n            maxLen=Math.max(maxLen,j-i+1);\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584764,
                "title": "very-easy-o-n-sol-java-7ms",
                "content": "class Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n     \\n        int res = Integer.MIN_VALUE;\\n        int start = 0;\\n        int n = s.length();\\n        int currCost = 0 ;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            if( s.charAt(i) != t.charAt(i) )\\n                currCost += Math.abs( s.charAt(i) - t.charAt(i) );\\n            \\n            while( currCost > maxCost){\\n                \\n                if( s.charAt(start) != t.charAt(start) )    currCost -= Math.abs( s.charAt(start) - t.charAt(start) );\\n                \\n                start++;\\n                \\n            }\\n            \\n            res = Math.max(res, i - start + 1 );\\n            \\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n     \\n        int res = Integer.MIN_VALUE;\\n        int start = 0;\\n        int n = s.length();\\n        int currCost = 0 ;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            if( s.charAt(i) != t.charAt(i) )\\n                currCost += Math.abs( s.charAt(i) - t.charAt(i) );\\n            \\n            while( currCost > maxCost){\\n                \\n                if( s.charAt(start) != t.charAt(start) )    currCost -= Math.abs( s.charAt(start) - t.charAt(start) );\\n                \\n                start++;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 584702,
                "title": "simple-java-solution-treemap",
                "content": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int res = 0, n = s.length();\\n        int[] pre = new int[n+1];\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i = 1; i <= n; i++) {\\n            pre[i] = pre[i-1] + Math.abs(s.charAt(i-1) - t.charAt(i-1));\\n            map.putIfAbsent(pre[i], i);\\n            if(pre[i] <= maxCost) res = i;\\n            else {\\n                Integer x = map.ceilingKey(pre[i] - maxCost);\\n                if(x != null) {\\n                    res = Math.max(res, i - map.get(x));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int res = 0, n = s.length();\\n        int[] pre = new int[n+1];\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i = 1; i <= n; i++) {\\n            pre[i] = pre[i-1] + Math.abs(s.charAt(i-1) - t.charAt(i-1));\\n            map.putIfAbsent(pre[i], i);\\n            if(pre[i] <= maxCost) res = i;\\n            else {\\n                Integer x = map.ceilingKey(pre[i] - maxCost);\\n                if(x != null) {\\n                    res = Math.max(res, i - map.get(x));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552474,
                "title": "java-o-n-sliding-window-with-explanation",
                "content": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int l=0,r=0;\\n        int max = 0;\\n        int windowCost = 0;\\n        \\n        for(;r<s.length();r++){\\n            //update window cost\\n            windowCost += Math.abs(s.charAt(r)-t.charAt(r));\\n            //shrink window\\n            if(windowCost>maxCost){\\n                windowCost -= Math.abs(s.charAt(l)-t.charAt(l));\\n                l++;\\n            }\\n            //update longest substring\\n            if(windowCost<=maxCost && (r-l+1>max)){\\n                max = r-l+1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int l=0,r=0;\\n        int max = 0;\\n        int windowCost = 0;\\n        \\n        for(;r<s.length();r++){\\n            //update window cost\\n            windowCost += Math.abs(s.charAt(r)-t.charAt(r));\\n            //shrink window\\n            if(windowCost>maxCost){\\n                windowCost -= Math.abs(s.charAt(l)-t.charAt(l));\\n                l++;\\n            }\\n            //update longest substring\\n            if(windowCost<=maxCost && (r-l+1>max)){\\n                max = r-l+1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506753,
                "title": "c-clean-sliding-window",
                "content": "```\\npublic class Solution \\n{\\n    public int EqualSubstring(string s, string t, int maxCost)\\n    {\\n        int maxLength = 0;\\n        int currentCost = 0;\\n        \\n        int begin = 0;\\n        int end = 0;\\n        \\n        while(end < s.Length)\\n        {\\n            char currentChar = s[end];\\n            char currentChar2 = t[end];\\n            \\n            currentCost += GetCost(currentChar, currentChar2);\\n            \\n            while(currentCost > maxCost && begin <= end)\\n            {\\n                currentCost -= GetCost(s[begin], t[begin]);\\n                begin++;\\n            }   \\n            \\n            maxLength = Math.Max(maxLength, (end-begin)+1);\\n            end++;\\n        }\\n        \\n        return maxLength;\\n    }\\n    \\n    private int GetCost(char ch, char ch2)\\n    {\\n        int val1 = (int)ch;\\n        int val2 = (int)ch2;\\n        return Math.Abs(val1-val2);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int EqualSubstring(string s, string t, int maxCost)\\n    {\\n        int maxLength = 0;\\n        int currentCost = 0;\\n        \\n        int begin = 0;\\n        int end = 0;\\n        \\n        while(end < s.Length)\\n        {\\n            char currentChar = s[end];\\n            char currentChar2 = t[end];\\n            \\n            currentCost += GetCost(currentChar, currentChar2);\\n            \\n            while(currentCost > maxCost && begin <= end)\\n            {\\n                currentCost -= GetCost(s[begin], t[begin]);\\n                begin++;\\n            }   \\n            \\n            maxLength = Math.Max(maxLength, (end-begin)+1);\\n            end++;\\n        }\\n        \\n        return maxLength;\\n    }\\n    \\n    private int GetCost(char ch, char ch2)\\n    {\\n        int val1 = (int)ch;\\n        int val2 = (int)ch2;\\n        return Math.Abs(val1-val2);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505952,
                "title": "c-o-n-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int K) {\\n        vector<int> diff(s.length(),0);\\n        for(int i=0;i<s.length();++i){\\n            diff[i]=abs(s[i]-t[i]);\\n        }\\n        int start=0,end=0,maxl=0;\\n        int curr_sum=0;\\n        for(;end<s.length();++end){\\n            curr_sum+=diff[end];\\n            while(K<curr_sum){\\n                curr_sum-=diff[start];\\n                start++;\\n            }\\n            maxl=max(maxl,end-start+1);\\n        }\\n        return maxl;\\n            \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int equalSubstring(string s, string t, int K) {\\n        vector<int> diff(s.length(),0);\\n        for(int i=0;i<s.length();++i){\\n            diff[i]=abs(s[i]-t[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 488843,
                "title": "fast-and-simple-c-solution",
                "content": "```\\nint equalSubstring(char *s1, char *s2, int cost)\\n{\\n    int max_len = 0;\\n    for (int left = 0, right = 0; s1[right]; right++) {\\n        cost -= abs(s1[right] - s2[right]);\\n        while (cost < 0) {\\n            cost += abs(s1[left] - s2[left]);\\n            left++;\\n        }\\n        int t_max_len = right - left + 1;\\n        max_len = t_max_len > max_len ? t_max_len : max_len;\\n    }\\n\\n    return max_len;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint equalSubstring(char *s1, char *s2, int cost)\\n{\\n    int max_len = 0;\\n    for (int left = 0, right = 0; s1[right]; right++) {\\n        cost -= abs(s1[right] - s2[right]);\\n        while (cost < 0) {\\n            cost += abs(s1[left] - s2[left]);\\n            left++;\\n        }\\n        int t_max_len = right - left + 1;\\n        max_len = t_max_len > max_len ? t_max_len : max_len;\\n    }\\n\\n    return max_len;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 453916,
                "title": "javascript-solution-t-o-n-s-o-1",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} maxCost\\n * @return {number}\\n */\\nvar equalSubstring = function(s, t, maxCost) {\\n    let currCost = 0;\\n    let startIndex = 0;\\n    let maxLength = 0;\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        currCost += Math.abs(s.charCodeAt(i) - t.charCodeAt(i));\\n        \\n        while (currCost > maxCost) {\\n            currCost -= Math.abs(s.charCodeAt(startIndex) - t.charCodeAt(startIndex));\\n            startIndex++;\\n        }\\n        \\n        maxLength = Math.max(maxLength, i - startIndex + 1);\\n    }\\n    \\n    return maxLength;\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} maxCost\\n * @return {number}\\n */\\nvar equalSubstring = function(s, t, maxCost) {\\n    let currCost = 0;\\n    let startIndex = 0;\\n    let maxLength = 0;\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        currCost += Math.abs(s.charCodeAt(i) - t.charCodeAt(i));\\n        \\n        while (currCost > maxCost) {\\n            currCost -= Math.abs(s.charCodeAt(startIndex) - t.charCodeAt(startIndex));\\n            startIndex++;\\n        }\\n        \\n        maxLength = Math.max(maxLength, i - startIndex + 1);\\n    }\\n    \\n    return maxLength;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 414032,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int cnt = 0, max = 0, r = 0, l = 0, n = s.length();\\n        while(r < n) {\\n            cnt += Math.abs(s.charAt(r) - t.charAt(r));\\n            r++;\\n            while(cnt > maxCost) {\\n                cnt -= Math.abs(s.charAt(l) - t.charAt(l));\\n                l++;\\n            }\\n            max = Math.max(max, r - l);\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int cnt = 0, max = 0, r = 0, l = 0, n = s.length();\\n        while(r < n) {\\n            cnt += Math.abs(s.charAt(r) - t.charAt(r));\\n            r++;\\n            while(cnt > maxCost) {\\n                cnt -= Math.abs(s.charAt(l) - t.charAt(l));\\n                l++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 407573,
                "title": "c-solution-99-100-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        \\n        int low = 0 ;\\n        int high = 0 ;\\n        int res = 0;\\n        \\n        int count = 0 ;\\n        int cost = 0 ;\\n        while (high < s.size()) \\n        {\\n            cost += abs(s[high]-t[high]) ;\\n            if (cost <= maxCost)\\n            {\\n                count++ ;\\n                res = max(count, res) ;\\n                high++ ;\\n            }\\n            else\\n            {\\n                count++ ;\\n                while (cost > maxCost)\\n                {\\n                    cost -= abs(s[low]-t[low]) ;\\n                    low++ ; \\n                    count--;\\n                }\\n                high++ ;\\n            }\\n        }\\n        return res ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        \\n        int low = 0 ;\\n        int high = 0 ;\\n        int res = 0;\\n        \\n        int count = 0 ;\\n        int cost = 0 ;\\n        while (high < s.size()) \\n        {\\n            cost += abs(s[high]-t[high]) ;\\n            if (cost <= maxCost)\\n            {\\n                count++ ;\\n                res = max(count, res) ;\\n                high++ ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 407198,
                "title": "c-plain-binary-search-on-sliding-window-length",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    inline bool check(int sz, int mxc, const string &s, const string &t)\\n    {\\n        int cost(0);\\n        for (int i = 0; i < sz; i++)\\n            cost += abs(s[i] - t[i]);\\n        \\n        if (cost <= mxc)\\n            return true;\\n        \\n        for (int i = sz; i < s.length(); i++)\\n        {\\n            cost -= abs(s[i - sz] - t[i - sz]);\\n            cost += abs(s[i] - t[i]);\\n            \\n            if (cost <= mxc)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int equalSubstring(string s, string t, int maxCost)\\n    {\\n        int l(1), r(s.length());\\n        while (l <= r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            if (check(mid, maxCost, s, t))\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        \\n        return l - 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    inline bool check(int sz, int mxc, const string &s, const string &t)\\n    {\\n        int cost(0);\\n        for (int i = 0; i < sz; i++)\\n            cost += abs(s[i] - t[i]);\\n        \\n        if (cost <= mxc)\\n            return true;\\n        \\n        for (int i = sz; i < s.length(); i++)\\n        {\\n            cost -= abs(s[i - sz] - t[i - sz]);\\n            cost += abs(s[i] - t[i]);\\n            \\n            if (cost <= mxc)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int equalSubstring(string s, string t, int maxCost)\\n    {\\n        int l(1), r(s.length());\\n        while (l <= r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            if (check(mid, maxCost, s, t))\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        \\n        return l - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396525,
                "title": "python-with-sliding-window",
                "content": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        \\n        distance=[abs(ord(s[index])-ord(t[index])) for index in range(len(s))]    #distance vector for character pairs\\n        left=0               #left bracket of sliding window\\n        right=0              #right bracket of sliding window\\n        current=0            #current sum\\n        maxlen=0\\n        while(right!=len(s)):\\n            if current+distance[right]<=maxCost:      #when we can expand the window\\n                current+=distance[right]                #expand\\n                right+=1\\n            else:                                     #when we cannot expand the window\\n                if left==right:                         \\n                    left+=1\\n                    right+=1\\n                else:\\n                    maxlen=max(maxlen,right-left)\\n                    current-=distance[left]\\n                    left+=1 \\n        maxlen=max(maxlen,right-left)\\n        return maxlen\\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        \\n        distance=[abs(ord(s[index])-ord(t[index])) for index in range(len(s))]    #distance vector for character pairs\\n        left=0               #left bracket of sliding window\\n        right=0              #right bracket of sliding window\\n        current=0            #current sum\\n        maxlen=0\\n        while(right!=len(s)):\\n            if current+distance[right]<=maxCost:      #when we can expand the window\\n                current+=distance[right]                #expand\\n                right+=1\\n            else:                                     #when we cannot expand the window\\n                if left==right:                         \\n                    left+=1\\n                    right+=1\\n                else:\\n                    maxlen=max(maxlen,right-left)\\n                    current-=distance[left]\\n                    left+=1 \\n        maxlen=max(maxlen,right-left)\\n        return maxlen\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 396004,
                "title": "clean-python",
                "content": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        diff = []\\n        for c1, c2 in zip(s, t):\\n            diff.append(abs(ord(c1)-ord(c2)))\\n        L = len(diff)\\n        \\n        i, j, cur_sum, max_len = 0, 0, 0, 0\\n        while j < L:\\n            cur_sum += diff[j]\\n            if cur_sum <= maxCost:\\n                max_len = max(max_len, j-i+1)\\n            else:\\n                while cur_sum > maxCost:\\n                    cur_sum -= diff[i]\\n                    i += 1\\n            j += 1\\n        \\n        return max_len\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        diff = []\\n        for c1, c2 in zip(s, t):\\n            diff.append(abs(ord(c1)-ord(c2)))\\n        L = len(diff)\\n        \\n        i, j, cur_sum, max_len = 0, 0, 0, 0\\n        while j < L:\\n            cur_sum += diff[j]\\n            if cur_sum <= maxCost:\\n                max_len = max(max_len, j-i+1)\\n            else:\\n                while cur_sum > maxCost:\\n                    cur_sum -= diff[i]\\n                    i += 1\\n            j += 1\\n        \\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394323,
                "title": "python-sliding-window",
                "content": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        L = len(s)\\n        dif = [abs(ord(sx) - ord(tx)) for sx, tx in zip(s, t)]\\n        start = 0\\n        cur = dif[0]\\n        res = 1 if cur <= maxCost else 0\\n        for i in range(1, L):\\n            cur += dif[i]\\n            while cur > maxCost:\\n                cur -= dif[start]\\n                start += 1\\n            res = max(res, i-start+1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        L = len(s)\\n        dif = [abs(ord(sx) - ord(tx)) for sx, tx in zip(s, t)]\\n        start = 0\\n        cur = dif[0]\\n        res = 1 if cur <= maxCost else 0\\n        for i in range(1, L):\\n            cur += dif[i]\\n            while cur > maxCost:\\n                cur -= dif[start]\\n                start += 1\\n            res = max(res, i-start+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393419,
                "title": "simply-simple-python-solution-with-explanation-prefix-sum",
                "content": "\\tdef equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        # At every step take current difference and add it to previous sum\\n        # If the current sum < maxCost then the usbstring length is i + 1\\n        # else find the sum in map such that the differenc of that sum and current sum\\n        # is <= maxCost.\\n        if maxCost == 0:\\n            return 1\\n        mp = {}\\n        prefix_sum = 0\\n        \\n        mp[0] = -1\\n        result = 0\\n        for i in range(len(s)):\\n            c1, c2 = s[i], t[i]\\n            prefix_sum += abs(ord(c1) - ord(c2))\\n            if prefix_sum <= maxCost:\\n                result = max(result, i+1)\\n            else:\\n                need = prefix_sum - maxCost\\n                # Say if prefix_sum is 10 and maxCost is 4\\n                # then you need to check if 6,7,8,9, or 10\\n                # exists in map or not. If yes then the cost is <= maxCost\\n                # and it is a candidate for the result\\n                # need = 10 - 4 = 6 that\\'s why you need to increase need \\n                while need < prefix_sum:\\n                    if need in mp:\\n                        result = max(result, i - mp[need])\\n                        break\\n                    need += 1\\n            mp[prefix_sum] = i\\n                    \\n        return result\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        # At every step take current difference and add it to previous sum\\n        # If the current sum < maxCost then the usbstring length is i + 1\\n        # else find the sum in map such that the differenc of that sum and current sum\\n        # is <= maxCost.\\n        if maxCost == 0:\\n            return 1\\n        mp = {}\\n        prefix_sum = 0\\n        \\n        mp[0] = -1\\n        result = 0\\n        for i in range(len(s)):\\n            c1, c2 = s[i], t[i]\\n            prefix_sum += abs(ord(c1) - ord(c2))\\n            if prefix_sum <= maxCost:\\n                result = max(result, i+1)\\n            else:\\n                need = prefix_sum - maxCost\\n                # Say if prefix_sum is 10 and maxCost is 4\\n                # then you need to check if 6,7,8,9, or 10\\n                # exists in map or not. If yes then the cost is <= maxCost\\n                # and it is a candidate for the result\\n                # need = 10 - 4 = 6 that\\'s why you need to increase need \\n                while need < prefix_sum:\\n                    if need in mp:\\n                        result = max(result, i - mp[need])\\n                        break\\n                    need += 1\\n            mp[prefix_sum] = i\\n                    \\n        return result\\n",
                "codeTag": "Python3"
            },
            {
                "id": 393097,
                "title": "solution-in-python-3-beats-100-six-lines",
                "content": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, M: int) -> int:\\n    \\tL, D, m, i, j = len(s)+1, [abs(ord(s[i])-ord(t[i])) for i in range(len(s))], 0, 0, 0\\n    \\tC = [0]+list(itertools.accumulate(D))\\n    \\twhile i < L - m:\\n    \\t\\twhile j < L and C[j]-C[i] <= M: m, j = max(m, j - i), j + 1\\n    \\t\\ti += 1\\n    \\treturn m\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, M: int) -> int:\\n    \\tL, D, m, i, j = len(s)+1, [abs(ord(s[i])-ord(t[i])) for i in range(len(s))], 0, 0, 0\\n    \\tC = [0]+list(itertools.accumulate(D))\\n    \\twhile i < L - m:\\n    \\t\\twhile j < L and C[j]-C[i] <= M: m, j = max(m, j - i), j + 1\\n    \\t\\ti += 1\\n    \\treturn m\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 392881,
                "title": "c-2-solutions-sliding-window-prefix-sum-binary-search",
                "content": "1, sliding window, O(n) space && O(n) time.\\n```cpp\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int k) {\\n        int n = s.length(), front, back = 0, maxLen = 0;\\n        vector<int> diff(n);\\n        for (front = 0; front < n; ++front) {\\n            diff[front] = abs(s[front] - t[front]);\\n            k -= diff[front];\\n            while (k < 0)\\n                k += diff[back++];\\n            if (front - back + 1 > maxLen)\\n                maxLen = front - back + 1;\\n        }\\n        return maxLen;\\n    }\\n};\\n```\\n2, prefix sum + binary search, O(n) space && O(n log n) time.\\n```cpp\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.size();\\n        vector<int> prefix(n + 1);\\n        prefix[0] = 0;\\n        for (int i = 0; i < n; i++)\\n            prefix[i + 1] = abs(s[i] - t[i]) + prefix[i];\\n        int maxLen = 0;\\n        for (int i = 0; i < n; i++) {\\n            int lo = i + 1, hi = n + 1;\\n            while (lo < hi) {\\n                int mi = lo + (hi - lo) / 2;\\n                if (prefix[mi] - prefix[i] <= maxCost)\\n                    lo = mi + 1;\\n                else\\n                    hi = mi;\\n            }\\n            if (lo - i - 1 > maxLen)\\n                maxLen = lo - i - 1;\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int k) {\\n        int n = s.length(), front, back = 0, maxLen = 0;\\n        vector<int> diff(n);\\n        for (front = 0; front < n; ++front) {\\n            diff[front] = abs(s[front] - t[front]);\\n            k -= diff[front];\\n            while (k < 0)\\n                k += diff[back++];\\n            if (front - back + 1 > maxLen)\\n                maxLen = front - back + 1;\\n        }\\n        return maxLen;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.size();\\n        vector<int> prefix(n + 1);\\n        prefix[0] = 0;\\n        for (int i = 0; i < n; i++)\\n            prefix[i + 1] = abs(s[i] - t[i]) + prefix[i];\\n        int maxLen = 0;\\n        for (int i = 0; i < n; i++) {\\n            int lo = i + 1, hi = n + 1;\\n            while (lo < hi) {\\n                int mi = lo + (hi - lo) / 2;\\n                if (prefix[mi] - prefix[i] <= maxCost)\\n                    lo = mi + 1;\\n                else\\n                    hi = mi;\\n            }\\n            if (lo - i - 1 > maxLen)\\n                maxLen = lo - i - 1;\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392860,
                "title": "simple-java-solution-using-sliding-window-with-explanation",
                "content": "First compute the cost for each char, then find a max window with limited cost.\\n```\\npublic int equalSubstring(String s, String t, int maxCost) {\\n        int n = s.length();\\n        int[] dist = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            dist[i] = Math.abs(s.charAt(i) - t.charAt(i));\\n        }\\n        int maxLen = 0;\\n        for (int start = 0, end = 0, curCost = 0; end < n; end++) {\\n            curCost += dist[end];\\n            while (start <= end && curCost > maxCost) {\\n                curCost -= dist[start];\\n                start++;\\n            }\\n            if (curCost <= maxCost) {\\n                maxLen = Math.max(maxLen, end - start + 1);\\n            }\\n        }\\n        return maxLen;\\n    }",
                "solutionTags": [],
                "code": "First compute the cost for each char, then find a max window with limited cost.\\n```\\npublic int equalSubstring(String s, String t, int maxCost) {\\n        int n = s.length();\\n        int[] dist = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            dist[i] = Math.abs(s.charAt(i) - t.charAt(i));\\n        }\\n        int maxLen = 0;\\n        for (int start = 0, end = 0, curCost = 0; end < n; end++) {\\n            curCost += dist[end];\\n            while (start <= end && curCost > maxCost) {\\n                curCost -= dist[start];\\n                start++;\\n            }\\n            if (curCost <= maxCost) {\\n                maxLen = Math.max(maxLen, end - start + 1);\\n            }\\n        }\\n        return maxLen;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 392843,
                "title": "my-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int res = 0, n = s.size(), cur = 0, start = 0;\\n        for (int i = 0; i < n; ++i) {\\n        \\tcur += abs(s[i] - t[i]);\\n        \\twhile (cur > maxCost && start <= i) {\\n        \\t\\tcur -= abs(s[start] - t[start]);\\n        \\t\\t++start;\\n        \\t}\\n        \\tres = max(res, i - start + 1);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int res = 0, n = s.size(), cur = 0, start = 0;\\n        for (int i = 0; i < n; ++i) {\\n        \\tcur += abs(s[i] - t[i]);\\n        \\twhile (cur > maxCost && start <= i) {\\n        \\t\\tcur -= abs(s[start] - t[start]);\\n        \\t\\t++start;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 392836,
                "title": "two-pointer-simple-solution-time-o-n-space-o-n",
                "content": "```\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int l = s.length();\\n        int[] nums = new int[l];\\n        for(int i=0; i<s.length(); ++i) {\\n            nums[i] = Math.abs(s.charAt(i) - t.charAt(i));\\n        }\\n        int len = 0;\\n        int sum = 0;\\n        for(int i=0, j=0; i<l; ++i) {\\n            sum += nums[i];\\n            while (j<=i && sum > maxCost) {\\n                sum -= nums[j++];\\n            }\\n            len = Math.max(len, i-j+1);\\n        }\\n        return len;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int l = s.length();\\n        int[] nums = new int[l];\\n        for(int i=0; i<s.length(); ++i) {\\n            nums[i] = Math.abs(s.charAt(i) - t.charAt(i));\\n        }\\n        int len = 0;\\n        int sum = 0;\\n        for(int i=0, j=0; i<l; ++i) {\\n            sum += nums[i];\\n            while (j<=i && sum > maxCost) {\\n                sum -= nums[j++];\\n            }\\n            len = Math.max(len, i-j+1);\\n        }\\n        return len;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 392826,
                "title": "c-bind-and-placeholders",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.size();\\n        vector<int> diff(n);\\n        transform(s.begin(), s.end(), t.begin(), diff.begin(), bind(::labs, bind(minus<int>(), placeholders::_1, placeholders::_2)));\\n        int res = 0;\\n        for (auto l = diff.begin(), r = diff.begin(); r < diff.end();) {\\n            maxCost -= *r++;\\n            while (maxCost < 0) maxCost += *l++;\\n            res = max(res, (int)distance(l, r));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.size();\\n        vector<int> diff(n);\\n        transform(s.begin(), s.end(), t.begin(), diff.begin(), bind(::labs, bind(minus<int>(), placeholders::_1, placeholders::_2)));\\n        int res = 0;\\n        for (auto l = diff.begin(), r = diff.begin(); r < diff.end();) {\\n            maxCost -= *r++;\\n            while (maxCost < 0) maxCost += *l++;\\n            res = max(res, (int)distance(l, r));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4106595,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int EqualSubstring(string s, string t, int maxCost) {\\n        int right=0, left=0, k=0, cost =0;\\n        \\n        while(right < s.Length){\\n            cost += Math.Abs(s[right] - t[right]);\\n            while(cost > maxCost){\\n                cost -= Math.Abs(s[left] - t[left]);\\n                left++;\\n            }\\n            int win = right - left + 1;\\n            k = k > win ? k : win;\\n            right++;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    public int EqualSubstring(string s, string t, int maxCost) {\\n        int right=0, left=0, k=0, cost =0;\\n        \\n        while(right < s.Length){\\n            cost += Math.Abs(s[right] - t[right]);\\n            while(cost > maxCost){\\n                cost -= Math.Abs(s[left] - t[left]);\\n                left++;\\n            }\\n            int win = right - left + 1;\\n            k = k > win ? k : win;\\n            right++;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064821,
                "title": "go-beats-100-convert-problem-into-longest-subarray-with-sum-less-than-equal-to-maxcost-o-n",
                "content": "# Intuition\\nConvert problem into Longest subarray with sum less than equal to maxCost by creating an array of absolute diff of characters\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc equalSubstring(s string, t string, maxCost int) int {\\n    // Build an array of char absolute diff\\n    n := len(s)\\n    diff := make([] int, n)\\n    maxLength := 0\\n    for i := 0; i < n; i++ {\\n        diff[i] = absDiff(s[i], t[i])\\n    }\\n\\n    // Now the problem has been reduced to maximum length subarray with sum less than equal to k.\\n    sum := 0 \\n    length := 0\\n    start := 0 \\n    end := 0 \\n    \\n    for end < n {\\n        sum += diff[end]\\n        length++\\n\\n        if sum > maxCost {\\n            // Reduce the window until the sum is within maxCost range\\n            for sum > maxCost && start <= end {\\n                sum -= diff[start]\\n                start++\\n                length--\\n            }\\n        }else {\\n           \\n            if length > maxLength {\\n                maxLength = length\\n            } \\n        }\\n\\n        end++\\n    }\\n    return maxLength\\n}\\n\\nfunc absDiff(a byte, b byte) int {\\n    if a > b {\\n        return int(a - b)\\n    }else {\\n        return int(b - a)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc equalSubstring(s string, t string, maxCost int) int {\\n    // Build an array of char absolute diff\\n    n := len(s)\\n    diff := make([] int, n)\\n    maxLength := 0\\n    for i := 0; i < n; i++ {\\n        diff[i] = absDiff(s[i], t[i])\\n    }\\n\\n    // Now the problem has been reduced to maximum length subarray with sum less than equal to k.\\n    sum := 0 \\n    length := 0\\n    start := 0 \\n    end := 0 \\n    \\n    for end < n {\\n        sum += diff[end]\\n        length++\\n\\n        if sum > maxCost {\\n            // Reduce the window until the sum is within maxCost range\\n            for sum > maxCost && start <= end {\\n                sum -= diff[start]\\n                start++\\n                length--\\n            }\\n        }else {\\n           \\n            if length > maxLength {\\n                maxLength = length\\n            } \\n        }\\n\\n        end++\\n    }\\n    return maxLength\\n}\\n\\nfunc absDiff(a byte, b byte) int {\\n    if a > b {\\n        return int(a - b)\\n    }else {\\n        return int(b - a)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4063603,
                "title": "java-sliding-window-tc-o-n-sc-o-1",
                "content": "# Approach\\nBuild a window that accumulates a cost until it is over maxCost. Once, we break this constraint, we move up the left pointer and subtract the left pointer\\u2019s cost. Every iteration, we update ans to find the max length of the subarray while maintaining curr \\u2264 maxCost.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int ans = 0;\\n        int curr = 0;\\n        int left = 0;\\n\\n        for (int right = 0; right < s.length(); right++) {\\n            // update curr\\n            curr += Math.abs(s.charAt(right) - t.charAt(right));\\n\\n            // broken constraint case\\n            while (curr > maxCost) {\\n                curr -= Math.abs(s.charAt(left) - t.charAt(left));\\n                left++;\\n            }\\n\\n            // update ans\\n            ans = Math.max(ans, right - left + 1);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int ans = 0;\\n        int curr = 0;\\n        int left = 0;\\n\\n        for (int right = 0; right < s.length(); right++) {\\n            // update curr\\n            curr += Math.abs(s.charAt(right) - t.charAt(right));\\n\\n            // broken constraint case\\n            while (curr > maxCost) {\\n                curr -= Math.abs(s.charAt(left) - t.charAt(left));\\n                left++;\\n            }\\n\\n            // update ans\\n            ans = Math.max(ans, right - left + 1);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042515,
                "title": "easy-o-n-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use variable length sliding window to get maximum window with sum less equals maxCost.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Take two pointer intialize to 0.\\n2. Move one while it less than size of the string and store the `sum` of `abs(s[i] - t[i])`.\\n3. When `sum` greater than `maxCost` then we shrink our window until it less or equal to `maxCost`.\\n4. then find the length and take max among them.Length of a window will be `j-i+1`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: As we are not using extra data structure the sc will be $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int n = s.length();\\n        int i = 0, j = 0;\\n        int diffSum = 0, len = 0;\\n        while(j < n) {\\n            diffSum += Math.abs(s.charAt(j)-t.charAt(j));\\n            while(diffSum > maxCost) {\\n                diffSum -= Math.abs(s.charAt(i) - t.charAt(i));\\n                i++;\\n            }\\n            len = Math.max(len, j-i+1);\\n            j++;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int n = s.length();\\n        int i = 0, j = 0;\\n        int diffSum = 0, len = 0;\\n        while(j < n) {\\n            diffSum += Math.abs(s.charAt(j)-t.charAt(j));\\n            while(diffSum > maxCost) {\\n                diffSum -= Math.abs(s.charAt(i) - t.charAt(i));\\n                i++;\\n            }\\n            len = Math.max(len, j-i+1);\\n            j++;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037738,
                "title": "java-beats-97-00-of-users-with-java-time-0-n-space-o-1",
                "content": "# Intuition\\nThis is a sliding-window problem because the question asks us to find its \"sub\".\\n\\n# Approach\\nWe start from the first index on both Strings and then we subtract those. In Java, whenever you do a char calculation, it will automatically convert it for you to an integer. E.g: \\'a\\' is 1, \\'b\\' is 2, etc.\\nAfter we subtract those two characters, we check if the current total surpass our maxCost or not. If so, then we subtract the total and increment the left bound until the total less than or equal to the maxCost.\\nLastly, we check the current length and compare it with our max length.\\nThat\\'s it!\\n\\n# Complexity\\n- Time complexity:\\nAmortized O(n), since the while block won\\'t run on each loop.\\n\\n- Space complexity:\\nO(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int maxLen = Integer.MIN_VALUE;\\n        char[] sStr = s.toCharArray();\\n        char[] tStr = t.toCharArray();\\n        int left = 0;\\n        int total = 0;\\n\\n        for (int right = 0; right < tStr.length; right++) {\\n            total += Math.abs(sStr[right] - tStr[right]);\\n            while (total > maxCost) {\\n                total -= Math.abs(sStr[left] - tStr[left]);\\n                left++;\\n            }\\n            maxLen = Math.max(maxLen, (right - left + 1));\\n        }\\n\\n        return (maxLen == Integer.MIN_VALUE) ? 0 : maxLen;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int maxLen = Integer.MIN_VALUE;\\n        char[] sStr = s.toCharArray();\\n        char[] tStr = t.toCharArray();\\n        int left = 0;\\n        int total = 0;\\n\\n        for (int right = 0; right < tStr.length; right++) {\\n            total += Math.abs(sStr[right] - tStr[right]);\\n            while (total > maxCost) {\\n                total -= Math.abs(sStr[left] - tStr[left]);\\n                left++;\\n            }\\n            maxLen = Math.max(maxLen, (right - left + 1));\\n        }\\n\\n        return (maxLen == Integer.MIN_VALUE) ? 0 : maxLen;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031802,
                "title": "kotlin-solution",
                "content": "# Intuition\\nDynamic sliding window\\n\\n# Approach\\nIterate through indexes while counting the cost. If the cost is bigger than our maxCost then subtract the cost of the left side pointer subtraction, with left pointer increment until the cost is less or equal to maxCost.\\nOn each iteration, we increment the length counter and while removing cost from the left we decrement the length.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun equalSubstring(s: String, t: String, maxCost: Int): Int {\\n        var left = 0\\n        var cost = 0\\n        var maxLength = 0\\n        var lengthCounter = 0\\n        for (i in s.indices) {\\n            cost += abs(s[i] - t[i])\\n            lengthCounter++\\n\\n            while (cost > maxCost) {\\n                cost -= abs(s[left] - t[left])\\n                lengthCounter--\\n                left++\\n            }\\n            maxLength = max(maxLength, lengthCounter)\\n        }\\n        return maxLength\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    fun equalSubstring(s: String, t: String, maxCost: Int): Int {\\n        var left = 0\\n        var cost = 0\\n        var maxLength = 0\\n        var lengthCounter = 0\\n        for (i in s.indices) {\\n            cost += abs(s[i] - t[i])\\n            lengthCounter++\\n\\n            while (cost > maxCost) {\\n                cost -= abs(s[left] - t[left])\\n                lengthCounter--\\n                left++\\n            }\\n            maxLength = max(maxLength, lengthCounter)\\n        }\\n        return maxLength\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028263,
                "title": "easy-java-o-n-solution-sliding-window",
                "content": "# Intuition\\nexpand to the right keeping track of the cost of swapping the current element in both strings. Find the cost to swap and add it to a currentCost variable. When the value exceeds the maxCost, subtract elements from the left.\\n\\n# Approach\\nCreate a sliding window. The elements on the right side should be added to a `currentCost` variable. When the `currentCost` exceeds `maxCost`, we move the left side of the window to the right subtracting the left most elements cost.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int longestSubString = 0;\\n        int l = 0;\\n        int currentCost = 0;\\n\\n        for(int i = 0; i < s.length(); i++){\\n            char tChar = t.charAt(i);\\n            char sChar = s.charAt(i);\\n            currentCost += Math.abs((sChar - \\'a\\') - (tChar - \\'a\\'));\\n\\n            while(currentCost > maxCost){\\n                char tLChar = t.charAt(l);\\n                char sLChar = s.charAt(l);\\n                currentCost -= Math.abs((sLChar - \\'a\\') - (tLChar - \\'a\\'));\\n                l++;\\n            }\\n\\n\\n            longestSubString = Math.max(longestSubString, i - l + 1);\\n        }\\n\\n        return longestSubString;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int longestSubString = 0;\\n        int l = 0;\\n        int currentCost = 0;\\n\\n        for(int i = 0; i < s.length(); i++){\\n            char tChar = t.charAt(i);\\n            char sChar = s.charAt(i);\\n            currentCost += Math.abs((sChar - \\'a\\') - (tChar - \\'a\\'));\\n\\n            while(currentCost > maxCost){\\n                char tLChar = t.charAt(l);\\n                char sLChar = s.charAt(l);\\n                currentCost -= Math.abs((sLChar - \\'a\\') - (tLChar - \\'a\\'));\\n                l++;\\n            }\\n\\n\\n            longestSubString = Math.max(longestSubString, i - l + 1);\\n        }\\n\\n        return longestSubString;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022252,
                "title": "6ms-speed-using-sliding-window-2-pointer",
                "content": "int equalSubstring(string s, string t, int maxcost) {\\n    int i = 0, j = 0;\\n    int n = s.size();\\n    int ans = 0;\\n    int cost = 0;\\n\\n    for (i = 0; i < n; i++) {\\n        cost += abs(s[i] - t[i]);\\n\\n        // If the cost exceeds maxcost, move the left pointer j\\n        while (cost > maxcost) {\\n            cost -= abs(s[j] - t[j]);\\n            j++;\\n        }\\n\\n        // Update the maximum substring length found so far\\n        ans = max(ans, i - j + 1);\\n    }\\n\\n    return ans;\\n}",
                "solutionTags": [
                    "String",
                    "Sliding Window"
                ],
                "code": "int equalSubstring(string s, string t, int maxcost) {\\n    int i = 0, j = 0;\\n    int n = s.size();\\n    int ans = 0;\\n    int cost = 0;\\n\\n    for (i = 0; i < n; i++) {\\n        cost += abs(s[i] - t[i]);\\n\\n        // If the cost exceeds maxcost, move the left pointer j\\n        while (cost > maxcost) {\\n            cost -= abs(s[j] - t[j]);\\n            j++;\\n        }\\n\\n        // Update the maximum substring length found so far\\n        ans = max(ans, i - j + 1);\\n    }\\n\\n    return ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3999203,
                "title": "java-max-length-of-sub-array-less-than-equal-to-k",
                "content": "class Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int arr[] = new int[s.length()];\\n        \\n        for(int i=0 ; i<s.length();i++){\\n            arr[i]=Math.abs(s.charAt(i)-t.charAt(i));\\n        }\\n        \\n        int maxlen = 0 , len = 0 ;\\n        int cnt =0 ,sum=0;\\n        for(int i=0 ; i<arr.length;i++){\\n            \\n            if(sum+arr[i]<=maxCost){\\n                sum+=arr[i];\\n                len++;\\n            }\\n            else{\\n                sum= sum - arr[i-len]+arr[i];\\n            }\\n            maxlen = Math.max(maxlen,len);\\n        }\\n        return maxlen;\\n    }\\n}",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int arr[] = new int[s.length()];\\n        \\n        for(int i=0 ; i<s.length();i++){\\n            arr[i]=Math.abs(s.charAt(i)-t.charAt(i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3962382,
                "title": "c-sliding-window-explained-in-line-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int start=0;\\n        int end=0;\\n        int max_length=0;\\n        int sum=0;\\n        //we are going to use sliding window technque \\n        //phir isme string s and string t e correspond end and start pointer to same hi rhega as length to same hai\\n        //jab jab window expnd hoga ham s[end]-t[end] krke calculate krte rhenge\\n        //and phir jab ye cost s[end]-st[end] gretaer ho jiga given maxcost se to ye phir nhi ho piga convert\\n        //isliye contract krenge isliye we wil contract by using start++\\n        //par phle start++ krne se phle ham jo start pe pointkr rha tha usko cost se htainge to sum-=s[start]-st[start] wala char ka cost ghta diya\\n        for(;end<s.size();end++) //as in constarints diya hua hai ki length are equal\\n        {\\n           sum+=abs(s[end]-t[end]);\\n           while(sum>maxCost)\\n           {\\n               sum-=abs(s[start]-t[start]);\\n               start++;\\n           }\\n           max_length=max(max_length,end-start+1);\\n        }\\n        return max_length;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int start=0;\\n        int end=0;\\n        int max_length=0;\\n        int sum=0;\\n        //we are going to use sliding window technque \\n        //phir isme string s and string t e correspond end and start pointer to same hi rhega as length to same hai\\n        //jab jab window expnd hoga ham s[end]-t[end] krke calculate krte rhenge\\n        //and phir jab ye cost s[end]-st[end] gretaer ho jiga given maxcost se to ye phir nhi ho piga convert\\n        //isliye contract krenge isliye we wil contract by using start++\\n        //par phle start++ krne se phle ham jo start pe pointkr rha tha usko cost se htainge to sum-=s[start]-st[start] wala char ka cost ghta diya\\n        for(;end<s.size();end++) //as in constarints diya hua hai ki length are equal\\n        {\\n           sum+=abs(s[end]-t[end]);\\n           while(sum>maxCost)\\n           {\\n               sum-=abs(s[start]-t[start]);\\n               start++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3961062,
                "title": "using-binary-search-and-fixed-len-sliding-window",
                "content": "# Intuition\\nBrute force is simply to iterate over all subarrays with len 1, 2, 3, etc..\\n\\n# Approach\\nWe are actually doing a linear search of subarray len starting from length 1, 2,...,n, n -> length of string. Instead we can do a binary search.\\n\\n# Complexity\\n- Time complexity:\\n$$O(NLogN)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int maxLen = 0;\\n        int n = s.length();\\n        int start = 0, end = n;\\n\\n        while(start <= end) {\\n            int mid = (start + end) / 2;\\n            int currMinCost = getCurrMinCost(s, t, maxCost, mid);\\n\\n            if(currMinCost > maxCost) {\\n                end = mid - 1;\\n            }\\n            else {\\n                start = mid + 1;\\n                maxLen = mid;\\n            }\\n        }\\n        return maxLen;\\n    }\\n\\n    int getCurrMinCost(String s, String t, int maxCost, int winLen) {\\n        int minCost = 0;\\n        int n = s.length();\\n\\n        for(int i = 0; i < winLen; i++) {\\n            minCost += Math.abs((int)s.charAt(i) - (int)t.charAt(i));\\n        }\\n\\n        int currCost = minCost;\\n        for(int i = winLen; i < n; i++) {\\n            int leftCost = Math.abs((int)s.charAt(i - winLen) - (int)t.charAt(i - winLen));\\n            int rightCost = Math.abs((int)s.charAt(i) - (int)t.charAt(i));\\n\\n            currCost += rightCost;\\n            currCost -= leftCost;\\n\\n            minCost = Math.min(minCost, currCost);\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int maxLen = 0;\\n        int n = s.length();\\n        int start = 0, end = n;\\n\\n        while(start <= end) {\\n            int mid = (start + end) / 2;\\n            int currMinCost = getCurrMinCost(s, t, maxCost, mid);\\n\\n            if(currMinCost > maxCost) {\\n                end = mid - 1;\\n            }\\n            else {\\n                start = mid + 1;\\n                maxLen = mid;\\n            }\\n        }\\n        return maxLen;\\n    }\\n\\n    int getCurrMinCost(String s, String t, int maxCost, int winLen) {\\n        int minCost = 0;\\n        int n = s.length();\\n\\n        for(int i = 0; i < winLen; i++) {\\n            minCost += Math.abs((int)s.charAt(i) - (int)t.charAt(i));\\n        }\\n\\n        int currCost = minCost;\\n        for(int i = winLen; i < n; i++) {\\n            int leftCost = Math.abs((int)s.charAt(i - winLen) - (int)t.charAt(i - winLen));\\n            int rightCost = Math.abs((int)s.charAt(i) - (int)t.charAt(i));\\n\\n            currCost += rightCost;\\n            currCost -= leftCost;\\n\\n            minCost = Math.min(minCost, currCost);\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960245,
                "title": "c-simple-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int l = 0, sum = 0, ans = 0;\\n        for (int i = 0; i < s.size(); ++i){\\n            sum += abs(s[i] - t[i]);\\n            while (sum > maxCost)\\n                sum -= abs(s[l] - t[l++]);\\n            ans = max(ans, i - l + 1);\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int l = 0, sum = 0, ans = 0;\\n        for (int i = 0; i < s.size(); ++i){\\n            sum += abs(s[i] - t[i]);\\n            while (sum > maxCost)\\n                sum -= abs(s[l] - t[l++]);\\n            ans = max(ans, i - l + 1);\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938654,
                "title": "easy-to-understand-sliding-window-solution-in-python",
                "content": "# Intuition\\nWe can keep expanding the window while its cost is less or equal to the max cost. As soon as the window stops being valid, we shrink the window from the left.\\n\\n# Approach\\nUse two pointers left and right. Increment right and update current cost at every iteration, while increment the left pointer only if the current cost exceeds the budget (`maxCost`). \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n      l = 0\\n\\n      curr_cost = 0\\n      max_len = 0\\n\\n      for r, char in enumerate(s):\\n        curr_cost += abs(ord(s[r]) - ord(t[r]))\\n\\n        if curr_cost <= maxCost:\\n          max_len = max(max_len, r - l + 1)\\n        else:\\n          curr_cost -= abs(ord(s[l]) - ord(t[l]))\\n          l += 1\\n        \\n      return max_len\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n      l = 0\\n\\n      curr_cost = 0\\n      max_len = 0\\n\\n      for r, char in enumerate(s):\\n        curr_cost += abs(ord(s[r]) - ord(t[r]))\\n\\n        if curr_cost <= maxCost:\\n          max_len = max(max_len, r - l + 1)\\n        else:\\n          curr_cost -= abs(ord(s[l]) - ord(t[l]))\\n          l += 1\\n        \\n      return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935419,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int left = 0, curr = 0, ans = 0;\\n\\n        for (int right = 0; right < s.length(); right++){\\n            curr += Math.abs(s.charAt(right) - t.charAt(right));\\n\\n            while (curr > maxCost){\\n                curr -= Math.abs(s.charAt(left) - t.charAt(left));\\n                left++;\\n            }\\n\\n            ans = Math.max(ans, right-left+1);\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int left = 0, curr = 0, ans = 0;\\n\\n        for (int right = 0; right < s.length(); right++){\\n            curr += Math.abs(s.charAt(right) - t.charAt(right));\\n\\n            while (curr > maxCost){\\n                curr -= Math.abs(s.charAt(left) - t.charAt(left));\\n                left++;\\n            }\\n\\n            ans = Math.max(ans, right-left+1);\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932798,
                "title": "easy-java-solution-with-explanation-beats-74",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int equalSubstring(String s, String t, int maxCost) {\\n        \\n        int maxLength = 0;       \\n        // Initialize the maximum length of valid substring\\n        int start = 0;           \\n        // Pointer for the start of the sliding window\\n        int currentCost = 0;     \\n        // Current cost within the sliding window\\n\\n        for (int end = 0; end < s.length(); end++) {\\n\\n            currentCost += Math.abs(t.charAt(end) - s.charAt(end));\\n            \\n                  // Calculate cost for the current characters\\n            \\n            while (currentCost > maxCost) {\\n                currentCost -= Math.abs(t.charAt(start) - s.charAt(start));\\n                \\n                  // Adjust the cost by removing characters from the start\\n                start++; \\n                  // Slide the window by moving the start pointer\\n            }\\n\\n            maxLength = Math.max(maxLength, end - start + 1);  \\n                  // Update maxLength with the current valid substring length\\n        }\\n\\n        return maxLength; \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int equalSubstring(String s, String t, int maxCost) {\\n        \\n        int maxLength = 0;       \\n        // Initialize the maximum length of valid substring\\n        int start = 0;           \\n        // Pointer for the start of the sliding window\\n        int currentCost = 0;     \\n        // Current cost within the sliding window\\n\\n        for (int end = 0; end < s.length(); end++) {\\n\\n            currentCost += Math.abs(t.charAt(end) - s.charAt(end));\\n            \\n                  // Calculate cost for the current characters\\n            \\n            while (currentCost > maxCost) {\\n                currentCost -= Math.abs(t.charAt(start) - s.charAt(start));\\n                \\n                  // Adjust the cost by removing characters from the start\\n                start++; \\n                  // Slide the window by moving the start pointer\\n            }\\n\\n            maxLength = Math.max(maxLength, end - start + 1);  \\n                  // Update maxLength with the current valid substring length\\n        }\\n\\n        return maxLength; \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926264,
                "title": "simple-python-solution-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        \\n        ans = cost = left = 0\\n        \\n        for i in range(len(s)):\\n            cost += abs(ord(s[i]) - ord(t[i]))\\n            while cost > maxCost:\\n                cost -= abs(ord(s[left]) - ord(t[left]))\\n                left += 1\\n            \\n            ans = max(ans, i - left + 1)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        \\n        ans = cost = left = 0\\n        \\n        for i in range(len(s)):\\n            cost += abs(ord(s[i]) - ord(t[i]))\\n            while cost > maxCost:\\n                cost -= abs(ord(s[left]) - ord(t[left]))\\n                left += 1\\n            \\n            ans = max(ans, i - left + 1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923073,
                "title": "c-solution-with-t-c-o-n-and-s-c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.size(),i = 0,j = 0,mxLen = 0,cost = 0;\\n        while(j < n){\\n            cost += abs(s[j] - t[j]);\\n            if(cost <= maxCost){\\n                mxLen = max(mxLen,j-i+1);\\n                j++;\\n            }else{\\n                while(cost > maxCost){\\n                    cost -= abs(s[i] - t[i]);\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return mxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.size(),i = 0,j = 0,mxLen = 0,cost = 0;\\n        while(j < n){\\n            cost += abs(s[j] - t[j]);\\n            if(cost <= maxCost){\\n                mxLen = max(mxLen,j-i+1);\\n                j++;\\n            }else{\\n                while(cost > maxCost){\\n                    cost -= abs(s[i] - t[i]);\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return mxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918253,
                "title": "binary-search-sliding-window-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string s, string t, int maxCost, int mid) {\\n        int cnt = 0;\\n        int i = 0, j = 0;\\n        int window = 0;\\n        while (j < s.size()) {\\n            cnt += abs(s[j] - t[j]);\\n            while (cnt > maxCost) {\\n                cnt -= abs(s[i] - t[i]);\\n                i++;\\n            }\\n            window = max(window, j - i + 1);\\n            j++;\\n        }\\n        if (window >= mid) return true;\\n        return false;\\n    }\\n\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int l = 0;\\n        int h = s.size();\\n        int result = 0;\\n        while (l <= h) {\\n            int m = l + (h - l) / 2;\\n            if (check(s, t, maxCost, m)) {\\n                result = m;  // Update result instead of l\\n                l = m + 1;\\n            } else {\\n                h = m - 1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s, string t, int maxCost, int mid) {\\n        int cnt = 0;\\n        int i = 0, j = 0;\\n        int window = 0;\\n        while (j < s.size()) {\\n            cnt += abs(s[j] - t[j]);\\n            while (cnt > maxCost) {\\n                cnt -= abs(s[i] - t[i]);\\n                i++;\\n            }\\n            window = max(window, j - i + 1);\\n            j++;\\n        }\\n        if (window >= mid) return true;\\n        return false;\\n    }\\n\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int l = 0;\\n        int h = s.size();\\n        int result = 0;\\n        while (l <= h) {\\n            int m = l + (h - l) / 2;\\n            if (check(s, t, maxCost, m)) {\\n                result = m;  // Update result instead of l\\n                l = m + 1;\\n            } else {\\n                h = m - 1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913533,
                "title": "python3-clean-sliding-window-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        \\n        l=[abs(ord(a)-ord(b)) for a,b in zip(s,t)]\\n        \\n        left=ans=sm=0\\n        \\n        for right,val in enumerate(l):\\n            sm+=val\\n            \\n            while sm>maxCost:\\n                sm-=l[left]\\n                left+=1\\n            \\n            ans=max(ans,right-left+1)\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        \\n        l=[abs(ord(a)-ord(b)) for a,b in zip(s,t)]\\n        \\n        left=ans=sm=0\\n        \\n        for right,val in enumerate(l):\\n            sm+=val\\n            \\n            while sm>maxCost:\\n                sm-=l[left]\\n                left+=1\\n            \\n            ans=max(ans,right-left+1)\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912889,
                "title": "easy-solution-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n\\n       \\n        int n=s.size();\\n        int len=0,ans=0;\\n        int f=maxCost;\\n        for(int i=0;i<n;i++)\\n        {\\n            // cout<<i<<endl;\\n            int a=t[i];\\n            int b=s[i];\\n            int g=abs(a-b);\\n            if((maxCost-g)>=0)\\n            {\\n                len++;\\n                maxCost-=g;\\n            }\\n            else\\n            { \\n                ans=max(ans,len);\\n                \\n                while((maxCost-g)<0 && len>0)\\n                {\\n                    a=s[i-len];\\n                    b=t[i-len];\\n                    len--;\\n                    maxCost+=abs(a-b);\\n                }\\n               \\n                if((maxCost-g)>=0){\\n                len++;\\n                maxCost-=g;\\n                }\\n            }\\n        } \\n        ans=max(ans,len);\\n        return ans;\\n        \\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n\\n       \\n        int n=s.size();\\n        int len=0,ans=0;\\n        int f=maxCost;\\n        for(int i=0;i<n;i++)\\n        {\\n            // cout<<i<<endl;\\n            int a=t[i];\\n            int b=s[i];\\n            int g=abs(a-b);\\n            if((maxCost-g)>=0)\\n            {\\n                len++;\\n                maxCost-=g;\\n            }\\n            else\\n            { \\n                ans=max(ans,len);\\n                \\n                while((maxCost-g)<0 && len>0)\\n                {\\n                    a=s[i-len];\\n                    b=t[i-len];\\n                    len--;\\n                    maxCost+=abs(a-b);\\n                }\\n               \\n                if((maxCost-g)>=0){\\n                len++;\\n                maxCost-=g;\\n                }\\n            }\\n        } \\n        ans=max(ans,len);\\n        return ans;\\n        \\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3900598,
                "title": "solution-with-sliding-windows-easy-to-understand-intuitive-explanation-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem, we need to find the maximum length of a substring in string **s** that can be transformed into the corresponding substring in string **t** within a given maximum cost. We aim to *maximize the length of such a substring while keeping the total cost of transformations within the limit.* Since this problem requires finding the maximum substring and has a condition that involves sliding the substring as a window, it occurred to me to solve this problem with the slide windows pattern given the characteristics of the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.- Initialize variables: **maxLenght** to keep track of the maximum length, **totalCost** to track the current total cost of transformations, and **left** to represent the left boundary of the current substring.\\n\\n2.- Iterate through each character in both strings simultaneously using the **right** index.\\n* Calculate the cost of transforming the current character in **s** to the corresponding character in **t** using the absolute difference of their ASCII values.\\n* Add this cost to **totalCost**.\\n\\n3.- Check if the **totalCost** exceeds the **maxCost**.\\n* If so, enter a while loop and keep reducing the cost by subtracting the cost of the leftmost character transformation until the total cost becomes within the limit.\\n* Increment the **left** boundary to slide the window.\\n \\n4.- Update the **maxLenght** with the maximum length achieved so far (*right - left + 1*).\\n\\n5.- Return the **maxLenght** as the result.\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        maxLenght = 0\\n        totalCost = 0\\n        left = 0\\n         \\n        for right in range(len(s)):\\n            difference = abs(ord(s[right]) - ord(t[right]))\\n            totalCost += difference\\n\\n            while totalCost > maxCost: \\n                totalCost -= abs(ord(s[left]) - ord(t[left]))\\n                left += 1\\n            \\n            maxLenght = max(maxLenght, right - left + 1)\\n        \\n        return maxLenght\\n\\n                \\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        maxLenght = 0\\n        totalCost = 0\\n        left = 0\\n         \\n        for right in range(len(s)):\\n            difference = abs(ord(s[right]) - ord(t[right]))\\n            totalCost += difference\\n\\n            while totalCost > maxCost: \\n                totalCost -= abs(ord(s[left]) - ord(t[left]))\\n                left += 1\\n            \\n            maxLenght = max(maxLenght, right - left + 1)\\n        \\n        return maxLenght\\n\\n                \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894084,
                "title": "sliding-window-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding window\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPseudo code for sliding window\\n\\n```\\nint left=0;\\nint right=0;\\nint len=0;\\nfor(right=0;right<n;right++)\\n{\\n  operation;\\n\\n  while(condition fails)\\n  {\\n     .....\\n     left++;  // window size shrinking\\n  } \\n  \\n  len=max(len, right-left+1);\\n}\\n\\nreturn len;\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        \\n        int len=0;\\n        int cost=0;\\n        int left=0;\\n        int right=0;\\n\\n        for(right=0;right<s.length();right++)\\n        {\\n            cost+=abs(s[right]-t[right]);\\n\\n            while(cost>maxCost)\\n            {\\n                cost-=abs(s[left]-t[left]);\\n                left++;\\n            }\\n\\n            len=max(len,right-left+1);\\n        }\\n\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint left=0;\\nint right=0;\\nint len=0;\\nfor(right=0;right<n;right++)\\n{\\n  operation;\\n\\n  while(condition fails)\\n  {\\n     .....\\n     left++;  // window size shrinking\\n  } \\n  \\n  len=max(len, right-left+1);\\n}\\n\\nreturn len;\\n```\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        \\n        int len=0;\\n        int cost=0;\\n        int left=0;\\n        int right=0;\\n\\n        for(right=0;right<s.length();right++)\\n        {\\n            cost+=abs(s[right]-t[right]);\\n\\n            while(cost>maxCost)\\n            {\\n                cost-=abs(s[left]-t[left]);\\n                left++;\\n            }\\n\\n            len=max(len,right-left+1);\\n        }\\n\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886059,
                "title": "easy-approach",
                "content": "# Approach\\nSliding Window \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int ans = 0;\\n\\n        int lp = 0; // Left Pointer\\n        int rp = 0; // Right Pointer\\n        int cost = 0;\\n        for(; rp<s.length(); rp++) {\\n            cost += (Math.abs(s.charAt(rp) - t.charAt(rp)) );\\n\\n            while(cost > maxCost) {\\n                cost -= (Math.abs(s.charAt(lp) - t.charAt(lp)) );\\n                lp++;\\n            }\\n\\n            ans = Math.max(ans, rp-lp+1);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int ans = 0;\\n\\n        int lp = 0; // Left Pointer\\n        int rp = 0; // Right Pointer\\n        int cost = 0;\\n        for(; rp<s.length(); rp++) {\\n            cost += (Math.abs(s.charAt(rp) - t.charAt(rp)) );\\n\\n            while(cost > maxCost) {\\n                cost -= (Math.abs(s.charAt(lp) - t.charAt(lp)) );\\n                lp++;\\n            }\\n\\n            ans = Math.max(ans, rp-lp+1);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882325,
                "title": "c-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int len = 0, i = 0, j = 0, cost = 0;\\n\\n        for(j = 0; j < s.length(); j++) {\\n            cost += abs(s[j] - t[j]);\\n\\n            while(cost > maxCost) {\\n                cost -= abs(s[i] - t[i]);\\n                i++;\\n            }\\n\\n            len = max(len, j - i + 1);\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int len = 0, i = 0, j = 0, cost = 0;\\n\\n        for(j = 0; j < s.length(); j++) {\\n            cost += abs(s[j] - t[j]);\\n\\n            while(cost > maxCost) {\\n                cost -= abs(s[i] - t[i]);\\n                i++;\\n            }\\n\\n            len = max(len, j - i + 1);\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849237,
                "title": "c-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> psum;\\n    bool valid(int mid,int maxCost,int n)\\n    {\\n        if(psum[mid-1] <= maxCost)\\n            return true;\\n        for(int i=0;i+mid<n;i++)\\n        {\\n            if( (psum[i+mid]-psum[i]) <= maxCost )\\n                return true;\\n        }\\n        return false;\\n    }\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n=s.size();\\n        int low=1;\\n        int high=n+1;\\n\\n        psum.resize(n,0);\\n        psum[0]=abs(s[0]-t[0]);\\n        for(int i=1;i<n;i++)\\n            psum[i]=psum[i-1]+abs(s[i]-t[i]);\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(valid(mid,maxCost,n))\\n                low=mid+1;\\n            else\\n                high=mid;    \\n        }\\n\\n        if(low==0)\\n            return low;\\n        return low-1;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> psum;\\n    bool valid(int mid,int maxCost,int n)\\n    {\\n        if(psum[mid-1] <= maxCost)\\n            return true;\\n        for(int i=0;i+mid<n;i++)\\n        {\\n            if( (psum[i+mid]-psum[i]) <= maxCost )\\n                return true;\\n        }\\n        return false;\\n    }\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n=s.size();\\n        int low=1;\\n        int high=n+1;\\n\\n        psum.resize(n,0);\\n        psum[0]=abs(s[0]-t[0]);\\n        for(int i=1;i<n;i++)\\n            psum[i]=psum[i-1]+abs(s[i]-t[i]);\\n        while(low<high)\\n        {\\n            int mid=(low+high)/2;\\n            if(valid(mid,maxCost,n))\\n                low=mid+1;\\n            else\\n                high=mid;    \\n        }\\n\\n        if(low==0)\\n            return low;\\n        return low-1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841909,
                "title": "ez-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int r = 0 ,l = 0,ans = -1,n = s.length(),cost = 0 ;\\n        for(;r<n;r++){\\n            cost += abs(s[r]-t[r]);\\n\\n            while(cost>maxCost){\\n                cost -= abs(s[l]-t[l]);\\n                l++;\\n            }\\n\\n            ans = max(ans,r-l+1);\\n\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int r = 0 ,l = 0,ans = -1,n = s.length(),cost = 0 ;\\n        for(;r<n;r++){\\n            cost += abs(s[r]-t[r]);\\n\\n            while(cost>maxCost){\\n                cost -= abs(s[l]-t[l]);\\n                l++;\\n            }\\n\\n            ans = max(ans,r-l+1);\\n\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832564,
                "title": "easiest-solution-c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxcost) {\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        int n=s.size();\\n        int cost=0;\\n        while(j<n){\\n            int cost1=s[j]-\\'0\\';\\n            int cost2=t[j]-\\'0\\';\\n            cost+=abs(cost1-cost2);\\n            if(cost<=maxcost)\\n            {\\n                ans=max(ans,j-i+1);\\n                j++;\\n                continue;\\n            }\\n            if(cost>maxcost){\\n                while(cost>maxcost){\\n                    int cost1=s[i]-\\'0\\';\\n            int cost2=t[i]-\\'0\\';\\n                    cost-=abs(cost1-cost2);\\n                    i++;\\n                }\\n                ans=max(ans,j-i+1);\\n                j++;\\n            }\\n            \\n           \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxcost) {\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        int n=s.size();\\n        int cost=0;\\n        while(j<n){\\n            int cost1=s[j]-\\'0\\';\\n            int cost2=t[j]-\\'0\\';\\n            cost+=abs(cost1-cost2);\\n            if(cost<=maxcost)\\n            {\\n                ans=max(ans,j-i+1);\\n                j++;\\n                continue;\\n            }\\n            if(cost>maxcost){\\n                while(cost>maxcost){\\n                    int cost1=s[i]-\\'0\\';\\n            int cost2=t[i]-\\'0\\';\\n                    cost-=abs(cost1-cost2);\\n                    i++;\\n                }\\n                ans=max(ans,j-i+1);\\n                j++;\\n            }\\n            \\n           \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814713,
                "title": "sliding-window-easy-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int cnt=0;\\n        int n=s.size();\\n        int i=0,j=0;\\n        int maxi=0;\\n        while(j<n)\\n        {\\n            maxCost=maxCost-abs(s[j]-t[j]);\\n            if(maxCost>=0)\\n            maxi=max(maxi,j-i+1);\\n            while(maxCost<0)\\n            {\\n                maxCost+=abs(s[i]-t[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int cnt=0;\\n        int n=s.size();\\n        int i=0,j=0;\\n        int maxi=0;\\n        while(j<n)\\n        {\\n            maxCost=maxCost-abs(s[j]-t[j]);\\n            if(maxCost>=0)\\n            maxi=max(maxi,j-i+1);\\n            while(maxCost<0)\\n            {\\n                maxCost+=abs(s[i]-t[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814243,
                "title": "fastest-solution-in-php-no-functions-call-beats-100-runtime-and-memory",
                "content": "# Approach\\nSliding window algorithm. It beats 100% runtime and memory at the moment of posting (20 ms, 19.58 mb). No functions calls (except `strlen()` and `ord()`).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @param String $t\\n     * @param Integer $maxCost\\n     * @return Integer\\n     */\\n    function equalSubstring($s, $t, $maxCost) {\\n        $result = 0;\\n        for ($right = $left = $sum = 0, $len = strlen($s); $right < $len; $right++) {\\n            $diff = ord($s[$right]) - ord($t[$right]);\\n            $sum += ($diff < 0 ? -1*$diff : $diff);\\n\\n            while ($sum > $maxCost) {\\n                $diff = ord($s[$left]) - ord($t[$left]);\\n                $sum -= ($diff < 0 ? -1*$diff : $diff);\\n                $left++;\\n            }\\n\\n            if ($right - $left + 1 > $result) {\\n                $result = $right - $left + 1;\\n            }\\n        }\\n\\n        return $result;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @param String $t\\n     * @param Integer $maxCost\\n     * @return Integer\\n     */\\n    function equalSubstring($s, $t, $maxCost) {\\n        $result = 0;\\n        for ($right = $left = $sum = 0, $len = strlen($s); $right < $len; $right++) {\\n            $diff = ord($s[$right]) - ord($t[$right]);\\n            $sum += ($diff < 0 ? -1*$diff : $diff);\\n\\n            while ($sum > $maxCost) {\\n                $diff = ord($s[$left]) - ord($t[$left]);\\n                $sum -= ($diff < 0 ? -1*$diff : $diff);\\n                $left++;\\n            }\\n\\n            if ($right - $left + 1 > $result) {\\n                $result = $right - $left + 1;\\n            }\\n        }\\n\\n        return $result;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797477,
                "title": "cpp-sliding-window-variable-size",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.size();\\n        vector<int> cost(n,0);\\n        for(int i=0;i<n;i++) cost[i]=(int)abs(s[i]-t[i]);\\n        \\n        int i=0,j=0,ans=0,sum=0;\\n        while(j<n){\\n            sum+=cost[j];\\n            \\n            if(sum<=maxCost) ans=max(ans,j-i+1);\\n            while(sum>maxCost) sum-=cost[i++];\\n            \\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.size();\\n        vector<int> cost(n,0);\\n        for(int i=0;i<n;i++) cost[i]=(int)abs(s[i]-t[i]);\\n        \\n        int i=0,j=0,ans=0,sum=0;\\n        while(j<n){\\n            sum+=cost[j];\\n            \\n            if(sum<=maxCost) ans=max(ans,j-i+1);\\n            while(sum>maxCost) sum-=cost[i++];\\n            \\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795340,
                "title": "java-simple-solution-using-sliding-window",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int left = 0;\\n        int cost = 0;\\n        int length = 0;\\n        for (int right = 0; right < s.length(); right++){\\n            while(cost > maxCost && left <= right){\\n                cost -= Math.abs((int) t.charAt(left) - (int) s.charAt(left));\\n                left += 1;\\n            }\\n            cost += Math.abs((int) t.charAt(right) - (int) s.charAt(right));\\n            if(((right - left + 1) >= length) && (cost <= maxCost)){\\n                length = right - left + 1;\\n            }\\n        }\\n        return length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int left = 0;\\n        int cost = 0;\\n        int length = 0;\\n        for (int right = 0; right < s.length(); right++){\\n            while(cost > maxCost && left <= right){\\n                cost -= Math.abs((int) t.charAt(left) - (int) s.charAt(left));\\n                left += 1;\\n            }\\n            cost += Math.abs((int) t.charAt(right) - (int) s.charAt(right));\\n            if(((right - left + 1) >= length) && (cost <= maxCost)){\\n                length = right - left + 1;\\n            }\\n        }\\n        return length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795204,
                "title": "c-2-pointers",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.size();\\n        int cost = 0;\\n        int ans = 0;\\n        int j = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            cost += abs(s[i] - t[i]);\\n            if(cost <= maxCost)\\n            {\\n                ans = max(ans,i - j + 1);\\n            }\\n            else\\n            {\\n                while(cost > maxCost)\\n                {\\n                    cost -= abs(s[j] - t[j]);\\n                    j++;\\n                }\\n                ans = max(ans,i - j + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.size();\\n        int cost = 0;\\n        int ans = 0;\\n        int j = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            cost += abs(s[i] - t[i]);\\n            if(cost <= maxCost)\\n            {\\n                ans = max(ans,i - j + 1);\\n            }\\n            else\\n            {\\n                while(cost > maxCost)\\n                {\\n                    cost -= abs(s[j] - t[j]);\\n                    j++;\\n                }\\n                ans = max(ans,i - j + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783996,
                "title": "python-solution-using-sliding-window",
                "content": "# Code\\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        l = res = cost = 0\\n        n = len(s)\\n        arr = [0]*n\\n        for i in range(n):\\n            arr[i] = abs(ord(s[i]) - ord(t[i]))\\n        for r in range(n):\\n            cost += arr[r]\\n            while cost > maxCost:\\n                cost -= arr[l]\\n                l += 1\\n            res = max(res, r - l + 1)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        l = res = cost = 0\\n        n = len(s)\\n        arr = [0]*n\\n        for i in range(n):\\n            arr[i] = abs(ord(s[i]) - ord(t[i]))\\n        for r in range(n):\\n            cost += arr[r]\\n            while cost > maxCost:\\n                cost -= arr[l]\\n                l += 1\\n            res = max(res, r - l + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783772,
                "title": "easy-java-sliding-window-template-problem",
                "content": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int i = 0, j = 0, n = s.length(), sum = 0, ans = 0;\\n        while (j < n) {\\n            sum += Math.abs(s.charAt(j) - t.charAt(j));\\n            while (sum > maxCost) {\\n                sum -= Math.abs(s.charAt(i) - t.charAt(i));\\n                i++;\\n            }\\n            ans = Math.max(ans, j - i + 1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n        int i = 0, j = 0, n = s.length(), sum = 0, ans = 0;\\n        while (j < n) {\\n            sum += Math.abs(s.charAt(j) - t.charAt(j));\\n            while (sum > maxCost) {\\n                sum -= Math.abs(s.charAt(i) - t.charAt(i));\\n                i++;\\n            }\\n            ans = Math.max(ans, j - i + 1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783602,
                "title": "sliding-windows",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n  \\n    int left = 0;\\n    int right = 0;\\n    int cost = 0;\\n    int maxLength = 0;\\n\\n    while (right < s.length()) {\\n        int diff = Math.abs(s.charAt(right) - t.charAt(right));\\n        cost += diff;\\n\\n        while (cost > maxCost) {\\n            int diffLeft = Math.abs(s.charAt(left) - t.charAt(left));\\n            cost -= diffLeft;\\n            left++;\\n        }\\n\\n        int length = right - left + 1;\\n        maxLength = Math.max(maxLength, length);\\n        right++;\\n    }\\n\\n    return maxLength;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n  \\n    int left = 0;\\n    int right = 0;\\n    int cost = 0;\\n    int maxLength = 0;\\n\\n    while (right < s.length()) {\\n        int diff = Math.abs(s.charAt(right) - t.charAt(right));\\n        cost += diff;\\n\\n        while (cost > maxCost) {\\n            int diffLeft = Math.abs(s.charAt(left) - t.charAt(left));\\n            cost -= diffLeft;\\n            left++;\\n        }\\n\\n        int length = right - left + 1;\\n        maxLength = Math.max(maxLength, length);\\n        right++;\\n    }\\n\\n    return maxLength;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767527,
                "title": "easy-to-understand-optimal-solution-sliding-window-standard-templatesl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int head=0, tail=0;\\n        int cost=0; int ans=0;\\n        int n=s.size();\\n\\n        for( head=0; head<n; head++){\\n            cost+=abs(s[head]-t[head]);\\n            while(cost>maxCost){\\n                cost-=abs(s[tail] - t[tail]);\\n                tail++;\\n            }\\n            ans=max(ans, head-tail+1);\\n        }\\n        return max(ans, head-tail);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int head=0, tail=0;\\n        int cost=0; int ans=0;\\n        int n=s.size();\\n\\n        for( head=0; head<n; head++){\\n            cost+=abs(s[head]-t[head]);\\n            while(cost>maxCost){\\n                cost-=abs(s[tail] - t[tail]);\\n                tail++;\\n            }\\n            ans=max(ans, head-tail+1);\\n        }\\n        return max(ans, head-tail);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767404,
                "title": "simplest-solution-atmost-template-pattern-java-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n int cost=0;\\n int i=0;\\n //this is a kind of a template which is used when some kind of atmost constraint is given i.e we have to calulate thing when.....less than or equal to something\\n//  in this what we are require is just run a while loop until length and a nested one till constaint is not follwed in rest cases just add....\\n int max=Integer.MIN_VALUE;\\n int j=0;\\n while(j<s.length()){\\n     cost+=Math.abs(s.charAt(j)-t.charAt(j));\\n    while(cost>maxCost){\\n        cost-=Math.abs(s.charAt(i)-t.charAt(i));\\n    i++;\\n    }\\n    max=Math.max(max,j-i+1);\\n    j++;\\n }       \\n return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalSubstring(String s, String t, int maxCost) {\\n int cost=0;\\n int i=0;\\n //this is a kind of a template which is used when some kind of atmost constraint is given i.e we have to calulate thing when.....less than or equal to something\\n//  in this what we are require is just run a while loop until length and a nested one till constaint is not follwed in rest cases just add....\\n int max=Integer.MIN_VALUE;\\n int j=0;\\n while(j<s.length()){\\n     cost+=Math.abs(s.charAt(j)-t.charAt(j));\\n    while(cost>maxCost){\\n        cost-=Math.abs(s.charAt(i)-t.charAt(i));\\n    i++;\\n    }\\n    max=Math.max(max,j-i+1);\\n    j++;\\n }       \\n return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756298,
                "title": "sliding-window-c-beats-98-20",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int len;\\n        int maxi=0;\\n         int ind=0;\\n       int cost=0;\\n        for(int i=0;i<s.size();i++)\\n        { if(s[i]!=t[i])\\n            { cost+=abs(s[i]-t[i]);\\n\\n            }\\n            while(cost>maxCost)\\n            { cost-=abs(s[ind]-t[ind]);\\n              ind++;\\n            }\\n            len=i-ind+1;\\n          maxi=max(len,maxi);\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int len;\\n        int maxi=0;\\n         int ind=0;\\n       int cost=0;\\n        for(int i=0;i<s.size();i++)\\n        { if(s[i]!=t[i])\\n            { cost+=abs(s[i]-t[i]);\\n\\n            }\\n            while(cost>maxCost)\\n            { cost-=abs(s[ind]-t[ind]);\\n              ind++;\\n            }\\n            len=i-ind+1;\\n          maxi=max(len,maxi);\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752160,
                "title": "sliding-window-beginner-friendlyyyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) \\n    {\\n        unordered_map<int, int> m;\\n\\n        int i=0, j=0;\\n\\n        int curr_cost = 0;\\n\\n        int ans = 0;\\n\\n        while(j < s.size())\\n        {\\n            curr_cost += abs(s[j]-t[j]);\\n\\n            if(curr_cost <= maxCost)\\n            {\\n                ans = max(ans, j-i+1);\\n                j++;\\n            }\\n            else if(curr_cost > maxCost)\\n            {\\n                while(curr_cost > maxCost)\\n                {\\n                    curr_cost -= abs(s[i]-t[i]);\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) \\n    {\\n        unordered_map<int, int> m;\\n\\n        int i=0, j=0;\\n\\n        int curr_cost = 0;\\n\\n        int ans = 0;\\n\\n        while(j < s.size())\\n        {\\n            curr_cost += abs(s[j]-t[j]);\\n\\n            if(curr_cost <= maxCost)\\n            {\\n                ans = max(ans, j-i+1);\\n                j++;\\n            }\\n            else if(curr_cost > maxCost)\\n            {\\n                while(curr_cost > maxCost)\\n                {\\n                    curr_cost -= abs(s[i]-t[i]);\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749484,
                "title": "c-standard-sliding-window-problem-easy-code",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.size();\\n        //Initialize the required variable\\n        int we=0 , ws=0;\\n        int myCost = 0 , maxLen=0;\\n\\n        for(; we<n; we++){\\n            //Start calculating cost of making the string \\'s\\' & \\'t\\' equal to each other till our cost exceeds the maxCost.\\n            myCost += abs(s[we] - t[we]);\\n\\n            //now as soon as our window become invalid start updating the window by removing element fron start till the window become valid again.\\n            for(; myCost > maxCost; ws++){\\n                myCost -= abs(s[ws] - t[ws]);\\n            }\\n            //keep track of the length of the current window by (we-ws+1)\\n            maxLen = max(maxLen , (we-ws+1));\\n        }\\n        return maxLen;\\n\\n    }\\n};\\n```\\n\\n# Javascript Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} maxCost\\n * @return {number}\\n */\\nvar equalSubstring = function(s, t, maxCost) {\\n    var n = s.length;\\n  \\n    var we = 0, ws = 0;\\n    var myCost = 0, maxLen = 0;\\n  \\n    for (; we < n; we++) {\\n      myCost += Math.abs(s.charCodeAt(we) - t.charCodeAt(we));\\n  \\n      for (; myCost > maxCost; ws++) {\\n        myCost -= Math.abs(s.charCodeAt(ws) - t.charCodeAt(ws));\\n      }\\n      maxLen = Math.max(maxLen, (we - ws + 1));\\n    }\\n    return maxLen;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int n = s.size();\\n        //Initialize the required variable\\n        int we=0 , ws=0;\\n        int myCost = 0 , maxLen=0;\\n\\n        for(; we<n; we++){\\n            //Start calculating cost of making the string \\'s\\' & \\'t\\' equal to each other till our cost exceeds the maxCost.\\n            myCost += abs(s[we] - t[we]);\\n\\n            //now as soon as our window become invalid start updating the window by removing element fron start till the window become valid again.\\n            for(; myCost > maxCost; ws++){\\n                myCost -= abs(s[ws] - t[ws]);\\n            }\\n            //keep track of the length of the current window by (we-ws+1)\\n            maxLen = max(maxLen , (we-ws+1));\\n        }\\n        return maxLen;\\n\\n    }\\n};\\n```\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} maxCost\\n * @return {number}\\n */\\nvar equalSubstring = function(s, t, maxCost) {\\n    var n = s.length;\\n  \\n    var we = 0, ws = 0;\\n    var myCost = 0, maxLen = 0;\\n  \\n    for (; we < n; we++) {\\n      myCost += Math.abs(s.charCodeAt(we) - t.charCodeAt(we));\\n  \\n      for (; myCost > maxCost; ws++) {\\n        myCost -= Math.abs(s.charCodeAt(ws) - t.charCodeAt(ws));\\n      }\\n      maxLen = Math.max(maxLen, (we - ws + 1));\\n    }\\n    return maxLen;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734291,
                "title": "sliding-window",
                "content": "# Approach\\nExpanding a window from left to right, and start shrinking it from left once window cost exceeds maxCost \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\nvar equalSubstring = function(s, t, maxCost) {\\n    let runCost=0,maxLen=0;\\n    for(let i=0,j=0;j<s.length;j++){\\n        // accumulating window cost\\n        runCost+=Math.abs(s[j].charCodeAt(0)-t[j].charCodeAt(0));\\n        \\n        // shrinking the window from left as window cost exceeds maxCost\\n        while(runCost>maxCost){ \\n            runCost-=Math.abs(s[i].charCodeAt(0)-t[i].charCodeAt(0));\\n            i++;\\n        }\\n        maxLen=Math.max(maxLen,j-i+1); // we confident that at this point we do not exceed maxCost \\n    }\\n    return maxLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\nvar equalSubstring = function(s, t, maxCost) {\\n    let runCost=0,maxLen=0;\\n    for(let i=0,j=0;j<s.length;j++){\\n        // accumulating window cost\\n        runCost+=Math.abs(s[j].charCodeAt(0)-t[j].charCodeAt(0));\\n        \\n        // shrinking the window from left as window cost exceeds maxCost\\n        while(runCost>maxCost){ \\n            runCost-=Math.abs(s[i].charCodeAt(0)-t[i].charCodeAt(0));\\n            i++;\\n        }\\n        maxLen=Math.max(maxLen,j-i+1); // we confident that at this point we do not exceed maxCost \\n    }\\n    return maxLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731042,
                "title": "optimal-sliding-window-o-n-time-o-1-space",
                "content": "# Intuition\\nWe want to expand substring as long as max cost is greater or equal zero. If max cost is below zero, we start shrinking substring until max cost greater or equal 0. After this, we continue expand substring again.\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        length = 0\\n        l = 0\\n        for r in range(len(s)):\\n            maxCost -= abs(ord(s[r]) - ord(t[r]))\\n            while maxCost < 0:\\n                maxCost += abs(ord(s[l]) - ord(t[l]))\\n                l += 1\\n            length = max(length, r - l + 1)\\n\\n        return length\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        length = 0\\n        l = 0\\n        for r in range(len(s)):\\n            maxCost -= abs(ord(s[r]) - ord(t[r]))\\n            while maxCost < 0:\\n                maxCost += abs(ord(s[l]) - ord(t[l]))\\n                l += 1\\n            length = max(length, r - l + 1)\\n\\n        return length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704957,
                "title": "c-faster-than-90-5-lines-only-easy-understanding-clean-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int m) {\\n\\n       int i = 0, j = 0, maxi = 0, sum = 0;\\n       while(j < s.size())\\n       {\\n         sum += abs(t[j] - s[j]);\\n         while(sum > m){ sum -= abs(t[i] - s[i]); i++;}\\n         maxi = max(maxi,j-i+1); j++;\\n       }\\n       return maxi;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int m) {\\n\\n       int i = 0, j = 0, maxi = 0, sum = 0;\\n       while(j < s.size())\\n       {\\n         sum += abs(t[j] - s[j]);\\n         while(sum > m){ sum -= abs(t[i] - s[i]); i++;}\\n         maxi = max(maxi,j-i+1); j++;\\n       }\\n       return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701443,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int i = 0 ;\\n        int j = 0 ;\\n        int cost = 0;\\n        int count = 0;\\n        for(int i = 0 ; i<s.size() ; i++)\\n        {\\n            cost += abs(s[i] - t[i]);\\n            if(j<=i && cost > maxCost){\\n                cost -= abs(s[j]-t[j]);\\n                j++;\\n            }\\n                count = max(count,i-j+1);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalSubstring(string s, string t, int maxCost) {\\n        int i = 0 ;\\n        int j = 0 ;\\n        int cost = 0;\\n        int count = 0;\\n        for(int i = 0 ; i<s.size() ; i++)\\n        {\\n            cost += abs(s[i] - t[i]);\\n            if(j<=i && cost > maxCost){\\n                cost -= abs(s[j]-t[j]);\\n                j++;\\n            }\\n                count = max(count,i-j+1);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697424,
                "title": "easy-to-follow",
                "content": "\\n# Approach\\nI divided to 2 smaller problems to make the code more accessable\\n- The former is to get the array of cost by each index replacement\\n- The second is to find the longest slice of the costByIndex array that have sum less than or equal max cost by using slide window \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        costOfIndex = []\\n        for i in range(len(s)): \\n            costOfIndex.append(abs(ord(s[i])- ord(t[i])))\\n        \\n        i,j, max_length = 0,0,0 \\n        current_cost = 0\\n\\n        for j in range(len(costOfIndex)):\\n            current_cost = current_cost + costOfIndex[j]\\n            if current_cost <= maxCost:\\n                max_length = max(max_length, j - i + 1)\\n            else:\\n                while current_cost > maxCost and i <= j:\\n                    current_cost = current_cost - costOfIndex[i]\\n                    i = i + 1\\n        \\n        return max_length\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\\n        costOfIndex = []\\n        for i in range(len(s)): \\n            costOfIndex.append(abs(ord(s[i])- ord(t[i])))\\n        \\n        i,j, max_length = 0,0,0 \\n        current_cost = 0\\n\\n        for j in range(len(costOfIndex)):\\n            current_cost = current_cost + costOfIndex[j]\\n            if current_cost <= maxCost:\\n                max_length = max(max_length, j - i + 1)\\n            else:\\n                while current_cost > maxCost and i <= j:\\n                    current_cost = current_cost - costOfIndex[i]\\n                    i = i + 1\\n        \\n        return max_length\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680821,
                "title": "kotlin-sliding-window-with-explanation",
                "content": "# Intuition\\nThe classical problem of the sliding window algorithm.\\n\\n# Approach\\nCreate the following variables:\\n\\n - Indices of the `left` and `right` of the substring being considered at every step.\\n\\n- The cost of the current substring `currentCost`.\\n\\n- The maximum length of a substring that satisfies the required condition `result`.\\n\\nThen iterate through the string `s` and at each step add the cost of the next character to `currentCost`.\\n\\nIf `currentCost` exceeds `maxCost`, then start shifting the `left` boundary of the window (inner `while` loop). At each step, subtract the cost of a character that is no longer part of the considered substring.\\n\\nAfter completing the inner loop, update the `result` with the maximum value between the length of the current window state `right - left + 1` and the previous value of `result`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun equalSubstring(s: String, t: String, maxCost: Int): Int {\\n        var left = 0\\n        var right = 0\\n        var currentCost = 0\\n        var result = 0\\n\\n        while (right <= s.lastIndex) {\\n            currentCost += Math.abs(s[right] - t[right])\\n            while (currentCost > maxCost) {\\n                currentCost -= Math.abs(s[left] - t[left])\\n                left++\\n            }\\n            result = Math.max(right - left + 1, result)\\n            right++\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun equalSubstring(s: String, t: String, maxCost: Int): Int {\\n        var left = 0\\n        var right = 0\\n        var currentCost = 0\\n        var result = 0\\n\\n        while (right <= s.lastIndex) {\\n            currentCost += Math.abs(s[right] - t[right])\\n            while (currentCost > maxCost) {\\n                currentCost -= Math.abs(s[left] - t[left])\\n                left++\\n            }\\n            result = Math.max(right - left + 1, result)\\n            right++\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677648,
                "title": "swift-sliding-window-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    func equalSubstring(_ s: String, _ t: String, _ maxCost: Int) -> Int {\\n        let s = s.compactMap(\\\\.asciiValue).map(Int32.init)\\n        let t = t.compactMap(\\\\.asciiValue).map(Int32.init)\\n        \\n        var ans = 0, left = 0, costSum = Int32(0)\\n        \\n        for right in s.indices {\\n            costSum += abs(s[right] - t[right])\\n            \\n            while costSum > maxCost {\\n                costSum -= abs(s[left] - t[left])\\n                left += 1\\n            }\\n            \\n            ans = max(ans, (right - left) + 1)\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    func equalSubstring(_ s: String, _ t: String, _ maxCost: Int) -> Int {\\n        let s = s.compactMap(\\\\.asciiValue).map(Int32.init)\\n        let t = t.compactMap(\\\\.asciiValue).map(Int32.init)\\n        \\n        var ans = 0, left = 0, costSum = Int32(0)\\n        \\n        for right in s.indices {\\n            costSum += abs(s[right] - t[right])\\n            \\n            while costSum > maxCost {\\n                costSum -= abs(s[left] - t[left])\\n                left += 1\\n            }\\n            \\n            ans = max(ans, (right - left) + 1)\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668923,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} maxCost\\n * @return {number}\\n */\\nvar equalSubstring = function(s, t, maxCost) {\\n    \\n\\n    var calculateDifference = function(c1, c2) {\\n        return Math.abs(c1.charCodeAt() - c2.charCodeAt());\\n    }\\n\\n\\n    let left = 0; max = -Infinity, count = 0;\\n\\n\\n    for(let right = 0; right < s.length; right++) {\\n        count += calculateDifference(s[right], t[right]);\\n\\n        while(count > maxCost) {\\n            count -= calculateDifference(s[left], t[left]);\\n            left++;\\n        }\\n\\n        max = Math.max(max, right - left + 1);\\n    }\\n\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} maxCost\\n * @return {number}\\n */\\nvar equalSubstring = function(s, t, maxCost) {\\n    \\n\\n    var calculateDifference = function(c1, c2) {\\n        return Math.abs(c1.charCodeAt() - c2.charCodeAt());\\n    }\\n\\n\\n    let left = 0; max = -Infinity, count = 0;\\n\\n\\n    for(let right = 0; right < s.length; right++) {\\n        count += calculateDifference(s[right], t[right]);\\n\\n        while(count > maxCost) {\\n            count -= calculateDifference(s[left], t[left]);\\n            left++;\\n        }\\n\\n        max = Math.max(max, right - left + 1);\\n    }\\n\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3663971,
                "title": "java-solution-using-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculate the changing string cost and based on that apply sliding window algorithm\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Check for change cost of strings by incrementing right pointer in the for loop.\\n2.if changecost is invalid, increment left pointer until it is valid.\\n3.calculate the maxlength of substring using (right-left+1) and return maxlength.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\n   public int equalSubstring(String s, String t, int maxCost) {\\n        int maxlength=0;\\n        int left=0;\\n        int changecost=0;\\n        for(int right=0;right<s.length();right++){\\n            changecost+=Math.abs(t.charAt(right)-s.charAt(right));\\n            while(changecost>maxCost){\\n                changecost-=Math.abs(t.charAt(left)-s.charAt(left));\\n            left++;}\\n            maxlength=Math.max(maxlength,right-left+1);\\n        }\\n        return maxlength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n   public int equalSubstring(String s, String t, int maxCost) {\\n        int maxlength=0;\\n        int left=0;\\n        int changecost=0;\\n        for(int right=0;right<s.length();right++){\\n            changecost+=Math.abs(t.charAt(right)-s.charAt(right));\\n            while(changecost>maxCost){\\n                changecost-=Math.abs(t.charAt(left)-s.charAt(left));\\n            left++;}\\n            maxlength=Math.max(maxlength,right-left+1);\\n        }\\n        return maxlength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653898,
                "title": "c-100-faster-sliding-window",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int equalSubstring(string s, string t, int maxCost) {\\n    int left = 0, curr = 0, ans = 0;\\n\\n    for(int right = 0; right < s.size(); right++) {\\n      curr += abs(static_cast<int>(s[right]) - static_cast<int>(t[right]));\\n\\n      while (curr > maxCost) {\\n        curr -= abs(static_cast<int>(s[left]) - static_cast<int>(t[left]));\\n        left++;\\n      }\\n\\n      ans = max(ans, right - left + 1);\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int equalSubstring(string s, string t, int maxCost) {\\n    int left = 0, curr = 0, ans = 0;\\n\\n    for(int right = 0; right < s.size(); right++) {\\n      curr += abs(static_cast<int>(s[right]) - static_cast<int>(t[right]));\\n\\n      while (curr > maxCost) {\\n        curr -= abs(static_cast<int>(s[left]) - static_cast<int>(t[left]));\\n        left++;\\n      }\\n\\n      ans = max(ans, right - left + 1);\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1909314,
                "content": [
                    {
                        "username": "treat",
                        "content": "The direction of shift can be in either direction or has to be circular. Its not clear from the question"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "can anyone explain me this testcase\\nInput\\ns =\\n\"krrgw\"\\nt =\\n\"zjxss\"\\nmaxCost =\\n19\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "corgoButt",
                        "content": "I am also getting this. k -> z = 15. r -> j = 8. So 15 + 8 == 23 > 19. Idk I could also be doing something wrong"
                    },
                    {
                        "username": "KedarDevs007",
                        "content": "Busted by brains on this one but its easier than i thought\\njust need to know when to update the left pointer and for how long"
                    },
                    {
                        "username": "ivzap",
                        "content": "Suppose you had a substring and the cost of such substring was greater than maxCost. How would you make that substring \"legal\"? Now think more generally, this should give you a hint to the solution."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Keep in mind that the strings don\\'t move relative to each other, this makes the problem way easier!"
                    },
                    {
                        "username": "yvaibhav29",
                        "content": "class Solution {\\npublic:\\n\\nint atMostSum(vector<int>arr, int n, int k)\\n{\\n    int sum = 0;\\n    int cnt = 0, maxcnt = 0;\\n \\n    for (int i = 0; i < n; i++) {\\n         \\n        // If adding current element doesn\\'t\\n        // cross limit add it to current window\\n        if ((sum + arr[i]) <= k) {\\n            sum += arr[i];\\n            cnt++;\\n        }\\n \\n        // Else, remove first element of current\\n        // window and add the current element\\n        else if(sum!=0)\\n        {\\n            sum = sum - arr[i - cnt] + arr[i];\\n        }\\n \\n        // keep track of max length.\\n        maxcnt = max(cnt, maxcnt);\\n    }\\n    return maxcnt;\\n}\\n\\n    int equalSubstring(string s, string t, int maxCost) {\\n        vector<int>ans;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=(int)s[i];\\n            int y=(int)t[i];\\n            ans.push_back(abs(x-y));\\n        }\\n        int res=atMostSum(ans,n,maxCost);\\n        if(res==INT_MIN)\\n        return 0;\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "y54su",
                        "content": "please move these code to solution."
                    },
                    {
                        "username": "pvlbzn",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "Bhargav_Thota",
                        "content": "Kindly move this code to solutions tab since discussions tab is used for doubts, hints etc. "
                    }
                ]
            },
            {
                "id": 2062953,
                "content": [
                    {
                        "username": "treat",
                        "content": "The direction of shift can be in either direction or has to be circular. Its not clear from the question"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "can anyone explain me this testcase\\nInput\\ns =\\n\"krrgw\"\\nt =\\n\"zjxss\"\\nmaxCost =\\n19\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "corgoButt",
                        "content": "I am also getting this. k -> z = 15. r -> j = 8. So 15 + 8 == 23 > 19. Idk I could also be doing something wrong"
                    },
                    {
                        "username": "KedarDevs007",
                        "content": "Busted by brains on this one but its easier than i thought\\njust need to know when to update the left pointer and for how long"
                    },
                    {
                        "username": "ivzap",
                        "content": "Suppose you had a substring and the cost of such substring was greater than maxCost. How would you make that substring \"legal\"? Now think more generally, this should give you a hint to the solution."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Keep in mind that the strings don\\'t move relative to each other, this makes the problem way easier!"
                    },
                    {
                        "username": "yvaibhav29",
                        "content": "class Solution {\\npublic:\\n\\nint atMostSum(vector<int>arr, int n, int k)\\n{\\n    int sum = 0;\\n    int cnt = 0, maxcnt = 0;\\n \\n    for (int i = 0; i < n; i++) {\\n         \\n        // If adding current element doesn\\'t\\n        // cross limit add it to current window\\n        if ((sum + arr[i]) <= k) {\\n            sum += arr[i];\\n            cnt++;\\n        }\\n \\n        // Else, remove first element of current\\n        // window and add the current element\\n        else if(sum!=0)\\n        {\\n            sum = sum - arr[i - cnt] + arr[i];\\n        }\\n \\n        // keep track of max length.\\n        maxcnt = max(cnt, maxcnt);\\n    }\\n    return maxcnt;\\n}\\n\\n    int equalSubstring(string s, string t, int maxCost) {\\n        vector<int>ans;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=(int)s[i];\\n            int y=(int)t[i];\\n            ans.push_back(abs(x-y));\\n        }\\n        int res=atMostSum(ans,n,maxCost);\\n        if(res==INT_MIN)\\n        return 0;\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "y54su",
                        "content": "please move these code to solution."
                    },
                    {
                        "username": "pvlbzn",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "Bhargav_Thota",
                        "content": "Kindly move this code to solutions tab since discussions tab is used for doubts, hints etc. "
                    }
                ]
            },
            {
                "id": 2065305,
                "content": [
                    {
                        "username": "treat",
                        "content": "The direction of shift can be in either direction or has to be circular. Its not clear from the question"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "can anyone explain me this testcase\\nInput\\ns =\\n\"krrgw\"\\nt =\\n\"zjxss\"\\nmaxCost =\\n19\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "corgoButt",
                        "content": "I am also getting this. k -> z = 15. r -> j = 8. So 15 + 8 == 23 > 19. Idk I could also be doing something wrong"
                    },
                    {
                        "username": "KedarDevs007",
                        "content": "Busted by brains on this one but its easier than i thought\\njust need to know when to update the left pointer and for how long"
                    },
                    {
                        "username": "ivzap",
                        "content": "Suppose you had a substring and the cost of such substring was greater than maxCost. How would you make that substring \"legal\"? Now think more generally, this should give you a hint to the solution."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Keep in mind that the strings don\\'t move relative to each other, this makes the problem way easier!"
                    },
                    {
                        "username": "yvaibhav29",
                        "content": "class Solution {\\npublic:\\n\\nint atMostSum(vector<int>arr, int n, int k)\\n{\\n    int sum = 0;\\n    int cnt = 0, maxcnt = 0;\\n \\n    for (int i = 0; i < n; i++) {\\n         \\n        // If adding current element doesn\\'t\\n        // cross limit add it to current window\\n        if ((sum + arr[i]) <= k) {\\n            sum += arr[i];\\n            cnt++;\\n        }\\n \\n        // Else, remove first element of current\\n        // window and add the current element\\n        else if(sum!=0)\\n        {\\n            sum = sum - arr[i - cnt] + arr[i];\\n        }\\n \\n        // keep track of max length.\\n        maxcnt = max(cnt, maxcnt);\\n    }\\n    return maxcnt;\\n}\\n\\n    int equalSubstring(string s, string t, int maxCost) {\\n        vector<int>ans;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=(int)s[i];\\n            int y=(int)t[i];\\n            ans.push_back(abs(x-y));\\n        }\\n        int res=atMostSum(ans,n,maxCost);\\n        if(res==INT_MIN)\\n        return 0;\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "y54su",
                        "content": "please move these code to solution."
                    },
                    {
                        "username": "pvlbzn",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "Bhargav_Thota",
                        "content": "Kindly move this code to solutions tab since discussions tab is used for doubts, hints etc. "
                    }
                ]
            },
            {
                "id": 2023014,
                "content": [
                    {
                        "username": "treat",
                        "content": "The direction of shift can be in either direction or has to be circular. Its not clear from the question"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "can anyone explain me this testcase\\nInput\\ns =\\n\"krrgw\"\\nt =\\n\"zjxss\"\\nmaxCost =\\n19\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "corgoButt",
                        "content": "I am also getting this. k -> z = 15. r -> j = 8. So 15 + 8 == 23 > 19. Idk I could also be doing something wrong"
                    },
                    {
                        "username": "KedarDevs007",
                        "content": "Busted by brains on this one but its easier than i thought\\njust need to know when to update the left pointer and for how long"
                    },
                    {
                        "username": "ivzap",
                        "content": "Suppose you had a substring and the cost of such substring was greater than maxCost. How would you make that substring \"legal\"? Now think more generally, this should give you a hint to the solution."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Keep in mind that the strings don\\'t move relative to each other, this makes the problem way easier!"
                    },
                    {
                        "username": "yvaibhav29",
                        "content": "class Solution {\\npublic:\\n\\nint atMostSum(vector<int>arr, int n, int k)\\n{\\n    int sum = 0;\\n    int cnt = 0, maxcnt = 0;\\n \\n    for (int i = 0; i < n; i++) {\\n         \\n        // If adding current element doesn\\'t\\n        // cross limit add it to current window\\n        if ((sum + arr[i]) <= k) {\\n            sum += arr[i];\\n            cnt++;\\n        }\\n \\n        // Else, remove first element of current\\n        // window and add the current element\\n        else if(sum!=0)\\n        {\\n            sum = sum - arr[i - cnt] + arr[i];\\n        }\\n \\n        // keep track of max length.\\n        maxcnt = max(cnt, maxcnt);\\n    }\\n    return maxcnt;\\n}\\n\\n    int equalSubstring(string s, string t, int maxCost) {\\n        vector<int>ans;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=(int)s[i];\\n            int y=(int)t[i];\\n            ans.push_back(abs(x-y));\\n        }\\n        int res=atMostSum(ans,n,maxCost);\\n        if(res==INT_MIN)\\n        return 0;\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "y54su",
                        "content": "please move these code to solution."
                    },
                    {
                        "username": "pvlbzn",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "Bhargav_Thota",
                        "content": "Kindly move this code to solutions tab since discussions tab is used for doubts, hints etc. "
                    }
                ]
            },
            {
                "id": 1875503,
                "content": [
                    {
                        "username": "treat",
                        "content": "The direction of shift can be in either direction or has to be circular. Its not clear from the question"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "can anyone explain me this testcase\\nInput\\ns =\\n\"krrgw\"\\nt =\\n\"zjxss\"\\nmaxCost =\\n19\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "corgoButt",
                        "content": "I am also getting this. k -> z = 15. r -> j = 8. So 15 + 8 == 23 > 19. Idk I could also be doing something wrong"
                    },
                    {
                        "username": "KedarDevs007",
                        "content": "Busted by brains on this one but its easier than i thought\\njust need to know when to update the left pointer and for how long"
                    },
                    {
                        "username": "ivzap",
                        "content": "Suppose you had a substring and the cost of such substring was greater than maxCost. How would you make that substring \"legal\"? Now think more generally, this should give you a hint to the solution."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Keep in mind that the strings don\\'t move relative to each other, this makes the problem way easier!"
                    },
                    {
                        "username": "yvaibhav29",
                        "content": "class Solution {\\npublic:\\n\\nint atMostSum(vector<int>arr, int n, int k)\\n{\\n    int sum = 0;\\n    int cnt = 0, maxcnt = 0;\\n \\n    for (int i = 0; i < n; i++) {\\n         \\n        // If adding current element doesn\\'t\\n        // cross limit add it to current window\\n        if ((sum + arr[i]) <= k) {\\n            sum += arr[i];\\n            cnt++;\\n        }\\n \\n        // Else, remove first element of current\\n        // window and add the current element\\n        else if(sum!=0)\\n        {\\n            sum = sum - arr[i - cnt] + arr[i];\\n        }\\n \\n        // keep track of max length.\\n        maxcnt = max(cnt, maxcnt);\\n    }\\n    return maxcnt;\\n}\\n\\n    int equalSubstring(string s, string t, int maxCost) {\\n        vector<int>ans;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=(int)s[i];\\n            int y=(int)t[i];\\n            ans.push_back(abs(x-y));\\n        }\\n        int res=atMostSum(ans,n,maxCost);\\n        if(res==INT_MIN)\\n        return 0;\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "y54su",
                        "content": "please move these code to solution."
                    },
                    {
                        "username": "pvlbzn",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "Bhargav_Thota",
                        "content": "Kindly move this code to solutions tab since discussions tab is used for doubts, hints etc. "
                    }
                ]
            },
            {
                "id": 1643544,
                "content": [
                    {
                        "username": "treat",
                        "content": "The direction of shift can be in either direction or has to be circular. Its not clear from the question"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "can anyone explain me this testcase\\nInput\\ns =\\n\"krrgw\"\\nt =\\n\"zjxss\"\\nmaxCost =\\n19\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "corgoButt",
                        "content": "I am also getting this. k -> z = 15. r -> j = 8. So 15 + 8 == 23 > 19. Idk I could also be doing something wrong"
                    },
                    {
                        "username": "KedarDevs007",
                        "content": "Busted by brains on this one but its easier than i thought\\njust need to know when to update the left pointer and for how long"
                    },
                    {
                        "username": "ivzap",
                        "content": "Suppose you had a substring and the cost of such substring was greater than maxCost. How would you make that substring \"legal\"? Now think more generally, this should give you a hint to the solution."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Keep in mind that the strings don\\'t move relative to each other, this makes the problem way easier!"
                    },
                    {
                        "username": "yvaibhav29",
                        "content": "class Solution {\\npublic:\\n\\nint atMostSum(vector<int>arr, int n, int k)\\n{\\n    int sum = 0;\\n    int cnt = 0, maxcnt = 0;\\n \\n    for (int i = 0; i < n; i++) {\\n         \\n        // If adding current element doesn\\'t\\n        // cross limit add it to current window\\n        if ((sum + arr[i]) <= k) {\\n            sum += arr[i];\\n            cnt++;\\n        }\\n \\n        // Else, remove first element of current\\n        // window and add the current element\\n        else if(sum!=0)\\n        {\\n            sum = sum - arr[i - cnt] + arr[i];\\n        }\\n \\n        // keep track of max length.\\n        maxcnt = max(cnt, maxcnt);\\n    }\\n    return maxcnt;\\n}\\n\\n    int equalSubstring(string s, string t, int maxCost) {\\n        vector<int>ans;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=(int)s[i];\\n            int y=(int)t[i];\\n            ans.push_back(abs(x-y));\\n        }\\n        int res=atMostSum(ans,n,maxCost);\\n        if(res==INT_MIN)\\n        return 0;\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "y54su",
                        "content": "please move these code to solution."
                    },
                    {
                        "username": "pvlbzn",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "Bhargav_Thota",
                        "content": "Kindly move this code to solutions tab since discussions tab is used for doubts, hints etc. "
                    }
                ]
            }
        ]
    }
]