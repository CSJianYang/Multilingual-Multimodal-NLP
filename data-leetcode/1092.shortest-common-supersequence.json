[
    {
        "title": "Shortest Common Supersequence ",
        "question_content": "Given two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences. If there are multiple valid strings, return any of them.\nA string s is a subsequence of string t if deleting some number of characters from t (possibly 0) results in the string s.\n&nbsp;\nExample 1:\n\nInput: str1 = \"abac\", str2 = \"cab\"\nOutput: \"cabac\"\nExplanation: \nstr1 = \"abac\" is a subsequence of \"cabac\" because we can delete the first \"c\".\nstr2 = \"cab\" is a subsequence of \"cabac\" because we can delete the last \"ac\".\nThe answer provided is the shortest such string that satisfies these properties.\n\nExample 2:\n\nInput: str1 = \"aaaaaaaa\", str2 = \"aaaaaaaa\"\nOutput: \"aaaaaaaa\"\n\n&nbsp;\nConstraints:\n\n\t1 <= str1.length, str2.length <= 1000\n\tstr1 and str2 consist of lowercase English letters.",
        "solutions": [
            {
                "id": 312710,
                "title": "c-python-find-the-lcs",
                "content": "## **Intuition**\\nChange the problem to find the LCS\\n<br>\\n\\n## **Complexity**\\nTIme O(MN) dp, \\nSpace O(MN) * O(string), but actually we can also save the storage of string.\\n<br>\\n\\n**C++:**\\n```\\n    string shortestCommonSupersequence(string& A, string& B) {\\n        int i = 0, j = 0;\\n        string res = \"\";\\n        for (char c : lcs(A, B)) {\\n            while (A[i] != c)\\n                res += A[i++];\\n            while (B[j] != c)\\n                res += B[j++];\\n            res += c, i++, j++;\\n        }\\n        return res + A.substr(i) + B.substr(j);\\n    }\\n\\n    string lcs(string& A, string& B) {\\n        int n = A.size(), m = B.size();\\n        vector<vector<string>> dp(n + 1, vector<string>(m + 1, \"\"));\\n        for (int i = 0; i < n; ++i)\\n            for (int j = 0; j < m; ++j)\\n                if (A[i] == B[j])\\n                    dp[i + 1][j + 1] = dp[i][j] + A[i];\\n                else\\n                    dp[i + 1][j + 1] = dp[i + 1][j].size() > dp[i][j + 1].size() ?  dp[i + 1][j] : dp[i][j + 1];\\n        return dp[n][m];\\n    }\\n```\\n\\n**Python:**\\n```\\n    def shortestCommonSupersequence(self, A, B):\\n        def lcs(A, B):\\n            n, m = len(A), len(B)\\n            dp = [[\"\" for _ in xrange(m + 1)] for _ in range(n + 1)]\\n            for i in range(n):\\n                for j in range(m):\\n                    if A[i] == B[j]:\\n                        dp[i + 1][j + 1] = dp[i][j] + A[i]\\n                    else:\\n                        dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1], key=len)\\n            return dp[-1][-1]\\n\\n        res, i, j = \"\", 0, 0\\n        for c in lcs(A, B):\\n            while A[i] != c:\\n                res += A[i]\\n                i += 1\\n            while B[j] != c:\\n                res += B[j]\\n                j += 1\\n            res += c\\n            i, j = i + 1, j + 1\\n        return res + A[i:] + B[j:]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    string shortestCommonSupersequence(string& A, string& B) {\\n        int i = 0, j = 0;\\n        string res = \"\";\\n        for (char c : lcs(A, B)) {\\n            while (A[i] != c)\\n                res += A[i++];\\n            while (B[j] != c)\\n                res += B[j++];\\n            res += c, i++, j++;\\n        }\\n        return res + A.substr(i) + B.substr(j);\\n    }\\n\\n    string lcs(string& A, string& B) {\\n        int n = A.size(), m = B.size();\\n        vector<vector<string>> dp(n + 1, vector<string>(m + 1, \"\"));\\n        for (int i = 0; i < n; ++i)\\n            for (int j = 0; j < m; ++j)\\n                if (A[i] == B[j])\\n                    dp[i + 1][j + 1] = dp[i][j] + A[i];\\n                else\\n                    dp[i + 1][j + 1] = dp[i + 1][j].size() > dp[i][j + 1].size() ?  dp[i + 1][j] : dp[i][j + 1];\\n        return dp[n][m];\\n    }\\n```\n```\\n    def shortestCommonSupersequence(self, A, B):\\n        def lcs(A, B):\\n            n, m = len(A), len(B)\\n            dp = [[\"\" for _ in xrange(m + 1)] for _ in range(n + 1)]\\n            for i in range(n):\\n                for j in range(m):\\n                    if A[i] == B[j]:\\n                        dp[i + 1][j + 1] = dp[i][j] + A[i]\\n                    else:\\n                        dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1], key=len)\\n            return dp[-1][-1]\\n\\n        res, i, j = \"\", 0, 0\\n        for c in lcs(A, B):\\n            while A[i] != c:\\n                res += A[i]\\n                i += 1\\n            while B[j] != c:\\n                res += B[j]\\n                j += 1\\n            res += c\\n            i, j = i + 1, j + 1\\n        return res + A[i:] + B[j:]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 312702,
                "title": "java-dp-solution-similiar-to-lcs",
                "content": "\\nDP Recurrence:\\n\\nLet str1[0..m - 1] and str2[0..n - 1] be two strings with lengths m and n .\\n\\n  if (m == 0) return n;\\n  if (n == 0) return m;\\n\\n  // If last characters are same, then add 1 to result and recur for str1[]\\n  if (str1.charAt(m - 1) == str2.charAt(n - 1))\\n     return 1 + shortestCommonSupersequence(str1, str2, m - 1, n - 1);\\n\\n  // Else find shortest of following two\\n  //  a) Remove last character from str1 and recur\\n  //  b) Remove last character from str2 and recur\\n  else return 1 + min( shortestCommonSupersequence(str1, str2, m - 1, n), shortestCommonSupersequence(str1, str2, m, n - 1) );\\n```\\npublic String shortestCommonSupersequence(String str1, String str2) {\\n        int m = str1.length();\\n        int n = str2.length();\\n\\n        int[][] dp = new int[m + 1][n + 1];\\n\\n        for (int i = 0; i <= m; i++)\\n        {\\n            for (int j = 0; j <= n; j++)\\n            {\\n                if (i == 0)\\n                    dp[i][j] = j;\\n                else if (j == 0)\\n                    dp[i][j] = i;\\n                else if (str1.charAt(i - 1) == str2.charAt(j - 1))\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\\n                else\\n                    dp[i][j] = 1 + Math.min(dp[i - 1][j],\\n                            dp[i][j - 1]);\\n            }\\n        }\\n\\n        int l = dp[m][n]; // Length of the ShortestSuperSequence\\n        char[] arr = new char[l];\\n        int i=m, j=n;\\n        while(i>0 && j>0)\\n        {\\n            /* If current character in str1 and str2 are same, then\\n             current character is part of shortest supersequence */\\n            if(str1.charAt(i-1) == str2.charAt(j-1)) {\\n                arr[--l] = str1.charAt(i-1);\\n                i--;j--;\\n            }else if(dp[i-1][j]<dp[i][j-1]) {\\n                arr[--l] = str1.charAt(i-1);\\n                i--;\\n            }\\n            else {\\n                arr[--l] = str2.charAt(j-1);\\n                j--;\\n            }\\n        }\\n        while (i > 0) {\\n            arr[--l] = str1.charAt(i-1);\\n            i--;\\n        }\\n        while (j > 0) {\\n            arr[--l] = str2.charAt(j-1);\\n            j--;\\n        }\\n        return new String(arr);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String shortestCommonSupersequence(String str1, String str2) {\\n        int m = str1.length();\\n        int n = str2.length();\\n\\n        int[][] dp = new int[m + 1][n + 1];\\n\\n        for (int i = 0; i <= m; i++)\\n        {\\n            for (int j = 0; j <= n; j++)\\n            {\\n                if (i == 0)\\n                    dp[i][j] = j;\\n                else if (j == 0)\\n                    dp[i][j] = i;\\n                else if (str1.charAt(i - 1) == str2.charAt(j - 1))\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\\n                else\\n                    dp[i][j] = 1 + Math.min(dp[i - 1][j],\\n                            dp[i][j - 1]);\\n            }\\n        }\\n\\n        int l = dp[m][n]; // Length of the ShortestSuperSequence\\n        char[] arr = new char[l];\\n        int i=m, j=n;\\n        while(i>0 && j>0)\\n        {\\n            /* If current character in str1 and str2 are same, then\\n             current character is part of shortest supersequence */\\n            if(str1.charAt(i-1) == str2.charAt(j-1)) {\\n                arr[--l] = str1.charAt(i-1);\\n                i--;j--;\\n            }else if(dp[i-1][j]<dp[i][j-1]) {\\n                arr[--l] = str1.charAt(i-1);\\n                i--;\\n            }\\n            else {\\n                arr[--l] = str2.charAt(j-1);\\n                j--;\\n            }\\n        }\\n        while (i > 0) {\\n            arr[--l] = str1.charAt(i-1);\\n            i--;\\n        }\\n        while (j > 0) {\\n            arr[--l] = str2.charAt(j-1);\\n            j--;\\n        }\\n        return new String(arr);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 580831,
                "title": "complete-c-code-with-full-explaination-beats-100",
                "content": "Computing Shortest Common Supersequence is similar to computing longest common subsequence (LCS)\\nKnowledge of finding LCS is very beneficial for this question. \\n\\n**Idea**: The idea is very simple. The result string should contain all characters of s1 and s2 discarding the common ones.\\n\\t\\t-> S1+S2-LCS\\n\\t\\tbecause characters appearing in LCS are coming twice in the result. So count them only once.\\n\\n**Here is the approach using dynamic programming**:\\n1) Compute the LCS using Dynamic Programming tabulation where each cell resturs the length of the cell upto i characters of String 1 and j characters of string 2.\\n2) We will start processing the table using the last cell till i>0 or j>0\\n\\t\\t2.1) Check if s1[i-1]==s2[j-1]. If equal, we must add this character to the result string only once\\n\\t\\t\\t\\t\\t2.2) If not equal, then find the maximum of t[i-1][j] and t[i][j-1] (this is how you had calculated LCS length first) , start moving in the max direction  after inserting the character to the result string. Moving in max direction means discarding that character of the string that has not contributed in LCS. But still inserting in the final string because it will contribute in SuperSequence.\\n\\t\\t\\t\\t\\ti.e\\n\\t\\t\\t\\t\\tif (t[i-1][j]>t[i][j-1])\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tres.push_back(s1[i-1]);\\n\\t\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t \\t\\t\\t\\t\\t\\t\\t2.3) Compute till i>0 && j>0. If any of the string is left i.e if i>0 or j>0 then add its characters to the result. This means that we copied 1 complete string but other is still remaining.\\n3. We have got the required string but stored all the characters in reverse order. So, just reverse the result and you will get the final answer.\\n\\t\\t\\t\\t\\t\\t\\t\\n\\n**Complete code for your refernece**\\nHope it helps!\\n\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s1, string s2) {\\n        int n=s1.size(); \\n        int m=s2.size();\\n        int t[n+1][m+1]; //table generated while computing LCS length\\n        string res; // result\\t\\n        // compute LCS length using tabulation      \\n    for(int i=0;i<=n;i++)\\n    {\\n        for(int j=0;j<=m;j++)\\n        {\\n            if(i==0||j==0)\\n                t[i][j]=0;\\n            else if(s1[i-1]==s2[j-1])\\n            {\\n                t[i][j]=1+t[i-1][j-1];\\n            }\\n            else\\n            {\\n                t[i][j]=max(t[i-1][j],t[i][j-1]);\\n            }\\n        }\\n    }     \\n       //print lcs\\n    int i=n,j=m;\\n    while(i>0 && j>0)\\n    {\\n        if(s1[i-1]==s2[j-1])\\n        {\\n            res.push_back(s1[i-1]);\\n            i--;\\n            j--;\\n        }\\n        else\\n        {\\n            if(t[i-1][j]>t[i][j-1])\\n            {\\n                res.push_back(s1[i-1]);\\n                i--;\\n            } else{\\n                res.push_back(s2[j-1]);\\n                j--;\\n            }\\n        }\\n    }\\n    while(i>0) // if s1 characters are still left\\n    {\\n        res.push_back(s1[i-1]);\\n        i--;\\n    }\\n    while(j>0) //if s2 characters are still left\\n    {\\n        res.push_back(s2[j-1]);\\n        j--;\\n        \\n    }\\n        reverse(res.begin(),res.end()); \\n        return res;\\n    }\\n};\\n\\n```\\nCredits: AdityaVerma Youtube video.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s1, string s2) {\\n        int n=s1.size(); \\n        int m=s2.size();\\n        int t[n+1][m+1]; //table generated while computing LCS length\\n        string res; // result\\t\\n        // compute LCS length using tabulation      \\n    for(int i=0;i<=n;i++)\\n    {\\n        for(int j=0;j<=m;j++)\\n        {\\n            if(i==0||j==0)\\n                t[i][j]=0;\\n            else if(s1[i-1]==s2[j-1])\\n            {\\n                t[i][j]=1+t[i-1][j-1];\\n            }\\n            else\\n            {\\n                t[i][j]=max(t[i-1][j],t[i][j-1]);\\n            }\\n        }\\n    }     \\n       //print lcs\\n    int i=n,j=m;\\n    while(i>0 && j>0)\\n    {\\n        if(s1[i-1]==s2[j-1])\\n        {\\n            res.push_back(s1[i-1]);\\n            i--;\\n            j--;\\n        }\\n        else\\n        {\\n            if(t[i-1][j]>t[i][j-1])\\n            {\\n                res.push_back(s1[i-1]);\\n                i--;\\n            } else{\\n                res.push_back(s2[j-1]);\\n                j--;\\n            }\\n        }\\n    }\\n    while(i>0) // if s1 characters are still left\\n    {\\n        res.push_back(s1[i-1]);\\n        i--;\\n    }\\n    while(j>0) //if s2 characters are still left\\n    {\\n        res.push_back(s2[j-1]);\\n        j--;\\n        \\n    }\\n        reverse(res.begin(),res.end()); \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312757,
                "title": "java-python-3-space-o-mn-clean-dp-code-w-picture-comments-and-analysis",
                "content": "\\n1. Find LCS;\\nLet `X` be `\\u201CXMJYAUZ\\u201D` and `Y` be `\\u201CMZJAWXU\\u201D`. The longest common subsequence between `X` and `Y` is `\\u201CMJAU\\u201D`. The following table shows the lengths of the longest common subsequences between prefixes of `X` and `Y`. The `ith` row and `jth` column shows the length of the LCS between `X_{1..i}` and `Y_{1..j}`.\\n![image](https://assets.leetcode.com/users/rock/image_1568826071.png)\\nyou can refer to [here](https://en.m.wikipedia.org/wiki/Longest_common_subsequence_problem) for more details.\\n\\n2. Reversely append the chars to StringBuilder, if the char is among the LCS, choose either one between the two strings.\\na) start from `i = m - 1` and `j = n - 1`, check if the corresponding chars are equal, that is, s1.charAt(i) == s2.charAt(j); if yes, append either of them; if no, append the char with larger `dp` value.\\nb) If we reach left end of s1 or s2 first, continue to append remaining chars in the other string.\\n\\n\\n```\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n\\n        // find LCS.\\n        int m = s1.length(), n = s2.length();\\n        int[][] dp = new int[m + 1][n + 1];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    dp[i + 1][j + 1] = 1 + dp[i][j];    \\n                }else {\\n                    dp[i + 1][j + 1] = Math.max(dp[i + 1][j], dp[i][j + 1]);\\n                }\\n            }\\n        }\\n\\t\\t\\n        // Build result.\\n        StringBuilder sb = new StringBuilder();\\n        int i = m - 1, j = n - 1;\\n        while (i >= 0 || j >= 0) { \\n            if (i < 0 ^ j < 0) { // only one string reaches left end.\\n                char c = i < 0 ? s2.charAt(j--) : s1.charAt(i--); // remaining chars in the other string.\\n                sb.append(c);\\n            }else if (s1.charAt(i) == s2.charAt(j)) { // common char in LCS.\\n                sb.append(s1.charAt(i)); // append the char of either s1 or s2.\\n                --i; --j;  \\n            }else { // the char is not in LCS.\\n                char c = dp[i][j + 1] > dp[i + 1][j] ? s1.charAt(i--) : s2.charAt(j--); // the char corresponding to larger dp value.\\n                sb.append(c);\\n            }\\n        } \\n        return sb.reverse().toString();\\n    }\\n```\\n```\\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        m, n = len(s1), len(s2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i, c in enumerate(s1):\\n            for j, d in enumerate(s2):\\n                dp[i + 1][j + 1] = 1 + dp[i][j] if c == d else max(dp[i + 1][j], dp[i][j + 1])\\n        i, j, stk = m - 1, n - 1, []\\n        while i >= 0 and j >= 0:\\n            if s1[i] == s2[j]:\\n                stk.append(s1[i])\\n                i -= 1\\n                j -= 1\\n            elif dp[i + 1][j] < dp[i][j + 1]:\\n                stk.append(s1[i])\\n                i -= 1\\n            else:\\n                stk.append(s2[j])\\n                j -= 1    \\n        return s1[: i + 1] + s2[: j + 1] + \\'\\'.join(reversed(stk))\\n```\\n**Analysis:**\\n\\nTime & space:: O(m * n), where m = s1.length(), n = s2.length().\\n\\n\\n----\\n\\n# Update:\\n**Q & A**\\n\\nQ1: Is it possible to move backwards in the find LCS so you would not need to reverse in the second half?\\nA1:\\nI believe it is possible, but that will NOT make the code simpler, and there could be more than one solution also. \\nIf you hope to compute `dp` array **backward** and construct the common  supersequence **forward**, here is the code:\\n```\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        int m = s1.length(), n = s2.length();\\n        int[][] dp = new int[m + 1][n + 1];\\n        for (int i = m - 1; i >= 0; --i) {\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    dp[i][j] = 1 + dp[i + 1][j + 1];\\n                }else {\\n                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);\\n                }\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0, j = 0;\\n        while (i < m || j < n) {\\n            if (i < m ^ j < n) {\\n                sb.append(i < m ? s1.charAt(i++) : s2.charAt(j++));\\n            }else if (s1.charAt(i) == s2.charAt(j)) {\\n                sb.append(s1.charAt(i++));\\n                ++j;\\n            }else {\\n                sb.append(dp[i + 1][j] > dp[i][j + 1] ? s1.charAt(i++) : s2.charAt(j++));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\\n```\\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        m, n = len(s1), len(s2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i, c in reversed(list(enumerate(s1))):\\n            for j, d in reversed(list(enumerate(s2))):\\n                dp[i][j] = 1 + dp[i + 1][j + 1] if c == d else max(dp[i + 1][j], dp[i][j + 1])\\n        i, j, seq = 0, 0, []\\n        while i < m and j < n:\\n            if s1[i] == s2[j]:\\n                seq.append(s1[i])\\n                i += 1\\n                j += 1\\n            elif dp[i + 1][j] > dp[i][j + 1]:\\n                seq.append(s1[i])\\n                i += 1\\n            else:\\n                seq.append(s2[j])\\n                j += 1    \\n        return \\'\\'.join(seq) + s1[i :] + s2[j :]\\n```\\nQ2: Could you explain the condition being described here? I understand about finishing one string and tacking on the rest of the other. I looked and saw ^ was a bitwise XOR operator, but I didn\\'t understand it in this context.\\n```\\n if (i < 0 ^ j < 0) { // only one string reaches left end.\\n```\\nA2:\\nSimilar to bitwise `xor`, which results `1` if and only if one operand is `1` and the other is `0`: `(conditional 1) ^ (conditional 2)` is true iff one is `true` and the other is `false`. In case you are not comfortable with it, you can rewrite it as: \\n```\\n if (i < 0 && j >= 0 || j < 0 && i >= 0) { // only one string reaches left end.\\n```\\nQ3: In your following code, why backtracking gives us the shortest super string?\\n```\\ni, j, stk = m - 1, n - 1, []\\nwhile i >= 0 and j >= 0:\\n```\\nWhy can\\'t we start with `i, j = 0, 0`?\\n\\nA3: If we start from `(0, 0)`, we need to search again for the LCS, which we have already found in the first half part of the code.\\ndp[m][n] is guaranteed to be the largest value, and by starting from its corresponding coordinate `(m - 1, n - 1)` we can follow the LCS path to make sure the chars in LCS appear only **once** not twice. If twice, that would not be the **shortest** super common sequence.\\n\\n**end** of Q & A\\n\\n----",
                "solutionTags": [],
                "code": "```\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n\\n        // find LCS.\\n        int m = s1.length(), n = s2.length();\\n        int[][] dp = new int[m + 1][n + 1];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    dp[i + 1][j + 1] = 1 + dp[i][j];    \\n                }else {\\n                    dp[i + 1][j + 1] = Math.max(dp[i + 1][j], dp[i][j + 1]);\\n                }\\n            }\\n        }\\n\\t\\t\\n        // Build result.\\n        StringBuilder sb = new StringBuilder();\\n        int i = m - 1, j = n - 1;\\n        while (i >= 0 || j >= 0) { \\n            if (i < 0 ^ j < 0) { // only one string reaches left end.\\n                char c = i < 0 ? s2.charAt(j--) : s1.charAt(i--); // remaining chars in the other string.\\n                sb.append(c);\\n            }else if (s1.charAt(i) == s2.charAt(j)) { // common char in LCS.\\n                sb.append(s1.charAt(i)); // append the char of either s1 or s2.\\n                --i; --j;  \\n            }else { // the char is not in LCS.\\n                char c = dp[i][j + 1] > dp[i + 1][j] ? s1.charAt(i--) : s2.charAt(j--); // the char corresponding to larger dp value.\\n                sb.append(c);\\n            }\\n        } \\n        return sb.reverse().toString();\\n    }\\n```\n```\\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        m, n = len(s1), len(s2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i, c in enumerate(s1):\\n            for j, d in enumerate(s2):\\n                dp[i + 1][j + 1] = 1 + dp[i][j] if c == d else max(dp[i + 1][j], dp[i][j + 1])\\n        i, j, stk = m - 1, n - 1, []\\n        while i >= 0 and j >= 0:\\n            if s1[i] == s2[j]:\\n                stk.append(s1[i])\\n                i -= 1\\n                j -= 1\\n            elif dp[i + 1][j] < dp[i][j + 1]:\\n                stk.append(s1[i])\\n                i -= 1\\n            else:\\n                stk.append(s2[j])\\n                j -= 1    \\n        return s1[: i + 1] + s2[: j + 1] + \\'\\'.join(reversed(stk))\\n```\n```\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        int m = s1.length(), n = s2.length();\\n        int[][] dp = new int[m + 1][n + 1];\\n        for (int i = m - 1; i >= 0; --i) {\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    dp[i][j] = 1 + dp[i + 1][j + 1];\\n                }else {\\n                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);\\n                }\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0, j = 0;\\n        while (i < m || j < n) {\\n            if (i < m ^ j < n) {\\n                sb.append(i < m ? s1.charAt(i++) : s2.charAt(j++));\\n            }else if (s1.charAt(i) == s2.charAt(j)) {\\n                sb.append(s1.charAt(i++));\\n                ++j;\\n            }else {\\n                sb.append(dp[i + 1][j] > dp[i][j + 1] ? s1.charAt(i++) : s2.charAt(j++));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\n```\\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        m, n = len(s1), len(s2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i, c in reversed(list(enumerate(s1))):\\n            for j, d in reversed(list(enumerate(s2))):\\n                dp[i][j] = 1 + dp[i + 1][j + 1] if c == d else max(dp[i + 1][j], dp[i][j + 1])\\n        i, j, seq = 0, 0, []\\n        while i < m and j < n:\\n            if s1[i] == s2[j]:\\n                seq.append(s1[i])\\n                i += 1\\n                j += 1\\n            elif dp[i + 1][j] > dp[i][j + 1]:\\n                seq.append(s1[i])\\n                i += 1\\n            else:\\n                seq.append(s2[j])\\n                j += 1    \\n        return \\'\\'.join(seq) + s1[i :] + s2[j :]\\n```\n```\\n if (i < 0 ^ j < 0) { // only one string reaches left end.\\n```\n```\\n if (i < 0 && j >= 0 || j < 0 && i >= 0) { // only one string reaches left end.\\n```\n```\\ni, j, stk = m - 1, n - 1, []\\nwhile i >= 0 and j >= 0:\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 313608,
                "title": "c-lcs-backtracking",
                "content": "**Intuition:** for the shortest supersequence, we need to find the maximum number of shared characters that appear in the same order in both strings.\\n\\nFor that, we can use the longest common subsequence (LCS) algorithm. \\n\\nFirst, build a m * n matrix with LCS results. Then, backtrack and build our superstring.\\n\\n**Complexity Analysis:** LCS is O(n ^ 2) in both runtime and memory.\\n\\n**C++**\\n```cpp\\nstring shortestCommonSupersequence(string a, string b) {\\n    int dp[1001][1001] = {}, m = a.size(), n = b.size();\\n    for (int i = 0; i < m; ++i) // DP\\n        for (int j = 0; j < n; ++j)\\n            dp[i + 1][j + 1] = a[i] == b[j] ? \\n                dp[i][j] + 1 : max(dp[i][j + 1], dp[i + 1][j]);\\n    string res;\\n    while (m && n) // Backtracking\\n        if (dp[m][n] == dp[m - 1][n])\\n            res += a[--m]; // Character only in a\\n        else if (dp[m][n] == dp[m][n - 1])\\n            res += b[--n]; // Character only in b\\n        else\\n            res += min(a[--m], b[--n]); // Shared character in a & b\\n    return a.substr(0, m) + b.substr(0, n) + string(rbegin(res), rend(res));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstring shortestCommonSupersequence(string a, string b) {\\n    int dp[1001][1001] = {}, m = a.size(), n = b.size();\\n    for (int i = 0; i < m; ++i) // DP\\n        for (int j = 0; j < n; ++j)\\n            dp[i + 1][j + 1] = a[i] == b[j] ? \\n                dp[i][j] + 1 : max(dp[i][j + 1], dp[i + 1][j]);\\n    string res;\\n    while (m && n) // Backtracking\\n        if (dp[m][n] == dp[m - 1][n])\\n            res += a[--m]; // Character only in a\\n        else if (dp[m][n] == dp[m][n - 1])\\n            res += b[--n]; // Character only in b\\n        else\\n            res += min(a[--m], b[--n]); // Shared character in a & b\\n    return a.substr(0, m) + b.substr(0, n) + string(rbegin(res), rend(res));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1281299,
                "title": "easy-solution-using-lcs",
                "content": "**Do Upvote if Useful :)**\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string X, string Y) {\\n       int n=X.size(), m=Y.size();\\n\\tint t[n+1][m+1];\\n\\tfor(int i=0;i<=n;i++)\\n\\t\\tfor(int j=0;j<=m;j++){\\n\\t\\t\\tif(i==0||j==0)\\n\\t\\t\\t\\tt[i][j]=0;\\n\\t\\t}\\n\\t\\t\\n\\tfor(int i=1;i<=n;i++)\\n\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\tif(X[i-1]==Y[j-1])\\n\\t\\t\\t\\tt[i][j]= 1+t[i-1][j-1];\\n\\t\\t\\telse\\n\\t\\t\\t\\tt[i][j]= max(t[i-1][j],t[i][j-1]);\\n\\t\\t}\\n\\t\\t\\n\\tint i=n,j=m;\\n\\tstring s;\\n\\twhile(i>0&&j>0){\\n\\t\\tif(X[i-1]==Y[j-1]){\\n\\t\\t\\ts += X[i - 1];\\n\\t\\t\\ti--, j--;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(t[i][j-1]>t[i-1][j]){\\n\\t\\t\\t\\ts += Y[j - 1];\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\ts += X[i - 1];\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\twhile(i>0){\\n\\t\\ts.push_back(X[i-1]);\\n\\t\\ti--;\\n\\t}\\n\\t\\n\\twhile(j>0){\\n\\t\\ts.push_back(Y[j-1]);\\n\\t\\tj--;\\n\\t}\\n\\treverse(s.begin(), s.end());\\n\\treturn s; \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string X, string Y) {\\n       int n=X.size(), m=Y.size();\\n\\tint t[n+1][m+1];\\n\\tfor(int i=0;i<=n;i++)\\n\\t\\tfor(int j=0;j<=m;j++){\\n\\t\\t\\tif(i==0||j==0)\\n\\t\\t\\t\\tt[i][j]=0;\\n\\t\\t}\\n\\t\\t\\n\\tfor(int i=1;i<=n;i++)\\n\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\tif(X[i-1]==Y[j-1])\\n\\t\\t\\t\\tt[i][j]= 1+t[i-1][j-1];\\n\\t\\t\\telse\\n\\t\\t\\t\\tt[i][j]= max(t[i-1][j],t[i][j-1]);\\n\\t\\t}\\n\\t\\t\\n\\tint i=n,j=m;\\n\\tstring s;\\n\\twhile(i>0&&j>0){\\n\\t\\tif(X[i-1]==Y[j-1]){\\n\\t\\t\\ts += X[i - 1];\\n\\t\\t\\ti--, j--;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(t[i][j-1]>t[i-1][j]){\\n\\t\\t\\t\\ts += Y[j - 1];\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\ts += X[i - 1];\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\twhile(i>0){\\n\\t\\ts.push_back(X[i-1]);\\n\\t\\ti--;\\n\\t}\\n\\t\\n\\twhile(j>0){\\n\\t\\ts.push_back(Y[j-1]);\\n\\t\\tj--;\\n\\t}\\n\\treverse(s.begin(), s.end());\\n\\treturn s; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764712,
                "title": "c-lcs-dp-top-down-easy-to-understand",
                "content": "# 1092. Shortest Common Supersequence\\n**KNOCKCAT**\\n```\\n1. Easy C++\\n2. Dynamic Programming.\\n3. Bottom up  (Tabulation).\\n4. Line by Line Explanation with Comments.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\\n[LeetCode](https://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\n    string LCS(string str1, string str2, int m, int n)\\n    {\\n        // matrix for Memoization\\n        int t[m+1][n+1];\\n        \\n        // string for storing shortest common super subsequence\\n        string ind = \"\";\\n        \\n        // filling dp / t Matrix\\n        \\n        for(int i = 0;i < m+1; ++i)\\n        {\\n            for(int j = 0; j< n+1; ++j)\\n            {\\n                // Initialising first row and first column of dp / t matrix to 0\\n                if(i == 0 || j == 0)\\n                    t[i][j] = 0;\\n            }\\n        }\\n        \\n        for(int i = 1; i < m+1; ++i)\\n        {\\n            for(int j = 1; j < n+1; ++j)\\n            {\\n                if(str1[i-1] == str2[j-1])\\n                    t[i][j] = 1 + t[i-1][j-1];\\n                else\\n                    t[i][j] = max(t[i-1][j], t[i][j-1]);\\n            }\\n        }\\n        \\n        // making shortest common supersubsequence\\n        int i = m, j = n;\\n        \\n        while(i > 0 && j > 0)\\n        {\\n            if(str1[i-1] == str2[j-1])\\n            {\\n                // if current character in str1 and str2 are same, then\\n                // current character is part of LCS\\n                \\n                ind.push_back(str1[i-1]); // put current character of LCS in ind\\n                --i;                     // reduce values of i,j\\n                --j;\\n            }\\n            \\n            // if current character in str1 and str2 are different\\n            \\n            else if(t[i][j-1] > t[i-1][j])\\n            {\\n                ind.push_back(str2[j-1]);  // put current character of str2 in ind\\n                --j;                       // reduce value of j\\n            }\\n            \\n            else\\n            {\\n                ind.push_back(str1[i-1]);  // put current character of str1 in ind\\n                --i;                       // reduce value of i \\n            }\\n        }\\n        \\n        // if str2 reaches its end,  put remaining characters of\\n        // str1 in ind\\n        \\n        while( i > 0)\\n        {\\n            ind.push_back(str1[i-1]);\\n            --i;\\n        }\\n        \\n        // if str1 reaches its end, put remaining characters of \\n        // str2 in ind\\n        \\n        while( j > 0)\\n        {\\n            ind.push_back(str2[j-1]);\\n            --j;\\n        }\\n        \\n        // reverse LCS as we started storing from t[m][n]\\n        reverse(ind.begin(),ind.end());\\n        \\n        // return the LCS\\n        return ind;\\n    }\\n    \\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        \\n        int m = str1.length();\\n        int n = str2.length();\\n        \\n        return LCS(str1, str2, m ,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n1. Easy C++\\n2. Dynamic Programming.\\n3. Bottom up  (Tabulation).\\n4. Line by Line Explanation with Comments.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\n    string LCS(string str1, string str2, int m, int n)\\n    {\\n        // matrix for Memoization\\n        int t[m+1][n+1];\\n        \\n        // string for storing shortest common super subsequence\\n        string ind = \"\";\\n        \\n        // filling dp / t Matrix\\n        \\n        for(int i = 0;i < m+1; ++i)\\n        {\\n            for(int j = 0; j< n+1; ++j)\\n            {\\n                // Initialising first row and first column of dp / t matrix to 0\\n                if(i == 0 || j == 0)\\n                    t[i][j] = 0;\\n            }\\n        }\\n        \\n        for(int i = 1; i < m+1; ++i)\\n        {\\n            for(int j = 1; j < n+1; ++j)\\n            {\\n                if(str1[i-1] == str2[j-1])\\n                    t[i][j] = 1 + t[i-1][j-1];\\n                else\\n                    t[i][j] = max(t[i-1][j], t[i][j-1]);\\n            }\\n        }\\n        \\n        // making shortest common supersubsequence\\n        int i = m, j = n;\\n        \\n        while(i > 0 && j > 0)\\n        {\\n            if(str1[i-1] == str2[j-1])\\n            {\\n                // if current character in str1 and str2 are same, then\\n                // current character is part of LCS\\n                \\n                ind.push_back(str1[i-1]); // put current character of LCS in ind\\n                --i;                     // reduce values of i,j\\n                --j;\\n            }\\n            \\n            // if current character in str1 and str2 are different\\n            \\n            else if(t[i][j-1] > t[i-1][j])\\n            {\\n                ind.push_back(str2[j-1]);  // put current character of str2 in ind\\n                --j;                       // reduce value of j\\n            }\\n            \\n            else\\n            {\\n                ind.push_back(str1[i-1]);  // put current character of str1 in ind\\n                --i;                       // reduce value of i \\n            }\\n        }\\n        \\n        // if str2 reaches its end,  put remaining characters of\\n        // str1 in ind\\n        \\n        while( i > 0)\\n        {\\n            ind.push_back(str1[i-1]);\\n            --i;\\n        }\\n        \\n        // if str1 reaches its end, put remaining characters of \\n        // str2 in ind\\n        \\n        while( j > 0)\\n        {\\n            ind.push_back(str2[j-1]);\\n            --j;\\n        }\\n        \\n        // reverse LCS as we started storing from t[m][n]\\n        reverse(ind.begin(),ind.end());\\n        \\n        // return the LCS\\n        return ind;\\n    }\\n    \\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        \\n        int m = str1.length();\\n        int n = str2.length();\\n        \\n        return LCS(str1, str2, m ,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501177,
                "title": "day-403-easy-lcs-0ms-100-python-java-c-explained-approach",
                "content": "\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n# Intuition & Approach\\n\\n##### \\u2022\\tThe shortestCommonSupersequence method takes two strings s1 and s2 as input and returns their shortest common supersequence\\n##### \\u2022\\tThe first finds the longest common subsequence (LCS) of s1 and s2 using the lcs helper method\\n##### \\u2022\\tThe lcs method takes two strings s1 and s2 as input and returns their LCS\\n##### \\u2022\\tIt uses dynamic programming to fill a 2D array dp where dp[i][j] represents the length of the LCS of the first i characters of s1 and the first j characters of s2\\n##### \\u2022 Then backtracks from the bottom right corner of the dp array to find the LCS\\n##### \\u2022\\tThe shortestCommonSupersequence method then merges s1 and s2 with the LCS to create the shortest common supersequence\\n##### \\u2022\\tIt uses a StringBuilder to build the merged string\\n##### \\u2022\\tThe method iterates over the characters of the LCS and adds characters from s1 and s2 until the LCS character is found\\n##### \\u2022\\tIt then adds the LCS character to the merged string\\n##### \\u2022\\tAfter all the LCS characters have been added, the method adds any remaining characters from s1 and s2 to the merged string\\n##### \\u2022\\tThe method returns the merged string as the shortest common supersequence\\n##### \\u2022\\tThe approach is to find the LCS of the two input strings and then merge the strings with the LCS to create the shortest common supersequence\\n##### \\u2022\\tThe use of dynamic programming to find the LCS allows for an efficient solution\\n\\n# Code\\n```java []\\npublic String shortestCommonSupersequence(String s1, String s2) {\\n    // find the LCS of s1 and s2\\n    char lcs[] = lcs(s1,s2).toCharArray();\\n    int i=0,j=0;\\n    StringBuilder sb = new StringBuilder();\\n    // merge s1 and s2 with the LCS\\n    for(char c:lcs){\\n        // add characters from s1 until the LCS character is found\\n        while(s1.charAt(i)!=c) sb.append(s1.charAt(i++));\\n        // add characters from s2 until the LCS character is found\\n        while(s2.charAt(j)!=c) sb.append(s2.charAt(j++));\\n        // add the LCS character\\n        sb.append(c);\\n        i++;\\n        j++;\\n    }\\n    // add any remaining characters from s1 and s2\\n    sb.append(s1.substring(i)).append(s2.substring(j));\\n    // return the merged string\\n    return sb.toString();\\n}\\n\\n// helper method to find the LCS of two strings\\nString lcs(String s1,String s2){\\n    int m = s1.length(),n=s2.length();\\n    int dp[][] = new int[m+1][n+1];\\n    // fill the dp array using dynamic programming\\n    for(int i=1;i<=m;i++){\\n        for(int j=1;j<=n;j++){\\n            if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                dp[i][j]=1+dp[i-1][j-1];\\n            }else dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\\n        }\\n    }\\n    // backtrack from the bottom right corner of the dp array to find the LCS\\n    StringBuilder sb = new StringBuilder();\\n    int i=m,j=n;\\n    while(i>0 && j>0){\\n        if(s1.charAt(i-1)==s2.charAt(j-1)){\\n            sb.append(s1.charAt(i-1));\\n            i--;\\n            j--;\\n        }else if(dp[i-1][j]>dp[i][j-1]) i--;\\n        else j--;\\n    }\\n    // reverse the LCS string and return it\\n    return sb.reverse().toString();\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s1, string s2) {\\n        // find the LCS of s1 and s2\\n        string lcs = getLCS(s1, s2);\\n        int i = 0, j = 0;\\n        string result = \"\";\\n        // merge s1 and s2 with the LCS\\n        for (char c : lcs) {\\n            // add characters from s1 until the LCS character is found\\n            while (s1[i] != c) {\\n                result += s1[i];\\n                i++;\\n            }\\n            // add characters from s2 until the LCS character is found\\n            while (s2[j] != c) {\\n                result += s2[j];\\n                j++;\\n            }\\n            // add the LCS character\\n            result += c;\\n            i++;\\n            j++;\\n        }\\n        // add any remaining characters from s1 and s2\\n        result += s1.substr(i) + s2.substr(j);\\n        // return the merged string\\n        return result;\\n    }\\n\\n    // helper method to find the LCS of two strings\\n    string getLCS(string s1, string s2) {\\n        int m = s1.length(), n = s2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        // fill the dp array using dynamic programming\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s1[i-1] == s2[j-1]) {\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        // backtrack from the bottom right corner of the dp array to find the LCS\\n        string lcs = \"\";\\n        int i = m, j = n;\\n        while (i > 0 && j > 0) {\\n            if (s1[i-1] == s2[j-1]) {\\n                lcs = s1[i-1] + lcs;\\n                i--;\\n                j--;\\n            } else if (dp[i-1][j] > dp[i][j-1]) {\\n                i--;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return lcs;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        # find the LCS of s1 and s2\\n        lcs = self.getLCS(s1, s2)\\n        i, j = 0, 0\\n        result = \"\"\\n        # merge s1 and s2 with the LCS\\n        for c in lcs:\\n            # add characters from s1 until the LCS character is found\\n            while s1[i] != c:\\n                result += s1[i]\\n                i += 1\\n            # add characters from s2 until the LCS character is found\\n            while s2[j] != c:\\n                result += s2[j]\\n                j += 1\\n            # add the LCS character\\n            result += c\\n            i += 1\\n            j += 1\\n        # add any remaining characters from s1 and s2\\n        result += s1[i:] + s2[j:]\\n        # return the merged string\\n        return result\\n\\n    # helper method to find the LCS of two strings\\n    def getLCS(self, s1: str, s2: str) -> str:\\n        m, n = len(s1), len(s2)\\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        # fill the dp array using dynamic programming\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if s1[i-1] == s2[j-1]:\\n                    dp[i][j] = 1 + dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n        # backtrack from the bottom right corner of the dp array to find the LCS\\n        lcs = \"\"\\n        i, j = m, n\\n        while i > 0 and j > 0:\\n            if s1[i-1] == s2[j-1]:\\n                lcs = s1[i-1] + lcs\\n                i -= 1\\n                j -= 1\\n            elif dp[i-1][j] > dp[i][j-1]:\\n                i -= 1\\n            else:\\n                j -= 1\\n        return lcs\\n```\\n\\n# Complexity\\n- Time complexity:o(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# optimal \\n```java []\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n    // find the LCS of s1 and s2\\n    int m = s1.length(),n=s2.length();\\n    int dp[][] = new int[m+1][n+1];\\n    // fill the dp array using dynamic programming\\n    for(int i=1;i<=m;i++){\\n        for(int j=1;j<=n;j++){\\n            if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                dp[i][j]=1+dp[i-1][j-1];\\n            }else dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\\n        }\\n    }\\n    // backtrack from the bottom right corner of the dp array to find the LCS\\n    StringBuilder sb = new StringBuilder();\\n    int i=m,j=n;\\n    while(i>0 && j>0){\\n        if(s1.charAt(i-1)==s2.charAt(j-1)){\\n            sb.append(s1.charAt(i-1));\\n            i--;\\n            j--;\\n        }else if(dp[i-1][j]>dp[i][j-1]){//shrink s1\\n        sb.append(s1.charAt(i-1));\\n         i--;\\n        }else{\\n            sb.append(s2.charAt(j-1));\\n         j--;\\n        }\\n    }\\n    while(i>0){//remaing 1 element in s1\\n    sb.append(s1.charAt(i-1));\\n         i--;\\n    }\\n     while(j>0){\\n    sb.append(s2.charAt(j-1));\\n         j--;\\n    }\\n    // reverse the LCS string and return it\\n    return sb.reverse().toString();\\n}\\n```\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```java []\\npublic String shortestCommonSupersequence(String s1, String s2) {\\n    // find the LCS of s1 and s2\\n    char lcs[] = lcs(s1,s2).toCharArray();\\n    int i=0,j=0;\\n    StringBuilder sb = new StringBuilder();\\n    // merge s1 and s2 with the LCS\\n    for(char c:lcs){\\n        // add characters from s1 until the LCS character is found\\n        while(s1.charAt(i)!=c) sb.append(s1.charAt(i++));\\n        // add characters from s2 until the LCS character is found\\n        while(s2.charAt(j)!=c) sb.append(s2.charAt(j++));\\n        // add the LCS character\\n        sb.append(c);\\n        i++;\\n        j++;\\n    }\\n    // add any remaining characters from s1 and s2\\n    sb.append(s1.substring(i)).append(s2.substring(j));\\n    // return the merged string\\n    return sb.toString();\\n}\\n\\n// helper method to find the LCS of two strings\\nString lcs(String s1,String s2){\\n    int m = s1.length(),n=s2.length();\\n    int dp[][] = new int[m+1][n+1];\\n    // fill the dp array using dynamic programming\\n    for(int i=1;i<=m;i++){\\n        for(int j=1;j<=n;j++){\\n            if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                dp[i][j]=1+dp[i-1][j-1];\\n            }else dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\\n        }\\n    }\\n    // backtrack from the bottom right corner of the dp array to find the LCS\\n    StringBuilder sb = new StringBuilder();\\n    int i=m,j=n;\\n    while(i>0 && j>0){\\n        if(s1.charAt(i-1)==s2.charAt(j-1)){\\n            sb.append(s1.charAt(i-1));\\n            i--;\\n            j--;\\n        }else if(dp[i-1][j]>dp[i][j-1]) i--;\\n        else j--;\\n    }\\n    // reverse the LCS string and return it\\n    return sb.reverse().toString();\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s1, string s2) {\\n        // find the LCS of s1 and s2\\n        string lcs = getLCS(s1, s2);\\n        int i = 0, j = 0;\\n        string result = \"\";\\n        // merge s1 and s2 with the LCS\\n        for (char c : lcs) {\\n            // add characters from s1 until the LCS character is found\\n            while (s1[i] != c) {\\n                result += s1[i];\\n                i++;\\n            }\\n            // add characters from s2 until the LCS character is found\\n            while (s2[j] != c) {\\n                result += s2[j];\\n                j++;\\n            }\\n            // add the LCS character\\n            result += c;\\n            i++;\\n            j++;\\n        }\\n        // add any remaining characters from s1 and s2\\n        result += s1.substr(i) + s2.substr(j);\\n        // return the merged string\\n        return result;\\n    }\\n\\n    // helper method to find the LCS of two strings\\n    string getLCS(string s1, string s2) {\\n        int m = s1.length(), n = s2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        // fill the dp array using dynamic programming\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s1[i-1] == s2[j-1]) {\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        // backtrack from the bottom right corner of the dp array to find the LCS\\n        string lcs = \"\";\\n        int i = m, j = n;\\n        while (i > 0 && j > 0) {\\n            if (s1[i-1] == s2[j-1]) {\\n                lcs = s1[i-1] + lcs;\\n                i--;\\n                j--;\\n            } else if (dp[i-1][j] > dp[i][j-1]) {\\n                i--;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return lcs;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        # find the LCS of s1 and s2\\n        lcs = self.getLCS(s1, s2)\\n        i, j = 0, 0\\n        result = \"\"\\n        # merge s1 and s2 with the LCS\\n        for c in lcs:\\n            # add characters from s1 until the LCS character is found\\n            while s1[i] != c:\\n                result += s1[i]\\n                i += 1\\n            # add characters from s2 until the LCS character is found\\n            while s2[j] != c:\\n                result += s2[j]\\n                j += 1\\n            # add the LCS character\\n            result += c\\n            i += 1\\n            j += 1\\n        # add any remaining characters from s1 and s2\\n        result += s1[i:] + s2[j:]\\n        # return the merged string\\n        return result\\n\\n    # helper method to find the LCS of two strings\\n    def getLCS(self, s1: str, s2: str) -> str:\\n        m, n = len(s1), len(s2)\\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        # fill the dp array using dynamic programming\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if s1[i-1] == s2[j-1]:\\n                    dp[i][j] = 1 + dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n        # backtrack from the bottom right corner of the dp array to find the LCS\\n        lcs = \"\"\\n        i, j = m, n\\n        while i > 0 and j > 0:\\n            if s1[i-1] == s2[j-1]:\\n                lcs = s1[i-1] + lcs\\n                i -= 1\\n                j -= 1\\n            elif dp[i-1][j] > dp[i][j-1]:\\n                i -= 1\\n            else:\\n                j -= 1\\n        return lcs\\n```\n```java []\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n    // find the LCS of s1 and s2\\n    int m = s1.length(),n=s2.length();\\n    int dp[][] = new int[m+1][n+1];\\n    // fill the dp array using dynamic programming\\n    for(int i=1;i<=m;i++){\\n        for(int j=1;j<=n;j++){\\n            if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                dp[i][j]=1+dp[i-1][j-1];\\n            }else dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\\n        }\\n    }\\n    // backtrack from the bottom right corner of the dp array to find the LCS\\n    StringBuilder sb = new StringBuilder();\\n    int i=m,j=n;\\n    while(i>0 && j>0){\\n        if(s1.charAt(i-1)==s2.charAt(j-1)){\\n            sb.append(s1.charAt(i-1));\\n            i--;\\n            j--;\\n        }else if(dp[i-1][j]>dp[i][j-1]){//shrink s1\\n        sb.append(s1.charAt(i-1));\\n         i--;\\n        }else{\\n            sb.append(s2.charAt(j-1));\\n         j--;\\n        }\\n    }\\n    while(i>0){//remaing 1 element in s1\\n    sb.append(s1.charAt(i-1));\\n         i--;\\n    }\\n     while(j>0){\\n    sb.append(s2.charAt(j-1));\\n         j--;\\n    }\\n    // reverse the LCS string and return it\\n    return sb.reverse().toString();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319439,
                "title": "java-dp-bottom-up-2d-matrix",
                "content": "str1 = \"abac\", n1=4, str2=\"cab\", n2=3\\nThe first loop finds the number of overlapping characters in the shortest common supersequence at mem[n1][n2]\\nMatrix will look like: -\\n----*----c-------a-------b\\n-*---0---**0**------0-------0\\na---0---0------**1**-------0\\nb---0---0------0-------**2**\\na---0---0------1-------**2**\\nc---0---0------1-------**2**\\n(values in bold represent the path to find the string)\\n\\nTo get the final string, start from the end and come back untill all characters are parsed.\\n1. While coming back, see if top or left value is equal to mem[i][j]\\n\\ta. If equal to top, then add the character at i-1 of str1, and do i--\\n\\tb. If equal to left, then add the character at j-1 of str2, and do j--\\n\\tc. If none are equal, then add either of the characters, as they will be the same anyway and do i-- as well as j--\\n2. Then, if either i=0, or j=0, then add the remaining characters to the string of the other\\n3. Since, this is bottom-up, the answer is the reverse of the resulting string \\n\\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int n1 = str1.length();\\n        int n2 = str2.length();\\n        int[][] mem = new int[n1+1][n2+1];\\n        int i, j;\\n\\n        for(i=1; i<=n1; i++) {\\n            for(j=1; j<=n2; j++) {\\n                char ch1 = str1.charAt(i-1);\\n                char ch2 = str2.charAt(j-1);\\n                if(ch1 == ch2) {\\n                    mem[i][j] = 1 + mem[i-1][j-1];\\n                } else {\\n                    mem[i][j] = Math.max(mem[i-1][j], mem[i][j-1]);\\n                }\\n            }\\n        }\\n        i=n1;\\n        j=n2;\\n        StringBuilder str = new StringBuilder();\\n        while(i>0 && j>0) {\\n            if(mem[i][j] == mem[i-1][j]) {\\n                str.append(str1.charAt(i-1));\\n                i--;\\n            } else if(mem[i][j] == mem[i][j-1]) {\\n                str.append(str2.charAt(j-1));\\n                j--;\\n            } else {\\n                str.append(str1.charAt(i-1));\\n                i--;\\n                j--;\\n            }\\n        }\\n        while(i-- > 0) {\\n            str.append(str1.charAt(i));\\n        }\\n        while(j-- > 0) {\\n            str.append(str2.charAt(j));\\n        }\\n        return str.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int n1 = str1.length();\\n        int n2 = str2.length();\\n        int[][] mem = new int[n1+1][n2+1];\\n        int i, j;\\n\\n        for(i=1; i<=n1; i++) {\\n            for(j=1; j<=n2; j++) {\\n                char ch1 = str1.charAt(i-1);\\n                char ch2 = str2.charAt(j-1);\\n                if(ch1 == ch2) {\\n                    mem[i][j] = 1 + mem[i-1][j-1];\\n                } else {\\n                    mem[i][j] = Math.max(mem[i-1][j], mem[i][j-1]);\\n                }\\n            }\\n        }\\n        i=n1;\\n        j=n2;\\n        StringBuilder str = new StringBuilder();\\n        while(i>0 && j>0) {\\n            if(mem[i][j] == mem[i-1][j]) {\\n                str.append(str1.charAt(i-1));\\n                i--;\\n            } else if(mem[i][j] == mem[i][j-1]) {\\n                str.append(str2.charAt(j-1));\\n                j--;\\n            } else {\\n                str.append(str1.charAt(i-1));\\n                i--;\\n                j--;\\n            }\\n        }\\n        while(i-- > 0) {\\n            str.append(str1.charAt(i));\\n        }\\n        while(j-- > 0) {\\n            str.append(str2.charAt(j));\\n        }\\n        return str.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317092,
                "title": "java-memoization-solution",
                "content": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        String[][] mem = new String[str1.length()][str2.length()];\\n        String res = memSol(str1, str2, 0, 0, mem);\\n        \\n        if(res.length() == 0) return str1+str2;\\n        \\n        StringBuilder ans = new StringBuilder();\\n        int i = 0, j = 0;\\n        for(char c: res.toCharArray()){\\n            while(str1.charAt(i) != c) ans.append(str1.charAt(i++));\\n            while(str2.charAt(j) != c) ans.append(str2.charAt(j++));\\n            ans.append(c);\\n            i++; j++;\\n        }\\n        \\n        ans.append(str1.substring(i));\\n        ans.append(str2.substring(j));\\n        return ans.toString();\\n    }\\n    \\n    public String memSol(String s1, String s2, int i, int j, String[][] mem){\\n        if(i >= s1.length() || j >= s2.length()) return \"\";\\n        \\n        if(mem[i][j] != null) return mem[i][j];\\n        \\n        String res = \"\";\\n        if(s1.charAt(i) == s2.charAt(j)){\\n            mem[i][j] = s1.charAt(i) + memSol(s1, s2, i+1, j+1, mem);\\n        }else{\\n            String left = memSol(s1, s2, i+1, j, mem);\\n            String right = memSol(s1, s2, i, j+1, mem);\\n            \\n            mem[i][j] = (left.length() >= right.length()) ? left : right;\\n        }\\n    \\n        return mem[i][j];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        String[][] mem = new String[str1.length()][str2.length()];\\n        String res = memSol(str1, str2, 0, 0, mem);\\n        \\n        if(res.length() == 0) return str1+str2;\\n        \\n        StringBuilder ans = new StringBuilder();\\n        int i = 0, j = 0;\\n        for(char c: res.toCharArray()){\\n            while(str1.charAt(i) != c) ans.append(str1.charAt(i++));\\n            while(str2.charAt(j) != c) ans.append(str2.charAt(j++));\\n            ans.append(c);\\n            i++; j++;\\n        }\\n        \\n        ans.append(str1.substring(i));\\n        ans.append(str2.substring(j));\\n        return ans.toString();\\n    }\\n    \\n    public String memSol(String s1, String s2, int i, int j, String[][] mem){\\n        if(i >= s1.length() || j >= s2.length()) return \"\";\\n        \\n        if(mem[i][j] != null) return mem[i][j];\\n        \\n        String res = \"\";\\n        if(s1.charAt(i) == s2.charAt(j)){\\n            mem[i][j] = s1.charAt(i) + memSol(s1, s2, i+1, j+1, mem);\\n        }else{\\n            String left = memSol(s1, s2, i+1, j, mem);\\n            String right = memSol(s1, s2, i, j+1, mem);\\n            \\n            mem[i][j] = (left.length() >= right.length()) ? left : right;\\n        }\\n    \\n        return mem[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911267,
                "title": "python-solution-using-lcs-clean-code-easy-to-understand",
                "content": "***If you find it useful, please upvote it so that others can find it easily.***\\n\\nIn this solution, the algorithm can be written like this-\\n\\n1. Find `Longest Common Subsequence (LCS)` of the two given string.\\n2. Then we need to adjust the `LCS` with the two given string so that we can create common parts which is stored in `res` variable in this case.\\n3. If the common parts are created, we should have trace which part we was able to count in from the given 2 strings (with `i` and `j` variable).\\n4. then we have our answer by this- `common parts` + `remain part of first string` + `remain part of second string`\\n\\n```\\nclass Solution:\\n    def shortestCommonSupersequence(self, A: str, B: str) -> str:\\n        res, i, j = \"\", 0, 0\\n        for c in self.longestCommonSubsequence(A, B):\\n            while A[i] != c:\\n                res += A[i]\\n                i += 1\\n            while B[j] != c:\\n                res += B[j]\\n                j += 1\\n            res+=c; i+=1; j+=1\\n        return res + A[i:] + B[j:]\\n\\n    def longestCommonSubsequence(self, A: str, B: str) -> str:\\n        n, m = len(A), len(B)\\n        dp = [[\"\" for _ in range(m + 1)] for _ in range(n + 1)]\\n        for i in range(n):\\n            for j in range(m):\\n                if A[i] == B[j]:\\n                    dp[i + 1][j + 1] = dp[i][j] + A[i]\\n                else:\\n                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1], key=len)\\n        #print(dp)\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, A: str, B: str) -> str:\\n        res, i, j = \"\", 0, 0\\n        for c in self.longestCommonSubsequence(A, B):\\n            while A[i] != c:\\n                res += A[i]\\n                i += 1\\n            while B[j] != c:\\n                res += B[j]\\n                j += 1\\n            res+=c; i+=1; j+=1\\n        return res + A[i:] + B[j:]\\n\\n    def longestCommonSubsequence(self, A: str, B: str) -> str:\\n        n, m = len(A), len(B)\\n        dp = [[\"\" for _ in range(m + 1)] for _ in range(n + 1)]\\n        for i in range(n):\\n            for j in range(m):\\n                if A[i] == B[j]:\\n                    dp[i + 1][j + 1] = dp[i][j] + A[i]\\n                else:\\n                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1], key=len)\\n        #print(dp)\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314401,
                "title": "c-without-finding-the-lcs-instead-find-the-solution-directly",
                "content": "You can find the solution directly with DP without finding the LCS first.\\ndp[i][j] is the whole state of the shortest string - with char at (i, j) and pointer to its parent.\\n\\nHere is the idea:\\nif (str1[i] == str2[j]) dp[i][j] = dp[i-1][j-1] + str1[i];\\nelse dp[i][j] = min(dp[i-1][j] + str1[i], dp[i][j-1] + str2[j]) \\n\\nBelow is the code that implements the idea:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // dp[i][j] = \\n    //       if str1[i] == str2[j]: dp[i][j] = dp[i-1][j-1]+str1[i]\\n    //       else min(dp[i-1][j] + str1[i], dp[i][j-1] + str2[j])\\n    \\n    int len[1001][1001];\\n    char ch[1001][1001];\\n    pair<int, int> prev[1001][1001];\\n    \\n    string shortestCommonSupersequence(string str1, string str2) {\\n        memset(len, 0, sizeof(len));\\n        int n = str1.size();\\n        int m = str2.size();\\n        \\n        for (int j = 0; j < m; ++j) {\\n            len[0][j+1] = j+1;\\n            ch[0][j+1] = str2[j];\\n            prev[0][j+1] = {0, j};\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            len[i+1][0] = i+1;\\n            ch[i+1][0] = str1[i];\\n            prev[i+1][0] = {i, 0};\\n            for (int j = 0; j < m; ++j) {\\n                if (str1[i] == str2[j]) {\\n                    len[i+1][j+1] = len[i][j] + 1;\\n                    ch[i+1][j+1] = str1[i];\\n                    prev[i+1][j+1] = {i, j};\\n                } else if (len[i][j+1] < len[i+1][j]) {\\n                    len[i+1][j+1] = len[i][j+1] + 1;\\n                    ch[i+1][j+1] = str1[i];\\n                    prev[i+1][j+1] = {i, j+1};\\n                } else {\\n                    len[i+1][j+1] = len[i+1][j] + 1;\\n                    ch[i+1][j+1] = str2[j];\\n                    prev[i+1][j+1] = {i+1, j};\\n                }\\n            }\\n        }\\n        \\n        string res;\\n        int i = n, j = m;\\n        while (i != 0 || j != 0) {\\n            res.push_back(ch[i][j]);\\n            pair<int,int> x = prev[i][j];\\n            i = x.first;\\n            j = x.second;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // dp[i][j] = \\n    //       if str1[i] == str2[j]: dp[i][j] = dp[i-1][j-1]+str1[i]\\n    //       else min(dp[i-1][j] + str1[i], dp[i][j-1] + str2[j])\\n    \\n    int len[1001][1001];\\n    char ch[1001][1001];\\n    pair<int, int> prev[1001][1001];\\n    \\n    string shortestCommonSupersequence(string str1, string str2) {\\n        memset(len, 0, sizeof(len));\\n        int n = str1.size();\\n        int m = str2.size();\\n        \\n        for (int j = 0; j < m; ++j) {\\n            len[0][j+1] = j+1;\\n            ch[0][j+1] = str2[j];\\n            prev[0][j+1] = {0, j};\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            len[i+1][0] = i+1;\\n            ch[i+1][0] = str1[i];\\n            prev[i+1][0] = {i, 0};\\n            for (int j = 0; j < m; ++j) {\\n                if (str1[i] == str2[j]) {\\n                    len[i+1][j+1] = len[i][j] + 1;\\n                    ch[i+1][j+1] = str1[i];\\n                    prev[i+1][j+1] = {i, j};\\n                } else if (len[i][j+1] < len[i+1][j]) {\\n                    len[i+1][j+1] = len[i][j+1] + 1;\\n                    ch[i+1][j+1] = str1[i];\\n                    prev[i+1][j+1] = {i, j+1};\\n                } else {\\n                    len[i+1][j+1] = len[i+1][j] + 1;\\n                    ch[i+1][j+1] = str2[j];\\n                    prev[i+1][j+1] = {i+1, j};\\n                }\\n            }\\n        }\\n        \\n        string res;\\n        int i = n, j = m;\\n        while (i != 0 || j != 0) {\\n            res.push_back(ch[i][j]);\\n            pair<int,int> x = prev[i][j];\\n            i = x.first;\\n            j = x.second;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933658,
                "title": "obsessed-with-dp-tables-do-a-recursive-solution-first-much-shorter-easier-to-understand-no-lcs",
                "content": "**Basic Idea**\\n```javascript\\nfunction rc (s1, s2, i1 = 0, i2 = 0) {\\n    if (i1 >= s1.length) return s2.slice(i2); // rest of s2\\n    if (i2 >= s2.length) return s1.slice(i1); // rest of s1\\n    \\n    if (s1[i1] === s2[i2]) return s1[i1] + rc(s1, s2, i1 + 1, i2 + 1); // same char, use either\\n    \\n    const useS1 = s1[i1] + rc(s1, s2, i1 + 1, i2); // try use s1\\'s char\\n    const useS2 = s2[i2] + rc(s1, s2, i1, i2 + 1); // try use s2\\'s char\\n    \\n    return useS1.length < useS2.length ? useS1 : useS2; // pick the shorter one\\n}\\n```\\n\\n**ADD MEMOISATION**\\n\\n```javascript\\nfunction rc (s1, s2, i1 = 0, i2 = 0, memo = {}) {\\n    if (i1 >= s1.length) return s2.slice(i2);\\n    if (i2 >= s2.length) return s1.slice(i1);\\n\\n    const memoKey = `${i1},${i2}`;\\n    if (memo[memoKey] !== undefined) return memo[memoKey]\\n    \\n    if (s1[i1] === s2[i2]) return memo[memoKey] = s1[i1] + rc(s1, s2, i1 + 1, i2 + 1, memo); // same char, use either\\n    \\n    const useS1 = s1[i1] + rc(s1, s2, i1 + 1, i2, memo); // try use s1\\'s char\\n    const useS2 = s2[i2] + rc(s1, s2, i1, i2 + 1, memo); // try use s2\\'s char\\n    \\n    return memo[memoKey] = useS1.length < useS2.length ? useS1 : useS2; // pick the shorter one\\n}\\n```\\n\\n**DP table is much easier after recusive solution is there, you don\\'t need to think hard**\\n\\n```javascript\\nfunction dp (s1, s2) {\\n    const dp = Array(s1.length + 1).fill(0).map(\\n        (_, i) => Array(s2.length + 1).fill(\\'\\').map(\\n            (_, j) => {\\n                if (i === 0 && j > 0) return s2.slice(0, j);\\n                if (j === 0 && i > 0) return s1.slice(0, i);\\n                return \\'\\';\\n            }\\n        )\\n    );   \\n    \\n    for (let i = 1; i <= s1.length; i++) {\\n        for (let j = 1; j <= s2.length; j++) {\\n            if (s1[i - 1] === s2[j - 1]) {\\n                dp[i][j] = dp[i - 1][j - 1] + s1[i - 1];\\n            } else {\\n                if (dp[i - 1][j].length < dp[i][j - 1].length) {\\n                    dp[i][j] = dp[i - 1][j] + s1[i - 1];\\n                } else {\\n                    dp[i][j] = dp[i][j - 1] + s2[j - 1];\\n                }\\n            }\\n        }\\n    }\\n\\n    return dp[s1.length][s2.length] \\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\nfunction rc (s1, s2, i1 = 0, i2 = 0) {\\n    if (i1 >= s1.length) return s2.slice(i2); // rest of s2\\n    if (i2 >= s2.length) return s1.slice(i1); // rest of s1\\n    \\n    if (s1[i1] === s2[i2]) return s1[i1] + rc(s1, s2, i1 + 1, i2 + 1); // same char, use either\\n    \\n    const useS1 = s1[i1] + rc(s1, s2, i1 + 1, i2); // try use s1\\'s char\\n    const useS2 = s2[i2] + rc(s1, s2, i1, i2 + 1); // try use s2\\'s char\\n    \\n    return useS1.length < useS2.length ? useS1 : useS2; // pick the shorter one\\n}\\n```\n```javascript\\nfunction rc (s1, s2, i1 = 0, i2 = 0, memo = {}) {\\n    if (i1 >= s1.length) return s2.slice(i2);\\n    if (i2 >= s2.length) return s1.slice(i1);\\n\\n    const memoKey = `${i1},${i2}`;\\n    if (memo[memoKey] !== undefined) return memo[memoKey]\\n    \\n    if (s1[i1] === s2[i2]) return memo[memoKey] = s1[i1] + rc(s1, s2, i1 + 1, i2 + 1, memo); // same char, use either\\n    \\n    const useS1 = s1[i1] + rc(s1, s2, i1 + 1, i2, memo); // try use s1\\'s char\\n    const useS2 = s2[i2] + rc(s1, s2, i1, i2 + 1, memo); // try use s2\\'s char\\n    \\n    return memo[memoKey] = useS1.length < useS2.length ? useS1 : useS2; // pick the shorter one\\n}\\n```\n```javascript\\nfunction dp (s1, s2) {\\n    const dp = Array(s1.length + 1).fill(0).map(\\n        (_, i) => Array(s2.length + 1).fill(\\'\\').map(\\n            (_, j) => {\\n                if (i === 0 && j > 0) return s2.slice(0, j);\\n                if (j === 0 && i > 0) return s1.slice(0, i);\\n                return \\'\\';\\n            }\\n        )\\n    );   \\n    \\n    for (let i = 1; i <= s1.length; i++) {\\n        for (let j = 1; j <= s2.length; j++) {\\n            if (s1[i - 1] === s2[j - 1]) {\\n                dp[i][j] = dp[i - 1][j - 1] + s1[i - 1];\\n            } else {\\n                if (dp[i - 1][j].length < dp[i][j - 1].length) {\\n                    dp[i][j] = dp[i - 1][j] + s1[i - 1];\\n                } else {\\n                    dp[i][j] = dp[i][j - 1] + s2[j - 1];\\n                }\\n            }\\n        }\\n    }\\n\\n    return dp[s1.length][s2.length] \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2095136,
                "title": "lord-aditya-verma-lcs-approach-easy-c-solution",
                "content": "```\\nstring shortestCommonSupersequence(string str1, string str2) {\\n        int n=str1.size();\\n        int m=str2.size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j]=0;\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                else \\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        string ans=\"\";\\n        int i=n,j=m;\\n        while(i>0 && j>0)\\n        {\\n            if(str1[i-1]==str2[j-1])\\n            {\\n                ans.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else\\n            {\\n                if(dp[i-1][j]>dp[i][j-1])\\n                {\\n                    ans.push_back(str1[i-1]);\\n                    i--;\\n                }\\n                else\\n                {\\n                    ans.push_back(str2[j-1]);\\n                    j--;\\n                }\\n            }\\n                \\n        }\\n        while(i>0)\\n        {\\n            ans.push_back(str1[i-1]);\\n            i--;\\n        }\\n        while(j>0)\\n        {\\n            ans.push_back(str2[j-1]);\\n            j--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nstring shortestCommonSupersequence(string str1, string str2) {\\n        int n=str1.size();\\n        int m=str2.size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j]=0;\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                else \\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        string ans=\"\";\\n        int i=n,j=m;\\n        while(i>0 && j>0)\\n        {\\n            if(str1[i-1]==str2[j-1])\\n            {\\n                ans.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else\\n            {\\n                if(dp[i-1][j]>dp[i][j-1])\\n                {\\n                    ans.push_back(str1[i-1]);\\n                    i--;\\n                }\\n                else\\n                {\\n                    ans.push_back(str2[j-1]);\\n                    j--;\\n                }\\n            }\\n                \\n        }\\n        while(i>0)\\n        {\\n            ans.push_back(str1[i-1]);\\n            i--;\\n        }\\n        while(j>0)\\n        {\\n            ans.push_back(str2[j-1]);\\n            j--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1440589,
                "title": "javascript-dynamic-programming-solution-explained",
                "content": "**Explanation** : This question is a combination of two other questions of dynamic programming. First one is **Printing Longest Common Subsequence** and second one was to **calculate the length of shortest common supersequence**.\\n\\n![image](https://assets.leetcode.com/users/images/91ab37b1-9e34-442d-81f2-99486c2e8216_1630587679.32531.png)\\n\\n\\nPrinting Longest common subsequence : In this question, we had to calculate the length of Longest common subsequence for every possible combination of str1 and str2 and then we get the lengths. After this, we traverse the grid from the bottom right corner like we did in this question\\n\\nbut the catch in this question is to print the shortest common supersequence and for that we will print those which are same in both the strings and most importantly, **we will also print those which are not common because here we are not finding the subsequence but the supersequence**. Rest of the code is almost same from printing LCS.\\n\\nPS: If you liked the approach and explanation of this question, do upvote this post ! It really motivates the author to post more solutions.\\n\\n```\\n/**\\n * @param {string} str1\\n * @param {string} str2\\n * @return {string}\\n */\\nvar shortestCommonSupersequence = function(str1, str2) {\\n    \\n    let dp = [];\\n    \\n    for(let rctr = 0 ; rctr <= str1.length ; rctr ++){\\n        let arr = [];\\n        \\n        for(let cctr = 0 ; cctr <= str2.length ; cctr ++) arr.push(0);\\n        \\n        dp.push(arr);\\n    }\\n    \\n    for(let row = 1 ; row <= str1.length ; row ++)\\n        for(let col = 1 ; col <= str2.length ; col ++) {\\n            \\n            if(str1[row-1] === str2[col-1])\\n                dp[row][col] = 1 + dp[row-1][col-1];\\n            else\\n                dp[row][col] = Math.max(dp[row-1][col],dp[row][col-1]);\\n            \\n        }\\n    \\n    let row = str1.length, col = str2.length ;\\n    \\n    let ans = \"\";\\n    \\n    while( row > 0 && col > 0 ) {\\n        \\n        if(str1[row-1] === str2[col-1]) {\\n            ans += str1[row-1];\\n            row -=1;\\n            col -=1;\\n            continue;\\n        }\\n        \\n        if(dp[row-1][col] > dp[row][col-1]) {\\n            ans += str1[row-1];\\n            row-=1;\\n        }\\n        else {\\n            ans+= str2[col-1]\\n            col -=1\\n        }\\n    }\\n    \\n    while(row > 0) {\\n        ans += str1[row-1]\\n        row -=1;\\n    }\\n    \\n    while(col > 0) {\\n        ans += str2[col-1];\\n        col -=1;\\n    }\\n    \\n    ans = ans.split(\"\");\\n    \\n    ans = ans.reverse()\\n    \\n    ans = ans.join(\"\");\\n    \\n    return ans;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {string} str1\\n * @param {string} str2\\n * @return {string}\\n */\\nvar shortestCommonSupersequence = function(str1, str2) {\\n    \\n    let dp = [];\\n    \\n    for(let rctr = 0 ; rctr <= str1.length ; rctr ++){\\n        let arr = [];\\n        \\n        for(let cctr = 0 ; cctr <= str2.length ; cctr ++) arr.push(0);\\n        \\n        dp.push(arr);\\n    }\\n    \\n    for(let row = 1 ; row <= str1.length ; row ++)\\n        for(let col = 1 ; col <= str2.length ; col ++) {\\n            \\n            if(str1[row-1] === str2[col-1])\\n                dp[row][col] = 1 + dp[row-1][col-1];\\n            else\\n                dp[row][col] = Math.max(dp[row-1][col],dp[row][col-1]);\\n            \\n        }\\n    \\n    let row = str1.length, col = str2.length ;\\n    \\n    let ans = \"\";\\n    \\n    while( row > 0 && col > 0 ) {\\n        \\n        if(str1[row-1] === str2[col-1]) {\\n            ans += str1[row-1];\\n            row -=1;\\n            col -=1;\\n            continue;\\n        }\\n        \\n        if(dp[row-1][col] > dp[row][col-1]) {\\n            ans += str1[row-1];\\n            row-=1;\\n        }\\n        else {\\n            ans+= str2[col-1]\\n            col -=1\\n        }\\n    }\\n    \\n    while(row > 0) {\\n        ans += str1[row-1]\\n        row -=1;\\n    }\\n    \\n    while(col > 0) {\\n        ans += str2[col-1];\\n        col -=1;\\n    }\\n    \\n    ans = ans.split(\"\");\\n    \\n    ans = ans.reverse()\\n    \\n    ans = ans.join(\"\");\\n    \\n    return ans;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820908,
                "title": "generate-lcs-then-make-super-string-stepbystep",
                "content": "```\\nstring shortestCommonSupersequence(string a, string b) {\\n        \\n        int n = a.length();\\n        int m = b.length();\\n        \\n        vector<vector<int>> dp(n+1 , vector<int>(m+1));\\n        \\n        // making LCS table\\n        for(int i=1 ; i<=n ; i++)\\n        {\\n            for(int j=1 ; j<=m ; j++)\\n            {\\n                if(a[i-1] == b[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+1;\\n                else\\n                    dp[i][j] = max(dp[i][j-1] , dp[i-1][j]);\\n            }\\n        }\\n        \\n        int i = n , j = m , c = dp[n][m];\\n        string s , ans;\\n        \\n        // now we need to backtrack from last cell to find our LCS\\n        while(i and j)\\n        {\\n            if(a[i-1] == b[j-1])\\n                s+=a[i-1] , i-- , j--;\\n            else\\n            {\\n                (dp[i-1][j] > dp[i][j-1]) ? i-- : j--;\\n            }\\n        }\\n        reverse(s.begin() , s.end());   // since LCSstring s would be in reverse order\\n        \\n        int k = 0;\\n        i = 0;\\n        j = 0;\\n        \\n        // now we make our superstring\\n        while(i<n and j<m and k<s.length())\\n        {\\n            if(a[i] == b[j] and a[i] == s[k])\\n                ans+=s[k] , i++ , j++ , k++;\\n            else\\n            {\\n                (a[i] == s[k]) ? ans+=b[j++] : ans+=a[i++];\\n            }\\n        }\\n        \\n        // assume that in the end some character is left in stringA , stringB and append those \\n        // remaining characters\\n        while(i < n)\\n            ans+=a[i++];\\n        while(j < m)\\n            ans+=b[j++];\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring shortestCommonSupersequence(string a, string b) {\\n        \\n        int n = a.length();\\n        int m = b.length();\\n        \\n        vector<vector<int>> dp(n+1 , vector<int>(m+1));\\n        \\n        // making LCS table\\n        for(int i=1 ; i<=n ; i++)\\n        {\\n            for(int j=1 ; j<=m ; j++)\\n            {\\n                if(a[i-1] == b[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+1;\\n                else\\n                    dp[i][j] = max(dp[i][j-1] , dp[i-1][j]);\\n            }\\n        }\\n        \\n        int i = n , j = m , c = dp[n][m];\\n        string s , ans;\\n        \\n        // now we need to backtrack from last cell to find our LCS\\n        while(i and j)\\n        {\\n            if(a[i-1] == b[j-1])\\n                s+=a[i-1] , i-- , j--;\\n            else\\n            {\\n                (dp[i-1][j] > dp[i][j-1]) ? i-- : j--;\\n            }\\n        }\\n        reverse(s.begin() , s.end());   // since LCSstring s would be in reverse order\\n        \\n        int k = 0;\\n        i = 0;\\n        j = 0;\\n        \\n        // now we make our superstring\\n        while(i<n and j<m and k<s.length())\\n        {\\n            if(a[i] == b[j] and a[i] == s[k])\\n                ans+=s[k] , i++ , j++ , k++;\\n            else\\n            {\\n                (a[i] == s[k]) ? ans+=b[j++] : ans+=a[i++];\\n            }\\n        }\\n        \\n        // assume that in the end some character is left in stringA , stringB and append those \\n        // remaining characters\\n        while(i < n)\\n            ans+=a[i++];\\n        while(j < m)\\n            ans+=b[j++];\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1440588,
                "title": "cpp-java-concise-sol-n-dp",
                "content": "This is a variation of **longest common subsequence problem** but this time we need to output the shortest supersequence between them. So after filling our dp[][] with the length of the common subsequence at a given instance. \\nThe idea is very simple. The result string should contain all characters of str1 and str2 excluding the common ones.\\n = Str1.length() + Str2.length() - LCS\\nbecause characters appearing in LCS are coming twice in the result. So to find the shortest we will exclude them.\\n\\nSo if str1[idx] = str2[idx2] we will add only single character as it is common And we need to make sure both our indexes would become zero as we need to find the supersequence. At the end reversing the string as we are taking index from last. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> lcs(string& s1, string &s2)\\n    {\\n        vector<vector<int>> dp(s1.size() + 1, vector<int>(s2.size() + 1, 0));\\n        \\n        for(int idx = 0; idx < s1.size() + 1; idx++)\\n            dp[idx][0] = 0;\\n        \\n        for(int idx = 0; idx < s2.size() + 1; idx++)\\n            dp[0][idx] = 0;\\n        \\n        for(int row = 1; row < s1.size() + 1; row++)\\n        {\\n            for(int col = 1; col < s2.size() + 1; col++)\\n            {\\n                if(s1[row - 1] == s2[col - 1])\\n                    dp[row][col] = 1 + dp[row - 1][col - 1];\\n                \\n                else\\n                    dp[row][col] = max(dp[row - 1][col] , dp[row][col - 1]);\\n            }\\n        }\\n        \\n        return dp;\\n    }\\n    \\n    string shortestCommonSupersequence(string& str1, string &str2)\\n    {\\n         vector<vector<int>> dp = lcs(str1, str2);\\n   \\n         int idx1 = str1.size(), idx2 = str2.size();\\n         string ans = \"\";\\n        \\n         while(idx1 > 0 and idx2 > 0)\\n         {\\n             if(str1[idx1 - 1] == str2[idx2 - 1]){\\n                 ans.push_back(str1[idx1 - 1]);\\n                 idx1--; idx2--; \\n             }\\n             \\n             else{\\n                 if(dp[idx1 - 1][idx2] > dp[idx1][idx2 - 1]){\\n                     ans.push_back(str1[idx1 - 1]);\\n                     idx1 --;\\n                 }\\n                 else{\\n                     ans.push_back(str2[idx2 - 1]);\\n                     idx2--;\\n                 }\\n             }\\n         }\\n        \\n         while(idx1 != 0)\\n         {\\n             ans.push_back(str1[idx1 - 1]);\\n             idx1--;\\n         }\\n        \\n          while(idx2 != 0)\\n         {\\n             ans.push_back(str2[idx2 - 1]);\\n             idx2--;\\n         }\\n        \\n         reverse(ans.begin(), ans.end());\\n        \\n         return ans;\\n    }\\n};\\n```\\n\\nSame Implementation using Array-->\\n\\n```\\nclass Solution {\\npublic:  \\n    string shortestCommonSupersequence(string str1, string str2)\\n    {\\n        int dp[str1.length() + 1][str2.length() + 1];\\n        \\n        for(int idx = 0; idx < str1.size() + 1; idx++)\\n            dp[idx][0] = 0;\\n        \\n        for(int idx = 0; idx < str2.size() + 1; idx++)\\n            dp[0][idx] = 0;\\n        \\n        for(int row = 1; row < str1.size() + 1; row++)\\n        {\\n            for(int col = 1; col < str2.size() + 1; col++)\\n            {\\n                if(str1[row - 1] == str2[col - 1])\\n                    dp[row][col] = 1 + dp[row - 1][col - 1];\\n                \\n                else\\n                    dp[row][col] = max(dp[row - 1][col], dp[row][col - 1]);\\n            }\\n        }\\n        \\n        int idx1 = str1.size() , idx2 = str2.size();\\n        string ans = \"\";\\n        \\n        while(idx1 > 0 and idx2 > 0)\\n        {\\n            if(str1[idx1 - 1] == str2[idx2 - 1])\\n            {\\n                ans.push_back(str1[idx1 - 1]);\\n                idx1--; idx2--;\\n            }\\n            \\n            else{\\n               \\n              if(dp[idx1 - 1][idx2] > dp[idx1][idx2 - 1]){\\n                  ans.push_back(str1[idx1 - 1]);\\n                  idx1--;\\n              }\\n              else{\\n                  ans.push_back(str2[idx2 - 1]);\\n                  idx2--;\\n              }\\n            }\\n        }\\n        \\n        while(idx1 > 0)\\n        {\\n            ans.push_back(str1[idx1 - 1]);\\n            idx1--;\\n        }\\n        \\n        while(idx2 > 0)\\n        {\\n            ans.push_back(str2[idx2 - 1]);\\n            idx2--;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nSame code in Java, this time reversing using string builder as i was not able to find inbuilt reverse function for String if anyone knows, do share in the comment section. \\n\\n```\\nclass Solution {\\n     public String reverseIt(String str)\\n     {\\n          int i, len = str.length();\\n         \\n          StringBuilder dest = new StringBuilder(len);\\n\\n          for (i = (len - 1); i >= 0; i--)\\n              dest.append(str.charAt(i));\\n         \\n           return dest.toString();\\n    }\\n    \\n    public String shortestCommonSupersequence(String str1, String str2)\\n    {\\n        int dp[][] = new int[str1.length() + 1][str2.length() + 1];\\n        \\n        for(int row = 1; row < str1.length() + 1; row++)\\n        {\\n            for(int col = 1; col < str2.length() + 1; col++)\\n            {\\n                if(str1.charAt(row - 1) == str2.charAt(col - 1))\\n                   dp[row][col] = 1 + dp[row - 1][col - 1];\\n                \\n                else\\n                   dp[row][col] = Math.max(dp[row - 1][col], dp[row][col - 1]);\\n            }\\n        }\\n        \\n        int idx1 = str1.length(), idx2 = str2.length();\\n        String ans = \"\";\\n        \\n        while(idx1 > 0 && idx2 > 0)\\n        {\\n            if(str1.charAt(idx1 - 1) == str2.charAt(idx2 - 1))\\n            {\\n                ans += str1.charAt(idx1 - 1);\\n                idx1--; idx2--;\\n            }\\n            \\n            else{\\n                if(dp[idx1 - 1][idx2] > dp[idx1][idx2 - 1]){\\n                    ans += str1.charAt(idx1 - 1);\\n                    idx1--;\\n                }\\n                \\n                else{\\n                    ans += str2.charAt(idx2 - 1);\\n                    idx2--;\\n                }\\n            }\\n        }\\n        \\n         while(idx1 > 0)\\n         {\\n            ans += str1.charAt(idx1 - 1);\\n            idx1--;\\n         }\\n        \\n        while(idx2 > 0)\\n        {\\n            ans += str2.charAt(idx2 - 1);\\n            idx2--;\\n        }\\n        \\n        String ans1 = reverseIt(ans);\\n        \\n        return ans1;\\n    }\\n}\\n```\\n\\nPlease feel free to comment regarding any query. Do upvote.\\uD83D\\uDE43\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> lcs(string& s1, string &s2)\\n    {\\n        vector<vector<int>> dp(s1.size() + 1, vector<int>(s2.size() + 1, 0));\\n        \\n        for(int idx = 0; idx < s1.size() + 1; idx++)\\n            dp[idx][0] = 0;\\n        \\n        for(int idx = 0; idx < s2.size() + 1; idx++)\\n            dp[0][idx] = 0;\\n        \\n        for(int row = 1; row < s1.size() + 1; row++)\\n        {\\n            for(int col = 1; col < s2.size() + 1; col++)\\n            {\\n                if(s1[row - 1] == s2[col - 1])\\n                    dp[row][col] = 1 + dp[row - 1][col - 1];\\n                \\n                else\\n                    dp[row][col] = max(dp[row - 1][col] , dp[row][col - 1]);\\n            }\\n        }\\n        \\n        return dp;\\n    }\\n    \\n    string shortestCommonSupersequence(string& str1, string &str2)\\n    {\\n         vector<vector<int>> dp = lcs(str1, str2);\\n   \\n         int idx1 = str1.size(), idx2 = str2.size();\\n         string ans = \"\";\\n        \\n         while(idx1 > 0 and idx2 > 0)\\n         {\\n             if(str1[idx1 - 1] == str2[idx2 - 1]){\\n                 ans.push_back(str1[idx1 - 1]);\\n                 idx1--; idx2--; \\n             }\\n             \\n             else{\\n                 if(dp[idx1 - 1][idx2] > dp[idx1][idx2 - 1]){\\n                     ans.push_back(str1[idx1 - 1]);\\n                     idx1 --;\\n                 }\\n                 else{\\n                     ans.push_back(str2[idx2 - 1]);\\n                     idx2--;\\n                 }\\n             }\\n         }\\n        \\n         while(idx1 != 0)\\n         {\\n             ans.push_back(str1[idx1 - 1]);\\n             idx1--;\\n         }\\n        \\n          while(idx2 != 0)\\n         {\\n             ans.push_back(str2[idx2 - 1]);\\n             idx2--;\\n         }\\n        \\n         reverse(ans.begin(), ans.end());\\n        \\n         return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:  \\n    string shortestCommonSupersequence(string str1, string str2)\\n    {\\n        int dp[str1.length() + 1][str2.length() + 1];\\n        \\n        for(int idx = 0; idx < str1.size() + 1; idx++)\\n            dp[idx][0] = 0;\\n        \\n        for(int idx = 0; idx < str2.size() + 1; idx++)\\n            dp[0][idx] = 0;\\n        \\n        for(int row = 1; row < str1.size() + 1; row++)\\n        {\\n            for(int col = 1; col < str2.size() + 1; col++)\\n            {\\n                if(str1[row - 1] == str2[col - 1])\\n                    dp[row][col] = 1 + dp[row - 1][col - 1];\\n                \\n                else\\n                    dp[row][col] = max(dp[row - 1][col], dp[row][col - 1]);\\n            }\\n        }\\n        \\n        int idx1 = str1.size() , idx2 = str2.size();\\n        string ans = \"\";\\n        \\n        while(idx1 > 0 and idx2 > 0)\\n        {\\n            if(str1[idx1 - 1] == str2[idx2 - 1])\\n            {\\n                ans.push_back(str1[idx1 - 1]);\\n                idx1--; idx2--;\\n            }\\n            \\n            else{\\n               \\n              if(dp[idx1 - 1][idx2] > dp[idx1][idx2 - 1]){\\n                  ans.push_back(str1[idx1 - 1]);\\n                  idx1--;\\n              }\\n              else{\\n                  ans.push_back(str2[idx2 - 1]);\\n                  idx2--;\\n              }\\n            }\\n        }\\n        \\n        while(idx1 > 0)\\n        {\\n            ans.push_back(str1[idx1 - 1]);\\n            idx1--;\\n        }\\n        \\n        while(idx2 > 0)\\n        {\\n            ans.push_back(str2[idx2 - 1]);\\n            idx2--;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n     public String reverseIt(String str)\\n     {\\n          int i, len = str.length();\\n         \\n          StringBuilder dest = new StringBuilder(len);\\n\\n          for (i = (len - 1); i >= 0; i--)\\n              dest.append(str.charAt(i));\\n         \\n           return dest.toString();\\n    }\\n    \\n    public String shortestCommonSupersequence(String str1, String str2)\\n    {\\n        int dp[][] = new int[str1.length() + 1][str2.length() + 1];\\n        \\n        for(int row = 1; row < str1.length() + 1; row++)\\n        {\\n            for(int col = 1; col < str2.length() + 1; col++)\\n            {\\n                if(str1.charAt(row - 1) == str2.charAt(col - 1))\\n                   dp[row][col] = 1 + dp[row - 1][col - 1];\\n                \\n                else\\n                   dp[row][col] = Math.max(dp[row - 1][col], dp[row][col - 1]);\\n            }\\n        }\\n        \\n        int idx1 = str1.length(), idx2 = str2.length();\\n        String ans = \"\";\\n        \\n        while(idx1 > 0 && idx2 > 0)\\n        {\\n            if(str1.charAt(idx1 - 1) == str2.charAt(idx2 - 1))\\n            {\\n                ans += str1.charAt(idx1 - 1);\\n                idx1--; idx2--;\\n            }\\n            \\n            else{\\n                if(dp[idx1 - 1][idx2] > dp[idx1][idx2 - 1]){\\n                    ans += str1.charAt(idx1 - 1);\\n                    idx1--;\\n                }\\n                \\n                else{\\n                    ans += str2.charAt(idx2 - 1);\\n                    idx2--;\\n                }\\n            }\\n        }\\n        \\n         while(idx1 > 0)\\n         {\\n            ans += str1.charAt(idx1 - 1);\\n            idx1--;\\n         }\\n        \\n        while(idx2 > 0)\\n        {\\n            ans += str2.charAt(idx2 - 1);\\n            idx2--;\\n        }\\n        \\n        String ans1 = reverseIt(ans);\\n        \\n        return ans1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339009,
                "title": "hard-made-easy-with-trippy-s-coding-approach",
                "content": "# Intuition\\nUSING LCS TO FIND SHORTEST COMMON SUPERSEQUENCE.\\nHERE I AM PRESENTING JAVA SOLUTION \\nC++ WILL BE REPLICA OF IT\\n\\n# Approach\\nTRIPPY\\'S SS APPROACH\\nJUST **SMILE** AND **SOLVE** \\uD83D\\uDE0E\\uD83D\\uDE0E\\n\\n# Complexity\\nNOTHING COMLEX HERE\\n\\n# PLEASE UPVOTE\\nPLEASE UPVOTE IF I HELPED YOU\\nTHANK YOU.\\nKEEP IT UP.\\nLOVE FOR YOU BY TRIPPY \\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F\\n\\n# Code\\n```\\nclass Solution {\\n    int arr[][] = new int[1001][1001];\\n    public String shortestCommonSupersequence(String text1, String text2) {\\n        int l = text1.length(), l2 = text2.length();\\n        for (int i = 1; i <= l; i++) {\\n            for (int j = 1; j <= l2; j++) {\\n                arr[i][j] = -1;\\n            }\\n        }\\n        int x = l + l2 - maxi(text1, text2, l, l2);\\n        String ans = \"\";\\n        int i = l, j = l2;\\n        while (i > 0 && j > 0) {\\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\\n                ans = \"\" + text1.charAt(i - 1) + ans;\\n                i--;\\n                j--;\\n            } else if (arr[i - 1][j] > arr[i][j - 1]) {\\n                ans = \"\" + text1.charAt(i - 1) + ans;\\n                i--;\\n            } else {\\n                ans = \"\" + text2.charAt(j - 1) + ans;\\n                j--;\\n            }\\n        }\\n        while (i > 0) {\\n            ans = \"\" + text1.charAt(i - 1) + ans;\\n            i--;\\n        }\\n        while (j > 0) {\\n            ans = \"\" + text2.charAt(j - 1) + ans;\\n            j--;\\n        }\\n        return ans;\\n\\n    }\\n        //PLEASE UPVOTE.\\n\\n    public int maxi(String s, String s2, int l, int l2) {\\n        if (l == 0 || l2 == 0)\\n            return 0;\\n        if (arr[l][l2] != -1)\\n            return arr[l][l2];\\n\\n        if (s.charAt(l - 1) == s2.charAt(l2 - 1)) {\\n            arr[l][l2] = 1 + maxi(s, s2, l - 1, l2 - 1);\\n            return arr[l][l2];\\n        }\\n        return arr[l][l2] = Math.max(maxi(s, s2, l, l2 - 1), maxi(s, s2, l - 1, l2));\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int arr[][] = new int[1001][1001];\\n    public String shortestCommonSupersequence(String text1, String text2) {\\n        int l = text1.length(), l2 = text2.length();\\n        for (int i = 1; i <= l; i++) {\\n            for (int j = 1; j <= l2; j++) {\\n                arr[i][j] = -1;\\n            }\\n        }\\n        int x = l + l2 - maxi(text1, text2, l, l2);\\n        String ans = \"\";\\n        int i = l, j = l2;\\n        while (i > 0 && j > 0) {\\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\\n                ans = \"\" + text1.charAt(i - 1) + ans;\\n                i--;\\n                j--;\\n            } else if (arr[i - 1][j] > arr[i][j - 1]) {\\n                ans = \"\" + text1.charAt(i - 1) + ans;\\n                i--;\\n            } else {\\n                ans = \"\" + text2.charAt(j - 1) + ans;\\n                j--;\\n            }\\n        }\\n        while (i > 0) {\\n            ans = \"\" + text1.charAt(i - 1) + ans;\\n            i--;\\n        }\\n        while (j > 0) {\\n            ans = \"\" + text2.charAt(j - 1) + ans;\\n            j--;\\n        }\\n        return ans;\\n\\n    }\\n        //PLEASE UPVOTE.\\n\\n    public int maxi(String s, String s2, int l, int l2) {\\n        if (l == 0 || l2 == 0)\\n            return 0;\\n        if (arr[l][l2] != -1)\\n            return arr[l][l2];\\n\\n        if (s.charAt(l - 1) == s2.charAt(l2 - 1)) {\\n            arr[l][l2] = 1 + maxi(s, s2, l - 1, l2 - 1);\\n            return arr[l][l2];\\n        }\\n        return arr[l][l2] = Math.max(maxi(s, s2, l, l2 - 1), maxi(s, s2, l - 1, l2));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289757,
                "title": "python-solution-dp-aditya-verma-approach-bottom-up",
                "content": "PLEASE UPVOTE if you like \\uD83D\\uDE01 If you have any question, feel free to ask.\\n# Intuition\\nUse Longest Common Subsequence to generated matrix and then matrix to get result string\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M) + O(N+M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        #Normal longest common subsequence\\n        n,m=len(str1),len(str2)\\n        #initialization\\n        dp=[[0 for i in range(m+1)]for j in range(n+1)]\\n        #filing the complete matrix\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if str1[i-1]==str2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]+1\\n                else:\\n                    dp[i][j]=max(dp[i][j-1],dp[i-1][j])\\n        #now making supersequence from matrix\\n        i,j=n,m\\n        res=\"\"\\n        #including common element once and rest too\\n        while i>0 and j>0:\\n            if str1[i-1]==str2[j-1]:\\n                res+=str1[i-1]\\n                i-=1\\n                j-=1\\n            else:\\n                if dp[i-1][j]>dp[i][j-1]:\\n                    res+=str1[i-1]\\n                    i-=1\\n                else:\\n                    res+=str2[j-1]\\n                    j-=1\\n        while i>0:\\n            res+=str1[i-1]\\n            i-=1\\n        while j>0:\\n            res+=str2[j-1]\\n            j-=1\\n        #reversing string\\n        return res[::-1]\\n            \\n```\\n![cat.jpeg](https://assets.leetcode.com/users/images/b9748c6b-026c-4b85-b505-e39f9a1ee24d_1678651587.8180952.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        #Normal longest common subsequence\\n        n,m=len(str1),len(str2)\\n        #initialization\\n        dp=[[0 for i in range(m+1)]for j in range(n+1)]\\n        #filing the complete matrix\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if str1[i-1]==str2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]+1\\n                else:\\n                    dp[i][j]=max(dp[i][j-1],dp[i-1][j])\\n        #now making supersequence from matrix\\n        i,j=n,m\\n        res=\"\"\\n        #including common element once and rest too\\n        while i>0 and j>0:\\n            if str1[i-1]==str2[j-1]:\\n                res+=str1[i-1]\\n                i-=1\\n                j-=1\\n            else:\\n                if dp[i-1][j]>dp[i][j-1]:\\n                    res+=str1[i-1]\\n                    i-=1\\n                else:\\n                    res+=str2[j-1]\\n                    j-=1\\n        while i>0:\\n            res+=str1[i-1]\\n            i-=1\\n        while j>0:\\n            res+=str2[j-1]\\n            j-=1\\n        #reversing string\\n        return res[::-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101314,
                "title": "c-different-solution-than-all-posted-here",
                "content": "This solution is giving TLE on 47th case. Passed on 46/47 cases. It was intuitive. \\nPosting it here just for sharing.\\n\\n```\\n//dp[i][j] = shortest common supersequence with s1[idx1...s1.length] and s2[idx2.....s2.length]\\n\\nclass Solution {\\npublic: \\n    string solve(string &s1,string &s2,int idx1,int idx2,vector<vector<string> > &dp){\\n        if(dp[idx1][idx2]!=\"?\")\\n            return dp[idx1][idx2];\\n        \\n        if(idx1==s1.length())\\n            return dp[idx1][idx2]=s2.substr(idx2);\\n        if(idx2==s2.length())\\n            return dp[idx1][idx2]=s1.substr(idx1);\\n        if(s1[idx1]==s2[idx2])\\n            return dp[idx1][idx2]=string(1,s1[idx1])+solve(s1,s2,idx1+1,idx2+1,dp);\\n        \\n        string new_s1=string(1,s1[idx1])+solve(s1,s2,idx1+1,idx2,dp);\\n        string new_s2=string(1,s2[idx2])+solve(s1,s2,idx1,idx2+1,dp);\\n        \\n        if(new_s1.length()<new_s2.length())\\n            return dp[idx1][idx2]=new_s1;\\n        return dp[idx1][idx2]=new_s2;\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int len1=str1.length();\\n        int len2=str2.length();\\n        if(len1==0)\\n            return str2;\\n        if(len2==0)\\n            return str1;\\n        vector<vector<string> >dp(len1+1,vector<string>(len2+1,\"?\"));\\n        return solve(str1,str2,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//dp[i][j] = shortest common supersequence with s1[idx1...s1.length] and s2[idx2.....s2.length]\\n\\nclass Solution {\\npublic: \\n    string solve(string &s1,string &s2,int idx1,int idx2,vector<vector<string> > &dp){\\n        if(dp[idx1][idx2]!=\"?\")\\n            return dp[idx1][idx2];\\n        \\n        if(idx1==s1.length())\\n            return dp[idx1][idx2]=s2.substr(idx2);\\n        if(idx2==s2.length())\\n            return dp[idx1][idx2]=s1.substr(idx1);\\n        if(s1[idx1]==s2[idx2])\\n            return dp[idx1][idx2]=string(1,s1[idx1])+solve(s1,s2,idx1+1,idx2+1,dp);\\n        \\n        string new_s1=string(1,s1[idx1])+solve(s1,s2,idx1+1,idx2,dp);\\n        string new_s2=string(1,s2[idx2])+solve(s1,s2,idx1,idx2+1,dp);\\n        \\n        if(new_s1.length()<new_s2.length())\\n            return dp[idx1][idx2]=new_s1;\\n        return dp[idx1][idx2]=new_s2;\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int len1=str1.length();\\n        int len2=str2.length();\\n        if(len1==0)\\n            return str2;\\n        if(len2==0)\\n            return str1;\\n        vector<vector<string> >dp(len1+1,vector<string>(len2+1,\"?\"));\\n        return solve(str1,str2,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940346,
                "title": "dp-memoization-approach-using-lcs",
                "content": "```\\n// Abhijit Dey\\nclass Solution {\\npublic:\\n    string s1,s2;\\n    int dp[1005][1005];\\n    int lcs(int i,int j)\\n    {\\n        int ans=0;\\n        if(i==s1.length() or j==s2.length())return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s1[i]==s2[j])\\n            ans=1+lcs(i+1,j+1);\\n        else\\n            ans=max(lcs(i+1,j), lcs(i,j+1));\\n        return dp[i][j]=ans;\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) \\n    {\\n        s1=str1;\\n        s2=str2;\\n        memset(dp,-1,sizeof(dp));\\n        lcs(0,0);\\n        int i=0,j=0;\\n        string res;\\n        while(i<str1.length() && j<str2.length())\\n        {\\n            if(str1[i]==str2[j])\\n            {\\n                res+=str1[i];\\n                i++;\\n                j++;\\n            }\\n            else if(dp[i+1][j]<dp[i][j+1])\\n            {\\n                res+=str2[j];\\n                j++;\\n            }\\n            else \\n            {\\n                res+=str1[i];\\n                i++;\\n            }\\n        }\\n        while(i<str1.length())\\n        {\\n            res+=str1[i];\\n            i++;\\n        }\\n        while(j<str2.length())\\n        {\\n            res+=str2[j];\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// Abhijit Dey\\nclass Solution {\\npublic:\\n    string s1,s2;\\n    int dp[1005][1005];\\n    int lcs(int i,int j)\\n    {\\n        int ans=0;\\n        if(i==s1.length() or j==s2.length())return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s1[i]==s2[j])\\n            ans=1+lcs(i+1,j+1);\\n        else\\n            ans=max(lcs(i+1,j), lcs(i,j+1));\\n        return dp[i][j]=ans;\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) \\n    {\\n        s1=str1;\\n        s2=str2;\\n        memset(dp,-1,sizeof(dp));\\n        lcs(0,0);\\n        int i=0,j=0;\\n        string res;\\n        while(i<str1.length() && j<str2.length())\\n        {\\n            if(str1[i]==str2[j])\\n            {\\n                res+=str1[i];\\n                i++;\\n                j++;\\n            }\\n            else if(dp[i+1][j]<dp[i][j+1])\\n            {\\n                res+=str2[j];\\n                j++;\\n            }\\n            else \\n            {\\n                res+=str1[i];\\n                i++;\\n            }\\n        }\\n        while(i<str1.length())\\n        {\\n            res+=str1[i];\\n            i++;\\n        }\\n        while(j<str2.length())\\n        {\\n            res+=str2[j];\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453374,
                "title": "java-dp-shortest-common-supersequence",
                "content": "Problem Statement : [1092. Shortest Common Supersequence](https://leetcode.com/problems/shortest-common-supersequence/)\\n\\nSupersequence of two strings ``` a = \"abbac\" ```  ``` b = \"babcz\" ``` will be ``` \"ababacz\" ```. Means, **a** and **b** should be *subsequence* of supersequence. \\n\\nTo find Supersequence we can use Longest Common Subsequence (LCS).\\n**Intuition:** in supersequence we store LCS once and all the character left in the string 1 and 2.\\n```\\nclass Solution {\\n    int[][] dp;\\n    \\n\\t// method to fill dp 2D array with length of LCS\\n    int lcs(String str1, String str2, int n, int m) {\\n        for(int i=1; i<=n; i++){\\n            for(int j=1; j<=m; j++){\\n                if(str1.charAt(i-1)==str2.charAt(j-1)){\\n                    dp[i][j] = dp[i-1][j-1]+1;\\n                }\\n                else{\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n    \\n\\t// method to get Shortest Supersequence\\n    String scs(String s1, String s2) {\\n        StringBuilder sb = new StringBuilder();\\n        int i=s1.length(), j=s2.length();\\n\\t\\t\\n\\t\\t// traversing back the path which we used to get LCS\\n        while(i>0 && j>0){\\n            if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                sb.append(s1.charAt(i-1));\\n                i--;\\n                j--;\\n            }\\n            else if(dp[i-1][j]>dp[i][j-1]){\\n                sb.append(s1.charAt(i-1));\\n                i--;\\n            }\\n            else if(dp[i-1][j]<=dp[i][j-1]){\\n                sb.append(s2.charAt(j-1));\\n                j--;\\n            }\\n            \\n        }\\n        while(i>0){\\n            sb.append(s1.charAt(i-1));\\n            i--;\\n        }\\n        while(j>0){\\n            sb.append(s2.charAt(j-1));\\n            j--;\\n        }\\n        return sb.reverse()+\"\";\\n    }\\n    \\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int n=str1.length(), m=str2.length();\\n        dp = new int[n+1][m+1];\\n        for(int i=0; i<n; i++) dp[i][0] = 0;\\n        for(int j=0; j<m; j++) dp[0][j] = 0;\\n        lcs(str1, str2, n, m);\\n        return scs(str1, str2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "``` a = \"abbac\" ```\n``` b = \"babcz\" ```\n``` \"ababacz\" ```\n```\\nclass Solution {\\n    int[][] dp;\\n    \\n\\t// method to fill dp 2D array with length of LCS\\n    int lcs(String str1, String str2, int n, int m) {\\n        for(int i=1; i<=n; i++){\\n            for(int j=1; j<=m; j++){\\n                if(str1.charAt(i-1)==str2.charAt(j-1)){\\n                    dp[i][j] = dp[i-1][j-1]+1;\\n                }\\n                else{\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n    \\n\\t// method to get Shortest Supersequence\\n    String scs(String s1, String s2) {\\n        StringBuilder sb = new StringBuilder();\\n        int i=s1.length(), j=s2.length();\\n\\t\\t\\n\\t\\t// traversing back the path which we used to get LCS\\n        while(i>0 && j>0){\\n            if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                sb.append(s1.charAt(i-1));\\n                i--;\\n                j--;\\n            }\\n            else if(dp[i-1][j]>dp[i][j-1]){\\n                sb.append(s1.charAt(i-1));\\n                i--;\\n            }\\n            else if(dp[i-1][j]<=dp[i][j-1]){\\n                sb.append(s2.charAt(j-1));\\n                j--;\\n            }\\n            \\n        }\\n        while(i>0){\\n            sb.append(s1.charAt(i-1));\\n            i--;\\n        }\\n        while(j>0){\\n            sb.append(s2.charAt(j-1));\\n            j--;\\n        }\\n        return sb.reverse()+\"\";\\n    }\\n    \\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int n=str1.length(), m=str2.length();\\n        dp = new int[n+1][m+1];\\n        for(int i=0; i<n; i++) dp[i][0] = 0;\\n        for(int j=0; j<m; j++) dp[0][j] = 0;\\n        lcs(str1, str2, n, m);\\n        return scs(str1, str2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274116,
                "title": "printing-scs-shortest-common-supersequence",
                "content": "* Now this question requires the knowledge of SCS and printing LCS\\n* We require LCS table for this so use the LCS code as it is\\n* Then when we had to print the LCS we tarversed from bottom right cell and if corresponding characters were equal , we printed them moved diagnally (i--,j--) and when they were not equal we didnt print the characrers and moved to max(dp[i-1][j],dp[i][j-1]) i.e (i-- or j--) because we only needed longest **COMMON** subsequence\\n* But Now suppose \"bc\" and \" \" have LCS = \" \" but SCS=\"bc\" \\n* So here we require longest common subsequence + rest characters too since SCS contains both strings as substrings\\n* So after finding the LCS table do as follow (similar to printing LCS)\\n* Start processing the table from the last cell till i>=1 AND  j>=1\\n* Check if s1[i-1]==s2[j-1]. If equal, we must add this character to the result string only once (same as LCS printing)\\n*  Else go th the max of dp[i-1][j] and dp[i][j-1] (similar to printing LCS) **but before going to the max add the current character of the corresponding substring then move**\\n*  after that we just need to take care of remaining charcters in one of the strings which will be left untraversed\\n![image](https://assets.leetcode.com/users/images/3ed12fc0-4bb5-46cf-9c7e-0e738bfc72be_1623758030.2208464.jpeg)\\n\\nCode for printing SCS\\n```\\nstring shortestCommonSupersequence(string X, string Y) {\\n        \\n        // LCS code as it is since we require dp[][]\\n\\t\\tint m=X.length();\\n        int n=Y.length();\\n        int dp[m+1][n+1];\\n        \\n        // initialization\\n        for(int i=0;i<=m;i++)\\n            dp[i][0]=0;   // Eg LCS of \"abc\" & \"\" = 0\\n        for(int j=0;j<=n;j++)\\n            dp[0][j]=0;   // Eg LCS of \"\" & \"abc\" = 0\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(X[i-1]==Y[j-1])\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n\\t\\t// Now we got the dp[ ][ ]\\n        // Now printing SCS ( similar to printing LCS )\\n\\t\\t string res=\"\";\\n        int i=m,j=n;\\n        while(i>=1 && j>=1)\\n        {\\n            if(X[i-1]==Y[j-1])\\n            {\\n                res+=X[i-1];\\n                i--,j--;\\n            }\\n            else if(dp[i-1][j]>dp[i][j-1])\\n            {\\n                res+=X[i-1];    // extra line\\n                i--;\\n            }\\n            else {\\n                res+=Y[j-1];     // extra line\\n                j--;\\n            }\\n        }\\n\\t\\t// after this point one of the strings will be traversed and one would have some remaining       //characters which we need to andd in our answer\\n\\t\\t// this is the extra code\\n   while(i>=1)\\n        {\\n            res+=X[i-1];\\n            i--;\\n        }\\n          while(j>=1)\\n        {\\n            res+=Y[j-1];\\n            j--;\\n        }\\n\\t\\t// since we traversed from end to begining so reversing the final ans\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }       \\n```\\nNote : We dont need to reverse our resultant string if we first add the new character at the top in our string and then add the previous string to its back (see this) :\\n```\\n int i=n1,j=n2;\\n    string ans=\"\";\\n    while(i>0 && j>0){\\n        if(s1[i-1]==s2[j-1]){\\n            ans=s1[i-1]+ans;\\n            i--;\\n            j--;\\n        }\\n        else if(dp[i-1][j] > dp[i][j-1]){\\n            ans=s1[i-1]+ans;\\n            i--;\\n        }\\n        else{\\n            ans=s2[j-1]+ans;\\n            j--;\\n        }\\n    }\\n    while(i>0){\\n        ans=s1[i-1]+ans;\\n        i--;\\n    }\\n    while(j>0){\\n        ans=s2[j-1]+ans;\\n        j--;\\n    }\\n    return ans;\\n```\\n",
                "solutionTags": [],
                "code": "```\\nstring shortestCommonSupersequence(string X, string Y) {\\n        \\n        // LCS code as it is since we require dp[][]\\n\\t\\tint m=X.length();\\n        int n=Y.length();\\n        int dp[m+1][n+1];\\n        \\n        // initialization\\n        for(int i=0;i<=m;i++)\\n            dp[i][0]=0;   // Eg LCS of \"abc\" & \"\" = 0\\n        for(int j=0;j<=n;j++)\\n            dp[0][j]=0;   // Eg LCS of \"\" & \"abc\" = 0\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(X[i-1]==Y[j-1])\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n\\t\\t// Now we got the dp[ ][ ]\\n        // Now printing SCS ( similar to printing LCS )\\n\\t\\t string res=\"\";\\n        int i=m,j=n;\\n        while(i>=1 && j>=1)\\n        {\\n            if(X[i-1]==Y[j-1])\\n            {\\n                res+=X[i-1];\\n                i--,j--;\\n            }\\n            else if(dp[i-1][j]>dp[i][j-1])\\n            {\\n                res+=X[i-1];    // extra line\\n                i--;\\n            }\\n            else {\\n                res+=Y[j-1];     // extra line\\n                j--;\\n            }\\n        }\\n\\t\\t// after this point one of the strings will be traversed and one would have some remaining       //characters which we need to andd in our answer\\n\\t\\t// this is the extra code\\n   while(i>=1)\\n        {\\n            res+=X[i-1];\\n            i--;\\n        }\\n          while(j>=1)\\n        {\\n            res+=Y[j-1];\\n            j--;\\n        }\\n\\t\\t// since we traversed from end to begining so reversing the final ans\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }       \\n```\n```\\n int i=n1,j=n2;\\n    string ans=\"\";\\n    while(i>0 && j>0){\\n        if(s1[i-1]==s2[j-1]){\\n            ans=s1[i-1]+ans;\\n            i--;\\n            j--;\\n        }\\n        else if(dp[i-1][j] > dp[i][j-1]){\\n            ans=s1[i-1]+ans;\\n            i--;\\n        }\\n        else{\\n            ans=s2[j-1]+ans;\\n            j--;\\n        }\\n    }\\n    while(i>0){\\n        ans=s1[i-1]+ans;\\n        i--;\\n    }\\n    while(j>0){\\n        ans=s2[j-1]+ans;\\n        j--;\\n    }\\n    return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 786544,
                "title": "simple-python-accepted-solution-using-lcs-implementation-faster-than-83-python-users",
                "content": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        n,m = len(str1),len(str2)\\n        dp = [[0 for j in range(m+1)]for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if str1[i-1] == str2[j-1]:\\n                    dp[i][j] = 1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\\n        i,j = n,m\\n        ans = \"\"\\n        while(i>0 and j>0):\\n            if str1[i-1] == str2[j-1]:\\n                ans += str1[i-1]\\n                i -= 1\\n                j -= 1\\n            else:\\n                if(dp[i-1][j] > dp[i][j-1]):\\n                    ans += str1[i-1]\\n                    i -= 1\\n                else:\\n                    ans += str2[j-1]\\n                    j -= 1\\n        while(i>0):\\n            ans += str1[i-1]\\n            i -= 1\\n        while(j>0):\\n            ans += str2[j-1]\\n            j -= 1\\n        return ans[::-1]\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        n,m = len(str1),len(str2)\\n        dp = [[0 for j in range(m+1)]for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if str1[i-1] == str2[j-1]:\\n                    dp[i][j] = 1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\\n        i,j = n,m\\n        ans = \"\"\\n        while(i>0 and j>0):\\n            if str1[i-1] == str2[j-1]:\\n                ans += str1[i-1]\\n                i -= 1\\n                j -= 1\\n            else:\\n                if(dp[i-1][j] > dp[i][j-1]):\\n                    ans += str1[i-1]\\n                    i -= 1\\n                else:\\n                    ans += str2[j-1]\\n                    j -= 1\\n        while(i>0):\\n            ans += str1[i-1]\\n            i -= 1\\n        while(j>0):\\n            ans += str2[j-1]\\n            j -= 1\\n        return ans[::-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 727722,
                "title": "java-lcs-and-tracing-back",
                "content": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int[][] dp = new int[str1.length() +1][str2.length()+1];\\n        \\n        for(int i = 0; i <= str1.length(); i++) {\\n            for(int j = 0; j <= str2.length(); j++) {\\n                if(i == 0 || j == 0) dp[i][j] = 0;\\n                else if(str1.charAt(i-1) == str2.charAt(j-1)) {\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int i = str1.length();\\n        int j = str2.length();\\n        StringBuffer result = new StringBuffer();\\n        \\n        while(i > 0 && j > 0) {\\n            if (str1.charAt(i-1) == str2.charAt(j-1)) {\\n                result.append(str1.charAt(i-1));\\n                i--;\\n                j--;\\n            } else if( dp[i-1][j] > dp[i][j-1] ) {\\n                result.append(str1.charAt(i-1));\\n                i--;\\n            } else {\\n                result.append(str2.charAt(j-1));\\n                j--;\\n            }\\n        }\\n        \\n        while(i > 0) {\\n           result.append(str1.charAt(i-1));\\n            i--; \\n        }\\n        \\n                \\n        while(j > 0) {\\n           result.append(str2.charAt(j-1));\\n            j--; \\n        }\\n        \\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int[][] dp = new int[str1.length() +1][str2.length()+1];\\n        \\n        for(int i = 0; i <= str1.length(); i++) {\\n            for(int j = 0; j <= str2.length(); j++) {\\n                if(i == 0 || j == 0) dp[i][j] = 0;\\n                else if(str1.charAt(i-1) == str2.charAt(j-1)) {\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int i = str1.length();\\n        int j = str2.length();\\n        StringBuffer result = new StringBuffer();\\n        \\n        while(i > 0 && j > 0) {\\n            if (str1.charAt(i-1) == str2.charAt(j-1)) {\\n                result.append(str1.charAt(i-1));\\n                i--;\\n                j--;\\n            } else if( dp[i-1][j] > dp[i][j-1] ) {\\n                result.append(str1.charAt(i-1));\\n                i--;\\n            } else {\\n                result.append(str2.charAt(j-1));\\n                j--;\\n            }\\n        }\\n        \\n        while(i > 0) {\\n           result.append(str1.charAt(i-1));\\n            i--; \\n        }\\n        \\n                \\n        while(j > 0) {\\n           result.append(str2.charAt(j-1));\\n            j--; \\n        }\\n        \\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361201,
                "title": "brute-force-to-dp-top-down-to-bottom-up-solution",
                "content": "```\\nThis is brute force solution\\n\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        String s1 = str1, s2 = str2;\\n        String[][] cache = new String[s1.length()][s2.length()];\\n        return helper(s1, s2, 0, 0, cache);\\n    }\\n    \\n    private String helper(String s1, String s2, int idx1, int idx2, String[][] cache) {\\n        if (idx1 == s1.length() && idx2 == s2.length()) {\\n            return \"\";\\n        }\\n        \\n        if (idx1 == s1.length()) return s2.substring(idx2, s2.length());\\n        else if (idx2 == s2.length()) return s1.substring(idx1, s1.length());\\n        if (cache[idx1][idx2] != null) return cache[idx1][idx2];\\n        \\n        if (s1.charAt(idx1) == s2.charAt(idx2)) {\\n           cache[idx1][idx2] = s1.charAt(idx1) + helper(s1, s2, idx1 + 1, idx2 + 1, cache);\\n           return cache[idx1][idx2];\\n        } \\n        \\n        String re1 = s1.charAt(idx1) + helper(s1, s2, idx1 + 1, idx2, cache);\\n        String re2 = s2.charAt(idx2) + helper(s1, s2, idx1, idx2 + 1, cache);\\n        \\n        String re = re1.length() <= re2.length() ? re1 : re2;\\n        \\n        cache[idx1][idx2] = re;\\n        return re;\\n        \\n    }\\n}\\n```\\n\\n\\n```\\nThis is top-down version \\n\\nclass Solution {\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        \\n        String[][] cache = new String[s1.length()][s2.length()];\\n        String LCS = helper(s1, s2, 0, 0, cache);\\n        System.out.println(LCS);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int i = 0, j = 0;\\n        for(char c : LCS.toCharArray()) {\\n            while(i < s1.length() && s1.charAt(i) != c) sb.append(s1.charAt(i++));\\n            while(j < s2.length() && s2.charAt(j) != c) sb.append(s2.charAt(j++));\\n            sb.append(c);\\n            i++;\\n            j++;\\n        }\\n        \\n        if (i < s1.length())\\n        sb.append(s1.substring(i, s1.length()));\\n        if (j < s2.length())\\n        sb.append(s2.substring(j, s2.length()));\\n        return sb.toString();\\n        \\n    }\\n    \\n    private String helper(String s1, String s2, int idx1, int idx2, String[][] cache) {\\n        if (idx1 == s1.length() || idx2 == s2.length()) return \"\";\\n        if (cache[idx1][idx2] != null) return cache[idx1][idx2];\\n        if (s1.charAt(idx1) == s2.charAt(idx2)) {\\n            cache[idx1][idx2] = s1.charAt(idx1) + helper(s1, s2, idx1 + 1, idx2 + 1, cache);\\n            return cache[idx1][idx2];\\n        }\\n        \\n        String re1 = helper(s1, s2, idx1 + 1, idx2, cache);\\n        String re2 = helper(s1, s2, idx1, idx2 + 1, cache);\\n        cache[idx1][idx2] = re1.length() >= re2.length() ? re1 : re2;\\n        return cache[idx1][idx2];\\n    }\\n}\\n```\\n\\n```\\nThis is bottom-up version\\n\\nclass Solution {\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        \\n        //1. apply bottom-up to find Longest common subSequence\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n        for(int i = 1; i < dp.length; i++) {\\n            for(int j = 1; j < dp[0].length; j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) dp[i][j] = 1 + dp[i - 1][j - 1];\\n                else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n        \\n        //2. Get Longest Common Subsequence String\\n        String LCS = getLCS(dp, s1);\\n        \\n        \\n        //3. Append missing character at s1 and s2 into longest common subsequence string\\n        int i = 0, j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : LCS.toCharArray()) {\\n            while(i < s1.length() && s1.charAt(i) != c) sb.append(s1.charAt(i++));\\n            while(j < s2.length() && s2.charAt(j) != c) sb.append(s2.charAt(j++));\\n            sb.append(c);\\n            i++;\\n            j++;\\n        }\\n        \\n        if (i < s1.length()) sb.append(s1.substring(i, s1.length()));\\n        if (j < s2.length()) sb.append(s2.substring(j, s2.length()));\\n        \\n        return sb.toString();\\n    }\\n    \\n    private String getLCS(int[][] dp, String s1) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = dp.length - 1, j = dp[0].length - 1;\\n        while(i > 0 && j > 0) {\\n            if (dp[i][j] == dp[i - 1][j]) i--;\\n            else if (dp[i][j] == dp[i][j - 1]) j--;\\n            else {\\n                sb.insert(0, s1.charAt(i - 1));\\n                i--;\\n                j--;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nThis is brute force solution\\n\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        String s1 = str1, s2 = str2;\\n        String[][] cache = new String[s1.length()][s2.length()];\\n        return helper(s1, s2, 0, 0, cache);\\n    }\\n    \\n    private String helper(String s1, String s2, int idx1, int idx2, String[][] cache) {\\n        if (idx1 == s1.length() && idx2 == s2.length()) {\\n            return \"\";\\n        }\\n        \\n        if (idx1 == s1.length()) return s2.substring(idx2, s2.length());\\n        else if (idx2 == s2.length()) return s1.substring(idx1, s1.length());\\n        if (cache[idx1][idx2] != null) return cache[idx1][idx2];\\n        \\n        if (s1.charAt(idx1) == s2.charAt(idx2)) {\\n           cache[idx1][idx2] = s1.charAt(idx1) + helper(s1, s2, idx1 + 1, idx2 + 1, cache);\\n           return cache[idx1][idx2];\\n        } \\n        \\n        String re1 = s1.charAt(idx1) + helper(s1, s2, idx1 + 1, idx2, cache);\\n        String re2 = s2.charAt(idx2) + helper(s1, s2, idx1, idx2 + 1, cache);\\n        \\n        String re = re1.length() <= re2.length() ? re1 : re2;\\n        \\n        cache[idx1][idx2] = re;\\n        return re;\\n        \\n    }\\n}\\n```\n```\\nThis is top-down version \\n\\nclass Solution {\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        \\n        String[][] cache = new String[s1.length()][s2.length()];\\n        String LCS = helper(s1, s2, 0, 0, cache);\\n        System.out.println(LCS);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int i = 0, j = 0;\\n        for(char c : LCS.toCharArray()) {\\n            while(i < s1.length() && s1.charAt(i) != c) sb.append(s1.charAt(i++));\\n            while(j < s2.length() && s2.charAt(j) != c) sb.append(s2.charAt(j++));\\n            sb.append(c);\\n            i++;\\n            j++;\\n        }\\n        \\n        if (i < s1.length())\\n        sb.append(s1.substring(i, s1.length()));\\n        if (j < s2.length())\\n        sb.append(s2.substring(j, s2.length()));\\n        return sb.toString();\\n        \\n    }\\n    \\n    private String helper(String s1, String s2, int idx1, int idx2, String[][] cache) {\\n        if (idx1 == s1.length() || idx2 == s2.length()) return \"\";\\n        if (cache[idx1][idx2] != null) return cache[idx1][idx2];\\n        if (s1.charAt(idx1) == s2.charAt(idx2)) {\\n            cache[idx1][idx2] = s1.charAt(idx1) + helper(s1, s2, idx1 + 1, idx2 + 1, cache);\\n            return cache[idx1][idx2];\\n        }\\n        \\n        String re1 = helper(s1, s2, idx1 + 1, idx2, cache);\\n        String re2 = helper(s1, s2, idx1, idx2 + 1, cache);\\n        cache[idx1][idx2] = re1.length() >= re2.length() ? re1 : re2;\\n        return cache[idx1][idx2];\\n    }\\n}\\n```\n```\\nThis is bottom-up version\\n\\nclass Solution {\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        \\n        //1. apply bottom-up to find Longest common subSequence\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n        for(int i = 1; i < dp.length; i++) {\\n            for(int j = 1; j < dp[0].length; j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) dp[i][j] = 1 + dp[i - 1][j - 1];\\n                else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n        \\n        //2. Get Longest Common Subsequence String\\n        String LCS = getLCS(dp, s1);\\n        \\n        \\n        //3. Append missing character at s1 and s2 into longest common subsequence string\\n        int i = 0, j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : LCS.toCharArray()) {\\n            while(i < s1.length() && s1.charAt(i) != c) sb.append(s1.charAt(i++));\\n            while(j < s2.length() && s2.charAt(j) != c) sb.append(s2.charAt(j++));\\n            sb.append(c);\\n            i++;\\n            j++;\\n        }\\n        \\n        if (i < s1.length()) sb.append(s1.substring(i, s1.length()));\\n        if (j < s2.length()) sb.append(s2.substring(j, s2.length()));\\n        \\n        return sb.toString();\\n    }\\n    \\n    private String getLCS(int[][] dp, String s1) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = dp.length - 1, j = dp[0].length - 1;\\n        while(i > 0 && j > 0) {\\n            if (dp[i][j] == dp[i - 1][j]) i--;\\n            else if (dp[i][j] == dp[i][j - 1]) j--;\\n            else {\\n                sb.insert(0, s1.charAt(i - 1));\\n                i--;\\n                j--;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498414,
                "title": "c-dp",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\n\\n1.We can construct dp table to get Longest Common Subsequence.\\n2.Characters present in LCS will be used once rest all we have to add.\\n3.Length of Shortest Common Supersequence = (n1+n2-lcs(s1,s2))\\n\\n```\\nclass Solution {\\npublic:\\n\\n    string shortestCommonSupersequence(string s1, string s2) {\\n        int n=s1.length(), m=s2.length();\\n\\t\\t\\n\\t\\t// constructing dp table to get Longest Common Subsequence\\n        int dp[n+1][m+1];\\n        for(int i=0,j=0;i<n+1;i++) dp[i][j]=0;\\n        for(int i=0,j=0;j<m+1;j++) dp[i][j]=0;\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Shortest Common Supersequence\\n        string ans=\"\";\\n        int i=n, j=m;\\n        while(i>0 && j>0){\\n            if(s1[i-1]==s2[j-1]){\\n                ans+=s1[i-1];\\n                i--, j--;\\n            }else{\\n                if(dp[i-1][j]>=dp[i][j-1]){\\n                    ans+=s1[i-1];\\n                    i--;\\n                }else{\\n                    ans+=s2[j-1];\\n                    j--;\\n                }\\n            }\\n        }\\n        while(i>0){\\n            ans+=s1[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            ans+=s2[j-1];\\n            j--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string shortestCommonSupersequence(string s1, string s2) {\\n        int n=s1.length(), m=s2.length();\\n\\t\\t\\n\\t\\t// constructing dp table to get Longest Common Subsequence\\n        int dp[n+1][m+1];\\n        for(int i=0,j=0;i<n+1;i++) dp[i][j]=0;\\n        for(int i=0,j=0;j<m+1;j++) dp[i][j]=0;\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Shortest Common Supersequence\\n        string ans=\"\";\\n        int i=n, j=m;\\n        while(i>0 && j>0){\\n            if(s1[i-1]==s2[j-1]){\\n                ans+=s1[i-1];\\n                i--, j--;\\n            }else{\\n                if(dp[i-1][j]>=dp[i][j-1]){\\n                    ans+=s1[i-1];\\n                    i--;\\n                }else{\\n                    ans+=s2[j-1];\\n                    j--;\\n                }\\n            }\\n        }\\n        while(i>0){\\n            ans+=s1[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            ans+=s2[j-1];\\n            j--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443393,
                "title": "python-longest-common-subsequence-idea-clean-concise",
                "content": "```python\\nclass Solution:\\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        m = len(s1)\\n        n = len(s2)\\n        dp = [[0] * (n+1) for _ in range(m+1)]  # let dp[i][j] is the lcs between s[:i-1], s[:j-1]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1] + 1\\n                else:\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n\\n        # Let\\'s backtrack\\n        i = m\\n        j = n\\n        lcs = []\\n        lcsIndexS1 = []\\n        lcsIndexS2 = []\\n        while i > 0 and j > 0:\\n            if s1[i-1] == s2[j-1]:\\n                i = i - 1\\n                j = j - 1\\n                lcs.append(s1[i])\\n                lcsIndexS1.append(i)\\n                lcsIndexS2.append(j)\\n            elif dp[i][j] == dp[i-1][j]:\\n                i = i - 1\\n            else:\\n                j = j - 1\\n        lcs = lcs[::-1]\\n        lcsIndexS1 = lcsIndexS1[::-1]\\n        lcsIndexS2 = lcsIndexS2[::-1]\\n        \\n        if len(lcs) == 0:\\n            return s1 + s2\\n        \\n        ans = []\\n        \\n        lcsIndexS1.append(m)\\n        lcsIndexS2.append(n)\\n        ans.append(s1[:lcsIndexS1[0]])\\n        ans.append(s2[:lcsIndexS2[0]])\\n        for i in range(len(lcsIndexS1)-1):\\n            ans.append(lcs[i])\\n            b1 = lcsIndexS1[i] + 1\\n            e1 = lcsIndexS1[i+1] - 1\\n            ans.append(s1[b1:e1+1])\\n            b2 = lcsIndexS2[i] + 1\\n            e2 = lcsIndexS2[i+1] - 1\\n            ans.append(s2[b2:e2+1])\\n        return \"\".join(ans)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        m = len(s1)\\n        n = len(s2)\\n        dp = [[0] * (n+1) for _ in range(m+1)]  # let dp[i][j] is the lcs between s[:i-1], s[:j-1]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1] + 1\\n                else:\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n\\n        # Let\\'s backtrack\\n        i = m\\n        j = n\\n        lcs = []\\n        lcsIndexS1 = []\\n        lcsIndexS2 = []\\n        while i > 0 and j > 0:\\n            if s1[i-1] == s2[j-1]:\\n                i = i - 1\\n                j = j - 1\\n                lcs.append(s1[i])\\n                lcsIndexS1.append(i)\\n                lcsIndexS2.append(j)\\n            elif dp[i][j] == dp[i-1][j]:\\n                i = i - 1\\n            else:\\n                j = j - 1\\n        lcs = lcs[::-1]\\n        lcsIndexS1 = lcsIndexS1[::-1]\\n        lcsIndexS2 = lcsIndexS2[::-1]\\n        \\n        if len(lcs) == 0:\\n            return s1 + s2\\n        \\n        ans = []\\n        \\n        lcsIndexS1.append(m)\\n        lcsIndexS2.append(n)\\n        ans.append(s1[:lcsIndexS1[0]])\\n        ans.append(s2[:lcsIndexS2[0]])\\n        for i in range(len(lcsIndexS1)-1):\\n            ans.append(lcs[i])\\n            b1 = lcsIndexS1[i] + 1\\n            e1 = lcsIndexS1[i+1] - 1\\n            ans.append(s1[b1:e1+1])\\n            b2 = lcsIndexS2[i] + 1\\n            e2 = lcsIndexS2[i+1] - 1\\n            ans.append(s2[b2:e2+1])\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347772,
                "title": "c-lcs-type-short-sweet-easy-to-understand-c",
                "content": "````\\nclass Solution\\n{\\npublic:\\n    string shortestCommonSupersequence(string s1, string s2)\\n    {\\n        int i, j, m = s1.length(), n = s2.length(), k = 0, x;\\n        vector<vector<string>> dp(m + 1, vector<string>(n + 1, \"\"));\\n\\t\\t//FIND LCS OF BOTH GIVEN STRINGS\\n        for (i = 1; i <= m; i++)\\n        {\\n            for (j = 1; j <= n; j++)\\n            {\\n                if (s1[i - 1] == s2[j - 1])\\n                {\\n                    dp[i][j] = dp[i - 1][j - 1] + s1[i - 1];\\n                }\\n                else\\n                {\\n                    if (dp[i][j - 1].length() > dp[i - 1][j].length())\\n                    {\\n                        dp[i][j] = dp[i][j - 1];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = dp[i - 1][j];\\n                    }\\n                }\\n            }\\n        }\\n        string str = dp[m][n];//STORE LCS IN STR\\n        string ans = \"\";\\n        x = str.length();\\n        i = 0, j = 0;\\n\\t\\t//i = FIRST STRING POINTER, j = SECOND STRING  POINTER, k = LCS STRING POINTER \\n        while (i < m && j < n && k < x)\\n        {\\n            while (i < m && s1[i] != str[k])\\n            {\\n                ans += s1[i++];//MOVE FORWARD UNTILL Kth CHAR NOT EQUAL TO ith CHAR & ADD ith CHAR TO ANS STRING\\n            }\\n            while (j < n && s2[j] != str[k])\\n            {\\n                ans += s2[j++];//MOVE FORWARD UNTILL Kth CHAR NOT EQUAL TO jth CHAR & ADD jth CHAR TO ANS STRING\\n            }\\n\\t\\t\\t//ith & jth CHAR EQUALS TO kth CHAR INCREASE i & j BY 1\\n            i++;\\n            j++;\\n\\t\\t\\t//ADD kth CHAR INTO ANS STRING  AND  INCREASE k BY 1\\n            ans += str[k++];\\n        }\\n        while (i < m)\\n        {\\n            ans += s1[i++];\\n        }\\n        while (j < n)\\n        {\\n            ans += s2[j++];\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution\\n{\\npublic:\\n    string shortestCommonSupersequence(string s1, string s2)\\n    {\\n        int i, j, m = s1.length(), n = s2.length(), k = 0, x;\\n        vector<vector<string>> dp(m + 1, vector<string>(n + 1, \"\"));\\n\\t\\t//FIND LCS OF BOTH GIVEN STRINGS\\n        for (i = 1; i <= m; i++)\\n        {\\n            for (j = 1; j <= n; j++)\\n            {\\n                if (s1[i - 1] == s2[j - 1])\\n                {\\n                    dp[i][j] = dp[i - 1][j - 1] + s1[i - 1];\\n                }\\n                else\\n                {\\n                    if (dp[i][j - 1].length() > dp[i - 1][j].length())\\n                    {\\n                        dp[i][j] = dp[i][j - 1];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = dp[i - 1][j];\\n                    }\\n                }\\n            }\\n        }\\n        string str = dp[m][n];//STORE LCS IN STR\\n        string ans = \"\";\\n        x = str.length();\\n        i = 0, j = 0;\\n\\t\\t//i = FIRST STRING POINTER, j = SECOND STRING  POINTER, k = LCS STRING POINTER \\n        while (i < m && j < n && k < x)\\n        {\\n            while (i < m && s1[i] != str[k])\\n            {\\n                ans += s1[i++];//MOVE FORWARD UNTILL Kth CHAR NOT EQUAL TO ith CHAR & ADD ith CHAR TO ANS STRING\\n            }\\n            while (j < n && s2[j] != str[k])\\n            {\\n                ans += s2[j++];//MOVE FORWARD UNTILL Kth CHAR NOT EQUAL TO jth CHAR & ADD jth CHAR TO ANS STRING\\n            }\\n\\t\\t\\t//ith & jth CHAR EQUALS TO kth CHAR INCREASE i & j BY 1\\n            i++;\\n            j++;\\n\\t\\t\\t//ADD kth CHAR INTO ANS STRING  AND  INCREASE k BY 1\\n            ans += str[k++];\\n        }\\n        while (i < m)\\n        {\\n            ans += s1[i++];\\n        }\\n        while (j < n)\\n        {\\n            ans += s2[j++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615215,
                "title": "amazing-approach-of-dp-l-c-s",
                "content": "class Solution {\\n\\n    string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n    string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1479605,
                "title": "c-dp-lcs-both-top-down-and-bottum-up-o-m-n",
                "content": "**BOTTOM-UP (TABULATION)**\\n\\n```\\nstatic int dp[1001][1001];\\nclass Solution {\\npublic:\\n    void lcs(string &s1, string &s2,int n, int m){\\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=0;\\n        for(int j=0;j<=m;j++)\\n            dp[0][j]=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1]==s2[j-1])\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                else\\n                    dp[i][j]= max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n    }\\n    \\n    string shortestCommonSupersequence(string s1, string s2) {\\n        int n=s1.size(), m=s2.size();\\n        lcs(s1,s2,n,m);\\n    \\n        int i=n,j=m;\\n        string s=\"\";\\n        while(i>0 && j>0){\\n            if(s1[i-1]==s2[j-1]){\\n                s.push_back(s1[i-1]);\\n                i--;j--;\\n            }\\n            else{\\n                if(dp[i-1][j]>dp[i][j-1]){\\n                    s.push_back(s1[i-1]);\\n                    i--;\\n                }\\n                else{\\n                    s.push_back(s2[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n            s.push_back(s1[i-1]);\\n            i--;\\n        }\\n        while(j>0){\\n            s.push_back(s2[j-1]);\\n            j--;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```\\n\\n**TOP-DOWN (MEMOIZATION)**\\n\\n```\\nstatic int dp[1001][1001];\\nclass Solution {\\npublic:\\n    int lcs(string &s1, string &s2,int n, int m){\\n        if(n==0 || m==0)\\n            return 0;\\n        if(dp[n][m]!=-1)\\n            return dp[n][m];\\n        if(s1[n-1]==s2[m-1])\\n            return dp[n][m]= 1+lcs(s1, s2, n-1, m-1);\\n        else\\n            return dp[n][m]=max(lcs(s1, s2, n-1, m), lcs(s1, s2, n, m-1));\\n    }\\n    \\n    string shortestCommonSupersequence(string s1, string s2) {\\n        int n=s1.size(), m=s2.size();\\n        memset(dp,-1,sizeof(dp));\\n        lcs(s1,s2,n,m);\\n    \\n        int i=n,j=m;\\n        string s=\"\";\\n        while(i>0 && j>0){\\n            if(s1[i-1]==s2[j-1]){\\n                s.push_back(s1[i-1]);\\n                i--;j--;\\n            }\\n            else{\\n                if(dp[i-1][j]>dp[i][j-1]){\\n                    s.push_back(s1[i-1]);\\n                    i--;\\n                }\\n                else{\\n                    s.push_back(s2[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n            s.push_back(s1[i-1]);\\n            i--;\\n        }\\n        while(j>0){\\n            s.push_back(s2[j-1]);\\n            j--;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int dp[1001][1001];\\nclass Solution {\\npublic:\\n    void lcs(string &s1, string &s2,int n, int m){\\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=0;\\n        for(int j=0;j<=m;j++)\\n            dp[0][j]=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1]==s2[j-1])\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                else\\n                    dp[i][j]= max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n    }\\n    \\n    string shortestCommonSupersequence(string s1, string s2) {\\n        int n=s1.size(), m=s2.size();\\n        lcs(s1,s2,n,m);\\n    \\n        int i=n,j=m;\\n        string s=\"\";\\n        while(i>0 && j>0){\\n            if(s1[i-1]==s2[j-1]){\\n                s.push_back(s1[i-1]);\\n                i--;j--;\\n            }\\n            else{\\n                if(dp[i-1][j]>dp[i][j-1]){\\n                    s.push_back(s1[i-1]);\\n                    i--;\\n                }\\n                else{\\n                    s.push_back(s2[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n            s.push_back(s1[i-1]);\\n            i--;\\n        }\\n        while(j>0){\\n            s.push_back(s2[j-1]);\\n            j--;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```\n```\\nstatic int dp[1001][1001];\\nclass Solution {\\npublic:\\n    int lcs(string &s1, string &s2,int n, int m){\\n        if(n==0 || m==0)\\n            return 0;\\n        if(dp[n][m]!=-1)\\n            return dp[n][m];\\n        if(s1[n-1]==s2[m-1])\\n            return dp[n][m]= 1+lcs(s1, s2, n-1, m-1);\\n        else\\n            return dp[n][m]=max(lcs(s1, s2, n-1, m), lcs(s1, s2, n, m-1));\\n    }\\n    \\n    string shortestCommonSupersequence(string s1, string s2) {\\n        int n=s1.size(), m=s2.size();\\n        memset(dp,-1,sizeof(dp));\\n        lcs(s1,s2,n,m);\\n    \\n        int i=n,j=m;\\n        string s=\"\";\\n        while(i>0 && j>0){\\n            if(s1[i-1]==s2[j-1]){\\n                s.push_back(s1[i-1]);\\n                i--;j--;\\n            }\\n            else{\\n                if(dp[i-1][j]>dp[i][j-1]){\\n                    s.push_back(s1[i-1]);\\n                    i--;\\n                }\\n                else{\\n                    s.push_back(s2[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n            s.push_back(s1[i-1]);\\n            i--;\\n        }\\n        while(j>0){\\n            s.push_back(s2[j-1]);\\n            j--;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408862,
                "title": "c-solution-using-lcs-faster-than-100",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string shortestCommonSupersequence(string a, string b) \\n\\t{\\n        int n = a.length(), m = b.length();\\n        int dp[n + 1][m + 1];\\n        string s;\\n        for(int i = 0; i <= n; i++) dp[i][0] = 0;\\n        for(int i = 0; i <= m; i++) dp[0][i] = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(a[i - 1] == b[j - 1])  dp[i][j] = 1 + dp[i - 1][j - 1];\\n                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);\\n            }\\n        }\\n        while(n != 0 and m != 0)\\n        {\\n            if(a[n - 1] == b[m - 1]) s.push_back(a[n - 1]), n --, m --;\\n            else (dp[n][m - 1] > dp[n - 1][m]) ? s.push_back(b[m - 1]), m -- : s.push_back(a[n - 1]), n --;\\n        }\\n        while(n != 0) s.push_back(a[n - 1]), n--;\\n        while(m != 0) s.push_back(b[m - 1]), m--;\\n        return reverse(s.begin(), s.end());\\n    }\\n};\\n```\\nDon\\'t Forget To Upvote !",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string shortestCommonSupersequence(string a, string b) \\n\\t{\\n        int n = a.length(), m = b.length();\\n        int dp[n + 1][m + 1];\\n        string s;\\n        for(int i = 0; i <= n; i++) dp[i][0] = 0;\\n        for(int i = 0; i <= m; i++) dp[0][i] = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(a[i - 1] == b[j - 1])  dp[i][j] = 1 + dp[i - 1][j - 1];\\n                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);\\n            }\\n        }\\n        while(n != 0 and m != 0)\\n        {\\n            if(a[n - 1] == b[m - 1]) s.push_back(a[n - 1]), n --, m --;\\n            else (dp[n][m - 1] > dp[n - 1][m]) ? s.push_back(b[m - 1]), m -- : s.push_back(a[n - 1]), n --;\\n        }\\n        while(n != 0) s.push_back(a[n - 1]), n--;\\n        while(m != 0) s.push_back(b[m - 1]), m--;\\n        return reverse(s.begin(), s.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916054,
                "title": "easy-java-code-using-longestcommonsubsequence-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String lcs(String s1, String s2) {\\n        int m=s1.length();\\n        int n=s2.length();\\n        int dp[][]=new int[m+1][n+1];\\n    \\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                }\\n                else{\\n                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n\\n       StringBuilder sb=new StringBuilder();\\n       int i=m,j=n;\\n       while(i>0&&j>0){\\n           if(s1.charAt(i-1)==s2.charAt(j-1)){\\n               sb.append(s1.charAt(i-1));\\n               i--;\\n               j--;\\n           }\\n           else if(dp[i-1][j]>dp[i][j-1])i--;\\n           else j--;\\n       }\\n       return sb.reverse().toString();\\n    }\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        String str=lcs(s1,s2);\\n        String ans=\"\";\\n        int p1=0,p2=0,p3=0;\\n       \\n        for(char c:str.toCharArray()){\\n            while(p1<s1.length()&&s1.charAt(p1)!=c){\\n                ans+=s1.charAt(p1++);\\n            }\\n            while(p2<s2.length()&&s2.charAt(p2)!=c){\\n                ans+=s2.charAt(p2++);\\n            }\\n            ans+=c;\\n            p1++;\\n            p2++;\\n            \\n        }\\n\\n        if(p1<s1.length())ans+=s1.substring(p1);\\n        if(p2<s2.length())ans+=s2.substring(p2);\\n        // ans+=s1.substring(p1)+s2.substring(p2);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String lcs(String s1, String s2) {\\n        int m=s1.length();\\n        int n=s2.length();\\n        int dp[][]=new int[m+1][n+1];\\n    \\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                }\\n                else{\\n                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n\\n       StringBuilder sb=new StringBuilder();\\n       int i=m,j=n;\\n       while(i>0&&j>0){\\n           if(s1.charAt(i-1)==s2.charAt(j-1)){\\n               sb.append(s1.charAt(i-1));\\n               i--;\\n               j--;\\n           }\\n           else if(dp[i-1][j]>dp[i][j-1])i--;\\n           else j--;\\n       }\\n       return sb.reverse().toString();\\n    }\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        String str=lcs(s1,s2);\\n        String ans=\"\";\\n        int p1=0,p2=0,p3=0;\\n       \\n        for(char c:str.toCharArray()){\\n            while(p1<s1.length()&&s1.charAt(p1)!=c){\\n                ans+=s1.charAt(p1++);\\n            }\\n            while(p2<s2.length()&&s2.charAt(p2)!=c){\\n                ans+=s2.charAt(p2++);\\n            }\\n            ans+=c;\\n            p1++;\\n            p2++;\\n            \\n        }\\n\\n        if(p1<s1.length())ans+=s1.substring(p1);\\n        if(p2<s2.length())ans+=s2.substring(p2);\\n        // ans+=s1.substring(p1)+s2.substring(p2);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787352,
                "title": "c-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.size(), m = str2.size();\\n        string lcs = longestCommonSubsequence(str1, str2, n, m); \\n        string result = \"\";\\n        int i = 0, j = 0;\\n\\n        for (char& c : lcs) {\\n            while (str1[i] != c) result += str1[i++];\\n            while (str2[j] != c) result += str2[j++];\\n            result += c, i++, j++;\\n        }\\n\\n        return result + str1.substr(i) + str2.substr(j);\\n    }\\n\\n    string longestCommonSubsequence(string& s, string& t, int& n, int& m) {\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (s[i-1] == t[j-1]) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = max(dp[i][j-1], dp[i-1][j]);\\n            }\\n        }\\n\\n        int k = dp[n][m];\\n        string result = string(k, \\'#\\'); // Placeholder string\\n\\n        // Building the lcs string\\n        for (int i = n, j = m; i > 0 && j > 0; ) {\\n            if (s[i-1] == t[j-1]) {\\n                result[--k] = s[i-1];\\n                i--; j--;\\n            } else {\\n                if (dp[i-1][j] > dp[i][j-1]) i--;\\n                else j--;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.size(), m = str2.size();\\n        string lcs = longestCommonSubsequence(str1, str2, n, m); \\n        string result = \"\";\\n        int i = 0, j = 0;\\n\\n        for (char& c : lcs) {\\n            while (str1[i] != c) result += str1[i++];\\n            while (str2[j] != c) result += str2[j++];\\n            result += c, i++, j++;\\n        }\\n\\n        return result + str1.substr(i) + str2.substr(j);\\n    }\\n\\n    string longestCommonSubsequence(string& s, string& t, int& n, int& m) {\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (s[i-1] == t[j-1]) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = max(dp[i][j-1], dp[i-1][j]);\\n            }\\n        }\\n\\n        int k = dp[n][m];\\n        string result = string(k, \\'#\\'); // Placeholder string\\n\\n        // Building the lcs string\\n        for (int i = n, j = m; i > 0 && j > 0; ) {\\n            if (s[i-1] == t[j-1]) {\\n                result[--k] = s[i-1];\\n                i--; j--;\\n            } else {\\n                if (dp[i-1][j] > dp[i][j-1]) i--;\\n                else j--;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362455,
                "title": "best-o-n-m-solution",
                "content": "# Approach\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * m)$$\\n\\n- Space complexity:\\n$$O(n * m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.length();\\n        int m = str2.length();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n        for (int i = 0; i <= n; i++)\\n            dp[i][0] = 0;\\n        for (int j = 0; j <= m; j++)\\n            dp[0][j] = 0;   \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (str1[i-1] == str2[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else\\n                    dp[i][j] = max (dp[i-1][j], dp[i][j-1]);    \\n            }\\n        }     \\n        string scs = \"\";\\n        int i = n, j = m;\\n        while (i > 0 && j > 0) {\\n            if (str1[i-1] == str2[j-1]) {\\n                scs += str1[i-1];\\n                i--;\\n                j--;\\n            } else if (dp[i][j-1] > dp[i-1][j]) {\\n                scs += str2[j-1];\\n                j--;\\n            } else {\\n                scs += str1[i-1];\\n                i--;\\n            }\\n        }\\n        while (i > 0) {\\n            scs += str1[i-1];\\n            i--;\\n        }\\n        while (j > 0) {\\n            scs += str2[j-1];\\n            j--;\\n        }\\n        reverse(scs.begin(), scs.end());\\n        return scs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.length();\\n        int m = str2.length();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n        for (int i = 0; i <= n; i++)\\n            dp[i][0] = 0;\\n        for (int j = 0; j <= m; j++)\\n            dp[0][j] = 0;   \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (str1[i-1] == str2[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else\\n                    dp[i][j] = max (dp[i-1][j], dp[i][j-1]);    \\n            }\\n        }     \\n        string scs = \"\";\\n        int i = n, j = m;\\n        while (i > 0 && j > 0) {\\n            if (str1[i-1] == str2[j-1]) {\\n                scs += str1[i-1];\\n                i--;\\n                j--;\\n            } else if (dp[i][j-1] > dp[i-1][j]) {\\n                scs += str2[j-1];\\n                j--;\\n            } else {\\n                scs += str1[i-1];\\n                i--;\\n            }\\n        }\\n        while (i > 0) {\\n            scs += str1[i-1];\\n            i--;\\n        }\\n        while (j > 0) {\\n            scs += str2[j-1];\\n            j--;\\n        }\\n        reverse(scs.begin(), scs.end());\\n        return scs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078921,
                "title": "python-3-dp-w-example-t-m-98-94",
                "content": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n\\n        n1, n2 = len(s1)+1, len(s2)+1               #  Example: str1 = \"abac\"  str2 = \"cab\"\\n        i1, i2, ans = n1-1, n2-1, \\'\\'                #             s1 = \" abac\"   s2 = \" cab\"\\n        s1,s2 = s1.rjust(n1),s2.rjust(n2)\\n        dp = [[0] * n2 for _ in range(n1)]\\n\\n        for i1 in range(1, n1):\\n            for i2 in range(1, n2):\\n                if s1[i1] == s2[i2]: dp[i1][i2] = dp[i1-1][i2-1] + 1\\n                else: dp[i1][i2] = max(dp[i1 - 1][i2], dp[i1][i2-1])\\n\\n        while i1|i2:                                #        \\' \\'  c   a   b\\n            if not i1*i2:                           #   \\' \\' [ 0   0   0   0 ]\\n                ans += s1[i1] if i1 else s2[i2]     #    a  [ 0   0   1   1 ]\\n                i2 -= bool(i2) ; i1 -= bool(i1)     #    b  [ 0   0   1   2 ]\\n                                                    #    a  [ 0   0   1   2 ]   \\n            elif s1[i1] == s2[i2]:                  #    c  [ 0   1   1   2 ]\\n                ans += s1[i1]\\n                i1 -= 1  ; i2 -= 1\\n\\n            elif    dp[i1][i2] == dp[i1-1][i2]:     #    i1     i2    s[i1]  s[i2]   ans\\n                ans += s1[i1]                       #    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\n                i1 -= 1                             #     4      3      c      b      \\'\\'\\n                                                    #     3      3      a      b       c\\n            else: # dp[i1][i2] == dp[i1][i2-1]      #     2      3      b      b       ca\\n                ans += s2[i2]                       #     1      2      \\'\\'     c       caba\\n                i2 -= 1                             #     0      0      \\'\\'     \\'\\'      cabac\\n\\n        return ans[::-1]\\n```\\n[https://leetcode.com/problems/shortest-common-supersequence/submissions/882059436/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*^2).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n\\n        n1, n2 = len(s1)+1, len(s2)+1               #  Example: str1 = \"abac\"  str2 = \"cab\"\\n        i1, i2, ans = n1-1, n2-1, \\'\\'                #             s1 = \" abac\"   s2 = \" cab\"\\n        s1,s2 = s1.rjust(n1),s2.rjust(n2)\\n        dp = [[0] * n2 for _ in range(n1)]\\n\\n        for i1 in range(1, n1):\\n            for i2 in range(1, n2):\\n                if s1[i1] == s2[i2]: dp[i1][i2] = dp[i1-1][i2-1] + 1\\n                else: dp[i1][i2] = max(dp[i1 - 1][i2], dp[i1][i2-1])\\n\\n        while i1|i2:                                #        \\' \\'  c   a   b\\n            if not i1*i2:                           #   \\' \\' [ 0   0   0   0 ]\\n                ans += s1[i1] if i1 else s2[i2]     #    a  [ 0   0   1   1 ]\\n                i2 -= bool(i2) ; i1 -= bool(i1)     #    b  [ 0   0   1   2 ]\\n                                                    #    a  [ 0   0   1   2 ]   \\n            elif s1[i1] == s2[i2]:                  #    c  [ 0   1   1   2 ]\\n                ans += s1[i1]\\n                i1 -= 1  ; i2 -= 1\\n\\n            elif    dp[i1][i2] == dp[i1-1][i2]:     #    i1     i2    s[i1]  s[i2]   ans\\n                ans += s1[i1]                       #    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\n                i1 -= 1                             #     4      3      c      b      \\'\\'\\n                                                    #     3      3      a      b       c\\n            else: # dp[i1][i2] == dp[i1][i2-1]      #     2      3      b      b       ca\\n                ans += s2[i2]                       #     1      2      \\'\\'     c       caba\\n                i2 -= 1                             #     0      0      \\'\\'     \\'\\'      cabac\\n\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066562,
                "title": "faster-than-70-solutions-of-java-and-python",
                "content": "java code\\n```\\n\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int n = str1.length(), m = str2.length();\\n        int[][] dp = new int[n + 1][m + 1];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n                }\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int i = n, j = m;\\n        while (i > 0 && j > 0) {\\n            if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\\n                sb.append(str1.charAt(i - 1));\\n                i--;\\n                j--;\\n            } else {\\n                if (dp[i][j - 1] > dp[i - 1][j]) {\\n                    sb.append(str2.charAt(j - 1));\\n                    j--;\\n                } else {\\n                    sb.append(str1.charAt(i - 1));\\n                    i--;\\n                }\\n            }\\n        }\\n        while (i > 0) {\\n            sb.append(str1.charAt(i - 1));\\n            i--;\\n        }\\n        while (j > 0) {\\n            sb.append(str2.charAt(j - 1));\\n            j--;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```\\npython code\\n```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        n,m = len(str1),len(str2)\\n        t = [[0 for j in range(m+1)]for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if str1[i-1] == str2[j-1]:\\n                    t[i][j] = 1+t[i-1][j-1]\\n                else:\\n                    t[i][j] = max(t[i-1][j],t[i][j-1])\\n        s=\"\" \\n        while i>0 and j>0:\\n            if str1[i-1]==str2[j-1]:\\n                s+=str1[i-1]\\n                i-=1\\n                j-=1\\n            else:\\n                if t[i][j-1]>t[i-1][j]:\\n                    s+=str2[j-1]\\n                    j-=1\\n                else :\\n                    s+=str1[i-1]\\n                    i-=1\\n        while i>0:\\n            s+=str1[i-1]\\n            i-=1\\n        while j>0:\\n            s+=str2[j-1]\\n            j-=1\\n        return s[::-1]\\n```\\nc++ code\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.size(), m = str2.size();\\n        vector<vector<int>> t(n+1, vector<int>(m+1, 0));\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (str1[i-1] == str2[j-1]) {\\n                    t[i][j] = 1 + t[i-1][j-1];\\n                } else {\\n                    t[i][j] = max(t[i-1][j], t[i][j-1]);\\n                }\\n            }\\n        }\\n        string s;\\n        int i = n, j = m;\\n        while (i > 0 && j > 0) {\\n            if (str1[i-1] == str2[j-1]) {\\n                s += str1[i-1];\\n                i--;\\n                j--;\\n            } else {\\n                if (t[i][j-1] > t[i-1][j]) {\\n                    s += str2[j-1];\\n                    j--;\\n                } else {\\n                    s += str1[i-1];\\n                    i--;\\n                }\\n            }\\n        }\\n        while (i > 0) {\\n            s += str1[i-1];\\n            i--;\\n        }\\n        while (j > 0) {\\n            s += str2[j-1];\\n            j--;\\n        }\\n        std::reverse(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int n = str1.length(), m = str2.length();\\n        int[][] dp = new int[n + 1][m + 1];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n                }\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int i = n, j = m;\\n        while (i > 0 && j > 0) {\\n            if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\\n                sb.append(str1.charAt(i - 1));\\n                i--;\\n                j--;\\n            } else {\\n                if (dp[i][j - 1] > dp[i - 1][j]) {\\n                    sb.append(str2.charAt(j - 1));\\n                    j--;\\n                } else {\\n                    sb.append(str1.charAt(i - 1));\\n                    i--;\\n                }\\n            }\\n        }\\n        while (i > 0) {\\n            sb.append(str1.charAt(i - 1));\\n            i--;\\n        }\\n        while (j > 0) {\\n            sb.append(str2.charAt(j - 1));\\n            j--;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        n,m = len(str1),len(str2)\\n        t = [[0 for j in range(m+1)]for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if str1[i-1] == str2[j-1]:\\n                    t[i][j] = 1+t[i-1][j-1]\\n                else:\\n                    t[i][j] = max(t[i-1][j],t[i][j-1])\\n        s=\"\" \\n        while i>0 and j>0:\\n            if str1[i-1]==str2[j-1]:\\n                s+=str1[i-1]\\n                i-=1\\n                j-=1\\n            else:\\n                if t[i][j-1]>t[i-1][j]:\\n                    s+=str2[j-1]\\n                    j-=1\\n                else :\\n                    s+=str1[i-1]\\n                    i-=1\\n        while i>0:\\n            s+=str1[i-1]\\n            i-=1\\n        while j>0:\\n            s+=str2[j-1]\\n            j-=1\\n        return s[::-1]\\n```\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.size(), m = str2.size();\\n        vector<vector<int>> t(n+1, vector<int>(m+1, 0));\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (str1[i-1] == str2[j-1]) {\\n                    t[i][j] = 1 + t[i-1][j-1];\\n                } else {\\n                    t[i][j] = max(t[i-1][j], t[i][j-1]);\\n                }\\n            }\\n        }\\n        string s;\\n        int i = n, j = m;\\n        while (i > 0 && j > 0) {\\n            if (str1[i-1] == str2[j-1]) {\\n                s += str1[i-1];\\n                i--;\\n                j--;\\n            } else {\\n                if (t[i][j-1] > t[i-1][j]) {\\n                    s += str2[j-1];\\n                    j--;\\n                } else {\\n                    s += str1[i-1];\\n                    i--;\\n                }\\n            }\\n        }\\n        while (i > 0) {\\n            s += str1[i-1];\\n            i--;\\n        }\\n        while (j > 0) {\\n            s += str2[j-1];\\n            j--;\\n        }\\n        std::reverse(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754988,
                "title": "c-dp-aditya-verma-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        \\n    int x=str1.size();\\n    int y=str2.size();\\n    \\n    int t[x+1][y+1];\\n    for(int i=0;i<x+1;i++){\\n        for(int j=0;j<y+1;j++){\\n            if(i==0||j==0) \\n                t[i][j]=0;\\n            \\n            else if(str1[i-1]==str2[j-1])\\n\\t\\t\\tt[i][j]=1+t[i-1][j-1];\\n            \\n            else \\n            t[i][j]=max(t[i-1][j],t[i][j-1]);\\n        }\\n    }\\n    \\n    int i=x;\\n    int j=y;\\n        \\n    string s=\"\";\\n    while(i>0 && j>0){\\n        if(str1[i-1]==str2[j-1]){\\n            s.push_back(str1[i-1]);\\n            i--;\\n            j--;\\n        }\\n        else{\\n            if(t[i][j-1] > t[i-1][j]){\\n                s.push_back(str2[j-1]);\\n                j--;\\n            }\\n            else{\\n                s.push_back(str1[i-1]);\\n                i--;\\n            }\\n        }\\n    }\\n        \\n    while(i>0){\\n        s.push_back(str1[i-1]);\\n        i--;\\n    }\\n    while(j>0){\\n        s.push_back(str2[j-1]);\\n        j--;\\n    }\\n    reverse(s.begin(),s.end());\\n    return s;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        \\n    int x=str1.size();\\n    int y=str2.size();\\n    \\n    int t[x+1][y+1];\\n    for(int i=0;i<x+1;i++){\\n        for(int j=0;j<y+1;j++){\\n            if(i==0||j==0) \\n                t[i][j]=0;\\n            \\n            else if(str1[i-1]==str2[j-1])\\n\\t\\t\\tt[i][j]=1+t[i-1][j-1];\\n            \\n            else \\n            t[i][j]=max(t[i-1][j],t[i][j-1]);\\n        }\\n    }\\n    \\n    int i=x;\\n    int j=y;\\n        \\n    string s=\"\";\\n    while(i>0 && j>0){\\n        if(str1[i-1]==str2[j-1]){\\n            s.push_back(str1[i-1]);\\n            i--;\\n            j--;\\n        }\\n        else{\\n            if(t[i][j-1] > t[i-1][j]){\\n                s.push_back(str2[j-1]);\\n                j--;\\n            }\\n            else{\\n                s.push_back(str1[i-1]);\\n                i--;\\n            }\\n        }\\n    }\\n        \\n    while(i>0){\\n        s.push_back(str1[i-1]);\\n        i--;\\n    }\\n    while(j>0){\\n        s.push_back(str2[j-1]);\\n        j--;\\n    }\\n    reverse(s.begin(),s.end());\\n    return s;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1542945,
                "title": "c-dp-solution",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string x, string y) {\\n        int m=x.size();\\n\\t    int n=y.size();\\n\\t    int dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<m+1;i++)\\n        {\\n            for(int j=1;j<n+1;j++)\\n            {\\n                if(x[i-1]==y[j-1])\\n                dp[i][j]=1+dp[i-1][j-1];\\n                else\\n                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        \\n        int i=m,j=n;\\n        string s=\"\";\\n        while(i>0 && j>0)\\n        {\\n            if(x[i-1]==y[j-1])\\n            {\\n                s+=x[i-1];\\n                i--;\\n                j--;\\n            }\\n            else\\n            {\\n                if(dp[i-1][j]>dp[i][j-1])\\n                {\\n                    s.push_back(x[i-1]);\\n                    i--;\\n                }\\n                else\\n                    if(dp[i][j-1]>=dp[i-1][j])\\n                    {\\n                        s+=y[j-1];\\n                        j--;\\n                    }\\n                \\n            }\\n            \\n          \\n        }\\n    \\n         while(i>0)\\n            {\\n                s+=x[i-1];\\n                i--;\\n            }\\n            while(j>0)\\n            {\\n                s+=y[j-1];\\n                j--;\\n                \\n            }\\n            \\n         reverse(s.begin(),s.end());\\n            return s;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string x, string y) {\\n        int m=x.size();\\n\\t    int n=y.size();\\n\\t    int dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<m+1;i++)\\n        {\\n            for(int j=1;j<n+1;j++)\\n            {\\n                if(x[i-1]==y[j-1])\\n                dp[i][j]=1+dp[i-1][j-1];\\n                else\\n                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        \\n        int i=m,j=n;\\n        string s=\"\";\\n        while(i>0 && j>0)\\n        {\\n            if(x[i-1]==y[j-1])\\n            {\\n                s+=x[i-1];\\n                i--;\\n                j--;\\n            }\\n            else\\n            {\\n                if(dp[i-1][j]>dp[i][j-1])\\n                {\\n                    s.push_back(x[i-1]);\\n                    i--;\\n                }\\n                else\\n                    if(dp[i][j-1]>=dp[i-1][j])\\n                    {\\n                        s+=y[j-1];\\n                        j--;\\n                    }\\n                \\n            }\\n            \\n          \\n        }\\n    \\n         while(i>0)\\n            {\\n                s+=x[i-1];\\n                i--;\\n            }\\n            while(j>0)\\n            {\\n                s+=y[j-1];\\n                j--;\\n                \\n            }\\n            \\n         reverse(s.begin(),s.end());\\n            return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227139,
                "title": "easiest-c-implementation-better-than-97",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string X, string Y) {\\n  int m = X.length();\\n  int n = Y.length();\\n  int dp[m+1][n+1];\\n  for(int i=0; i<=m; i++)\\n    for(int j=0; j<=n; j++)\\n      if(i==0||j==0)\\n        dp[i][j] = 0;\\n  for(int i=1; i<=m; i++)\\n  {\\n    for(int j=1; j<=n; j++)\\n    {\\n      if(X[i-1]==Y[j-1])\\n        dp[i][j] = 1 + dp[i-1][j-1];\\n      else\\n        dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n    }\\n  }\\n\\n  int i=m, j=n;\\n  string ans = \"\";\\n  while(i>0 && j>0)\\n  {\\n    if(X[i-1]==Y[j-1])\\n    {\\n      ans.push_back(X[i-1]);\\n      i--;  j--;\\n    }\\n    else if(dp[i][j-1]>dp[i-1][j])\\n    {\\n      ans.push_back(Y[j-1]);\\n      j--;\\n    }\\n    else\\n    {\\n      ans.push_back(X[i-1]);\\n      i--;\\n    }\\n  }\\n  while(i>0)\\n  {\\n    ans.push_back(X[i-1]);\\n    i--;\\n  }\\n  while(j>0)\\n  {\\n    ans.push_back(Y[j-1]);\\n    j--;\\n  }\\n  reverse(ans.begin(),ans.end());\\n  return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string X, string Y) {\\n  int m = X.length();\\n  int n = Y.length();\\n  int dp[m+1][n+1];\\n  for(int i=0; i<=m; i++)\\n    for(int j=0; j<=n; j++)\\n      if(i==0||j==0)\\n        dp[i][j] = 0;\\n  for(int i=1; i<=m; i++)\\n  {\\n    for(int j=1; j<=n; j++)\\n    {\\n      if(X[i-1]==Y[j-1])\\n        dp[i][j] = 1 + dp[i-1][j-1];\\n      else\\n        dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n    }\\n  }\\n\\n  int i=m, j=n;\\n  string ans = \"\";\\n  while(i>0 && j>0)\\n  {\\n    if(X[i-1]==Y[j-1])\\n    {\\n      ans.push_back(X[i-1]);\\n      i--;  j--;\\n    }\\n    else if(dp[i][j-1]>dp[i-1][j])\\n    {\\n      ans.push_back(Y[j-1]);\\n      j--;\\n    }\\n    else\\n    {\\n      ans.push_back(X[i-1]);\\n      i--;\\n    }\\n  }\\n  while(i>0)\\n  {\\n    ans.push_back(X[i-1]);\\n    i--;\\n  }\\n  while(j>0)\\n  {\\n    ans.push_back(Y[j-1]);\\n    j--;\\n  }\\n  reverse(ans.begin(),ans.end());\\n  return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598960,
                "title": "you-will-not-regret-watching-the-video-attached",
                "content": "https://www.youtube.com/watch?v=VDhRg-ZJTuc&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=31&t=886s\\n\\nMy code:\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int t[][]=new int[str1.length()+1][str2.length()+1];\\n        for(int i=1;i<=str1.length();i++){\\n            for(int j=1;j<=str2.length();j++){\\n                if(str1.charAt(i-1)==str2.charAt(j-1))\\n                    t[i][j]=1+t[i-1][j-1];\\n                else\\n                    t[i][j]=Math.max(t[i-1][j],t[i][j-1]);\\n            }\\n        }\\n        int i=str1.length(),j=str2.length();\\n        StringBuilder sb=new StringBuilder();\\n        while(i>0 && j>0){\\n            if(str1.charAt(i-1)==str2.charAt(j-1)){\\n                sb.append(str1.charAt(i-1));\\n                i--;\\n               j--;\\n            }\\n            else{\\n                if(t[i][j-1]>t[i-1][j]){\\n                    sb.append(str2.charAt(j-1));\\n                    j--;\\n                }\\n                else {\\n                     sb.append(str1.charAt(i-1));\\n                    i--;\\n                }\\n            }\\n        }\\n        while(i>0){\\n            sb.append(str1.charAt(i-1));\\n            i--;\\n        }\\n        while(j>0){\\n            sb.append(str2.charAt(j-1));\\n            j--;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int t[][]=new int[str1.length()+1][str2.length()+1];\\n        for(int i=1;i<=str1.length();i++){\\n            for(int j=1;j<=str2.length();j++){\\n                if(str1.charAt(i-1)==str2.charAt(j-1))\\n                    t[i][j]=1+t[i-1][j-1];\\n                else\\n                    t[i][j]=Math.max(t[i-1][j],t[i][j-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 315501,
                "title": "lcs-based-solution",
                "content": "Find LCS of strings, appends chars of both string but adding chars that are in LCS only once.\\n\\n``` csharp\\npublic class Solution {\\n     public string ShortestCommonSupersequence(string str1, string str2)\\n        {\\n            string lcs = GetLCS(str1.ToCharArray(), str2.ToCharArray(), out string[,] C);\\n            Console.WriteLine(lcs);\\n            string result = string.Empty;\\n\\n            int i = 0, j = 0;\\n            StringBuilder sb = new StringBuilder();\\n            foreach (char ch in lcs)\\n            {\\n                while (str1[i] != ch)\\n                {\\n                    sb.Append(str1[i++]);\\n                }\\n\\n                while (str2[j] != ch)\\n                {\\n                    sb.Append(str2[j++]);\\n                }\\n\\n                sb.Append(ch);\\n                i++;\\n                j++;\\n            }\\n\\n            result = sb.Append(str1.Substring(i)).Append(str2.Substring(j)).ToString();\\n            Console.WriteLine(result);\\n            return result;\\n        }\\n\\n        public string GetLCS(char[] X, char[] Y, out string[,] C)\\n        {\\n            int m = X.Length;\\n            int n = Y.Length;\\n\\n            C = new string[m + 1, n + 1];\\n\\n            for (int i = 0; i <= m; i++)\\n            {\\n                for (int j = 0; j <= n; j++)\\n                {\\n                    if (i == 0 || j == 0)\\n                    {\\n                        C[i, j] = string.Empty;\\n                    }\\n\\n                    else if (X[i - 1] == Y[j - 1])\\n                    {\\n                        C[i, j] = C[i - 1, j - 1] + X[i - 1];\\n                    }\\n\\n                    else\\n                    {\\n                        if (C[i - 1, j].Length > C[i, j - 1].Length)\\n                        {\\n                            C[i, j] = C[i - 1, j];\\n                        }\\n                        else\\n                        {\\n                            C[i, j] = C[i, j - 1];\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return C[m, n];\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "``` csharp\\npublic class Solution {\\n     public string ShortestCommonSupersequence(string str1, string str2)\\n        {\\n            string lcs = GetLCS(str1.ToCharArray(), str2.ToCharArray(), out string[,] C);\\n            Console.WriteLine(lcs);\\n            string result = string.Empty;\\n\\n            int i = 0, j = 0;\\n            StringBuilder sb = new StringBuilder();\\n            foreach (char ch in lcs)\\n            {\\n                while (str1[i] != ch)\\n                {\\n                    sb.Append(str1[i++]);\\n                }\\n\\n                while (str2[j] != ch)\\n                {\\n                    sb.Append(str2[j++]);\\n                }\\n\\n                sb.Append(ch);\\n                i++;\\n                j++;\\n            }\\n\\n            result = sb.Append(str1.Substring(i)).Append(str2.Substring(j)).ToString();\\n            Console.WriteLine(result);\\n            return result;\\n        }\\n\\n        public string GetLCS(char[] X, char[] Y, out string[,] C)\\n        {\\n            int m = X.Length;\\n            int n = Y.Length;\\n\\n            C = new string[m + 1, n + 1];\\n\\n            for (int i = 0; i <= m; i++)\\n            {\\n                for (int j = 0; j <= n; j++)\\n                {\\n                    if (i == 0 || j == 0)\\n                    {\\n                        C[i, j] = string.Empty;\\n                    }\\n\\n                    else if (X[i - 1] == Y[j - 1])\\n                    {\\n                        C[i, j] = C[i - 1, j - 1] + X[i - 1];\\n                    }\\n\\n                    else\\n                    {\\n                        if (C[i - 1, j].Length > C[i, j - 1].Length)\\n                        {\\n                            C[i, j] = C[i - 1, j];\\n                        }\\n                        else\\n                        {\\n                            C[i, j] = C[i, j - 1];\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return C[m, n];\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313188,
                "title": "this-question-is-really-hard",
                "content": "We can easily find out the LCS by dp solution. While LCS might not unique, it can be several same length strings, thus can lead to different length of Common Supersequence, the shortest one is from one of the LCSs. Like:\\n\"aabbabaa\"\\n\"aabbbbbbaa\"\\nwe can get LCS: \"aabbaaa\" which lead to common supersequence \"aabbbbbbabaa\". This is not Shortest Common Supersequence.\\nsame length LCS can be: \"aabbbaa\", which can lead answer: \"aabbabbbbaa\"\\n\\nThis code was my failed try:\\n```\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int M = str1.length();\\n        int N = str2.length();\\n        String LCS = \"\";\\n        int[][] f = new int[M + 1][N + 1];\\n        char[] s1 = str1.toCharArray();\\n        char[] s2 = str2.toCharArray();\\n        for (int i = 1; i <= M; ++i) {\\n            for (int j = 1; j <= N; ++j) {\\n                if (s1[i - 1] == s2[j - 1]) {\\n                    f[i][j] = f[i - 1][j - 1] + 1;\\n                    if (f[i][j] > LCS.length()) {\\n                        LCS += s1[i - 1];\\n                    }\\n                } else {\\n                    f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);\\n                }\\n            }\\n        }\\n        String res = \"\";\\n        int ptr1 = 0, ptr2 = 0;\\n        int ptr = 0;\\n        while (ptr1 < M && ptr2 < N && ptr < LCS.length()) {\\n            if (ptr < LCS.length()) {\\n                if (s1[ptr1] == LCS.charAt(ptr) && s2[ptr2] == LCS.charAt(ptr)) {\\n                    res += LCS.charAt(ptr++);\\n                    ptr1++;\\n                    ptr2++;\\n                } else if (s1[ptr1] == LCS.charAt(ptr)) {\\n                    res += s2[ptr2++];\\n                } else {\\n                    res += s1[ptr1++];\\n                }\\n            }\\n        }\\n        if (ptr1 < M) {\\n            res += str1.substring(ptr1);\\n        }\\n        if (ptr2 < N) {\\n            res += str2.substring(ptr2);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int M = str1.length();\\n        int N = str2.length();\\n        String LCS = \"\";\\n        int[][] f = new int[M + 1][N + 1];\\n        char[] s1 = str1.toCharArray();\\n        char[] s2 = str2.toCharArray();\\n        for (int i = 1; i <= M; ++i) {\\n            for (int j = 1; j <= N; ++j) {\\n                if (s1[i - 1] == s2[j - 1]) {\\n                    f[i][j] = f[i - 1][j - 1] + 1;\\n                    if (f[i][j] > LCS.length()) {\\n                        LCS += s1[i - 1];\\n                    }\\n                } else {\\n                    f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);\\n                }\\n            }\\n        }\\n        String res = \"\";\\n        int ptr1 = 0, ptr2 = 0;\\n        int ptr = 0;\\n        while (ptr1 < M && ptr2 < N && ptr < LCS.length()) {\\n            if (ptr < LCS.length()) {\\n                if (s1[ptr1] == LCS.charAt(ptr) && s2[ptr2] == LCS.charAt(ptr)) {\\n                    res += LCS.charAt(ptr++);\\n                    ptr1++;\\n                    ptr2++;\\n                } else if (s1[ptr1] == LCS.charAt(ptr)) {\\n                    res += s2[ptr2++];\\n                } else {\\n                    res += s1[ptr1++];\\n                }\\n            }\\n        }\\n        if (ptr1 < M) {\\n            res += str1.substring(ptr1);\\n        }\\n        if (ptr2 < N) {\\n            res += str2.substring(ptr2);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3274144,
                "title": "lcs-variation-beats-95-76-of-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s assume 2 string s1 = \"ABCD\", s2 = \"CDE\" there shortest common supersequence will be \"CDABE\". As we can see there is some common part and then both strings remaining characters are completed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all we will find the common string in both the string and then we will add the remaining character of the String to make it shortest common supersequence. To find the common in the string we will use LCS(Longest common subsequence) and then iterate over the string to add the remaining part of the string.\\n\\nHere the 2-D matrix first row and first colum is initialized with 0.\\n\\n# Complexity\\n- Time complexity: O(mn + m + n), which is equivalent to O(mn).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        int n = s1.length(),m = s2.length();\\n        int[][] t = new int[n+1][m+1];\\n        for(int i= 0; i< n+1;i++){   //initialized\\n            for(int j = 0;j < m+1;j++){\\n                if(i == 0||j == 0) t[i][j] = 0;\\n            }\\n        }\\n        for (int i = 1; i < n+1; i++) {\\n            for (int j = 1; j < m+1; j++) {\\n                if(s1.charAt(i-1) == s2.charAt(j-1)){\\n                    t[i][j] = t[i-1][j-1]+1;\\n                }\\n                else{\\n                    t[i][j] = Math.max(t[i-1][j],t[i][j-1]);\\n                }\\n            }\\n        }\\n        StringBuilder sb =new StringBuilder();\\n        while(m > 0 && n >0){\\n            if(s1.charAt(n-1) == s2.charAt(m-1)){\\n                sb.append(s1.charAt(n-1));\\n                m--;\\n                n--;\\n            }\\n            else {\\n                if (t[n-1][m] >t[n][m-1]){\\n                    sb.append(s1.charAt(n-1));\\n                    n--;\\n                }\\n                else{\\n                    sb.append(s2.charAt(m-1));\\n                    m--;\\n                }\\n            }\\n        }\\n        while(n>0)\\n        {\\n            sb.append(s1.charAt(n-1));\\n            n--;\\n        }\\n        while(m>0)\\n        {\\n            sb.append(s2.charAt(m-1));\\n            m--;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        int n = s1.length(),m = s2.length();\\n        int[][] t = new int[n+1][m+1];\\n        for(int i= 0; i< n+1;i++){   //initialized\\n            for(int j = 0;j < m+1;j++){\\n                if(i == 0||j == 0) t[i][j] = 0;\\n            }\\n        }\\n        for (int i = 1; i < n+1; i++) {\\n            for (int j = 1; j < m+1; j++) {\\n                if(s1.charAt(i-1) == s2.charAt(j-1)){\\n                    t[i][j] = t[i-1][j-1]+1;\\n                }\\n                else{\\n                    t[i][j] = Math.max(t[i-1][j],t[i][j-1]);\\n                }\\n            }\\n        }\\n        StringBuilder sb =new StringBuilder();\\n        while(m > 0 && n >0){\\n            if(s1.charAt(n-1) == s2.charAt(m-1)){\\n                sb.append(s1.charAt(n-1));\\n                m--;\\n                n--;\\n            }\\n            else {\\n                if (t[n-1][m] >t[n][m-1]){\\n                    sb.append(s1.charAt(n-1));\\n                    n--;\\n                }\\n                else{\\n                    sb.append(s2.charAt(m-1));\\n                    m--;\\n                }\\n            }\\n        }\\n        while(n>0)\\n        {\\n            sb.append(s1.charAt(n-1));\\n            n--;\\n        }\\n        while(m>0)\\n        {\\n            sb.append(s2.charAt(m-1));\\n            m--;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098163,
                "title": "beats-100-extension-of-longest-common-subsequence-tabulation-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s, string t) {\\n        int m = s.size() , n = t.size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0 ||j==0) dp[i][j] = 0;\\n                else if(s[i-1] == t[j-1]){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]= max( dp[i-1][j] , dp[i][j-1] );\\n                }\\n            }\\n\\n        }\\n        string ans = \"\";\\n        int i = m , j = n;\\n        while(i>0 && j>0){\\n            if( s[i-1] == t[j-1] ){\\n                ans += s[i-1];\\n                i--;\\n                j--;\\n            }\\n            else if( dp[i-1][j] > dp[i][j-1] ){\\n                ans += s[i-1];\\n                i--;\\n            }\\n            else{\\n                ans += t[j-1];\\n                j--;\\n            }\\n        }\\n        while(i>0){\\n            ans += s[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            ans += t[j-1];\\n            j--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s, string t) {\\n        int m = s.size() , n = t.size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0 ||j==0) dp[i][j] = 0;\\n                else if(s[i-1] == t[j-1]){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]= max( dp[i-1][j] , dp[i][j-1] );\\n                }\\n            }\\n\\n        }\\n        string ans = \"\";\\n        int i = m , j = n;\\n        while(i>0 && j>0){\\n            if( s[i-1] == t[j-1] ){\\n                ans += s[i-1];\\n                i--;\\n                j--;\\n            }\\n            else if( dp[i-1][j] > dp[i][j-1] ){\\n                ans += s[i-1];\\n                i--;\\n            }\\n            else{\\n                ans += t[j-1];\\n                j--;\\n            }\\n        }\\n        while(i>0){\\n            ans += s[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            ans += t[j-1];\\n            j--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075540,
                "title": "c-easy-solution-please-upvote",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s1, string s2) {\\n         int n=s1.length();\\n        int m=s2.length();\\n        // vector<vector<int>> dp(n,vector<int>(m,-1));\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        for(int i=0;i<=n;i++){\\n            dp[i][0] = 0;\\n        }\\n        for(int i=0;i<=m;i++){\\n            dp[0][i] = 0;\\n        }\\n        \\n        for(int ind1=1;ind1<=n;ind1++){\\n            for(int ind2=1;ind2<=m;ind2++){\\n                if(s1[ind1-1]==s2[ind2-1])\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                else\\n                    dp[ind1][ind2] = 0 + max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n            }\\n        }\\n        int i=n,j=m;\\n        string s=\"\";\\n        while(i>0 && j>0){\\n            if(s1[i-1]==s2[j-1]){\\n                s+=s1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else if(dp[i-1][j]>dp[i][j-1]){\\n                s+=s1[i-1];\\n                i--;     \\n            }\\n            else{\\n                s+=s2[j-1];\\n                j--;\\n            }\\n        }\\n        cout<<s;\\n        while(i>0){\\n            s+=s1[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            s+=s2[j-1];\\n            j--;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s1, string s2) {\\n         int n=s1.length();\\n        int m=s2.length();\\n        // vector<vector<int>> dp(n,vector<int>(m,-1));\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        for(int i=0;i<=n;i++){\\n            dp[i][0] = 0;\\n        }\\n        for(int i=0;i<=m;i++){\\n            dp[0][i] = 0;\\n        }\\n        \\n        for(int ind1=1;ind1<=n;ind1++){\\n            for(int ind2=1;ind2<=m;ind2++){\\n                if(s1[ind1-1]==s2[ind2-1])\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                else\\n                    dp[ind1][ind2] = 0 + max(dp[ind1-1][ind2],dp[ind1][ind2-1]);\\n            }\\n        }\\n        int i=n,j=m;\\n        string s=\"\";\\n        while(i>0 && j>0){\\n            if(s1[i-1]==s2[j-1]){\\n                s+=s1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else if(dp[i-1][j]>dp[i][j-1]){\\n                s+=s1[i-1];\\n                i--;     \\n            }\\n            else{\\n                s+=s2[j-1];\\n                j--;\\n            }\\n        }\\n        cout<<s;\\n        while(i>0){\\n            s+=s1[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            s+=s2[j-1];\\n            j--;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2698749,
                "title": "c-solution-using-3-major-steps",
                "content": "```\\nstring shortestCommonSupersequence(string str1, string str2) {\\n        // 1. Find the longest common subsequence\\n        int n=str1.size();\\n        int m=str2.size();\\n        vector<vector<int>> t(n+1,vector<int>(m+1,0));\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(str1[i-1]==str2[j-1])\\n                {\\n                    t[i][j] = 1 + t[i-1][j-1];\\n                }\\n                else {\\n                    t[i][j] = max(t[i-1][j],t[i][j-1]);\\n                }\\n            }\\n        }\\n        //2. Now we will iterate our dp tabel \\n        // if char is same then we will go to i-- and j--\\n        // else we will go to max value in the tabel\\n        string res=\"\";\\n        int i=n,j=m;\\n        while(i>0 && j>0)\\n        {\\n            // Adding same char\\'s\\n            if(str1[i-1]==str2[j-1])\\n            {\\n                res+=str1[i-1];\\n                i--;\\n                j--;\\n            }\\n            // Adding different char\\'s\\n            else if(t[i-1][j]>t[i][j-1])\\n            {\\n                res+=str1[i-1];\\n                i--;\\n            }\\n            else {\\n                res+=str2[j-1];\\n                j--;\\n            }\\n        }\\n        //Now we have to add remaining chars\\n        \\n        while(i>0)\\n        {\\n            res+=str1[i-1];\\n            i--;\\n        }\\n        while(j>0)\\n        {\\n            res+=str2[j-1];\\n            j--;\\n        }\\n        //3. Reverse the string as we are iterating from last\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nstring shortestCommonSupersequence(string str1, string str2) {\\n        // 1. Find the longest common subsequence\\n        int n=str1.size();\\n        int m=str2.size();\\n        vector<vector<int>> t(n+1,vector<int>(m+1,0));\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(str1[i-1]==str2[j-1])\\n                {\\n                    t[i][j] = 1 + t[i-1][j-1];\\n                }\\n                else {\\n                    t[i][j] = max(t[i-1][j],t[i][j-1]);\\n                }\\n            }\\n        }\\n        //2. Now we will iterate our dp tabel \\n        // if char is same then we will go to i-- and j--\\n        // else we will go to max value in the tabel\\n        string res=\"\";\\n        int i=n,j=m;\\n        while(i>0 && j>0)\\n        {\\n            // Adding same char\\'s\\n            if(str1[i-1]==str2[j-1])\\n            {\\n                res+=str1[i-1];\\n                i--;\\n                j--;\\n            }\\n            // Adding different char\\'s\\n            else if(t[i-1][j]>t[i][j-1])\\n            {\\n                res+=str1[i-1];\\n                i--;\\n            }\\n            else {\\n                res+=str2[j-1];\\n                j--;\\n            }\\n        }\\n        //Now we have to add remaining chars\\n        \\n        while(i>0)\\n        {\\n            res+=str1[i-1];\\n            i--;\\n        }\\n        while(j>0)\\n        {\\n            res+=str2[j-1];\\n            j--;\\n        }\\n        //3. Reverse the string as we are iterating from last\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2434827,
                "title": "100-00-of-c-optimise-space-dp-solun-bottom-up-approach",
                "content": "This problem is closely related to longest common subsequence problem. Below are steps.\\n1) Find Longest Common Subsequence (lcs) of two given strings. For example, lcs of \\u201Cgeek\\u201D and \\u201Ceke\\u201D is \\u201Cek\\u201D. \\n2) Insert non-lcs characters (in their original order in strings) to the lcs found above, and return the result. So \\u201Cek\\u201D becomes \\u201Cgeeke\\u201D which is shortest common supersequence.\\nLet us consider another example, str1 = \\u201CAGGTAB\\u201D and str2 = \\u201CGXTXAYB\\u201D. LCS of str1 and str2 is \\u201CGTAB\\u201D. Once we find LCS, we insert characters of both strings in order and we get \\u201CAGXGTXAYB\\u201D\\nHow does this work? \\nWe need to find a string that has both strings as subsequences and is shortest such string. If both strings have all characters different, then result is sum of lengths of two given strings. If there are common characters, then we don\\u2019t want them multiple times as the task is to minimize length. Therefore, we first find the longest common subsequence, take one occurrence of this subsequence and add extra characters. \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        \\n        int m = str1.size();\\n        int n = str2.size();\\n        int dp[m+1][n+1];\\n        // vector<vector<int>>dp(m+1,vector<int>(n+1,0));\\n        \\n        for(int i=0;i<=n;i++) dp[0][i]=0;\\n        for(int i=0;i<=m;i++) dp[i][0]=0;\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                \\n                if(str1[i-1]==str2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=max(dp[i-1][j] , dp[i][j-1]);\\n                }    \\n            }\\n        }\\n        \\n        string s = \"\";\\n        int i = m , j = n;\\n        while(i>0 && j>0){\\n            \\n            if(str1[i-1]==str2[j-1]){\\n                s+=str1[i-1];\\n                i-- , j--;\\n            }\\n            else if(dp[i-1][j]>dp[i][j-1]){\\n                    s+=str1[i-1];\\n                    i--;\\n                }\\n            else{\\n                     s+=str2[j-1];\\n                     j--;\\n            } \\n        }\\n        \\n        while(i>0){\\n            s+=str1[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            s+=str2[j-1];\\n            j--;\\n        }\\n        reverse(s.begin() , s.end());\\n        return s;\\n    }\\n};\\n\\n**PLEASE UPVOTE IF YOU FOUND THIS HELPFUL**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        \\n        int m = str1.size();\\n        int n = str2.size();\\n        int dp[m+1][n+1];\\n        // vector<vector<int>>dp(m+1,vector<int>(n+1,0));\\n        \\n        for(int i=0;i<=n;i++) dp[0][i]=0;\\n        for(int i=0;i<=m;i++) dp[i][0]=0;\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                \\n                if(str1[i-1]==str2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2364943,
                "title": "wrong-answer-help-in-understanding-test-case",
                "content": "![image](https://assets.leetcode.com/users/images/8b53a7f7-547d-4f39-99c3-a49a134fc974_1659362643.922342.png)\\n\\nHere is a screenshot of the test case, I tried re-reading the question, but its same. My output has same length as that of expected output and it contains both the strings as superstring. However, the result is showing wrong answer. I am not asking help in code or anything, I am just asking why my output is incorrect.\\n\\nI am attaching the test case just in case someone wants to try it out:\\n\\nTest case:\\n\"bbbaaaba\"\\n\"bbababbb\"\\n\\nMy output:\\n\"bbbaaaaabba\"\\n\\nExpected output:\\n\"bbbaaababbb\"\\n\\nCode to reproduce the result: (I know my code will most probably TLE/MLE, and thats not an issue. I just want to know why its showing wring answer on this test case.)\\n\\n```\\nclass Solution {\\n    int m, n;\\n    vector<vector<string>> dp;\\n    string helper(string &s1, string &s2, int i, int j){\\n        if(i == 0 && j == 0)\\n            return \"\";\\n        if(!dp[i][j].empty())\\n            return dp[i][j];\\n        \\n        if(i == 0)\\n            return dp[i][j] = s2.substr(0, j);\\n        if(j == 0)\\n            return dp[i][j] = s1.substr(0, i);\\n        \\n        if(s1[i] == s2[j]){\\n            auto before = helper(s1, s2, i-1, j-1);\\n            before += s1[i-1];\\n            return dp[i][j] = before;\\n        }\\n        \\n        auto before1 = helper(s1,s2,i-1,j);\\n        auto before2 = helper(s1,s2,i,j-1);\\n        \\n        before1 += s1[i-1];\\n        before2 += s2[j-1];\\n        \\n        if(before1.size() < before2.size())\\n            return dp[i][j] = before1;\\n        if(before2.size() < before1.size())\\n            return dp[i][j] = before2;\\n        return dp[i][j] = min(before1, before2);\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        m = str1.size(), n = str2.size();\\n        dp.assign(m+1, vector<string>(n+1, \"\"));\\n        return helper(str1, str2, m, n);\\n    }\\n};\\n/*\\n\"bbbaaaba\"\\n\"bbababbb\"\\n*/\\n```\\n\\nIt would help a lot if you can help. Thanks.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    vector<vector<string>> dp;\\n    string helper(string &s1, string &s2, int i, int j){\\n        if(i == 0 && j == 0)\\n            return \"\";\\n        if(!dp[i][j].empty())\\n            return dp[i][j];\\n        \\n        if(i == 0)\\n            return dp[i][j] = s2.substr(0, j);\\n        if(j == 0)\\n            return dp[i][j] = s1.substr(0, i);\\n        \\n        if(s1[i] == s2[j]){\\n            auto before = helper(s1, s2, i-1, j-1);\\n            before += s1[i-1];\\n            return dp[i][j] = before;\\n        }\\n        \\n        auto before1 = helper(s1,s2,i-1,j);\\n        auto before2 = helper(s1,s2,i,j-1);\\n        \\n        before1 += s1[i-1];\\n        before2 += s2[j-1];\\n        \\n        if(before1.size() < before2.size())\\n            return dp[i][j] = before1;\\n        if(before2.size() < before1.size())\\n            return dp[i][j] = before2;\\n        return dp[i][j] = min(before1, before2);\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        m = str1.size(), n = str2.size();\\n        dp.assign(m+1, vector<string>(n+1, \"\"));\\n        return helper(str1, str2, m, n);\\n    }\\n};\\n/*\\n\"bbbaaaba\"\\n\"bbababbb\"\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306952,
                "title": "python-lcs-non-lcs-str1-str2-aditya-verma-s-explained",
                "content": "**feel free to ask incase of any doubts**\\n# ITERATIVE METHOD\\n\\n```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n\\t\\t\\n        n, m = len(str1), len(str2)\\n        \\n        # DP array | rows = inidices of text1, col = indices of text2\\n        dp = [[0 for j in range(m+1)] for n in range(n+1)]\\n          \\n        \"\"\"initialization | Not required as already all values in dp array is 0,\\n        I kept it as it\\'s mandatory for understanding\"\"\"\\n        # for i in range(n+1):\\n        #     for j in range(m+1):\\n        #         if i == 0 or j == 0:\\n        #             dp[i][j] == 0\\n        \\n        \"\"\" populating dp arr \"\"\"\\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                # found common | text1[i] == text2[j] \\n                if str1[i-1] == str2[j-1]:\\n                    dp[i][j] = 1 + dp[i-1][j-1]\\n                # skipping \\n                else:\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n            \\n            \\n        \"\"\" GETTING Longest Common Subsequence \"\"\"\\n        string, i, j  = \"\", n, m\\n        \\n        while i > 0 and j > 0:\\n            if str1[i-1] == str2[j-1]:\\n                string += str1[i-1]\\n                i -= 1\\n                j -= 1\\n            \\n            else:\\n                if dp[i][j-1] > dp[i-1][j]:\\n                    # string += str2[j-1]\\n                    j -= 1\\n                else:\\n                    # string += str1[i-1]\\n                    i -= 1    \\n                \\n        \\n        \"\"\" Forming SCS | MERGING lcs + remaining letters from str1 & str2\"\"\"\\n        lcs = string[::-1]# CORRECTING THE ORDER OF LCS | REVERSING STRING\\n        i, j, k = 0, 0 , 0 \\n        \\n        scs = \"\"\\n        while i < n and j < m and k < len(lcs):\\n            if str1[i] != lcs[k]:\\n                scs += str1[i]\\n                i += 1\\n                \\n            elif str2[j] != lcs[k]:\\n                scs += str2[j]\\n                j += 1\\n            \\n            else:\\n                scs += lcs[k]\\n                k += 1\\n                i += 1\\n                j += 1\\n        return scs + str1[i:] + str2[j:] + lcs[k:]\\n    \\n\"\"\" \\nALGO\\nTC : O(n*m)\\nSc : O(n*m)\\n\\n\\n************************PRINTING LCSubsequence USING DP ARRAY***************************** \\n\\nApproach:\\nstarting from the end of the dp table and traversing towards the top [0][0] \\nif the text1[i] == text2[j] digonaly moving back, while storing the letter to a string.\\n    \\nif text1[i] != text2[j], then we\\'ll have to move to the cell that has A greater LCS value only bc \"LCS\" is calculated\\nusing maxVal of lcs only, that\\'s what the condition we have in the else part. \\n    \\nEND we\\'ll have to reverse the string to make it straight.      \\n\\n\\n*****************************Forming SCS******************************************************\\n\\nFORMULATE FOR SCS\\n[ Shortest Common Supersequence == lcs + remaining letters from both str1 & str2 ]  | lcs = Longest Common Subsequence\\n\\ncommon supersequence == str1 + str2\\n                     == (lcs + remaining letters in str1) + (lcs + remaining letters in str2) \\n                     == 2 * lcs + remaining letters in (str1 & str2)\\n                     \\ntheir for, to get Shortest Common Supersequence we can remove 1 extra redundant lcs from common supersequence.\\n\\nSCS = lcs + remaining letters in (str1 & str2)\\n\\n\"\"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n\\t\\t\\n        n, m = len(str1), len(str2)\\n        \\n        # DP array | rows = inidices of text1, col = indices of text2\\n        dp = [[0 for j in range(m+1)] for n in range(n+1)]\\n          \\n        \"\"\"initialization | Not required as already all values in dp array is 0,\\n        I kept it as it\\'s mandatory for understanding\"\"\"\\n        # for i in range(n+1):\\n        #     for j in range(m+1):\\n        #         if i == 0 or j == 0:\\n        #             dp[i][j] == 0\\n        \\n        \"\"\" populating dp arr \"\"\"\\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                # found common | text1[i] == text2[j] \\n                if str1[i-1] == str2[j-1]:\\n                    dp[i][j] = 1 + dp[i-1][j-1]\\n                # skipping \\n                else:\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n            \\n            \\n        \"\"\" GETTING Longest Common Subsequence \"\"\"\\n        string, i, j  = \"\", n, m\\n        \\n        while i > 0 and j > 0:\\n            if str1[i-1] == str2[j-1]:\\n                string += str1[i-1]\\n                i -= 1\\n                j -= 1\\n            \\n            else:\\n                if dp[i][j-1] > dp[i-1][j]:\\n                    # string += str2[j-1]\\n                    j -= 1\\n                else:\\n                    # string += str1[i-1]\\n                    i -= 1    \\n                \\n        \\n        \"\"\" Forming SCS | MERGING lcs + remaining letters from str1 & str2\"\"\"\\n        lcs = string[::-1]# CORRECTING THE ORDER OF LCS | REVERSING STRING\\n        i, j, k = 0, 0 , 0 \\n        \\n        scs = \"\"\\n        while i < n and j < m and k < len(lcs):\\n            if str1[i] != lcs[k]:\\n                scs += str1[i]\\n                i += 1\\n                \\n            elif str2[j] != lcs[k]:\\n                scs += str2[j]\\n                j += 1\\n            \\n            else:\\n                scs += lcs[k]\\n                k += 1\\n                i += 1\\n                j += 1\\n        return scs + str1[i:] + str2[j:] + lcs[k:]\\n    \\n\"\"\" \\nALGO\\nTC : O(n*m)\\nSc : O(n*m)\\n\\n\\n************************PRINTING LCSubsequence USING DP ARRAY***************************** \\n\\nApproach:\\nstarting from the end of the dp table and traversing towards the top [0][0] \\nif the text1[i] == text2[j] digonaly moving back, while storing the letter to a string.\\n    \\nif text1[i] != text2[j], then we\\'ll have to move to the cell that has A greater LCS value only bc \"LCS\" is calculated\\nusing maxVal of lcs only, that\\'s what the condition we have in the else part. \\n    \\nEND we\\'ll have to reverse the string to make it straight.      \\n\\n\\n*****************************Forming SCS******************************************************\\n\\nFORMULATE FOR SCS\\n[ Shortest Common Supersequence == lcs + remaining letters from both str1 & str2 ]  | lcs = Longest Common Subsequence\\n\\ncommon supersequence == str1 + str2\\n                     == (lcs + remaining letters in str1) + (lcs + remaining letters in str2) \\n                     == 2 * lcs + remaining letters in (str1 & str2)\\n                     \\ntheir for, to get Shortest Common Supersequence we can remove 1 extra redundant lcs from common supersequence.\\n\\nSCS = lcs + remaining letters in (str1 & str2)\\n\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299223,
                "title": "by-finding-longest-common-subseqeunce",
                "content": "```\\nclass Solution {\\npublic:\\n// First finding longest common subsequnce\\n    string rec(int n, int m, string& text1, string& text2, vector<vector<string>>& dp){\\n        if(n==0 or m==0){\\n            return \"\";\\n        }\\n        else if(dp[n][m]!=\"A\"){\\n            return dp[n][m];\\n        }\\n        if(text1[n-1]==text2[m-1]){\\n            return dp[n][m]=text1[n-1]+rec(n-1, m-1, text1, text2, dp);\\n        }\\n        string left=rec(n-1, m, text1, text2, dp);\\n        string right=rec(n, m-1, text1, text2, dp);\\n        if(left.size()>right.size())\\n          return dp[n][m]=left;\\n        else \\n          return dp[n][m]=right;\\n    }\\n    string shortestCommonSupersequence(string text1, string text2) {\\n        int n= text1.size(), m=text2.size();\\n        vector<vector<string>> dp(n+1, vector<string>(m+1, \"A\"));\\n        string lcs=rec(n, m, text1, text2, dp);\\n\\t\\t// lcs string is the longest common subsequence but in the reverse order.\\n        reverse(lcs.begin(), lcs.end());\\n        string ans;\\n        int i=0, j=0, k=0;\\n        while(k<lcs.size()){\\n           if(lcs[k]!=text1[i]){\\n               ans+=text1[i];\\n               i++;\\n           }\\n           if(lcs[k]!=text2[j]){\\n               ans+=text2[j];\\n               j++;\\n           }\\n           if(lcs[k]==text1[i] and lcs[k]==text2[j]){\\n               ans+=lcs[k];\\n               k++;\\n               i++;\\n               j++;\\n           }\\n        }\\n        while(i<text1.size()){\\n            ans+=text1[i];\\n            i++;\\n        }\\n        while(j<text2.size()){\\n            ans+=text2[j];\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// First finding longest common subsequnce\\n    string rec(int n, int m, string& text1, string& text2, vector<vector<string>>& dp){\\n        if(n==0 or m==0){\\n            return \"\";\\n        }\\n        else if(dp[n][m]!=\"A\"){\\n            return dp[n][m];\\n        }\\n        if(text1[n-1]==text2[m-1]){\\n            return dp[n][m]=text1[n-1]+rec(n-1, m-1, text1, text2, dp);\\n        }\\n        string left=rec(n-1, m, text1, text2, dp);\\n        string right=rec(n, m-1, text1, text2, dp);\\n        if(left.size()>right.size())\\n          return dp[n][m]=left;\\n        else \\n          return dp[n][m]=right;\\n    }\\n    string shortestCommonSupersequence(string text1, string text2) {\\n        int n= text1.size(), m=text2.size();\\n        vector<vector<string>> dp(n+1, vector<string>(m+1, \"A\"));\\n        string lcs=rec(n, m, text1, text2, dp);\\n\\t\\t// lcs string is the longest common subsequence but in the reverse order.\\n        reverse(lcs.begin(), lcs.end());\\n        string ans;\\n        int i=0, j=0, k=0;\\n        while(k<lcs.size()){\\n           if(lcs[k]!=text1[i]){\\n               ans+=text1[i];\\n               i++;\\n           }\\n           if(lcs[k]!=text2[j]){\\n               ans+=text2[j];\\n               j++;\\n           }\\n           if(lcs[k]==text1[i] and lcs[k]==text2[j]){\\n               ans+=lcs[k];\\n               k++;\\n               i++;\\n               j++;\\n           }\\n        }\\n        while(i<text1.size()){\\n            ans+=text1[i];\\n            i++;\\n        }\\n        while(j<text2.size()){\\n            ans+=text2[j];\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154596,
                "title": "c-lcs-well-explained-aditya-verma",
                "content": "first through tabulation /bottom up approach we will fill the table . and from that table we will make the required shortest common supersequence .\\nSo basically  shortest common supersequence  will contain the shortest string from which we can form both str1 and str2 , so we will find the LCS through tabulation , after that we will slightly modify the printing of LCS approach by ADITYA VERMA SIR \\nlink for printing shortest common supersequence  :https://www.youtube.com/watch?v=hbTaCmQGqLg&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=29\\nlink for printing of LCS: https://www.youtube.com/watch?v=x5hQvnUcjiM&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=23 \\nand for  shortest common supersequence : https://www.youtube.com/watch?v=823Grn4_dCQ&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=24\\n\\nnow as we know that shortest common supersequence will contain the LCS between them , + the extra characters which are not in the LCS BUT PRESENT IN BOTH THE STRINGS str1 and str2, \\nso we will be modifying the printLCS function , and also keep in mind that order should be maintained, because   SEQUENCE = order Maintainedn + continous\\n\\n```\\nclass Solution {\\npublic:\\n    string printLCS(string str1, string str2,int m , int n, vector<vector<int>> &t){\\n        \\n        int i=m;\\n        int j=n;\\n        string s=\"\";\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                s.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(t[i][j-1] > t[i-1][j])\\n                {   s.push_back(str2[j-1]);  // so we will pick the table value having smaller value , because it would be at last , after reversing the string \\n                    j--;\\n                }\\n                else\\n                {   s.push_back(str1[i-1]);\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n            s.push_back(str1[i-1]);    // if any characters left from str1\\n            i--;\\n        }\\n         while(j>0){\\n            s.push_back(str2[j-1]);   // if any characters left from str2\\n            j--;\\n        }\\n        \\n        reverse(s.begin(),s.end());\\n        \\n        return s;\\n        \\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.size();\\n        int n=str2.size();\\n        vector<vector<int>> t(m+1,vector<int>(n+1));\\n        \\n        for(int i=0;i<m+1;i++){\\n            for(int j=0;j<n+1;j++){\\n                if(i==0 || j==0)\\n                t[i][j]=0;\\n            }\\n        }\\n        \\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(str1[i-1]==str2[j-1])\\n                  t[i][j]=1+t[i-1][j-1];\\n                \\n                else\\n                  t[i][j]=max(t[i-1][j],t[i][j-1]);\\n            }\\n        }\\n        \\n        \\n        string s=printLCS(str1,str2,m,n,t);\\n        \\n        return s;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    string printLCS(string str1, string str2,int m , int n, vector<vector<int>> &t){\\n        \\n        int i=m;\\n        int j=n;\\n        string s=\"\";\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                s.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1926618,
                "title": "c-dp-lcs-derivative",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m = str1.length();\\n        int n = str2.length();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n            dp[i][0] = 0;\\n        for(int i=0;i<=n;i++)\\n            dp[0][i] = 0;\\n        for(int i=1;i<=m;i++) {\\n            for(int j=1;j<=n;j++) {\\n                if(str1[i-1] == str2[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        stack<char> s;\\n        int i = m;\\n        int j = n;\\n        while(i > 0 && j > 0) {\\n            if(str1[i-1] == str2[j-1]) {\\n                s.push(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n                \\n            else if(dp[i-1][j] > dp[i][j-1]) {\\n                s.push(str1[i-1]);\\n                i--;\\n            }\\n                \\n            else {\\n                s.push(str2[j-1]);\\n                j--;\\n            }\\n                \\n        }\\n        while(i>0) {\\n            s.push(str1[i-1]);\\n            i--;\\n        }\\n            \\n        while(j>0) {\\n            s.push(str2[j-1]);\\n            j--;\\n        }\\n            \\n        \\n        string ans;\\n        while(!s.empty()) {\\n            char c = s.top();\\n            ans.push_back(c);\\n            s.pop();\\n        }\\n        \\n        return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m = str1.length();\\n        int n = str2.length();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n            dp[i][0] = 0;\\n        for(int i=0;i<=n;i++)\\n            dp[0][i] = 0;\\n        for(int i=1;i<=m;i++) {\\n            for(int j=1;j<=n;j++) {\\n                if(str1[i-1] == str2[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        stack<char> s;\\n        int i = m;\\n        int j = n;\\n        while(i > 0 && j > 0) {\\n            if(str1[i-1] == str2[j-1]) {\\n                s.push(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n                \\n            else if(dp[i-1][j] > dp[i][j-1]) {\\n                s.push(str1[i-1]);\\n                i--;\\n            }\\n                \\n            else {\\n                s.push(str2[j-1]);\\n                j--;\\n            }\\n                \\n        }\\n        while(i>0) {\\n            s.push(str1[i-1]);\\n            i--;\\n        }\\n            \\n        while(j>0) {\\n            s.push(str2[j-1]);\\n            j--;\\n        }\\n            \\n        \\n        string ans;\\n        while(!s.empty()) {\\n            char c = s.top();\\n            ans.push_back(c);\\n            s.pop();\\n        }\\n        \\n        return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693516,
                "title": "c-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string text1, string text2) {\\n        int n = text1.size();\\n        int m = text2.size();\\n        \\n        int dp[n+1][m+1];\\n        \\n        for(int i = 0; i <= n; i++)\\n        {\\n            for(int j = 0; j <= m; j++)\\n            {\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(text1[i-1] == text2[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n\\n        int i = n, j = m;\\n        string str;\\n        while(i > 0 && j > 0)\\n        {\\n\\t\\t    /* If the characters corresponding to current cell (i, j) in text1 and text2 are same, \\n\\t\\t\\tthen the character is part of shortest supersequence. \\n\\t\\t\\tWe append it in output string and move diagonally to next cell (i.e. (i - 1, j - 1)).*/\\n            if(text1[i-1] == text2[j-1])\\n            {\\n                str.push_back(text1[i-1]);\\n                i--;\\n                j--;\\n            }\\n\\t\\t\\t// If current character in text1 and text2 are different/\\n            else if(dp[i-1][j] > dp[i][j-1])\\n            {\\n                str.push_back(text1[i-1]);\\n                i--;\\n            }\\n            else\\n            {\\n                str.push_back(text2[j-1]);\\n                j--;\\n            }\\n        }\\n\\t\\t/* If string text2 reaches its end i.e. j = 0, we add remaining\\n            characters of string text1 in the output string*/\\n        while(i > 0)\\n        {\\n            str.push_back(text1[i-1]);\\n            i--;\\n        }\\n\\t\\t/* If string text1 reaches its end i.e. i = 0, we add remaining\\n            characters of string text2 in the output string*/\\n        while(j > 0)\\n        {\\n            str.push_back(text2[j-1]);\\n                j--;\\n        }\\n        \\n        reverse(str.begin(), str.end());\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string text1, string text2) {\\n        int n = text1.size();\\n        int m = text2.size();\\n        \\n        int dp[n+1][m+1];\\n        \\n        for(int i = 0; i <= n; i++)\\n        {\\n            for(int j = 0; j <= m; j++)\\n            {\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(text1[i-1] == text2[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n\\n        int i = n, j = m;\\n        string str;\\n        while(i > 0 && j > 0)\\n        {\\n\\t\\t    /* If the characters corresponding to current cell (i, j) in text1 and text2 are same, \\n\\t\\t\\tthen the character is part of shortest supersequence. \\n\\t\\t\\tWe append it in output string and move diagonally to next cell (i.e. (i - 1, j - 1)).*/\\n            if(text1[i-1] == text2[j-1])\\n            {\\n                str.push_back(text1[i-1]);\\n                i--;\\n                j--;\\n            }\\n\\t\\t\\t// If current character in text1 and text2 are different/\\n            else if(dp[i-1][j] > dp[i][j-1])\\n            {\\n                str.push_back(text1[i-1]);\\n                i--;\\n            }\\n            else\\n            {\\n                str.push_back(text2[j-1]);\\n                j--;\\n            }\\n        }\\n\\t\\t/* If string text2 reaches its end i.e. j = 0, we add remaining\\n            characters of string text1 in the output string*/\\n        while(i > 0)\\n        {\\n            str.push_back(text1[i-1]);\\n            i--;\\n        }\\n\\t\\t/* If string text1 reaches its end i.e. i = 0, we add remaining\\n            characters of string text2 in the output string*/\\n        while(j > 0)\\n        {\\n            str.push_back(text2[j-1]);\\n                j--;\\n        }\\n        \\n        reverse(str.begin(), str.end());\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679078,
                "title": "c-solution-dp-top-down-approach-faster-than-95-81-percent",
                "content": "```\\n// SCS of text1 + text2 = s(text1) + s(text2) - s(LCS)\\n// DP Table for both the strings will be created just the way it is did for LCS\\n// Then starting from dp[m][n] of DP table and going backwards, output string will be made(reversed format)\\n// Then it is reversed and returned\\n\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m = str1.length();\\n        int n = str2.length();\\n        string output;\\n        \\n        int dp[m + 1][n + 1];\\n        \\n        for(int i = 0; i < m; ++i)\\n            dp[i][0] = 0;\\n        \\n        for(int j = 0; j < n; ++j)\\n            dp[0][j] = 0;\\n        \\n        for(int i = 1; i < (m + 1); ++i) {\\n            for(int j = 1; j < (n + 1); ++j) {\\n                if(str1[i - 1] == str2[j - 1])\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                else\\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n        // DP Table is created til now, below code will do the work of pushing characters into output string\\n        \\n        int i = m;\\n        int j = n;\\n\\n        while(i > 0 && j > 0) {\\n            if(str1[i - 1] == str2[j - 1]) {\\n                output.push_back(str1[i - 1]);\\n                i--;\\n                j--;\\n            }\\n            else {\\n                if(dp[i - 1][j] > dp[i][j - 1]) {\\n                    output.push_back(str1[i - 1]);\\n                    i--;\\n                }\\n                else {\\n                    output.push_back(str2[j - 1]);\\n                    j--;\\n                }\\n            }\\n        }\\n\\n        while(i > 0) {\\n            output.push_back(str1[i - 1]);\\n            i--;\\n        }\\n\\n        while(j > 0) {\\n            output.push_back(str2[j - 1]);\\n            j--;\\n        }\\n\\n        reverse(output.begin(), output.end());\\n\\n        return output;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// SCS of text1 + text2 = s(text1) + s(text2) - s(LCS)\\n// DP Table for both the strings will be created just the way it is did for LCS\\n// Then starting from dp[m][n] of DP table and going backwards, output string will be made(reversed format)\\n// Then it is reversed and returned\\n\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m = str1.length();\\n        int n = str2.length();\\n        string output;\\n        \\n        int dp[m + 1][n + 1];\\n        \\n        for(int i = 0; i < m; ++i)\\n            dp[i][0] = 0;\\n        \\n        for(int j = 0; j < n; ++j)\\n            dp[0][j] = 0;\\n        \\n        for(int i = 1; i < (m + 1); ++i) {\\n            for(int j = 1; j < (n + 1); ++j) {\\n                if(str1[i - 1] == str2[j - 1])\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                else\\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n        // DP Table is created til now, below code will do the work of pushing characters into output string\\n        \\n        int i = m;\\n        int j = n;\\n\\n        while(i > 0 && j > 0) {\\n            if(str1[i - 1] == str2[j - 1]) {\\n                output.push_back(str1[i - 1]);\\n                i--;\\n                j--;\\n            }\\n            else {\\n                if(dp[i - 1][j] > dp[i][j - 1]) {\\n                    output.push_back(str1[i - 1]);\\n                    i--;\\n                }\\n                else {\\n                    output.push_back(str2[j - 1]);\\n                    j--;\\n                }\\n            }\\n        }\\n\\n        while(i > 0) {\\n            output.push_back(str1[i - 1]);\\n            i--;\\n        }\\n\\n        while(j > 0) {\\n            output.push_back(str2[j - 1]);\\n            j--;\\n        }\\n\\n        reverse(output.begin(), output.end());\\n\\n        return output;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520759,
                "title": "c-using-dp-lcs-commented",
                "content": "```\\nstring shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.length();\\n        int n=str2.length();\\n        vector<vector<int>>dp(m+1,vector<int>(n+1));\\n        for(int i=0;i<m+1;i++){\\n            for(int j=0;j<n+1;j++){\\n                if(i==0||j==0){\\n                    dp[i][j]=0;\\n                }else if(str1[i-1]==str2[j-1]){            //DP for finding LCS\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        string s=\"\";\\n        int i=m;\\n        int j=n;\\n        while(i>0&&j>0){\\n            if(str1[i-1]==str2[j-1]){         // if equal add to ans string (s) \\n                s=s+str1[i-1];\\n                i--;\\n                j--;\\n            }\\n            //Not equal check from which side of dp matrix we can get the LCS\\n            else if(dp[i-1][j]>=dp[i][j-1]){   \\n                s=s+str1[i-1];\\n                i--;\\n            }else if(dp[i][j-1]>dp[i-1][j]){\\n                s=s+str2[j-1];\\n                j--;\\n            }\\n        }\\n        // now check is i ans j both equal to zero if not then make it to zero\\n        // and add strings in ans string (s)\\n        while(i>0){\\n            s=s+str1[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            s=s+str2[j-1];\\n            j--;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.length();\\n        int n=str2.length();\\n        vector<vector<int>>dp(m+1,vector<int>(n+1));\\n        for(int i=0;i<m+1;i++){\\n            for(int j=0;j<n+1;j++){\\n                if(i==0||j==0){\\n                    dp[i][j]=0;\\n                }else if(str1[i-1]==str2[j-1]){            //DP for finding LCS\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        string s=\"\";\\n        int i=m;\\n        int j=n;\\n        while(i>0&&j>0){\\n            if(str1[i-1]==str2[j-1]){         // if equal add to ans string (s) \\n                s=s+str1[i-1];\\n                i--;\\n                j--;\\n            }\\n            //Not equal check from which side of dp matrix we can get the LCS\\n            else if(dp[i-1][j]>=dp[i][j-1]){   \\n                s=s+str1[i-1];\\n                i--;\\n            }else if(dp[i][j-1]>dp[i-1][j]){\\n                s=s+str2[j-1];\\n                j--;\\n            }\\n        }\\n        // now check is i ans j both equal to zero if not then make it to zero\\n        // and add strings in ans string (s)\\n        while(i>0){\\n            s=s+str1[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            s=s+str2[j-1];\\n            j--;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479075,
                "title": "dp-intuitive-solution-with-slight-variation-of-lcs",
                "content": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        m = len(str1)\\n        n = len(str2) \\n        \\n        # construct the dp table\\n        t = [[0 for j in range(n + 1)] for i in range(m + 1)]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if str1[i-1] == str2[j-1]:\\n                    t[i][j] = 1 + t[i-1][j-1]\\n                else:\\n                    t[i][j] = max(t[i-1][j], t[i][j-1])\\n            \\n            \\n\\n        i = len(str1)\\n        j = len(str2)\\n        \\n        string = \\'\\'\\n        \\n        while i>0 and j>0:\\n            if str1[i-1] == str2[j-1]:\\n                string += str1[i-1]\\n                i -= 1\\n                j -= 1\\n            else:\\n                if t[i][j-1] > t[i-1][j]:\\n                    string += str2[j-1]\\n                    j -= 1\\n                else:\\n                    string += str1[i-1]\\n                    i -= 1\\n        # now atleast ome string must have been exhausted\\n        # so for remaining string\\n        \\n        \\n        # if str1 is remaining\\n        while i>0:\\n            string += str1[i-1]\\n            i -= 1\\n        \\n        # if str2 is remaining\\n        while j>0:\\n            string += str2[j-1]\\n            j -= 1\\n        \\n        return string[::-1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        m = len(str1)\\n        n = len(str2) \\n        \\n        # construct the dp table\\n        t = [[0 for j in range(n + 1)] for i in range(m + 1)]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if str1[i-1] == str2[j-1]:\\n                    t[i][j] = 1 + t[i-1][j-1]\\n                else:\\n                    t[i][j] = max(t[i-1][j], t[i][j-1])\\n            \\n            \\n\\n        i = len(str1)\\n        j = len(str2)\\n        \\n        string = \\'\\'\\n        \\n        while i>0 and j>0:\\n            if str1[i-1] == str2[j-1]:\\n                string += str1[i-1]\\n                i -= 1\\n                j -= 1\\n            else:\\n                if t[i][j-1] > t[i-1][j]:\\n                    string += str2[j-1]\\n                    j -= 1\\n                else:\\n                    string += str1[i-1]\\n                    i -= 1\\n        # now atleast ome string must have been exhausted\\n        # so for remaining string\\n        \\n        \\n        # if str1 is remaining\\n        while i>0:\\n            string += str1[i-1]\\n            i -= 1\\n        \\n        # if str2 is remaining\\n        while j>0:\\n            string += str2[j-1]\\n            j -= 1\\n        \\n        return string[::-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333342,
                "title": "java-using-lcs",
                "content": "* First we use tabulation or (Bottom Up) approach for finding length of longest common Subsequence\\n* Then we backtrack to find any one longest common subsequence and store it in stringbuffer\\n* Then simply add those chars in stringbuffer which are not in lcs of both the strings s1 and s2( keeping their location intact )\\n```\\npublic String shortestCommonSupersequence(String s1, String s2) {\\n       \\n        int m = s1.length();\\n        int n = s2.length();\\n        \\n        int arr[][] = new int[m+1][n+1];\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                    arr[i][j] = 1+arr[i-1][j-1];\\n                }\\n                else{\\n                    arr[i][j] = Math.max(arr[i-1][j],arr[i][j-1]);\\n                }\\n            }\\n        }\\n        int lcs = arr[m][n];\\n        StringBuffer sb = new StringBuffer(\"\");\\n        int i=m,j=n;\\n        while(i>0 && j>0){\\n            if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                sb.append(s1.charAt(i-1));\\n                i--;j--;\\n            }\\n            else{\\n                if(arr[i][j-1]>arr[i-1][j]){\\n                    j--;\\n                }\\n                else{\\n                    i--;\\n                }\\n            }\\n        }\\n        sb.reverse();\\n        int ptr1=0,ptr2=0,ptr3=0;\\n        while(lcs-->0){\\n            while(ptr1<s1.length()&&s1.charAt(ptr1)!=sb.charAt(ptr3)){\\n                sb.insert(ptr3,s1.charAt(ptr1));ptr1++;ptr3++;\\n            }\\n            ptr1++;\\n            while(ptr2<s2.length()&&s2.charAt(ptr2)!=sb.charAt(ptr3)){\\n                sb.insert(ptr3,s2.charAt(ptr2));ptr2++;ptr3++;\\n            }\\n            ptr2++;\\n            ptr3++;\\n        }\\n        while(ptr1<s1.length()){\\n            sb.insert(ptr3,s1.charAt(ptr1));\\n            ptr1++;ptr3++;\\n        }\\n        while(ptr2<s2.length()){\\n            sb.insert(ptr3,s2.charAt(ptr2));\\n            ptr2++;ptr3++;\\n        }\\n        return sb.toString();\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "* First we use tabulation or (Bottom Up) approach for finding length of longest common Subsequence\\n* Then we backtrack to find any one longest common subsequence and store it in stringbuffer\\n* Then simply add those chars in stringbuffer which are not in lcs of both the strings s1 and s2( keeping their location intact )\\n```\\npublic String shortestCommonSupersequence(String s1, String s2) {\\n       \\n        int m = s1.length();\\n        int n = s2.length();\\n        \\n        int arr[][] = new int[m+1][n+1];\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                    arr[i][j] = 1+arr[i-1][j-1];\\n                }\\n                else{\\n                    arr[i][j] = Math.max(arr[i-1][j],arr[i][j-1]);\\n                }\\n            }\\n        }\\n        int lcs = arr[m][n];\\n        StringBuffer sb = new StringBuffer(\"\");\\n        int i=m,j=n;\\n        while(i>0 && j>0){\\n            if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                sb.append(s1.charAt(i-1));\\n                i--;j--;\\n            }\\n            else{\\n                if(arr[i][j-1]>arr[i-1][j]){\\n                    j--;\\n                }\\n                else{\\n                    i--;\\n                }\\n            }\\n        }\\n        sb.reverse();\\n        int ptr1=0,ptr2=0,ptr3=0;\\n        while(lcs-->0){\\n            while(ptr1<s1.length()&&s1.charAt(ptr1)!=sb.charAt(ptr3)){\\n                sb.insert(ptr3,s1.charAt(ptr1));ptr1++;ptr3++;\\n            }\\n            ptr1++;\\n            while(ptr2<s2.length()&&s2.charAt(ptr2)!=sb.charAt(ptr3)){\\n                sb.insert(ptr3,s2.charAt(ptr2));ptr2++;ptr3++;\\n            }\\n            ptr2++;\\n            ptr3++;\\n        }\\n        while(ptr1<s1.length()){\\n            sb.insert(ptr3,s1.charAt(ptr1));\\n            ptr1++;ptr3++;\\n        }\\n        while(ptr2<s2.length()){\\n            sb.insert(ptr3,s2.charAt(ptr2));\\n            ptr2++;ptr3++;\\n        }\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1311165,
                "title": "c-not-using-lcs-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int dp[str1.length()+1][str2.length()+1];\\n        for(int i=0;i<=str1.length();i++)\\n            for(int j=0;j<=str2.length();j++)\\n                dp[i][j] = 10000000;  //inf\\n        \\n\\t\\t//following is the code as per the ques \\n        for(int i=0;i<=str1.length();i++){\\n            for(int j=0;j<=str2.length();j++){\\n                if(i==0||j==0){\\n                    dp[i][j] = (i+j);  //if one string end , we have to take all the elements of other string\\n                }\\n                else{\\n                    if(str1[i-1]==str2[j-1]){\\n                        dp[i][j] = 1 + dp[i-1][j-1];\\n                    }\\n                    else{\\n                        dp[i][j] = 1 + min(dp[i-1][j],dp[i][j-1]);\\n                    }\\n                }\\n            }\\n        }\\n\\t\\t\\n        int r=str1.length(),c=str2.length();\\n        string ans;\\n        //we traversed back the way we got down in code\\n        \\n        while(r>0 && c>0){\\n            if(str1[r-1]==str2[c-1]){\\n                ans.push_back(str1[r-1]);\\n                --r;--c;\\n            }\\n            else{\\n                if(dp[r-1][c]>dp[r][c-1]){\\n                    ans.push_back(str2[c-1]);\\n                    c--;\\n                }\\n                else{\\n                    ans.push_back(str1[r-1]);\\n                    r--;\\n                }\\n            }\\n        }\\n        while(r>0){\\n            ans.push_back(str1[r-1]);\\n            r--;\\n        }\\n        while(c>0){\\n            ans.push_back(str2[c-1]);\\n            c--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int dp[str1.length()+1][str2.length()+1];\\n        for(int i=0;i<=str1.length();i++)\\n            for(int j=0;j<=str2.length();j++)\\n                dp[i][j] = 10000000;  //inf\\n        \\n\\t\\t//following is the code as per the ques \\n        for(int i=0;i<=str1.length();i++){\\n            for(int j=0;j<=str2.length();j++){\\n                if(i==0||j==0){\\n                    dp[i][j] = (i+j);  //if one string end , we have to take all the elements of other string\\n                }\\n                else{\\n                    if(str1[i-1]==str2[j-1]){\\n                        dp[i][j] = 1 + dp[i-1][j-1];\\n                    }\\n                    else{\\n                        dp[i][j] = 1 + min(dp[i-1][j],dp[i][j-1]);\\n                    }\\n                }\\n            }\\n        }\\n\\t\\t\\n        int r=str1.length(),c=str2.length();\\n        string ans;\\n        //we traversed back the way we got down in code\\n        \\n        while(r>0 && c>0){\\n            if(str1[r-1]==str2[c-1]){\\n                ans.push_back(str1[r-1]);\\n                --r;--c;\\n            }\\n            else{\\n                if(dp[r-1][c]>dp[r][c-1]){\\n                    ans.push_back(str2[c-1]);\\n                    c--;\\n                }\\n                else{\\n                    ans.push_back(str1[r-1]);\\n                    r--;\\n                }\\n            }\\n        }\\n        while(r>0){\\n            ans.push_back(str1[r-1]);\\n            r--;\\n        }\\n        while(c>0){\\n            ans.push_back(str2[c-1]);\\n            c--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255450,
                "title": "c-solution-using-lcs",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s1, string s2) \\n    {\\n        int len1 = s1.size(), len2 = s2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0; i<=len1; i++)\\n            dp[i][0] = \"\";\\n        \\n        for(int i=0; i<=len2; i++)\\n            dp[0][i] = \"\";\\n        \\n        // Finding LCS\\n        for(int i=1; i<=len1; i++)\\n        {\\n            for(int j=1; j<=len2; j++)\\n            {\\n                if(s1[i-1] == s2[j-1])\\n                    dp[i][j] = dp[i-1][j-1] + s2[j-1];\\n                \\n                else\\n                    dp[i][j] = (dp[i-1][j].size() < dp[i][j-1].size()) ? dp[i][j-1] : dp[i-1][j];\\n            }\\n        }\\n        \\n        string lcs = dp[len1][len2];\\n        int i=0, j=0;\\n        string ans;\\n        \\n        for(auto c:lcs)\\n        {\\n            while(s1[i] != c and i<len1)\\n                ans += s1[i++];\\n            \\n            while(s2[j] != c and j<len2)\\n                ans += s2[j++];\\n            \\n            i++;\\n            j++;\\n            ans += c;\\n        }\\n        \\n        while(i<len1)\\n            ans += s1[i++];\\n        \\n        while(j<len2)\\n            ans += s2[j++];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s1, string s2) \\n    {\\n        int len1 = s1.size(), len2 = s2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0; i<=len1; i++)\\n            dp[i][0] = \"\";\\n        \\n        for(int i=0; i<=len2; i++)\\n            dp[0][i] = \"\";\\n        \\n        // Finding LCS\\n        for(int i=1; i<=len1; i++)\\n        {\\n            for(int j=1; j<=len2; j++)\\n            {\\n                if(s1[i-1] == s2[j-1])\\n                    dp[i][j] = dp[i-1][j-1] + s2[j-1];\\n                \\n                else\\n                    dp[i][j] = (dp[i-1][j].size() < dp[i][j-1].size()) ? dp[i][j-1] : dp[i-1][j];\\n            }\\n        }\\n        \\n        string lcs = dp[len1][len2];\\n        int i=0, j=0;\\n        string ans;\\n        \\n        for(auto c:lcs)\\n        {\\n            while(s1[i] != c and i<len1)\\n                ans += s1[i++];\\n            \\n            while(s2[j] != c and j<len2)\\n                ans += s2[j++];\\n            \\n            i++;\\n            j++;\\n            ans += c;\\n        }\\n        \\n        while(i<len1)\\n            ans += s1[i++];\\n        \\n        while(j<len2)\\n            ans += s2[j++];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176701,
                "title": "java-bottom-up-dp-solution-similar-to-lcs",
                "content": "\\tclass Solution {\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        int[][] t = new int[s1.length() +1][s2.length()+1];\\n        \\n        int m = s1.length();\\n        int n = s2.length();\\n        \\n        for(int i = 0; i <= m; i++) {\\n            for(int j = 0; j <= n; j++) {\\n                if(i == 0 || j == 0) t[i][j] = 0;\\n                else if(s1.charAt(i-1) == s2.charAt(j-1)) {\\n                    t[i][j] = 1 + t[i-1][j-1];\\n                } else {\\n                    t[i][j] = Math.max(t[i-1][j], t[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int i = m;\\n        int j = n;\\n        StringBuffer output = new StringBuffer();\\n        \\n        while(i > 0 && j > 0) {\\n            if (s1.charAt(i-1) == s2.charAt(j-1)) {\\n                output.append(s1.charAt(i-1));\\n                i--;\\n                j--;\\n            } else if( t[i-1][j] > t[i][j-1] ) {\\n                output.append(s1.charAt(i-1));\\n                i--;\\n            } else {\\n                output.append(s2.charAt(j-1));\\n                j--;\\n            }\\n        }\\n        \\n        while(i > 0) {\\n           output.append(s1.charAt(i-1));\\n            i--; \\n        }\\n        \\n                \\n        while(j > 0) {\\n           output.append(s2.charAt(j-1));\\n            j--; \\n        }\\n        \\n        return output.reverse().toString();\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        int[][] t = new int[s1.length() +1][s2.length()+1];\\n        \\n        int m = s1.length();\\n        int n = s2.length();\\n        \\n        for(int i = 0; i <= m; i++) {\\n            for(int j = 0; j <= n; j++) {\\n                if(i == 0 || j == 0) t[i][j] = 0;\\n                else if(s1.charAt(i-1) == s2.charAt(j-1)) {\\n                    t[i][j] = 1 + t[i-1][j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1150023,
                "title": "my-java-solution-using-the-concept-of-lcs",
                "content": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int length1 = str1.length();\\n        int length2 = str2.length();\\n        int [][] dp = new int [length1 + 1][length2 + 1];\\n        longestCommonSubsequence(str1, str2, dp, length1, length2);\\n        String result = buildTheResultString(str1, str2, length1, length2, dp);\\n        return result;\\n    }\\n    \\n    // the code for the longest common subsequence\\n    public void longestCommonSubsequence(String s1, String s2, int [][] dp, int length1, int length2) {\\n        for (int i=1; i<=length1; i++) {\\n            for (int j=1; j<=length2; j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1))\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\\n                else \\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n    }\\n    \\n    // building the final result\\n    public String buildTheResultString(String s1, String s2, int length1, int length2, int [][] dp) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = length1 - 1;\\n        int j = length2 - 1;\\n        while (i >= 0 || j >= 0) {\\n            if (i < 0 || j < 0) {\\n                char c = i < 0 ? s2.charAt(j--) : s1.charAt(i--);\\n                sb.append(c);\\n            }\\n            else if (s1.charAt(i) == s2.charAt(j)) {\\n                sb.append(s1.charAt(i));\\n                i -= 1;\\n                j -= 1;\\n            }\\n            else {\\n                char c = dp[i][j+1] > dp[i+1][j] ? s1.charAt(i--) : s2.charAt(j--);\\n                sb.append(c);\\n            }\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int length1 = str1.length();\\n        int length2 = str2.length();\\n        int [][] dp = new int [length1 + 1][length2 + 1];\\n        longestCommonSubsequence(str1, str2, dp, length1, length2);\\n        String result = buildTheResultString(str1, str2, length1, length2, dp);\\n        return result;\\n    }\\n    \\n    // the code for the longest common subsequence\\n    public void longestCommonSubsequence(String s1, String s2, int [][] dp, int length1, int length2) {\\n        for (int i=1; i<=length1; i++) {\\n            for (int j=1; j<=length2; j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1))\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\\n                else \\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n    }\\n    \\n    // building the final result\\n    public String buildTheResultString(String s1, String s2, int length1, int length2, int [][] dp) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = length1 - 1;\\n        int j = length2 - 1;\\n        while (i >= 0 || j >= 0) {\\n            if (i < 0 || j < 0) {\\n                char c = i < 0 ? s2.charAt(j--) : s1.charAt(i--);\\n                sb.append(c);\\n            }\\n            else if (s1.charAt(i) == s2.charAt(j)) {\\n                sb.append(s1.charAt(i));\\n                i -= 1;\\n                j -= 1;\\n            }\\n            else {\\n                char c = dp[i][j+1] > dp[i+1][j] ? s1.charAt(i--) : s2.charAt(j--);\\n                sb.append(c);\\n            }\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045517,
                "title": "c-cpp-solution-faster-than-100-dp",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string a, string b) {\\n       int n = a.length();\\n    int m = b.length();\\n    int t[n + 1][m + 1];\\n    for (int i = 0; i < n + 1; i++)\\n    {\\n        for (int j = 0; j < m + 1; j++)\\n        {\\n            if (i == 0 || j == 0)\\n                t[i][j] = 0;\\n        }\\n    }\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            if (a[i - 1] == b[j - 1])\\n                t[i][j] = 1 + t[i - 1][j - 1];\\n            else\\n            {\\n                t[i][j] = max(t[i - 1][j], t[i][j - 1]);\\n            }\\n        }\\n    }\\n    string op = \"\";\\n    int i = n, j = m;\\n    while (i > 0 && j > 0)\\n    {\\n        if (a[i - 1] == b[j - 1])\\n        {\\n            op.push_back(a[i - 1]);\\n            i--;\\n            j--;\\n        }\\n        else\\n        {\\n            if (t[i - 1][j] > t[i][j - 1])\\n            {\\n                op.push_back(a[i - 1]);\\n                i--;\\n            }\\n            else\\n            {\\n                op.push_back(b[j - 1]);\\n                j--;\\n            }\\n        }\\n    }\\n    while (i > 0)\\n    {\\n        op.push_back(a[i - 1]);\\n        i--;\\n    }\\n    while (j > 0)\\n    {\\n        op.push_back(b[j - 1]);\\n        j--;\\n    }\\n\\treverse(op.begin(), op.end());\\n    return op; \\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string shortestCommonSupersequence(string a, string b) {\\n       int n = a.length();\\n    int m = b.length();\\n    int t[n + 1][m + 1];\\n    for (int i = 0; i < n + 1; i++)\\n    {\\n        for (int j = 0; j < m + 1; j++)\\n        {\\n            if (i == 0 || j == 0)\\n                t[i][j] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 973686,
                "title": "memory-limit-exceed",
                "content": "I have used top-down approach to write the solution, it is giving me `MemoryLimitExceeded`\\nCan someone suggest some optimizations ? \\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        int n = s1.length(), m = s2.length();\\n        String[][] dp = new String[n][m];\\n        return recur(s1, s2, 0, 0, dp);\\n        \\n    }\\n    \\n    private String recur(String s1, String s2, int i, int j, String[][] dp){\\n        if(i == s1.length() && j == s2.length()) return \"\";\\n        if(i == s1.length()) return s2.substring(j);\\n        if(j == s2.length()) return s1.substring(i);\\n        if(dp[i][j] != null) return dp[i][j];\\n        String res = null;\\n        if(s1.charAt(i) == s2.charAt(j)){\\n            res = s1.charAt(i) + recur(s1, s2, i+1, j+1, dp);\\n        }else{\\n            String c1 = s2.charAt(j) + recur(s1, s2, i, j+1, dp);\\n            String c2 = s1.charAt(i) + recur(s1, s2, i+1, j, dp);\\n            res = c1.length() < c2.length() ? c1 : c2;\\n        }\\n        dp[i][j] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        int n = s1.length(), m = s2.length();\\n        String[][] dp = new String[n][m];\\n        return recur(s1, s2, 0, 0, dp);\\n        \\n    }\\n    \\n    private String recur(String s1, String s2, int i, int j, String[][] dp){\\n        if(i == s1.length() && j == s2.length()) return \"\";\\n        if(i == s1.length()) return s2.substring(j);\\n        if(j == s2.length()) return s1.substring(i);\\n        if(dp[i][j] != null) return dp[i][j];\\n        String res = null;\\n        if(s1.charAt(i) == s2.charAt(j)){\\n            res = s1.charAt(i) + recur(s1, s2, i+1, j+1, dp);\\n        }else{\\n            String c1 = s2.charAt(j) + recur(s1, s2, i, j+1, dp);\\n            String c2 = s1.charAt(i) + recur(s1, s2, i+1, j, dp);\\n            res = c1.length() < c2.length() ? c1 : c2;\\n        }\\n        dp[i][j] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880733,
                "title": "javascript-using-lcs",
                "content": "Tweaking Longest Common Subsequence to get supersequnce length and then inserting characters based on the minimum count\\n\\n```\\nvar shortestCommonSupersequence = function(str1, str2) {\\n    let len1 = str1.length;\\n    let len2 = str2.length;\\n    let table = [];\\n    for (let i = 0; i <= len1; i++)\\n        table[i] = new Array(len2);\\n    for (let i = 0; i <= len1; i++) {\\n        for (let j = 0; j <= len2; j++) {\\n            if (!i) {\\n                table[i][j] = j;\\n            } else if (!j) {\\n                table[i][j] = i;\\n            } else if (str1[i-1] == str2[j-1]) {\\n                table[i][j] = 1 + table[i-1][j-1];\\n            } else {\\n                table[i][j] = 1 + Math.min(table[i-1][j], table[i][j-1]);\\n            }\\n        }\\n    }\\n    let resLen = table[len1][len2];\\n    let result = new Array(resLen);\\n    let i = len1, j = len2;\\n    while (i > 0 && j > 0) {\\n        if (str1[i-1] == str2[j-1]) {\\n            result[resLen-1] = str1[i-1];\\n            i--;\\n            j--;\\n            resLen--;\\n        } else if (table[i-1][j] < table[i][j-1]) {\\n            result[resLen-1] = str1[i-1];\\n            i--;\\n            resLen--;\\n        } else {\\n            result[resLen-1] = str2[j-1];\\n            j--;\\n            resLen--;\\n        }\\n    }\\n    while (i > 0) {\\n        result[resLen-1] = str1[i-1];\\n        i--;\\n        resLen--;\\n    }\\n    while (j > 0) {\\n        result[resLen-1] = str2[j-1];\\n        j--;\\n        resLen--;\\n    }\\n    return result.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar shortestCommonSupersequence = function(str1, str2) {\\n    let len1 = str1.length;\\n    let len2 = str2.length;\\n    let table = [];\\n    for (let i = 0; i <= len1; i++)\\n        table[i] = new Array(len2);\\n    for (let i = 0; i <= len1; i++) {\\n        for (let j = 0; j <= len2; j++) {\\n            if (!i) {\\n                table[i][j] = j;\\n            } else if (!j) {\\n                table[i][j] = i;\\n            } else if (str1[i-1] == str2[j-1]) {\\n                table[i][j] = 1 + table[i-1][j-1];\\n            } else {\\n                table[i][j] = 1 + Math.min(table[i-1][j], table[i][j-1]);\\n            }\\n        }\\n    }\\n    let resLen = table[len1][len2];\\n    let result = new Array(resLen);\\n    let i = len1, j = len2;\\n    while (i > 0 && j > 0) {\\n        if (str1[i-1] == str2[j-1]) {\\n            result[resLen-1] = str1[i-1];\\n            i--;\\n            j--;\\n            resLen--;\\n        } else if (table[i-1][j] < table[i][j-1]) {\\n            result[resLen-1] = str1[i-1];\\n            i--;\\n            resLen--;\\n        } else {\\n            result[resLen-1] = str2[j-1];\\n            j--;\\n            resLen--;\\n        }\\n    }\\n    while (i > 0) {\\n        result[resLen-1] = str1[i-1];\\n        i--;\\n        resLen--;\\n    }\\n    while (j > 0) {\\n        result[resLen-1] = str2[j-1];\\n        j--;\\n        resLen--;\\n    }\\n    return result.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 593734,
                "title": "step-by-step-optimization",
                "content": "## Brute Force\\nCauses TLE: because we have overlapping subproblems.\\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        return shortestCommonSupersequence(str1, str2, 0, 0);\\n    }\\n    \\n    private String shortestCommonSupersequence(String s1, String s2, int i1, int i2) {\\n        if (i1 == s1.length())\\n            return s2.substring(i2);\\n        if (i2 == s2.length())\\n            return s1.substring(i1);\\n        \\n        if (s1.charAt(i1) == s2.charAt(i2))\\n            return s1.charAt(i1) + shortestCommonSupersequence(s1, s2, i1 + 1, i2 + 1);\\n        else {\\n            String res1 = s2.charAt(i2) + shortestCommonSupersequence(s1, s2, i1, i2 + 1);\\n            String res2 = s1.charAt(i1) + shortestCommonSupersequence(s1, s2, i1 + 1, i2);\\n            return res1.length() < res2.length() ? res1 : res2;\\n        }\\n    }\\n}\\n```\\n## Bottom-up DP\\nCauses MLE: because `String[][] dp` takes too much space.\\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        String[][] dp = new String[s1.length() + 1][s2.length() + 1];\\n        dp[0][0] = \"\";\\n        for(int i = 1; i<= s1.length(); i++)\\n            dp[i][0] = s1.substring(0, i);\\n        for(int j = 1; j <= s2.length(); j++)\\n            dp[0][j] = s2.substring(0, j);\\n        \\n        for (int i = 1; i <= s1.length(); i++) {\\n            for (int j = 1; j <= s2.length(); j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1))\\n                    dp[i][j] = dp[i - 1][j - 1] + s1.charAt(i - 1);\\n                else {\\n                    dp[i][j] = (dp[i - 1][j].length() < dp[i][j - 1].length()) ?\\n                        dp[i - 1][j] + s1.charAt(i - 1):\\n                        dp[i][j - 1] + s2.charAt(j - 1);\\n                }\\n            }\\n        }\\n        return dp[s1.length()][s2.length()];\\n    }\\n}\\n```\\n## Optimized Bottom-up DP \\nPasses.\\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n\\n        return getShortestCommonSupersequenceFromDPArray(\\n            s1,\\n            s2, \\n            buildLenShortestCommonSupersequenceDPArray(s1, s2) // dp\\n        );\\n    }\\n    \\n    private int[][] buildLenShortestCommonSupersequenceDPArray(String s1, String s2) {\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n        \\n        for(int i = 1; i<= s1.length(); i++)\\n            dp[i][0] = i;\\n        for(int j = 1; j <= s2.length(); j++)\\n            dp[0][j] = j;\\n        \\n        for (int i = 1; i <= s1.length(); i++) {\\n            for (int j = 1; j <= s2.length(); j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                }\\n                else {\\n                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1;\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n    \\n    private String getShortestCommonSupersequenceFromDPArray(\\n        String s1, \\n        String s2, \\n        int[][] dp) {\\n        int shortestLen = dp[s1.length()][s2.length()];\\n        char[] commonSupersequence = new char[shortestLen];\\n        int i = s1.length(), j = s2.length();\\n        while (i > 0 && j > 0) {\\n            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                commonSupersequence[--shortestLen] = s1.charAt(i - 1);\\n                i--;\\n                j--;\\n            } else if (dp[i - 1][j] < dp[i][j - 1]) {\\n                commonSupersequence[--shortestLen] = s1.charAt(i - 1);\\n                i--;\\n            } else {\\n                commonSupersequence[--shortestLen] = s2.charAt(j - 1);\\n                j--;\\n            }\\n        }\\n        \\n        while (i > 0) {\\n            commonSupersequence[--shortestLen] = s1.charAt(i - 1);\\n            i--;   \\n        }\\n        while (j > 0) {\\n            commonSupersequence[--shortestLen] = s2.charAt(j - 1);\\n            j--;   \\n        }\\n        return new String(commonSupersequence);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        return shortestCommonSupersequence(str1, str2, 0, 0);\\n    }\\n    \\n    private String shortestCommonSupersequence(String s1, String s2, int i1, int i2) {\\n        if (i1 == s1.length())\\n            return s2.substring(i2);\\n        if (i2 == s2.length())\\n            return s1.substring(i1);\\n        \\n        if (s1.charAt(i1) == s2.charAt(i2))\\n            return s1.charAt(i1) + shortestCommonSupersequence(s1, s2, i1 + 1, i2 + 1);\\n        else {\\n            String res1 = s2.charAt(i2) + shortestCommonSupersequence(s1, s2, i1, i2 + 1);\\n            String res2 = s1.charAt(i1) + shortestCommonSupersequence(s1, s2, i1 + 1, i2);\\n            return res1.length() < res2.length() ? res1 : res2;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n        String[][] dp = new String[s1.length() + 1][s2.length() + 1];\\n        dp[0][0] = \"\";\\n        for(int i = 1; i<= s1.length(); i++)\\n            dp[i][0] = s1.substring(0, i);\\n        for(int j = 1; j <= s2.length(); j++)\\n            dp[0][j] = s2.substring(0, j);\\n        \\n        for (int i = 1; i <= s1.length(); i++) {\\n            for (int j = 1; j <= s2.length(); j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1))\\n                    dp[i][j] = dp[i - 1][j - 1] + s1.charAt(i - 1);\\n                else {\\n                    dp[i][j] = (dp[i - 1][j].length() < dp[i][j - 1].length()) ?\\n                        dp[i - 1][j] + s1.charAt(i - 1):\\n                        dp[i][j - 1] + s2.charAt(j - 1);\\n                }\\n            }\\n        }\\n        return dp[s1.length()][s2.length()];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String s1, String s2) {\\n\\n        return getShortestCommonSupersequenceFromDPArray(\\n            s1,\\n            s2, \\n            buildLenShortestCommonSupersequenceDPArray(s1, s2) // dp\\n        );\\n    }\\n    \\n    private int[][] buildLenShortestCommonSupersequenceDPArray(String s1, String s2) {\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n        \\n        for(int i = 1; i<= s1.length(); i++)\\n            dp[i][0] = i;\\n        for(int j = 1; j <= s2.length(); j++)\\n            dp[0][j] = j;\\n        \\n        for (int i = 1; i <= s1.length(); i++) {\\n            for (int j = 1; j <= s2.length(); j++) {\\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                }\\n                else {\\n                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1;\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n    \\n    private String getShortestCommonSupersequenceFromDPArray(\\n        String s1, \\n        String s2, \\n        int[][] dp) {\\n        int shortestLen = dp[s1.length()][s2.length()];\\n        char[] commonSupersequence = new char[shortestLen];\\n        int i = s1.length(), j = s2.length();\\n        while (i > 0 && j > 0) {\\n            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n                commonSupersequence[--shortestLen] = s1.charAt(i - 1);\\n                i--;\\n                j--;\\n            } else if (dp[i - 1][j] < dp[i][j - 1]) {\\n                commonSupersequence[--shortestLen] = s1.charAt(i - 1);\\n                i--;\\n            } else {\\n                commonSupersequence[--shortestLen] = s2.charAt(j - 1);\\n                j--;\\n            }\\n        }\\n        \\n        while (i > 0) {\\n            commonSupersequence[--shortestLen] = s1.charAt(i - 1);\\n            i--;   \\n        }\\n        while (j > 0) {\\n            commonSupersequence[--shortestLen] = s2.charAt(j - 1);\\n            j--;   \\n        }\\n        return new String(commonSupersequence);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489562,
                "title": "java-dp-iterative-simple-thought",
                "content": "`dp[i+1][j+1]` is the shortest common supersequence of `s1(0,i)` and `s2(0,j)`\\n\\n- if `s1(i) == s2(j)` then obviously `dp[i+1][j+1] = dp[i][j] + s1(i)`\\n- if `s1(i) != s2(j)` then `dp[i+1][j+1] =` \\n\\t+ either `dp[i][j+1] + s1(i)` \\n\\t+ or `dp[i+1][j] + s2(j)`\\n(it depends on the length of `dp[i][j+1]` and `dp[i+1][j]`. We will pick up the **shortest**)\\n\\nThe simple code will look like:\\n```\\n\\tpublic String dp_iterative(String s1, String s2) {\\n        int m = s1.length(), n = s2.length();\\n        String[][] dp = new String[m+1][n+1];\\n        dp[0][0] = \"\";\\n\\n        for (int i = 1; i <= m; i++) dp[i][0] = dp[i-1][0] + s1.charAt(i-1);\\n        for (int j = 1; j <= n; j++) dp[0][j] = dp[0][j-1] + s2.charAt(j-1);\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s1.charAt(i-1) == s2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1] + s1.charAt(i-1);                \\n                else {\\n                    if (dp[i-1][j].length() < dp[i][j-1].length())\\n                        dp[i][j] = dp[i-1][j] + s1.charAt(i-1);                    \\n                    else\\n                        dp[i][j] = dp[i][j-1] + s2.charAt(j-1);                    \\n                }\\n            }\\n        }\\n\\t\\t\\n        return dp[m][n];\\n    }\\n```\\n\\nIf you run this code, it will lead to \"**MEMORY LIMIT EXCEEDED**\"\\nWe can improve the space complexity by using 1D memo as follow:\\n\\n```\\n\\tpublic String dp_iterative_improve_space(String s1, String s2) {\\n\\t\\tint m = s1.length(), n = s2.length();\\n        if (m < n) return shortestCommonSupersequence(s2, s1);\\n        \\n        String[] dp = new String[n+1];\\n        dp[0] = \"\";\\n        for (int i = 1; i <= n; i++) dp[i] = dp[i-1] + s2.charAt(i-1);\\n        \\n        for (int i = 1; i <= m; i++) {            \\n            String prev = dp[0];\\n            dp[0] += s1.charAt(i-1);\\n            \\n            for (int j = 1; j <= n; j++) {                \\n                String tmp = dp[j];\\n                if (s1.charAt(i-1) == s2.charAt(j-1))\\n                    dp[j] = prev + s1.charAt(i-1);                \\n                else {\\n                    if (dp[j].length() < dp[j-1].length())\\n                        dp[j] += s1.charAt(i-1);                    \\n                    else\\n                        dp[j] = dp[j-1] + s2.charAt(j-1);                    \\n                }\\n                prev = tmp;\\n            }\\n        }\\n        \\n        return dp[n];\\n\\t}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\tpublic String dp_iterative(String s1, String s2) {\\n        int m = s1.length(), n = s2.length();\\n        String[][] dp = new String[m+1][n+1];\\n        dp[0][0] = \"\";\\n\\n        for (int i = 1; i <= m; i++) dp[i][0] = dp[i-1][0] + s1.charAt(i-1);\\n        for (int j = 1; j <= n; j++) dp[0][j] = dp[0][j-1] + s2.charAt(j-1);\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s1.charAt(i-1) == s2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1] + s1.charAt(i-1);                \\n                else {\\n                    if (dp[i-1][j].length() < dp[i][j-1].length())\\n                        dp[i][j] = dp[i-1][j] + s1.charAt(i-1);                    \\n                    else\\n                        dp[i][j] = dp[i][j-1] + s2.charAt(j-1);                    \\n                }\\n            }\\n        }\\n\\t\\t\\n        return dp[m][n];\\n    }\\n```\n```\\n\\tpublic String dp_iterative_improve_space(String s1, String s2) {\\n\\t\\tint m = s1.length(), n = s2.length();\\n        if (m < n) return shortestCommonSupersequence(s2, s1);\\n        \\n        String[] dp = new String[n+1];\\n        dp[0] = \"\";\\n        for (int i = 1; i <= n; i++) dp[i] = dp[i-1] + s2.charAt(i-1);\\n        \\n        for (int i = 1; i <= m; i++) {            \\n            String prev = dp[0];\\n            dp[0] += s1.charAt(i-1);\\n            \\n            for (int j = 1; j <= n; j++) {                \\n                String tmp = dp[j];\\n                if (s1.charAt(i-1) == s2.charAt(j-1))\\n                    dp[j] = prev + s1.charAt(i-1);                \\n                else {\\n                    if (dp[j].length() < dp[j-1].length())\\n                        dp[j] += s1.charAt(i-1);                    \\n                    else\\n                        dp[j] = dp[j-1] + s2.charAt(j-1);                    \\n                }\\n                prev = tmp;\\n            }\\n        }\\n        \\n        return dp[n];\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313542,
                "title": "my-python-2d-dp-solution",
                "content": "```python\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        m = len(str1)\\n        n = len(str2)\\n        DP = [[0 for j in range(n + 1)] for i in range(m + 1)]\\n        res = []\\n        \\n        for i in range(m + 1):\\n            DP[i][0] = i\\n        for j in range(n + 1):\\n            DP[0][j] = j\\n        \\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if str1[i - 1] == str2[j - 1]:\\n                    DP[i][j] = 1 + DP[i - 1][j - 1]\\n                else:\\n                    if DP[i - 1][j] < DP[i][j - 1]:\\n                        DP[i][j] = 1 + DP[i - 1][j]\\n                    else:\\n                        DP[i][j] = 1 + DP[i][j - 1]\\n        #print(DP[m][n])\\n        #build string from DP array\\n        i = m\\n        j = n\\n        res = []\\n        while i > 0 or j > 0:\\n            if i - 1 >= 0 and j - 1 >= 0 and str1[i - 1] == str2[j - 1]:\\n                res.append(str1[i - 1])\\n                i -= 1\\n                j -= 1\\n            else:\\n                if DP[i - 1][j] < DP[i][j - 1]:\\n                    res.append(str1[i - 1])\\n                    i -= 1\\n                else:\\n                    res.append(str2[j - 1])\\n                    j -= 1\\n        return \\'\\'.join(reversed(res))\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        m = len(str1)\\n        n = len(str2)\\n        DP = [[0 for j in range(n + 1)] for i in range(m + 1)]\\n        res = []\\n        \\n        for i in range(m + 1):\\n            DP[i][0] = i\\n        for j in range(n + 1):\\n            DP[0][j] = j\\n        \\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if str1[i - 1] == str2[j - 1]:\\n                    DP[i][j] = 1 + DP[i - 1][j - 1]\\n                else:\\n                    if DP[i - 1][j] < DP[i][j - 1]:\\n                        DP[i][j] = 1 + DP[i - 1][j]\\n                    else:\\n                        DP[i][j] = 1 + DP[i][j - 1]\\n        #print(DP[m][n])\\n        #build string from DP array\\n        i = m\\n        j = n\\n        res = []\\n        while i > 0 or j > 0:\\n            if i - 1 >= 0 and j - 1 >= 0 and str1[i - 1] == str2[j - 1]:\\n                res.append(str1[i - 1])\\n                i -= 1\\n                j -= 1\\n            else:\\n                if DP[i - 1][j] < DP[i][j - 1]:\\n                    res.append(str1[i - 1])\\n                    i -= 1\\n                else:\\n                    res.append(str2[j - 1])\\n                    j -= 1\\n        return \\'\\'.join(reversed(res))\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313090,
                "title": "what-s-this-leetcode-46-47-test-cases-pass-tle",
                "content": "Similar to others but did not use LCS, thought of it in a different way.\\n\\n```\\nstring f(string s, string t, int i, int j, vector<vector<string>>& dp) {\\n    if(dp[i][j] != \"\")\\n            return dp[i][j];\\n    if(i == s.size())\\n        return t.substr(j);\\n    if(j == t.size())\\n        return s.substr(i);\\n    if(s[i] == t[j]) {\\n        return dp[i][j] = s[i] + f(s, t, i + 1, j + 1, dp);\\n    }\\n    string op1 = s[i] + f(s, t, i + 1, j, dp);\\n    string op2 = t[j] + f(s, t, i, j + 1, dp);\\n    if(op1.size() < op2.size())\\n        return dp[i][j] = op1;\\n    return dp[i][j] = op2;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    string shortestCommonSupersequence(string str1, string str2) {\\n        vector<vector<string>> dp(1001, vector<string>(1001, \"\"));\\n        return f(str1, str2, 0, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstring f(string s, string t, int i, int j, vector<vector<string>>& dp) {\\n    if(dp[i][j] != \"\")\\n            return dp[i][j];\\n    if(i == s.size())\\n        return t.substr(j);\\n    if(j == t.size())\\n        return s.substr(i);\\n    if(s[i] == t[j]) {\\n        return dp[i][j] = s[i] + f(s, t, i + 1, j + 1, dp);\\n    }\\n    string op1 = s[i] + f(s, t, i + 1, j, dp);\\n    string op2 = t[j] + f(s, t, i, j + 1, dp);\\n    if(op1.size() < op2.size())\\n        return dp[i][j] = op1;\\n    return dp[i][j] = op2;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    string shortestCommonSupersequence(string str1, string str2) {\\n        vector<vector<string>> dp(1001, vector<string>(1001, \"\"));\\n        return f(str1, str2, 0, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312730,
                "title": "simple-python-dp-space-o-m-o-string",
                "content": "When we use dp, we only need the previous row of the whole dp matrix, thus we only store that row to avoid memory limit.\\n```\\nclass Solution(object):\\n    def shortestCommonSupersequence(self, str1, str2):\\n        dp = [str1[:i] for i in range(len(str1)+1)]\\n        for i in range(1,len(str2)+1):\\n            new = [str2[:i]]\\n            for j in range(1,len(dp)):\\n                if str1[j-1] == str2[i-1]:\\n                    new += [dp[j-1] + str1[j-1]]\\n                else:\\n                    t1 = new[j-1] + str1[j-1]\\n                    t2 = dp[j] + str2[i-1]\\n                    if len(t1) < len(t2):\\n                        new += [t1]\\n                    else:\\n                        new += [t2]\\n            dp = new\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def shortestCommonSupersequence(self, str1, str2):\\n        dp = [str1[:i] for i in range(len(str1)+1)]\\n        for i in range(1,len(str2)+1):\\n            new = [str2[:i]]\\n            for j in range(1,len(dp)):\\n                if str1[j-1] == str2[i-1]:\\n                    new += [dp[j-1] + str1[j-1]]\\n                else:\\n                    t1 = new[j-1] + str1[j-1]\\n                    t2 = dp[j] + str2[i-1]\\n                    if len(t1) < len(t2):\\n                        new += [t1]\\n                    else:\\n                        new += [t2]\\n            dp = new\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922622,
                "title": "python-dp-easy-lcs",
                "content": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        n,m=len(s1),len(s2)\\n        dp=[[0 for j in range(m+1)] for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if s1[i-1]==s2[j-1]:\\n                    dp[i][j]=1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\\n        s=\\'\\'\\n        i,j=n,m\\n        while i > 0 and j > 0:\\n            if s1[i - 1] == s2[j - 1]:\\n                s+= s1[i - 1]\\n                i -= 1\\n                j -= 1\\n            elif dp[i - 1][j] > dp[i][j - 1]:\\n                s+=s1[i-1]\\n                i -= 1\\n            else:\\n                s+=s2[j-1]\\n                j -= 1\\n        while i>0:\\n            s+=s1[i-1]\\n            i-=1\\n        while j>0:\\n            s+=s2[j-1]\\n            j-=1   \\n        return s[-1::-1]\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        n,m=len(s1),len(s2)\\n        dp=[[0 for j in range(m+1)] for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if s1[i-1]==s2[j-1]:\\n                    dp[i][j]=1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\\n        s=\\'\\'\\n        i,j=n,m\\n        while i > 0 and j > 0:\\n            if s1[i - 1] == s2[j - 1]:\\n                s+= s1[i - 1]\\n                i -= 1\\n                j -= 1\\n            elif dp[i - 1][j] > dp[i][j - 1]:\\n                s+=s1[i-1]\\n                i -= 1\\n            else:\\n                s+=s2[j-1]\\n                j -= 1\\n        while i>0:\\n            s+=s1[i-1]\\n            i-=1\\n        while j>0:\\n            s+=s2[j-1]\\n            j-=1   \\n        return s[-1::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882057,
                "title": "python-dp-striver-dp-series",
                "content": "## Approach:-\\nInitialize two variables, n and m, with the lengths of s1 and s2 respectively.\\nCreate a 2D array dp with dimensions (n+1) x (m+1) to store the length of the longest common subsequence for various prefixes of s1 and s2. Initialize all elements of the array to 0.\\nIterate through each character of both strings, comparing characters to find common subsequences:\\nIf s1[i-1] is equal to s2[j-1], it means the characters match. Increment the value in the dp array at (i, j) by 1, considering the increment in length of the common subsequence.\\nIf the characters don\\'t match, set the value in the dp array at (i, j) to the maximum of the value above it (dp[i-1][j]) and the value to its left (dp[i][j-1]). This accounts for the case when you consider either the next character of s1 or s2 for the subsequence.\\nAfter filling the dp array, initialize an empty string ans to store the result.\\nStart from the bottom-right corner of the dp array, which represents the length of the longest common subsequence of the entire strings s1 and s2.\\nWhile i is greater than 0 and j is greater than 0:\\nIf s1[i-1] is equal to s2[j-1], it means this character is part of the common subsequence. Append the character to ans, decrement both i and j, and move diagonally in the dp array.\\nIf not, check whether moving up in the dp array (dp[i-1][j]) or moving left (dp[i][j-1]) would lead to a longer common subsequence. Choose the direction with the larger value and append the corresponding character to ans, then decrement either i or j accordingly.\\nAfter the loop, there might be remaining characters in either s1 or s2. Append the remaining characters to ans by traversing either string from the last character to the beginning.\\nFinally, return the reversed ans, as we have been appending characters in reverse order.\\n# Code Below\\n```\\nclass Solution:\\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        n=len(s1)\\n        m=len(s2)\\n           \\n        dp=[[0 for i in range(m+1)] for i in range(n+1)]\\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1] + 1\\n                else:\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n        ans=\\'\\'\\n        i=n\\n        j=m\\n        while i>0 and j>0:\\n            if s1[i-1]==s2[j-1]:\\n                ans+=s1[i-1]\\n                i-=1\\n                j-=1\\n            elif dp[i-1][j]>dp[i][j-1]:\\n                ans+=s1[i-1]\\n                i-=1\\n            else:\\n                ans+=s2[j-1]\\n                j-=1\\n        while i>0:\\n            ans+=s1[i-1]\\n            i-=1 \\n        while j>0:\\n            ans+=s2[j-1]\\n            j-=1\\n        return ans[::-1]\\n```\\n\\n## Please Upvote it! Guys :/\\n![image](https://assets.leetcode.com/users/images/edd3477b-2579-427c-909c-de622531905d_1691503357.2447505.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, s1: str, s2: str) -> str:\\n        n=len(s1)\\n        m=len(s2)\\n           \\n        dp=[[0 for i in range(m+1)] for i in range(n+1)]\\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1] + 1\\n                else:\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n        ans=\\'\\'\\n        i=n\\n        j=m\\n        while i>0 and j>0:\\n            if s1[i-1]==s2[j-1]:\\n                ans+=s1[i-1]\\n                i-=1\\n                j-=1\\n            elif dp[i-1][j]>dp[i][j-1]:\\n                ans+=s1[i-1]\\n                i-=1\\n            else:\\n                ans+=s2[j-1]\\n                j-=1\\n        while i>0:\\n            ans+=s1[i-1]\\n            i-=1 \\n        while j>0:\\n            ans+=s2[j-1]\\n            j-=1\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541318,
                "title": "without-lcs-different-approach-top-down-solution-c",
                "content": "#### **Approach:**\\n* ***Initialize*** a DP table to store the lengths of the shortest common supersequence (SCS) for different prefixes of str1 and str2.\\n\\n* ***Set base cases:*** \\nIf one string is empty, the SCS length is equal to the length of the other string\\'s prefix.\\n\\n* ***Fill the DP table:***\\n    1. If characters at the current positions are the `same`, `add 1` to the SCS length from the previous positions.\\n    2. Otherwise, choose the `minimum length` from two options:\\n              -Include the character from str1 and consider the SCS length from the previous position of str1.\\n              -Include the character from str2 and consider the SCS length from the previous position of str2.\\n\\n* ***Backtrack through the DP table to construct the SCS string:***\\n    1. Start from the last cell and compare characters at corresponding positions.\\n    2. If characters match, include the character once and move diagonally up-left in the DP table.\\n    3. If characters don\\'t match, move towards the direction with the smaller value in the DP table.\\n    4. Append characters to the SCS string accordingly.\\n\\n* ***Reverse*** the SCS string to obtain the actual shortest common supersequence.\\n\\n\\n#### **Code:**\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n1=str1.size(), n2=str2.size();\\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1,0));\\n        string ans=\"\";\\n\\n        for(int i = 0; i <= n1; i++) dp[i][0] = i;\\n        for(int j = 0; j <= n2; j++) dp[0][j] = j;\\n\\n        for(int i=1;i<=n1;i++){\\n            for(int j=1;j<=n2;j++){\\n                if(str1[i-1]==str2[j-1]) dp[i][j]=1+dp[i-1][j-1];\\n                else dp[i][j]=1 + min(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n\\n        int i=n1, j=n2;\\n\\n        while(i>0 || j>0){\\n            if(j==0){\\n                ans+=str1[--i];\\n            }else if(i==0){\\n                ans+=str2[--j];\\n            }else if(str1[i-1]==str2[j-1]){\\n                ans+=str1[--i];\\n                j--;\\n            }else if(dp[i-1][j]>dp[i][j-1]){\\n                ans+=str2[j-1];\\n                j--;\\n            }else{\\n                ans+=str1[i-1];\\n                i--;\\n            }\\n        }\\n\\n        reverse(ans.begin(), ans.end());\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n#### **Complexity:**\\n* *Time Complexity* - O(n1 * n2)\\n* *Space Complexity* - O(n1 * n2)\\n\\n**Please consider upvoting, If you found this solution helpful.**\\n\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n1=str1.size(), n2=str2.size();\\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1,0));\\n        string ans=\"\";\\n\\n        for(int i = 0; i <= n1; i++) dp[i][0] = i;\\n        for(int j = 0; j <= n2; j++) dp[0][j] = j;\\n\\n        for(int i=1;i<=n1;i++){\\n            for(int j=1;j<=n2;j++){\\n                if(str1[i-1]==str2[j-1]) dp[i][j]=1+dp[i-1][j-1];\\n                else dp[i][j]=1 + min(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n\\n        int i=n1, j=n2;\\n\\n        while(i>0 || j>0){\\n            if(j==0){\\n                ans+=str1[--i];\\n            }else if(i==0){\\n                ans+=str2[--j];\\n            }else if(str1[i-1]==str2[j-1]){\\n                ans+=str1[--i];\\n                j--;\\n            }else if(dp[i-1][j]>dp[i][j-1]){\\n                ans+=str2[j-1];\\n                j--;\\n            }else{\\n                ans+=str1[i-1];\\n                i--;\\n            }\\n        }\\n\\n        reverse(ans.begin(), ans.end());\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525975,
                "title": "clean-dp-using-backtracking-the-matrix-java-comments-added-explained",
                "content": "# Please Up Vote\\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String s, String ss) {\\n        int n = s.length(); int m = ss.length();\\n        int dp[][]= new int [n+1][m+1]; // 1 based indexing \\n        // LCS dp table\\n        for(int i =1 ;i<=n ;i++){\\n            for(int j =1; j<=m ;j++ ){\\n                if( s.charAt(i-1)== ss.charAt(j-1)){\\n                    dp[i][j]= 1+ dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]= Math.max(dp[i][j-1], dp[i-1][j]);\\n                }\\n            }\\n        }\\n        // for dry run dp matrix\\n        for(int i =0 ;i<=n; i++){\\n            for(int j =0; j<=m ;j++){\\n                System.out.print(dp[i][j]+\" \");\\n            }\\n            System.out.println();\\n        }\\n        \\n        int i = n; int j =m; \\n        String res = \"\";\\n        // from the dp matrix backtracking and adding to the res string\\n        while( i>0 && j>0) {\\n            if( s.charAt(i-1) != ss.charAt(j-1)) {\\n                if( dp[i-1][j]>dp[i][j-1]) {\\n                    res+= s.charAt(i-1);\\n                    i--;\\n                }else{\\n                    res+= ss.charAt(j-1); \\n                    j--;\\n                }\\n            }else{\\n                res+= s.charAt(i-1); \\n                i--; j--;\\n            }\\n        }\\n        // Remaining characters if any \\n        while( i>0){\\n            res+=s.charAt(i-1); \\n            i--;\\n        }\\n        while( j>0){\\n            res+=ss.charAt(j-1); \\n            j--;\\n        }\\n\\n        String ans =  \"\";\\n        // reversing the res\\n        for(int ii = res.length()-1; ii>=0 ; ii--)\\n            ans+= res.charAt(ii);\\n\\n        return ans;\\n    }\\n}\\n\\n\\n\\n    // If wanna see why memoised matrix doesnt works here \\n // private int f( int i ,int j , String s , String ss , int dp[][]){\\n    //     if(i>s.length()-1 || j>ss.length()-1) return 0;\\n    //     if( dp[i][j]!=-1) return dp[i][j];\\n    //     if( s.charAt(i)== ss.charAt(j) ) return dp[i][j]= 1+f( i+1, j+1, s, ss, dp);\\n    //     return dp[i][j]=Math.max( f(i, j+1, s , ss ,dp), f(i+1, j, s, ss,dp));\\n    // }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String s, String ss) {\\n        int n = s.length(); int m = ss.length();\\n        int dp[][]= new int [n+1][m+1]; // 1 based indexing \\n        // LCS dp table\\n        for(int i =1 ;i<=n ;i++){\\n            for(int j =1; j<=m ;j++ ){\\n                if( s.charAt(i-1)== ss.charAt(j-1)){\\n                    dp[i][j]= 1+ dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]= Math.max(dp[i][j-1], dp[i-1][j]);\\n                }\\n            }\\n        }\\n        // for dry run dp matrix\\n        for(int i =0 ;i<=n; i++){\\n            for(int j =0; j<=m ;j++){\\n                System.out.print(dp[i][j]+\" \");\\n            }\\n            System.out.println();\\n        }\\n        \\n        int i = n; int j =m; \\n        String res = \"\";\\n        // from the dp matrix backtracking and adding to the res string\\n        while( i>0 && j>0) {\\n            if( s.charAt(i-1) != ss.charAt(j-1)) {\\n                if( dp[i-1][j]>dp[i][j-1]) {\\n                    res+= s.charAt(i-1);\\n                    i--;\\n                }else{\\n                    res+= ss.charAt(j-1); \\n                    j--;\\n                }\\n            }else{\\n                res+= s.charAt(i-1); \\n                i--; j--;\\n            }\\n        }\\n        // Remaining characters if any \\n        while( i>0){\\n            res+=s.charAt(i-1); \\n            i--;\\n        }\\n        while( j>0){\\n            res+=ss.charAt(j-1); \\n            j--;\\n        }\\n\\n        String ans =  \"\";\\n        // reversing the res\\n        for(int ii = res.length()-1; ii>=0 ; ii--)\\n            ans+= res.charAt(ii);\\n\\n        return ans;\\n    }\\n}\\n\\n\\n\\n    // If wanna see why memoised matrix doesnt works here \\n // private int f( int i ,int j , String s , String ss , int dp[][]){\\n    //     if(i>s.length()-1 || j>ss.length()-1) return 0;\\n    //     if( dp[i][j]!=-1) return dp[i][j];\\n    //     if( s.charAt(i)== ss.charAt(j) ) return dp[i][j]= 1+f( i+1, j+1, s, ss, dp);\\n    //     return dp[i][j]=Math.max( f(i, j+1, s , ss ,dp), f(i+1, j, s, ss,dp));\\n    // }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303257,
                "title": "c-dp-tabulation-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n\\n- Space complexity:$$O(n*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n=str1.size(), m=str2.size(), l1=n, l2=m;\\n        vector<vector<int>>dp(n+1, vector<int>(m+1, 0));\\n        for(int i=1; i<=n; i++){\\n            for(int j=1; j<=m; j++){\\n                if(str1[i-1]==str2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(l1>0 && l2>0){\\n            if(str1[l1-1]==str2[l2-1]){\\n                ans+=str1[l1-1];\\n                l1--; l2--;\\n            }\\n            else if(dp[l1-1][l2]>dp[l1][l2-1]){\\n                ans+=(str1[l1-1]);\\n                l1--;\\n            }\\n            else{\\n                ans+=(str2[l2-1]);\\n                l2--;\\n            }\\n        }\\n        while(l1>0){\\n            ans+=str1[l1-1];\\n            l1--;\\n        }\\n        while(l2>0){\\n            ans+=str2[l2-1];\\n            l2--;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n=str1.size(), m=str2.size(), l1=n, l2=m;\\n        vector<vector<int>>dp(n+1, vector<int>(m+1, 0));\\n        for(int i=1; i<=n; i++){\\n            for(int j=1; j<=m; j++){\\n                if(str1[i-1]==str2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(l1>0 && l2>0){\\n            if(str1[l1-1]==str2[l2-1]){\\n                ans+=str1[l1-1];\\n                l1--; l2--;\\n            }\\n            else if(dp[l1-1][l2]>dp[l1][l2-1]){\\n                ans+=(str1[l1-1]);\\n                l1--;\\n            }\\n            else{\\n                ans+=(str2[l2-1]);\\n                l2--;\\n            }\\n        }\\n        while(l1>0){\\n            ans+=str1[l1-1];\\n            l1--;\\n        }\\n        while(l2>0){\\n            ans+=str2[l2-1];\\n            l2--;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272432,
                "title": "c-simplest-solution-using-lcs-dp-100-faster-code-striver",
                "content": "\\n# LCS Tabulation + Printing SCS\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.size(), m = str2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n\\n        // Getting LCS\\n\\n        for(int i=0; i<=n; i++) dp[i][0] = 0;\\n        for (int j=0; j<=m; j++) dp[0][j] = 0;\\n\\n        for (int i=1; i<=n; i++) {\\n            for (int j=1; j<=m; j++) {\\n                if (str1[i-1] == str2[j-1]) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = 0 + max(dp[i][j-1], dp[i-1][j]);\\n            }\\n        }\\n\\n        // Printing SCS\\n\\n        int i = str1.size();\\n        int j = str2.size();\\n        string ans = \"\";\\n        while (i > 0 && j > 0) {\\n            if (str1[i-1] == str2[j-1]) {\\n                ans += str1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else if (dp[i][j-1] >  dp[i-1][j]) {\\n                ans += str2[j-1];\\n                j--;\\n            }\\n            else {\\n                ans += str1[i-1];\\n                i--;\\n            }\\n        }\\n        while (i > 0) {\\n            ans += str1[i-1];\\n            i--;\\n        }\\n        while (j > 0) {\\n            ans += str2[j-1];\\n            j--;\\n        };\\n        reverse(begin(ans), end(ans));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.size(), m = str2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n\\n        // Getting LCS\\n\\n        for(int i=0; i<=n; i++) dp[i][0] = 0;\\n        for (int j=0; j<=m; j++) dp[0][j] = 0;\\n\\n        for (int i=1; i<=n; i++) {\\n            for (int j=1; j<=m; j++) {\\n                if (str1[i-1] == str2[j-1]) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = 0 + max(dp[i][j-1], dp[i-1][j]);\\n            }\\n        }\\n\\n        // Printing SCS\\n\\n        int i = str1.size();\\n        int j = str2.size();\\n        string ans = \"\";\\n        while (i > 0 && j > 0) {\\n            if (str1[i-1] == str2[j-1]) {\\n                ans += str1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else if (dp[i][j-1] >  dp[i-1][j]) {\\n                ans += str2[j-1];\\n                j--;\\n            }\\n            else {\\n                ans += str1[i-1];\\n                i--;\\n            }\\n        }\\n        while (i > 0) {\\n            ans += str1[i-1];\\n            i--;\\n        }\\n        while (j > 0) {\\n            ans += str2[j-1];\\n            j--;\\n        };\\n        reverse(begin(ans), end(ans));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044929,
                "title": "bottom-up-lcs-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=m; j++) {\\n                if(s[i - 1] == t[j - 1]) dp[i][j] = 1 + dp[i - 1][j - 1];\\n                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n\\n        int i = n, j = m;\\n        string ans;\\n        while(i && j) {\\n            if(s[i - 1] == t[j - 1]) {\\n                ans += s[i - 1];\\n                i--, j--;\\n            }\\n            else if(dp[i - 1][j] > dp[i][j - 1]) ans += s[i - 1], i--;\\n            else ans += t[j - 1], j--;\\n        }\\n        while(i) ans += s[--i];\\n        while(j) ans += t[--j];\\n\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=m; j++) {\\n                if(s[i - 1] == t[j - 1]) dp[i][j] = 1 + dp[i - 1][j - 1];\\n                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n\\n        int i = n, j = m;\\n        string ans;\\n        while(i && j) {\\n            if(s[i - 1] == t[j - 1]) {\\n                ans += s[i - 1];\\n                i--, j--;\\n            }\\n            else if(dp[i - 1][j] > dp[i][j - 1]) ans += s[i - 1], i--;\\n            else ans += t[j - 1], j--;\\n        }\\n        while(i) ans += s[--i];\\n        while(j) ans += t[--j];\\n\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041472,
                "title": "fastest-simple-python-solution-lcs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(N*M)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N*M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        n=len(str1)\\n        m=len(str2)\\n        dp=[[\"\"]*(m+1) for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if str1[i-1]==str2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]+str1[i-1]\\n                else:\\n                    if len(dp[i-1][j])>len(dp[i][j-1]):\\n                        dp[i][j]=dp[i-1][j]\\n                    else:\\n                        dp[i][j]=dp[i][j-1]\\n        i,j=0,0\\n        f1,f2=False,False\\n        st=\"\"\\n        x=dp[-1][-1]\\n        while i<n and j<m and x:\\n            if f1==True and f2==True:\\n                f1,f2=False,False\\n                i+=1\\n                j+=1\\n                st+=x[0]\\n                x=x[1:]\\n                continue\\n            if  str1[i]!=x[0]:\\n                st+=str1[i]\\n                i+=1\\n            else:\\n                f1=True\\n            if str2[j]!=x[0]:\\n                st+=str2[j]\\n                j+=1\\n            else:\\n                f2=True\\n        \\n        st+=str1[i:]\\n        st+=str2[j:]\\n\\n        return st\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        n=len(str1)\\n        m=len(str2)\\n        dp=[[\"\"]*(m+1) for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if str1[i-1]==str2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]+str1[i-1]\\n                else:\\n                    if len(dp[i-1][j])>len(dp[i][j-1]):\\n                        dp[i][j]=dp[i-1][j]\\n                    else:\\n                        dp[i][j]=dp[i][j-1]\\n        i,j=0,0\\n        f1,f2=False,False\\n        st=\"\"\\n        x=dp[-1][-1]\\n        while i<n and j<m and x:\\n            if f1==True and f2==True:\\n                f1,f2=False,False\\n                i+=1\\n                j+=1\\n                st+=x[0]\\n                x=x[1:]\\n                continue\\n            if  str1[i]!=x[0]:\\n                st+=str1[i]\\n                i+=1\\n            else:\\n                f1=True\\n            if str2[j]!=x[0]:\\n                st+=str2[j]\\n                j+=1\\n            else:\\n                f2=True\\n        \\n        st+=str1[i:]\\n        st+=str2[j:]\\n\\n        return st\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673602,
                "title": "using-lcs-concept-aditya-verma-sir-approach",
                "content": "string LCS(string str1, string str2,int m,int n){\\n        string s=\"\";\\n        int t[m+1][n+1];\\n        for(int i=0;i<m+1;i++){\\n            for(int j=0;j<n+1;j++){\\n                if(i==0 || j==0){\\n                    t[i][j]=0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(str1[i-1]==str2[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                }\\n                else{\\n                    t[i][j]=max(t[i-1][j],t[i][j-1]);\\n                }\\n            }\\n        }\\n        int i=m;\\n        int j=n;\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                s.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else if(t[i-1][j]>t[i][j-1]){\\n                s.push_back(str1[i-1]);\\n                i--;\\n            }\\n            else{\\n                s.push_back(str2[j-1]);\\n                j--;\\n            }\\n        }\\n        while(i>0){\\n            s.push_back(str1[i-1]);\\n            i--;\\n        }\\n        while(j>0){\\n            s.push_back(str2[j-1]);\\n                j--;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n        \\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.size();\\n        int n=str2.size();\\n        string ans=LCS(str1,str2,m,n);\\n        return ans;\\n        \\n\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "string LCS(string str1, string str2,int m,int n){\\n        string s=\"\";\\n        int t[m+1][n+1];\\n        for(int i=0;i<m+1;i++){\\n            for(int j=0;j<n+1;j++){\\n                if(i==0 || j==0){\\n                    t[i][j]=0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(str1[i-1]==str2[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                }\\n                else{\\n                    t[i][j]=max(t[i-1][j],t[i][j-1]);\\n                }\\n            }\\n        }\\n        int i=m;\\n        int j=n;\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                s.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else if(t[i-1][j]>t[i][j-1]){\\n                s.push_back(str1[i-1]);\\n                i--;\\n            }\\n            else{\\n                s.push_back(str2[j-1]);\\n                j--;\\n            }\\n        }\\n        while(i>0){\\n            s.push_back(str1[i-1]);\\n            i--;\\n        }\\n        while(j>0){\\n            s.push_back(str2[j-1]);\\n                j--;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n        \\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.size();\\n        int n=str2.size();\\n        string ans=LCS(str1,str2,m,n);\\n        return ans;\\n        \\n\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2639281,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        def fun(text1,text2,n,m,dp):\\n\\n            #in problem in string we have have two option (mathch and not match)\\n            for i in range(1,n+1):\\n                for j in range(1,m+1):\\n                    #match\\n                    if text1[i-1]==text2[j-1]:\\n                        (dp[i])[j]=1+ (dp[i-1])[j-1]\\n                    else:   \\n                    #not match\\n                        (dp[i])[j]=max((dp[i-1])[j],(dp[i])[j-1])\\n\\n            # Now we have dp table in which dp[n][m] represent the length of longest path.\\n            # Now I have to walk in dp table and have to find the word which is common in both text\\n\\n            i=n\\n            j=m\\n            s=\"\"\\n            while i>0 and j>0:\\n                if text1[i-1]==text2[j-1]:\\n                    s=s+text1[i-1]\\n                    i-=1\\n                    j-=1\\n                elif (dp[i])[j-1] > (dp[i-1])[j]:\\n                    s=s+text2[j-1]\\n                    j-=1\\n\\n                else:\\n                    s=s+text1[i-1]\\n                    i-=1\\n\\n\\n            while i>0:\\n                s=s+text1[i-1]\\n                i-=1\\n            while j>0:\\n                s=s+text2[j-1]\\n                j-=1\\n            return s[::-1]\\n\\n \\n        n=len(str1)\\n        m=len(str2)\\n        dp=[[0]*(m+1) for i in range (n+1)]\\n        return fun(str1,str2,n,m,dp)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        def fun(text1,text2,n,m,dp):\\n\\n            #in problem in string we have have two option (mathch and not match)\\n            for i in range(1,n+1):\\n                for j in range(1,m+1):\\n                    #match\\n                    if text1[i-1]==text2[j-1]:\\n                        (dp[i])[j]=1+ (dp[i-1])[j-1]\\n                    else:   \\n                    #not match\\n                        (dp[i])[j]=max((dp[i-1])[j],(dp[i])[j-1])\\n\\n            # Now we have dp table in which dp[n][m] represent the length of longest path.\\n            # Now I have to walk in dp table and have to find the word which is common in both text\\n\\n            i=n\\n            j=m\\n            s=\"\"\\n            while i>0 and j>0:\\n                if text1[i-1]==text2[j-1]:\\n                    s=s+text1[i-1]\\n                    i-=1\\n                    j-=1\\n                elif (dp[i])[j-1] > (dp[i-1])[j]:\\n                    s=s+text2[j-1]\\n                    j-=1\\n\\n                else:\\n                    s=s+text1[i-1]\\n                    i-=1\\n\\n\\n            while i>0:\\n                s=s+text1[i-1]\\n                i-=1\\n            while j>0:\\n                s=s+text2[j-1]\\n                j-=1\\n            return s[::-1]\\n\\n \\n        n=len(str1)\\n        m=len(str2)\\n        dp=[[0]*(m+1) for i in range (n+1)]\\n        return fun(str1,str2,n,m,dp)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544087,
                "title": "c-solution-using-lcs-aditya-verma-bhaiya-op",
                "content": "**Solution **-->\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string text1, string text2) {\\n        int n=text1.size();\\n        int m=text2.size();\\n        \\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0 || j==0) dp[i][j]=0;\\n            }\\n        }\\n        // i->n;\\n        // j->m;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(text1[i-1]==text2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int i=n;\\n        int j=m;\\n        string ans=\"\";\\n        while(i>0 && j>0){\\n            if(text1[i-1]==text2[j-1]){\\n                ans+=text1[i-1];\\n                i--;j--;\\n            }\\n            else{\\n                if(dp[i-1][j]>dp[i][j-1]){\\n                    ans+=text1[i-1];\\n                    i--;\\n                }\\n                else{\\n                    ans+=text2[j-1];\\n                    j--;\\n                }\\n            }\\n        }\\n        while(i>0) \\n        {\\n            ans+=(text1[i-1]);\\n            i--;\\n        }\\n        while(j>0) \\n        {\\n            ans+=(text2[j-1]);\\n            j--;\\n\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\nCredit of the Solution goes to **Aditya Verma Bhaiya **",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string text1, string text2) {\\n        int n=text1.size();\\n        int m=text2.size();\\n        \\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0 || j==0) dp[i][j]=0;\\n            }\\n        }\\n        // i->n;\\n        // j->m;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(text1[i-1]==text2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int i=n;\\n        int j=m;\\n        string ans=\"\";\\n        while(i>0 && j>0){\\n            if(text1[i-1]==text2[j-1]){\\n                ans+=text1[i-1];\\n                i--;j--;\\n            }\\n            else{\\n                if(dp[i-1][j]>dp[i][j-1]){\\n                    ans+=text1[i-1];\\n                    i--;\\n                }\\n                else{\\n                    ans+=text2[j-1];\\n                    j--;\\n                }\\n            }\\n        }\\n        while(i>0) \\n        {\\n            ans+=(text1[i-1]);\\n            i--;\\n        }\\n        while(j>0) \\n        {\\n            ans+=(text2[j-1]);\\n            j--;\\n\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491557,
                "title": "dynamic-programming",
                "content": "class Solution {\\npublic:\\nstring shortestCommonSupersequence(string str1, string str2) {\\n\\n    int m = str1.size();\\n    int n = str2.size();\\n    int dp[m+1][n+1];\\n    // vector<vector<int>>dp(m+1,vector<int>(n+1,0));\\n    \\n    for(int i=0;i<=n;i++) dp[0][i]=0;\\n    for(int i=0;i<=m;i++) dp[i][0]=0;\\n    \\n    for(int i=1;i<=m;i++){\\n        for(int j=1;j<=n;j++){\\n            \\n            if(str1[i-1]==str2[j-1]){\\n                dp[i][j]=1+dp[i-1][j-1];\\n            }\\n            else{\\n                dp[i][j]=max(dp[i-1][j] , dp[i][j-1]);\\n            }    \\n        }\\n    }\\n    \\n    string s = \"\";\\n    int i = m , j = n;\\n    while(i>0 && j>0){\\n        \\n        if(str1[i-1]==str2[j-1]){\\n            s+=str1[i-1];\\n            i-- , j--;\\n        }\\n        else if(dp[i-1][j]>dp[i][j-1]){\\n                s+=str1[i-1];\\n                i--;\\n            }\\n        else{\\n                 s+=str2[j-1];\\n                 j--;\\n        } \\n    }\\n    \\n    while(i>0){\\n        s+=str1[i-1];\\n        i--;\\n    }\\n    while(j>0){\\n        s+=str2[j-1];\\n        j--;\\n    }\\n    reverse(s.begin() , s.end());\\n    return s;\\n}\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\nstring shortestCommonSupersequence(string str1, string str2) {\\n\\n    int m = str1.size();\\n    int n = str2.size();\\n    int dp[m+1][n+1];\\n    // vector<vector<int>>dp(m+1,vector<int>(n+1,0));\\n    \\n    for(int i=0;i<=n;i++) dp[0][i]=0;\\n    for(int i=0;i<=m;i++) dp[i][0]=0;\\n    \\n    for(int i=1;i<=m;i++){\\n        for(int j=1;j<=n;j++){\\n            \\n            if(str1[i-1]==str2[j-1]){\\n                dp[i][j]=1+dp[i-1][j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2464477,
                "title": "hard-made-easy-python-solution-lcs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def LCS(self,s,t):\\n        m=len(s)\\n        n=len(t)\\n        dp=[[0 for i in range(n+1)]for j in range(m+1)]\\n        for i in range(m+1):\\n            dp[i][0]=0\\n        for j in range(n+1):\\n            dp[0][j]=0\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if s[i-1]==t[j-1]:\\n                    dp[i][j]=1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\\n        return dp\\n    \\n    def shortestCommonSupersequence(self, s: str, t: str) -> str:\\n        dp=self.LCS(s,t)\\n        m=len(dp)-1\\n        n=len(dp[0])-1\\n        ans=\"\"\\n        i=m\\n        j=n\\n        while(i>0 and j>0):\\n            if s[i-1]==t[j-1]:\\n                ans+=s[i-1]\\n                i-=1\\n                j-=1\\n            elif dp[i-1][j]>dp[i][j-1]:\\n                ans+=s[i-1]\\n                i-=1\\n            else:\\n                ans+=t[j-1]\\n                j-=1\\n        while(i>0):\\n            ans+=s[i-1]\\n            i-=1\\n        while(j>0):\\n            ans+=t[j-1]\\n            j-=1\\n        return ans[::-1]\\n```\\n\\nIf anyone not got Kindly comment i will explain",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def LCS(self,s,t):\\n        m=len(s)\\n        n=len(t)\\n        dp=[[0 for i in range(n+1)]for j in range(m+1)]\\n        for i in range(m+1):\\n            dp[i][0]=0\\n        for j in range(n+1):\\n            dp[0][j]=0\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if s[i-1]==t[j-1]:\\n                    dp[i][j]=1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\\n        return dp\\n    \\n    def shortestCommonSupersequence(self, s: str, t: str) -> str:\\n        dp=self.LCS(s,t)\\n        m=len(dp)-1\\n        n=len(dp[0])-1\\n        ans=\"\"\\n        i=m\\n        j=n\\n        while(i>0 and j>0):\\n            if s[i-1]==t[j-1]:\\n                ans+=s[i-1]\\n                i-=1\\n                j-=1\\n            elif dp[i-1][j]>dp[i][j-1]:\\n                ans+=s[i-1]\\n                i-=1\\n            else:\\n                ans+=t[j-1]\\n                j-=1\\n        while(i>0):\\n            ans+=s[i-1]\\n            i-=1\\n        while(j>0):\\n            ans+=t[j-1]\\n            j-=1\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445939,
                "title": "simple-cpp-solution-aditya-verma",
                "content": "\\n\\n    string printSCS(string str1, string str2,int i , int j, vector<vector<int>> &dp)\\n    {\\n        string ans=\"\";\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                s.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(dp[i][j-1] > dp[i-1][j])\\n                {   ans.push_back(str2[j-1]); \\n                    j--;\\n                }\\n                else\\n                {   ans.push_back(str1[i-1]);\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n            ans.push_back(str1[i-1]);    \\n            i--;\\n        }\\n         while(j>0){\\n            ans.push_back(str2[j-1]);   \\n            j--;\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n        \\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.size();\\n        int n=str2.size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1));\\n        \\n        for(int i=0;i<m+1;i++){\\n            for(int j=0;j<n+1;j++){\\n                if(i==0 || j==0)\\n                dp[i][j]=0;\\n            }\\n        }\\n        \\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(str1[i-1]==str2[j-1])\\n                  dp[i][j]=1+dp[i-1][j-1];\\n                \\n                else\\n                 dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        \\n        \\n        string s=printSCS(str1,str2,m,n,dp);\\n        \\n        return s;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n    string printSCS(string str1, string str2,int i , int j, vector<vector<int>> &dp)\\n    {\\n        string ans=\"\";\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                s.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(dp[i][j-1] > dp[i-1][j])\\n                {   ans.push_back(str2[j-1]); \\n                    j--;\\n                }\\n                else\\n                {   ans.push_back(str1[i-1]);\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n            ans.push_back(str1[i-1]);    \\n            i--;\\n        }\\n         while(j>0){\\n            ans.push_back(str2[j-1]);   \\n            j--;\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n        \\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.size();\\n        int n=str2.size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1));\\n        \\n        for(int i=0;i<m+1;i++){\\n            for(int j=0;j<n+1;j++){\\n                if(i==0 || j==0)\\n                dp[i][j]=0;\\n            }\\n        }\\n        \\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(str1[i-1]==str2[j-1])\\n                  dp[i][j]=1+dp[i-1][j-1];\\n                \\n                else\\n                 dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        \\n        \\n        string s=printSCS(str1,str2,m,n,dp);\\n        \\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2427634,
                "title": "c-dp-solution-print-shortest-common-supersequence-with-comments-lc-hard-1092",
                "content": "class Solution {\\npublic:\\n    \\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.length();\\n        int n=str2.length();\\n        \\n        //initialising dp matrix using vector.\\n        \\n        vector<vector<int>>dp(m+1,vector<int>(n+1,0));\\n        \\n        //filling up the dp matrix .\\n\\t\\t//( if you are having problem understanding this part of code please refer the code of Longest Common   subsequence using DP, it is exactly the same code ).\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(str1[i-1]==str2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        //creating empty string \"ans\" to store the longest common supersequence that we will return at the end.\\n        \\n        string ans=\"\";\\n        int i=m;\\n        int j=n;\\n\\t\\t\\n\\t\\t//traversing the dp matrix from the last element i.e \"dp[m][n]\" \\n\\t\\t/* if the current character in both the string are equal then just add any one of the character to the \"ans\" string either you can add str1[i-1] or str2[j-1]. \\n\\t\\tElse, if current str1[i-1] is not equal to current str2[j-1], then we have to look the values stored at dp[i-1][j] and dp[i][j-1] whichever value will be greater we will move in that direction. */\\n\\t\\t\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                ans+=str1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(dp[i-1][j]>dp[i][j-1]){\\n                    ans+=str1[i-1];\\n                    i--;\\n                }\\n                else{\\n                    ans+=str2[j-1];\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        // if any string (either str1 or str2) is still not empty, then add those remaining element of non-empty string to our \"ans\" string.\\n        \\n        // if str2 is not empty then add the remaining elements of str 2 to \"ans\" string till the str2 becomes empty.\\n        \\n        while(j>0 && i==0){\\n            ans+=str2[j-1];\\n            j--;\\n        }\\n        \\n        //if str1 is not empty then add the remaining elements of str1 to \"ans\" string till the str1 becomes empty.\\n        \\n        while(i>0 && j==0){\\n            ans+=str1[i-1];\\n            i--;\\n        }\\n        \\n        \\n        // since we were traversing the dp matrix from the last element i.e. dp[m][n] it basically means that we were making operations on current last element of string str1 and str2 so the first charachter of \"ans\" string is actually the last element of either str1 or str2. \\n\\t\\t\\n\\t\\t//So to get the string in proper order we will reverse the \"ans\" string.\\n\\t\\t\\n        reverse(ans.begin(),ans.end());\\n\\t\\t\\n\\t\\t//return the final \"ans\" string.\\n\\t\\t\\n        return ans;\\n \\n    }\\n};\\n\\n**IF YOU FIND THIS HELPFUL PLEASE UPVOTE\\u2764\\uFE0F **",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.length();\\n        int n=str2.length();\\n        \\n        //initialising dp matrix using vector.\\n        \\n        vector<vector<int>>dp(m+1,vector<int>(n+1,0));\\n        \\n        //filling up the dp matrix .\\n\\t\\t//( if you are having problem understanding this part of code please refer the code of Longest Common   subsequence using DP, it is exactly the same code ).\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(str1[i-1]==str2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2296841,
                "title": "simple-easy-to-understand-solution-with-comments-done-using-lcs-dp-table",
                "content": "Upvote if solution was of any help :)\\n\\n```class Solution {\\npublic:\\n    string print_scs(string x,string y,int i,int j,vector< vector< int>>& dp){\\n        string ans;\\n        while(i > 0  and j > 0){\\n            if(x[i-1] == y[j-1]){\\n                ans.push_back(x[i-1]); //if chars are equals then push it to string and move diagonally up\\n                i--;j--;\\n            }else{\\n                if(dp[i][j-1] > dp[i-1][j]){  // if left element > top element \\n                    ans.push_back(y[j-1]);\\n                    j--;\\n                }else if(dp[i-1][j] > dp[i][j-1]){ // if top element > left element\\n                    ans.push_back(x[i-1]);\\n                    i--;\\n                }else{\\n                    ans.push_back(x[i-1]);  // if both left element == top element\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        while(i > 0){\\n            ans.push_back(x[i-1]);\\n            i--;\\n        }\\n        \\n        while(j > 0){\\n            ans.push_back(y[j-1]);\\n            j--;\\n        }\\n        \\n        return ans;\\n    }\\n    int lcs(string x,string y,int n,int m,vector< vector< int>>& dp){\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i == 0 || j == 0){\\n                    dp[i][j] = 0;\\n                }else{\\n                    if(x[i-1] == y[j-1]){\\n                        dp[i][j] = 1+dp[i-1][j-1];\\n                    }else{\\n                        dp[i][j] = max(dp[i][j-1],dp[i-1][j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n    string shortestCommonSupersequence(string x, string y) {\\n        int n=x.size();\\n        int m=y.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        lcs(x,y,n,m,dp); //calculating lcs dp table\\n        \\n        string ans = print_scs(x,y,n,m,dp); //finding scs using lcs dp table\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    string print_scs(string x,string y,int i,int j,vector< vector< int>>& dp){\\n        string ans;\\n        while(i > 0  and j > 0){\\n            if(x[i-1] == y[j-1]){\\n                ans.push_back(x[i-1]); //if chars are equals then push it to string and move diagonally up\\n                i--;j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2219006,
                "title": "python3-concise-recursion-memoization",
                "content": "```\\n\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n    \\n        @lru_cache(maxsize= 8000)\\n        def helper(first: str, second: str):\\n            \\n            if not first and not second:\\n                return \"\"\\n            \\n            if not first:\\n                return second\\n            \\n            if not second:\\n                return first\\n            \\n            if first[0] == second[0]:\\n                return first[0] + helper(first[1:], second[1:])\\n            \\n            right = second[0] + helper(first, second[1:])\\n            left = first[0] + helper(first[1:], second)\\n            \\n            if len(right) > len(left):\\n                return left\\n            return right\\n            \\n        return helper(str1, str2)\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n    \\n        @lru_cache(maxsize= 8000)\\n        def helper(first: str, second: str):\\n            \\n            if not first and not second:\\n                return \"\"\\n            \\n            if not first:\\n                return second\\n            \\n            if not second:\\n                return first\\n            \\n            if first[0] == second[0]:\\n                return first[0] + helper(first[1:], second[1:])\\n            \\n            right = second[0] + helper(first, second[1:])\\n            left = first[0] + helper(first[1:], second)\\n            \\n            if len(right) > len(left):\\n                return left\\n            return right\\n            \\n        return helper(str1, str2)\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212391,
                "title": "easy-python-top-down-dp-o-mn",
                "content": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        \"\"\"\\n            dp(i, j):\\n                if i and j both reach end: return \"\"\\n            \\n                if i == j:\\n                    return ok\\n                \\n                else:\\n                    min(\\n                        take ith index + dp(i+1. j)\\n                        take j + dp(i, j+1)\\n                    )\\n        \"\"\"\\n        \\n        # @cache\\n        @lru_cache(1000*10)\\n        def dp(i, j):\\n            \\n            if i == len(str1) and j == len(str2):\\n                return \"\"\\n            \\n            if i == len(str1):\\n                return str2[j:]\\n            \\n            if j == len(str2):\\n                return str1[i:]\\n            \\n            if str1[i] == str2[j]:\\n                return str1[i] + dp(i+1, j+1)\\n            \\n            else:\\n                m1 = dp(i+1, j)\\n                m2 = dp(i, j+1)\\n                \\n                if len(m1) > len(m2):\\n                    return str2[j] + m2\\n                else:\\n                    return str1[i] + m1\\n        \\n        return dp(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        \"\"\"\\n            dp(i, j):\\n                if i and j both reach end: return \"\"\\n            \\n                if i == j:\\n                    return ok\\n                \\n                else:\\n                    min(\\n                        take ith index + dp(i+1. j)\\n                        take j + dp(i, j+1)\\n                    )\\n        \"\"\"\\n        \\n        # @cache\\n        @lru_cache(1000*10)\\n        def dp(i, j):\\n            \\n            if i == len(str1) and j == len(str2):\\n                return \"\"\\n            \\n            if i == len(str1):\\n                return str2[j:]\\n            \\n            if j == len(str2):\\n                return str1[i:]\\n            \\n            if str1[i] == str2[j]:\\n                return str1[i] + dp(i+1, j+1)\\n            \\n            else:\\n                m1 = dp(i+1, j)\\n                m2 = dp(i, j+1)\\n                \\n                if len(m1) > len(m2):\\n                    return str2[j] + m2\\n                else:\\n                    return str1[i] + m1\\n        \\n        return dp(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209109,
                "title": "c-dp-solution-using-lcs-easy-solution",
                "content": "**UpVote if you find it Helpful.**\\n\\nclass Solution {\\npublic:\\n\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m = str1.size();\\n        int n = str2.size();\\n        \\n        int dp[m+1][n+1];\\n        \\n        for(int i=0;i<m+1;i++){\\n            for(int j=0;j<n+1;j++){\\n                if(i==0 || j==0)\\n                    dp[i][j] = 0;\\n            }\\n        }\\n        \\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(str1[i-1] == str2[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else\\n                    dp[i][j] = max(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        \\n        int i=m, j=n;\\n        string s = \"\";\\n        while(i>0 && j>0){\\n            if(str1[i-1] == str2[j-1]){\\n               s.push_back(str1[i-1]);\\n                i--; j--;\\n            }\\n            else{\\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    s.push_back(str1[i-1]);\\n                    i--;\\n                }\\n                else{\\n                    s.push_back(str2[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        while(i>0){\\n            s.push_back(str1[i-1]);\\n            i--;\\n        }\\n        while(j>0){\\n            s.push_back(str2[j-1]);\\n            j--;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m = str1.size();\\n        int n = str2.size();\\n        \\n        int dp[m+1][n+1];\\n        \\n        for(int i=0;i<m+1;i++){\\n            for(int j=0;j<n+1;j++){\\n                if(i==0 || j==0)\\n                    dp[i][j] = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2163189,
                "title": "c-lcs-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    string LCS(string a,string b){\\n        int n = a.length();\\n        int m = b.length();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0||j==0){\\n                    dp[i][j]=0;\\n                }\\n                else if(a[i-1]==b[j-1]){\\n                    dp[i][j] = 1+ dp[i-1][j-1];\\n                }\\n                else {\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        int i=n,j=m;\\n        string s=\"\";\\n        while(i>0&&j>0){\\n            if(a[i-1]==b[j-1]){\\n               s.push_back(a[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n               if(dp[i-1][j]>dp[i][j-1]){\\n                   i--;\\n               }\\n               else{\\n                   j--;\\n               } \\n            }\\n        }\\n       reverse(s.begin(),s.end());\\n        \\n      return s;  \\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string k =LCS(str1,str2);\\n        string res =\"\";\\n        int l = k.length();\\n        int j=0;\\n        int p=0;\\n        for(int i=0;i<l;i++){\\n            while(k[i]!=str1[j]&&j<str1.length()){\\n                res.push_back(str1[j]);\\n                j++;\\n            }\\n            while(k[i]!=str2[p]&&p<str2.length()){\\n                res.push_back(str2[p]);\\n                p++;\\n            }\\n            j++;\\n            p++;\\n            res.push_back(k[i]); \\n        }\\n        while(j<str1.length()){\\n           res.push_back(str1[j]);\\n            j++;\\n        }\\n        while(p<str2.length()){\\n            res.push_back(str2[p]);\\n            p++;\\n        }\\n     return res;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string LCS(string a,string b){\\n        int n = a.length();\\n        int m = b.length();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0||j==0){\\n                    dp[i][j]=0;\\n                }\\n                else if(a[i-1]==b[j-1]){\\n                    dp[i][j] = 1+ dp[i-1][j-1];\\n                }\\n                else {\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        int i=n,j=m;\\n        string s=\"\";\\n        while(i>0&&j>0){\\n            if(a[i-1]==b[j-1]){\\n               s.push_back(a[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n               if(dp[i-1][j]>dp[i][j-1]){\\n                   i--;\\n               }\\n               else{\\n                   j--;\\n               } \\n            }\\n        }\\n       reverse(s.begin(),s.end());\\n        \\n      return s;  \\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string k =LCS(str1,str2);\\n        string res =\"\";\\n        int l = k.length();\\n        int j=0;\\n        int p=0;\\n        for(int i=0;i<l;i++){\\n            while(k[i]!=str1[j]&&j<str1.length()){\\n                res.push_back(str1[j]);\\n                j++;\\n            }\\n            while(k[i]!=str2[p]&&p<str2.length()){\\n                res.push_back(str2[p]);\\n                p++;\\n            }\\n            j++;\\n            p++;\\n            res.push_back(k[i]); \\n        }\\n        while(j<str1.length()){\\n           res.push_back(str1[j]);\\n            j++;\\n        }\\n        while(p<str2.length()){\\n            res.push_back(str2[p]);\\n            p++;\\n        }\\n     return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158257,
                "title": "aditya-verma-op",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    string lcs(string str1,string str2,int n,int m){\\n        int t[n+1][m+1];\\n        \\n        \\n        for(int i=0;i<=n;i++){  // initialization\\n            for(int j=0;j<=m;j++ ){\\n                if(i==0 || j==0){\\n                    t[i][j]=0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                \\n                if(str1[i-1]==str2[j-1]){\\n                    \\n                    t[i][j]=1+t[i-1][j-1];\\n                }\\n                else{\\n                    \\n                    t[i][j]=max(t[i-1][j],t[i][j-1]);\\n                }\\n            }\\n        }\\n        int i=n;int j=m;\\n        string s=\"\";\\n        while(i>0 && j>0){\\n            \\n            if(str1[i-1]==str2[j-1]){\\n                \\n                s+=str1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else{\\n                \\n                if(t[i-1][j]<t[i][j-1]){\\n                    \\n                    s+=str2[j-1];\\n                    j--;\\n                }\\n                else{\\n                    \\n                    s+=str1[i-1];\\n                    i--;\\n                }\\n            }\\n            \\n         \\n            \\n            \\n            \\n            \\n           \\n        }\\n        \\n        \\n        while(i>0){\\n             \\n             s+=str1[i-1];\\n             i--;\\n             \\n         } \\n         while(j>0){\\n             s+=str2[j-1];\\n             j--;\\n             \\n             \\n         }\\n         reverse(s.begin(),s.end());\\n        \\n        return s;\\n        \\n \\n    }\\n\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n=str1.length();\\n        int m=str2.length();\\n        \\n        return lcs(str1,str2,n,m);\\n    }\\n};``",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1946731,
                "title": "c-lcs-variation-with-detailed-explanation-of-each-line",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.size();\\n        int n=str2.size();\\n        int t[m+1][n+1];            //Create matrix for DP\\n        for(int i=0;i<m+1;i++)     //initializing matrix at i=changing and j=0\\n            t[i][0]=0;\\n        for(int j=0;j<n+1;j++)      //initializing matrix at i=0 and j=changing\\n            t[0][j]=0;\\n        for(int i=1;i<m+1;i++) {     //Filling the remaining grids of matrix\\n            for(int j=1;j<n+1;j++) {\\n                if(str1[i-1]==str2[j-1])\\n                    t[i][j]=1+t[i-1][j-1];\\n                else\\n                    t[i][j]=max(t[i][j-1],t[i-1][j]);\\n            }\\n        }            //Till now we have filled whole matrix having total number of common elements at the last grid of matrix i.e. at t[m][n].\\n        string s;   //Create empty string which will store our answer further\\n        int i=m,j=n;   //We will start finding uncommon elements from the last grid of matrix.\\n        while(i>0 and j>0) {\\n            if(str1[i-1]==str2[j-1]) {\\n                s.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else {\\n                if(t[i][j-1]>t[i-1][j]) {\\n                    s.push_back(str2[j-1]);\\n                    j--;\\n                }\\n                else {\\n                    s.push_back(str1[i-1]);\\n                    i--;\\n                }\\n            }\\n        }\\n        while(i>0) {  //If the string \\'str2\\' finishes,we must store remaining elements of str1.\\n            s.push_back(str1[i-1]);\\n            i--;\\n        }\\n        while(j>0) {  //If the string \\'str1\\' finishes,we must store remaining elements of str1.\\n            s.push_back(str2[j-1]);\\n            j--;\\n        }  //As we started from last grid of matrix till i=0 and j=0 i.e till both the string finishes.\\n        reverse(s.begin(),s.end()); //Reverse string \\'s\\' because we have stored elements from last grid.\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.size();\\n        int n=str2.size();\\n        int t[m+1][n+1];            //Create matrix for DP\\n        for(int i=0;i<m+1;i++)     //initializing matrix at i=changing and j=0\\n            t[i][0]=0;\\n        for(int j=0;j<n+1;j++)      //initializing matrix at i=0 and j=changing\\n            t[0][j]=0;\\n        for(int i=1;i<m+1;i++) {     //Filling the remaining grids of matrix\\n            for(int j=1;j<n+1;j++) {\\n                if(str1[i-1]==str2[j-1])\\n                    t[i][j]=1+t[i-1][j-1];\\n                else\\n                    t[i][j]=max(t[i][j-1],t[i-1][j]);\\n            }\\n        }            //Till now we have filled whole matrix having total number of common elements at the last grid of matrix i.e. at t[m][n].\\n        string s;   //Create empty string which will store our answer further\\n        int i=m,j=n;   //We will start finding uncommon elements from the last grid of matrix.\\n        while(i>0 and j>0) {\\n            if(str1[i-1]==str2[j-1]) {\\n                s.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else {\\n                if(t[i][j-1]>t[i-1][j]) {\\n                    s.push_back(str2[j-1]);\\n                    j--;\\n                }\\n                else {\\n                    s.push_back(str1[i-1]);\\n                    i--;\\n                }\\n            }\\n        }\\n        while(i>0) {  //If the string \\'str2\\' finishes,we must store remaining elements of str1.\\n            s.push_back(str1[i-1]);\\n            i--;\\n        }\\n        while(j>0) {  //If the string \\'str1\\' finishes,we must store remaining elements of str1.\\n            s.push_back(str2[j-1]);\\n            j--;\\n        }  //As we started from last grid of matrix till i=0 and j=0 i.e till both the string finishes.\\n        reverse(s.begin(),s.end()); //Reverse string \\'s\\' because we have stored elements from last grid.\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842544,
                "title": "c-code-aditya-verma-bhaiya-s-code-for-scs",
                "content": "\\n  \\n  \\n  \\n  \\n  \\n  \\n        string shortestCommonSupersequence(string x, string y) {\\n         string ans=\"\";\\n        int m = x.size();//length of first string \\n        int n = y.size();//length of second string\\n        vector <vector <int> > t(m+1, vector<int> (n+1,0));\\n\\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                //code of choice diagram \\n                if(x[i-1]==y[j-1])\\n                    t[i][j] = 1+t[i-1][j-1];\\n                else\\n                    t[i][j] = max(t[i][j-1],t[i-1][j]);\\n            }\\n        }\\n        int i=m,j=n;\\n        while(i>0 && j>0){\\n            if(x[i-1] == y[j-1]){\\n                ans.push_back(x[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(t[i-1][j]>t[i][j-1]){\\n                    ans.push_back(x[i-1]);\\n                    i--; \\n                }else{\\n                    ans.push_back(y[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        while (i>0)\\n        {\\n            ans.push_back(x[i-1]);\\n            i--;\\n        }\\n        while (j>0)\\n        {\\n            ans.push_back(y[j-1]);\\n            j--;\\n        }\\n       reverse(ans.begin(),ans.end());\\n            return ans;\\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\tcredits : Aditya verma bhaiya ( Dp god :) )",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "\\n  \\n  \\n  \\n  \\n  \\n  \\n        string shortestCommonSupersequence(string x, string y) {\\n         string ans=\"\";\\n        int m = x.size();//length of first string \\n        int n = y.size();//length of second string\\n        vector <vector <int> > t(m+1, vector<int> (n+1,0));\\n\\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                //code of choice diagram \\n                if(x[i-1]==y[j-1])\\n                    t[i][j] = 1+t[i-1][j-1];\\n                else\\n                    t[i][j] = max(t[i][j-1],t[i-1][j]);\\n            }\\n        }\\n        int i=m,j=n;\\n        while(i>0 && j>0){\\n            if(x[i-1] == y[j-1]){\\n                ans.push_back(x[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(t[i-1][j]>t[i][j-1]){\\n                    ans.push_back(x[i-1]);\\n                    i--; \\n                }else{\\n                    ans.push_back(y[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        while (i>0)\\n        {\\n            ans.push_back(x[i-1]);\\n            i--;\\n        }\\n        while (j>0)\\n        {\\n            ans.push_back(y[j-1]);\\n            j--;\\n        }\\n       reverse(ans.begin(),ans.end());\\n            return ans;\\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\tcredits : Aditya verma bhaiya ( Dp god :) )",
                "codeTag": "Unknown"
            },
            {
                "id": 1763873,
                "title": "simple-enhanced-lcs-from-brute-force-to-dp",
                "content": "first to understand how to find lcs refer below link ->\\nhttps://leetcode.com/problems/longest-common-subsequence/discuss/1453785/3-solution-explained-from-brute-force-recursive-to-dp\\n\\nnow by using above approach we can prepare dp table array. now we will again follow print lcs logic of adding ith char to answer if  ith and jth char matches. just change logic of else part where characters are different. in such case add that character also.  as they are part of super set.\\nsimilarly once loop finishes i.e. either of i or j reaches 0. we need to copy remaining characters also to answer.\\n\\n```\\npublic String getShortestCommonSupersequenceLength(String s1, String s2) {\\n\\t\\tint[][] dp = bottomUpLCS(s1, s2);\\n\\t\\treturn printSCS(dp, s1, s2);\\n\\t}\\n\\n\\tprivate String printSCS(int[][] dp, String s1, String s2) {\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint i = s1.length();\\n\\t\\tint j = s2.length();\\n\\t\\twhile (i > 0 && j > 0) {\\n\\t\\t\\tif (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n\\t\\t\\t\\tsb.append(s1.charAt(i - 1));\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t} else if (dp[i - 1][j] > dp[i][j - 1]) {\\n\\t\\t\\t\\tsb.append(s1.charAt(i - 1));\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsb.append(s2.charAt(j - 1));\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (i > 0) {\\n\\t\\t\\tsb.append(s1.charAt(i - 1));\\n\\t\\t\\ti--;\\n\\t\\t}\\n\\t\\twhile (j > 0) {\\n\\t\\t\\tsb.append(s2.charAt(j - 1));\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\n\\t\\treturn sb.reverse().toString();\\n\\t}\\n\\n\\tprivate int[][] bottomUpLCS(String s1, String s2) {\\n\\t\\tint[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n\\t\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\t\\tif (i == 0 || j == 0) {\\n\\t\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t\\t\\t} else if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1] + 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp;\\n\\t}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\npublic String getShortestCommonSupersequenceLength(String s1, String s2) {\\n\\t\\tint[][] dp = bottomUpLCS(s1, s2);\\n\\t\\treturn printSCS(dp, s1, s2);\\n\\t}\\n\\n\\tprivate String printSCS(int[][] dp, String s1, String s2) {\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint i = s1.length();\\n\\t\\tint j = s2.length();\\n\\t\\twhile (i > 0 && j > 0) {\\n\\t\\t\\tif (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n\\t\\t\\t\\tsb.append(s1.charAt(i - 1));\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t} else if (dp[i - 1][j] > dp[i][j - 1]) {\\n\\t\\t\\t\\tsb.append(s1.charAt(i - 1));\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsb.append(s2.charAt(j - 1));\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (i > 0) {\\n\\t\\t\\tsb.append(s1.charAt(i - 1));\\n\\t\\t\\ti--;\\n\\t\\t}\\n\\t\\twhile (j > 0) {\\n\\t\\t\\tsb.append(s2.charAt(j - 1));\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\n\\t\\treturn sb.reverse().toString();\\n\\t}\\n\\n\\tprivate int[][] bottomUpLCS(String s1, String s2) {\\n\\t\\tint[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n\\t\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\t\\tif (i == 0 || j == 0) {\\n\\t\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t\\t\\t} else if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1] + 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1607806,
                "title": "very-smart-variation-of-lowest-common-subsequence-with-comments",
                "content": "```\\nstring printlcs(string text1, string text2) \\n     {\\n        int a=text1.length(),b=text2.length();\\n        int dp[a+1][b+1];\\n        for(int i=0;i<=a;i++)\\n        {\\n            for(int j=0;j<=b;j++)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j]=0;\\n            }\\n        }\\n        for(int i=1;i<=a;i++)\\n        {\\n            for(int j=1;j<=b;j++)\\n            {\\n                if(text1[i-1]==text2[j-1])\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                else\\n                    dp[i][j]=max(dp[i-1][j]  , dp[i][j-1]);\\n            }\\n        }\\n         string s=\"\";\\n         int i=a,j=b;\\n         while(i>0 && j>0)\\n         {\\n             if(text1[i-1]==text2[j-1])\\n             {\\n                 s+=text1[i-1];\\n                 i--;\\n                 j--;\\n             }\\n             else\\n             {\\n                 if(dp[i][j-1]>dp[i-1][j])\\n                     j--;\\n                 else\\n                     i--;\\n             }\\n         }\\n         reverse(s.begin(),s.end());\\n         return s;\\n    }\\n    \\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string lcs=printlcs(str1,str2);   // returns lcs\\n        string res=\"\";\\n        int ptr1=0,ptr2=0;      //keeping 2 pointers to track str1 and str2\\n        for(int i=0;i<lcs.length();i++)\\n        {\\n            while(str1[ptr1]!=lcs[i])//until we find current element of lcs in str1\\n                res+=str1[ptr1++];\\n            while(str2[ptr2]!=lcs[i])//until we find current element of lcs in str2\\n                res+=str2[ptr2++];\\n            res+=lcs[i];   //include the common element in all 3 strings\\n            ptr1++;\\n            ptr2++;\\n        }\\n        res+=str1.substr(ptr1)+str2.substr(ptr2);// include the rest portion of str1 and str2\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nstring printlcs(string text1, string text2) \\n     {\\n        int a=text1.length(),b=text2.length();\\n        int dp[a+1][b+1];\\n        for(int i=0;i<=a;i++)\\n        {\\n            for(int j=0;j<=b;j++)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j]=0;\\n            }\\n        }\\n        for(int i=1;i<=a;i++)\\n        {\\n            for(int j=1;j<=b;j++)\\n            {\\n                if(text1[i-1]==text2[j-1])\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                else\\n                    dp[i][j]=max(dp[i-1][j]  , dp[i][j-1]);\\n            }\\n        }\\n         string s=\"\";\\n         int i=a,j=b;\\n         while(i>0 && j>0)\\n         {\\n             if(text1[i-1]==text2[j-1])\\n             {\\n                 s+=text1[i-1];\\n                 i--;\\n                 j--;\\n             }\\n             else\\n             {\\n                 if(dp[i][j-1]>dp[i-1][j])\\n                     j--;\\n                 else\\n                     i--;\\n             }\\n         }\\n         reverse(s.begin(),s.end());\\n         return s;\\n    }\\n    \\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string lcs=printlcs(str1,str2);   // returns lcs\\n        string res=\"\";\\n        int ptr1=0,ptr2=0;      //keeping 2 pointers to track str1 and str2\\n        for(int i=0;i<lcs.length();i++)\\n        {\\n            while(str1[ptr1]!=lcs[i])//until we find current element of lcs in str1\\n                res+=str1[ptr1++];\\n            while(str2[ptr2]!=lcs[i])//until we find current element of lcs in str2\\n                res+=str2[ptr2++];\\n            res+=lcs[i];   //include the common element in all 3 strings\\n            ptr1++;\\n            ptr2++;\\n        }\\n        res+=str1.substr(ptr1)+str2.substr(ptr2);// include the rest portion of str1 and str2\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1557089,
                "title": "c-longest-common-sub-sequence-dp-o-mn-explained",
                "content": "### Algorithm\\n\\n1. Intialize 2D array\\n![image](https://assets.leetcode.com/users/images/af2954b0-2edd-4306-8f3f-904727947c8a_1635941043.2477422.png)\\n\\n2. Find the length of Longest Common Subsequence\\n\\n![image](https://assets.leetcode.com/users/images/e5f399e2-7fda-467e-a156-6adb0190e2da_1635941223.5975559.png)\\n\\n3. Printring the resulting string\\n\\n\\tLet\\n\\ti  = lenght of str1\\n\\tj  = length of str2 \\n\\twhere, i and j represent the index of str1 and str2.\\n\\t\\n\\t`1. If, str1[i]  != [j] then move to the adjacent cell with maximum value.`\\n\\t`2. Else if, str1[i] = str2[j] then move diagonally upwards.`\\n\\t`3. If, i changes push str1[i] in the resulting array.`\\n\\t`4. if, j changes push str2[j] in the resulting array.`\\n\\t\\n\\t\\n\\n![image](https://assets.leetcode.com/users/images/7aef561d-ad05-4219-8630-38c03bf9d020_1635941830.0392156.png)\\n\\n\\t\\n\\tstr1[i] = c\\n\\tstr2[j] = b\\n\\tstr1[i] != str2[j], hence i-- and push str1[i] in result array\\n\\t\\n\\tresult: c\\n\\t\\n\\n![image](https://assets.leetcode.com/users/images/5e761de6-e297-4af4-9c1d-5def19d7f824_1635941850.3462338.png)\\n`result: c a b`\\n![image](https://assets.leetcode.com/users/images/98859300-ab56-4eaa-8b8c-8411cc91924e_1635941870.7942457.png)\\n`result: c a b a c`\\n\\n4. Reverse the resulting string\\n\\n`result: c a b a c`\\n\\n**Time complexity : O(mn)**\\n\\n**C++ Code**\\n\\n```\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        \\n        int m = str1.size();\\n        int n = str2.size();\\n        string res = \"\";\\n        \\n        vector<vector<int>> t(m+1, vector<int>(n+1, 0));\\n        \\n        //Find the length of longest common subequence\\n        for(int i = 1;  i < m+1; i ++){\\n            for(int j = 1; j < n+1; j++){\\n                \\n                if(str1[i-1] == str2[j-1])\\n                    t[i][j] = t[i-1][j-1] + 1;\\n                else\\n                    t[i][j] = max(t[i-1][j], t[i][j-1]);\\n            }\\n        }\\n    \\n        //Print the resulting array\\n        int i = m;\\n        int j = n;\\n        \\n        while(i>0 && j>0){\\n            if(str1[i-1] == str2[j-1]){\\n                res.push_back(str1[i-1]);\\n                i--; j--;\\n            }\\n            else if(t[i][j-1] > t[i-1][j]){\\n                res.push_back(str2[j-1]);\\n                j--;\\n            }\\n            else{\\n                res.push_back(str1[i-1]);\\n                i--;\\n            }\\n        }\\n        \\n        while(i > 0){\\n            res.push_back(str1[i-1]);\\n            i--;\\n        }\\n        while(j > 0){\\n            res.push_back(str2[j-1]);\\n            j--;\\n        }\\n        \\n        \\n        //reverse the string\\n        reverse(res.begin(), res.end());\\n       \\n        \\n        return res;\\n    }\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        \\n        int m = str1.size();\\n        int n = str2.size();\\n        string res = \"\";\\n        \\n        vector<vector<int>> t(m+1, vector<int>(n+1, 0));\\n        \\n        //Find the length of longest common subequence\\n        for(int i = 1;  i < m+1; i ++){\\n            for(int j = 1; j < n+1; j++){\\n                \\n                if(str1[i-1] == str2[j-1])\\n                    t[i][j] = t[i-1][j-1] + 1;\\n                else\\n                    t[i][j] = max(t[i-1][j], t[i][j-1]);\\n            }\\n        }\\n    \\n        //Print the resulting array\\n        int i = m;\\n        int j = n;\\n        \\n        while(i>0 && j>0){\\n            if(str1[i-1] == str2[j-1]){\\n                res.push_back(str1[i-1]);\\n                i--; j--;\\n            }\\n            else if(t[i][j-1] > t[i-1][j]){\\n                res.push_back(str2[j-1]);\\n                j--;\\n            }\\n            else{\\n                res.push_back(str1[i-1]);\\n                i--;\\n            }\\n        }\\n        \\n        while(i > 0){\\n            res.push_back(str1[i-1]);\\n            i--;\\n        }\\n        while(j > 0){\\n            res.push_back(str2[j-1]);\\n            j--;\\n        }\\n        \\n        \\n        //reverse the string\\n        reverse(res.begin(), res.end());\\n       \\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1462766,
                "title": "c-using-lcs",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.size(),n=str2.size();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0||j==0)\\n                    dp[i][j]=0;\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                else\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        int i=m,j=n;\\n        string s=\"\";\\n        while(i>0&&j>0){\\n            if(str1[i-1]==str2[j-1])\\n            {\\n                s=s+str1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(dp[i][j-1]>dp[i-1][j])\\n                {\\n                    s+=str2[j-1];\\n                    j--;\\n                }\\n                else{\\n                    s+=str1[i-1];\\n                    i--;\\n                }\\n            }\\n        }\\n        while(i>0){\\n            s+=str1[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            s+=str2[j-1];\\n            j--;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.size(),n=str2.size();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0||j==0)\\n                    dp[i][j]=0;\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                else\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        int i=m,j=n;\\n        string s=\"\";\\n        while(i>0&&j>0){\\n            if(str1[i-1]==str2[j-1])\\n            {\\n                s=s+str1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(dp[i][j-1]>dp[i-1][j])\\n                {\\n                    s+=str2[j-1];\\n                    j--;\\n                }\\n                else{\\n                    s+=str1[i-1];\\n                    i--;\\n                }\\n            }\\n        }\\n        while(i>0){\\n            s+=str1[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            s+=str2[j-1];\\n            j--;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382023,
                "title": "c-solution",
                "content": "find lcs..\\n````\\nclass Solution {    \\npublic:\\n    \\n    string shortestCommonSupersequence(string str1, string str2) \\n    {\\n        \\n        int l1=str1.length(); int l2= str2.length();\\n        vector<vector<int>> dp(l1+1,vector<int>(l2+1));\\n         string ans=\"\";\\n    \\n        \\n        for(int i=0;i<=l1;i++) dp[i][0]=0;\\n        for(int j=0;j<=l2;j++) dp[0][j]=0;\\n        \\n        for(int i=1;i<=l1;i++)\\n        {\\n            for(int j=1;j<=l2;j++)\\n            {\\n                if(str1[i-1]==str2[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else\\n                {\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int i=l1, j=l2;\\n        \\n        while(i>0 and j>0)\\n        {\\n            if(str1[i-1]==str2[j-1])\\n            {\\n                ans=ans+str1[i-1];\\n                i--;j--;\\n            }\\n            else\\n            {\\n                if(dp[i][j-1]>=dp[i-1][j])\\n                {\\n                    j--;ans+=str2[j];\\n                }\\n                else\\n                {\\n                    i--; ans+=str1[i];\\n                }\\n            }\\n        }\\n        \\n        while(i>0)\\n        {\\n            ans+=str1[i-1];\\n            i--;\\n        }\\n        \\n        while(j>0)\\n        {\\n            ans+=str2[j-1];\\n            j--;\\n        }\\n        \\n        \\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution {    \\npublic:\\n    \\n    string shortestCommonSupersequence(string str1, string str2) \\n    {\\n        \\n        int l1=str1.length(); int l2= str2.length();\\n        vector<vector<int>> dp(l1+1,vector<int>(l2+1));\\n         string ans=\"\";\\n    \\n        \\n        for(int i=0;i<=l1;i++) dp[i][0]=0;\\n        for(int j=0;j<=l2;j++) dp[0][j]=0;\\n        \\n        for(int i=1;i<=l1;i++)\\n        {\\n            for(int j=1;j<=l2;j++)\\n            {\\n                if(str1[i-1]==str2[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else\\n                {\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int i=l1, j=l2;\\n        \\n        while(i>0 and j>0)\\n        {\\n            if(str1[i-1]==str2[j-1])\\n            {\\n                ans=ans+str1[i-1];\\n                i--;j--;\\n            }\\n            else\\n            {\\n                if(dp[i][j-1]>=dp[i-1][j])\\n                {\\n                    j--;ans+=str2[j];\\n                }\\n                else\\n                {\\n                    i--; ans+=str1[i];\\n                }\\n            }\\n        }\\n        \\n        while(i>0)\\n        {\\n            ans+=str1[i-1];\\n            i--;\\n        }\\n        \\n        while(j>0)\\n        {\\n            ans+=str2[j-1];\\n            j--;\\n        }\\n        \\n        \\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324746,
                "title": "c-lcs-variation-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s1, string s2) {\\n        string ans;\\n        int n=s1.length();\\n        int m=s2.length();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                dp[i][j]=0;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        int i=n,j=m;\\n        while(i>=1 && j>=1){\\n            if(dp[i][j]==max(dp[i-1][j],dp[i][j-1])){\\n                if(dp[i-1][j]>dp[i][j-1]){\\n                    ans+=s1[i-1];\\n                    --i;\\n                }\\n                else{\\n                    ans+=s2[j-1];\\n                    --j;\\n                }\\n            }\\n            else{\\n                ans+=s1[i-1];\\n                --i;\\n                --j;\\n            }\\n        }\\n        while(i>0){\\n            ans+=s1[i-1];\\n            --i;\\n        }\\n        while(j>0){\\n            ans+=s2[j-1];\\n            --j;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    string shortestCommonSupersequence(string s1, string s2) {\\n        string ans;\\n        int n=s1.length();\\n        int m=s2.length();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                dp[i][j]=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1270482,
                "title": "simplest-c-solution-with-comments-lcs-dp",
                "content": "**Please upvote this post to motivate me in my quest of documenting leetcode solutions.**\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m = str1.size();\\n        int n = str2.size();\\n        // fill the dp table\\n        int dp[m + 1][n + 1];\\n        for(int i = 0; i <= m; i++)\\n        {\\n            for(int j = 0; j <= n; j++)\\n            {\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n                else if(str1[i - 1] == str2[j - 1])\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                else\\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n        string ans;\\n        int i = m, j = n;\\n        while(i > 0 && j > 0)\\n        {\\n            // If current character in both the strings are same, then current character is part of shortest supersequence\\n            if(str1[i - 1] == str2[j - 1])\\n            {\\n                ans.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            // If current character in X and Y are different & we are moving upwards\\n            else if(dp[i - 1][j] > dp[i][j - 1])\\n            {\\n                ans.push_back(str1[i - 1]);\\n                i--;\\n            }\\n            // If current character in X and Y are different & we are moving leftwards\\n            else\\n            {\\n                ans.push_back(str2[j - 1]);\\n                j--;\\n            }\\n        }\\n        // If str2 reaches its end, put remaining characters of str1 in the result string\\n        while(i > 0)\\n        {\\n            ans.push_back(str1[i - 1]);\\n            i--;\\n        }\\n        // If str1 reaches its end, put remaining characters of str2 in the result string\\n        while(j > 0)\\n        {\\n            ans.push_back(str2[j - 1]);\\n            j--;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m = str1.size();\\n        int n = str2.size();\\n        // fill the dp table\\n        int dp[m + 1][n + 1];\\n        for(int i = 0; i <= m; i++)\\n        {\\n            for(int j = 0; j <= n; j++)\\n            {\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n                else if(str1[i - 1] == str2[j - 1])\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                else\\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n        string ans;\\n        int i = m, j = n;\\n        while(i > 0 && j > 0)\\n        {\\n            // If current character in both the strings are same, then current character is part of shortest supersequence\\n            if(str1[i - 1] == str2[j - 1])\\n            {\\n                ans.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            // If current character in X and Y are different & we are moving upwards\\n            else if(dp[i - 1][j] > dp[i][j - 1])\\n            {\\n                ans.push_back(str1[i - 1]);\\n                i--;\\n            }\\n            // If current character in X and Y are different & we are moving leftwards\\n            else\\n            {\\n                ans.push_back(str2[j - 1]);\\n                j--;\\n            }\\n        }\\n        // If str2 reaches its end, put remaining characters of str1 in the result string\\n        while(i > 0)\\n        {\\n            ans.push_back(str1[i - 1]);\\n            i--;\\n        }\\n        // If str1 reaches its end, put remaining characters of str2 in the result string\\n        while(j > 0)\\n        {\\n            ans.push_back(str2[j - 1]);\\n            j--;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018617,
                "title": "beats-98-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n=str1.size();\\n        int m=str2.size();\\n        int t[n+1][m+1];\\n        memset(t,0,sizeof(t));\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(str1[i-1]==str2[j-1])\\n                    t[i][j]=1+t[i-1][j-1];\\n                else\\n                    t[i][j]=max(t[i][j-1], t[i-1][j]);\\n            }\\n        }\\n        string ans;\\n        int i=n,j=m;\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                ans+=str1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(t[i-1][j]>t[i][j-1]){\\n                  ans+=str1[i-1];\\n                  i--;  \\n                }\\n                else{\\n                  ans+=str2[j-1];\\n                  j--;  \\n                }\\n            }\\n        }\\n        while(i>0)\\n        {\\n            ans+=str1[i-1];\\n            i--;\\n        }\\n         while(j>0)\\n        {\\n            ans+=str2[j-1];\\n            j--;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n=str1.size();\\n        int m=str2.size();\\n        int t[n+1][m+1];\\n        memset(t,0,sizeof(t));\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(str1[i-1]==str2[j-1])\\n                    t[i][j]=1+t[i-1][j-1];\\n                else\\n                    t[i][j]=max(t[i][j-1], t[i-1][j]);\\n            }\\n        }\\n        string ans;\\n        int i=n,j=m;\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                ans+=str1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(t[i-1][j]>t[i][j-1]){\\n                  ans+=str1[i-1];\\n                  i--;  \\n                }\\n                else{\\n                  ans+=str2[j-1];\\n                  j--;  \\n                }\\n            }\\n        }\\n        while(i>0)\\n        {\\n            ans+=str1[i-1];\\n            i--;\\n        }\\n         while(j>0)\\n        {\\n            ans+=str2[j-1];\\n            j--;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960113,
                "title": "java-dp-explained-same-as-lcs",
                "content": "In short , Shortest Common Supersequence = String a + String b - LCS(a, b)\\ndp[i][j] means the **Longest Common Subsequence** between String a[0:i] and String b[0:j]\\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String a, String b) {\\n        int m = a.length();\\n        int n = b.length();\\n        int dp[][] = new int[m+1][n+1];\\n\\t\\t// Finding the Longest Common Subsequence\\n        for(int i=0;i<=m;i++) {\\n            for(int j=0;j<=n;j++) {\\n\\t\\t\\t\\t// If either of the strings are empty, then there will not be any common subsequence.Hence 0\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n\\t\\t\\t\\t// If characters match, then add 1 to dp[i-1][j-1].\\n\\t\\t\\t\\t// Meaning we can take this matched character into account \\n\\t\\t\\t\\t// and longest common subsequence between String a[0:i-1] and String b[0:j-1]\\n\\t\\t\\t\\t// which is nothing but dp[i-1][j-1]\\n                else if(a.charAt(i-1) == b.charAt(j-1))\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n\\t\\t\\t\\t// In case of mismatch, we can ignore the character from String a or from String b\\n\\t\\t\\t\\t// And we will take which ever gives the maximum.\\n\\t\\t\\t\\t// If we ignore unmatched character from String a , then it will become dp[i-1][j] \\n\\t\\t\\t\\t// because we need to look at longest common subsequence between String a[0:i-1] and String b[0:j]\\n\\t\\t\\t\\t// If we ignore unmatched character from String b, then it will become dp[i][j-1] \\n\\t\\t\\t\\t// because we need to look at longest common subsequence between String a[0:i] and String b[0:j-1]\\n                else\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n\\t\\t// Now comes the Shortest Common Supersequence\\n\\t\\t// Taking two variables \"q\" & \"w\" to traverse the String a and String b respectively \\n        int q = m;\\n        int w = n;\\n\\t\\t// res holds the final result which we will return at the end\\n        String res = \"\";\\n        while(q != 0 && w != 0) {\\n\\t\\t\\t// If match, then adding this character to the res\\n            if(a.charAt(q-1) == b.charAt(w-1)) {\\n                res = a.charAt(q-1) + res;\\n                q -= 1;\\n                w -= 1;\\n            }\\n\\t\\t\\t// We have to go in the direction of maximum because this has yielded maximum LCS\\n\\t\\t\\t// While moving in that direction we have to include the mismatched character \\n\\t\\t\\t// from the String which we are moving away from \\n\\t\\t\\t// Here we are moving away from String a, hence adding that character to the res\\n\\t\\t\\telse if(dp[q-1][w] > dp[q][w-1]) {\\n                res = a.charAt(q-1) + res;\\n                q -= 1;\\n            } \\n\\t\\t\\t// Same explanation as above\\n\\t\\t\\telse {\\n                res = b.charAt(w-1) + res;\\n                w -= 1;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Now we need to add leftover characters from String\\'s a & b \\n\\t\\t// because the res String should contain all the characters from both the given Strings.\\n\\t\\t\\n\\t\\t// Order in which we add doesn\\'t matter\\n\\t\\t// i.e., String a\\'s leftover characters before b\\'s or Otherwise,\\n\\t\\t// since it is anyways subsequence\\n        \\n\\t\\t\\n        while(q != 0) {\\n            res = a.charAt(q-1) + res;\\n            q -= 1;\\n        }\\n       \\n        while(w != 0) {\\n            res = b.charAt(w-1) + res;\\n            w -= 1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String a, String b) {\\n        int m = a.length();\\n        int n = b.length();\\n        int dp[][] = new int[m+1][n+1];\\n\\t\\t// Finding the Longest Common Subsequence\\n        for(int i=0;i<=m;i++) {\\n            for(int j=0;j<=n;j++) {\\n\\t\\t\\t\\t// If either of the strings are empty, then there will not be any common subsequence.Hence 0\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n\\t\\t\\t\\t// If characters match, then add 1 to dp[i-1][j-1].\\n\\t\\t\\t\\t// Meaning we can take this matched character into account \\n\\t\\t\\t\\t// and longest common subsequence between String a[0:i-1] and String b[0:j-1]\\n\\t\\t\\t\\t// which is nothing but dp[i-1][j-1]\\n                else if(a.charAt(i-1) == b.charAt(j-1))\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n\\t\\t\\t\\t// In case of mismatch, we can ignore the character from String a or from String b\\n\\t\\t\\t\\t// And we will take which ever gives the maximum.\\n\\t\\t\\t\\t// If we ignore unmatched character from String a , then it will become dp[i-1][j] \\n\\t\\t\\t\\t// because we need to look at longest common subsequence between String a[0:i-1] and String b[0:j]\\n\\t\\t\\t\\t// If we ignore unmatched character from String b, then it will become dp[i][j-1] \\n\\t\\t\\t\\t// because we need to look at longest common subsequence between String a[0:i] and String b[0:j-1]\\n                else\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n\\t\\t// Now comes the Shortest Common Supersequence\\n\\t\\t// Taking two variables \"q\" & \"w\" to traverse the String a and String b respectively \\n        int q = m;\\n        int w = n;\\n\\t\\t// res holds the final result which we will return at the end\\n        String res = \"\";\\n        while(q != 0 && w != 0) {\\n\\t\\t\\t// If match, then adding this character to the res\\n            if(a.charAt(q-1) == b.charAt(w-1)) {\\n                res = a.charAt(q-1) + res;\\n                q -= 1;\\n                w -= 1;\\n            }\\n\\t\\t\\t// We have to go in the direction of maximum because this has yielded maximum LCS\\n\\t\\t\\t// While moving in that direction we have to include the mismatched character \\n\\t\\t\\t// from the String which we are moving away from \\n\\t\\t\\t// Here we are moving away from String a, hence adding that character to the res\\n\\t\\t\\telse if(dp[q-1][w] > dp[q][w-1]) {\\n                res = a.charAt(q-1) + res;\\n                q -= 1;\\n            } \\n\\t\\t\\t// Same explanation as above\\n\\t\\t\\telse {\\n                res = b.charAt(w-1) + res;\\n                w -= 1;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Now we need to add leftover characters from String\\'s a & b \\n\\t\\t// because the res String should contain all the characters from both the given Strings.\\n\\t\\t\\n\\t\\t// Order in which we add doesn\\'t matter\\n\\t\\t// i.e., String a\\'s leftover characters before b\\'s or Otherwise,\\n\\t\\t// since it is anyways subsequence\\n        \\n\\t\\t\\n        while(q != 0) {\\n            res = a.charAt(q-1) + res;\\n            q -= 1;\\n        }\\n       \\n        while(w != 0) {\\n            res = b.charAt(w-1) + res;\\n            w -= 1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796322,
                "title": "javascript-simple-dp-with-comments",
                "content": "```js\\n/**\\n * @param {string} str1\\n * @param {string} str2\\n * @return {string}\\n */\\nvar shortestCommonSupersequence = function(str1, str2) {\\n\\t// dp[i][j] holds the shortest supersequence between the first i chars of str1 and the first j chars of str2\\n\\tconst dp = new Array(str1.length + 1)\\n        .fill()\\n        .map(() => new Array(str2.length + 1));\\n    \\n\\t// Initialize base cases\\n    for (let i = 0; i <= str1.length; i++) {\\n        dp[i][0] = str1.substring(0,i);\\n    }\\n    \\n    for (let j = 0; j <= str2.length; j++) {\\n        dp[0][j] = str2.substring(0,j);\\n    }\\n    \\n    for (let i = 1; i <= str1.length; i++) {\\n        for (let j = 1; j <= str2.length; j++) {\\n\\t\\t\\t// If next char to add is common between strings, we can add it to the previous supersequence\\n            if (str1[i-1] === str2[j-1]) {\\n                dp[i][j] = dp[i-1][j-1] + str1[i-1];\\n            }\\n\\t\\t\\t// Otherwise choose the shorter supersequence to add it to\\n\\t\\t\\telse {\\n                if (dp[i-1][j].length < dp[i][j-1].length) {\\n                    dp[i][j] = dp[i-1][j] + str1[i-1];\\n                } else {\\n                    dp[i][j] = dp[i][j-1] + str2[j-1];\\n                }\\n            }\\n        }\\n    }\\n    \\n    return dp[str1.length][str2.length];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {string} str1\\n * @param {string} str2\\n * @return {string}\\n */\\nvar shortestCommonSupersequence = function(str1, str2) {\\n\\t// dp[i][j] holds the shortest supersequence between the first i chars of str1 and the first j chars of str2\\n\\tconst dp = new Array(str1.length + 1)\\n        .fill()\\n        .map(() => new Array(str2.length + 1));\\n    \\n\\t// Initialize base cases\\n    for (let i = 0; i <= str1.length; i++) {\\n        dp[i][0] = str1.substring(0,i);\\n    }\\n    \\n    for (let j = 0; j <= str2.length; j++) {\\n        dp[0][j] = str2.substring(0,j);\\n    }\\n    \\n    for (let i = 1; i <= str1.length; i++) {\\n        for (let j = 1; j <= str2.length; j++) {\\n\\t\\t\\t// If next char to add is common between strings, we can add it to the previous supersequence\\n            if (str1[i-1] === str2[j-1]) {\\n                dp[i][j] = dp[i-1][j-1] + str1[i-1];\\n            }\\n\\t\\t\\t// Otherwise choose the shorter supersequence to add it to\\n\\t\\t\\telse {\\n                if (dp[i-1][j].length < dp[i][j-1].length) {\\n                    dp[i][j] = dp[i-1][j] + str1[i-1];\\n                } else {\\n                    dp[i][j] = dp[i][j-1] + str2[j-1];\\n                }\\n            }\\n        }\\n    }\\n    \\n    return dp[str1.length][str2.length];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 718319,
                "title": "c-dp-bottom-up-simple-and-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.size();\\n        int n=str2.size();\\n        int dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(str1[i-1]==str2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int i=m;\\n        int j=n;\\n        string ans=\"\";\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                ans.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(dp[i-1][j]>dp[i][j-1]){\\n                    ans.push_back(str1[i-1]);\\n                    i--;\\n                }\\n                else{\\n                    ans.push_back(str2[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n            ans.push_back(str1[i-1]);\\n            i--;\\n        }\\n        while(j>0){\\n            ans.push_back(str2[j-1]);\\n            j--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int m=str1.size();\\n        int n=str2.size();\\n        int dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(str1[i-1]==str2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int i=m;\\n        int j=n;\\n        string ans=\"\";\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                ans.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(dp[i-1][j]>dp[i][j-1]){\\n                    ans.push_back(str1[i-1]);\\n                    i--;\\n                }\\n                else{\\n                    ans.push_back(str2[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n            ans.push_back(str1[i-1]);\\n            i--;\\n        }\\n        while(j>0){\\n            ans.push_back(str2[j-1]);\\n            j--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700498,
                "title": "easy-to-understand-with-explanation-c-give-it-a-try-c-beat-80-in-time",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string text1, string text2)\\n    {\\n        vector<vector<int>> dp;\\n        int m=text1.size();\\n        int n=text2.size();\\n        dp.resize(m+1,vector<int>(n+1,0));\\n        string str;\\n        // calculationg the table for longest common subsequence using botton up approach....\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(text1[i]==text2[j])\\n                {\\n                    dp[i+1][j+1]=dp[i][j]+1;\\n                }\\n                else\\n                    dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]);\\n            }\\n        }\\n       int i=m,j=n;\\n        // Getting the LCS string\\n        while(i>0 and j>0)\\n        {\\n            if(dp[i][j]!=dp[i][j-1] and dp[i][j]!=dp[i-1][j])\\n            {\\n                str+=text1[i-1];\\n                \\n                i--;\\n                j--;\\n            }\\n            else if(dp[i][j]==dp[i][j-1])\\n                j--;\\n            else i--;\\n        }\\n       reverse(str.begin(),str.end());\\n        int k=0;\\n        \\n        string ans,res;\\n        // now comparing the cases basically 3 cases are possible.\\n       for(i=0,j=0;i<m,j<n;)\\n       {\\n           //1. if character from both given strings is equal in taht case it will belong to subsequence in that case \\n           //copy it from LCS as it only required once...\\n           if(str[k]==text1[i] and str[k]==text2[j])\\n           {\\n               res+=str[k];\\n               i++;\\n               j++;\\n               k++;\\n           }\\n           //2. else char belongs to 2nd string\\n           else if(str[k]!=text2[j])\\n           {\\n               res+=text2[j];\\n               j++;\\n           }\\n           //3. or it belong to 1st string\\n           else\\n           {\\n               res+=text1[i];\\n               i++;\\n           }\\n       }\\n        //suppose one string is larger then another string with such that it doesn\\'t have remaining any LCS char in the rest part and thereforne considered differnely...\\n        for(;i<m;i++)\\n            res+=text1[i];\\n        for(;j<n;j++)\\n            res+=text2[j];\\n     \\n        return res;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string shortestCommonSupersequence(string text1, string text2)\\n    {\\n        vector<vector<int>> dp;\\n        int m=text1.size();\\n        int n=text2.size();\\n        dp.resize(m+1,vector<int>(n+1,0));\\n        string str;\\n        // calculationg the table for longest common subsequence using botton up approach....\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(text1[i]==text2[j])\\n                {\\n                    dp[i+1][j+1]=dp[i][j]+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 637303,
                "title": "c-solution-using-lcs-w-backtrack",
                "content": "Run-time is `O(N^2)`. Space is `O(N^2)`. \\n\\nTo create the actual string using backtrack, we would simply add based on previous pointer. If the current indices are `i` and `j`  (`i` for `str1` and `j` for `str2`) and the previous pointer goes to `i-1` and `j-1`, then it means the LCS used match here, and so we just add `str1[i]` or `str[j]`, since they are the same. If it goes to `i-1` and `j`, then this character was not part of the LCS, and we add `str1[i]`. Similarly, if we come from `j-1`, `i` then we add `str2[j]`. \\n\\nOnce we finish adding up all the characters, we simply reverse the string to get the solution.\\n\\n```\\nstruct Val {\\n    Val(): p(0), previ(0), prevj(0) {}\\n    int p;\\n    int previ;\\n    int prevj;\\n};\\n\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(const string& str1, const string& str2) {\\n        int size1 = str1.size(), size2 = str2.size();\\n        vector<vector<Val>> dp(size1+1, vector<Val>(size2+1));\\n        for(int i = 1; i < size1; ++i) dp[i][0].previ = i-1;\\n        for(int j = 1; j < size2; ++j) dp[0][j].prevj = j-1;\\n        for(int i = 1; i <= size1; ++i) {\\n            for(int j = 1; j <= size2; ++j) {\\n                auto &[p, previ, prevj] {dp[i][j]};\\n                if(str1[i-1] == str2[j-1]) p = dp[i-1][j-1].p+1, previ = i-1, prevj = j-1;\\n                } else {\\n                    if(dp[i-1][j].p > dp[i][j-1].p) p = dp[i-1][j].p, previ = i-1, prevj = j;\\n                    else p = dp[i][j-1].p, previ = i, prevj = j-1;\\n                }\\n            }\\n        }\\n\\n        int previ = size1, prevj = size2;\\n        string res = \"\";\\n        while(previ != 0 || prevj != 0) {\\n            auto [p, i, j] {dp[previ][prevj]};\\n            if(i < previ && j < previ) res += str1[previ-1];\\n            else if(i < previ) res += str1[previ-1];\\n            else res += str2[prevj-1];\\n            previ = i;\\n            prevj = j;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Val {\\n    Val(): p(0), previ(0), prevj(0) {}\\n    int p;\\n    int previ;\\n    int prevj;\\n};\\n\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(const string& str1, const string& str2) {\\n        int size1 = str1.size(), size2 = str2.size();\\n        vector<vector<Val>> dp(size1+1, vector<Val>(size2+1));\\n        for(int i = 1; i < size1; ++i) dp[i][0].previ = i-1;\\n        for(int j = 1; j < size2; ++j) dp[0][j].prevj = j-1;\\n        for(int i = 1; i <= size1; ++i) {\\n            for(int j = 1; j <= size2; ++j) {\\n                auto &[p, previ, prevj] {dp[i][j]};\\n                if(str1[i-1] == str2[j-1]) p = dp[i-1][j-1].p+1, previ = i-1, prevj = j-1;\\n                } else {\\n                    if(dp[i-1][j].p > dp[i][j-1].p) p = dp[i-1][j].p, previ = i-1, prevj = j;\\n                    else p = dp[i][j-1].p, previ = i, prevj = j-1;\\n                }\\n            }\\n        }\\n\\n        int previ = size1, prevj = size2;\\n        string res = \"\";\\n        while(previ != 0 || prevj != 0) {\\n            auto [p, i, j] {dp[previ][prevj]};\\n            if(i < previ && j < previ) res += str1[previ-1];\\n            else if(i < previ) res += str1[previ-1];\\n            else res += str2[prevj-1];\\n            previ = i;\\n            prevj = j;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 618128,
                "title": "java-solution-for-scs-using-lcs-beats-100-space-and-95-time",
                "content": "**To print LCS**\\n\\n1)First we build the LCS table.\\n2)We start from i=str1.length() and j = str2.length() and if the characters are equal then we append the char and move diagonally (i-- & j--) \\n3)Else we move in the direction which has maximum value in the dp table\\n\\t3.1 If dp[i-1][j]> dp[i][j-1])  then move up (i--)\\n\\t3.2 else move left (j--)\\n\\n**To print SCS using LCS Table**\\'\\n\\nIs there a way to print SCS using the LCS DP Table? Yes, there is.\\nIf we observe keenly,\\nSCS is nothing but str1+str2 - LCS.\\n\\n1)So here we print the common characters only once as usual.\\n2)But we also print the char in the else loop whose matrix value is greater (Because we need them to form a supersequence of str1 & str2)\\n3)The while loops ends if any of the string str1 or str2 is exhausted.\\nSo we need to check and print the remaining chars either str1 or str2 whichever is not exhausted.\\n4)Finally we return the reversed string.\\n\\n**Code**\\n\\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) \\n    {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        int m = str1.length();\\n        int n = str2.length();\\n        int dp[][] = new int[m+1][n+1];\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(str1.charAt(i-1)==str2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1]+1;\\n                else\\n                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        \\n        int i=m;\\n        int j=n;\\n        \\n        while(i>0&&j>0)\\n        {\\n            if(str1.charAt(i-1)==str2.charAt(j-1))\\n            {\\n               sb.append(str1.charAt(i-1));\\n                i--;\\n                j--;\\n            }\\n                \\n            \\n            else\\n            {\\n                if(dp[i][j-1]>dp[i-1][j])\\n                {\\n                        sb.append(str2.charAt(j-1));\\n                        j--;\\n                }\\n                \\n                else\\n                {\\n                   sb.append(str1.charAt(i-1));\\n                   i--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0)\\n        {\\n            sb.append(str1.charAt(i-1));\\n            i--;\\n        }\\n        \\n        while(j>0)\\n        {\\n            sb.append(str2.charAt(j-1));\\n            j--;\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n\\n**Performance:**\\n\\nRuntime: 10 ms, faster than 95.22% of Java online submissions for Shortest Common Supersequence .\\nMemory Usage: 43.1 MB, less than 100.00% of Java online submissions for Shortest Common Supersequence .\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) \\n    {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        int m = str1.length();\\n        int n = str2.length();\\n        int dp[][] = new int[m+1][n+1];\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(str1.charAt(i-1)==str2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1]+1;\\n                else\\n                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        \\n        int i=m;\\n        int j=n;\\n        \\n        while(i>0&&j>0)\\n        {\\n            if(str1.charAt(i-1)==str2.charAt(j-1))\\n            {\\n               sb.append(str1.charAt(i-1));\\n                i--;\\n                j--;\\n            }\\n                \\n            \\n            else\\n            {\\n                if(dp[i][j-1]>dp[i-1][j])\\n                {\\n                        sb.append(str2.charAt(j-1));\\n                        j--;\\n                }\\n                \\n                else\\n                {\\n                   sb.append(str1.charAt(i-1));\\n                   i--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0)\\n        {\\n            sb.append(str1.charAt(i-1));\\n            i--;\\n        }\\n        \\n        while(j>0)\\n        {\\n            sb.append(str2.charAt(j-1));\\n            j--;\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537643,
                "title": "very-easy-understand-java-dp-and-three-pointer-solution-java-26ms",
                "content": "First we get the longest subsequence between the two string word1 and word2 using dynamic programming. Once we have the long common subsequence. \\n\\nwe make three pointers point at the word1 word2 and subsequence and append the string accodingly and we get the shortest common supersuquence.\\ne.g.\\nword1:        a b c d e \\nword2: x a a d c f e\\nsub:            a  c  e\\n\\nwhen **i** points at a of the sub: for word1 we add nothing , for word2 we add x. we add the a and then move to c. we get **xa**\\n\\nwhen **i** points at c, for word1 we add b, for word2 we add a d. then we add the c and then move to e.\\nwe get **xabadc**\\n\\nwhen **i** points at e, for word1 we add d, for word2 we add f. then we add the  e\\nwe get **xabadcdfe**\\n\\n\\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String word1, String word2) {\\n        int len1 = word1.length();\\n        int len2 = word2.length();\\n        \\n        String[][] dp = new String[len1 + 1][len2 + 1];\\n        for (String[] row : dp) {\\n            Arrays.fill(row, \"\");\\n        }\\n        \\n        // Find the longest common substring.\\n        for (int i = 0; i < len1; i++) {\\n            for (int j = 0; j < len2; j++) {\\n                if (word1.charAt(i) == word2.charAt(j)) {\\n                    dp[i + 1][j + 1] = dp[i][j] + word1.charAt(i);\\n                } else {\\n                    if (dp[i][j + 1].length() >= dp[i + 1][j].length()) {\\n                        dp[i + 1][j + 1] = dp[i][j + 1];\\n                    } else {\\n                        dp[i + 1][j + 1] = dp[i + 1][j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Get the longest common subsequence\\n        StringBuilder sb = new StringBuilder();\\n        String commonStr = dp[len1][len2];\\n        \\n\\t\\t// Three pointers which points at the begining of  word1, word2 as well as the \\n\\t\\t// common substring \\n        int i = 0;\\n        int p1 = 0;\\n        int p2 = 0;\\n        \\n        while (i < commonStr.length()) {\\n            char temp = commonStr.charAt(i);\\n            while (p1 < word1.length() && word1.charAt(p1) != temp) {\\n                sb.append(word1.charAt(p1));\\n                p1 += 1;\\n            }\\n            while (p2 < word2.length() && word2.charAt(p2) != temp) {\\n                sb.append(word2.charAt(p2));\\n                p2 += 1;\\n            }\\n            sb.append(temp);\\n            i += 1;\\n            p1 += 1;\\n            p2 += 1;\\n        }\\n        \\n        while (p1 < word1.length()) sb.append(word1.charAt(p1++));        \\n        while (p2 < word2.length()) sb.append(word2.charAt(p2++));\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String word1, String word2) {\\n        int len1 = word1.length();\\n        int len2 = word2.length();\\n        \\n        String[][] dp = new String[len1 + 1][len2 + 1];\\n        for (String[] row : dp) {\\n            Arrays.fill(row, \"\");\\n        }\\n        \\n        // Find the longest common substring.\\n        for (int i = 0; i < len1; i++) {\\n            for (int j = 0; j < len2; j++) {\\n                if (word1.charAt(i) == word2.charAt(j)) {\\n                    dp[i + 1][j + 1] = dp[i][j] + word1.charAt(i);\\n                } else {\\n                    if (dp[i][j + 1].length() >= dp[i + 1][j].length()) {\\n                        dp[i + 1][j + 1] = dp[i][j + 1];\\n                    } else {\\n                        dp[i + 1][j + 1] = dp[i + 1][j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Get the longest common subsequence\\n        StringBuilder sb = new StringBuilder();\\n        String commonStr = dp[len1][len2];\\n        \\n\\t\\t// Three pointers which points at the begining of  word1, word2 as well as the \\n\\t\\t// common substring \\n        int i = 0;\\n        int p1 = 0;\\n        int p2 = 0;\\n        \\n        while (i < commonStr.length()) {\\n            char temp = commonStr.charAt(i);\\n            while (p1 < word1.length() && word1.charAt(p1) != temp) {\\n                sb.append(word1.charAt(p1));\\n                p1 += 1;\\n            }\\n            while (p2 < word2.length() && word2.charAt(p2) != temp) {\\n                sb.append(word2.charAt(p2));\\n                p2 += 1;\\n            }\\n            sb.append(temp);\\n            i += 1;\\n            p1 += 1;\\n            p2 += 1;\\n        }\\n        \\n        while (p1 < word1.length()) sb.append(word1.charAt(p1++));        \\n        while (p2 < word2.length()) sb.append(word2.charAt(p2++));\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536363,
                "title": "c-dp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring shortestCommonSupersequence(string str1, string str2) {\\n\\t\\t\\tint n1=str1.size();\\n\\t\\t\\tint n2=str2.size();\\n\\t\\t\\tvector<vector<int>> dp(n1+1,vector<int>(n2+1));\\n\\t\\t\\tfor(int i=1;i<=n1;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=n2;j++){\\n\\t\\t\\t\\t\\tif(str1[i-1]==str2[j-1]){\\n\\t\\t\\t\\t\\t\\tdp[i][j]=dp[i-1][j-1]+1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tdp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tstring ans;\\n\\t\\t\\twhile(n1 || n2){\\n\\t\\t\\t\\tif(n1==0){\\n\\t\\t\\t\\t\\tans+=str2[n2-1];\\n\\t\\t\\t\\t\\tn2--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(n2==0){\\n\\t\\t\\t\\t\\tans+=str1[n1-1];\\n\\t\\t\\t\\t\\tn1--;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse if(str1[n1-1]==str2[n2-1]){\\n\\t\\t\\t\\t\\tans+=str1[n1-1];\\n\\t\\t\\t\\t\\tn1--;\\n\\t\\t\\t\\t\\tn2--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(dp[n1-1][n2]==dp[n1][n2]){\\n\\n\\t\\t\\t\\t\\tans+=str1[n1-1];\\n\\t\\t\\t\\t\\tn1--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(dp[n1][n2-1]==dp[n1][n2]){\\n\\t\\t\\t\\t\\tans+=str2[n2-1];\\n\\t\\t\\t\\t\\tn2--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treverse(ans.begin(),ans.end());\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring shortestCommonSupersequence(string str1, string str2) {\\n\\t\\t\\tint n1=str1.size();\\n\\t\\t\\tint n2=str2.size();\\n\\t\\t\\tvector<vector<int>> dp(n1+1,vector<int>(n2+1));\\n\\t\\t\\tfor(int i=1;i<=n1;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=n2;j++){\\n\\t\\t\\t\\t\\tif(str1[i-1]==str2[j-1]){\\n\\t\\t\\t\\t\\t\\tdp[i][j]=dp[i-1][j-1]+1;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 368709,
                "title": "python-dp-solution",
                "content": "Let\\'s say `dp[i][j]` represents the shortest answer for `str1[:i+1]` and `str2[:j+1]`, then `dp[i][j]` equals to the shortest string among:\\n* `dp[i-1][j] + str1[i]`,\\n* `dp[i][j-1] + str2[j]`,\\n* `dp[i-1][j-1] + str1[i]` (only when `str1[i] == str2[j]`)\\nAnd all the `dp[0][*]` and `dp[*][0]` are easy to calculate.\\n\\nFirst I tried memorization + recursion, I got a **Memory Limit Exceeded**. I tried bottom-up DP, still the same.\\n\\nThen I realized in the bottom-up version, for each `dp[i][j]`, only `dp[i][*]` and `dp[i-1][*]` are needed. Basically, I only have to save the latest 2 rounds of `dp[][]`.\\n\\nIt\\'s also easier to handle starting data: I can prepare the `dp[-1][*]` before the bottom-up DP loop.\\n\\nHere is the code:\\n```\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        dp0, dp1 = [str2[:j+1] for j in range(len(str2))], [\"\"] * len(str2)\\n        for i in range(len(str1)):\\n            dp1[0] = min(dp0[0] + str1[i],\\n                         str1[:i+1] + (\"\" if str1[i] == str2[0] else str2[0]), key=len)\\n            for j in range(1, len(str2)):\\n                temp = [dp0[j] + str1[i], dp1[j-1] + str2[j]]\\n                if str1[i] == str2[j]: temp.append(dp0[j-1] + str1[i])\\n                dp1[j] = min(temp, key=len)\\n            dp0 = dp1.copy()\\n        return dp1[-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        dp0, dp1 = [str2[:j+1] for j in range(len(str2))], [\"\"] * len(str2)\\n        for i in range(len(str1)):\\n            dp1[0] = min(dp0[0] + str1[i],\\n                         str1[:i+1] + (\"\" if str1[i] == str2[0] else str2[0]), key=len)\\n            for j in range(1, len(str2)):\\n                temp = [dp0[j] + str1[i], dp1[j-1] + str2[j]]\\n                if str1[i] == str2[j]: temp.append(dp0[j-1] + str1[i])\\n                dp1[j] = min(temp, key=len)\\n            dp0 = dp1.copy()\\n        return dp1[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 314392,
                "title": "short-python-c-dp-no-lcs",
                "content": "**Python 3**\\n```python\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def shortestCommonSupersequence(self, s, t):\\n        @lru_cache(50000)\\n        def dp(s, t):\\n            if s == \"\": return t\\n            if t == \"\": return s\\n            if s[-1] == t[-1]:\\n                return dp(s[:-1], t[:-1]) + s[-1]\\n            else:\\n                return min(dp(s[:-1], t) + s[-1], dp(s, t[:-1]) + t[-1], key=len)\\n        return dp(s, t)\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s, string t) {\\n        auto n = s.size();\\n        auto m = t.size();\\n        \\n        std::string dp[2][m + 1];\\n        \\n        for (int j = 1; j <= m; j++) {\\n            dp[0][j] = t.substr(0, j);\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            dp[i&1][0] = s.substr(0, i);\\n            for (int j = 1; j <= m; j++) {\\n                if (s[i - 1] == t[j - 1]) {\\n                    dp[i&1][j] = dp[~i&1][j - 1] + s[i - 1];\\n                } else if (dp[~i&1][j].size() < dp[i&1][j - 1].size()) {\\n                    dp[i&1][j] = dp[~i&1][j] + s[i - 1];\\n                } else {\\n                    dp[i&1][j] = dp[i&1][j - 1] + t[j - 1];\\n                }\\n            }\\n        }\\n        \\n        return dp[n&1][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def shortestCommonSupersequence(self, s, t):\\n        @lru_cache(50000)\\n        def dp(s, t):\\n            if s == \"\": return t\\n            if t == \"\": return s\\n            if s[-1] == t[-1]:\\n                return dp(s[:-1], t[:-1]) + s[-1]\\n            else:\\n                return min(dp(s[:-1], t) + s[-1], dp(s, t[:-1]) + t[-1], key=len)\\n        return dp(s, t)\\n```\n```c++\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s, string t) {\\n        auto n = s.size();\\n        auto m = t.size();\\n        \\n        std::string dp[2][m + 1];\\n        \\n        for (int j = 1; j <= m; j++) {\\n            dp[0][j] = t.substr(0, j);\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            dp[i&1][0] = s.substr(0, i);\\n            for (int j = 1; j <= m; j++) {\\n                if (s[i - 1] == t[j - 1]) {\\n                    dp[i&1][j] = dp[~i&1][j - 1] + s[i - 1];\\n                } else if (dp[~i&1][j].size() < dp[i&1][j - 1].size()) {\\n                    dp[i&1][j] = dp[~i&1][j] + s[i - 1];\\n                } else {\\n                    dp[i&1][j] = dp[i&1][j - 1] + t[j - 1];\\n                }\\n            }\\n        }\\n        \\n        return dp[n&1][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312826,
                "title": "c-table-dp-lcs-solution-beats-100-time-and-memory-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int lcs[1010] [1010];\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n\\t\\t\\n\\t\\t//simple table dp lcs generation code\\n        for(int i=0; i<len1; i++) {\\n            for(int j=0; j<len2; j++) {\\n                int left = (i-1>=0? lcs[i-1][j]:0);\\n                int up = (j-1>=0? lcs[i][j-1]: 0);\\n                int up_left = (i>0 && j>0? lcs[i-1][j-1]:0);\\n                if(str1[i]==str2[j])\\n                    lcs[i][j] = up_left+1;\\n                else\\n                    lcs[i][j] = max(up, left);\\n            }\\n        }\\n        cout<<\"lcs:\"<<lcs[len1-1][len2-1]<<endl;\\n        \\n        int i = len1- 1, j = len2-1;\\n        string temp;\\n        \\n\\t\\t//going the reverse path in table dp and generating the common string\\n        while(i>=0 && j>=0) {\\n            if(str1[i]==str2[j]) { // take a char if both strings have same char in respective positions\\n                temp+= str1[i];\\n                i--;\\n                j--;\\n            } else if((i>0 && j>0 && lcs[i-1][j]>=lcs[i][j-1]) || (j==0 && i>0)) { //if we get more common by taking current character from str1 or str2 two have only one character to pick and str1 one have many left (the next character might match with the last character of str2) take from str1.\\n                temp+=str1[i];\\n                i--;\\n            } else {\\n                temp+= str2[j];\\n                j--;\\n            }\\n        }\\n        \\n        while(i>=0) {\\n            temp+= str1[i];\\n            i--;\\n        }\\n        while(j>=0) {\\n            temp+= str2[j];\\n            j--;\\n        }\\n        reverse(temp.begin(), temp.end());\\n        return temp; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lcs[1010] [1010];\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n\\t\\t\\n\\t\\t//simple table dp lcs generation code\\n        for(int i=0; i<len1; i++) {\\n            for(int j=0; j<len2; j++) {\\n                int left = (i-1>=0? lcs[i-1][j]:0);\\n                int up = (j-1>=0? lcs[i][j-1]: 0);\\n                int up_left = (i>0 && j>0? lcs[i-1][j-1]:0);\\n                if(str1[i]==str2[j])\\n                    lcs[i][j] = up_left+1;\\n                else\\n                    lcs[i][j] = max(up, left);\\n            }\\n        }\\n        cout<<\"lcs:\"<<lcs[len1-1][len2-1]<<endl;\\n        \\n        int i = len1- 1, j = len2-1;\\n        string temp;\\n        \\n\\t\\t//going the reverse path in table dp and generating the common string\\n        while(i>=0 && j>=0) {\\n            if(str1[i]==str2[j]) { // take a char if both strings have same char in respective positions\\n                temp+= str1[i];\\n                i--;\\n                j--;\\n            } else if((i>0 && j>0 && lcs[i-1][j]>=lcs[i][j-1]) || (j==0 && i>0)) { //if we get more common by taking current character from str1 or str2 two have only one character to pick and str1 one have many left (the next character might match with the last character of str2) take from str1.\\n                temp+=str1[i];\\n                i--;\\n            } else {\\n                temp+= str2[j];\\n                j--;\\n            }\\n        }\\n        \\n        while(i>=0) {\\n            temp+= str1[i];\\n            i--;\\n        }\\n        while(j>=0) {\\n            temp+= str2[j];\\n            j--;\\n        }\\n        reverse(temp.begin(), temp.end());\\n        return temp; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3751004,
                "title": "easiest-python-code-clean-and-simple-striver",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        n=len(str1)\\n        m=len(str2)\\n        ans=\"\"\\n        i=n\\n        j=m\\n        dp=[[0]*(m+1) for _ in range(n+1)]\\n        for j in range(m+1):\\n            dp[0][j]=0\\n        for i in range(n+1):\\n            dp[i][0]=0\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if str1[i-1]==str2[j-1]:\\n                    dp[i][j]=1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=max(dp[i][j-1],dp[i-1][j])\\n        \\n        while(i>0 and j>0):\\n            if str1[i-1]==str2[j-1]:\\n                ans+=str1[i-1]\\n                i=i-1\\n                j=j-1\\n            elif dp[i-1][j]>dp[i][j-1]:\\n                ans+=str1[i-1]\\n                i=i-1\\n            else:\\n                ans+=str2[j-1]\\n                j=j-1\\n        while i>0:\\n            ans+=str1[i-1]\\n            i-=1\\n        while j>0:\\n            ans+=str2[j-1]\\n            j-=1\\n        return ans[::-1]\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        n=len(str1)\\n        m=len(str2)\\n        ans=\"\"\\n        i=n\\n        j=m\\n        dp=[[0]*(m+1) for _ in range(n+1)]\\n        for j in range(m+1):\\n            dp[0][j]=0\\n        for i in range(n+1):\\n            dp[i][0]=0\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if str1[i-1]==str2[j-1]:\\n                    dp[i][j]=1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=max(dp[i][j-1],dp[i-1][j])\\n        \\n        while(i>0 and j>0):\\n            if str1[i-1]==str2[j-1]:\\n                ans+=str1[i-1]\\n                i=i-1\\n                j=j-1\\n            elif dp[i-1][j]>dp[i][j-1]:\\n                ans+=str1[i-1]\\n                i=i-1\\n            else:\\n                ans+=str2[j-1]\\n                j=j-1\\n        while i>0:\\n            ans+=str1[i-1]\\n            i-=1\\n        while j>0:\\n            ans+=str2[j-1]\\n            j-=1\\n        return ans[::-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642313,
                "title": "best-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     \\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n=str1.length();\\n        int m=str2.length();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0||j==0){\\n                    dp[i][j]=0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                \\n                if(str1[i-1]==str2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n\\n        // int i=n;\\n        // int j=m;\\n        // string str=\"\";\\n        // while(i!=0&&j!=0){\\n        //     if(str1[i-1]==str[j-1]){\\n        //         str.push_back(str1[i-1]);\\n        //         i--;\\n        //         j--;\\n        //     }\\n        //     else if(dp[i][j-1] > dp[i-1][j]){\\n        //         j--;\\n        //     }\\n        //     else{\\n        //         i--;\\n        //     }\\n        // }\\n        // reverse(str.begin(),str.end());\\n         \\n        // string modified=str1;\\n\\n        // for(int i=0;i<n+1;i++){\\n        //     for(int j=0;j<str.length();j++){\\n        //         if(str[j]==modified[i]){\\n        //             modified.erase(i,1);\\n        //             break;\\n        //         }\\n        //     }\\n\\n        // }\\n\\n        // string result=modified+str2;\\n\\n        // return result;\\n         int i = n;\\n    int j = m;\\n    string str = \"\";\\n    while (i > 0 && j > 0) {  // Corrected condition\\n        if (str1[i-1] == str2[j-1]) {\\n            str.push_back(str1[i-1]);\\n            i--;\\n            j--;\\n        }\\n        else if (dp[i][j-1] > dp[i-1][j]) {\\n            str.push_back(str2[j-1]);  // Append character from str2\\n            j--;\\n        }\\n        else {\\n            str.push_back(str1[i-1]);  // Append character from str1\\n            i--;\\n        }\\n    }\\n\\n    while (i > 0) {\\n        str.push_back(str1[i-1]);\\n        i--;\\n    }\\n\\n    while (j > 0) {\\n        str.push_back(str2[j-1]);\\n        j--;\\n    }\\n\\n    reverse(str.begin(), str.end());\\n\\n    return str;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     \\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n=str1.length();\\n        int m=str2.length();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0||j==0){\\n                    dp[i][j]=0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                \\n                if(str1[i-1]==str2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n\\n        // int i=n;\\n        // int j=m;\\n        // string str=\"\";\\n        // while(i!=0&&j!=0){\\n        //     if(str1[i-1]==str[j-1]){\\n        //         str.push_back(str1[i-1]);\\n        //         i--;\\n        //         j--;\\n        //     }\\n        //     else if(dp[i][j-1] > dp[i-1][j]){\\n        //         j--;\\n        //     }\\n        //     else{\\n        //         i--;\\n        //     }\\n        // }\\n        // reverse(str.begin(),str.end());\\n         \\n        // string modified=str1;\\n\\n        // for(int i=0;i<n+1;i++){\\n        //     for(int j=0;j<str.length();j++){\\n        //         if(str[j]==modified[i]){\\n        //             modified.erase(i,1);\\n        //             break;\\n        //         }\\n        //     }\\n\\n        // }\\n\\n        // string result=modified+str2;\\n\\n        // return result;\\n         int i = n;\\n    int j = m;\\n    string str = \"\";\\n    while (i > 0 && j > 0) {  // Corrected condition\\n        if (str1[i-1] == str2[j-1]) {\\n            str.push_back(str1[i-1]);\\n            i--;\\n            j--;\\n        }\\n        else if (dp[i][j-1] > dp[i-1][j]) {\\n            str.push_back(str2[j-1]);  // Append character from str2\\n            j--;\\n        }\\n        else {\\n            str.push_back(str1[i-1]);  // Append character from str1\\n            i--;\\n        }\\n    }\\n\\n    while (i > 0) {\\n        str.push_back(str1[i-1]);\\n        i--;\\n    }\\n\\n    while (j > 0) {\\n        str.push_back(str2[j-1]);\\n        j--;\\n    }\\n\\n    reverse(str.begin(), str.end());\\n\\n    return str;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618607,
                "title": "best-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string X, string Y) {\\n        int n= X.size();\\n        int m= Y.size();\\n\\n        int t[n+1][m+1];\\n\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0 || j==0)\\n                    t[i][j]=0;\\n            }\\n        }\\n\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(X[i-1]==Y[j-1])\\n                    t[i][j]=1+t[i-1][j-1];\\n                else\\n                    t[i][j]=max(t[i-1][j],t[i][j-1]);\\n            }\\n        }\\n\\n    int i=n,j=m;\\n    string scs=\"\";\\n    while(i>0 && j> 0){\\n        if(X[i-1]==Y[j-1]){\\n            scs.push_back(X[i-1]);\\n            i--;\\n            j--;\\n        }\\n        else{\\n            if(t[i-1][j]<t[i][j-1]){\\n                scs.push_back(Y[j-1]);\\n                j--;\\n            }\\n            else{\\n                scs.push_back(X[i-1]);\\n                i--;\\n            }\\n        }\\n    }\\n    while(i>0){\\n        scs.push_back(X[i-1]);\\n        i--;\\n    }\\n    while(j>0){\\n        scs.push_back(Y[j-1]);\\n        j--;\\n    }\\n\\n    reverse(scs.begin(),scs.end());\\n\\n    return scs;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string X, string Y) {\\n        int n= X.size();\\n        int m= Y.size();\\n\\n        int t[n+1][m+1];\\n\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0 || j==0)\\n                    t[i][j]=0;\\n            }\\n        }\\n\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(X[i-1]==Y[j-1])\\n                    t[i][j]=1+t[i-1][j-1];\\n                else\\n                    t[i][j]=max(t[i-1][j],t[i][j-1]);\\n            }\\n        }\\n\\n    int i=n,j=m;\\n    string scs=\"\";\\n    while(i>0 && j> 0){\\n        if(X[i-1]==Y[j-1]){\\n            scs.push_back(X[i-1]);\\n            i--;\\n            j--;\\n        }\\n        else{\\n            if(t[i-1][j]<t[i][j-1]){\\n                scs.push_back(Y[j-1]);\\n                j--;\\n            }\\n            else{\\n                scs.push_back(X[i-1]);\\n                i--;\\n            }\\n        }\\n    }\\n    while(i>0){\\n        scs.push_back(X[i-1]);\\n        i--;\\n    }\\n    while(j>0){\\n        scs.push_back(Y[j-1]);\\n        j--;\\n    }\\n\\n    reverse(scs.begin(),scs.end());\\n\\n    return scs;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557591,
                "title": "c-lcs-tabulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans =\"\";\\n        vector<vector<int>>dp(str1.length()+1,vector<int>(str2.length()+1,-1));\\n        for(int i=0;i<=str1.length();i++){\\n            dp[i][0]=0;\\n        }\\n        for(int i=0;i<=str2.length();i++){\\n            dp[0][i]=0;\\n        }\\n        for(int i=1;i<=str1.length();i++){\\n            for(int j=1;j<=str2.length();j++){\\n                if(str1[i-1]==str2[j-1]){\\n                dp[i][j]= 1 + dp[i-1][j-1];\\n        }\\n        else {\\n            int x = dp[i-1][j];\\n            int y = dp[i][j-1];\\n            dp[i][j]=max(x,y);\\n        }\\n        }\\n        }\\n        int i = str1.length(),j = str2.length();\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                ans.append(1,str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                int x = dp[i-1][j];\\n                int y = dp[i][j-1];\\n                if(x>y){\\n                    ans.append(1,str1[i-1]);\\n                    i--;\\n                }\\n                else{\\n                    ans.append(1,str2[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        while(j>0){\\n             ans.append(1,str2[j-1]);\\n             j--;\\n        }\\n        while(i>0){\\n             ans.append(1,str1[i-1]);\\n             i--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans =\"\";\\n        vector<vector<int>>dp(str1.length()+1,vector<int>(str2.length()+1,-1));\\n        for(int i=0;i<=str1.length();i++){\\n            dp[i][0]=0;\\n        }\\n        for(int i=0;i<=str2.length();i++){\\n            dp[0][i]=0;\\n        }\\n        for(int i=1;i<=str1.length();i++){\\n            for(int j=1;j<=str2.length();j++){\\n                if(str1[i-1]==str2[j-1]){\\n                dp[i][j]= 1 + dp[i-1][j-1];\\n        }\\n        else {\\n            int x = dp[i-1][j];\\n            int y = dp[i][j-1];\\n            dp[i][j]=max(x,y);\\n        }\\n        }\\n        }\\n        int i = str1.length(),j = str2.length();\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                ans.append(1,str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                int x = dp[i-1][j];\\n                int y = dp[i][j-1];\\n                if(x>y){\\n                    ans.append(1,str1[i-1]);\\n                    i--;\\n                }\\n                else{\\n                    ans.append(1,str2[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        while(j>0){\\n             ans.append(1,str2[j-1]);\\n             j--;\\n        }\\n        while(i>0){\\n             ans.append(1,str1[i-1]);\\n             i--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224227,
                "title": "detailed-solution-inspired-by-aditya-verma-simple-solution-with-explanantion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is yet another variation of the LCS( Longest common subsequence) Category of problems . \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n<h2>Step 1</h2>\\n If you don\\'t Know about LCS ( Longest common Subsequence ) then you should watch the videos of Aditya verma and first learn how to find and print the LCS. \\n\\n<h2>Step 2</h2>\\nFind LCS and then just print the shortest common subsequence like LCS , just one thing to keep in mind is that while checking for maximum value just print the left over value .\\n\\n\\n# Complexity\\n- Time complexity:\\n O(n) \\nn=max(str1.size(),str2.size()); \\n\\n- Space complexity:\\n  O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint t[1001][1001];\\n\\n\\n//Code for Longest common subsequence\\nint LCS(string &s,string &r,int n,int m)\\n{\\n  if(n==0||m==0){\\n  \\treturn 0;\\n  }\\n  else if(t[n][m]!=-1){\\n  \\treturn t[n][m];\\n  }\\n  else if(s[n-1]==r[m-1]){\\n  \\treturn t[n][m]=LCS(s,r,n-1,m-1)+1;\\n  }\\n  else{\\n    return t[n][m]=max(LCS(s,r,n-1,m),LCS(s,r,n,m-1));\\n  }\\n\\n}\\nstring shortestCommonSupersequence(string s, string r) {\\n\\nmemset(t,-1,sizeof(t));\\n\\n\\nint i=s.size();\\nint j=r.size();\\n\\nif(i==0){\\n    return r;\\n}\\nif(j==0){\\n    return s;\\n}\\n\\n//Fining the longest common subsequence \\nint x=LCS(s,r,i,j);\\n\\n//Printing Shortest common supersequence\\nstring v;\\nwhile(i>0&&j>0){\\n  if(s[i-1]==r[j-1]){\\n   v.push_back(s[i-1]);\\n   i--;j--;\\n  }else{\\n    if(t[i-1][j]>t[i][j-1]){\\n       v.push_back(s[i-1]);\\n       i--;\\n    }else{\\n      v.push_back(r[j-1]);\\n      j--;\\n    }\\n  }         \\n}\\n\\n//Considering \"if Left\" values\\nwhile(i>0){\\n  v.push_back(s[i-1]);i--;\\n}\\nwhile(j>0){\\n  v.push_back(r[j-1]);j--;\\n}\\n\\n//Reversing string because I iterated from end !\\nreverse(v.begin(),v.end());\\n\\nreturn v;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint t[1001][1001];\\n\\n\\n//Code for Longest common subsequence\\nint LCS(string &s,string &r,int n,int m)\\n{\\n  if(n==0||m==0){\\n  \\treturn 0;\\n  }\\n  else if(t[n][m]!=-1){\\n  \\treturn t[n][m];\\n  }\\n  else if(s[n-1]==r[m-1]){\\n  \\treturn t[n][m]=LCS(s,r,n-1,m-1)+1;\\n  }\\n  else{\\n    return t[n][m]=max(LCS(s,r,n-1,m),LCS(s,r,n,m-1));\\n  }\\n\\n}\\nstring shortestCommonSupersequence(string s, string r) {\\n\\nmemset(t,-1,sizeof(t));\\n\\n\\nint i=s.size();\\nint j=r.size();\\n\\nif(i==0){\\n    return r;\\n}\\nif(j==0){\\n    return s;\\n}\\n\\n//Fining the longest common subsequence \\nint x=LCS(s,r,i,j);\\n\\n//Printing Shortest common supersequence\\nstring v;\\nwhile(i>0&&j>0){\\n  if(s[i-1]==r[j-1]){\\n   v.push_back(s[i-1]);\\n   i--;j--;\\n  }else{\\n    if(t[i-1][j]>t[i][j-1]){\\n       v.push_back(s[i-1]);\\n       i--;\\n    }else{\\n      v.push_back(r[j-1]);\\n      j--;\\n    }\\n  }         \\n}\\n\\n//Considering \"if Left\" values\\nwhile(i>0){\\n  v.push_back(s[i-1]);i--;\\n}\\nwhile(j>0){\\n  v.push_back(r[j-1]);j--;\\n}\\n\\n//Reversing string because I iterated from end !\\nreverse(v.begin(),v.end());\\n\\nreturn v;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207644,
                "title": "lcs-navigation",
                "content": "# Intuition\\n\\nCalculate the LCS, based on that use the smallest path to match both strings but think of adding characters instead of deleting them.\\n\\n# Approach\\n- LCS\\n- Matrix Navigation\\n\\n# Complexity\\n- Time complexity:\\n$$O(str1.length*str2.length)$$\\n\\n- Space complexity:\\n$$O(str1.length*str2.length)$$\\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/e2409089-341e-4dad-a9d5-95fb85e67c58_1676845676.1123145.png)\\n\\n```java\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int[][] memo=new int[str1.length()+1][str2.length()+1];\\n        for(int i=memo.length-1;i>-1;i--) memo[i][memo[0].length-1]=memo.length-1-i;\\n        for(int i=memo[0].length-1;i>-1;i--) memo[memo.length-1][i]=memo[0].length-1-i;\\n        for(int i=str1.length()-1;i>-1;i--) {\\n            int[] m=memo[i], mPrev=memo[i+1];\\n            for(int j=str2.length()-1;j>-1;j--) {\\n                if(str1.charAt(i)==str2.charAt(j)) m[j]=mPrev[j+1];\\n                else m[j]=Math.min(m[j+1],mPrev[j])+1;\\n            }\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        int x=0,y=0;\\n        while(x<str1.length()||y<str2.length()) {\\n            if(x==str1.length()) {\\n                sb.append(str2.charAt(y));\\n                y=y+1;\\n            } else if(y==str2.length()) {\\n                sb.append(str1.charAt(x));\\n                x=x+1;\\n            } else if(str1.charAt(x)==str2.charAt(y)) {\\n                sb.append(str2.charAt(y));\\n                x=x+1;\\n                y=y+1;\\n            } else if(memo[x][y+1]<memo[x+1][y]) {\\n                sb.append(str2.charAt(y));\\n                y=y+1;\\n            } else {\\n                sb.append(str1.charAt(x));\\n                x=x+1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int[][] memo=new int[str1.length()+1][str2.length()+1];\\n        for(int i=memo.length-1;i>-1;i--) memo[i][memo[0].length-1]=memo.length-1-i;\\n        for(int i=memo[0].length-1;i>-1;i--) memo[memo.length-1][i]=memo[0].length-1-i;\\n        for(int i=str1.length()-1;i>-1;i--) {\\n            int[] m=memo[i], mPrev=memo[i+1];\\n            for(int j=str2.length()-1;j>-1;j--) {\\n                if(str1.charAt(i)==str2.charAt(j)) m[j]=mPrev[j+1];\\n                else m[j]=Math.min(m[j+1],mPrev[j])+1;\\n            }\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        int x=0,y=0;\\n        while(x<str1.length()||y<str2.length()) {\\n            if(x==str1.length()) {\\n                sb.append(str2.charAt(y));\\n                y=y+1;\\n            } else if(y==str2.length()) {\\n                sb.append(str1.charAt(x));\\n                x=x+1;\\n            } else if(str1.charAt(x)==str2.charAt(y)) {\\n                sb.append(str2.charAt(y));\\n                x=x+1;\\n                y=y+1;\\n            } else if(memo[x][y+1]<memo[x+1][y]) {\\n                sb.append(str2.charAt(y));\\n                y=y+1;\\n            } else {\\n                sb.append(str1.charAt(x));\\n                x=x+1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066847,
                "title": "java-dp-solution-similar-to-lcs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int[][] dp=new int[str1.length()+1][str2.length()+1];\\n        for(int i=1;i<str1.length()+1;i++){\\n            for(int j=1;j<str2.length()+1;j++){\\n                if(str1.charAt(i-1)==str2.charAt(j-1)){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j]);\\n                }\\n            }\\n        }\\n       int i=str1.length(),j=str2.length();\\n        String res=\"\";\\n        while(i>0 && j>0){\\n            if(str1.charAt(i-1)==str2.charAt(j-1)){\\n                res=str1.charAt(i-1)+res;\\n                i--;\\n                j--;\\n            }else if(dp[i-1][j]>dp[i][j-1]){\\n                res=str1.charAt(i-1)+res;\\n                i--;\\n            }else{\\n                res=str2.charAt(j-1)+res;\\n                j--;\\n            }\\n        }\\n        while(i>0){\\n            res=str1.charAt(i-1)+res;\\n            i--;\\n        }\\n        while(j>0){\\n            res=str2.charAt(j-1)+res;\\n            j--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int[][] dp=new int[str1.length()+1][str2.length()+1];\\n        for(int i=1;i<str1.length()+1;i++){\\n            for(int j=1;j<str2.length()+1;j++){\\n                if(str1.charAt(i-1)==str2.charAt(j-1)){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j]);\\n                }\\n            }\\n        }\\n       int i=str1.length(),j=str2.length();\\n        String res=\"\";\\n        while(i>0 && j>0){\\n            if(str1.charAt(i-1)==str2.charAt(j-1)){\\n                res=str1.charAt(i-1)+res;\\n                i--;\\n                j--;\\n            }else if(dp[i-1][j]>dp[i][j-1]){\\n                res=str1.charAt(i-1)+res;\\n                i--;\\n            }else{\\n                res=str2.charAt(j-1)+res;\\n                j--;\\n            }\\n        }\\n        while(i>0){\\n            res=str1.charAt(i-1)+res;\\n            i--;\\n        }\\n        while(j>0){\\n            res=str2.charAt(j-1)+res;\\n            j--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022284,
                "title": "similar-to-printing-the-lcs",
                "content": "how i thought:\\nthe scs always has lcs in it --> i can get the get the lcs from the tabulation matrix -> need to somehow get the scs.\\n\\nsteps:\\nget tabulation matrix from lcs method -> traverse the matrix to build the lcs like you would normally do, but this time append every time to the ans string -> then put the remaning characters in the ans string.\\n# Code\\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int t[][] = lcs(str1,str2);\\n        StringBuilder ans = new StringBuilder();\\n        int i = str1.length(),j=str2.length();\\n        while(i>0 && j>0){\\n            if(str1.charAt(i-1) == str2.charAt(j-1)){\\n                ans.append(str1.charAt(i-1));\\n                i--;j--;\\n            }else if(t[i-1][j]>=t[i][j-1]){\\n                ans.append(str1.charAt(i-1));\\n                i--;\\n            }else{\\n                ans.append(str2.charAt(j-1));\\n                j--;\\n            }\\n        }\\n        while(i>0){\\n            ans.append(str1.charAt(i-1));\\n            i--;\\n        }\\n        while(j>0){\\n            ans.append(str2.charAt(j-1));\\n            j--;\\n        }\\n        return ans.reverse()+\"\";\\n    }\\n    public static int[][] lcs(String s1, String s2){\\n        int t[][] = new int[s1.length()+1][s2.length()+1];\\n        for(int i = 1;i<s1.length()+1;i++){\\n            for(int j = 1;j<s2.length()+1;j++){\\n                if(s1.charAt(i-1) == s2.charAt(j-1)){\\n                    t[i][j] = t[i-1][j-1]+1;\\n                }else{\\n                    int ans1 = t[i-1][j];\\n                    int ans2 = t[i][j-1];\\n                    t[i][j] = Math.max(ans1, ans2);\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int t[][] = lcs(str1,str2);\\n        StringBuilder ans = new StringBuilder();\\n        int i = str1.length(),j=str2.length();\\n        while(i>0 && j>0){\\n            if(str1.charAt(i-1) == str2.charAt(j-1)){\\n                ans.append(str1.charAt(i-1));\\n                i--;j--;\\n            }else if(t[i-1][j]>=t[i][j-1]){\\n                ans.append(str1.charAt(i-1));\\n                i--;\\n            }else{\\n                ans.append(str2.charAt(j-1));\\n                j--;\\n            }\\n        }\\n        while(i>0){\\n            ans.append(str1.charAt(i-1));\\n            i--;\\n        }\\n        while(j>0){\\n            ans.append(str2.charAt(j-1));\\n            j--;\\n        }\\n        return ans.reverse()+\"\";\\n    }\\n    public static int[][] lcs(String s1, String s2){\\n        int t[][] = new int[s1.length()+1][s2.length()+1];\\n        for(int i = 1;i<s1.length()+1;i++){\\n            for(int j = 1;j<s2.length()+1;j++){\\n                if(s1.charAt(i-1) == s2.charAt(j-1)){\\n                    t[i][j] = t[i-1][j-1]+1;\\n                }else{\\n                    int ans1 = t[i-1][j];\\n                    int ans2 = t[i][j-1];\\n                    t[i][j] = Math.max(ans1, ans2);\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945115,
                "title": "easy-cpp-using-lcs-dp-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing LCS\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)//size of the 2 strings\\n\\n- Space complexity:\\nO(m*n)//size of the 2 strings\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string t1, string t2) {\\n       vector<vector<int>> dp(t1.size()+1,vector<int> (t2.size()+1,0));\\n        \\n        for(int i=1;i<t1.size()+1;i++){\\n            for(int j=1;j<=t2.size();j++){\\n                if(t1[i-1]==t2[j-1])dp[i][j]=1+dp[i-1][j-1];\\n                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        \\n        int i=t1.size(),j=t2.size();\\n        string s=\"\";\\n        while(i>0 && j>0){\\n            if(t1[i-1]==t2[j-1]){\\n                s+=t1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else if(dp[i-1][j]>dp[i][j-1]){\\n                s+=t1[i-1];\\n                i--;\\n                \\n            }\\n            else {\\n                s+=t2[j-1];\\n                j--;\\n            }\\n        }\\n        \\n         while(i>0){\\n             s+=t1[i-1];\\n             i--;\\n         }\\n        while(j>0){\\n             s+=t2[j-1];\\n            j--;\\n         }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string t1, string t2) {\\n       vector<vector<int>> dp(t1.size()+1,vector<int> (t2.size()+1,0));\\n        \\n        for(int i=1;i<t1.size()+1;i++){\\n            for(int j=1;j<=t2.size();j++){\\n                if(t1[i-1]==t2[j-1])dp[i][j]=1+dp[i-1][j-1];\\n                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        \\n        int i=t1.size(),j=t2.size();\\n        string s=\"\";\\n        while(i>0 && j>0){\\n            if(t1[i-1]==t2[j-1]){\\n                s+=t1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else if(dp[i-1][j]>dp[i][j-1]){\\n                s+=t1[i-1];\\n                i--;\\n                \\n            }\\n            else {\\n                s+=t2[j-1];\\n                j--;\\n            }\\n        }\\n        \\n         while(i>0){\\n             s+=t1[i-1];\\n             i--;\\n         }\\n        while(j>0){\\n             s+=t2[j-1];\\n            j--;\\n         }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777802,
                "title": "c-lcs-dp",
                "content": "**Code1** \\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        // length of shortst common supersequence will be len(str1)+len(str2)-len(lcs)\\n        int m=str1.size();\\n        int n=str2.size();\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,0)); // for lcs \\n        for(int i=1;i<m+1;i++)\\n        {\\n            for(int j=1;j<n+1;j++)\\n            {\\n                if(str1[i-1]==str2[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else \\n                {\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        // lcs length is in dp[m][n] \\n        string s=\"\";\\n        int i=m,j=n;\\n        while(i>0 && j>0)\\n        {\\n            if(str1[i-1]==str2[j-1])\\n            {\\n                s=str1[i-1]+s;\\n                i--,j--;\\n            }\\n            else \\n            {\\n                if(dp[i][j-1]>dp[i-1][j])\\n                {\\n                    s=str2[j-1]+s;\\n                    j--;\\n                }\\n                else\\n                {\\n                    s=str1[i-1]+s;\\n                    i--;\\n                }\\n            }\\n        }\\n        while(i>0)\\n        {\\n            s=str1[i-1]+s;\\n            i--;\\n        }\\n        while(j>0)\\n        {\\n            s=str2[j-1]+s;\\n            j--;\\n        }\\n        // reverse(s.begin(),s.end());  // since character is added at the start of string  \\n        return s;\\n    }\\n};\\n```\\n\\n**Code2**\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        // length of shortst common supersequence will be len(str1)+len(str2)-len(lcs)\\n        int m=str1.size();\\n        int n=str2.size();\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,0)); // for lcs \\n        for(int i=1;i<m+1;i++)\\n        {\\n            for(int j=1;j<n+1;j++)\\n            {\\n                if(str1[i-1]==str2[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else \\n                {\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        // lcs length is in dp[m][n] \\n        string s=\"\";\\n        int i=m,j=n;\\n        while(i>0 && j>0)\\n        {\\n            if(str1[i-1]==str2[j-1])\\n            {\\n                s+=str1[i-1];\\n                i--,j--;\\n            }\\n            else \\n            {\\n                if(dp[i][j-1]>dp[i-1][j])\\n                {\\n                    s+=str2[j-1];\\n                    j--;\\n                }\\n                else\\n                {\\n                    s+=str1[i-1];\\n                    i--;\\n                }\\n            }\\n        }\\n        while(i>0)\\n        {\\n            s+=str1[i-1];\\n            i--;\\n        }\\n        while(j>0)\\n        {\\n            s+=str2[j-1];\\n            j--;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        // length of shortst common supersequence will be len(str1)+len(str2)-len(lcs)\\n        int m=str1.size();\\n        int n=str2.size();\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,0)); // for lcs \\n        for(int i=1;i<m+1;i++)\\n        {\\n            for(int j=1;j<n+1;j++)\\n            {\\n                if(str1[i-1]==str2[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else \\n                {\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        // lcs length is in dp[m][n] \\n        string s=\"\";\\n        int i=m,j=n;\\n        while(i>0 && j>0)\\n        {\\n            if(str1[i-1]==str2[j-1])\\n            {\\n                s=str1[i-1]+s;\\n                i--,j--;\\n            }\\n            else \\n            {\\n                if(dp[i][j-1]>dp[i-1][j])\\n                {\\n                    s=str2[j-1]+s;\\n                    j--;\\n                }\\n                else\\n                {\\n                    s=str1[i-1]+s;\\n                    i--;\\n                }\\n            }\\n        }\\n        while(i>0)\\n        {\\n            s=str1[i-1]+s;\\n            i--;\\n        }\\n        while(j>0)\\n        {\\n            s=str2[j-1]+s;\\n            j--;\\n        }\\n        // reverse(s.begin(),s.end());  // since character is added at the start of string  \\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        // length of shortst common supersequence will be len(str1)+len(str2)-len(lcs)\\n        int m=str1.size();\\n        int n=str2.size();\\n        vector<vector<int>>dp(m+1,vector<int>(n+1,0)); // for lcs \\n        for(int i=1;i<m+1;i++)\\n        {\\n            for(int j=1;j<n+1;j++)\\n            {\\n                if(str1[i-1]==str2[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else \\n                {\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        // lcs length is in dp[m][n] \\n        string s=\"\";\\n        int i=m,j=n;\\n        while(i>0 && j>0)\\n        {\\n            if(str1[i-1]==str2[j-1])\\n            {\\n                s+=str1[i-1];\\n                i--,j--;\\n            }\\n            else \\n            {\\n                if(dp[i][j-1]>dp[i-1][j])\\n                {\\n                    s+=str2[j-1];\\n                    j--;\\n                }\\n                else\\n                {\\n                    s+=str1[i-1];\\n                    i--;\\n                }\\n            }\\n        }\\n        while(i>0)\\n        {\\n            s+=str1[i-1];\\n            i--;\\n        }\\n        while(j>0)\\n        {\\n            s+=str2[j-1];\\n            j--;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584944,
                "title": "top-down-approach-dp-solution-with-print-length-of-scs",
                "content": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        def lcs(x,y,n,m):\\n\\n            #creating martix of n+1 and m+1\\n            dp = [[-1 for _ in range(len(y)+1)] for _ in range(len(x)+1)]\\n\\n            for i in range(n+1):\\n                for j in range(m+1):\\n                    if i == 0 or j == 0:\\n                        dp[i][j] = 0\\n                    elif x[i-1] == y[j-1]:\\n                        dp[i][j] = 1 + dp[i-1][j-1]\\n                    else:\\n                        dp[i][j] = max(dp[i-1][j],dp[i][j-1])\\n\\n            # return (m+n-dp[-1][-1])\\n            # to print shortest common subsequence uncomment 17th line and comment out below code\\n            \\n#             code to print shortest common subsequence\\n            i = n\\n            j = m\\n            s = \"\"\\n\\n        #     when i and j both have values in it \\n            while i>0 and j>0:\\n                if x[i-1] == y[j-1]:\\n                    s+=x[i-1]\\n                    i-=1\\n                    j-=1\\n                elif dp[i][j-1]>dp[i-1][j]:\\n                    s+=y[j-1]\\n                    j-=1\\n                else:\\n                    s+=x[i-1]\\n                    i-=1\\n\\n        #     when j has no values but i have \\n            while i>0:\\n                s+=x[i-1]\\n                i-=1\\n\\n        #     when i has no values but j have \\n            while j>0:\\n                s+=y[j-1]\\n                j-=1    \\n\\n            return s[::-1]  \\n        \\n        return lcs(str1,str2,len(str1),len(str2))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\\n        def lcs(x,y,n,m):\\n\\n            #creating martix of n+1 and m+1\\n            dp = [[-1 for _ in range(len(y)+1)] for _ in range(len(x)+1)]\\n\\n            for i in range(n+1):\\n                for j in range(m+1):\\n                    if i == 0 or j == 0:\\n                        dp[i][j] = 0\\n                    elif x[i-1] == y[j-1]:\\n                        dp[i][j] = 1 + dp[i-1][j-1]\\n                    else:\\n                        dp[i][j] = max(dp[i-1][j],dp[i][j-1])\\n\\n            # return (m+n-dp[-1][-1])\\n            # to print shortest common subsequence uncomment 17th line and comment out below code\\n            \\n#             code to print shortest common subsequence\\n            i = n\\n            j = m\\n            s = \"\"\\n\\n        #     when i and j both have values in it \\n            while i>0 and j>0:\\n                if x[i-1] == y[j-1]:\\n                    s+=x[i-1]\\n                    i-=1\\n                    j-=1\\n                elif dp[i][j-1]>dp[i-1][j]:\\n                    s+=y[j-1]\\n                    j-=1\\n                else:\\n                    s+=x[i-1]\\n                    i-=1\\n\\n        #     when j has no values but i have \\n            while i>0:\\n                s+=x[i-1]\\n                i-=1\\n\\n        #     when i has no values but j have \\n            while j>0:\\n                s+=y[j-1]\\n                j-=1    \\n\\n            return s[::-1]  \\n        \\n        return lcs(str1,str2,len(str1),len(str2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552426,
                "title": "2d-dp",
                "content": "```cpp\\nclass Solution {\\n   public:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.size();\\n        int m = str2.size();\\n        int dp[n + 1][m + 1];\\n        memset(dp, 65, sizeof dp);\\n        for (int i = 0; i <= n; i++) dp[i][m] = n - i;\\n        for (int j = 0; j <= m; j++) dp[n][j] = m - j;\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                if (str1[i] == str2[j]) {\\n                    dp[i][j] = 1 + dp[i + 1][j + 1];\\n                } else {\\n                    // push ith char or jth char\\n                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j + 1]);\\n                }\\n            }\\n        }\\n        int i = 0, j = 0;\\n        string ans;\\n        while (true) {\\n            if (i == n) {\\n                ans += str2.substr(j);\\n                break;\\n            }\\n            if (j == m) {\\n                ans += str1.substr(i);\\n                break;\\n            }\\n            if (str1[i] == str2[j]) {\\n                ans.push_back(str1[i]);\\n                i++;\\n                j++;\\n            } else if (dp[i + 1][j] < dp[i][j + 1]) {\\n                ans.push_back(str1[i]);\\n                i++;\\n            } else {\\n                ans.push_back(str2[j]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n   public:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.size();\\n        int m = str2.size();\\n        int dp[n + 1][m + 1];\\n        memset(dp, 65, sizeof dp);\\n        for (int i = 0; i <= n; i++) dp[i][m] = n - i;\\n        for (int j = 0; j <= m; j++) dp[n][j] = m - j;\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                if (str1[i] == str2[j]) {\\n                    dp[i][j] = 1 + dp[i + 1][j + 1];\\n                } else {\\n                    // push ith char or jth char\\n                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j + 1]);\\n                }\\n            }\\n        }\\n        int i = 0, j = 0;\\n        string ans;\\n        while (true) {\\n            if (i == n) {\\n                ans += str2.substr(j);\\n                break;\\n            }\\n            if (j == m) {\\n                ans += str1.substr(i);\\n                break;\\n            }\\n            if (str1[i] == str2[j]) {\\n                ans.push_back(str1[i]);\\n                i++;\\n                j++;\\n            } else if (dp[i + 1][j] < dp[i][j + 1]) {\\n                ans.push_back(str1[i]);\\n                i++;\\n            } else {\\n                ans.push_back(str2[j]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512134,
                "title": "simple-memoization-code-c",
                "content": "```\\n string shortestCommonSupersequence(string s1, string s2) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=0;\\n            \\n        }\\n        for(int i=0;i<=m;i++){\\n            dp[0][i]=0;\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        int len=dp[n][m];\\n      //  int indx=len-1;\\n        int i=n;\\n        int j=m;\\n        string ans=\"\";\\n        while(i>0 and j>0){\\n            if(s1[i-1]==s2[j-1]){\\n                ans+=s1[i-1];\\n                i--;\\n                j--;\\n                //indx--;\\n            }\\n            else if(dp[i-1][j]>dp[i][j-1]){\\n                ans+=s1[i-1];\\n                i--;\\n               // indx--;\\n            }\\n            else{\\n                ans+=s2[j-1];\\n                j--;\\n               // indx--;\\n            }\\n        }\\n        while(i>0){\\n            ans+=s1[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            ans+=s2[j-1];\\n            j--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n string shortestCommonSupersequence(string s1, string s2) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=0;\\n            \\n        }\\n        for(int i=0;i<=m;i++){\\n            dp[0][i]=0;\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1]==s2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        int len=dp[n][m];\\n      //  int indx=len-1;\\n        int i=n;\\n        int j=m;\\n        string ans=\"\";\\n        while(i>0 and j>0){\\n            if(s1[i-1]==s2[j-1]){\\n                ans+=s1[i-1];\\n                i--;\\n                j--;\\n                //indx--;\\n            }\\n            else if(dp[i-1][j]>dp[i][j-1]){\\n                ans+=s1[i-1];\\n                i--;\\n               // indx--;\\n            }\\n            else{\\n                ans+=s2[j-1];\\n                j--;\\n               // indx--;\\n            }\\n        }\\n        while(i>0){\\n            ans+=s1[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            ans+=s2[j-1];\\n            j--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2507752,
                "title": "java-solution-dp-29-ms-easy-solution-lcs",
                "content": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int n = str1.length();\\n        int m = str2.length();\\n        \\n        int[][] dp = new int[n+1][m+1];\\n        \\n        for(int i=1; i<=n; i++){\\n            for(int j=1; j<=m; j++){\\n                if(str1.charAt(i-1) == str2.charAt(j-1)){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int i=n, j=m;\\n        String res = \"\";\\n        while(i > 0 && j > 0 ){\\n            if(str1.charAt(i-1) == str2.charAt(j-1)){\\n                res+=str1.charAt(i-1);\\n                i--;\\n                j--;\\n            }\\n            else{ \\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    res+= str1.charAt(i-1) ;\\n                    i--;\\n            }   else if(dp[i][j-1] >= dp[i-1][j]) {\\n                    res+=str2.charAt(j-1);\\n                    j--;\\n                } \\n            }\\n        }\\n        while(i > 0){\\n            res+=str1.charAt(i-1);\\n            i--;\\n        }\\n        while(j > 0){\\n            res+=str2.charAt(j-1);\\n            j--;\\n        }\\n        \\n        return new StringBuilder(res).reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int n = str1.length();\\n        int m = str2.length();\\n        \\n        int[][] dp = new int[n+1][m+1];\\n        \\n        for(int i=1; i<=n; i++){\\n            for(int j=1; j<=m; j++){\\n                if(str1.charAt(i-1) == str2.charAt(j-1)){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int i=n, j=m;\\n        String res = \"\";\\n        while(i > 0 && j > 0 ){\\n            if(str1.charAt(i-1) == str2.charAt(j-1)){\\n                res+=str1.charAt(i-1);\\n                i--;\\n                j--;\\n            }\\n            else{ \\n                if(dp[i-1][j] > dp[i][j-1]){\\n                    res+= str1.charAt(i-1) ;\\n                    i--;\\n            }   else if(dp[i][j-1] >= dp[i-1][j]) {\\n                    res+=str2.charAt(j-1);\\n                    j--;\\n                } \\n            }\\n        }\\n        while(i > 0){\\n            res+=str1.charAt(i-1);\\n            i--;\\n        }\\n        while(j > 0){\\n            res+=str2.charAt(j-1);\\n            j--;\\n        }\\n        \\n        return new StringBuilder(res).reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477217,
                "title": "c-logic-explained-easy-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/b3614ef9-5171-4bc2-86e8-99d4c0edbb65_1661412115.5632708.png)\\n\\n***This question is the variation of LCS. If we wolud have to print the length of the supersequence than that would be an easier job but the point that we have to print the exact supersequence makes this a bit tricky but still if we know how to print a subsequence using DP Table than we will be able to do this question.***\\n\\n\\tclass Solution {\\n\\tpublic: \\n\\t\\tstring shortestCommonSupersequence(string s1, string s2) {\\n\\t\\t\\tint n=s1.size(),m=s2.size();\\n\\t//      Creating DP Table\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(m+1,0));  \\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1]==s2[j-1]) dp[i][j]=1+dp[i-1][j-1];\\n\\t\\t\\t\\t\\telse dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t//      Using DP Table    \\n\\t\\t\\tint i=n,j=m;\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\twhile(i>0 && j>0){\\n\\t\\t\\t\\t\\tif(s1[i-1]==s2[j-1]){\\n\\t\\t\\t\\t\\t\\tans+=s1[i-1];\\n\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(dp[i-1][j]>dp[i][j-1]){\\n\\t\\t\\t\\t\\t\\tans+=s1[i-1];\\n\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tans+=s2[j-1];\\n\\t\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}     \\n\\t\\t\\twhile(i>0) ans+=s1[i-1]; i--;  \\n\\t\\t\\twhile(j>0) ans+=s2[j-1]; j--;\\n\\t\\t\\treverse(ans.begin(),ans.end());\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic: \\n\\t\\tstring shortestCommonSupersequence(string s1, string s2) {\\n\\t\\t\\tint n=s1.size(),m=s2.size();\\n\\t//      Creating DP Table\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(m+1,0));  \\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1]==s2[j-1]) dp[i][j]=1+dp[i-1][j-1];\\n\\t\\t\\t\\t\\telse dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2462074,
                "title": "c-easy-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string text1, string text2) {\\n        int n= text1.size();\\n        int m=text2.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=0;\\n        for(int j=0;j<=m;j++)\\n            dp[0][j]=0;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(text1[i-1]==text2[j-1])\\n                     dp[i][j]= 1 + dp[i-1][j-1];\\n                else\\n                     dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        string ans=\"\";\\n        int i=n;\\n        int j=m;\\n        while(i>0 && j>0){\\n            if(text1[i-1]==text2[j-1]){\\n                ans+=text1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else if(dp[i-1][j]>dp[i][j-1]){\\n                ans+=text1[i-1];\\n                i--;\\n            }\\n            else{\\n                ans+=text2[j-1];\\n                j--;\\n            }\\n        }\\n        while(i>0){\\n            ans+=text1[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            ans+=text2[j-1];\\n            j--;\\n        }\\n        reverse (ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    string shortestCommonSupersequence(string text1, string text2) {\\n        int n= text1.size();\\n        int m=text2.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=0;\\n        for(int j=0;j<=m;j++)\\n            dp[0][j]=0;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(text1[i-1]==text2[j-1])\\n                     dp[i][j]= 1 + dp[i-1][j-1];\\n                else\\n                     dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2443615,
                "title": "simple-java-solution-using-top-down-dp",
                "content": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) \\n    {\\n        int m= str1.length(), n = str2.length();\\n        int dp[][] = new int[m+1][n+1];\\n        \\n        \\n        for(int i=0; i < m+1; i++) // Initializing dp matrix\\n        {\\n            for(int j=0; j < n+1; j++)\\n            {    \\n                if(i ==0 || j==0)\\n                {\\n                    dp[i][j] =0;\\n                    continue;\\n                }\\n                \\n                if(str1.charAt(i-1) == str2.charAt(j-1))\\n                    dp[i][j] = 1+ dp[i-1][j-1];\\n                \\n                else\\n                    dp[i][j] = Math.max(dp[i-1][j] , dp[i][j-1]);\\n            }\\n            \\n        }\\n        \\n        //Getting String now\\n        String result = \"\";\\n        \\n        while(m > 0 && n > 0)\\n        {\\n            if(str1.charAt(m-1) == str2.charAt(n-1))\\n            {\\n                result = result + str1.charAt(m-1);\\n                m--;\\n                n--;\\n            }\\n            \\n            else\\n            {\\n                if(dp[m-1][n] > dp[m][n-1])\\n                {\\n                    result = result + str1.charAt(m-1);\\n                    m--;\\n                }\\n                else\\n                {\\n                    result = result + str2.charAt(n-1);\\n                    n--;\\n                }\\n            }\\n        }\\n        \\n        while(m > 0)\\n        {\\n            result = result + str1.charAt(m-1);\\n            m--;\\n        }\\n        \\n        while(n>0)\\n        {\\n            result = result + str2.charAt(n-1);\\n            n--;\\n        }\\n        \\n        String final_result = reverse(result);\\n        return final_result;\\n        \\n        \\n    }\\n    \\n    private String reverse(String s)\\n    {\\n        String w = \"\";\\n        \\n        for(int i=0; i<s.length();i++)\\n        {\\n            char ch =s.charAt(i);\\n            w=ch+w;\\n        }\\n        return w;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) \\n    {\\n        int m= str1.length(), n = str2.length();\\n        int dp[][] = new int[m+1][n+1];\\n        \\n        \\n        for(int i=0; i < m+1; i++) // Initializing dp matrix\\n        {\\n            for(int j=0; j < n+1; j++)\\n            {    \\n                if(i ==0 || j==0)\\n                {\\n                    dp[i][j] =0;\\n                    continue;\\n                }\\n                \\n                if(str1.charAt(i-1) == str2.charAt(j-1))\\n                    dp[i][j] = 1+ dp[i-1][j-1];\\n                \\n                else\\n                    dp[i][j] = Math.max(dp[i-1][j] , dp[i][j-1]);\\n            }\\n            \\n        }\\n        \\n        //Getting String now\\n        String result = \"\";\\n        \\n        while(m > 0 && n > 0)\\n        {\\n            if(str1.charAt(m-1) == str2.charAt(n-1))\\n            {\\n                result = result + str1.charAt(m-1);\\n                m--;\\n                n--;\\n            }\\n            \\n            else\\n            {\\n                if(dp[m-1][n] > dp[m][n-1])\\n                {\\n                    result = result + str1.charAt(m-1);\\n                    m--;\\n                }\\n                else\\n                {\\n                    result = result + str2.charAt(n-1);\\n                    n--;\\n                }\\n            }\\n        }\\n        \\n        while(m > 0)\\n        {\\n            result = result + str1.charAt(m-1);\\n            m--;\\n        }\\n        \\n        while(n>0)\\n        {\\n            result = result + str2.charAt(n-1);\\n            n--;\\n        }\\n        \\n        String final_result = reverse(result);\\n        return final_result;\\n        \\n        \\n    }\\n    \\n    private String reverse(String s)\\n    {\\n        String w = \"\";\\n        \\n        for(int i=0; i<s.length();i++)\\n        {\\n            char ch =s.charAt(i);\\n            w=ch+w;\\n        }\\n        return w;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442777,
                "title": "striver-lcs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s, string t) {\\n        int ind1 = s.size();\\n        int ind2 = t.size();\\n        vector<vector<int>> dp(ind1+1,vector<int>(ind2+1,0));\\n        for(int i=0;i<=ind1;i++) dp[i][0]=0;\\n        for(int j=0;j<=ind2;j++) dp[0][j]=0;\\n\\n        for(int i=1;i<=ind1;i++){\\n            for(int j=1;j<=ind2;j++){\\n                if(s[i-1]==t[j-1]) dp[i][j] = 1+dp[i-1][j-1];\\n                else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n\\n        int i=ind1,j=ind2;\\n        string ans = \"\";\\n        while(i>0 and j>0){\\n            if(s[i-1]==t[j-1]){\\n                ans+=s[i-1];\\n                i--;\\n                j--;\\n            }\\n            else if(dp[i-1][j]>dp[i][j-1]){\\n                ans+=s[i-1];\\n                i--;\\n            }\\n            else{\\n                ans+=t[j-1];\\n                j--;\\n            }\\n        }\\n        while(i>0) {ans+=s[i-1];i--;}\\n        while(j>0) {ans+=t[j-1];j--;}\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s, string t) {\\n        int ind1 = s.size();\\n        int ind2 = t.size();\\n        vector<vector<int>> dp(ind1+1,vector<int>(ind2+1,0));\\n        for(int i=0;i<=ind1;i++) dp[i][0]=0;\\n        for(int j=0;j<=ind2;j++) dp[0][j]=0;\\n\\n        for(int i=1;i<=ind1;i++){\\n            for(int j=1;j<=ind2;j++){\\n                if(s[i-1]==t[j-1]) dp[i][j] = 1+dp[i-1][j-1];\\n                else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n\\n        int i=ind1,j=ind2;\\n        string ans = \"\";\\n        while(i>0 and j>0){\\n            if(s[i-1]==t[j-1]){\\n                ans+=s[i-1];\\n                i--;\\n                j--;\\n            }\\n            else if(dp[i-1][j]>dp[i][j-1]){\\n                ans+=s[i-1];\\n                i--;\\n            }\\n            else{\\n                ans+=t[j-1];\\n                j--;\\n            }\\n        }\\n        while(i>0) {ans+=s[i-1];i--;}\\n        while(j>0) {ans+=t[j-1];j--;}\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411257,
                "title": "c-dp-solution",
                "content": "```\\n string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.length();\\n        int m = str2.length();\\n        vector<vector<int>>dp(n+1, vector<int>(m+1, 0));\\n        for(int i=0; i<=n; i++)\\n            dp[i][0] = 0;\\n        for(int j=0; j<=m; j++)\\n            dp[0][j] = 0;\\n        for(int ind1 = 1; ind1<=n; ind1++)\\n        {\\n            for(int ind2 = 1; ind2 <= m; ind2++)\\n            {\\n                if(str1[ind1-1] == str2[ind2-1])\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                else\\n                    dp[ind1][ind2] = 0 + max(dp[ind1-1][ind2], dp[ind1][ind2-1]);\\n            }\\n        }\\n        int i=n, j=m;\\n        string ans = \"\";\\n        while(i>0 && j>0){\\n            if(str1[i-1] == str2[j-1]){\\n                ans += str1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else if(dp[i-1][j] > dp[i][j-1]){\\n                ans += str1[i-1];\\n                i--;\\n            }\\n            else{\\n                ans += str2[j-1];\\n                j--;\\n            }\\n        }\\n        \\n        while(i>0){\\n            ans += str1[i-1];\\n            i--;\\n        }\\n        \\n        while(j>0){\\n            ans += str2[j-1];\\n            j--;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.length();\\n        int m = str2.length();\\n        vector<vector<int>>dp(n+1, vector<int>(m+1, 0));\\n        for(int i=0; i<=n; i++)\\n            dp[i][0] = 0;\\n        for(int j=0; j<=m; j++)\\n            dp[0][j] = 0;\\n        for(int ind1 = 1; ind1<=n; ind1++)\\n        {\\n            for(int ind2 = 1; ind2 <= m; ind2++)\\n            {\\n                if(str1[ind1-1] == str2[ind2-1])\\n                    dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1];\\n                else\\n                    dp[ind1][ind2] = 0 + max(dp[ind1-1][ind2], dp[ind1][ind2-1]);\\n            }\\n        }\\n        int i=n, j=m;\\n        string ans = \"\";\\n        while(i>0 && j>0){\\n            if(str1[i-1] == str2[j-1]){\\n                ans += str1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else if(dp[i-1][j] > dp[i][j-1]){\\n                ans += str1[i-1];\\n                i--;\\n            }\\n            else{\\n                ans += str2[j-1];\\n                j--;\\n            }\\n        }\\n        \\n        while(i>0){\\n            ans += str1[i-1];\\n            i--;\\n        }\\n        \\n        while(j>0){\\n            ans += str2[j-1];\\n            j--;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2385888,
                "title": "easy-c-solution-variation-of-lcs",
                "content": "Same as longest common subsequence but we have to minus the length of the lcs from m+n\\nSupersequence is a string that contains both the strings as a subsequence\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint main(){\\n    string x=\"aaaa\";\\n    string y=\"aa\";\\n    int n=x.length();\\n    int m=y.length();\\n    int t[n+1][m+1];\\n    for(int i=0;i<n+1;i++){\\n        for(int j=0;j<m+1;j++){\\n            if(i==0 || j==0)\\n            t[i][j]=0;\\n        }\\n    }\\n    for(int i=1;i<n+1;i++){\\n        for(int j=1;j<m+1;j++){\\n            if(x[i-1]==y[j-1])\\n            t[i][j]=1+t[i-1][j-1];\\n            else{\\n                t[i][j]=max(t[i-1][j],t[i][j-1]);\\n            }\\n        }\\n    }\\n    cout<<m+n-t[n][m];\\n    return 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint main(){\\n    string x=\"aaaa\";\\n    string y=\"aa\";\\n    int n=x.length();\\n    int m=y.length();\\n    int t[n+1][m+1];\\n    for(int i=0;i<n+1;i++){\\n        for(int j=0;j<m+1;j++){\\n            if(i==0 || j==0)\\n            t[i][j]=0;\\n        }\\n    }\\n    for(int i=1;i<n+1;i++){\\n        for(int j=1;j<m+1;j++){\\n            if(x[i-1]==y[j-1])\\n            t[i][j]=1+t[i-1][j-1];\\n            else{\\n                t[i][j]=max(t[i-1][j],t[i][j-1]);\\n            }\\n        }\\n    }\\n    cout<<m+n-t[n][m];\\n    return 0;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2378100,
                "title": "golang-aditya-verma-approach-top-down-dp",
                "content": "```\\nfunc shortestCommonSupersequence(str1 string, str2 string) string {\\n    m:=len(str1)\\n    n:=len(str2)\\n    \\n    t:=make([][]int, m+1)\\n    for i,_ := range t{\\n        t[i]=make([]int, n+1)\\n    }\\n    \\n    for i:=1; i<m+1;i++{\\n        for j:=1; j<n+1;j++{\\n            if str1[i-1]==str2[j-1]{\\n                t[i][j] = 1 + t[i-1][j-1]\\n            }else{\\n                t[i][j] = max(t[i-1][j], t[i][j-1])\\n            }\\n        }\\n    }\\n    \\n    res:=\"\"\\n    i,j := m,n\\n    \\n    for i>0 && j>0{\\n        if str1[i-1]==str2[j-1]{\\n            res=res+string(str1[i-1])\\n            i--\\n            j--\\n        }else{\\n            if t[i][j-1]>t[i-1][j]{\\n                res+=string(str2[j-1])\\n                j--\\n            }else{\\n                res+=string(str1[i-1])\\n                i--\\n            }\\n        }\\n    }\\n    \\n    for i>0{\\n        res+=string(str1[i-1])\\n        i--\\n    }\\n    for j>0{\\n        res+=string(str2[j-1])\\n        j--\\n    }\\n    return reverse(res)\\n}\\n\\n// max function\\nfunc max(a,b int) int{\\n    if a>b{\\n        return a\\n    }\\n    return b\\n}\\n// reverse function\\nfunc reverse(str string) string{\\n    temp:=\"\"\\n    for i:=len(str)-1;i>=0;i--{\\n        temp+=string(str[i])\\n    }\\n    return temp\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc shortestCommonSupersequence(str1 string, str2 string) string {\\n    m:=len(str1)\\n    n:=len(str2)\\n    \\n    t:=make([][]int, m+1)\\n    for i,_ := range t{\\n        t[i]=make([]int, n+1)\\n    }\\n    \\n    for i:=1; i<m+1;i++{\\n        for j:=1; j<n+1;j++{\\n            if str1[i-1]==str2[j-1]{\\n                t[i][j] = 1 + t[i-1][j-1]\\n            }else{\\n                t[i][j] = max(t[i-1][j], t[i][j-1])\\n            }\\n        }\\n    }\\n    \\n    res:=\"\"\\n    i,j := m,n\\n    \\n    for i>0 && j>0{\\n        if str1[i-1]==str2[j-1]{\\n            res=res+string(str1[i-1])\\n            i--\\n            j--\\n        }else{\\n            if t[i][j-1]>t[i-1][j]{\\n                res+=string(str2[j-1])\\n                j--\\n            }else{\\n                res+=string(str1[i-1])\\n                i--\\n            }\\n        }\\n    }\\n    \\n    for i>0{\\n        res+=string(str1[i-1])\\n        i--\\n    }\\n    for j>0{\\n        res+=string(str2[j-1])\\n        j--\\n    }\\n    return reverse(res)\\n}\\n\\n// max function\\nfunc max(a,b int) int{\\n    if a>b{\\n        return a\\n    }\\n    return b\\n}\\n// reverse function\\nfunc reverse(str string) string{\\n    temp:=\"\"\\n    for i:=len(str)-1;i>=0;i--{\\n        temp+=string(str[i])\\n    }\\n    return temp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2375141,
                "title": "easy-java-solution-aditya-verma-approach",
                "content": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int m=str1.length();\\n        int n=str2.length();\\n        int[][] dp=new int[m+1][n+1];\\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(str1.charAt(i-1)==str2.charAt(j-1)){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j]);\\n                }\\n            }\\n        }\\n        int i=m,j=n;\\n        String res=\"\";\\n        while(i>0 && j>0){\\n            if(str1.charAt(i-1)==str2.charAt(j-1)){\\n                res=str1.charAt(i-1)+res;\\n                i--;\\n                j--;\\n            }else if(dp[i-1][j]>dp[i][j-1]){\\n                res=str1.charAt(i-1)+res;\\n                i--;\\n            }else{\\n                res=str2.charAt(j-1)+res;\\n                j--;\\n            }\\n        }\\n        while(i>0){\\n            res=str1.charAt(i-1)+res;\\n            i--;\\n        }\\n        while(j>0){\\n            res=str2.charAt(j-1)+res;\\n            j--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int m=str1.length();\\n        int n=str2.length();\\n        int[][] dp=new int[m+1][n+1];\\n        for(int i=1;i<m+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(str1.charAt(i-1)==str2.charAt(j-1)){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j]);\\n                }\\n            }\\n        }\\n        int i=m,j=n;\\n        String res=\"\";\\n        while(i>0 && j>0){\\n            if(str1.charAt(i-1)==str2.charAt(j-1)){\\n                res=str1.charAt(i-1)+res;\\n                i--;\\n                j--;\\n            }else if(dp[i-1][j]>dp[i][j-1]){\\n                res=str1.charAt(i-1)+res;\\n                i--;\\n            }else{\\n                res=str2.charAt(j-1)+res;\\n                j--;\\n            }\\n        }\\n        while(i>0){\\n            res=str1.charAt(i-1)+res;\\n            i--;\\n        }\\n        while(j>0){\\n            res=str2.charAt(j-1)+res;\\n            j--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349501,
                "title": "shortest-common-supersequence-using-lcs",
                "content": "``` \\nstring LCS(string text1, string text2,int n,int m,vector<vector<int>> &dp){\\n        \\n        //base condn\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0 || j==0){\\n                    dp[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(text1[i-1]==text2[j-1]){\\n                    dp[i][j]= 1+dp[i-1][j-1];\\n                }\\n                \\n                else{\\n                    dp[i][j]=max(dp[i][j-1],dp[i-1][j]);\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        int i=n;\\n        int j=m;\\n        string s=\"\";\\n        \\n        while(i>0 && j>0){\\n            if(text1[i-1]==text2[j-1]){\\n                s.push_back(text1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(dp[i][j-1]>dp[i-1][j]){\\n                    s.push_back(text2[j-1]);\\n                    j--;\\n                }\\n                else{\\n                    s.push_back(text1[i-1]);\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n           s.push_back(text1[i-1]);\\n            i--;\\n        }\\n        \\n        while(j>0){\\n           s.push_back(text2[j-1]);\\n            j--;\\n        }\\n        \\n        \\n        reverse(s.begin(),s.end());\\n        \\n        \\n        return s;\\n        \\n\\n        \\n        \\n        \\n        \\n    }\\n    \\n    \\n    string shortestCommonSupersequence(string str1, string str2) {\\n        \\n        int n=str1.length();\\n        int m=str2.length();\\n        \\n        vector<vector<int>> dp(n+1, vector<int> (m+1,-1));\\n        \\n        \\n        \\n        string ans=LCS(str1,str2,n,m,dp);\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n\\t\\n\\t```\\n\\t\\n\\tPlease upvote if you like the solution.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "``` \\nstring LCS(string text1, string text2,int n,int m,vector<vector<int>> &dp){\\n        \\n        //base condn\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0 || j==0){\\n                    dp[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(text1[i-1]==text2[j-1]){\\n                    dp[i][j]= 1+dp[i-1][j-1];\\n                }\\n                \\n                else{\\n                    dp[i][j]=max(dp[i][j-1],dp[i-1][j]);\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        int i=n;\\n        int j=m;\\n        string s=\"\";\\n        \\n        while(i>0 && j>0){\\n            if(text1[i-1]==text2[j-1]){\\n                s.push_back(text1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(dp[i][j-1]>dp[i-1][j]){\\n                    s.push_back(text2[j-1]);\\n                    j--;\\n                }\\n                else{\\n                    s.push_back(text1[i-1]);\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n           s.push_back(text1[i-1]);\\n            i--;\\n        }\\n        \\n        while(j>0){\\n           s.push_back(text2[j-1]);\\n            j--;\\n        }\\n        \\n        \\n        reverse(s.begin(),s.end());\\n        \\n        \\n        return s;\\n        \\n\\n        \\n        \\n        \\n        \\n    }\\n    \\n    \\n    string shortestCommonSupersequence(string str1, string str2) {\\n        \\n        int n=str1.length();\\n        int m=str2.length();\\n        \\n        vector<vector<int>> dp(n+1, vector<int> (m+1,-1));\\n        \\n        \\n        \\n        string ans=LCS(str1,str2,n,m,dp);\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2346535,
                "title": "print-scs",
                "content": "```\\n\\t//Recursion\\n    int scs(string str1, string str2, int n, int m) {\\n        if(n==0) return m;\\n        if(m==0) return n;\\n        if(str1[n-1] == str2[m-1])\\n            return scs(str1,str2,n-1,m-1) + 1;\\n        return min(scs(str1,str2,n-1,m), scs(str1,str2,n,m-1)) + 1;\\n    }\\n    \\n    //Memoization\\n    int scs(string str1, string str2, int n, int m, vector<vector<int>> &dp) {\\n        if(n==0) return m;\\n        if(m==0) return n;\\n        if(dp[n][m] != -1) \\n            return dp[n][m];\\n        if(str1[n-1] == str2[m-1])\\n            dp[n][m] = scs(str1,str2,n-1,m-1,dp) + 1;\\n        else\\n            dp[n][m] = min(scs(str1,str2,n-1,m,dp),scs(str1,str2,n,m-1,dp)) + 1;\\n        return dp[n][m];\\n    }\\n    \\n    //Tabulation\\n    int scs(string str1, string str2, int n, int m, vector<vector<int>> &dp) {\\n        for(int i=0; i<=n; i++) {\\n            for(int j=0; j<=m; j++) {\\n                if(i == 0) \\n                    dp[i][j] = j;\\n                else if(j == 0) \\n                    dp[i][j] = i;\\n                else if(str1[i-1] == str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1] + 1;\\n                else\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1;\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n    \\n    string printSCS(string str1, string str2, int n, int m, vector<vector<int>> &dp) {\\n        string res = \"\"; \\n        int i=n, j=m;\\n        while(i > 0 and j > 0) {\\n            if(str1[i-1] == str2[j-1]) {\\n                res += str1[i-1];\\n                i--; j--;\\n            }\\n            else if(dp[i-1][j] > dp[i][j-1]) {\\n                res += str2[j-1];\\n                j--;\\n            }\\n            else {\\n                res += str1[i-1];\\n                i--;\\n            }\\n        }\\n        while(i>0) {\\n            res += str1[i-1];\\n            i--;\\n        }\\n        while(j>0) {\\n            res += str2[j-1];\\n            j--;\\n        }\\n        \\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.size();\\n        int m = str2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int lenSCS = scs(str1, str2, n, m, dp);\\n        \\n        return printSCS(str1, str2, n, m, dp);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\t//Recursion\\n    int scs(string str1, string str2, int n, int m) {\\n        if(n==0) return m;\\n        if(m==0) return n;\\n        if(str1[n-1] == str2[m-1])\\n            return scs(str1,str2,n-1,m-1) + 1;\\n        return min(scs(str1,str2,n-1,m), scs(str1,str2,n,m-1)) + 1;\\n    }\\n    \\n    //Memoization\\n    int scs(string str1, string str2, int n, int m, vector<vector<int>> &dp) {\\n        if(n==0) return m;\\n        if(m==0) return n;\\n        if(dp[n][m] != -1) \\n            return dp[n][m];\\n        if(str1[n-1] == str2[m-1])\\n            dp[n][m] = scs(str1,str2,n-1,m-1,dp) + 1;\\n        else\\n            dp[n][m] = min(scs(str1,str2,n-1,m,dp),scs(str1,str2,n,m-1,dp)) + 1;\\n        return dp[n][m];\\n    }\\n    \\n    //Tabulation\\n    int scs(string str1, string str2, int n, int m, vector<vector<int>> &dp) {\\n        for(int i=0; i<=n; i++) {\\n            for(int j=0; j<=m; j++) {\\n                if(i == 0) \\n                    dp[i][j] = j;\\n                else if(j == 0) \\n                    dp[i][j] = i;\\n                else if(str1[i-1] == str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1] + 1;\\n                else\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1;\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n    \\n    string printSCS(string str1, string str2, int n, int m, vector<vector<int>> &dp) {\\n        string res = \"\"; \\n        int i=n, j=m;\\n        while(i > 0 and j > 0) {\\n            if(str1[i-1] == str2[j-1]) {\\n                res += str1[i-1];\\n                i--; j--;\\n            }\\n            else if(dp[i-1][j] > dp[i][j-1]) {\\n                res += str2[j-1];\\n                j--;\\n            }\\n            else {\\n                res += str1[i-1];\\n                i--;\\n            }\\n        }\\n        while(i>0) {\\n            res += str1[i-1];\\n            i--;\\n        }\\n        while(j>0) {\\n            res += str2[j-1];\\n            j--;\\n        }\\n        \\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.size();\\n        int m = str2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        int lenSCS = scs(str1, str2, n, m, dp);\\n        \\n        return printSCS(str1, str2, n, m, dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2344567,
                "title": "c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.length();\\n        int m = str2.length();\\n        \\n        int t[n+1][m+1];\\n        memset(t,0,sizeof(t));\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(str1[i-1]==str2[j-1]){\\n                    t[i][j] = 1+t[i-1][j-1];\\n                }\\n                else{\\n                    t[i][j] = max(t[i-1][j], t[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int i=n;\\n        int j=m;\\n        string ans=\"\";\\n        \\n        while(i>0 and j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                ans.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(t[i][j-1]>t[i-1][j]){\\n                    ans.push_back(str2[j-1]);\\n                    j--;\\n                }\\n                else{\\n                    ans.push_back(str1[i-1]);\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n            ans.push_back(str1[i-1]);\\n            i--;\\n        }\\n        \\n        while(j>0){\\n            ans.push_back(str2[j-1]);\\n            j--;\\n        }\\n        \\n        string s = string(ans.rbegin(),ans.rend());\\n        \\n    return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.length();\\n        int m = str2.length();\\n        \\n        int t[n+1][m+1];\\n        memset(t,0,sizeof(t));\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(str1[i-1]==str2[j-1]){\\n                    t[i][j] = 1+t[i-1][j-1];\\n                }\\n                else{\\n                    t[i][j] = max(t[i-1][j], t[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int i=n;\\n        int j=m;\\n        string ans=\"\";\\n        \\n        while(i>0 and j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                ans.push_back(str1[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                if(t[i][j-1]>t[i-1][j]){\\n                    ans.push_back(str2[j-1]);\\n                    j--;\\n                }\\n                else{\\n                    ans.push_back(str1[i-1]);\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n            ans.push_back(str1[i-1]);\\n            i--;\\n        }\\n        \\n        while(j>0){\\n            ans.push_back(str2[j-1]);\\n            j--;\\n        }\\n        \\n        string s = string(ans.rbegin(),ans.rend());\\n        \\n    return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332049,
                "title": "clean-dp-memoization-o-n-2-time-space",
                "content": "```\\nclass Solution {\\n    int len1,len2;\\n    string s1,s2;\\n    int dp[1001][1001];\\n    vector<vector<int>> path;\\n    int dfs(int idx1, int idx2){\\n        if(idx1==len1)\\n            return len2-idx2;\\n        if(idx2==len2)\\n            return len1-idx1;\\n\\n        if(dp[idx1][idx2]!=-1)\\n            return dp[idx1][idx2];\\n        \\n        if(s1[idx1]==s2[idx2])\\n            return 1+dfs(idx1+1,idx2+1);\\n        int one=1+dfs(idx1+1,idx2);\\n        int two=1+dfs(idx1,idx2+1);\\n        if(one<=two){\\n            path[idx1][idx2]=1;\\n            return dp[idx1][idx2]=one;\\n        }\\n        path[idx1][idx2]=2;\\n        return dp[idx1][idx2]=two;\\n    }\\n    string dfs2(int idx1, int idx2){\\n        string res=\"\";\\n        while(idx1<len1 and idx2<len2){\\n            if(path[idx1][idx2]==0){\\n                res+=s1[idx1];\\n                idx1++;idx2++;\\n            }else if(path[idx1][idx2]==1){\\n                res+=s1[idx1];\\n                idx1++;\\n            }else{\\n                res+=s2[idx2];\\n                idx2++;\\n            }\\n        }\\n        res+=s1.substr(idx1,len1)+s2.substr(idx2,len2);\\n        return res;\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        s1=str1;s2=str2;\\n        len1=str1.size();\\n        len2=str2.size();\\n        memset(dp,-1,sizeof(dp));\\n        path.resize(len1+1,vector<int>(len2+1,0));\\n        dfs(0,0);\\n        return dfs2(0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int len1,len2;\\n    string s1,s2;\\n    int dp[1001][1001];\\n    vector<vector<int>> path;\\n    int dfs(int idx1, int idx2){\\n        if(idx1==len1)\\n            return len2-idx2;\\n        if(idx2==len2)\\n            return len1-idx1;\\n\\n        if(dp[idx1][idx2]!=-1)\\n            return dp[idx1][idx2];\\n        \\n        if(s1[idx1]==s2[idx2])\\n            return 1+dfs(idx1+1,idx2+1);\\n        int one=1+dfs(idx1+1,idx2);\\n        int two=1+dfs(idx1,idx2+1);\\n        if(one<=two){\\n            path[idx1][idx2]=1;\\n            return dp[idx1][idx2]=one;\\n        }\\n        path[idx1][idx2]=2;\\n        return dp[idx1][idx2]=two;\\n    }\\n    string dfs2(int idx1, int idx2){\\n        string res=\"\";\\n        while(idx1<len1 and idx2<len2){\\n            if(path[idx1][idx2]==0){\\n                res+=s1[idx1];\\n                idx1++;idx2++;\\n            }else if(path[idx1][idx2]==1){\\n                res+=s1[idx1];\\n                idx1++;\\n            }else{\\n                res+=s2[idx2];\\n                idx2++;\\n            }\\n        }\\n        res+=s1.substr(idx1,len1)+s2.substr(idx2,len2);\\n        return res;\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        s1=str1;s2=str2;\\n        len1=str1.size();\\n        len2=str2.size();\\n        memset(dp,-1,sizeof(dp));\\n        path.resize(len1+1,vector<int>(len2+1,0));\\n        dfs(0,0);\\n        return dfs2(0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305616,
                "title": "simple-cpp-solution-using-lcs",
                "content": "class Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n\\t\\n        int m=str1.length(), n=str2.length();\\n        int t[m+1][n+1];\\n        // getting lcs matrix\\n        for(int i=0; i<m+1; i++){\\n            for(int j=0; j<n+1; j++){\\n                if(i==0 || j==0) t[i][j]=0;\\n                else if(str1[i-1]==str2[j-1]) t[i][j] = t[i-1][j-1] + 1;\\n                else t[i][j] = max(t[i][j-1], t[i-1][j]);\\n            }\\n        }\\n        \\n        // getting the lcs string\\n        int i=m, j=n;\\n        string lcs=\"\";\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                lcs+=str1[i-1];\\n                i--;j--;\\n            }\\n            else if(t[i-1][j]>t[i][j-1]){\\n                lcs+=str1[i-1];\\n                i--;\\n            }else{\\n                lcs+=str2[j-1];\\n                j--;\\n            }\\n        }\\n        while(i>0){\\n            lcs+=str1[i-1];\\n            i--;\\n        }\\n        while(j>0){\\n            lcs+=str2[j-1];\\n            j--;\\n        }\\n        \\n        reverse(lcs.begin(), lcs.end());\\n        return lcs;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n\\t\\n        int m=str1.length(), n=str2.length();\\n        int t[m+1][n+1];\\n        // getting lcs matrix\\n        for(int i=0; i<m+1; i++){\\n            for(int j=0; j<n+1; j++){\\n                if(i==0 || j==0) t[i][j]=0;\\n                else if(str1[i-1]==str2[j-1]) t[i][j] = t[i-1][j-1] + 1;\\n                else t[i][j] = max(t[i][j-1], t[i-1][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2304039,
                "title": "simple-java-tabulation-method",
                "content": "```\\nclass Solution {\\n    \\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        return get(str1 , str2);\\n    }\\n    \\n    \\n    public String get(String text1, String text2) {\\n        \\n        int m = text1.length();\\n        int n = text2.length();\\n        \\n        int[][] dp = new int[m + 1][n + 1];\\n     \\n        char[] s = text1.toCharArray();\\n        char[] t = text2.toCharArray();\\n        \\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s[i - 1] == t[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                } else {\\n                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);\\n                }\\n            }\\n        }\\n        \\n        int i = m ;\\n        int j = n ;\\n        \\n        \\n        StringBuilder str = new StringBuilder();\\n        \\n        while ( i > 0 && j > 0){\\n            if(s[i-1] == t[j-1]){\\n                str.insert(0 , s[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                \\n                if(dp[i-1][j] < dp[i][j-1]){\\n                    str.insert( 0 , t[j-1]);\\n                    j--;\\n                }\\n                else{\\n                    str.insert( 0 , s[i-1]);\\n                    i--;\\n                }\\n                \\n            }\\n        }\\n        \\n        if( i > 0){\\n            str.insert( 0 , text1.substring(0 , i));\\n        }\\n        if( j > 0){\\n            str.insert( 0 , text2.substring(0 , j));\\n        }\\n        \\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        return get(str1 , str2);\\n    }\\n    \\n    \\n    public String get(String text1, String text2) {\\n        \\n        int m = text1.length();\\n        int n = text2.length();\\n        \\n        int[][] dp = new int[m + 1][n + 1];\\n     \\n        char[] s = text1.toCharArray();\\n        char[] t = text2.toCharArray();\\n        \\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s[i - 1] == t[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                } else {\\n                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);\\n                }\\n            }\\n        }\\n        \\n        int i = m ;\\n        int j = n ;\\n        \\n        \\n        StringBuilder str = new StringBuilder();\\n        \\n        while ( i > 0 && j > 0){\\n            if(s[i-1] == t[j-1]){\\n                str.insert(0 , s[i-1]);\\n                i--;\\n                j--;\\n            }\\n            else{\\n                \\n                if(dp[i-1][j] < dp[i][j-1]){\\n                    str.insert( 0 , t[j-1]);\\n                    j--;\\n                }\\n                else{\\n                    str.insert( 0 , s[i-1]);\\n                    i--;\\n                }\\n                \\n            }\\n        }\\n        \\n        if( i > 0){\\n            str.insert( 0 , text1.substring(0 , i));\\n        }\\n        if( j > 0){\\n            str.insert( 0 , text2.substring(0 , j));\\n        }\\n        \\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299756,
                "title": "c-find-lcs-and-add-other-remaining-elements",
                "content": "**class Solution {\\npublic:**\\n\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n=str1.length(),m=str2.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=0;i<=n;++i){\\n            dp[i][0]=0;\\n        }\\n        for(int i=0;i<=m;++i){\\n            dp[0][i]=0;\\n        }\\n        for(int i=1;i<=n;++i){\\n            for(int j=1;j<=m;++j){\\n                if(str1[i-1]==str2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        int len=dp[n][m];\\n        string s=\"\";\\n        for(int i=0;i<n+m-len;++i){\\n            s+=\\'$\\';\\n        }\\n        int ind=n+m-len-1;\\n        int i=str1.length(),j=str2.length();\\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                s[ind]=str1[i-1];\\n                i--,j--;\\n                ind--;\\n            }\\n            else{\\n                if(dp[i-1][j]>dp[i][j-1]){\\n                    s[ind]=str1[i-1];\\n                    i=i-1;\\n                }\\n                else{\\n                    s[ind]=str2[j-1];\\n                    j=j-1;\\n                }\\n                ind--;\\n            }\\n        }\\n        while(i>0 && ind>=0){\\n            s[ind]=str1[i-1];\\n            ind--;\\n            i--;\\n        }\\n        while(j>0 && ind>=0){\\n            s[ind]=str2[j-1];\\n            ind--;\\n            j--;\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:**\\n\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n=str1.length(),m=str2.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=0;i<=n;++i){\\n            dp[i][0]=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2296792,
                "title": "c-dp-lcs-variation-simple-easy-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tstring shortestCommonSupersequence(string str1, string str2) {\\n        \\n        int n=str1.size(), m=str2.size();\\n        \\n        vector<vector<int>> dp(n+1, vector<int>(m+1,0));\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                \\n                if(str1[i-1]==str2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        string ans;\\n        int i=n, j=m;\\n        \\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                ans.push_back(str1[i-1]);\\n                i--; j--;\\n            }\\n            else{\\n                if(dp[i-1][j]>dp[i][j-1]){\\n                    ans.push_back(str1[i-1]);\\n                    i--;\\n                }\\n                else{\\n                    ans.push_back(str2[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n            ans.push_back(str1[i-1]);\\n            i--;\\n        }\\n        \\n        while(j>0){\\n            ans.push_back(str2[j-1]);\\n            j--;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tstring shortestCommonSupersequence(string str1, string str2) {\\n        \\n        int n=str1.size(), m=str2.size();\\n        \\n        vector<vector<int>> dp(n+1, vector<int>(m+1,0));\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                \\n                if(str1[i-1]==str2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        string ans;\\n        int i=n, j=m;\\n        \\n        while(i>0 && j>0){\\n            if(str1[i-1]==str2[j-1]){\\n                ans.push_back(str1[i-1]);\\n                i--; j--;\\n            }\\n            else{\\n                if(dp[i-1][j]>dp[i][j-1]){\\n                    ans.push_back(str1[i-1]);\\n                    i--;\\n                }\\n                else{\\n                    ans.push_back(str2[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0){\\n            ans.push_back(str1[i-1]);\\n            i--;\\n        }\\n        \\n        while(j>0){\\n            ans.push_back(str2[j-1]);\\n            j--;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2262817,
                "title": "c-fastest-submisiion-tabulation-dp-lcs-extension",
                "content": "This problem is ans extension of LCS(longest common subsequence)\\nfirst we will find what is the common longest subsequence present in both the strings.\\nthen from LCS table we will trace backward in order to get the string. ifat any index the string character matches then we we will take it once bcz it is the common charater in both the string. otehrwise we will take go to the maximium cell from wehere we have arrived either dp[i-1][j] or dp[i][j-1] and before going we will add the charcter in ans. Our string is ready but in reverse order.\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> createLCS(string &s1,string &s2){\\n        int n1=s1.size();\\n        int n2=s2.size();\\n        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));\\n        \\n        for(int i=1;i<=n1;i++){\\n            for(int j=1;j<=n2;j++){\\n                if(s1[i-1]==s2[j-1])\\n                    dp[i][j]= 1 + dp[i-1][j-1];\\n                else\\n                    dp[i][j]= max(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        return dp;\\n    }\\n    \\n    string getStringFromLcsTable(vector<vector<int>>&dp,string &s1,string &s2){\\n        string ans=\"\";\\n        int i=s1.size();\\n        int j=s2.size();\\n        while(i>0 && j>0){\\n            \\n            if(s1[i-1]==s2[j-1]){\\n                ans+=s1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else{\\n                int maxi=max(dp[i][j-1] ,dp[i-1][j]);\\n                if(dp[i][j-1]==maxi){\\n                    ans+=s2[j-1];\\n                    j--;\\n                }\\n                else{\\n                    ans+=s1[i-1];\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0)\\n        {\\n            ans+= s1[i-1];\\n            i--;\\n        }\\n        while(j>0)\\n        {\\n            ans+= s2[j-1];\\n            j--;\\n        }\\n        return ans;\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        vector<vector<int>>dp= createLCS(str1,str2);\\n        string ans= getStringFromLcsTable(dp,str1,str2);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> createLCS(string &s1,string &s2){\\n        int n1=s1.size();\\n        int n2=s2.size();\\n        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));\\n        \\n        for(int i=1;i<=n1;i++){\\n            for(int j=1;j<=n2;j++){\\n                if(s1[i-1]==s2[j-1])\\n                    dp[i][j]= 1 + dp[i-1][j-1];\\n                else\\n                    dp[i][j]= max(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        return dp;\\n    }\\n    \\n    string getStringFromLcsTable(vector<vector<int>>&dp,string &s1,string &s2){\\n        string ans=\"\";\\n        int i=s1.size();\\n        int j=s2.size();\\n        while(i>0 && j>0){\\n            \\n            if(s1[i-1]==s2[j-1]){\\n                ans+=s1[i-1];\\n                i--;\\n                j--;\\n            }\\n            else{\\n                int maxi=max(dp[i][j-1] ,dp[i-1][j]);\\n                if(dp[i][j-1]==maxi){\\n                    ans+=s2[j-1];\\n                    j--;\\n                }\\n                else{\\n                    ans+=s1[i-1];\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        while(i>0)\\n        {\\n            ans+= s1[i-1];\\n            i--;\\n        }\\n        while(j>0)\\n        {\\n            ans+= s2[j-1];\\n            j--;\\n        }\\n        return ans;\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        vector<vector<int>>dp= createLCS(str1,str2);\\n        string ans= getStringFromLcsTable(dp,str1,str2);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258102,
                "title": "java-solution-dp-lcs",
                "content": "The solution is same as Longest Common Subsequence(LCS)\\nIf you like the solution, then please UPVOTE it\\n\\n```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int l1 = str1.length();\\n        int l2 = str2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        \\n        for(int i = 0 ; i <= l1 ; i++)\\n            dp[i][0] = 1;\\n        for(int j = 0 ; j <= l2 ; j++)\\n            dp[0][j] = 1;\\n        \\n        for(int i = 1 ; i <= l1 ; i++){\\n            for(int j = 1 ; j <= l2 ; j++){\\n                if(str1.charAt(i-1) == str2.charAt(j-1))\\n                    dp[i][j] = 1+dp[i-1][j-1];\\n                else\\n                    dp[i][j] = Math.max(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        \\n        String ans = \"\";\\n        \\n        while(l1 >= 1 && l2 >= 1)\\n        {\\n            if(str1.charAt(l1-1) == str2.charAt(l2-1))\\n            {\\n                ans = str1.charAt(l1-1) + ans;\\n                l1--;\\n                l2--;\\n            }\\n            else\\n            {\\n                if(dp[l1-1][l2] > dp[l1][l2-1])\\n                {\\n                    ans = str1.charAt(l1-1) + ans;\\n                    l1--;\\n                }\\n                else\\n                {\\n                    ans = str2.charAt(l2-1) + ans;\\n                    l2--;\\n                }\\n            }\\n        }\\n        while(l1 > 0)\\n            ans = str1.charAt(--l1) + ans;\\n        while(l2 > 0)\\n            ans = str2.charAt(--l2) + ans;\\n        \\n        return ans;\\n    }\\n}\\n```\\nHaven\\'t UPVOTED yet, can do it now",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String str1, String str2) {\\n        int l1 = str1.length();\\n        int l2 = str2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        \\n        for(int i = 0 ; i <= l1 ; i++)\\n            dp[i][0] = 1;\\n        for(int j = 0 ; j <= l2 ; j++)\\n            dp[0][j] = 1;\\n        \\n        for(int i = 1 ; i <= l1 ; i++){\\n            for(int j = 1 ; j <= l2 ; j++){\\n                if(str1.charAt(i-1) == str2.charAt(j-1))\\n                    dp[i][j] = 1+dp[i-1][j-1];\\n                else\\n                    dp[i][j] = Math.max(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        \\n        String ans = \"\";\\n        \\n        while(l1 >= 1 && l2 >= 1)\\n        {\\n            if(str1.charAt(l1-1) == str2.charAt(l2-1))\\n            {\\n                ans = str1.charAt(l1-1) + ans;\\n                l1--;\\n                l2--;\\n            }\\n            else\\n            {\\n                if(dp[l1-1][l2] > dp[l1][l2-1])\\n                {\\n                    ans = str1.charAt(l1-1) + ans;\\n                    l1--;\\n                }\\n                else\\n                {\\n                    ans = str2.charAt(l2-1) + ans;\\n                    l2--;\\n                }\\n            }\\n        }\\n        while(l1 > 0)\\n            ans = str1.charAt(--l1) + ans;\\n        while(l2 > 0)\\n            ans = str2.charAt(--l2) + ans;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247851,
                "title": "simple-solution-using-lcs-dp-table-c",
                "content": "```\\nstring shortestCommonSupersequence(string s, string t) {\\n        int n=s.size();\\n        int m=t.size();\\n        vector<vector<int>>dp(n+1, vector<int>(m+1, 0));\\n        \\n        \\n        // for finding longest subsequence length\\n        for(int i=0;i<=n;i++)\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0|| j==0) dp[i][j]=0;\\n                else if(s[i-1]==t[j-1]) \\n                    dp[i][j] = 1+dp[i-1][j-1];\\n                else\\n                    dp[i][j]= max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        \\n        \\n        //length of resultant string\\n        int len = n+m-dp[n][m]; \\n        string res=\"\";\\n        for(int i=0;i<len;i++) res = res+\"$\";\\n        int i = n, j=m;\\n        int index = len-1;\\n        \\n        \\n        //traverse dp table from n,m to 0,0\\n        //if char are same then move diagonally up\\n        //else move up or left(whichever is max)\\n        //while moving in dp table, parallelly add char to our resultant string\\n        while(i>0 && j>0)\\n        {\\n            if(s[i-1]==t[j-1]) \\n            {\\n                \\n                res[index--]= s[i-1];\\n                i--, j--;\\n            }\\n            else\\n            {\\n                if(dp[i-1][j]> dp[i][j-1]) \\n                {\\n                    res[index--]= s[i-1]; \\n                    i--;\\n                }\\n                else {\\n                    res[index--]= t[j-1];\\n                    j--;\\n                    }\\n                }\\n        }\\n        \\n        \\n        //in the end maybe j or i will get 0\\n        //append the remaining char to our result\\n        \\n        while(i>0) \\n        {\\n            res[index--] = s[i-1]; \\n            i--;\\n        }\\n        while(j>0) \\n        {\\n            res[index--] = t[j-1]; \\n            j--;\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nstring shortestCommonSupersequence(string s, string t) {\\n        int n=s.size();\\n        int m=t.size();\\n        vector<vector<int>>dp(n+1, vector<int>(m+1, 0));\\n        \\n        \\n        // for finding longest subsequence length\\n        for(int i=0;i<=n;i++)\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0|| j==0) dp[i][j]=0;\\n                else if(s[i-1]==t[j-1]) \\n                    dp[i][j] = 1+dp[i-1][j-1];\\n                else\\n                    dp[i][j]= max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        \\n        \\n        //length of resultant string\\n        int len = n+m-dp[n][m]; \\n        string res=\"\";\\n        for(int i=0;i<len;i++) res = res+\"$\";\\n        int i = n, j=m;\\n        int index = len-1;\\n        \\n        \\n        //traverse dp table from n,m to 0,0\\n        //if char are same then move diagonally up\\n        //else move up or left(whichever is max)\\n        //while moving in dp table, parallelly add char to our resultant string\\n        while(i>0 && j>0)\\n        {\\n            if(s[i-1]==t[j-1]) \\n            {\\n                \\n                res[index--]= s[i-1];\\n                i--, j--;\\n            }\\n            else\\n            {\\n                if(dp[i-1][j]> dp[i][j-1]) \\n                {\\n                    res[index--]= s[i-1]; \\n                    i--;\\n                }\\n                else {\\n                    res[index--]= t[j-1];\\n                    j--;\\n                    }\\n                }\\n        }\\n        \\n        \\n        //in the end maybe j or i will get 0\\n        //append the remaining char to our result\\n        \\n        while(i>0) \\n        {\\n            res[index--] = s[i-1]; \\n            i--;\\n        }\\n        while(j>0) \\n        {\\n            res[index--] = t[j-1]; \\n            j--;\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2244744,
                "title": "cpp-aditya-verma-dp",
                "content": "**SOLUTION FOR THOSE WHO ARE GETTING TLE,\\nRuntime =  16ms , better than 78% **\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.size() , m = str2.size();\\n        int dp[n+1][m+1];\\n        \\n        // for(int i=0;i<n+1;i++) dp[i][0] = 0;\\n        // for(int i=0;i<m+1;i++) dp[0][i] = 0;\\n        \\n        for(int i =0;i<n+1;i++)\\n        {\\n            for(int j=0;j<m+1;j++)\\n            {\\n                if(i==0 || j==0) dp[i][j] = 0 ;\\n                else\\n                {\\n                    if(str1[i-1] == str2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;\\n                    else dp[i][j] = max(dp[i-1][j] , dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int i=n , j = m;\\n        string ans = \"\";\\n        \\n        while(i > 0 && j > 0)\\n        {\\n            if(str1[i-1] == str2[j-1])\\n            {\\n                ans += (str1[i-1]);\\n                i--; j--;\\n            }\\n            else if(dp[i-1][j] > dp[i][j-1])\\n            {\\n                ans += (str1[i-1]);\\n                i--;\\n            }\\n            else\\n            {\\n                ans += (str2[j-1]);\\n                j--;\\n            }\\n        }\\n        while(i>0)\\n        {\\n            ans += (str1[i-1]);\\n            i--;\\n        }\\n        while(j>0)\\n        {\\n            ans += (str2[j-1]);\\n            j--;\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        int n = str1.size() , m = str2.size();\\n        int dp[n+1][m+1];\\n        \\n        // for(int i=0;i<n+1;i++) dp[i][0] = 0;\\n        // for(int i=0;i<m+1;i++) dp[0][i] = 0;\\n        \\n        for(int i =0;i<n+1;i++)\\n        {\\n            for(int j=0;j<m+1;j++)\\n            {\\n                if(i==0 || j==0) dp[i][j] = 0 ;\\n                else\\n                {\\n                    if(str1[i-1] == str2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;\\n                    else dp[i][j] = max(dp[i-1][j] , dp[i][j-1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2242396,
                "title": "c-complete-code-with-full-explanation-scs-lcs-variation-dp",
                "content": "#### **Approach 1**\\n```\\nclass Solution {\\n    string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }\\n};\\n```\\n\\n#### **Approach 2** \\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string X, string Y) {\\n        int n = X.size(), m = Y.size();\\n        int t[n+1][m+1];\\n        //Base case initialization\\n        for(int i = 0 ; i <= n ; i++)\\n            for(int j = 0 ; j <= m; j++){\\n                if( i == 0 || j == 0)\\n                    t[i][j] = 0;\\n            }\\n        \\n        //Filling of DP table\\n        for(int i = 1 ; i <= n ; i++)\\n            for(int j = 1 ; j <= m ; j++){\\n                if(X[i-1] == Y[j-1])\\n                    t[i][j]= 1 + t[i-1][j-1];\\n                else\\n                    t[i][j] = max(t[i-1][j],t[i][j-1]);\\n            }\\n        \\n        \\n        // for(int p = 0 ; p <= n ; p++){\\n        //     for(int q = 0 ; q <= m ; q++){\\n        //         cout << t[p][q] << \" \";\\n        //     }\\n        //     cout << endl;\\n        // }\\n\\t\\t\\n        int i = n, j = m;  //Starting from the last block\\n        string s;\\n        while(i > 0 && j > 0){\\n            //Loop until i and j are not out of bound\\n            if(X[i-1] == Y[j-1]){\\n                //Concatinating LCS Part moving diagonal\\n                s += X[i - 1];\\n                i--;\\n                j--;\\n            }\\n            else\\n            {\\n                //Moving in max direction means discarding that character of the string that has not contributed in LCS.\\n               //But still inserting in the final string because it will contribute in SuperSequence.\\n                if(t[i][j-1] > t[i-1][j]){\\n                    s += Y[j - 1];\\n                    j--;\\n                }\\n                else{\\n                    s += X[i - 1];\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        //Adding left out characters\\n        while(i > 0){\\n            s.push_back(X[i-1]);\\n            i--;\\n        }\\n\\n        while(j > 0){\\n            s.push_back(Y[j-1]);\\n            j--;\\n        }\\n        \\n\\treverse(s.begin(), s.end());\\n\\treturn s; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string X, string Y) {\\n        int n = X.size(), m = Y.size();\\n        int t[n+1][m+1];\\n        //Base case initialization\\n        for(int i = 0 ; i <= n ; i++)\\n            for(int j = 0 ; j <= m; j++){\\n                if( i == 0 || j == 0)\\n                    t[i][j] = 0;\\n            }\\n        \\n        //Filling of DP table\\n        for(int i = 1 ; i <= n ; i++)\\n            for(int j = 1 ; j <= m ; j++){\\n                if(X[i-1] == Y[j-1])\\n                    t[i][j]= 1 + t[i-1][j-1];\\n                else\\n                    t[i][j] = max(t[i-1][j],t[i][j-1]);\\n            }\\n        \\n        \\n        // for(int p = 0 ; p <= n ; p++){\\n        //     for(int q = 0 ; q <= m ; q++){\\n        //         cout << t[p][q] << \" \";\\n        //     }\\n        //     cout << endl;\\n        // }\\n\\t\\t\\n        int i = n, j = m;  //Starting from the last block\\n        string s;\\n        while(i > 0 && j > 0){\\n            //Loop until i and j are not out of bound\\n            if(X[i-1] == Y[j-1]){\\n                //Concatinating LCS Part moving diagonal\\n                s += X[i - 1];\\n                i--;\\n                j--;\\n            }\\n            else\\n            {\\n                //Moving in max direction means discarding that character of the string that has not contributed in LCS.\\n               //But still inserting in the final string because it will contribute in SuperSequence.\\n                if(t[i][j-1] > t[i-1][j]){\\n                    s += Y[j - 1];\\n                    j--;\\n                }\\n                else{\\n                    s += X[i - 1];\\n                    i--;\\n                }\\n            }\\n        }\\n        \\n        //Adding left out characters\\n        while(i > 0){\\n            s.push_back(X[i-1]);\\n            i--;\\n        }\\n\\n        while(j > 0){\\n            s.push_back(Y[j-1]);\\n            j--;\\n        }\\n        \\n\\treverse(s.begin(), s.end());\\n\\treturn s; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2236849,
                "title": "shortest-common-supersequence",
                "content": "# Runtime: 35 ms, faster than 40.96% of C++ online submissions for Shortest Common Supersequence .\\n# Memory Usage: 13 MB, less than 36.39% of C++ online submissions for Shortest Common Supersequence .\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s1, string s2) {\\n        int n = s1.size();\\n  int m = s2.size();\\n\\n  vector < vector < int >> dp(n + 1, vector < int > (m + 1, 0));\\n  for (int i = 0; i <= n; i++) {\\n    dp[i][0] = 0;\\n  }\\n  for (int i = 0; i <= m; i++) {\\n    dp[0][i] = 0;\\n  }\\n\\n  for (int ind1 = 1; ind1 <= n; ind1++) {\\n    for (int ind2 = 1; ind2 <= m; ind2++) {\\n      if (s1[ind1 - 1] == s2[ind2 - 1])\\n        dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1];\\n      else\\n        dp[ind1][ind2] = 0 + max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1]);\\n    }\\n  }\\n\\n  int len = dp[n][m];\\n  int i = n;\\n  int j = m;\\n\\n  int index = len - 1;\\n  string ans = \"\";\\n\\n  while (i > 0 && j > 0) {\\n    if (s1[i - 1] == s2[j - 1]) {\\n      ans += s1[i-1];\\n      index--;\\n      i--;\\n      j--;\\n    } else if (dp[i - 1][j] > dp[i][j - 1]) {\\n        ans += s1[i-1];\\n        i--;\\n    } else {\\n        ans += s2[j-1];\\n        j--;\\n    }\\n  }\\n  \\n  //Adding Remaing Characters - Only one of the below two while loops will run \\n  \\n  while(i>0){\\n      ans += s1[i-1];\\n      i--;\\n  }\\n  while(j>0){\\n      ans += s2[j-1];\\n      j--;\\n  }\\n\\n  reverse(ans.begin(),ans.end());\\n  \\n  return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shortestCommonSupersequence(string s1, string s2) {\\n        int n = s1.size();\\n  int m = s2.size();\\n\\n  vector < vector < int >> dp(n + 1, vector < int > (m + 1, 0));\\n  for (int i = 0; i <= n; i++) {\\n    dp[i][0] = 0;\\n  }\\n  for (int i = 0; i <= m; i++) {\\n    dp[0][i] = 0;\\n  }\\n\\n  for (int ind1 = 1; ind1 <= n; ind1++) {\\n    for (int ind2 = 1; ind2 <= m; ind2++) {\\n      if (s1[ind1 - 1] == s2[ind2 - 1])\\n        dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1];\\n      else\\n        dp[ind1][ind2] = 0 + max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1]);\\n    }\\n  }\\n\\n  int len = dp[n][m];\\n  int i = n;\\n  int j = m;\\n\\n  int index = len - 1;\\n  string ans = \"\";\\n\\n  while (i > 0 && j > 0) {\\n    if (s1[i - 1] == s2[j - 1]) {\\n      ans += s1[i-1];\\n      index--;\\n      i--;\\n      j--;\\n    } else if (dp[i - 1][j] > dp[i][j - 1]) {\\n        ans += s1[i-1];\\n        i--;\\n    } else {\\n        ans += s2[j-1];\\n        j--;\\n    }\\n  }\\n  \\n  //Adding Remaing Characters - Only one of the below two while loops will run \\n  \\n  while(i>0){\\n      ans += s1[i-1];\\n      i--;\\n  }\\n  while(j>0){\\n      ans += s2[j-1];\\n      j--;\\n  }\\n\\n  reverse(ans.begin(),ans.end());\\n  \\n  return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209696,
                "title": "java-dp-tabulation",
                "content": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String word1, String word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        int[][] dp = new int[m+1][n+1];\\n        \\n\\t\\t//Tabulation\\n\\t\\t\\n        for(int i = 0; i < m; i++)\\n            dp[i][0] = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n            dp[0][i] = 0;\\n        \\n\\n        for(int i = 1; i <=m; i++){\\n            for(int j = 1; j <=n; j++){\\n                if(word1.charAt(i-1) == word2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1] + 1;\\n                else\\n                    dp[i][j] = Integer.max(dp[i][j-1], dp[i-1][j]);\\n            }\\n        }\\n        \\n        //Extract characters with the help of DP array \\n\\t\\t\\n        int i=m,j=n;\\n        String ans=\"\";\\n        while(i>0 && j>0)\\n        {\\n            if(word1.charAt(i-1)==word2.charAt(j-1))\\n            {\\n                ans+=word1.charAt(i-1);\\n                i--;\\n                j--;\\n            }\\n            \\n            else if(dp[i-1][j]>dp[i][j-1])\\n            {\\n                ans+=word1.charAt(i-1);\\n                i--;\\n            }\\n            else{\\n                ans+=word2.charAt(j-1);\\n                j--;\\n            }\\n        }\\n        \\n        while(i>0)\\n        {\\n            ans+=word1.charAt(i-1);\\n            i--;\\n        }\\n        while(j>0)\\n        {\\n            ans+=word2.charAt(j-1);\\n            j--;\\n        }\\n        \\n\\t\\t//Reverse the string formed.\\n\\t\\t\\n    StringBuilder sb=new StringBuilder(ans);  \\n    sb.reverse();  \\n    return sb.toString();  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String shortestCommonSupersequence(String word1, String word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        int[][] dp = new int[m+1][n+1];\\n        \\n\\t\\t//Tabulation\\n\\t\\t\\n        for(int i = 0; i < m; i++)\\n            dp[i][0] = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n            dp[0][i] = 0;\\n        \\n\\n        for(int i = 1; i <=m; i++){\\n            for(int j = 1; j <=n; j++){\\n                if(word1.charAt(i-1) == word2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1] + 1;\\n                else\\n                    dp[i][j] = Integer.max(dp[i][j-1], dp[i-1][j]);\\n            }\\n        }\\n        \\n        //Extract characters with the help of DP array \\n\\t\\t\\n        int i=m,j=n;\\n        String ans=\"\";\\n        while(i>0 && j>0)\\n        {\\n            if(word1.charAt(i-1)==word2.charAt(j-1))\\n            {\\n                ans+=word1.charAt(i-1);\\n                i--;\\n                j--;\\n            }\\n            \\n            else if(dp[i-1][j]>dp[i][j-1])\\n            {\\n                ans+=word1.charAt(i-1);\\n                i--;\\n            }\\n            else{\\n                ans+=word2.charAt(j-1);\\n                j--;\\n            }\\n        }\\n        \\n        while(i>0)\\n        {\\n            ans+=word1.charAt(i-1);\\n            i--;\\n        }\\n        while(j>0)\\n        {\\n            ans+=word2.charAt(j-1);\\n            j--;\\n        }\\n        \\n\\t\\t//Reverse the string formed.\\n\\t\\t\\n    StringBuilder sb=new StringBuilder(ans);  \\n    sb.reverse();  \\n    return sb.toString();  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207279,
                "title": "c-lcs-variation-dp-simple-approach",
                "content": "```\\nint dp[1001][1001];\\nclass Solution {\\npublic:\\n    int fun(int i,int j,string&str1,string&str2){\\n        if(i==0) return j;\\n        if(j==0) return i;\\n        if(dp[i][j]!=0) return dp[i][j];\\n        if(str1[i-1]==str2[j-1]) return dp[i][j]=1+fun(i-1,j-1,str1,str2);\\n        else return dp[i][j]=1+min(fun(i-1,j,str1,str2),fun(i,j-1,str1,str2));\\n    }\\n    string shortestCommonSupersequence(string str1, string str2){\\n        int n1=str1.length(),n2=str2.length();\\n        memset(dp,0,sizeof(dp));\\n        int val=fun(n1,n2,str1,str2);\\n        string ans=\"\";\\n        for(int i=0;i<val;i++) ans+=\\'#\\';\\n        int idx=val-1;\\n        while(n1>0&&n2>0){\\n            if(str1[n1-1]==str2[n2-1]){\\n                ans[idx--]=str1[n1-1];\\n                n1--;n2--;\\n                if(n1==0){\\n                    while(n2>0){\\n                        ans[idx--]=str2[n2-1];\\n                        n2--;\\n                    }\\n                }\\n                if(n2==0){\\n                    while(n1>0){\\n                        ans[idx--]=str1[n1-1];\\n                        n1--;\\n                    }   \\n                }\\n            }\\n            else{\\n                if(dp[n1][n2]==1+dp[n1][n2-1]){\\n                    ans[idx--]=str2[n2-1];\\n                    n2--;\\n                }\\n                else if(dp[n1][n2]==1+dp[n1-1][n2]){\\n                    ans[idx--]=str1[n1-1];\\n                    n1--;\\n                }\\n                else{\\n                    while(n1>0){\\n                        ans[idx--]=str1[n1-1];\\n                        n1--;\\n                    }\\n                    while(n2>0){\\n                        ans[idx--]=str2[n2-1];\\n                        n2--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint dp[1001][1001];\\nclass Solution {\\npublic:\\n    int fun(int i,int j,string&str1,string&str2){\\n        if(i==0) return j;\\n        if(j==0) return i;\\n        if(dp[i][j]!=0) return dp[i][j];\\n        if(str1[i-1]==str2[j-1]) return dp[i][j]=1+fun(i-1,j-1,str1,str2);\\n        else return dp[i][j]=1+min(fun(i-1,j,str1,str2),fun(i,j-1,str1,str2));\\n    }\\n    string shortestCommonSupersequence(string str1, string str2){\\n        int n1=str1.length(),n2=str2.length();\\n        memset(dp,0,sizeof(dp));\\n        int val=fun(n1,n2,str1,str2);\\n        string ans=\"\";\\n        for(int i=0;i<val;i++) ans+=\\'#\\';\\n        int idx=val-1;\\n        while(n1>0&&n2>0){\\n            if(str1[n1-1]==str2[n2-1]){\\n                ans[idx--]=str1[n1-1];\\n                n1--;n2--;\\n                if(n1==0){\\n                    while(n2>0){\\n                        ans[idx--]=str2[n2-1];\\n                        n2--;\\n                    }\\n                }\\n                if(n2==0){\\n                    while(n1>0){\\n                        ans[idx--]=str1[n1-1];\\n                        n1--;\\n                    }   \\n                }\\n            }\\n            else{\\n                if(dp[n1][n2]==1+dp[n1][n2-1]){\\n                    ans[idx--]=str2[n2-1];\\n                    n2--;\\n                }\\n                else if(dp[n1][n2]==1+dp[n1-1][n2]){\\n                    ans[idx--]=str1[n1-1];\\n                    n1--;\\n                }\\n                else{\\n                    while(n1>0){\\n                        ans[idx--]=str1[n1-1];\\n                        n1--;\\n                    }\\n                    while(n2>0){\\n                        ans[idx--]=str2[n2-1];\\n                        n2--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1844251,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1963448,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1805428,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1722592,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1800955,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1576201,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 2027876,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1999955,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1849897,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1793168,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1844251,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1963448,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1805428,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1722592,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1800955,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1576201,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 2027876,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1999955,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1849897,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            },
            {
                "id": 1793168,
                "content": [
                    {
                        "username": "gurnainwadhwa",
                        "content": "just lcs\\n"
                    },
                    {
                        "username": "Mohit___Kumar",
                        "content": "madarchod "
                    },
                    {
                        "username": "idkbro191",
                        "content": " The test cases are wrong. They do not adhere to this statement. \\n\"If there are multiple valid strings, return any of them.\"\\n\\nThe test case in question:\\nstr1 = \"bbabacaa\"\\nstr2 = \"cccababab\"\\nOutput = \"bbcccabacbaab\"\\nExpected = \"bbcccabacabab\"\\n\\nBoth output and expected are valid shortest common supersequence.\\n"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "yes so your output will be considered, just one of the expected outputs is shown not all"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `string findLCS(string str1,string str2)\\n    {\\n        int len1 = str1.size();\\n        int len2 = str2.size();\\n        string dp[len1+1][len2+1];\\n        \\n        for(int i=0;i<=len1;++i)\\n            for(int j=0;j<=len2;++j)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j] = \"\";\\n                else if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1]+str1[i-1];\\n                else\\n                    dp[i][j] = dp[i][j-1].size() > dp[i-1][j].size() ? dp[i][j-1]:dp[i-1][j];\\n            }\\n        return dp[len1][len2];\\n    }\\npublic:\\n    string shortestCommonSupersequence(string str1, string str2) {\\n        string ans = \"\";\\n        string lcs = findLCS(str1,str2);\\n        \\n        int p1=0,p2=0;\\n        for(char c: lcs)\\n        {\\n            while(str1[p1]!=c)  //Add all non-LCS chars from str1\\n                ans += str1[p1++];\\n            while(str2[p2]!=c)  //Add all non-LCS chars from str2\\n                ans += str2[p2++];\\n            \\n            ans += c;   //Add LCS-char and increment both ptrs\\n            ++p1;\\n            ++p2;\\n        }\\n        ans += str1.substr(p1) + str2.substr(p2);\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "braads07",
                        "content": "46 / 47 passed...getting a TLE on the last one!!\\n\\nANY SUGGESTIONS???\\n\\nclass Solution {\\npublic:\\n\\n    string solve(string ans , int i , int j , int n , int m , string s1 , string s2 , vector<vector<string>>&dp)\\n    {\\n        if(dp[i][j]!=\"-1\")\\n        return dp[i][j];\\n        \\n        if(i==n)\\n        {\\n            if(j!=m)\\n            {\\n                for(int k=j;k<m;k++)\\n                {\\n                    ans+=s2[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        if(j==m)\\n        {\\n            if(i!=n)\\n            {\\n                for(int k=i;k<n;k++)\\n                {\\n                    ans+=s1[k];\\n                }\\n\\n            }\\n            return ans;\\n        }\\n\\n        // dp ka function //\\n        \\n\\n        if(s1[i]==s2[j])\\n        {\\n            ans=s1[i]+solve(ans , i+1 , j+1 , n , m , s1 ,s2 , dp) ;\\n            return dp[i][j]=ans;\\n        }\\n        else\\n        {\\n            string ans1=s1[i] + solve(ans , i+1 , j, n , m , s1 , s2 , dp);\\n            string ans2=s2[j] + solve(ans , i , j+1 , n , m , s1 , s2 , dp);\\n            if(ans1.size()<ans2.size())\\n            {\\n                return dp[i][j]=ans1;\\n            }\\n            else\\n            return dp[i][j]=ans2;\\n        }\\n\\n    }\\n    string shortestCommonSupersequence(string str1, string str2) {\\n    \\n    int n=str1.size();\\n    int m=str2.size();\\n    int i=0;\\n    int j=0;\\n    string ans=\"\";\\n    vector<vector<string>>dp(n+1 , vector<string>(m+1 , \"-1\"));\\n    return solve(ans , i , j , n , m , str1 , str2 , dp);\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "pass it by reference "
                    },
                    {
                        "username": "user1518g",
                        "content": "copying a string takes o(n)\\n"
                    },
                    {
                        "username": "manj8327",
                        "content": "same"
                    },
                    {
                        "username": "_aka5h",
                        "content": "This problem is so good."
                    },
                    {
                        "username": "shashank_rustagi__",
                        "content": "![image](https://assets.leetcode.com/users/images/1a10390c-ba28-474a-819d-83512f3aa674_1641901887.2307892.png)\\n\\n1. We will find the longest common subsequence of both the strings x and y using the standard DP approach. Then we declare a vector of vector of string vvs dp who is going to store our LCS. \\n2. we will traverse the entire memo once and update each entry one by one, each entry will contain the LCS upto that part in a string. \\n3. We will check if both the characters in the two strings are similar in that case, we will add what is stored previously in the dp[i][j] with x[i] i.e. the character at that particular location in dp[i+1][j+1].\\n4. if they are not equal in that case we will check the size of the left cell of dp[i+1][j+1] and up cell of dp[i+1][j+1] and check who has bigger string present, we copy the bigger string in the cell and then move on.\\n5. At the end we return dp[n][m].\\n6. This will return the LCS as the return type of the function is string.\\n7. Now we look at our function SCS, that will start with empty string s.\\n8. We will traverse over lcs(x,y) with character c and check inside with a while loop and keep on adding the non similar character in x then we wil add it to s and incremenet i++, likewise we will do for string y and update the pointer and add them into the string if they do not match. \\n9. At the end the string s contains the non matching characters which are not a part of LCS \\n10. Now at the end we will keep on adding LCS character C and increment both the pointers\\n\\nAt the end return s+ remaining letters in x and remaining letters in y."
                    },
                    {
                        "username": "coolGirl_mona",
                        "content": "for last test case I am facing  \"memory limit exceeded\" even in tabular form also. in this test case only str1 and that too a empty string. how can I resolve this?"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Last testcase is the reason why memoization is not getting accepted. I hate tabulation T_T"
                    },
                    {
                        "username": "SitanshuYadav",
                        "content": "why finding lcs with memoization is giving tle...whereas finding lcs with tabulation is accepted?\nhere is my code to find lcs using memoization\n string ans;\n    string dp[1001][1001];\n    string ini=\"#\";\n    void calc(string &a,string &b,int i,int j,string s)\n    {\n        if(i==a.length()||j==b.length())\n        {\n            if(s.length()>ans.length())\n            ans=s;\n            return;\n        }\n        if(dp[i][j]==s)\n        return;\n        if(a[i]==b[j])\n        {\n            calc(a,b,i+1,j+1,s+a[i]);\n        }\n        else\n        {\n            calc(a,b,i+1,j,s);\n            calc(a,b,i,j+1,s);\n        }\n        dp[i][j]=s;\n        //cout<<dp[i][j]<<endl;\n    }"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "in your void calc() you need to return string s instead of pass it as a parameter. Since you are not passing string s as reference, i.e. you are not using &, each time the string s will be copied when function is called which takes O(n) time each time. "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "recursion stack space"
                    },
                    {
                        "username": "osman93",
                        "content": "Hello, \\n\\nI have a problem with one of the test cases. The problem is that I did not understand why the expected output is correct for this case. I cannot find the str1 as a substring in the expected output. Any help for the clarification will be appreciated. This question was put me in a mock assessment and my grade is lowered because of this case.\\n\\nThanks in advance.\\n\\nInput:\\n\\nstr1 =\\n\"bbbaaaba\"\\nstr2 =\\n\"bbababbb\"\\n\\nOutput:\\n\\n\"bbababbbaaaba\"\\n\\nExpected:\\n\\n\"bbabaaababb\""
                    },
                    {
                        "username": "osman93",
                        "content": "[@jasonwillhudson](/jasonwillhudson) Hi Jason. It turns out that the terms \\'substring\\' and \\'subsequence\\' are two different things and we have written a code to overcome for the substring case. A \\'substring\\' is directly the original string itself with no extra letters in between but in a \\'subsequence\\' the letters should appear as in the same order with the original one but there can be some additional letters on top. For example the word \\'top\\' is a subsequence of the word \\'trophy\\' but it is not a substring. I hope that also clarifies it for you, as well."
                    },
                    {
                        "username": "jasonwillhudson",
                        "content": "I am stucked at this test case too and cannot understand it"
                    }
                ]
            }
        ]
    }
]